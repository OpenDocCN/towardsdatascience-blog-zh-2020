<html>
<head>
<title>Part 7: Fast Pattern Searching with STUMPY</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第7部分:用STUMPY进行快速模式搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1?source=collection_archive---------21-----------------------#2020-09-30">https://towardsdatascience.com/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1?source=collection_archive---------21-----------------------#2020-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c80a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为已知模式寻找相似的子序列匹配</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db1fca669227e8909be4d312a560fab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLGBIovwwgcY16J3hC5WgA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://unsplash.com/@stevenwright" rel="noopener ugc nofollow" target="_blank">史蒂夫·赖特</a>提供)</p></figure><h1 id="c678" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">整体大于部分之和</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/758e3cefa067bc6457466a0ba2167890.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/0*NcHutg8DmWfCv4YB.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0638" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY是一个强大且可扩展的Python库，用于现代时间序列分析</a>，在其核心，有效地计算出一种叫做<em class="mo">矩阵轮廓</em>的东西。这个多部分系列的目标是解释什么是matrix profile，以及如何开始利用<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>完成所有现代时间序列数据挖掘任务！</p><p id="b7a2" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><em class="mo">注:这些教程最初出现在</em> <a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="mo"> STUMPY文档</em> </a> <em class="mo">中。</em></p><p id="143e" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">第1部分:<a class="ae ky" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692">矩阵轮廓图</a> <br/>第2部分:<a class="ae ky" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92"> STUMPY基础知识</a> <br/>第3部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">时间序列链</a> <br/>第4部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">语义分割</a> <br/>第5部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">用STUMPY快速近似矩阵轮廓图</a> <br/>第6部分:<a class="ae ky" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">用于流式时间序列数据的矩阵轮廓图</a> <br/>第7部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">用STUMPY快速模式搜索</a> 10: <a class="ae ky" rel="noopener" target="_blank" href="/part-10-discovering-multidimensional-time-series-motifs-45da53b594bb">发现多维时间序列模体</a> <br/>第11部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-11-user-guided-motif-search-d3d317caf9ea">用户引导的模体搜索</a> <br/>第12部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f">机器学习的矩阵轮廓</a></p><h1 id="2f3e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">超越矩阵轮廓</h1><p id="5d8f" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">在STUMPY的核心，人们可以获取任何时间序列数据，并有效地计算所谓的<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/Tutorial_The_Matrix_Profile.html" rel="noopener ugc nofollow" target="_blank">矩阵轮廓</a>，它基本上以固定的窗口大小<code class="fe mu mv mw mx b">m</code>扫描整个时间序列，并为时间序列中的每个子序列找到最接近的邻居。矩阵配置文件允许您确定数据中是否有任何保守行为(即，保守子序列/模式)，如果有，它可以告诉您它们在时间序列中的确切位置。在<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/Tutorial_STUMPY_Basics.html" rel="noopener ugc nofollow" target="_blank">之前的教程</a>中，我们演示了如何使用STUMPY轻松获得矩阵轮廓，学习了如何解释结果，以及发现有意义的主题和不一致。虽然当您不知道正在寻找什么模式或保守行为时，这种强力方法可能非常有用，但是对于足够大的数据集，执行这种彻底的成对搜索可能会变得非常昂贵。</p><p id="bac6" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">然而，如果你已经有一个特定的用户定义的模式，那么你实际上不需要计算完整的矩阵配置文件！例如，您可能已经根据历史股票市场数据确定了一个有趣的交易策略，并且您希望了解过去是否在一个或多个股票代码中观察到了该特定模式。在这种情况下，搜索一个已知的模式或“查询”实际上非常简单，可以通过使用STUMPY中出色的<code class="fe mu mv mw mx b">core.mass</code>函数快速完成。</p><p id="44c1" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在这个简短的教程中，我们将采用一个简单的感兴趣的已知模式(例如，一个查询子序列)，我们将在一个单独的独立时间序列中搜索这个模式。我们开始吧！</p><h1 id="217e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">入门指南</h1><p id="5946" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">让我们导入加载、分析和绘制数据所需的包</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="dc26" class="nc la it mx b gy nd ne l nf ng">%matplotlib inline<br/><br/>import pandas as pd<br/>import stumpy<br/>import numpy as np<br/>import numpy.testing as npt<br/>import matplotlib.pyplot as plt<br/>from matplotlib.patches import Rectangle<br/><br/>plt.rcParams["figure.figsize"] = [20, 6]  # width, height<br/>plt.rcParams['xtick.direction'] = 'out'</span></pre><h1 id="ada2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">加载索尼AIBO机器狗数据集</h1><p id="e2aa" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">时间序列数据(下图)，<code class="fe mu mv mw mx b">T_df</code>，有<code class="fe mu mv mw mx b">n = 13000</code>个数据点，它是从<a class="ae ky" href="https://en.wikipedia.org/wiki/AIBO" rel="noopener ugc nofollow" target="_blank">索尼爱宝机器狗</a>内部的加速度计收集的，当机器狗从水泥地面走到铺有地毯的地面，最后回到水泥地面时，它跟踪机器狗:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="0522" class="nc la it mx b gy nd ne l nf ng">T_df = pd.read_csv("https://zenodo.org/record/4276393/files/Fast_Pattern_Searching_robot_dog.csv?download=1")<br/>T_df.head()</span><span id="694b" class="nc la it mx b gy nh ne l nf ng">   Acceleration<br/>0  0.89969<br/>1  0.89969<br/>2  0.89969<br/>3  0.89969<br/>4  0.89969</span></pre><h1 id="1a44" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">可视化索尼AIBO机器狗数据集</h1><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="004b" class="nc la it mx b gy nd ne l nf ng">plt.suptitle('Sony AIBO Robot Dog Dataset, T_df', fontsize='30')<br/>plt.xlabel('Time', fontsize ='20')<br/>plt.ylabel('Acceleration', fontsize='20')<br/>plt.plot(T_df)<br/>plt.text(2000, 4.5, 'Cement', color="black", fontsize=20)<br/>plt.text(10000, 4.5, 'Cement', color="black", fontsize=20)<br/>ax = plt.gca()<br/>rect = Rectangle((5000, -4), 3000, 10, facecolor='lightgrey')<br/>ax.add_patch(rect)<br/>plt.text(6000, 4.5, 'Carpet', color="black", fontsize=20)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/88d1cfdd835c33dae3d104250afb1405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oWisAwLBxl4oT-fj.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="f979" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在上面的图中，机器狗在水泥地上行走的时间用白色背景显示，而机器狗在地毯上行走的时间用灰色背景突出显示。你注意到在不同的路面上行走有什么明显的不同吗？有什么有趣的见解可以用人眼观察到？在这个时间序列中是否存在任何保守的模式，如果存在，它们在哪里？</p><h1 id="37eb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">你见过这个图案吗？</h1><p id="9329" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">我们有兴趣在时间序列(上图)中搜索的子序列模式或查询(下图)如下所示:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="008e" class="nc la it mx b gy nd ne l nf ng">Q_df = pd.read_csv("https://zenodo.org/record/4276880/files/carpet_query.csv?download=1")</span><span id="af07" class="nc la it mx b gy nh ne l nf ng">plt.suptitle('Pattern or Query Subsequence, Q_df', fontsize='30')<br/>plt.xlabel('Time', fontsize ='20')<br/>plt.ylabel('Acceleration', fontsize='20')<br/>plt.plot(Q_df, lw=2, color="C1")  # Walking on cement<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/14d7376b1d621f3507fa29af9f80d745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E-BK0CN8D7yzCG5f.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b971" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">这个图案<code class="fe mu mv mw mx b">Q_df</code>的窗口长度为<code class="fe mu mv mw mx b">m = 100</code>，它取自一个完全独立的行走样本。是不是一点都不眼熟？类似的模式是否存在于我们更早的时间序列中，<code class="fe mu mv mw mx b">T_df</code>？您能说出收集这个查询样本时机器狗正在哪个表面上行走吗？</p><p id="0452" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">要回答其中的一些问题，您可以通过计算一种称为“距离剖面”的东西，将这个特定的查询子序列或模式与完整的时间序列进行比较。本质上，您获取这个查询，<code class="fe mu mv mw mx b">Q_df</code>，并通过计算所有可能的(z-归一化欧几里得)成对距离，将其与<code class="fe mu mv mw mx b">T_df</code>中的每个子序列进行比较。因此，距离轮廓只是一个一维向量，它告诉你<code class="fe mu mv mw mx b">Q_df</code>与<code class="fe mu mv mw mx b">T_df</code>中的每个子序列(长度相同)有多相似/不相似。现在，计算距离轮廓的简单算法需要花费<code class="fe mu mv mw mx b">O(n*m)</code>时间来处理，但幸运的是，我们可以做得比这好得多，因为存在一种称为<a class="ae ky" href="https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html" rel="noopener ugc nofollow" target="_blank">“Mueen的相似性搜索算法”</a> (MASS)的超级有效的方法，它能够以快得多的<code class="fe mu mv mw mx b">O(n*log(n))</code>时间(<code class="fe mu mv mw mx b">log</code>基数2)来计算距离轮廓。现在，如果您只有几个短时间序列要分析，这可能不是什么大问题，但是如果您需要用不同的查询子序列多次重复这个过程，那么事情会很快增加。事实上，随着时间序列的长度<code class="fe mu mv mw mx b">n</code>和/或查询子序列的长度<code class="fe mu mv mw mx b">m</code>变得越来越长，朴素算法将花费太多时间！</p><h1 id="7e2b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用质量计算距离剖面</h1><p id="d9ee" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">因此，给定一个查询子序列<code class="fe mu mv mw mx b">Q_df</code>和一个时间序列<code class="fe mu mv mw mx b">T_df</code>，我们可以执行一个快速相似性搜索，并使用STUMPY中的<code class="fe mu mv mw mx b">core.mass</code>函数计算距离分布图:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="cb6e" class="nc la it mx b gy nd ne l nf ng">distance_profile = stumpy.core.mass(Q_df["Acceleration"], T_df["Acceleration"])</span></pre><p id="4a8e" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">并且，由于<code class="fe mu mv mw mx b">distance_profile</code>包含了<code class="fe mu mv mw mx b">Q_df</code>和<code class="fe mu mv mw mx b">T_df</code>内每个子序列之间的成对距离的完整列表，我们可以通过找到<code class="fe mu mv mw mx b">distance_profile</code>中的最小距离值并提取其位置索引来从<code class="fe mu mv mw mx b">T_df</code>中检索最相似的子序列:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="9312" class="nc la it mx b gy nd ne l nf ng">idx = np.argmin(distance_profile)</span><span id="d67f" class="nc la it mx b gy nh ne l nf ng">print(f"The nearest neighbor to `Q_df` is located at index {idx} in `T_df`")z</span><span id="a147" class="nc la it mx b gy nh ne l nf ng">The nearest neighbor to `Q_df` is located at index 7479 in `T_df`</span></pre><p id="531c" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">所以，为了回答我们之前的问题“在我们之前的时间序列中是否存在类似的模式，T_df？”，让我们继续在<code class="fe mu mv mw mx b">T_df</code>中绘制最相似的子序列，它位于索引7479(蓝色)，并用我们的查询模式<code class="fe mu mv mw mx b">Q_df</code>(橙色)覆盖它:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="9b47" class="nc la it mx b gy nd ne l nf ng"># Since MASS computes z-normalized Euclidean distances, we should z-normalize our subsequences before plotting<br/>Q_z_norm = stumpy.core.z_norm(Q_df.values)<br/>T_z_norm = stumpy.core.z_norm(T_df.values[idx:idx+len(Q_df)])</span><span id="e819" class="nc la it mx b gy nh ne l nf ng">plt.suptitle('Comparing The Query (Orange) And Its Nearest Neighbor (Blue)', fontsize='30')<br/>plt.xlabel('Time', fontsize ='20')<br/>plt.ylabel('Acceleration', fontsize='20')<br/>plt.plot(Q_z_norm, lw=2, color="C1")<br/>plt.plot(T_z_norm, lw=2)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d36e0e820ca889e1b88f9f6435247b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qd_S6WdNCbqqa-EN.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="9e47" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">注意，即使查询子序列不完全匹配它的最近邻，STUMPY仍然能够找到它！然后，为了回答第二个问题“你能说出当这个查询样本被收集时机器狗正在哪个表面上行走吗？”，我们可以精确地看到<code class="fe mu mv mw mx b">idx</code>在<code class="fe mu mv mw mx b">T_df</code>中的位置:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="b880" class="nc la it mx b gy nd ne l nf ng">plt.suptitle('Sony AIBO Robot Dog Dataset, T_df', fontsize='30')<br/>plt.xlabel('Time', fontsize ='20')<br/>plt.ylabel('Acceleration', fontsize='20')<br/>plt.plot(T_df)<br/>plt.text(2000, 4.5, 'Cement', color="black", fontsize=20)<br/>plt.text(10000, 4.5, 'Cement', color="black", fontsize=20)<br/>ax = plt.gca()<br/>rect = Rectangle((5000, -4), 3000, 10, facecolor='lightgrey')<br/>ax.add_patch(rect)<br/>plt.text(6000, 4.5, 'Carpet', color="black", fontsize=20)<br/>plt.plot(range(idx, idx+len(Q_df)), T_df.values[idx:idx+len(Q_df)], lw=2)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/0371b6342105fce828ee275051c29f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dMkzqhZGKNEzgt8K.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="2d00" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">正如我们在上面看到的，与<code class="fe mu mv mw mx b">Q_df</code>最近的邻居(橙色)是机器狗在地毯上行走时发现的子序列，事实证明，<code class="fe mu mv mw mx b">Q_df</code>是从机器狗也在地毯上行走的独立样本中收集的！为了更进一步，我们可以查看顶部<code class="fe mu mv mw mx b">k = 16</code>最近邻居的位置，而不是提取唯一的顶部最近邻居:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="67b6" class="nc la it mx b gy nd ne l nf ng"># This simply returns the (sorted) positional indices of the top 16 smallest distances found in the distance_profile<br/>k = 16<br/>idxs = np.argpartition(distance_profile, k)[:k]<br/>idxs = idxs[np.argsort(distance_profile[idxs])]</span></pre><p id="00e4" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">然后让我们根据它们的索引位置来绘制所有这些子序列:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5d91" class="nc la it mx b gy nd ne l nf ng">plt.suptitle('Sony AIBO Robot Dog Dataset, T_df', fontsize='30')<br/>plt.xlabel('Time', fontsize ='20')<br/>plt.ylabel('Acceleration', fontsize='20')<br/>plt.plot(T_df)<br/>plt.text(2000, 4.5, 'Cement', color="black", fontsize=20)<br/>plt.text(10000, 4.5, 'Cement', color="black", fontsize=20)<br/>ax = plt.gca()<br/>rect = Rectangle((5000, -4), 3000, 10, facecolor='lightgrey')<br/>ax.add_patch(rect)<br/>plt.text(6000, 4.5, 'Carpet', color="black", fontsize=20)</span><span id="02ec" class="nc la it mx b gy nh ne l nf ng">for idx in idxs:<br/>    plt.plot(range(idx, idx+len(Q_df)), T_df.values[idx:idx+len(Q_df)], lw=2)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/814063a18eeec5894ebe7bf9abdb7377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_KX8kMlYsa39krnW.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="fd57" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">不出所料，当机器狗在地毯(灰色)上行走时，可以找到与<code class="fe mu mv mw mx b">Q_df</code>最近的前<code class="fe mu mv mw mx b">k = 16</code>(或最佳匹配，如上多种颜色所示)！</p><h1 id="be4f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="ef29" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">就是这样！您现在已经获得了一个感兴趣的已知模式(或查询)，使用STUMPY在<code class="fe mu mv mw mx b">core.mass</code>中运行它，并且您能够在另一个时间序列中快速搜索这个模式。有了这些新发现的知识，你现在可以在你自己的时间序列项目中寻找模式。编码快乐！</p><h1 id="321d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">附加注释-具有非归一化欧几里得距离的距离剖面</h1><p id="49b5" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">有时，您可能希望使用非归一化的欧几里德距离作为相似性/不相似性的度量，因此，您可以使用<code class="fe mu mv mw mx b">core.mass_absolute</code>函数，而不是使用<code class="fe mu mv mw mx b">core.mass</code>(在计算成对欧几里德距离之前，首先对您的子序列进行z归一化)。这是为那些对计算互补的<code class="fe mu mv mw mx b">stumpy.aamp</code>、<code class="fe mu mv mw mx b">stumpy.aamped</code>、<code class="fe mu mv mw mx b">stumpy.gpu_aamp</code>和<code class="fe mu mv mw mx b">stumpy.ammpi</code>函数中可用的非归一化矩阵轮廓感兴趣的人提供的。</p><h1 id="cd1b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">奖金部分——是什么让质量如此之快？</h1><p id="2e18" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">MASS比简单方法快得多的原因是因为MASS使用快速傅立叶变换(FFT)将数据转换到频域，并执行所谓的“卷积”，这将<code class="fe mu mv mw mx b">m</code>操作减少到<code class="fe mu mv mw mx b">log(n)</code>操作。你可以在最初的<a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/PID4481997_extend_Matrix%20Profile_I.pdf" rel="noopener ugc nofollow" target="_blank"> Matrix Profile I论文</a>中了解更多信息。</p><p id="3986" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">下面是计算距离剖面的一个简单实现:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f1be" class="nc la it mx b gy nd ne l nf ng">def compute_naive_distance_profile(Q, T):<br/>    Q = Q.copy()<br/>    T = T.copy()<br/>    n = len(T)<br/>    m = len(Q)<br/>    naive_distance_profile = np.empty(n - m + 1)</span><span id="cf44" class="nc la it mx b gy nh ne l nf ng">    start = time.time()<br/>    Q = stumpy.core.z_norm(Q)<br/>    for i in range(n - m + 1):<br/>        naive_distance_profile[i] = np.linalg.norm(Q - stumpy.core.z_norm(T[i:i+m]))<br/>    naive_elapsed_time = time.time()-start</span><span id="8ad5" class="nc la it mx b gy nh ne l nf ng">    print(f"For n = {n} and m = {m}, the naive algorithm takes {np.round(naive_elapsed_time, 2)}s to compute the distance profile")</span><span id="bedd" class="nc la it mx b gy nh ne l nf ng">    return naive_distance_profile</span></pre><p id="fb2c" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">对于随机时间序列<code class="fe mu mv mw mx b">T_random</code>，有一百万个数据点和一个随机查询子序列<code class="fe mu mv mw mx b">Q_random</code>:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a5f4" class="nc la it mx b gy nd ne l nf ng">Q_random = np.random.rand(100)<br/>T_random = np.random.rand(1_000_000)</span><span id="e5c1" class="nc la it mx b gy nh ne l nf ng">naive_distance_profile = compute_naive_distance_profile(Q_random, T_random)</span><span id="8883" class="nc la it mx b gy nh ne l nf ng">For n = 1000000 and m = 100, the naive algorithm takes 44.1s to compute the distance profile</span></pre><p id="87a3" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">朴素算法需要半分多钟来计算！然而，MASS可以在大约1秒钟内处理这个(甚至更大的数据集):</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="3728" class="nc la it mx b gy nd ne l nf ng">start = time.time()<br/>mass_distance_profile = stumpy.core.mass(Q_random, T_random)<br/>mass_elapsed_time = time.time()-start</span><span id="f770" class="nc la it mx b gy nh ne l nf ng">print(f"For n = {len(T_random)} and m = {len(Q_random)}, the MASS algorithm takes {np.round(mass_elapsed_time, 2)}s to compute the distance profile")</span><span id="5c78" class="nc la it mx b gy nh ne l nf ng">For n = 1000000 and m = 100, the MASS algorithm takes 1.13s to compute the distance profile</span></pre><p id="c133" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">为了绝对确定，让我们确保并检查两种方法的输出是否相同:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="bce3" class="nc la it mx b gy nd ne l nf ng">npt.assert_almost_equal(naive_distance_profile, mass_distance_profile)</span></pre><p id="b400" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">成功，没有错误！这意味着两个输出是相同的。来吧，试一试！</p><h1 id="1d1a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">资源</h1><p id="be79" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><a class="ae ky" href="http://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html" rel="noopener ugc nofollow" target="_blank">欧氏距离下时间序列子序列的最快相似性搜索算法</a> <br/> <a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY矩阵概要文档</a> <br/> <a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY矩阵概要Github代码库</a></p><h2 id="d0b4" class="nc la it bd lb nk nl dn lf nm nn dp lj mb no np ll mf nq nr ln mj ns nt lp nu bi translated">← <a class="ae ky" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">第6部分:流式时间序列数据的矩阵剖面图</a> | <a class="ae ky" rel="noopener" target="_blank" href="/part-8-ab-joins-with-stumpy-af985e12e391">第8部分:AB-Joins with STUMPY </a> →</h2></div></div>    
</body>
</html>