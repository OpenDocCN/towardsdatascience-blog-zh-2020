<html>
<head>
<title>Neural Network Calibration using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PyTorch校准神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neural-network-calibration-using-pytorch-c44b7221a61?source=collection_archive---------2-----------------------#2020-09-24">https://towardsdatascience.com/neural-network-calibration-using-pytorch-c44b7221a61?source=collection_archive---------2-----------------------#2020-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="524a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用几行代码就能让你的模型适用于安全关键的应用。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/3c797411c0d68641465536d298d87966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RtX9tLD2_hmPMvz_b8rPvA.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com/s/photos/fall?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kz" href="https://unsplash.com/@gregshield?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Greg Shield </a>拍照</p></figure><p id="ae1d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi lw translated">我想你是在这家新的高科技医院工作的放射科医生。上周，你得到了第一个基于神经网络的模型，它可以帮助你根据病人的数据进行诊断，并最终提高诊断的准确性。但是等等！就像我们人类一样，合成模型的预测永远不会100%准确。但是，我们如何知道一个模型是绝对确定的，还是仅仅超出了猜测的范围呢？这些知识对于正确的解释和选择合适的治疗方法是至关重要的。</p><p id="5a79" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设你更像是一名工程师:这种情况也与自动驾驶高度相关，在自动驾驶中，汽车必须不断做出决定，判断前方是否有障碍。忽略不确定性会很快变得很糟糕。</p><p id="9be1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你像90%的深度学习社区(包括过去的我)一样，你只是假设由Softmax函数<br/>产生的预测代表概率，因为它们被整齐地挤压到域[0，1]中。这是一个常见的陷阱，因为这些预测通常过于自信。正如我们将很快看到的，这种行为受到各种架构选择的影响，如批量规范化的使用或层数。</p><p id="f77e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可以在这里找到一个交互式Google Colab笔记本，上面有所有代码<a class="ae kz" href="https://colab.research.google.com/drive/1H_XlTbNvjxlAXMW5NuBDWhxF3F2Osg1F?usp=sharing" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="1fe9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">可靠性图</h1><p id="3dbd" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj mz ll lm ln na lp lq lr nb lt lu lv im bi translated">正如我们现在所知道的，希望输出<strong class="lc iu">校准的置信度</strong>而不是它们的原始对应物。为了直观地了解特定架构在这方面的表现，经常使用<strong class="lc iu">可靠性图表</strong>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f9fc28c01b20c924f09274096d55b868.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*eSWDHgjQwU70fkmmnjzeKg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">在CIFAR10上训练了10个时期的ResNet101的可靠性图(图片由作者提供)</p></figure><p id="fe45" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">用一句话来概括，可靠性图显示了预测的置信度得分与其实际准确性的对比情况。因此，给定100个预测，每个预测的置信度为0.9，如果模型完全校准，我们预计其中90%是正确的。</p><p id="e714" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了完全理解正在发生的事情，我们需要更深入一点。从图中可以看出，测试集的所有置信度得分都被分入<em class="nd"> M=10 </em>个不同的仓[0，0.1]，[0.1，0.2]，…，[0.9，1]。对于每个箱，我们可以计算它的<strong class="lc iu">精度</strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/39ccc120f0c10d971ab8ebd611d8fe10.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*1sP2stJckY-ZLpwKMlWErQ.png"/></div></figure><p id="caa1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">和<strong class="lc iu">信心</strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/95289b86e3829e92d75ee2ae8a6ed854.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*bKG4G-4LDCqORfOTkIUhxw.png"/></div></figure><p id="6156" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然后，这两个值都显示为一个条形图，其中同一条线表示完美校准。</p><h1 id="9943" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">韵律学</h1><p id="5677" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj mz ll lm ln na lp lq lr nb lt lu lv im bi translated">图表和情节只是故事的一面。为了根据模型的<strong class="lc iu">校准误差</strong>对模型进行评分，我们需要定义指标。幸运的是，这里最常用的两个指标都非常直观。</p><p id="661f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">预期校准误差(ECE) </strong>只是对绝对精度/置信度差异进行加权平均。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3bd4e7a4c1d820b58c9ac455f7c482d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*2xj0osMMcL_01xBFh4zQtQ.png"/></div></figure><p id="a9b2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于如上所述的安全关键应用，测量精确度和置信度之间的最大差异可能是有用的。这可以通过使用<strong class="lc iu">最大校准误差(MCE) </strong>来完成。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8bc3ceaf9d6ea5fd517b8f11275fc2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*b1sViyqN8GE02FM-RhfX6A.png"/></div></figure><h1 id="7882" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">温度标度</h1><p id="4b1e" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj mz ll lm ln na lp lq lr nb lt lu lv im bi translated">我们现在想关注如何解决这个问题。虽然存在许多解决方案，如<a class="ae kz" href="https://cseweb.ucsd.edu/~elkan/calibrated.pdf" rel="noopener ugc nofollow" target="_blank">直方图宁滨、</a> <a class="ae kz" href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.13.7457&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">保序回归</a>、<a class="ae kz" href="https://people.cs.pitt.edu/~milos/research/AAAI_Calibration.pdf" rel="noopener ugc nofollow" target="_blank">贝叶斯宁滨分位数(BBQ) </a>和<a class="ae kz" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.1639" rel="noopener ugc nofollow" target="_blank">普拉特缩放</a>(以及它们对多类问题的相应扩展)，但我们希望将重点放在<strong class="lc iu">温度缩放</strong>。这是因为它是最容易实现的，同时给出了上述其他算法中的最佳结果。</p><p id="2f5a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了充分理解它，我们需要后退一步，看看神经网络的输出。假设一个多类问题，网络的最后一层输出逻辑<strong class="lc iu"> z </strong> ᵢ ∈ ℝ.然后可以使用Softmax函数σ获得预测的概率。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/caa676b8f591ce2abe0b53b2e954eabe.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*6pQKgUuA5keEq_ecKDBqNA.png"/></div></figure><p id="1db6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">温度缩放直接作用于逻辑<strong class="lc iu"> z </strong> ᵢ <strong class="lc iu">(而不是预测的概率！！</strong>)并使用单一参数<em class="nd"> T &gt; 0 </em>对所有类别进行缩放。校准后的置信度可以通过下式获得</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/42b1b053f2697bb499be4532e8bbbe62.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*TRs8qH3K0BLLbd8TVCrBVQ.png"/></div></figure><p id="b2b9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">值得注意的是，参数<em class="nd"> T </em>是根据<strong class="lc iu">验证集</strong>的负对数似然(NLL)损失进行优化的，网络参数在此阶段是固定的。</p><h1 id="cdab" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结果</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/12cdbf0e4a9d6c7afe58791eaaab2440.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*O0YIE3vnHMaCV-8aZrO-og.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">ResNet101在CIFAR10上训练10个时期并使用温度标度校准的可靠性图(图片由作者提供)</p></figure><p id="0c0f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如我们从图中看到的，这些条现在更接近身份线，表明几乎完美的校准。我们也可以从指标中看到这一点。经济效率从2.10%下降到0.25%，经济效率从27.27%下降到3.86%，这是一个巨大的进步。</p><h1 id="ce9b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">PyTorch中的实现</h1><p id="aa81" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj mz ll lm ln na lp lq lr nb lt lu lv im bi translated">正如承诺的那样，PyTorch中的实现相当简单。</p><p id="3f45" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，我们定义在给定特定温度<strong class="lc iu"> T </strong>和<strong class="lc iu">逻辑</strong>的情况下返回校准置信度的<em class="nd"> T_scaling </em>方法。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e0e6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在下一步中，必须使用<a class="ae kz" href="https://en.wikipedia.org/wiki/Limited-memory_BFGS" rel="noopener ugc nofollow" target="_blank"> LBGFS </a>算法来估计参数T。这在GPU上应该只需要几秒钟。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">代码有点类似于gpleiss的<a class="ae kz" href="https://github.com/gpleiss/temperature_scaling" rel="noopener ugc nofollow" target="_blank">库</a>。</p></figure><p id="b1cf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">欢迎你在我这里<a class="ae kz" href="https://colab.research.google.com/drive/1H_XlTbNvjxlAXMW5NuBDWhxF3F2Osg1F?usp=sharing" rel="noopener ugc nofollow" target="_blank">创建的Google Colab笔记本里玩一玩</a>。</p><h1 id="49b9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="a1d2" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj mz ll lm ln na lp lq lr nb lt lu lv im bi translated">如本文所示，只需几行代码就可以完成网络校准，并有很大的改进。如果有足够的兴趣，我很乐意在另一篇Medium文章中讨论模型校准的其他方法。如果你有兴趣深入研究这个话题，我强烈推荐郭等人的论文“<a class="ae kz" href="https://arxiv.org/pdf/1706.04599.pdf" rel="noopener ugc nofollow" target="_blank">关于神经网络的校准</a>..</p><p id="e50a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">干杯！</p></div></div>    
</body>
</html>