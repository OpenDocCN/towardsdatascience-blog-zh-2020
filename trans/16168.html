<html>
<head>
<title>Classifying Images of Alcoholic Beverages with fast.ai v2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用fast.ai v2对酒精饮料图像进行分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/classifying-images-of-alcoholic-beverages-with-fast-ai-34c4560b5543?source=collection_archive---------16-----------------------#2020-11-07">https://towardsdatascience.com/classifying-images-of-alcoholic-beverages-with-fast-ai-34c4560b5543?source=collection_archive---------16-----------------------#2020-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d274" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="a4fe" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated"><span class="l kr ks kt bm ku kv kw kx ky di"> U </span> sing fast.ai v2和Google Colab提供令人陶醉的数据和dram混合服务</h2></div><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/851154c2301a5825e86856609d924249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-vcRd6gfi6osKXaz4mFew.jpeg"/></div></div><p class="ll lm gj gh gi ln lo bd b be z dk translated">照片由<a class="ae lp" href="https://unsplash.com/@quinguyen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Q.U.I </a>在<a class="ae lp" href="https://unsplash.com/s/photos/alcohol?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="2c5a" class="lq lr it bd ls lt lu lv lw lx ly lz ma ki mb kj mc kl md km me ko mf kp mg mh bi translated">动机</h1><p id="68d3" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">我已经开始沉浸在更新的fast.ai v2深度学习课程中，我觉得应用和记录我迄今为止所学的东西将是理想的。在这篇文章中，我将分享我如何训练深度学习(CNN)分类器来区分不同类型的流行酒精饮料。</p><p id="e82a" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">本演练的一个重要亮点是，它详细介绍了有关如何利用更新的Microsoft Azure Bing Search V7 API的最新说明，因为关键更改已于2020年10月30日实现。</p><h1 id="7f32" class="lq lr it bd ls lt lu lv lw lx ly lz ma ki mb kj mc kl md km me ko mf kp mg mh bi translated">链接</h1><ul class=""><li id="8d89" class="nj nk it mk b ml mm mo mp mr nl mv nm mz nn nd no np nq nr bi translated"><a class="ae lp" href="https://github.com/kennethleungty/Alcohol-Image-Classifier-fastai" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li><li id="1823" class="nj nk it mk b ml ns mo nt mr nu mv nv mz nw nd no np nq nr bi translated"><a class="ae lp" href="https://github.com/kennethleungty/Alcohol-Image-Classifier-fastai/blob/main/Alcohol_Image_Classifier_Full_Version.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本(完整版)</a></li><li id="2301" class="nj nk it mk b ml ns mo nt mr nu mv nv mz nw nd no np nq nr bi translated"><a class="ae lp" href="https://github.com/kennethleungty/Alcohol-Image-Classifier-fastai/blob/main/Alcohol_Image_Classifier_Clean_Version.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本(干净版)</a></li></ul><h1 id="6a6e" class="lq lr it bd ls lt lu lv lw lx ly lz ma ki mb kj mc kl md km me ko mf kp mg mh bi translated">内容</h1><blockquote class="nx ny nz"><p id="8470" class="mi mj oa mk b ml ne kd mn mo nf kg mq ob ng mt mu oc nh mx my od ni nb nc nd im bi translated"><em class="it">第1节—设置</em></p><p id="4f85" class="mi mj oa mk b ml ne kd mn mo nf kg mq ob ng mt mu oc nh mx my od ni nb nc nd im bi translated"><em class="it">第2部分—下载图像数据</em></p><p id="0ad8" class="mi mj oa mk b ml ne kd mn mo nf kg mq ob ng mt mu oc nh mx my od ni nb nc nd im bi translated"><em class="it">第3节—准备图像数据集</em></p><p id="926a" class="mi mj oa mk b ml ne kd mn mo nf kg mq ob ng mt mu oc nh mx my od ni nb nc nd im bi translated"><em class="it">第4部分——训练模型</em></p><p id="1513" class="mi mj oa mk b ml ne kd mn mo nf kg mq ob ng mt mu oc nh mx my od ni nb nc nd im bi translated"><em class="it">第5节—清理数据</em></p><p id="f5ae" class="mi mj oa mk b ml ne kd mn mo nf kg mq ob ng mt mu oc nh mx my od ni nb nc nd im bi translated"><em class="it">第6节—使用图像分类器进行推理</em></p><p id="2781" class="mi mj oa mk b ml ne kd mn mo nf kg mq ob ng mt mu oc nh mx my od ni nb nc nd im bi translated"><em class="it">第7部分—部署为Web应用</em></p></blockquote></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="d5d5" class="lq lr it bd ls lt ol lv lw lx om lz ma ki on kj mc kl oo km me ko op kp mg mh bi translated">第1部分—设置</h1><p id="1f9d" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">首先，我强烈推荐在Google Colab上运行这款笔记本。要了解更多关于Google Colab设置的信息，请访问此<a class="ae lp" href="https://course.fast.ai/start_colab" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="5d0d" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">一旦这台笔记本在Google Colab上打开，<strong class="mk jd">打开笔记本的GPU加速器，方法是前往顶部菜单，单击</strong><code class="fe oq or os ot b"><strong class="mk jd">Runtime</strong></code><strong class="mk jd">&gt;</strong><code class="fe oq or os ot b"><strong class="mk jd">Change runtime type</strong></code><strong class="mk jd">&gt;，选择</strong> <code class="fe oq or os ot b"><strong class="mk jd">GPU</strong></code> <strong class="mk jd">作为硬件加速器。</strong></p><p id="c992" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">接下来，在Google Colab运行时上安装Google Drive。将出现一个链接，供您点击并检索您的授权码。授予Google Drive文件流的权限后，复制提供的代码，将其粘贴到“输入您的授权码”下的字段中，然后按Enter键。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="d29c" class="oy lr it ot b gy oz pa l pb pc">from google.colab import drive<br/>drive.mount('/content/drive/')</span></pre><p id="cbe1" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">下一步是安装fast.ai依赖项。我发现这种依赖版本的组合在Google Colab上工作得很顺利。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="438d" class="oy lr it ot b gy oz pa l pb pc">!pip install fastai==2.0.19<br/>!pip install fastai2==0.0.30<br/>!pip install fastcore==1.3.1<br/>!pip install -Uqq fastbook</span><span id="4267" class="oy lr it ot b gy pd pa l pb pc">import fastbook<br/>from fastbook import *<br/>fastbook.setup_book()<br/>from fastai.vision.widgets import *<br/><br/>import warnings<br/>warnings.filterwarnings("ignore")<br/><br/>import requests<br/>import matplotlib.pyplot as plt<br/>import PIL.Image<br/>from io import BytesIO<br/>import os<br/><br/>from IPython.display import Image<br/>from IPython.core.display import HTML</span></pre><p id="ad8f" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">然后，我们创建一个路径来存储将要下载的图像。注意，结果目录路径将是<code class="fe oq or os ot b">/content/images</code>。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="f495" class="oy lr it ot b gy oz pa l pb pc">try:<br/>  os.mkdir('images')<br/>except:<br/>  pass</span></pre><p id="4208" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">之后，我们需要检索Azure Bing Search V7的API密钥，因为我们将使用它从Bing中提取图像数据集。要了解更多关于在微软Azure门户中设置Bing搜索API密钥的信息，请查看我的GitHub repo中的<a class="ae lp" href="https://github.com/kennethleungty/Alcohol-Image-Classifier-fastai/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>，以及微软Azure Bing搜索API <a class="ae lp" href="https://docs.microsoft.com/en-us/bing/search-apis/bing-image-search/quickstarts/rest/python" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="770b" class="oy lr it ot b gy oz pa l pb pc">subscription_key = "XXX" #Replace XXX with your own API key<br/>search_url = "https://api.bing.microsoft.com/v7.0/images/search"<br/>headers = {"Ocp-Apim-Subscription-Key" : subscription_key}</span></pre><p id="e79e" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">一旦关键字被输入到<code class="fe oq or os ot b">subscription_key</code>变量中，我们就可以检索一组与您选择的关键字相关的图像URL。例如，为了找到<code class="fe oq or os ot b">whisky</code>的一组图像，我们运行以下代码:</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="02dd" class="oy lr it ot b gy oz pa l pb pc">search_term = "whisky"</span><span id="bf94" class="oy lr it ot b gy pd pa l pb pc">#Add in count parameter so that max number of images (150) is  #retrieved upon each API call. Otherwise, default is 35.</span><span id="f8ee" class="oy lr it ot b gy pd pa l pb pc">params  = {"q": search_term, "license": "public", "imageType": "photo", "count":"150"}</span><span id="f910" class="oy lr it ot b gy pd pa l pb pc">response = requests.get(search_url, headers=headers, params=params)<br/>response.raise_for_status()</span><span id="cb2f" class="oy lr it ot b gy pd pa l pb pc"># Return json file<br/>search_results = response.json()</span><span id="9204" class="oy lr it ot b gy pd pa l pb pc"># Create a set of thumbnails for visualization<br/>thumbnail_urls = [img["thumbnailUrl"] for img in search_results["value"][:16]]</span></pre><p id="d798" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们可以创建一个4 x 4的缩略图网格图来可视化检索到的图像，允许我们验证这些图像确实代表了我们的关键字<code class="fe oq or os ot b">whisky</code>。从展示的内容来看，我觉得这的确很像上好的老威士忌。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="fe95" class="oy lr it ot b gy oz pa l pb pc">f, axes = plt.subplots(4, 4)<br/>for i in range(4):<br/>    for j in range(4):<br/>        image_data = requests.get(thumbnail_urls[i+4*j])<br/>        image_data.raise_for_status()<br/>        image = Image.open(BytesIO(image_data.content))        <br/>        axes[i][j].imshow(image)<br/>        axes[i][j].axis("off")<br/>plt.show()</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/375ef87552315eb3bbe118e9d5cc2e75.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Wi2P2mG5l3xzWK6-uPK4OA.png"/></div></figure><p id="0c55" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">下一步是整理来自搜索结果JSON文件的图像URL列表。与图像URL相关联的关键字是<code class="fe oq or os ot b">contentUrl</code>。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="37c1" class="oy lr it ot b gy oz pa l pb pc">img_urls = [img['contentUrl'] for img in search_results["value"]]<br/>len(img_urls)</span></pre><p id="27da" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated"><code class="fe oq or os ot b">len</code>函数应该会返回一个与关键字<code class="fe oq or os ot b">whisky</code>相关的150个图片URL的列表。然后，我们从URL下载并显示一张图片到我们的<code class="fe oq or os ot b">images</code>文件夹中名为<code class="fe oq or os ot b">whisky_test.jpg</code>的<strong class="mk jd">dest</strong>ining文件中。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="749a" class="oy lr it ot b gy oz pa l pb pc">dest = 'images/whisky_test.jpg'<br/>download_url(img_urls[1], dest)</span><span id="1a59" class="oy lr it ot b gy pd pa l pb pc">img = Image.open(dest)<br/>img.to_thumb(224,224)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/a3641e1893b92a61cfa55e527385d41d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*usdVD9GnB4GRNcTHGwkRSw.png"/></div></figure><p id="bbdd" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们得到了上面的威士忌图片，显示上面的代码块完美地工作。我们现在准备好了主要的行动。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="63af" class="lq lr it bd ls lt ol lv lw lx om lz ma ki on kj mc kl oo km me ko op kp mg mh bi translated">第2节—下载图像数据</h1><p id="4e47" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated"><em class="oa">更新:由于图片下载方式是动态的，请参考fast.ai </em> <a class="ae lp" href="https://course.fast.ai/images" rel="noopener ugc nofollow" target="_blank"> <em class="oa">图片部分</em> </a> <em class="oa">了解图片下载的最新方式</em></p><p id="8e58" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">区分常见酒类的图像会很有趣，即<strong class="mk jd">威士忌、葡萄酒和啤酒。为此，我们首先在一个列表中定义三种酒精类型，并创建一个<code class="fe oq or os ot b">Path</code>来存储我们稍后将要下载的图像。</strong></p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="8576" class="oy lr it ot b gy oz pa l pb pc">alcohol_types = ['whisky','wine','beer']<br/>path = Path('alcohol')</span></pre><p id="fcef" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">对于三种酒精类型中的每一种，我们都创建了一个子路径来存储图像，然后从整理好的图像URL中下载图像。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="3f46" class="oy lr it ot b gy oz pa l pb pc">if not path.exists():<br/>    path.mkdir()<br/>    for alc_type in alcohol_types:<br/>        dest = (path/alc_type)<br/>        dest.mkdir(exist_ok=True)<br/>        <br/>        search_term = alc_type<br/>        params  = {"q":search_term, "license":"public",   <br/>                   "imageType":"photo", "count":"150"}<br/>        response = requests.get(search_url, headers=headers, <br/>                   params=params)<br/>        response.raise_for_status()<br/>        search_results = response.json()<br/>        img_urls = [img['contentUrl'] for img in   <br/>                    search_results["value"]]<br/>        <br/>        # Downloading images from the list of image URLs<br/>        download_images(dest, urls=img_urls)</span></pre><p id="81bc" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">现在，我们应该将图像下载到带有酒精类型标签的相应文件夹中。为了证实这一点，我们可以利用<code class="fe oq or os ot b">get_image_files</code>函数。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="149e" class="oy lr it ot b gy oz pa l pb pc">img_files = get_image_files(path)<br/>img_files</span><span id="07d8" class="oy lr it ot b gy pd pa l pb pc">(#445) [Path('alcohol/beer/00000069.jpeg'),Path('alcohol/beer/00000007.jpg'),Path('alcohol/beer/00000092.jpg'),Path('alcohol/beer/00000054.jpg'),Path('alcohol/beer/00000082.jpg'),Path('alcohol/beer/00000071.jpg'),Path('alcohol/beer/00000045.jpg'),Path('alcohol/beer/00000134.jpg'),Path('alcohol/beer/00000061.jpg'),Path('alcohol/beer/00000138.jpg')...]</span></pre><p id="00bc" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">另一种验证下载的方法是点击Google Colab屏幕左侧导航栏上的文件图标，并导航至<code class="fe oq or os ot b">content</code> &gt; <code class="fe oq or os ot b">alcohol</code>以查看各自的文件夹。</p><p id="ea1c" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">之后，我们需要检查我们下载的文件是否损坏。幸运的是，fastai通过<code class="fe oq or os ot b">verify_images</code>函数提供了一种方便的方法来实现这一点。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="7dd6" class="oy lr it ot b gy oz pa l pb pc">failed = verify_images(img_files)<br/>failed</span></pre><p id="16e5" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">然后我们可以使用<code class="fe oq or os ot b">map</code>和<code class="fe oq or os ot b">unlink</code>方法从数据集中移除这些损坏的文件(如果有的话)。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="bd14" class="oy lr it ot b gy oz pa l pb pc">failed.map(Path.unlink)</span></pre></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="6be6" class="lq lr it bd ls lt ol lv lw lx om lz ma ki on kj mc kl oo km me ko op kp mg mh bi translated">第3节-准备影像数据集</h1><p id="47ae" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">fastai有一个叫做<em class="oa">数据块API </em>的灵活系统。有了这个API，我们可以完全定制<code class="fe oq or os ot b">DataLoaders</code>对象的创建。<code class="fe oq or os ot b">DataLoaders</code>可以存储我们放置在其中的任何<code class="fe oq or os ot b">DataLoader</code>对象，并用于随后生成训练集和验证集。</p><p id="3175" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在我的理解中，<code class="fe oq or os ot b">DataLoaders</code>本质上是一个对象，它存储了关于我们将要运行模型的数据的信息。<code class="fe oq or os ot b">DataBlock</code>基本上是一个创建<code class="fe oq or os ot b">DataLoaders</code>的模板函数。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="946c" class="oy lr it ot b gy oz pa l pb pc">alcohols = DataBlock(<br/>    blocks=(ImageBlock, CategoryBlock), <br/>    get_items=get_image_files, <br/>    splitter=RandomSplitter(valid_pct=0.2, seed=1),<br/>    get_y=parent_label,<br/>    item_tfms=Resize(128))</span></pre><p id="6be4" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">让我们一部分一部分地看一下上面的代码:</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="5a76" class="oy lr it ot b gy oz pa l pb pc"><em class="oa">blocks=(ImageBlock, CategoryBlock)</em></span></pre><p id="d98e" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">这个<code class="fe oq or os ot b">blocks</code>元组分别表示我们的<em class="oa">独立</em>和<em class="oa">相关</em>变量的数据类型。因为我们的目标是对图像进行分类，我们的自变量是图像(<code class="fe oq or os ot b">ImageBlock</code>)，而因变量是类别/标签(<code class="fe oq or os ot b">CategoryBlock</code>)</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="7b8c" class="oy lr it ot b gy oz pa l pb pc"><em class="oa">get_items=get_image_files</em></span></pre><p id="ec5e" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated"><code class="fe oq or os ot b">get_items</code>参数指定要使用的函数，以便提取数据集中图像的文件路径。回想一下，我们之前使用fastai内置的<code class="fe oq or os ot b">get_image_files</code>将文件路径放入变量<code class="fe oq or os ot b">img_files</code>。这个<code class="fe oq or os ot b">get_image_files</code>函数获取一个路径(我们将在后面指定)，并返回该路径中所有图像的列表。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="35b9" class="oy lr it ot b gy oz pa l pb pc"><em class="oa">splitter=RandomSplitter(valid_pct=0.2, seed=1)</em></span></pre><p id="69c9" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated"><code class="fe oq or os ot b">splitter</code>方法将把数据集分成训练集和验证集。我们指定<code class="fe oq or os ot b">RandomSplitter</code>来确保它被随机分割，其中的<code class="fe oq or os ot b">valid_pct</code>参数用于指示数据集的多大比例将被分配为验证集。也可以在<code class="fe oq or os ot b">RandomSplitter</code>中设置随机种子，以实现结果的再现性。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="b5eb" class="oy lr it ot b gy oz pa l pb pc"><em class="oa">get_y=parent_label</em></span></pre><p id="db24" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated"><code class="fe oq or os ot b">parent_label</code>是fastai提供的一个函数，用来获取图像文件所在文件夹的名称。由于我们已经将图像放在具有各自酒类名称的文件夹中，这个<code class="fe oq or os ot b">parent_label</code>将返回文件夹名称<em class="oa">威士忌、葡萄酒</em>和<em class="oa">啤酒</em>。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="979e" class="oy lr it ot b gy oz pa l pb pc"><em class="oa">item_tfms=Resize(128)</em></span></pre><p id="2c36" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们通常使用将图像调整为正方形，因为这样做更容易，因为原始图像可以有不同的高度/宽度和纵横比。为此，我们对每个项目(<code class="fe oq or os ot b">item_tfms</code>)执行转换，将它调整为128x128像素的正方形。</p><p id="f157" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">既然已经提供了所有的细节和参数，我们就可以用下面的单行代码启动数据加载器了。请注意，<code class="fe oq or os ot b">dataloaders</code>的参数是存储图像的<code class="fe oq or os ot b">path</code>，即<code class="fe oq or os ot b">alcohol</code>文件夹路径。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="1226" class="oy lr it ot b gy oz pa l pb pc">dls = alcohols.dataloaders(path)</span></pre><p id="bd9d" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">让我们通过展示我们的验证集中的10个图像的子集来简要地看一下这些图像</p><p id="3fe2" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated"><em class="oa">注:以下显示的图像缩略图是验证数据下载是否正确的好方法。以前当我运行这段代码时，我意识到我没有相应地更新搜索词，导致所有图像都是威士忌。如果操作正确，接下来的一批应该会显示来自不同类别的大量图像。</em></p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="33a1" class="oy lr it ot b gy oz pa l pb pc">dls.valid.show_batch(max_n=12, nrows=2)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/a1211af15884d63331f3559f07e8fbe6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*aHg2OfqDMozXO69CExDe8g.png"/></div></figure></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h2 id="97d4" class="oy lr it bd ls pf pg dn lw ph pi dp ma mr pj pk mc mv pl pm me mz pn po mg iz bi translated">演示数据增强的工作原理</h2><p id="9ef6" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">在继续下一步之前，有必要讨论一下数据扩充的概念。为了丰富我们的训练数据集，我们可以创建输入数据的随机变化，使它们看起来不同，但实际上不会改变数据的原始含义和表示。</p><p id="1152" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">一种常见的方法包括<code class="fe oq or os ot b">RandomResizedCrop</code>，它抓取原始图像的随机子集。我们使用<code class="fe oq or os ot b">unique=True</code>用不同版本的<code class="fe oq or os ot b">RandomResizedCrop</code>变换来重复相同的图像。</p><p id="ca47" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">发生的情况是，在每个时期(这是一个完整的通过我们在数据集中的所有图像)，我们随机选择每个图像的不同部分。这意味着我们的模型可以学习识别我们图像中的不同特征。它还反映了图像在现实世界中的工作方式，因为同一件物品的不同照片可能会以略微不同的方式取景。使用项目转换的好处是，它反过来有助于防止过度拟合。</p><p id="f09f" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">指定的<code class="fe oq or os ot b">min_scale</code>参数决定了每次最少选择多少图像。有了以上所有的决定，我们可以使用<code class="fe oq or os ot b">.new</code>方法创建一个新的<code class="fe oq or os ot b">DataBlock</code>对象，并运行它来给我们一个名为<code class="fe oq or os ot b">dls</code>的新的<code class="fe oq or os ot b">DataLoaders</code>对象。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="1687" class="oy lr it ot b gy oz pa l pb pc">alcohols = alcohols.new(item_tfms=RandomResizedCrop(128, min_scale=0.3))<br/>dls = alcohols.dataloaders(path)<br/>dls.train.show_batch(max_n=8, nrows=2, unique=True)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/466b1b52071c10b9d240e143aadc74c3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dxL0gZWwa6_SL0aRDi74ow.png"/></div></figure><p id="4e5c" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">在项目转换(<code class="fe oq or os ot b">item_tfms</code>)之后，我们运行批量转换(<code class="fe oq or os ot b">batch_tfms</code>)，在批量单个项目上应用一组标准的数据扩充转换(<code class="fe oq or os ot b">aug_transforms()</code>)。</p><p id="f515" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated"><code class="fe oq or os ot b">item_tfms</code>和<code class="fe oq or os ot b">batch_tfms</code>的区别在于<code class="fe oq or os ot b">item_tfms</code>对每个单独的项目(如图像)进行转换，而<code class="fe oq or os ot b">batch_tfms</code>对整批项目进行转换。</p><p id="5c4f" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">以下代码说明了增强变换<code class="fe oq or os ot b">aug_transforms</code>对单个输入图像的影响。你将能够观察到某种形式的旋转、视角扭曲和对比度变化。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="7a84" class="oy lr it ot b gy oz pa l pb pc">alcohols = alcohols.new(item_tfms=Resize(128), batch_tfms=aug_transforms())<br/>dls = alcohols.dataloaders(path)<br/>dls.train.show_batch(max_n=8, nrows=2, unique=True)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/d963cd5dd28694727a23e9a7bc6fa86f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Z1ClOvM7GGXI5FCNHCPI7Q.png"/></div></figure></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="513c" class="lq lr it bd ls lt ol lv lw lx om lz ma ki on kj mc kl oo km me ko op kp mg mh bi translated">第4部分—训练模型</h1><p id="7b10" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">现在，图像已经准备好了(尽管还没有清理)，我们可以开始训练，立即构建一个简单的深度学习模型。首先，我们用下面的代码准备好<code class="fe oq or os ot b">DataLoaders</code>对象。在这个迭代中，我们以224x224像素的尺寸调整和裁剪我们的图像，<code class="fe oq or os ot b">min_scale</code>为0.5。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="6cc4" class="oy lr it ot b gy oz pa l pb pc">alcohols = alcohols.new(<br/>    item_tfms=RandomResizedCrop(224, min_scale=0.5),<br/>    batch_tfms=aug_transforms())<br/>dls = alcohols.dataloaders(path)</span></pre><p id="114a" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">卷积神经网络(CNN)是用于图像分类的事实上的神经网络类型，这就是我们将要使用的。架构方面，我对<code class="fe oq or os ot b">cnn_learner</code> fast.ai函数任意选择了resnet34(即34层深)。resnet的细节可以在<a class="ae lp" rel="noopener" target="_blank" href="/an-overview-of-resnet-and-its-variants-5281e2f56035">这里</a>找到。</p><p id="8253" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们使用<code class="fe oq or os ot b">.fine_tune</code>方法而不是<code class="fe oq or os ot b">.fit</code>方法，因为我们利用预训练的resnet模型来执行迁移学习。我们指定历元的数量为4(即<code class="fe oq or os ot b">.fine_tune</code>中的参数)。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="ac50" class="oy lr it ot b gy oz pa l pb pc">learn = cnn_learner(dls, resnet34, metrics=error_rate)<br/>learn.fine_tune(4)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/da7fde2d4e2019c50243fa111bd1a4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*h7N-N3afHmCFlc44go8CCQ.png"/></div></figure><p id="2cf5" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">从上面我们可以看到，在训练我们的CNN学习者几分钟后，我们获得了0.229的<code class="fe oq or os ot b">error_rate</code>(即77.1%的准确率)。考虑到我们还没有清理数据集，这是一个不错的开始。</p><p id="a3af" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">使用混淆矩阵可以更好地可视化结果。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="b0eb" class="oy lr it ot b gy oz pa l pb pc">interpretation = ClassificationInterpretation.from_learner(learn)<br/>interpretation.plot_confusion_matrix()</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/12f2d4a44a029c4d606de827a20ab541.png" data-original-src="https://miro.medium.com/v2/format:webp/1*k7oHerzjyX4L4xRRRhWVzg.png"/></div></figure><p id="4caa" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">fast.ai还提供了一种简单的方法，让我们可以找出哪些图像的丢失率最高。如果模型是不正确的(特别是如果它也对其不正确的答案有信心)，或者如果它是正确的，但对其正确的答案没有信心，则损失是较高的数字。这些帮助我们识别模型有问题的图像。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="4fda" class="oy lr it ot b gy oz pa l pb pc">interpretation.plot_top_losses(5, nrows=1)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/6d45aa6be95a929030d4c2347c68fedb.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CSEaNquKQepTGQCbE2gjuQ.png"/></div></figure><p id="3159" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">从上面来看，似乎有些问题源于几个实际标签贴错了，而不是预测错了。</p><p id="2c39" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">例如，行中间的图像很明显是一品脱啤酒的图像(这正是模型所预测的)。然而，分配给它的实际标签是威士忌，这是不正确的。这凸显了在训练任何类型的机器学习模型之前，拥有正确标记的数据(尽可能多)的重要性。</p><h2 id="9869" class="oy lr it bd ls pf pg dn lw ph pi dp ma mr pj pk mc mv pl pm me mz pn po mg iz bi translated">第5节—清理数据</h2><p id="e0bd" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">请注意，我们在清理数据之前运行了模型。事实上，这样做使得数据清理更加容易。如上图所示，<code class="fe oq or os ot b">plot_top_losses</code>已经可以指出哪些图像是模型最难处理的。</p><p id="f377" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">通过内置的fast.ai <code class="fe oq or os ot b">ImageClassifierCleaner</code>图形用户界面(GUI)小部件，数据清理过程变得很容易。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="8a2f" class="oy lr it ot b gy oz pa l pb pc">cleaner = ImageClassifierCleaner(learn)<br/>cleaner</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi pq"><img src="../Images/7a957a8add33a961fe7864391454d5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cT5mOAuOBmRgDGCkpoqDqA.png"/></div></div></figure><p id="b37c" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">显示的图像行是损失最大的图像，这个GUI为您提供了查看和修改它们的机会。</p><p id="2731" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">清理是通过为上面的每个图像选择一个下拉选项，然后反复运行“清理”代码来完成的。由于网上的解释不清楚，我花了一些时间来弄清楚这个问题，所以这里有一些进一步的细节:</p><ul class=""><li id="d3d7" class="nj nk it mk b ml ne mo nf mr pr mv ps mz pt nd no np nq nr bi translated"><strong class="mk jd">步骤1 </strong>:在<code class="fe oq or os ot b">cleaner</code>输出单元中加载一行图像(如葡萄酒类别的训练集)后，根据您自己的判断，为您希望编辑的图像选择一个下拉选项。选项包括从数据集中删除图像，或将图像移动到新的类别中。如果不需要更改，则不需要选择任何选项，因为默认选项是&lt;保持&gt;。</li><li id="fb13" class="nj nk it mk b ml ns mo nt mr nu mv nv mz nw nd no np nq nr bi translated"><strong class="mk jd">步骤2 </strong>:一旦你完成了显示的图像行的选项更新，运行下面的“清理”代码来执行更改。</li></ul><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="594e" class="oy lr it ot b gy oz pa l pb pc"># Delete images marked as delete<br/>for idx in cleaner.delete(): cleaner.fns[idx].unlink()<br/>    <br/># Update category of image to the newly specified category by moving # it into the appropriate folder<br/>for idx,cat in cleaner.change(): shutil.copyfile(cleaner.fns[idx], path/cat)</span></pre><p id="c0d7" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated"><code class="fe oq or os ot b">cleaner.delete</code>删除您标记为&lt;删除&gt;的图像，同时<code class="fe oq or os ot b">cleaner.change</code>将图像转移到带有更新标签的文件夹中。</p><ul class=""><li id="92fe" class="nj nk it mk b ml ne mo nf mr pr mv ps mz pt nd no np nq nr bi translated"><strong class="mk jd">步骤3: </strong>再次返回到带有该行图像的<code class="fe oq or os ot b">cleaner</code>单元格，并通过下拉菜单切换到一组新的图像，例如啤酒类别的验证组或威士忌类别的训练组</li><li id="3721" class="nj nk it mk b ml ns mo nt mr nu mv nv mz nw nd no np nq nr bi translated"><strong class="mk jd">步骤4: </strong>加载新一行图像后，选择每个图像的相关下拉选项，然后重新运行“清理”代码</li><li id="d8fa" class="nj nk it mk b ml ns mo nt mr nu mv nv mz nw nd no np nq nr bi translated"><strong class="mk jd">第5步</strong>:对每个数据集重复第3步和第4步，直到所有数据集至少被检查一次。</li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h2 id="f11c" class="oy lr it bd ls pf pg dn lw ph pi dp ma mr pj pk mc mv pl pm me mz pn po mg iz bi translated">数据清理后重新训练模型</h2><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="4f9c" class="oy lr it ot b gy oz pa l pb pc">dls = alcohols.dataloaders(path)<br/>learn = cnn_learner(dls, resnet34, metrics=error_rate)<br/>learn.fine_tune(4)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/6cec81fb41ed48cc4f08f42392070dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*PmRCAwNz3YRExZywK5uqDg.png"/></div></figure><p id="0c3d" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">通过一点点数据清理(主要是通过用<code class="fe oq or os ot b">.unlink</code>方法移除不相关的图像)，我们看到了<code class="fe oq or os ot b">error_rate</code>的巨大改进(从0.229降低到0.096)。这意味着准确率从更早的77.1%(数据清理前)提高到了现在的90.4%。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="d1cd" class="oy lr it ot b gy oz pa l pb pc">interpretation = ClassificationInterpretation.from_learner(learn)<br/>interpretation.plot_confusion_matrix()</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/3064f13248d9d7a571d246407daed45d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mTXDBgYG9EcGrWkA2wknFw.png"/></div></figure><p id="53f4" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">从上面的混淆矩阵中，我们可以清楚地看到，该模型在区分三种类型的酒精饮料方面变得更好。</p><p id="23ab" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">训练完成后，我们希望导出模型，以便保存架构、训练参数和<code class="fe oq or os ot b">DataLoaders</code>设置。这些都要存到泡菜里(。pkl)文件。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="a598" class="oy lr it ot b gy oz pa l pb pc">learn.export()</span><span id="c073" class="oy lr it ot b gy pd pa l pb pc">path = Path()<br/>path.ls(file_exts='.pkl')</span><span id="1b53" class="oy lr it ot b gy pd pa l pb pc">(#1) [Path('export.pkl')]</span></pre></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="4185" class="lq lr it bd ls lt ol lv lw lx om lz ma ki on kj mc kl oo km me ko op kp mg mh bi translated">第6节—使用图像分类器进行推理</h1><p id="0224" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">在加载包含我们深度学习图像分类模型信息的pickle文件后，我们可以用它来推断(或预测)新图像的标签。模型现在被加载到学习变量<code class="fe oq or os ot b">learn_inf</code>中。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="82b3" class="oy lr it ot b gy oz pa l pb pc">learn_inf = load_learner(path/'export.pkl')</span></pre><p id="3da1" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们使用一个样本图像来测试我们的模型</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="0cec" class="oy lr it ot b gy oz pa l pb pc"># Sample image<br/>ims = ['https://alcohaul.sg/products/i/400/5f7edfe79ae56e6d7b8b49cf_0.jpg']<br/>dest = 'images/test_whisky.jpg'<br/>download_url(ims[0], dest)</span><span id="1e7d" class="oy lr it ot b gy pd pa l pb pc">im = Image.open(dest)<br/>im.to_thumb(224,224)</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="ab gu cl pe"><img src="../Images/084100a7b348adb3439db4ac709cf824.png" data-original-src="https://miro.medium.com/v2/format:webp/1*SWyzzwJogsEfEWIQw45KJA.png"/></div></figure><p id="381b" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">我们的样本图像是日比喜和谐威士忌的图像。让我们看看我们的模型是否能够识别它的类别。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="7538" class="oy lr it ot b gy oz pa l pb pc">learn_inf.predict('images/test_whisky.jpg')</span><span id="15e0" class="oy lr it ot b gy pd pa l pb pc">('whisky', tensor(1), tensor([4.1783e-04, 9.9951e-01, 7.0310e-05]))</span><span id="b5b4" class="oy lr it ot b gy pd pa l pb pc">learn_inf.dls.vocab</span><span id="102c" class="oy lr it ot b gy pd pa l pb pc">['beer', 'whisky', 'wine']</span></pre><p id="8e01" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">看起来一切都很好。该模型能够以高置信度确定测试图像代表威士忌的图像(概率为99.95%)。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="43e9" class="lq lr it bd ls lt ol lv lw lx om lz ma ki on kj mc kl oo km me ko op kp mg mh bi translated">第7部分—部署为Web应用程序</h1><p id="a4d8" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">让我们简单探讨一下模型的部署。我们首先为用户创建一个按钮，上传他们希望分类的新图像。</p><p id="9659" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">然后，我们利用<code class="fe oq or os ot b">PIL.Image.create</code>方法检索上传的图像，并将其存储在<code class="fe oq or os ot b">img</code>变量中</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="1493" class="oy lr it ot b gy oz pa l pb pc">btn_upload = widgets.FileUpload()<br/>btn_upload</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/184293ba48433fd7a8f4e9d8bb7f6005.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*K_eYWuxMwjwQicNLHFBBOQ.png"/></div></figure><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="b27a" class="oy lr it ot b gy oz pa l pb pc"># Retrieving the uploaded image<br/>img = PIL.Image.create(btn_upload.data[-1])</span></pre><p id="5225" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">然后我们设置一个<code class="fe oq or os ot b">Output</code>小部件来显示上传的图像。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="ca25" class="oy lr it ot b gy oz pa l pb pc">out_pl = widgets.Output()<br/>out_pl.clear_output()<br/>with out_pl: display(img.to_thumb(224,224))<br/>out_pl</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/fb5edcceaa698552dbf747f1f8a5078e.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*Nsv6Ve1shL3pcMayjEUzEw.png"/></div></figure><p id="1329" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">用户上传了一张Talisker 18威士忌图片。现在是时候再次测试我们建立的模型的分类能力了。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="93e4" class="oy lr it ot b gy oz pa l pb pc">pred,pred_idx,probs = learn_inf.predict(img)</span><span id="ea6f" class="oy lr it ot b gy pd pa l pb pc">lbl_pred = widgets.Label()<br/>lbl_pred.value = f'Prediction: {pred}; Probability: {probs[pred_idx]:.04f}'<br/>lbl_pred</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi px"><img src="../Images/b551f04a07056a9d23a4798109ccec39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*Vbvpvc-9QArVfP8Vq6bNnA.png"/></div></figure><p id="68dd" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">从上面可以看出，我们的模型确实预测图像是威士忌的图像(概率为99.65%)。我们现在可以继续构建我们的web应用程序，包括一个运行按钮，供用户单击并启动分类过程。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="92bc" class="oy lr it ot b gy oz pa l pb pc">btn_run = widgets.Button(description='Classify Image')<br/>btn_run</span><span id="7f26" class="oy lr it ot b gy pd pa l pb pc">Button(description='Classify Image', style=ButtonStyle())</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi py"><img src="../Images/c4603af4f96b84384ea5844e278238dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*j_6rcpnY3ul2iDlHiBjaDQ.png"/></div></figure><p id="3f96" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">然后我们设置一个回调，这样上面的按钮可以在点击时执行特定的功能。我们想要的是，每当用户为他/她上传的图像单击“分类图像”时，分类模型就会运行，然后生成分类预测。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="5513" class="oy lr it ot b gy oz pa l pb pc">def on_click_classify(change):<br/>    img = PIL.Image.create(btn_upload.data[-1])<br/>    out_pl.clear_output()<br/>    with out_pl: display(img.to_thumb(128,128))<br/>    pred,pred_idx,probs = learn_inf.predict(img)<br/>    lbl_pred.value = f'Prediction: {pred}; Probability: {probs[pred_idx]:.04f}'<br/><br/>btn_run.on_click(on_click_classify)</span></pre><p id="ac8a" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">现在，将所有这些放在一个VBox中，这样小部件就可以很好地排列在我们笔记本中的垂直web应用程序模板中。</p><pre class="la lb lc ld gt ou ot ov ow aw ox bi"><span id="8823" class="oy lr it ot b gy oz pa l pb pc">VBox([widgets.Label('Select your alcohol!'), <br/>      btn_upload, btn_run, out_pl, lbl_pred]</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/c549827b365c9a08819c87e4853e4676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tZbSj40Y6UlLyqn_9O0saQ.png"/></div></figure><h1 id="38d3" class="lq lr it bd ls lt lu lv lw lx ly lz ma ki mb kj mc kl md km me ko mf kp mg mh bi translated"><strong class="ak">进一步的步骤</strong></h1><p id="a0a6" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">为了在笔记本之外部署这个应用程序，我们可以利用<code class="fe oq or os ot b">Voila</code>来创建一个真正独立的应用程序(基于Jupyter笔记本)。</p><p id="31f3" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">由于这方面超出了本笔记本的范围，请随意在这里探索Voila <a class="ae lp" href="https://voila.readthedocs.io/en/stable/using.html" rel="noopener ugc nofollow" target="_blank">的细节。</a></p><h1 id="ffce" class="lq lr it bd ls lt lu lv lw lx ly lz ma ki mb kj mc kl md km me ko mf kp mg mh bi translated">结论</h1><p id="fc3a" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">至此，本教程到此结束。我们讨论了端到端的建模体验，从fast.ai和Google Colab设置，到数据摄取，一直到为我们构建的模型设置一个简单的web应用程序。</p><p id="d915" class="pw-post-body-paragraph mi mj it mk b ml ne kd mn mo nf kg mq mr ng mt mu mv nh mx my mz ni nb nc nd im bi translated">随着我继续fast.ai学习之旅，我将继续发布进一步的演练。同时，喝一杯的时间到了。干杯！</p><h1 id="aa92" class="lq lr it bd ls lt lu lv lw lx ly lz ma ki mb kj mc kl md km me ko mf kp mg mh bi translated">在你走之前</h1><p id="8159" class="pw-post-body-paragraph mi mj it mk b ml mm kd mn mo mp kg mq mr ms mt mu mv mw mx my mz na nb nc nd im bi translated">欢迎您<strong class="mk jd">加入我的数据科学学习之旅！</strong>点击此<a class="ae lp" href="https://kennethleungty.medium.com/" rel="noopener">媒体</a>页面，查看我的<a class="ae lp" href="https://github.com/kennethleungty" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，了解更多令人兴奋的数据科学内容。</p></div></div>    
</body>
</html>