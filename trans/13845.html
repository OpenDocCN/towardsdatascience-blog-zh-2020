<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://towardsdatascience.com/a-must-know-new-clustering-algorithm-for-disease-modelling-7c28cd031434?source=collection_archive---------18-----------------------#2020-09-23">https://towardsdatascience.com/a-must-know-new-clustering-algorithm-for-disease-modelling-7c28cd031434?source=collection_archive---------18-----------------------#2020-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6fcda528d1ba5d4ad86604d862dd630f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*D8bomjgjPgYxmrIiFF5wSA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://www.freepik.com/photos/food" rel="noopener ugc nofollow" target="_blank">valeria _ aksakova创作的美食照片</a>——【www.freepik.com T2】</p></figure></div><div class="ab cl jh ji hx jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="im in io ip iq"><h1 id="37ee" class="jo jp jq bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一个必须知道的疾病建模的新聚类算法</h1><p id="153f" class="pw-post-body-paragraph kn ko jq kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">本文阐述了一种新的疾病数据聚类方法，通过将<strong class="kp ll">中的</strong><strong class="kp ll">子类型</strong>和<strong class="kp ll">阶段</strong>称为SuStaIn(子类型&amp;阶段推断)。它解释了<strong class="kp ll">概念</strong>，总结了<strong class="kp ll">数学</strong>，并提供了<strong class="kp ll"> python代码的链接。</strong></p></div><div class="ab cl jh ji hx jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="im in io ip iq"><p id="1b50" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">当我们想要找到横截面子类型(也称为聚类)时，经典聚类算法(如K-Means和高斯混合模型(GMM ))对于数据建模非常有用。这种分型在医学上被大量使用。一个众所周知的通用示例是<strong class="kp ll">使用单次血糖测量将糖尿病细分为“I型”和“II型”</strong><strong class="kp ll"/>。这可以帮助医生决定是开胰岛素注射还是改变生活方式。</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lr"><img src="../Images/1f9fa6329f4ce1723298f555d6cdcb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tx6foxtGHlupebCAZYzGCw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图一</strong>。使用横断面生物数据按表型划分的疾病亚型；例如，血糖的单次测量或医学图像。一个例子是糖尿病，其被细分为“I型”和“II型”。作者创建的图像。</p></figure><p id="7e1a" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">根据疾病阶段对疾病进行分组在医学上也非常有用，这次是为了模拟疾病进展。例如，使用<strong class="kp ll">纵向数据</strong>(同一个人在一段时间内的多次测量)开发了一个将癌症分为<strong class="kp ll">1–4期</strong>的模型。该模型本身是使用<em class="lx">纵向</em>数据开发的，但一旦开发，允许医生仅使用单个<em class="lx">横截面</em>测量值(即，以毫米为单位的肿瘤大小)来确定患者处于哪个阶段。了解癌症的阶段可能有助于医生决定是否需要放疗或化疗。</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/2b14026d67b6c9a15bd0cd06f1ea68be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFEz_2yRjBKEvZtkJbjXsw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图二。</strong>使用测量随时间进展的纵向数据，按阶段对疾病进行分组。一个例子是癌症，通常分为1-4期。作者创建的图像。</p></figure><p id="9e9d" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">这种分期模型的缺点是，它们假设所有患者都来自同一类型的疾病。即，它们说明了疾病<em class="lx">的进展</em>，但没有说明疾病<em class="lx">的亚型</em>。</p><p id="96e0" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">相反，前面提到的“横断面亚型”解释了<em class="lx">亚型</em>而不是<em class="lx">进展。</em>即<em class="lx"> </em>他们假设所有患者都处于同一阶段。</p><p id="1fb6" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">那么，如果我们想双管齐下，即<strong class="kp ll">根据疾病如何随时间发展</strong>的找到疾病的亚型<em class="lx">，并仅使用横截面数据创建该模型，会怎么样呢？</em></p><h1 id="3267" class="jo jp jq bd jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki md kk kl km bi translated">引入Z分数维持(子类型和阶段推断)算法</h1><p id="c888" class="pw-post-body-paragraph kn ko jq kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Z-Score SuStaIn是一种无监督的机器学习技术，它根据生物标记识别具有不同疾病进展模式的人群亚组(聚类)。这在下面的图3中抽象地显示出来。</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi me"><img src="../Images/13ec771ee5aa8e2538cf054c41208ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dz9rDjg5-k8HI0aIUiFwpg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图三</strong>。圆圈代表生物标记组。颜色(绿色、橙色、蓝色)代表不同的子类型，即不同的进展模式。注意:SuStaIn中产生的亚型不是基于临床定义的表型疾病亚型(如I型和II型糖尿病)，而是基于它们各自如何随时间发展<em class="mf"/>。作者创建的图像。</p></figure><blockquote class="mg mh mi"><p id="7618" class="kn ko lx kp b kq lm ks kt ku ln kw kx mj lo la lb mk lp le lf ml lq li lj lk im bi translated"><strong class="kp ll"> <em class="jq">生物标志物:</em></strong>任何可以在体内或其产物中被测量的物质、结构或过程，能够影响或预测结果或疾病的发生率”(世卫组织，2011)。<em class="jq">这包括从血糖测量和心率到出汗水平和大脑电信号的一切。</em></p></blockquote><p id="501e" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">为了用一个真实的例子来说明这一点，我们可以看看如何根据每个神经生物标志物的进展来发现阿尔茨海默氏症的<strong class="kp ll"> 3种亚型</strong>(见下图)。这里的生物标记(特征)是通过核磁共振扫描测量的各个大脑区域的萎缩水平。<em class="lx">图片说明中解释了颜色。</em></p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/92bdb755c286b2b1c4a838e30a3add27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1cDi5eQ9EFPkNN55jMIwIQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图4 </strong>。这张图片显示了老年痴呆症的<strong class="bd lw"> 3 </strong> <strong class="bd lw">亚型</strong> <strong class="bd lw">基于每种类型的进展情况(使用MRI脑部图像测量)。颜色编码代表生物标记退化，其中白色表示无病变，r <em class="mf"> ed </em>表示中度病变，p <em class="mf"> ink </em>表示中度病变，而<em class="mf">蓝色</em>表示最大病变。图片改编自Young等人(2018)。</strong></p></figure><p id="01fe" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">正如我们所见，<strong class="kp ll">基于不同的神经衰退模式，出现了3种不同的疾病进展模式，</strong>。例如，如下图5中突出显示的，亚型2在第9阶段开始显示枕叶(大脑图像中最左边的小角落)萎缩，然而亚型3在该区域根本没有显示萎缩，即使到了第25阶段也是如此。<strong class="kp ll">这些是非常不同类型的疾病进展，可能需要不同的医疗干预。</strong></p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mn"><img src="../Images/f266bd5537606566a74389237179c99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeoGto5fgR_ToS8sQBcRew.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图5 </strong>。亚型2在第9阶段显示枕叶萎缩，但是亚型3甚至在第25阶段也没有在该区域显示萎缩。图片改编自Young等人(2018)。</p></figure><h1 id="abb2" class="jo jp jq bd jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki md kk kl km bi translated">但是如何使用横断面数据来模拟疾病随时间的发展呢？</h1><p id="31e5" class="pw-post-body-paragraph kn ko jq kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kp ll"> SuStaIn </strong>是一种与疾病进展模型协同工作的聚类算法，在这种情况下是<strong class="kp ll"> Z-Score </strong>模型(因此得名Z-Score SuStaIn)。Z-Score SuStaIn使用生物标记数据的z-scores对疾病进展进行建模<strong class="kp ll"/>，用它来测量<strong class="kp ll">每个生物标记偏离正常状态的程度</strong>，即生物标记与健康个体<strong class="kp ll"> </strong>(对照组)的生物标记如何不同。这可以在上面的图4中看到，其中不同的颜色表示每个生物标记(在这种情况下为脑萎缩水平)与对照平均值的标准偏差的数量。因此，时间<em class="lx">阶段</em>(以及<em class="lx">子类型</em>)本质上是我们从数据<strong class="kp ll">中提取的<strong class="kp ll">隐藏变量</strong>。</strong>这就是我们如何仅使用横截面数据来衡量进展。</p><p id="aa66" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">Z分数维持算法以两个交替的步骤产生类似于图4中的输出。首先，在给定(z得分)数据的情况下，它选择具有<strong class="kp ll">最大可能性</strong>的<strong class="kp ll">事件序列</strong>。其次，它对个体进行亚型划分，并估计每个亚组的进展模式。然后，该算法在对具有相似进展模式的个体进行亚分类和重新估计每个亚组中的进展模式之间交替，直到其收敛，<strong class="kp ll">产生具有不同进展模式的几个亚型</strong>(如图3和4所示)。</p><p id="3a4e" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated"><strong class="kp ll">这种方法的主要优点是:</strong></p><ol class=""><li id="0743" class="mo mp jq kp b kq lm ku ln ky mq lc mr lg ms lk mt mu mv mw bi translated"><strong class="kp ll">可以根据疾病<em class="lx">亚型</em>和疾病<em class="lx">分期</em>对患者进行分类。</strong>如果开发成应用程序，这将基本上允许临床医生或研究人员对患者进行MRI扫描，通过训练的模型运行它，并被告知患者在给定疾病中处于哪个亚型和阶段。</li><li id="3607" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk mt mu mv mw bi translated"><strong class="kp ll">仅使用横断面数据</strong>就可以衡量疾病进展，这是非常(非常！)比纵向数据更容易获得，尤其是在医学领域。这意味着它可以用来了解更广泛的疾病。</li><li id="55af" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk mt mu mv mw bi translated">与现有模型相比，它为我们提供了一个更加 <strong class="kp ll">的疾病进展精细模型。支撑Z分数模型的模型，称为EBM(基于事件的模型；在“数学”部分解释)，提供医生需要的关键信息；即一个人是否生病。当生物标记测量值过渡到异常水平时，就会出现这种情况。然而，通过使用z分数，SuStaIn模型显示了人们如何通过<strong class="kp ll">正常到异常的多个间歇阶段</strong>，为我们提供了对进展的更精细的洞察。这种精细的洞察力<strong class="kp ll">还允许我们从数据中开发更准确的基于进展的亚型</strong>，这可能导致<strong class="kp ll"> </strong>到<strong class="kp ll"> </strong>更有针对性的药物开发。例如，不是为所有类型的疾病开发一种通用药物(这可能带来最大的副作用)<strong class="kp ll">而是可以开发针对每个亚型的药物</strong>，并且可以根据该亚型的进展模式来测量效果。这可能会减少不必要的副作用，并在治疗或缓解症状方面更加有效。</strong></li></ol><p id="d5a3" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated"><strong class="kp ll">的主要缺点</strong>是Z-score SuStaIn只对控制人群<strong class="kp ll">中具有正态分布变异性的<strong class="kp ll"> </strong>数据有效。</strong>如果数据不是高斯分布，结果会很差。(<em class="lx">在这种情况下，如果使用Firth等人(2018)最近开发的非参数</em> <a class="ae jg" href="https://www.biorxiv.org/content/10.1101/297978v1" rel="noopener ugc nofollow" target="_blank"> <em class="lx">核密度估计混合模型</em> </a> <em class="lx"> (KDEMM)代替Z-Score模型，效果会更好)。</em></p><h1 id="26d7" class="jo jp jq bd jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki md kk kl km bi translated">数据</h1><p id="15f5" class="pw-post-body-paragraph kn ko jq kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Z得分维持的输入数据可以是任何种类的生物标记，通过例如血液测试、MRI扫描、心电图等来测量。</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nc"><img src="../Images/ea146c7d07c97beb112b3b6a4cbfed5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzD0hRKuvUZwf8fsqgO3LA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图6。</strong>作者创造的形象。</p></figure><p id="cc83" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">在标准数据清理之后，在将数据放入算法之前，需要对数据<strong class="kp ll">做3件事:</strong></p><ol class=""><li id="d67f" class="mo mp jq kp b kq lm ku ln ky mq lc mr lg ms lk mt mu mv mw bi translated"><strong class="kp ll">根据协变量的影响进行调整。</strong>例如，在脑容量测量中，协变量可以是<em class="lx">年龄</em>，因为这个变量独立于疾病影响脑容量(随着年龄的增长，我们的大脑往往会自然缩小一点)。像这样的非疾病相关因素的影响应该被剔除，这样我们就可以只测量疾病对生物标记测量的影响。(通过回归实现这一点的代码在本文末尾的GitHub repo中)。</li><li id="d80e" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk mt mu mv mw bi translated"><strong class="kp ll"> Z值数据</strong>。这整个算法是基于生物标记偏离平均值的程度来衡量疾病的进展。因此，我们需要以z分数的形式输入数据；即一个数据点偏离平均值(在这种情况下，是控制平均值)的标准偏差数。</li><li id="79fa" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk mt mu mv mw bi translated"><strong class="kp ll">确定所有特征<em class="lx">增加</em>带病</strong>。如果任何特征<em class="lx">随着疾病而减少</em>，则将这些特征中的数据乘以-1。例如，随着生物标志物<em class="lx">额叶体积</em>减少，生物标志物<em class="lx">脑液</em>可能会增加(这是因为当大脑部分收缩时，身体会用液体填充空白空间)。如果混合了增加和减少的特征，算法将会变得混乱并产生不准确的结果。</li></ol><p id="a2e4" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">所有这些步骤和分析本身的python代码都在<a class="ae jg" href="https://github.com/ucl-pond/pySuStaIn/blob/master/SuStaIn%20tutorial%20using%20simulated%20data.ipynb" rel="noopener ugc nofollow" target="_blank"> SuStaIn Jupyter教程</a>中，也在本文末尾有链接。</p><h1 id="dea2" class="jo jp jq bd jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki md kk kl km bi translated">数学</h1><p id="a723" class="pw-post-body-paragraph kn ko jq kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="lx">为那些对SuStaIn细节感兴趣的人准备的额外部分。</em></p><p id="c18e" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated"><strong class="kp ll"> SuStaIn </strong>是一个基于可能性的分型模型，它与疾病进展模型协同工作，在本例中为<strong class="kp ll"> Z评分模型。</strong></p><p id="48cd" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated"><strong class="kp ll"> Z分数模型</strong>旨在<strong class="kp ll">预测最大化数据</strong>可能性的事件 <strong class="kp ll">的顺序，其中<em class="lx">事件</em>是生物标记从一个阶段到下一个阶段的转变(基于Z分数)。</strong></p><p id="5c8d" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated"><strong class="kp ll"> Z得分模型</strong>建立在<strong class="kp ll">基于事件的模型</strong> (Fonteijn等人，2014)之上，因此要理解<strong class="kp ll"> Z得分模型</strong>，首先理解EBM更容易。EBM通过测量生物标记从正常向异常转变的点，以二元方式测量疾病进展。</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nd"><img src="../Images/5904db8bd47e7954412a3bdd2c26833e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*9Tikq7_yz2zdXOQF3_C5rQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图7。</strong>基于事件的模型(EBM)。图片来自Young等人(2018)。</p></figure><p id="0395" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">上式显示了<a class="ae jg" href="https://pubmed.ncbi.nlm.nih.gov/22281676/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp ll">基于事件的模型(EBM) </strong> </a>其中:</p><ul class=""><li id="dddb" class="mo mp jq kp b kq lm ku ln ky mq lc mr lg ms lk ne mu mv mw bi translated"><strong class="kp ll"> X </strong>是原始生物标记测量的数据集(不是z分数)</li><li id="fd6d" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk ne mu mv mw bi translated"><strong class="kp ll"> S </strong>是生物标志物从正常向异常转变的序列。</li><li id="7119" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk ne mu mv mw bi translated"><strong class="kp ll"> p(X|S) </strong>是使数据可能性最大化的最可能的事件顺序。</li><li id="3bdf" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk ne mu mv mw bi translated"><strong class="kp ll"> p(k) </strong>是E1，…Ek事件发生时处于阶段k的先验概率(使用统一先验)。</li><li id="60ba" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk ne mu mv mw bi translated"><strong class="kp ll"> p(x|E) </strong> <strong class="kp ll">和p(x| E) </strong>是给定x内的数据点x，事件已经发生(生物标记已经转变为异常)和没有发生的概率。这些被建模为正态分布。</li></ul><p id="76aa" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">当仅使用少量生物标志物时，可以列举所有可能的排序，并且事件的<strong class="kp ll">顺序</strong><strong class="kp ll">ŝ</strong>是使P(X|S)最大化的顺序，如上图7所示。</p><p id="09e1" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">然而，因为可能序列的数量随着生物标记数量的增加而阶乘地增长，所以当要采样的序列数量太大而无法枚举时，使用<strong class="kp ll"> p(S|X) </strong>的<a class="ae jg" rel="noopener" target="_blank" href="/a-zero-math-introduction-to-markov-chain-monte-carlo-methods-dcba889e0c50"> <strong class="kp ll">马尔可夫链蒙特卡罗(MCMC) </strong> </a> <strong class="kp ll"> </strong>采样来寻找<strong class="kp ll">ŝ</strong>。(<em class="lx">这个过程在第4页的</em> <a class="ae jg" href="https://www.nature.com/articles/s41467-018-05892-0.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="lx">这篇文章的</em> </a>中有解释)。</p><p id="ef31" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">一旦我们有了ŝ，它就可以被用于<strong class="kp ll">估计个人的疾病阶段，给出他们的生物标记测量值。</strong>疾病阶段k被定义为，在给定数据和我们的序列的情况下，具有<strong class="kp ll">最高概率的阶段(即，迄今已发生的事件数量)。这是通过最大化上面图7中的等式来计算的，如下图8所示:</strong></p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/2e8c97ed7dd5212455634964aafa1ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drDqH4d1lH8wUiDJZbwtrQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图8 </strong>。与疾病阶段相关的优化，k .(图片取自Firth等人，2018年)。</p></figure><p id="3a49" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">然后<strong class="kp ll"> Z分数模型</strong>建立在EBM模型上，如下所示:</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/31a229838e4edcc22de193442eb62dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xr5bR2TubBt2wL46ijZJRQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图九。</strong>Z得分维持模型</p></figure><p id="899b" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">Z-score模型中有两个关键创新(与EBM相比)。首先是<strong class="kp ll"> X </strong>现在等于<strong class="kp ll"> </strong>数据而不是原始数据的<strong class="kp ll"> z分数。第二个是<strong class="kp ll"> S </strong>现在等于生物标记通过多个阶段</strong>移动<strong class="kp ll">的序列，而不仅仅是从正常到异常。因此，我们现在能够测量进展，不是通过从正常到异常的单一转变，而是通过疾病进展的多个阶段之间的<strong class="kp ll">转变。这给了我们一个更精细的疾病发展模型。</strong></strong></p><p id="0ebf" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated"><strong class="kp ll">持续</strong>然后通过同时优化子类型成员、子类型轨迹和两者的后验分布进行拟合(见下图10)。它是分层拟合的，由此通过从十重交叉验证获得的模型选择标准CVIC(交叉验证信息标准)来选择数据可以支持的子类型的数量。</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/ef3e150edf29797060ab40e344f4bfe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d4QOALKQM6jrstDHKSo6w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd lw">图10: </strong>持续模型</p></figure><p id="6a77" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">其中:</p><ul class=""><li id="8089" class="mo mp jq kp b kq lm ku ln ky mq lc mr lg ms lk ne mu mv mw bi translated"><strong class="kp ll"> C </strong>是集群(子类型)的数量</li><li id="4721" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk ne mu mv mw bi translated">f 是分配到特定聚类(子类型)的受试者比例</li><li id="5739" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk ne mu mv mw bi translated"><strong class="kp ll"> M </strong>是整体延音模式</li></ul><p id="28af" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated"><em class="lx">对这些数学模型的完整解释可以在</em> <a class="ae jg" href="https://www.nature.com/articles/s41467-018-05892-0" rel="noopener ugc nofollow" target="_blank"> <em class="lx">维持介绍论文</em> </a> <em class="lx"> (Young et al，2018)中看到。</em></p><h1 id="d1aa" class="jo jp jq bd jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki md kk kl km bi translated"><strong class="ak">总之</strong></h1><p id="8a42" class="pw-post-body-paragraph kn ko jq kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果您正在寻找疾病的亚型或使用生物标志物对疾病进展进行建模，那么在您的模型评估中包括SuStaIn是非常值得的。</p><p id="0564" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">希望那有用！如果你有任何问题，请直接在LinkedIn 上给我发消息。你也可以<strong class="kp ll">订阅我的帖子</strong> <a class="ae jg" href="https://medium.com/subscribe/@LuRoth_" rel="noopener">这里</a>。</p><p id="5a9a" class="pw-post-body-paragraph kn ko jq kp b kq lm ks kt ku ln kw kx ky lo la lb lc lp le lf lg lq li lj lk im bi translated">最后，如果你想进一步支持Medium上的作者，你可以在这里注册成为会员。</p><h1 id="8727" class="jo jp jq bd jr js lz ju jv jw ma jy jz ka mb kc kd ke mc kg kh ki md kk kl km bi translated">实施的关键资源</h1><p id="1c88" class="pw-post-body-paragraph kn ko jq kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">持续方法是由亚历克斯·扬博士和她的同事在UCL大学开发的，高级作者<a class="ae jg" href="https://twitter.com/fishpiechicken" rel="noopener ugc nofollow" target="_blank">丹尼尔·亚历山大教授</a> ( <a class="ae jg" href="https://www.nature.com/articles/s41467-018-05892-0" rel="noopener ugc nofollow" target="_blank">杨等人，2018 </a>)。它是由<a class="ae jg" href="https://twitter.com/WijDr" rel="noopener ugc nofollow" target="_blank"> Peter Wijeratne </a>博士在<a class="ae jg" href="https://iris.ucl.ac.uk/iris/browse/profile?upi=LLAKS78" rel="noopener ugc nofollow" target="_blank"> Leon Aksman </a>博士和<a class="ae jg" href="https://twitter.com/es_arman" rel="noopener ugc nofollow" target="_blank">Arman Eshaghi</a>博士的支持下用python实现的。</p><ul class=""><li id="fb45" class="mo mp jq kp b kq lm ku ln ky mq lc mr lg ms lk ne mu mv mw bi translated"><a class="ae jg" href="https://github.com/ucl-pond/pySuStaIn/blob/master/notebooks/SuStaIn%20tutorial%20using%20simulated%20data.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="kp ll">维持教程</strong> <strong class="kp ll">在Jupyter笔记本</strong> </a> <strong class="kp ll"> </strong>(作者亚历克斯·扬)。这也在下面的Github repo中，但是本教程是一个非常好的起点。</li><li id="7522" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk ne mu mv mw bi translated"><a class="ae jg" href="https://github.com/ucl-pond/pySuStaIn" rel="noopener ugc nofollow" target="_blank">完整的Github回购与<strong class="kp ll"> python代码</strong> </a> <strong class="kp ll"> </strong>(由<a class="ae jg" href="https://twitter.com/WijDr" rel="noopener ugc nofollow" target="_blank"> Peter Wijeratne </a>和同事完成)。</li><li id="0832" class="mo mp jq kp b kq mx ku my ky mz lc na lg nb lk ne mu mv mw bi translated"><a class="ae jg" href="https://www.nature.com/articles/s41467-018-05892-0" rel="noopener ugc nofollow" target="_blank">介绍<strong class="kp ll">维持</strong>的论文(亚历克斯·扬等，2018；【T21自然)】</a></li></ul></div></div>    
</body>
</html>