<html>
<head>
<title>Develop Database Driven REST API with Python in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python在10分钟内开发数据库驱动的REST API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/develop-database-driven-rest-api-with-python-in-10-minutes-9b8cbb7ce5b2?source=collection_archive---------5-----------------------#2020-10-06">https://towardsdatascience.com/develop-database-driven-rest-api-with-python-in-10-minutes-9b8cbb7ce5b2?source=collection_archive---------5-----------------------#2020-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee21" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python做一个完整的CRUD REST API。我提到过它是数据库驱动的吗？</h2></div><p id="9b38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">REST APIs在我们身边无处不在，被用来构建高质量的软件。在数据科学中，它们用于将机器学习模型部署到生产中，所以不，从长远来看，你无法避免它们。今天我们将使用Python和<code class="fe le lf lg lh b">Flask-RESTful</code>创建一个简单但功能齐全的数据库驱动API。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/d93ff7ae718d6b347b4fac51f87dfc0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuEUDAkSJw0qIIAOK4qoiw.jpeg"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">照片由<a class="ae ly" href="https://unsplash.com/@cookiethepom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Cookie在<a class="ae ly" href="https://unsplash.com/s/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的Pom </a>拍摄</p></figure><p id="93e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是所用技术的简要概述:</p><ul class=""><li id="982c" class="lz ma it kk b kl km ko kp kr mb kv mc kz md ld me mf mg mh bi translated">Python是一种神奇的编程语言，广泛用于各种类型的任务</li><li id="8a9a" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><strong class="kk iu">Flask-RESTful</strong>—<code class="fe le lf lg lh b">Flask</code>库的扩展。使我们能够快速开发API</li><li id="805e" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><strong class="kk iu"> SQLAlchemy </strong> —一种ORM(对象关系映射器)。帮助我们在不编写SQL的情况下与数据库通信</li></ul><p id="0265" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">差不多就是这样。这篇文章应该很容易理解，完成它不应该花费你超过10-15分钟的时间(如果按照代码进行的话)。</p><p id="cab7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章的结构如下:</p><p id="3388" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里下载源代码<a class="ae ly" href="https://gist.github.com/betterdatascience/1b552750a4ab1c6c94c1d4e451ded9f9" rel="noopener ugc nofollow" target="_blank">。让我们开始吧。</a></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8223" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">问题描述</h1><p id="61cd" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">我们想创建一个存储用户数据的数据库(想想网站上的注册表单)。我们可以访问用户名、密码、真实姓名和年龄等信息。</p><p id="673d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们想开发一个REST API来简化数据库处理。此外，API使我们的逻辑可用于任何编程语言、终端和工具，如。</p><p id="f612" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望以尽可能简单的方式从数据库中读取、插入、更新和删除记录。让我们就这样做吧，从下一节开始。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f49d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">设置和模型声明</h1><p id="7dc1" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">首先，在某个地方创建一个新目录，并在其中创建一个Python文件。我把我的命名为<code class="fe le lf lg lh b">app.py</code>，因为这是一个惯例，但这不是一个要求——所以你可以随意命名你的。</p><p id="61b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们继续进口，好吗？我们需要几个库:<code class="fe le lf lg lh b">Flask</code>、<code class="fe le lf lg lh b">Flask-RESTful</code>、<code class="fe le lf lg lh b">Flask-SQLAlchemy</code>和<code class="fe le lf lg lh b">Flask-Marshmallow</code>。以下是进口货:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="c7f8" class="nv mv it lh b gy nw nx l ny nz">from flask import Flask, request, jsonify <br/>from flask_sqlalchemy import SQLAlchemy <br/>from flask_marshmallow import Marshmallow <br/>from flask_restful import Resource, Api</span></pre><p id="6f4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当这个问题解决后，我们可以继续初始化。我们必须创建一个<code class="fe le lf lg lh b">Flask</code>应用程序和API的实例，并指定数据库的位置。我们正在使用，因此请确保您首先熟悉它:</p><div class="oa ob gp gr oc od"><a rel="noopener follow" target="_blank" href="/python-has-a-built-in-database-heres-how-to-use-it-47826c10648a"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">Python有一个内置的数据库——下面是如何使用它</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">如何利用内置数据库进行数据存储和操作</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="on l oo op oq om or ls od"/></div></div></a></div><p id="1ec5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还必须制作一个<code class="fe le lf lg lh b">SQLAlchemy</code>和<code class="fe le lf lg lh b">Marshmallow</code>的实例。后者用于使处理JSON响应变得轻而易举。代码如下:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="225f" class="nv mv it lh b gy nw nx l ny nz">app = Flask(__name__) <br/>api = Api(app) <br/>app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db' <br/>app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False <br/>db = SQLAlchemy(app) <br/>ma = Marshmallow(app)</span></pre><p id="e69a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">厉害！现在让我们进入正题，为我们的用户声明一个模型。<code class="fe le lf lg lh b">SQLAlchemy</code>需要它来动态构建和执行SQL，所以我们不必担心这个问题。如简介部分所述，我们将处理姓名、年龄、用户名和密码等数据。</p><p id="67e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要指定数据类型和它们的大小，所以<code class="fe le lf lg lh b">SQLAlchemy</code>可以创建表。这一切都发生在继承自<code class="fe le lf lg lh b">SQLAlchemy.Model</code>的<code class="fe le lf lg lh b">class</code>内。最后，我们将把参数传递给类的构造函数。代码如下:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="bbe9" class="nv mv it lh b gy nw nx l ny nz">class User(db.Model):<br/>    id = db.Column(db.Integer, primary_key=True)<br/>    username = db.Column(db.String(32), unique=True)<br/>    password = db.Column(db.String(32))<br/>    first_name = db.Column(db.String(32))<br/>    last_name = db.Column(db.String(32))<br/>    age = db.Column(db.Integer)<br/><br/>    def __init__(self, username, password, first_name, last_name, age):<br/>        self.username = username<br/>        self.password = password<br/>        self.first_name = first_name<br/>        self.last_name = last_name<br/>        self.age = age</span></pre><p id="ba20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码片段应该易于阅读和理解，因为没有什么复杂的东西。现在我们可以为我们的用户声明一个模式。这只是继承自<code class="fe le lf lg lh b">Marshmallow.Schema</code>的另一个类，用于避免令人头疼的JSON解析。代码如下:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="16af" class="nv mv it lh b gy nw nx l ny nz">class UserSchema(ma.Schema):<br/>    class Meta:<br/>        fields = ('id', 'username', 'password', 'first_name', 'last_name', 'age')</span></pre><p id="fb1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，我们已经准备好初始化数据库并创建<code class="fe le lf lg lh b">users</code>表。为此，在根文件夹中打开一个新窗口，执行如下所示的所有操作:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi os"><img src="../Images/ebd12947ef50f3c3af373fee01d95041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4IbO7huRRPSTrXg0.png"/></div></div></figure><p id="cf0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">厉害！我们需要做的最后一件事是使用声明的<code class="fe le lf lg lh b">UserSchema</code>。我们将声明两个变量——一个用于获取单个用户，另一个用于获取多个用户:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="19ab" class="nv mv it lh b gy nw nx l ny nz">user_schema = UserSchema() <br/>users_schema = UserSchema(many=True)</span></pre><p id="608e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以继续实际的API开发了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="43e6" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">API开发</h1><p id="5aa1" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">现在，我们将处理五件不同的事情:</p><p id="240d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这些逻辑都写在一个名为<code class="fe le lf lg lh b">UserManager</code>的类中。你可以随意命名你的名字，但这个似乎更合适。在谈到我们需要编写的样板代码的数量时,<code class="fe le lf lg lh b">Flask-RESTful</code>非常友好。它是最小的。首先，我们需要声明一个继承自<code class="fe le lf lg lh b">Flask-RESTful.Resource</code>的类。这是一个起始代码:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="d645" class="nv mv it lh b gy nw nx l ny nz">class UserManager(Resource): <br/>    pass</span></pre><p id="a3b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将从实现获取一个/所有用户的逻辑开始。后面的每个代码块都在<code class="fe le lf lg lh b">UserManager</code>类中。</p><h2 id="f8a3" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">获取用户</h2><p id="47fa" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">在<code class="fe le lf lg lh b">UserManager</code>类中，我们将声明一个名为<code class="fe le lf lg lh b">get</code>的静态方法。这一次命名非常重要，因为方法的名称代表了我们打算发出的HTTP请求的类型。请求是获取数据最合适的方式，所以我们将使用它。</p><p id="0867" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逻辑是这样的:</p><ul class=""><li id="3871" class="lz ma it kk b kl km ko kp kr mb kv mc kz md ld me mf mg mh bi translated">检查用户是否在URL后面附加了<code class="fe le lf lg lh b">ID</code>参数——如果是，我们需要单个用户的数据。如果没有，我们需要所有用户的数据</li><li id="9781" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">通过<code class="fe le lf lg lh b">SQLAlchemy</code>进行相应的查询</li><li id="e922" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">使用<code class="fe le lf lg lh b">flask.jsonify</code>函数返回JSON格式的数据</li></ul><p id="2876" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是代码:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="1afe" class="nv mv it lh b gy nw nx l ny nz">@staticmethod<br/>def get():<br/>    try: id = request.args['id']<br/>    except Exception as _: id = None<br/><br/>    if not id:<br/>        users = User.query.all()<br/>        return jsonify(users_schema.dump(users))<br/>    user = User.query.get(id)<br/>    return jsonify(user_schema.dump(user))</span></pre><p id="3e08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们继续插入新用户。</p><h2 id="12df" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">插入用户</h2><p id="800c" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">这次我们将使用HTTP请求。这意味着用户应该以JSON格式为新用户传递数据——在测试部分会有更多的介绍。此外，我们的新静态方法必须命名为<code class="fe le lf lg lh b">post</code>。</p><p id="7e77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们必须实现的逻辑:</p><ul class=""><li id="f70f" class="lz ma it kk b kl km ko kp kr mb kv mc kz md ld me mf mg mh bi translated">获取提供的用户名、密码、名字、姓氏和年龄的JSON数据</li><li id="02f9" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">用提供的数据创建一个<code class="fe le lf lg lh b">User</code>类的实例</li><li id="bd16" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">将该用户添加到数据库中，并提交事务</li><li id="5644" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">返回一条消息，表明用户已被插入</li></ul><p id="2fc2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个相对简单的函数。代码如下:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="469d" class="nv mv it lh b gy nw nx l ny nz">@staticmethod<br/>def post():<br/>    username = request.json['username']<br/>    password = request.json['password']<br/>    first_name = request.json['first_name']<br/>    last_name = request.json['last_name']<br/>    age = request.json['age']<br/><br/>    user = User(username, password, first_name, last_name, age)<br/>    db.session.add(user)<br/>    db.session.commit()<br/><br/>    return jsonify({<br/>        'Message': f'User {first_name} {last_name} inserted.'<br/>    })</span></pre><p id="4e7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们继续更新现有用户。</p><h2 id="efc3" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">更新用户</h2><p id="346c" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">要更新现有用户，我们将使用HTTP请求。然后，静态方法被命名为<code class="fe le lf lg lh b">put</code>，您已经猜到了。这是逻辑的概述:</p><ul class=""><li id="bc90" class="lz ma it kk b kl km ko kp kr mb kv mc kz md ld me mf mg mh bi translated">检查呼叫中是否传递了用户<code class="fe le lf lg lh b">ID</code>。否则，将返回一条错误消息。这是因为我们一次只更新一个用户</li><li id="e3b6" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">获取提供的用户名、密码、名字、姓氏和年龄的JSON数据</li><li id="63ef" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">根据提供的数据为数据库用户设置值，并提交事务</li><li id="f65d" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">返回一条消息，表明用户已被更新</li></ul><p id="90cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法比前一种稍微复杂一点，但是仍然相当容易实现:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="be5e" class="nv mv it lh b gy nw nx l ny nz">@staticmethod<br/>def put():<br/>    try: id = request.args['id']<br/>    except Exception as _: id = None<br/><br/>    if not id:<br/>        return jsonify({ 'Message': 'Must provide the user ID' })<br/><br/>    user = User.query.get(id)<br/>    username = request.json['username']<br/>    password = request.json['password']<br/>    first_name = request.json['first_name']<br/>    last_name = request.json['last_name']<br/>    age = request.json['age']<br/><br/>    user.username = username<br/>    user.password = password<br/>    user.first_name = first_name<br/>    user.last_name = last_name<br/>    user.age = age<br/><br/>    db.session.commit()<br/>    return jsonify({<br/>        'Message': f'User {first_name} {last_name} altered.'<br/>    })</span></pre><h2 id="8a50" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">删除用户</h2><p id="cd31" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">这是我们要实现的最终方法。它的任务是从数据库中删除单个用户。我相信您现在已经猜到我们将发出什么类型的HTTP请求，以及必须如何调用该方法。逻辑是这样的:</p><ul class=""><li id="5851" class="lz ma it kk b kl km ko kp kr mb kv mc kz md ld me mf mg mh bi translated">检查呼叫中是否传递了用户<code class="fe le lf lg lh b">ID</code>。否则，将返回一条错误消息。这是因为我们一次只删除一个用户</li><li id="4e0a" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">从数据库中删除用户并提交事务</li><li id="37f0" class="lz ma it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">返回一条消息，表明用户已被更新</li></ul><p id="f8ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码如下:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="3357" class="nv mv it lh b gy nw nx l ny nz">@staticmethod<br/>def delete():<br/>    try: id = request.args['id']<br/>    except Exception as _: id = None<br/><br/>    if not id:<br/>        returnjsonify({ 'Message': 'Must provide the user ID' })<br/><br/>    user = User.query.get(id)<br/>    db.session.delete(user)<br/>    db.session.commit()<br/><br/>    return jsonify({<br/>        'Message': f'User {str(id)} deleted.'<br/>    })</span></pre><p id="8ee3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">整个<code class="fe le lf lg lh b">UserManager</code>班就这样。接下来让我们完成文件，开始测试。</p><h2 id="66b4" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">收尾</h2><p id="f91e" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">为了完成<code class="fe le lf lg lh b">app.py</code>文件，我们需要将<code class="fe le lf lg lh b">UserManager</code>类附加到某个实际的端点上。我已经决定把我的名字命名为<code class="fe le lf lg lh b">/api/users</code>，但是命名的决定取决于你。</p><p id="2ce4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，从终端执行文件后，我们需要运行<code class="fe le lf lg lh b">Flask</code>应用程序。以下是两者的代码:</p><pre class="lj lk ll lm gt nr lh ns nt aw nu bi"><span id="dc74" class="nv mv it lh b gy nw nx l ny nz">api.add_resource(UserManager, '/api/users')<br/><br/>if __name__ == '__main__':<br/>    app.run(debug=True)</span></pre><p id="ed32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就这样——我们可以开始测试了。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="d5cf" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">测试</h1><p id="77e7" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">要启动我们的应用程序，请在根文件夹中打开一个新的终端窗口，并运行以下命令:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi pe"><img src="../Images/69df4bc1d9a247dd2405f14d2f1c8f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EBbZo4vSmxssfpAq.png"/></div></div></figure><p id="3c15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">厉害！API现在在<code class="fe le lf lg lh b">http://127.0.0.1:5000/api/users</code>运行，我们可以开始测试了。为了使这个过程简单明了，我决定使用这个应用程序。您不必这样做，因为您可以直接从Python甚至从终端做任何事情。我们将从插入开始，因为这对空数据库最有意义。</p><p id="3b6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您正在跟随，请打开Postman并按照下面的说明进行操作。</p><h2 id="dc9f" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">创建新用户</h2><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi pf"><img src="../Images/4a4131def3a908f838114cf605138c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qveIq-8w3T1vk_1Y.gif"/></div></div></figure><h2 id="a415" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">获取所有用户</h2><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi pf"><img src="../Images/efa1fda26fe296d437d8fc323c405a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0g7kOo03IKhAXRuK.gif"/></div></div></figure><h2 id="6890" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">获取单个用户</h2><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi pf"><img src="../Images/9d415f10b5d35428a097a2088bf3129d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F3mXFSgIqvbrkF5V.gif"/></div></div></figure><h2 id="9b03" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">更新用户</h2><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi pf"><img src="../Images/95427979a91c6aa25c9635dbb3f304d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YSzUvdSsLBCGT5qE.gif"/></div></div></figure><h2 id="94e4" class="nv mv it bd mw ot ou dn na ov ow dp ne kr ox oy ng kv oz pa ni kz pb pc nk pd bi translated">删除用户</h2><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi pf"><img src="../Images/38cdeb53d894b79f68d9c6d8427e76de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WlvcSr7UVxwma8sq.gif"/></div></div></figure><p id="2069" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">差不多就是这样了！一切都像宣传的那样工作，所以让我们在下一部分总结一下。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4278" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="16dd" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">这是一篇很长的文章，值得一读——我承认这一点。不过，我希望你已经设法跟上了，如果没有，请参考<a class="ae ly" href="https://gist.github.com/betterdatascience/1b552750a4ab1c6c94c1d4e451ded9f9" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="acb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">了解如何使用API以及如何设计它们是任何数据科学家的基本技能，Python提供了一种令人惊讶的简单入门方式。现在由你来决定向你认为合适的方向发展。请在下面的评论区留下你的想法。</p><p id="4df4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。</p><p id="2e54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加入我的私人邮件列表，获取更多有用的见解。 </p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="87f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="pg">喜欢这篇文章吗？成为</em> <a class="ae ly" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="pg">中等会员</em> </a> <em class="pg">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="oa ob gp gr oc od"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="ph l oo op oq om or ls od"/></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="aee1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="pg">原载于2020年10月6日https://betterdatascience.com</em><em class="pg"><a class="ae ly" href="https://betterdatascience.com/develop-database-driven-rest-api-with-python-in-10-minutes/" rel="noopener ugc nofollow" target="_blank"><em class="pg">。</em></a></em></p></div></div>    
</body>
</html>