<html>
<head>
<title>Meet the hardest functions of Pandas, Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">认识熊猫最难的功能，第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/meet-the-hardest-functions-of-pandas-part-i-7d1f74597e92?source=collection_archive---------15-----------------------#2020-10-08">https://towardsdatascience.com/meet-the-hardest-functions-of-pandas-part-i-7d1f74597e92?source=collection_archive---------15-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7f75" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">用熊猫重塑数据框</h2><div class=""/><div class=""><h2 id="5503" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">掌握<code class="fe kr ks kt ku b">pivot_table()</code>、<code class="fe kr ks kt ku b">stack()</code>、<code class="fe kr ks kt ku b">unstack()</code>的时间和方式</h2></div><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/12686deb8b8c7e8ba5f930fcc0abc75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eP4pmgM57BUhPy0UuEYb8w.jpeg"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated">来自<a class="ae ll" href="https://www.pexels.com/photo/fitness-power-man-person-17840/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ll" href="https://www.pexels.com/@binyaminmellish?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Binyamin Mellish </a>照片</p></figure><h2 id="9b70" class="lm ln it bd lo lp lq dn lr ls lt dp lu lv lw lx ly lz ma mb mc md me mf mg iz bi translated">介绍</h2><p id="06da" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp lv mq mr ms lz mt mu mv md mw mx my mz im bi translated">下面是最糟糕的情况:你在看付费课程，讲师在讲某个话题。然后，突然，他引入了一个全新的函数，说“这个函数/方法在这种情况下是完美的，它非常简单，所以只需查看其文档以了解更多细节”。你说OK，去文档，连自己在看什么都不知道。</p><p id="7b58" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">你感到沮丧，去读一些文章或StackOverflow线程，有时回来时感觉更糟。相信我，每个人都会这样。这篇文章专门讨论硬<code class="fe kr ks kt ku b">pandas</code>函数的情况。</p><p id="ebc8" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">大多数资料没有涵盖<code class="fe kr ks kt ku b">pandas</code>的一些高级功能的原因主要是它们非常具体。当您学习基本的方法和函数时，您将在它们自己的上下文中学习它们，就像在玩具数据集上一样。对于较难的函数，它们很难解释，并且很难创建它们有用的上下文。</p><p id="d2ba" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">这种功能通常在更有经验的科学家的工具箱中。当你以这样的方式使用它们时，它们会产生不同，函数用一行代码很优雅地解决了你遇到的问题。这个帖子讲的就是他们三个:<code class="fe kr ks kt ku b">pivot_table()</code>、<code class="fe kr ks kt ku b">stack()</code>和<code class="fe kr ks kt ku b">unstack()</code>。</p><div class="nf ng gp gr nh ni"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">通过我的推荐链接加入Medium-BEXGBoost</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw lf ni"/></div></div></a></div><p id="efe5" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">获得由强大的AI-Alpha信号选择和总结的最佳和最新的ML和AI论文:</p><div class="nf ng gp gr nh ni"><a href="https://alphasignal.ai/?referrer=Bex" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">阿尔法信号|机器学习的极品。艾总结的。</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">留在循环中，不用花无数时间浏览下一个突破；我们的算法识别…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">alphasignal.ai</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw lf ni"/></div></div></a></div></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h2 id="d75c" class="lm ln it bd lo lp lq dn lr ls lt dp lu lv lw lx ly lz ma mb mc md me mf mg iz bi translated">可点击的目录(仅限网络)</h2><p id="bccd" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp lv mq mr ms lz mt mu mv md mw mx my mz im bi translated">1.<a class="ae ll" href="#9b70" rel="noopener ugc nofollow">简介</a> <br/> 2。<a class="ae ll" href="#dce4" rel="noopener ugc nofollow">设置</a> <br/> 3。<a class="ae ll" href="#af38" rel="noopener ugc nofollow"> Pandas pivot_table()，与groupby() </a> <br/> 4比较。<a class="ae ll" href="#cc49" rel="noopener ugc nofollow">熊猫栈()</a> <br/> 5。<a class="ae ll" href="#40fd" rel="noopener ugc nofollow">熊猫解散()</a></p><blockquote class="of og oh"><p id="a212" class="mh mi oi mj b mk na kd mm mn nb kg mp oj nc mr ms ok nd mu mv ol ne mx my mz im bi translated">每个函数第一次出现时，我都给它们的文档加了超链接。请查看更多详细信息。</p></blockquote><h2 id="cc39" class="lm ln it bd lo lp lq dn lr ls lt dp lu lv lw lx ly lz ma mb mc md me mf mg iz bi translated">设置</h2><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h2 id="af38" class="lm ln it bd lo lp lq dn lr ls lt dp lu lv lw lx ly lz ma mb mc md me mf mg iz bi translated">Pandas pivot_table()，与groupby()比较</h2><blockquote class="of og oh"><p id="9e00" class="mh mi oi mj b mk na kd mm mn nb kg mp oj nc mr ms ok nd mu mv ol ne mx my mz im bi translated">应该有一种——最好只有一种——显而易见的方法来做这件事。</p></blockquote><p id="4b9d" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">以上是引用python的禅宗。Python希望一个问题只有一个明显的解决方案。但是，<code class="fe kr ks kt ku b">pandas</code>刻意回避了这一点。往往在<code class="fe kr ks kt ku b">pandas</code>中，一个操作有几种方式。</p><p id="86eb" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated"><code class="fe kr ks kt ku b"><a class="ae ll" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html" rel="noopener ugc nofollow" target="_blank">pivot_table()</a></code>就是一个例子。它是<code class="fe kr ks kt ku b">groupby()</code>功能的完整替代，有时甚至是更好的替代。不同的是结果的形状。<code class="fe kr ks kt ku b">groupby()</code>返回一个<code class="fe kr ks kt ku b">Series</code>对象，而<code class="fe kr ks kt ku b">pivot_table()</code>给出一个易于操作的数据框架。</p><p id="47eb" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">让我们用这两个函数来解决一个问题并给出解决方案。我将从<code class="fe kr ks kt ku b">seaborn</code>加载<code class="fe kr ks kt ku b">tips</code>数据集:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="0895" class="lm ln it ku b gy os ot l ou ov">tips = sns.load_dataset('tips')<br/>tips.head()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/320eb196e8ed6ba04f33062abbcc94de.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hE08jGT1D0eV0-_hb3N8xw.png"/></div></figure><p id="8ce7" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">我们想找出每个性别所有账单的总和:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/b3bec063f4d445af5e9777c2bb1f903b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*11tKvvvNb_qd2EhSmwd8rw.png"/></div></figure><p id="49f1" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">让我们比较一下这两个函数的语法。在<code class="fe kr ks kt ku b">groupby()</code>中，我们将想要分组的列放在括号中，在<code class="fe kr ks kt ku b">pivot_table()</code>中，等价的参数是<code class="fe kr ks kt ku b">index</code>。在<code class="fe kr ks kt ku b">groupby()</code>中，为了选择要聚合的列，我们使用带括号的子集，而在<code class="fe kr ks kt ku b">pivot_table()</code>中，我们将其传递给<code class="fe kr ks kt ku b">values</code>。最后，为了选择聚合函数，我们在<code class="fe kr ks kt ku b">groupby()</code>中使用方法链接，而<code class="fe kr ks kt ku b">pivot_table()</code>提供了<code class="fe kr ks kt ku b">aggfunc</code>参数。</p><p id="f85d" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">当我写一篇关于DS和ML的项目设置的文章时，我研究了很多笔记本。我发现令人惊讶的是，许多人使用<code class="fe kr ks kt ku b">groupby()</code>并使用<code class="fe kr ks kt ku b">.reset_index()</code>函数将<code class="fe kr ks kt ku b">groupby()</code>的结果转化为数据帧，让我们进一步探索以找出原因:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="efba" class="lm ln it ku b gy os ot l ou ov">result = tips.groupby('sex')['total_bill'].sum().reset_index()<br/>result</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/cfc13b39da146eaf57a9f5e0f23d5f25.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WT8jNyV7QubpVaa5wt5ttQ.png"/></div></figure><p id="6ddc" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">如果你使用<code class="fe kr ks kt ku b">pivot_table()</code>，你不必使用<code class="fe kr ks kt ku b">reset_index()</code>将结果转换成数据帧。<code class="fe kr ks kt ku b">groupby()</code>结果不像数据帧那样容易处理。让我们看看如何按多列分组和用多个函数聚合:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="f56a" class="lm ln it ku b gy os ot l ou ov">tips.groupby(['sex', 'day'])['total_bill']\<br/>            .agg([np.mean, np.median, np.sum]).reset_index()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/c0e1c2bd2fa2fd94adefdc182044cb6f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*K7ozrDrW1kUaS9N56LlPew.png"/></div></figure><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="8bf8" class="lm ln it ku b gy os ot l ou ov">tips.pivot_table(values='total_bill', <br/>                 index=['sex', 'day'], <br/>                 aggfunc=[np.mean, np.median, np.sum])</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/e485215ee9c30aa3043523b85d6f63f2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WAHtS-5GVZwYzg6DXoMy_Q.png"/></div></figure><p id="2a68" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">两个函数都返回多列的数据帧。但是，尽管对于单个列来说<code class="fe kr ks kt ku b">pivot_table()</code>更好，但是对<code class="fe kr ks kt ku b">groupby</code>结果使用<code class="fe kr ks kt ku b">reset_index()</code>会给出更好的数据框架。也许这就是Kagglers更喜欢<code class="fe kr ks kt ku b">groupby()</code>的原因。</p><p id="51ce" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">在<code class="fe kr ks kt ku b">pivot_table()</code>中，有时你可以用<code class="fe kr ks kt ku b">columns</code>参数代替<code class="fe kr ks kt ku b">index</code>(或者有时两者都用)将每组显示为一列。但是如果您向<code class="fe kr ks kt ku b">columns</code>传递多个参数，结果将是一个只有一行的长数据帧。</p><p id="7bec" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated"><code class="fe kr ks kt ku b">groupby()</code>和<code class="fe kr ks kt ku b">pivot_table()</code>的另一个区别是<code class="fe kr ks kt ku b">fill_value</code>参数。有时，当您按多个变量分组时，不会有匹配的结果单元格。在这种情况下，<code class="fe kr ks kt ku b">groupby()</code>会放置<code class="fe kr ks kt ku b">NaN</code> s，但在<code class="fe kr ks kt ku b">pivot_table()</code>中，您可以控制这种行为:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="30af" class="lm ln it ku b gy os ot l ou ov">tips.head()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/320eb196e8ed6ba04f33062abbcc94de.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hE08jGT1D0eV0-_hb3N8xw.png"/></div></figure><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/72f12a2f894d0a282df84dc152152205.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zPbKXoe9HFpt0IWbvDRAjg.png"/></div></figure><p id="a8e5" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">你想在什么时候使用<code class="fe kr ks kt ku b">pivot_table()</code>？正如我之前说过的，它有时可能是<code class="fe kr ks kt ku b">groupby()</code>的更好选择。说到语法也是个人喜好。一个明显的例子是选择<code class="fe kr ks kt ku b">pivot_table()</code>，因为它有一些<code class="fe kr ks kt ku b">groupby()</code>中没有的其他参数。我已经报道了<code class="fe kr ks kt ku b">fill_value</code>，但是还有其他类似<code class="fe kr ks kt ku b">margins</code>的。你可以在<a class="ae ll" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.pivot_table.html" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多信息😁。</p><blockquote class="of og oh"><p id="04ea" class="mh mi oi mj b mk na kd mm mn nb kg mp oj nc mr ms ok nd mu mv ol ne mx my mz im bi translated">请阅读文章的第二部分，了解计算分组汇总统计数据的函数之间的更多差异:</p></blockquote><div class="nf ng gp gr nh ni"><a rel="noopener follow" target="_blank" href="/meet-the-hardest-functions-of-pandas-part-ii-f8029a2b0c9b"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">认识熊猫最难的功能，第二部分</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">掌握交叉表的时间和方式()</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">towardsdatascience.com</p></div></div><div class="nr l"><div class="ox l nt nu nv nr nw lf ni"/></div></div></a></div></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h2 id="cc49" class="lm ln it bd lo lp lq dn lr ls lt dp lu lv lw lx ly lz ma mb mc md me mf mg iz bi translated">熊猫栈()</h2><p id="3a4b" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp lv mq mr ms lz mt mu mv md mw mx my mz im bi translated">使用时，<code class="fe kr ks kt ku b"><a class="ae ll" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html" rel="noopener ugc nofollow" target="_blank">stack()</a></code>返回带有多级索引的整形数据帧。最内层是通过旋转数据框架的列来创建的。我们最好从一个例子开始。为了更好地理解，我将加载<code class="fe kr ks kt ku b">cars</code>数据集并对其进行子集化:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/b7245ed3d6388694e74f89d27f4c5ec6.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9HRDSPPdCFRng5LHH_sjlg.png"/></div></figure><p id="d23c" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">让我们看看如何透视数据帧，使列现在成为索引:</p><p id="a3ed" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">当我们在这个数据帧上使用<code class="fe kr ks kt ku b">stack()</code>函数时，结果会有多级索引，<code class="fe kr ks kt ku b">name</code>为外层，<code class="fe kr ks kt ku b">weight</code>，<code class="fe kr ks kt ku b">horsepower</code>为内层:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="3320" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">这里，原始数据帧只有一个单级列名。这就是结果数据帧是<code class="fe kr ks kt ku b">pandas.Series</code>而不是数据帧的原因。</p><p id="cbb2" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">记住<code class="fe kr ks kt ku b">stack()</code>函数总是将列旋转到内部级别索引。如果没有剩余的列，意味着如果最终数据是一个系列，<code class="fe kr ks kt ku b">stack()</code>将不起作用。我们来试试上面的<code class="fe kr ks kt ku b">Series</code>:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="ea8d" class="lm ln it ku b gy os ot l ou ov">stacked_cars.stack()</span><span id="160a" class="lm ln it ku b gy oy ot l ou ov">AttributeError: 'Series' object has no attribute 'stack'</span></pre><p id="42f4" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated"><code class="fe kr ks kt ku b">stack()</code>的一个更复杂的例子是当列名作为多级索引给出时。让我们回到我们的一个数据透视表:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/e485215ee9c30aa3043523b85d6f63f2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WAHtS-5GVZwYzg6DXoMy_Q.png"/></div></figure><p id="f187" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">如您所见，列名有两个层次。您可以访问具有多级名称的列，如下所示:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5ac5" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">让我们在这个数据帧上使用<code class="fe kr ks kt ku b">stack()</code>,看看会发生什么:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="2fed" class="lm ln it ku b gy os ot l ou ov">multi_name.stack()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/9e93cc3931e99af729713c378eafa3d4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4wZkHyyERGczNMuVarbLoA.png"/></div></figure><p id="9ab8" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">现在，<code class="fe kr ks kt ku b">total_bill</code>这个内层列名变成了一个索引。您可以控制要堆叠的列级别。让我们看看如何堆叠外层列名:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="2a85" class="lm ln it ku b gy os ot l ou ov">multi_name.stack(level=0)</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/0f83a56e576e01678e5f2bb0e93b8191.png" data-original-src="https://miro.medium.com/v2/format:webp/1*LhxRdkd6KE9mgp4YRZKSNw.png"/></div></figure><p id="4004" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">如您所见，使用不同的级别会产生不同形状的数据帧。默认情况下，<code class="fe kr ks kt ku b">level</code>设置为1。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h2 id="40fd" class="lm ln it bd lo lp lq dn lr ls lt dp lu lv lw lx ly lz ma mb mc md me mf mg iz bi translated">熊猫解散堆叠()</h2><p id="d38d" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp lv mq mr ms lz mt mu mv md mw mx my mz im bi translated">顾名思义，<code class="fe kr ks kt ku b"><a class="ae ll" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html" rel="noopener ugc nofollow" target="_blank">unstack()</a></code>做的和<code class="fe kr ks kt ku b">stack()</code>完全相反。它采用多级索引<code class="fe kr ks kt ku b">Series</code>或数据帧，并将索引转换为列。如果我们拆分堆叠的汽车系列，我们将获得原始数据框架:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="96dc" class="lm ln it ku b gy os ot l ou ov">&gt;&gt;&gt; print('Unstacked Dataframe:')<br/>&gt;&gt;&gt; stacked_cars.unstack()</span><span id="89cd" class="lm ln it ku b gy oy ot l ou ov">Unstacked Dataframe:</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/9d2c8951e828b24df463a8c05e6e5f81.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Kr48aXdwShf4fg7GtUQyeA.png"/></div></figure><p id="09b6" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">也许，拆垛最明显的用例是当我们使用<code class="fe kr ks kt ku b">groupby()</code>函数时。虽然当我们按一个变量分组时，这一过程是不可能的，但拆分证明对按多个变量分组非常有用。让我们回到我们的<code class="fe kr ks kt ku b">tips</code>数据集:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="9c71" class="lm ln it ku b gy os ot l ou ov">tips.head()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/320eb196e8ed6ba04f33062abbcc94de.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hE08jGT1D0eV0-_hb3N8xw.png"/></div></figure><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="37c2" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">结果是一个具有4级索引的序列。这不是我们想要的。让我们拆分一下，以便更容易使用:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="74d6" class="lm ln it ku b gy os ot l ou ov">multiple_groups.unstack()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/c19df81b8788e37feab6dee511580548.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WhGcnOC2CpK2GMC58xf1KA.png"/></div></figure><p id="9041" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">结果还是多级索引。这是因为<code class="fe kr ks kt ku b">unstack()</code>一次只在一个索引级别上工作。让我们再次调用它来获得具有单一索引级别的数据帧:</p><pre class="kw kx ky kz gt oo ku op oq aw or bi"><span id="db71" class="lm ln it ku b gy os ot l ou ov">multiple_groups.unstack().unstack()</span></pre><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="ab gu cl ow"><img src="../Images/76fb9d63edd214a4a5eafc9a7e20e435.png" data-original-src="https://miro.medium.com/v2/format:webp/1*BFrh1h7NvbssiURnhKbHzA.png"/></div></figure><p id="93a5" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">我想你已经看到了<code class="fe kr ks kt ku b">unstack()</code>和<code class="fe kr ks kt ku b">groupby()</code>一起使用的效果。多级索引总是很难使用。除非万不得已，否则尽量避开它们。一种方法是使用<code class="fe kr ks kt ku b">unstack()</code>。</p><p id="9a2d" class="pw-post-body-paragraph mh mi it mj b mk na kd mm mn nb kg mp lv nc mr ms lz nd mu mv md ne mx my mz im bi translated">虽然<code class="fe kr ks kt ku b">stack()</code>不常用，但我还是向你展示了它的基本语法和一般用法，以便你更好地掌握<code class="fe kr ks kt ku b">unstack()</code>。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h2 id="6659" class="lm ln it bd lo lp lq dn lr ls lt dp lu lv lw lx ly lz ma mb mc md me mf mg iz bi translated">包裹</h2><p id="3643" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp lv mq mr ms lz mt mu mv md mw mx my mz im bi translated">这个帖子只有大约3个功能。在不久的将来，我计划为其他功能编写类似的文章，这些功能可能有点难以理解并集成到日常使用中。所以，请继续关注！</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><h1 id="c094" class="oz ln it bd lo pa pb pc lr pd pe pf lu ki pg kj ly kl ph km mc ko pi kp mg pj bi translated">如果你喜欢这篇文章，请分享并留下反馈。作为一名作家，你的支持对我来说意味着一切！</h1><p id="0ab8" class="pw-post-body-paragraph mh mi it mj b mk ml kd mm mn mo kg mp lv mq mr ms lz mt mu mv md mw mx my mz im bi translated">阅读更多与主题相关的文章:</p><div class="nf ng gp gr nh ni"><a rel="noopener follow" target="_blank" href="/meet-the-hardest-functions-of-pandas-part-ii-f8029a2b0c9b"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">认识熊猫最难的功能，第二部分</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">掌握交叉表的时间和方式()</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">towardsdatascience.com</p></div></div><div class="nr l"><div class="ox l nt nu nv nr nw lf ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a rel="noopener follow" target="_blank" href="/shape-tables-like-jelly-with-pandas-melt-and-pivot-f2e13e666d6"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">认识熊猫最难的功能，第三部分</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">形状像果冻的桌子有熊猫旋转()和融化()</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">towardsdatascience.com</p></div></div><div class="nr l"><div class="pk l nt nu nv nr nw lf ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a rel="noopener follow" target="_blank" href="/how-i-customarily-bin-data-with-pandas-9303c9e4d946"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">我习惯如何将数据与熊猫绑定</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">您可能只使用了默认值</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">towardsdatascience.com</p></div></div><div class="nr l"><div class="pl l nt nu nv nr nw lf ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a rel="noopener follow" target="_blank" href="/masteriadsf-246b4c16daaf"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">掌握连接:Pandas合并、连接、追加方法</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">从半连接/反连接到验证数据合并</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">towardsdatascience.com</p></div></div><div class="nr l"><div class="pm l nt nu nv nr nw lf ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a rel="noopener follow" target="_blank" href="/from-kagglers-best-project-setup-for-ds-and-ml-ffb253485f98"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jd gy z fp nn fr fs no fu fw jc bi translated">来自Kagglers:DS和ML的最佳项目设置</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">来自顶级Kagglers的项目成功最佳实践的集合</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">towardsdatascience.com</p></div></div><div class="nr l"><div class="pn l nt nu nv nr nw lf ni"/></div></div></a></div></div></div>    
</body>
</html>