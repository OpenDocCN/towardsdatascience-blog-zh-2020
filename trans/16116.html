<html>
<head>
<title>Fast transition between dplyr and data.table</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">dplyr和data.table之间的快速转换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fast-transition-between-dplyr-and-data-table-c02d53cb769f?source=collection_archive---------15-----------------------#2020-11-06">https://towardsdatascience.com/fast-transition-between-dplyr-and-data-table-c02d53cb769f?source=collection_archive---------15-----------------------#2020-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c942" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">dplyr和data.table的并行语法比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec85b4183de2ddf62db40daa2c82e5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqmUf85DCJDjaEFtxenQKQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>从<a class="ae ky" href="https://www.pexels.com/photo/man-people-woman-laptop-5698381/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><p id="2192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我比较了R的两个最强大的数据操作库的语法:dplyr和data.table。我在这里不是要提倡任何包。然而，在处理一个具有异常大的数据集的项目时，为了速度和内存效率，我首选的包变成了data.table。我在dplyr中使用了一个遗留项目，并在data.table中重新创建了它。</p><blockquote class="lv lw lx"><p id="dca5" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><code class="fe mc md me mf b"><strong class="lb iu"><em class="it">data table</em></strong></code>提供高性能版本的base R数据帧，增强了语法和功能，以提高易用性、便利性和编程速度根据数据表作者马特·道尔的说法</p><p id="599d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><code class="fe mc md me mf b"><strong class="lb iu"><em class="it">dplyr </em></strong></code>是一种数据操作语法，提供一组一致的动词，帮助您解决最常见的数据操作挑战根据《dplyr》的作者Hadley Wickham所说</p></blockquote><h1 id="65d1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">库和数据集</strong></h1><p id="af9a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我将使用R内置的汽车保险索赔的AutoClaims数据集。让我们安装和加载库，并为练习准备数据集。</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="3beb" class="nh mh it mf b gy ni nj l nk nl">#install.packages(“dplyr”)<br/>#install.packages(“data.table”)<br/>#install.packages(“insuranceData”)</span><span id="f8cb" class="nh mh it mf b gy nm nj l nk nl">library(dplyr)<br/>library(data.table)<br/>library(insuranceData)</span><span id="8165" class="nh mh it mf b gy nm nj l nk nl">data(“AutoClaims”) <em class="ly">#load the dataset</em><br/>data &lt;- AutoClaims <em class="ly">#rename the dataset</em><br/>data &lt;- data.table(data) <em class="ly">#convert it to data.table</em></span></pre><p id="7767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据有6773行和5列。让我们看看数据是怎样的。</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="2abd" class="nh mh it mf b gy ni nj l nk nl">&gt; head(data)<br/>STATE CLASS GENDER AGE PAID<br/>1 STATE 14 C6 M 97 1134.44<br/>2 STATE 15 C6 M 96 3761.24<br/>3 STATE 15 C11 M 95 7842.31<br/>4 STATE 15 F6 F 95 2384.67<br/>5 STATE 15 F6 M 95 650.00<br/>6 STATE 15 F6 M 95 391.12</span></pre><h1 id="eede" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">十大最常用的数据操作功能</strong></h1><ol class=""><li id="2eb1" class="nn no it lb b lc my lf mz li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">按行过滤</strong></li></ol><p id="9375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们过滤79岁或更年轻的男性</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="8672" class="nh mh it mf b gy ni nj l nk nl">data[AGE &lt;= 79 &amp; GENDER == “M”]<strong class="mf iu"> </strong><em class="ly">#datatable</em></span><span id="650d" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% filter(AGE &lt;= 79 &amp; GENDER == “M”) <em class="ly">#dplyr</em></span></pre><p id="3daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。按列选择</strong></p><p id="3a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们选择性别、年龄和薪酬列</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="b8a3" class="nh mh it mf b gy ni nj l nk nl">data[, .(GENDER, AGE, PAID)] <em class="ly">#datatable</em></span><span id="b013" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% select(GENDER, AGE, PAID) <em class="ly">#dplyr</em></span></pre><p id="445f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。添加新列</strong></p><p id="a23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用0.85美元/欧元的兑换率将美元兑换成欧元。产生的新变量被添加到数据集中</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="622c" class="nh mh it mf b gy ni nj l nk nl">data[, PAID.IN.EURO := PAID * 0.85] <em class="ly">#datatable</em></span><span id="7f2d" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% mutate(PAID.IN.EURO = PAID * 0.85) <em class="ly">#dplyr</em></span></pre><p id="e4f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4。删除栏目</strong></p><p id="3ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们删除新创建的变量</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="e765" class="nh mh it mf b gy ni nj l nk nl">data[, !c(“PAID.IN.EURO”)] <em class="ly">#datatable<br/></em>data[, PAID.IN.EURO:= NULL] <em class="ly">#datatable (alternative way)</em></span><span id="40cb" class="nh mh it mf b gy nm nj l nk nl">select(data, -PAID.IN.EURO) <em class="ly">#dplyr</em></span></pre><p id="5af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5。创建新列</strong></p><p id="e3cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在创建一个新变量并删除现有的变量。因此，数据集将只有一个新变量</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="eacf" class="nh mh it mf b gy ni nj l nk nl">data[, .(PAID.IN.EURO = PAID * 0.85)] #datatable</span><span id="7f38" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% transmute(PAID.IN.EURO = PAID * 0.85) #dplyr</span></pre><p id="9015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 6。按列汇总</strong></p><p id="4bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平均赔付的保险理赔是多少？</p><p id="255d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码聚合数据并返回名为AVG的单记录。有报酬的</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="82b4" class="nh mh it mf b gy ni nj l nk nl">data[, .(AVG.PAID = mean(PAID))] <em class="ly">#datatable</em></span><span id="dc84" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% summarise(AVG.PAID = mean(PAID)) <em class="ly">#dplyr</em></span></pre><p id="e8ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 7。重命名变量</strong></p><p id="3594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于data.table，我们使用setnames函数，它先引用旧名称，然后引用新名称。对于dplyr，顺序正好相反</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="afb3" class="nh mh it mf b gy ni nj l nk nl">setnames(data, c(“GENDER”, “CLASS”), c(“gender”, “class”)) <em class="ly">#dt</em></span><span id="83a0" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% rename(“gender” = “GENDER”, “class” = “CLASS”) <em class="ly">#dplyr</em></span></pre><p id="4648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 8。按升序或降序排列数据</strong></p><p id="5f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用data.table中的<code class="fe mc md me mf b">setorder</code>函数和dplyr中的<code class="fe mc md me mf b">arrange</code>函数对数据进行升序和降序排序。</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="800f" class="nh mh it mf b gy ni nj l nk nl">setorder(data, PAID) <em class="ly">#datatable ascending order</em><br/>setorder(data, -PAID) <em class="ly">#datatable descending order</em></span><span id="f801" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% arrange(PAID) <em class="ly">#dplyr ascending </em><br/>data %&gt;% arrange(desc(PAID)) <em class="ly">#dplyr descending</em></span></pre><p id="174a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 9。按列分组</strong></p><p id="bf65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单独对数据分组没有任何作用；您应该将它与另一个函数结合使用，例如，按州分组并汇总数据，或者筛选数据。</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="9164" class="nh mh it mf b gy ni nj l nk nl">data[, .(mean.paid.by.state = mean(PAID)), by = "STATE"]</span><span id="b0f2" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% group_by(STATE) %&gt;%<br/>  summarize(mean.paid.by.state = mean(PAID))</span></pre><p id="697c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 10。计数观察值</strong></p><p id="94d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过对dplyr和使用n()函数来计算每个类有多少个观察值。n代表数据表</p><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="3bad" class="nh mh it mf b gy ni nj l nk nl">data[, .N, by= “class”] <em class="ly">#datatable</em></span><span id="68a4" class="nh mh it mf b gy nm nj l nk nl">data %&gt;% <em class="ly">#dplyr</em><br/> group_by(class) %&gt;%<br/> summarise(n())</span></pre><p id="e67d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看更多关于如何在dplyr和data.table中链接函数的例子。</p><h1 id="ce5b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">链接功能</strong></h1><p id="9459" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在dplyr中，我们使用%&gt;%管道操作符来链接函数。在data.table中，可以在一行代码中简洁地编写几个函数，或者使用方括号进行更复杂的链接。</p><ul class=""><li id="9a08" class="nn no it lb b lc ld lf lg li nw lm nx lq ny lu nz nt nu nv bi translated">让我们选择三个变量:STATE、AGE和payed，然后创建一个20% payed的新列，并根据列AGE对结果进行升序排序。</li></ul><pre class="kj kk kl km gt nd mf ne nf aw ng bi"><span id="f175" class="nh mh it mf b gy ni nj l nk nl"><strong class="mf iu"><em class="ly">#datatable</em></strong><br/>data[, .(STATE, AGE, PAID)][, .paid.20 := PAID * 0.2, keyby = "AGE"]</span><span id="2f27" class="nh mh it mf b gy nm nj l nk nl"><strong class="mf iu"><em class="ly">#dplyr</em></strong><br/>data %&gt;% select(STATE, AGE, PAID) %&gt;% <br/>  mutate(paid.20 = PAID * 0.2) %&gt;%<br/>  arrange(AGE)</span></pre><h1 id="dbcc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">结论</strong></h1><p id="9d23" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">今天我们并排比较了<code class="fe mc md me mf b">dplyr</code>和<code class="fe mc md me mf b">data.table</code>的语法，使用了10个常用函数和链式函数。使用这两个库，您可以做更多的事情。</p><p id="7b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">语法。</strong> Data.table使用比dplyr更短的语法，但通常更加细致和复杂。dplyr使用管道操作符，对于初学者阅读和调试来说更直观。此外，许多其他库使用管道操作符，如ggplot2和tidyr。虽然data.table和dplyr都在R社区中广泛使用，但dplyr的使用范围更广，提供了更多的协作机会。</p><p id="0756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">内存和速度</strong>重要吗？在构建复杂的报告和仪表板时，尤其是在处理非常大的数据集时，data.table具有明显的优势。</p><p id="a428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用哪个库进行分析由您决定！</p><p id="3a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在参考资料部分找到更多的资料。</p><p id="3026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p><h1 id="07ae" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">参考文献</strong></h1><div class="oa ob gp gr oc od"><a href="https://rdatatable.gitlab.io/data.table/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">“数据帧”的扩展</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">data.table提供了base R的data.frame的高性能版本，并增强了语法和功能，以便于…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">rdatatable.gitlab.io</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://dplyr.tidyverse.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">数据操作的语法</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">一个快速、一致的工具，用于在内存中和内存外处理类似数据帧的对象。</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">dplyr.tidyverse.org</p></div></div><div class="om l"><div class="os l oo op oq om or ks od"/></div></div></a></div></div></div>    
</body>
</html>