<html>
<head>
<title>Python 3.9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.9</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-3-9-9c2ce1332eb4?source=collection_archive---------3-----------------------#2020-10-02">https://towardsdatascience.com/python-3-9-9c2ce1332eb4?source=collection_archive---------3-----------------------#2020-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef1a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有什么新的，下一步是什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bb8d3c6ee7b81249ad8c6f6257132f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lG7s6Lf_SiRpxtti"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@fabiolucas_foto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比奥·卢卡斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ad1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">Python 3.9的完整版本发布了！</strong></p><p id="856b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，这个版本标志着Python进化旧路线的一个转折点，走上了一条新的道路。我们将涵盖:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8c3c" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&gt; Python's New Path</strong><br/>  - Parser change<br/>  - Development cycles</span><span id="adbe" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&gt; New Features</strong><br/>  - Type Hinting<br/>  - String Methods<br/>  - Dictionary Unions</span></pre><p id="aeb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探索这些新特性，了解Python的发展方向。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="57e6" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Python的新路径</h1><p id="c03e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这次更新中有两个重要的变化，我们看不到任何直接的影响——但我们将开始注意到Python作为一种语言的略微不同的演变。</p><p id="bb7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这归结为:</p><ul class=""><li id="afb5" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">Python的解析器限制</li><li id="8d57" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">更小但更频繁的发布</li></ul><h2 id="87bd" class="ma mb it bd mp ny nz dn mt oa ob dp mx li oc od mz lm oe of nb lq og oh nd oi bi translated">LL(1)和PEG</h2><p id="1eb9" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">大约30年前，<a class="oj ok ep" href="https://medium.com/u/1ecea0006127?source=post_page-----9c2ce1332eb4--------------------------------" rel="noopener" target="_blank">吉多·范·罗苏姆</a>写了pgen。为Python编写的第一批代码之一——它至今仍被用作Python的解析器[1]。</p><p id="09b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pgen使用基于LL(1)的语法的变体。这意味着我们的解析器从上到下、从左到右地读取代码，只对一个标记进行前瞻。</p><p id="765d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实质上意味着Python开发受到了限制，因为:</p><ul class=""><li id="0733" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">一个标记的前瞻限制了语法规则的表达能力。</li><li id="52b3" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">Python已经包含了非LL(1)语法，这意味着当前的解析器使用了大量的变通方法，使过程过于复杂。</li><li id="5e9d" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">即使有这些变通办法，也只能做到这一点。规则可以变通，但不能破坏。</li><li id="4370" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">对于LL(1)，特定的左递归语法会导致解析树中的无限循环，从而导致堆栈溢出——正如这里的<a class="oj ok ep" href="https://medium.com/u/1ecea0006127?source=post_page-----9c2ce1332eb4--------------------------------" rel="noopener" target="_blank">吉多·范·罗苏姆</a>T12所解释的。</li></ul><p id="6bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于LL(1)的解析器的这些属性限制了Python中的能力。</p><p id="0975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3.9已经突破了这些限制，这要感谢一个闪亮的新<strong class="lb iu"> PEG </strong>解析器，在<a class="ae ky" href="https://www.python.org/dev/peps/pep-0617/" rel="noopener ugc nofollow" target="_blank"> PEP 617 </a>中有概述。</p><p id="fd07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">立刻，我们不会注意到这一点。在Python 3.10之前，不会利用新的解析器进行任何更改。但在那之后，这种语言将被从它的枷锁中释放出来。</p><h2 id="1f5e" class="ma mb it bd mp ny nz dn mt oa ob dp mx li oc od mz lm oe of nb lq og oh nd oi bi translated">开发周期</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/fd8bfa77327d98e678b884ee2ce7a8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBom5-3nZyOjvwvSIvGYEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python发布时间表，它将从18个月的发布时间表切换到12个月。</p></figure><p id="8564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在3.9之前，Python的发布时间表是18个月。现在，我们看到了向12个月发布时间表的转变。</p><p id="f30d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在每年都会看到新版本的Python，而不是一年半一次。这意味着:</p><ul class=""><li id="52d8" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">就新特性而言，发行版更小。</li><li id="cabc" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">变化更为渐进，但通过更快地发布新功能和修复程序来获益。</li><li id="f27b" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">更加一致的发布日历。我们现在知道新的Python将在每年十月到来！</li></ul><p id="9f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，本质上，我们在这里看到的是在12个月的周期内专注于较小的增量变化，而不是每18个月的较大变化。与此同时，发展速度预计将保持不变。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="43d6" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">新功能</h1><p id="2fab" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">除了这些幕后的变化，我们还可以看到一些新的Python特性！</p><h2 id="9bf0" class="ma mb it bd mp ny nz dn mt oa ob dp mx li oc od mz lm oe of nb lq og oh nd oi bi translated">类型提示</h2><p id="db94" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">早在2008年，Python 3引入了函数注释——类型提示的前身。它不是特别健壮，但它是一个开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/477b33df7809679d3ae3e54f9c845c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deuUc8tlaYJ31L_C_EuwXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中类型提示的当前状态是随着时间的推移，对注释和类型的许多添加和修改的累积结果。</p></figure><p id="1a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，随着时间的推移，更多的功能被添加进来。但是现在，3.9将所有这些不同的特性和一个整洁的新语法结合在一起，产生了Python类型提示的最新发展。</p><p id="db4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地指定变量的预期数据类型。如果我们写了一些没有意义的东西(比如我们把一个字符串传递给一个整数)，那么我们的编辑器会标记这个问题。</p><p id="313f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不会出现任何错误(不幸的是)，但是在处理复杂的代码库时，它非常有用。让我们来看看新的语法。</p><p id="cb0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，用<code class="fe on oo op lw b">+</code>将两个字符串加在一起绝对有效。因此，在这个<code class="fe on oo op lw b">add_int</code>函数接收两个字符串的情况下，不会出现错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/38359e354a4bc0efa193ac67edd46b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bEajxyjGKNdSlL4T.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无类型提示(左)，Python 3.9 <strong class="bd or">带</strong>类型提示(右)。</p></figure><p id="2027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了新的类型提示功能，我们只需在函数定义中将<code class="fe on oo op lw b">: int</code>添加到我们的参数中，我们的编辑器就会立即注意到这个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/d9e60e58275f74aeb24005b885c42cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2azw6uemqgj3IJ3y.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指定预期的输入和输出数据类型。</p></figure><p id="1ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<code class="fe on oo op lw b">-&gt; type</code>语法来确定函数输出的值的类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/cfbe637683b0a49f3b4525fb5342fa51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1sDyr33P_loWAzfa.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以将不同的类型结合起来创建更复杂的注释。</p></figure><p id="6007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也不局限于简单的预定义类型！</p><h2 id="e2eb" class="ma mb it bd mp ny nz dn mt oa ob dp mx li oc od mz lm oe of nb lq og oh nd oi bi translated">字符串方法</h2><p id="fd61" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">也许不像其他变化那样华丽，但我看到它被大量使用。我们有两种新方法来删除字符串前缀和后缀:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0dfe" class="ma mb it lw b gy mc md l me mf">"foo bar".remove<strong class="lw iu">prefix</strong>("fo")</span></pre><p id="2317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op lw b"><strong class="lb iu">[Out]</strong>: 'o bar'</code></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5a19" class="ma mb it lw b gy mc md l me mf">"foo bar".remove<strong class="lw iu">suffix</strong>("ar")</span></pre><p id="8cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op lw b"><strong class="lb iu">[Out]</strong>: 'foo b'</code></p><h2 id="2b9b" class="ma mb it bd mp ny nz dn mt oa ob dp mx li oc od mz lm oe of nb lq og oh nd oi bi translated">字典联盟</h2><p id="169f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们现在有两个新的操作符来执行字典联合。</p><p id="75eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是合并操作符<code class="fe on oo op lw b">|</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="81c5" class="ma mb it lw b gy mc md l me mf">a = {1: <strong class="lw iu">'a'</strong>, 2: <strong class="lw iu">'b'</strong>, 3: <strong class="lw iu">'c'</strong>}<br/>b = {4: <strong class="lw iu">'d'</strong>, 5: <strong class="lw iu">'e'</strong>}</span><span id="2e99" class="ma mb it lw b gy mg md l me mf">c = <strong class="lw iu">a | b</strong><br/>print(c)</span></pre><p id="0bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op lw b">[Out]: {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}</code></p><p id="9434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及<strong class="lb iu">更新</strong>操作符，执行合并<strong class="lb iu">就地</strong>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2e21" class="ma mb it lw b gy mc md l me mf">a = {1: 'a', 2: 'b', 3: 'c'}<br/>b = {4: 'd', 5: 'e'}</span><span id="4ca8" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">a |= b</strong><br/>print(a)</span></pre><p id="06cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op lw b">[Out]: {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}</code></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="4210" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">有很多值得期待的</h1><p id="dd30" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">作为一门语言，Python的未来有很多值得期待的地方。看到这种语言如何随着新的发布时间表和解析器而发展将是非常有趣的。</p><p id="8fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击这里获取下载链接！</p><p id="7c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题或建议，请在<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中告诉我。如果你想知道更多类似的内容，我也会在YouTube上发布。</p><p id="7abb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="2592" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><p id="2ff5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">[1]吉多·范·罗苏姆，<a class="ae ky" href="https://medium.com/@gvanrossum_83706/peg-parsers-7ed72462f97c" rel="noopener"> PEG解析器</a> (2019)。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="8b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对Python感兴趣——你可能会喜欢我的使用Docker将Python APIs部署到Google Cloud的指南:</p><div class="os ot gp gr ou ov"><a rel="noopener follow" target="_blank" href="/deploy-apis-with-python-and-docker-4ec5e7986224"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">用Python和Docker部署API</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">使用Flask、Docker和Google Cloud部署API的权威指南</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div><p id="104c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pk">*所有图片均由作者制作，除非另有说明。</em></p></div></div>    
</body>
</html>