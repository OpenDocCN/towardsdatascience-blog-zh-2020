<html>
<head>
<title>Boosting Python Scripts With Cython (Applied on Raspberry Pi)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Cython提升Python脚本(应用于Raspberry Pi)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/boosting-python-scripts-with-cython-applied-on-raspberry-pi-5ea191292e68?source=collection_archive---------7-----------------------#2020-10-21">https://towardsdatascience.com/boosting-python-scripts-with-cython-applied-on-raspberry-pi-5ea191292e68?source=collection_archive---------7-----------------------#2020-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2b15" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Cython将Python代码加速数千倍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bebc3aaac645e0583b05c3bc93fc0028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khPMvPhoN9_f8vMMTwsW-g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">比尔·杰伦:【https://unsplash.com/photos/NVWyN8GamCk】T2</p></figure><p id="407f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python可能是当今最流行的编程语言之一，但它肯定不是最高效的。特别是在机器学习领域，从业者为了Python提供的易用性牺牲了效率。</p><p id="9bd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这并不意味着你不能用其他方法加快速度。Cython是一种显著减少Python脚本计算时间的简单方法，而不会牺牲使用Python轻松实现的功能。</p><p id="4eae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程将向您介绍如何使用Cython来加速Python脚本。我们将看到一个简单但计算量很大的任务:为循环创建一个<em class="ls">，该循环遍历一个包含10亿个数字的Python列表，并对它们求和。由于在资源有限的设备上运行代码时，时间尤其重要，我们将通过考虑如何在Raspberry Pi (RPi)上的Cython中实现Python代码来考虑这个问题。Cython显著提高了计算速度。把它想象成树懒和猎豹的比较。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/03a605f5a1beb205990e4da0f08f9f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqDo12mqkPzNkKA40jLwnQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">今日印度<a class="ae kv" href="https://www.indiatoday.in/education-today/gk-current-affairs/story/slowest-animals-261003-2015-09-03" rel="noopener ugc nofollow" target="_blank">的树懒图片</a>| pix abay的猎豹图片<a class="ae kv" href="https://pixabay.com/photos/cheetah-africa-namibia-cat-run-2859581" rel="noopener ugc nofollow" target="_blank"/></p></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="a6d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">本文原载于</strong> <a class="ae kv" href="https://blog.paperspace.com/boosting-python-scripts-cython" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Paperspace博客</strong> </a> <strong class="ky ir">。你可以在渐变</strong>  <strong class="ky ir">上免费运行我的教程的代码</strong> <a class="ae kv" href="https://gradient.paperspace.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">。</strong></a></p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="1179" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程涵盖的部分如下:</p><ul class=""><li id="6a12" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">Python、CPython和Cython</li><li id="5816" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">简化Python代码</li><li id="102c" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">为回路鸣音一个<em class="ls"/></li><li id="8701" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">将C数据类型赋给变量</li><li id="b702" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">Cython在树莓派中的应用</li></ul><p id="77ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧。</p><h1 id="e380" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">Python和CPython</h1><p id="84af" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">许多人没有意识到这样一个事实，即像Python这样的语言实际上是用其他语言实现的。比如Python的C实现叫做<strong class="ky ir"> CPython </strong>。注意不是<strong class="ky ir"> Cython </strong>。<strong class="ky ir"> </strong>关于Python不同实现的更多信息，你可以阅读<a class="ae kv" href="https://www.toptal.com/python/why-are-there-so-many-pythons" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="b58f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python的默认和最流行的实现是CPython。使用它有一个重要的优点。c是一种编译语言，它的代码被转换成机器代码，由中央处理器(CPU)直接执行。现在你可能会想，如果C是一种编译语言，那是不是意味着Python也是？</p><p id="8e48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">C (CPython)中的Python实现不是100%编译的，也不是100%解释的。在运行Python脚本的过程中，既有编译也有解释。为了说明这一点，让我们来看看运行Python脚本的步骤:</p><ol class=""><li id="98c5" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr nm mh mi mj bi translated">使用CPython编译源代码以生成字节码</li><li id="b7ba" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr nm mh mi mj bi translated">在CPython解释器中解释字节码</li><li id="e68f" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr nm mh mi mj bi translated">在CPython虚拟机中运行CPython解释器的输出</li></ol><p id="7c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当CPython编译源代码(.py文件)来生成CPython字节码(.pyc文件)。CPython字节码(。pyc文件)然后使用CPython解释器进行解释，输出在CPython虚拟机上运行。根据上面的步骤，运行Python脚本的过程包括编译和解释。</p><p id="2167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CPython编译器只生成一次字节码，但是每次代码运行时都会调用解释器。通常字节码的解释要花很多时间。如果使用解释器会降低执行速度，为什么还要使用它呢？最大的原因是它有助于Python跨平台。因为字节码运行在CPU之上的CPython虚拟机中，所以它独立于运行它的机器。因此，字节码可以在不同的机器上运行而不发生变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/8bcc8b643ab67f8c0766fde4984048fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnQQ9eKNdj54Bv6eU6tyUQ.jpeg"/></div></div></figure><p id="4e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有使用解释器，那么CPython编译器将生成直接在CPU中运行的机器码。因为不同的平台有不同的指令，所以代码不会跨平台。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/141721dc339c0f427ee0496b2e00dfda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cu0IaSlAyRdCYOOibVdqfg.jpeg"/></div></div></figure><p id="c722" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，使用编译器加快了这个过程，但是解释器使代码跨平台。所以，Python比C慢的一个原因是使用了解释器。记住编译器只运行一次，但是每次代码执行时解释器都会运行。</p><p id="b46a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python比C慢得多，但许多程序员仍然喜欢它，因为它更容易使用。Python对程序员隐藏了许多细节，这有助于防止令人沮丧的调试。例如，因为Python是一种动态类型语言，所以您不必在代码中显式指定每个变量的类型——Python会自动推导出它的类型。相反，对于静态类型的语言(如C、C++或Java ),您必须指定变量的类型，如下所示。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="0bd8" class="nu mq iq nq b gy nv nw l nx ny">int x = 10 <br/>string s = "Hello"</span></pre><p id="8eb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将它与下面的Python实现进行比较。动态类型化使编码更容易，但是增加了机器寻找合适的数据类型的负担。这使得该过程更慢。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="9d73" class="nu mq iq nq b gy nv nw l nx ny">x = 10<br/>s = "Hello"</span></pre><p id="76d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，像Python这样的“高级”语言对开发者来说更容易使用。然而，当代码运行时，它需要被转换成低级指令。这种转换需要更多的时间，这是为了易于使用而牺牲的。</p><p id="715f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果时间是一个重要的因素，那么你需要使用低级指令。因此，您可以使用CPython编写代码，而不是使用Python(这是一种接口)来键入代码，CPython是用C实现的Python的后端。但是，如果您这样做，您会觉得您是在用C而不是Python编程。</p><p id="28a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">CPython要复杂得多。在CPython中，一切都是用C实现的。在编码中没有办法逃避C的复杂性。这就是为什么许多开发者选择Cython而不是T1的原因。但是Cython和CPython有什么不同呢？</p><h1 id="788c" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">Cython与众不同</h1><p id="b43c" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">根据<a class="ae kv" href="https://cython.readthedocs.io/en/latest/src/tutorial/cython_tutorial.html" rel="noopener ugc nofollow" target="_blank"> Cython文档</a>，Cython是C数据类型的Python。来自<a class="ae kv" href="http://conference.scipy.org/proceedings/SciPy2009/paper_1" rel="noopener ugc nofollow" target="_blank"> Cython tutorial 2009论文</a>的另一个定义阐明:</p><blockquote class="nz oa ob"><p id="467e" class="kw kx ls ky b kz la jr lb lc ld ju le oc lg lh li od lk ll lm oe lo lp lq lr ij bi translated">Cython是一种基于Python的编程语言，具有额外的语法来提供静态类型声明。这充分利用了Python的优势，同时允许用户达到c语言的速度</p></blockquote><p id="df7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据上面的定义，Cython是一种让你拥有两个世界的最好的语言——速度和易用性。您仍然可以用Python编写常规代码，但是为了在运行时加快速度，Cython允许您用c语言替换Python代码的某些部分。因此，您最终会将两种语言混合在一个文件中。请注意，您可以想象Python中的一切在Cython中都是有效的，但有一些限制。有关限制的更多信息，您可以访问<a class="ae kv" href="https://cython.readthedocs.io/en/latest/src/userguide/limitations.html#cython-limitations" rel="noopener ugc nofollow" target="_blank">本页</a>。</p><p id="fcc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">常规Python文件的扩展名为. py，但Cython文件的扩展名为。改为pyx扩展名。相同的Python代码可以编写在。pyx文件，但是这些文件也允许您使用Cython代码。请注意，与直接运行Python代码相比，仅将Python代码放入. pyx文件中可能会加快速度，但不如声明变量类型时快。因此，本教程的重点不仅仅是在。pyx文件，但也进行编辑，这将使它运行得更快。通过这样做，我们给编程增加了一点难度，但是这样做节省了很多时间。如果你有C语言编程的经验，那么对你来说会更容易。</p><h1 id="ebb3" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">简化Python代码</h1><p id="4e90" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">要将Python转换成Cython，首先需要用<strong class="ky ir">创建一个文件。pyx </strong>分机而不是<strong class="ky ir">。py </strong>分机。在这个文件中，你可以从编写常规的Python代码开始(注意，Cython接受的Python代码有一些限制，在<a class="ae kv" href="https://cython.readthedocs.io/en/latest/src/userguide/limitations.html#cython-limitations" rel="noopener ugc nofollow" target="_blank"> Cython文档</a>中已经阐明)。</p><p id="763f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在继续之前，请确保安装了Cython。您可以使用以下命令来完成此操作。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="f241" class="nu mq iq nq b gy nv nw l nx ny">pip install cython</span></pre><p id="bb07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来生成。pyd/。所以我们需要首先构建Cython文件。的。pyd/。所以file表示稍后要导入的模块。为了构建Cython文件，将使用setup.py文件。创建这个文件，并将下面的代码放入其中。我们将使用distutils.core.setup()函数来调用Cython。Build.cythonize()函数，该函数将。pyx文件。该函数接受您想要cythonize的文件的路径。这里我假设setup.py文件与test_cython.pyx文件放在同一个位置。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="12b7" class="nu mq iq nq b gy nv nw l nx ny">import distutils.core <br/>import Cython.Build </span><span id="910f" class="nu mq iq nq b gy of nw l nx ny">distutils.core.setup(ext_modules = Cython.Build.cythonize("test_cython.pyx"))</span></pre><p id="8c6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了构建Cython文件，在命令提示符下发出下面的命令。命令提示符的当前目录应该与setup.py文件的目录相同。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8f69" class="nu mq iq nq b gy nv nw l nx ny">python setup.py build_ext --inplace</span></pre><p id="abb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令完成后，两个文件将被放在。pyx文件。第一个有。c扩展名，而另一个文件将具有该扩展名。pyd(或类似的，基于使用的操作系统)。为了使用生成的文件，只需导入test_cython模块，就会直接出现“Hello Cython”消息，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/66ac4da7fe9a7cc592814b897eb6ba3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*bFmxZ-qHw7SUPYh_IaRlHg.jpeg"/></div></figure><p id="c289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在已经成功地将Python代码细胞化了。下一节将讨论如何创建一个. pyx文件，并在其中创建循环。</p><h1 id="9361" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">将“for”循环变成Cythonizing</h1><p id="9c05" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">现在让我们优化我们前面提到的任务:一个<em class="ls"> for </em>循环，它遍历100万个数字并将它们相加。让我们从查看循环迭代的效率开始。导入时间模块是为了估计执行需要多长时间。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="2a9e" class="nu mq iq nq b gy nv nw l nx ny">import time</span><span id="c550" class="nu mq iq nq b gy of nw l nx ny">cdef unsigned long long int maxval<br/>cdef unsigned long long int total<br/>cdef int k<br/>cdef double t1, t2, t</span><span id="49ac" class="nu mq iq nq b gy of nw l nx ny">maxval = 1000000000<br/>t1=time.time()</span><span id="c446" class="nu mq iq nq b gy of nw l nx ny">for k in range(maxval):<br/>    total = total + k<br/>print "Total =", total</span><span id="6aff" class="nu mq iq nq b gy of nw l nx ny">t2=time.time()<br/>t = t2-t1<br/>print("%.10f" % t)</span></pre><p id="eeb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在. pyx文件中，3次运行的平均时间是0.0281秒。代码运行在配备酷睿i7–6500 u CPU @ 2.5 GHz和16 GB DDR3 RAM的机器上。</p><p id="6553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将它与运行一个普通Python文件所需的时间进行比较，后者的平均值为0.0411秒。这意味着仅在迭代方面，Cython就比Python快1.46倍，尽管我们不需要修改循环的<em class="ls">来让它以C速度执行。</em></p><p id="53c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们添加求和任务。为此，我们将使用range()函数。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="09a8" class="nu mq iq nq b gy nv nw l nx ny">import time<br/>t1 = time.time()</span><span id="4bad" class="nu mq iq nq b gy of nw l nx ny">total = 0<br/>for k in range(1000000):<br/>    total = total + k<br/>print "Total =", total</span><span id="c018" class="nu mq iq nq b gy of nw l nx ny">t2 = time.time()<br/>t = t2-t1<br/>print("%.100f" % t)</span></pre><p id="9f9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这两个脚本返回相同的值，即499999500000。在Python中，平均运行时间为0.1183秒(三次试验之间)。在Cython中，它的速度快了1.35倍，平均为0.0875秒。</p><p id="b1f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看另一个例子，循环从0开始遍历10亿个数字。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="a5a7" class="nu mq iq nq b gy nv nw l nx ny">import time<br/>t1 = time.time()</span><span id="cd02" class="nu mq iq nq b gy of nw l nx ny">total = 0<br/>for k in range(1000000000):<br/>    total = total + k<br/>print "Total =", total</span><span id="a391" class="nu mq iq nq b gy of nw l nx ny">t2 = time.time()<br/>t = t2-t1<br/>print("%.20f" % t)</span></pre><p id="c1f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Cython脚本完成了将近85秒(1.4分钟)，而Python脚本完成了将近115秒(1.9分钟)。在这两种情况下，时间都太长了。如果在如此琐碎的任务上持续超过一分钟，那么使用Cython的好处是什么？注意这是我们的错，不是Cython的。</p><p id="b846" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，在Cython中编写Python代码。pyx脚本是一个改进，但是它并没有大幅减少执行时间。我们必须在Cython脚本中编辑Python代码。首先要关注的是明确定义所用变量的数据类型。</p><h1 id="bf80" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">将C数据类型赋给变量</h1><p id="a8d3" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">根据前面的代码，使用了5个变量:<em class="ls"> total，k，t1，t2 </em>，<em class="ls">T5<em class="ls">t</em>。所有这些变量的数据类型都是由代码隐式推导出来的，因此需要更多的时间。为了节省推断它们的数据类型的时间，让我们从C语言中指定它们的数据类型。</em></p><p id="b6f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> total </em>变量的类型是<strong class="ky ir">无符号long long int </strong>。它是一个整数，因为所有数字的总和是一个整数，它是无符号的，因为总和将是正数。但是为什么是<strong class="ky ir">长</strong>长呢？因为所有数字的和非常大，所以添加<strong class="ky ir"> long long </strong>以将变量大小增加到最大可能大小。</p><p id="0052" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为变量<em class="ls"> k </em>定义的类型为<strong class="ky ir"> int </strong>，为剩余的三个变量<em class="ls"> t1 </em>、<em class="ls"> t2 </em>和<em class="ls"> t </em>分配了<strong class="ky ir"> double </strong>类型。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="5af3" class="nu mq iq nq b gy nv nw l nx ny">import time</span><span id="85dc" class="nu mq iq nq b gy of nw l nx ny">cdef unsigned long long int total<br/>cdef int k<br/>cdef double t1, t2, t</span><span id="6e18" class="nu mq iq nq b gy of nw l nx ny">t1 = time.time()</span><span id="d1a8" class="nu mq iq nq b gy of nw l nx ny">for k in range(1000000000):<br/>    total = total + k<br/>print "Total =", total</span><span id="fb0d" class="nu mq iq nq b gy of nw l nx ny">t2 = time.time()<br/>t = t2-t1<br/>print("%.20f" % t)</span></pre><p id="570f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python需要超过1.9分钟，而Cython只需要0.00009346秒。</p><p id="fabf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经看到了如何通过使用Cython来提高Python脚本的性能，那么让我们将其应用到Raspberry Pi (RPi)中。</p><h1 id="ea91" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">从PC访问Raspberry Pi</h1><p id="a541" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">如果这是你第一次使用你的Raspberry Pi，那么你的PC和RPi都需要通过网络连接。为此，您可以将它们连接到一台交换机，在该交换机中，DHCP(动态主机配置协议)处于活动状态，以便自动为它们分配IP地址。成功创建网络后，您可以根据分配给它的IPv4地址访问RPi。您如何知道分配给您的RPi的IPv4地址是什么？别担心，你可以简单地使用一个IP扫描工具。在本教程中，我将使用一个名为<a class="ae kv" href="https://www.advanced-ip-scanner.com/" rel="noopener ugc nofollow" target="_blank">高级IP扫描器</a>的免费应用程序。</p><p id="a606" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序的界面如下所示。它接受要搜索的IPv4地址范围，并返回活动设备的信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/98ae7f1af6b3b1c3e3280b897caf8497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-rRtgx5w15yBypQtq7uhxw.jpeg"/></div></div></figure><p id="ef5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您需要输入本地网络中的IPv4地址范围。如果您不知道范围，只需在Windows中发出ipconfig命令(或在Linux中发出ifconfig)即可知道您的PC IPv4地址(如下图所示)。在我的例子中，分配给我的PC的Wi-Fi适配器的IPv4地址是192.168.43.177，子网掩码是255.255.255.0。这意味着网络中的IPv4地址范围是从192.168.43.1到192.168.43.255。如图所示，IPv4地址192.168.43.1被分配给网关。请注意，范围内的最后一个IPv4地址192.168.43.255是为广播消息保留的。因此，搜索范围应该从192.168.43.2开始，到192.168.43.254结束。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5664c6551235d4bfdab58b541358619d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*qTylWdDpNLq34E0PYjtEhw.jpeg"/></div></figure><p id="48e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据下图所示的扫描结果，分配给RPi的IPv4地址是192.168.43.63。此IPv4地址可用于创建安全外壳(SSH)会话。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/4a4b93f1ca5d96103f5c1abcf61e11c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eb4hscsF6RiEuOFymX8fAw.jpeg"/></div></div></figure><p id="be29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了建立SSH会话，我将使用一个名为<a class="ae kv" href="https://mobaxterm.mobatek.net/" rel="noopener ugc nofollow" target="_blank">的免费软件。应用程序的界面如下。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/8eb4835d15fd8d892f39ca0b4325c167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnqLdL6_ihihn5ie2mAigQ.jpeg"/></div></div></figure><p id="871b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了创建一个SSH会话，只需点击左上角的<strong class="ky ir">会话</strong>按钮。将出现一个新窗口，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/3538684606abb083c14399c1ec6a022c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUImuNiJx2pzEJ-aFP7dkQ.jpeg"/></div></div></figure><p id="3394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在该窗口中，单击左上角的SSH按钮，打开如下所示的窗口。只需输入RPi的IPv4地址和用户名(默认为Pi)，然后单击OK启动会话。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/fb0fff2ab08a16b6d0ce0796d7c7d28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVq18OaTIjr87lWg1Buv4Q.jpeg"/></div></div></figure><p id="b89c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单击OK按钮后，会出现一个新窗口，要求输入密码。默认密码是raspberrypi。登录后，将出现下一个窗口。左侧的窗格有助于轻松导航RPi的目录。还有一个用于输入命令的命令行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/27fdf74a7600ca0657d4c1e231b4fa2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6V1OV8fOpN4f3CX0o3Spg.jpeg"/></div></div></figure><h1 id="189a" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">将Cython与树莓Pi一起使用</h1><p id="7649" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">创建一个新文件，并将其扩展名设置为。pyx来编写最后一个例子的代码。左侧窗格的栏中有用于创建新文件和目录的选项。您可以使用“新建文件”图标使事情变得更加简单，如下图所示。我在RPi的根目录下创建了一个名为test_cython.pyx的文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/d29a2d5ac33249e9d5dddf7bfc9cf763.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*lsVTIxykoNooTWt0yheL_g.jpeg"/></div></figure><p id="6134" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需双击文件打开它，粘贴代码，并保存它。之后，我们可以创建<strong class="ky ir"> setup.py </strong>文件，这与我们之前讨论的完全相同。接下来，我们必须发出以下命令来构建Cython脚本。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="a70e" class="nu mq iq nq b gy nv nw l nx ny">python3 setup.py build_ext --inplace</span></pre><p id="5a2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令成功完成后，您可以根据下图找到左侧窗格中列出的输出文件。注意，要导入的模块的扩展现在是。因此，由于我们不再使用Windows。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/1e91555232d987330c79d632b01762ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*nfsvzo78VIChYKd7tl4Jvw.jpeg"/></div></figure><p id="f84b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们激活Python并导入模块，如下所示并运行Cython代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/855839f6ae12cbb1ec3e052a403114f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JvzX6vo54bQtslE5JssUA.jpeg"/></div></div></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="2e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">本文原载于</strong> <a class="ae kv" href="https://blog.paperspace.com/boosting-python-scripts-cython" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Paperspace博客</strong> </a> <strong class="ky ir">。你可以在渐变</strong>  <strong class="ky ir">上免费运行我的教程的代码</strong> <a class="ae kv" href="https://gradient.paperspace.com" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">。</strong></a></p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="6d87" class="mp mq iq bd mr ms oo mu mv mw op my mz jw oq jx nb jz or ka nd kc os kd nf ng bi translated">结论</h1><p id="81c1" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">本教程讨论了如何使用Cython来减少执行Python脚本的计算时间。我们看了使用一个<em class="ls"> for </em>循环对一个包含10亿个数字的Python列表中的所有元素求和的例子，并比较了声明变量类型和不声明变量类型的执行时间。虽然这在纯Python中运行需要将近两分钟，但使用Cython声明的静态变量运行基本上不需要时间。</p><p id="3ecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇教程中，我们将用NumPy数组替换这个Python列表，并看看如何使用Cython优化NumPy数组处理。然后，我们将看看如何将更高级的Python脚本(如遗传算法)进行cythonize。这是轻松提高机器学习项目效率的好方法。</p></div></div>    
</body>
</html>