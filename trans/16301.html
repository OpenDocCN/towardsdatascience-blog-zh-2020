<html>
<head>
<title>Zonal Statistics Algorithm with Python in 4 Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现4步分区统计算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/zonal-statistics-algorithm-with-python-in-4-steps-382a3b66648a?source=collection_archive---------19-----------------------#2020-11-10">https://towardsdatascience.com/zonal-statistics-algorithm-with-python-in-4-steps-382a3b66648a?source=collection_archive---------19-----------------------#2020-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0efe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何汇总面区域的栅格数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca52731daf38411adcd62edc53a2268a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5JcfgGMFUjUUz_ql"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土银行</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ef63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常需要汇总不规则形状区域内网格化数据集的信息。虽然乍一看这似乎很简单，但调和栅格(格网)和矢量(面)数据类型之间的差异可能会很快变得复杂。本文展示了如何通过4个步骤用Python实现区域统计算法。</p><ol class=""><li id="d491" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">加载栅格数据和矢量多边形</li><li id="c89a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">栅格化面要素</li><li id="bf57" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将输入数据掩膜到面范围</li><li id="8555" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">计算面范围的分区统计数据</li></ol><h1 id="5795" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.加载栅格数据和矢量多边形</h1><p id="91a6" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">首先导入必要的Python模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="23fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在设置光栅和矢量数据的文件路径，并使用<code class="fe ni nj nk nl b">gdal</code>和<code class="fe ni nj nk nl b">ogr</code>分别加载光栅和矢量数据。从已加载的矢量数据源访问包含面数据的图层。然后获取地理变换信息(定位网格化栅格数据并指定像元大小),而不获取栅格数据的数据值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还要用<code class="fe ni nj nk nl b">gdal</code>和<code class="fe ni nj nk nl b">ogr</code>做一些设置，为确定栅格和矢量多边形之间的重叠做准备。让<code class="fe ni nj nk nl b">gdal</code>和<code class="fe ni nj nk nl b">ogr</code>驱动程序在内存中创建临时光栅和矢量图层，并为临时shapefile设置名称。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="c7b7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2.栅格化面要素</h1><p id="613c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">加载栅格和矢量数据后，就该确定它们重叠的地方了。这将是算法中最复杂和最密集的部分。首先，从矢量图层读取第一个面要素。然后开始一个<code class="fe ni nj nk nl b">while</code>循环，只要矢量层中还有另一个特征，循环就会继续。下面是设置循环的基本方法。随着我们的继续，这个循环将被修改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建一些函数来帮助我们创建一个新的栅格来存储栅格化的面要素。当我们用实际数据调用这些函数时，它们会更有意义。现在，在脚本的顶部添加函数定义。首先，我们需要将包含面要素的边界框的坐标转换为与输入栅格相对应的像元坐标或偏移量(行号和列号)。面的边界框是包含整个面要素的矩形，它由最小和最大X和Y坐标组成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="de86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来编写一个函数，用上面函数中计算的像元偏移量创建一个新的GeoTransform。这两个函数将允许我们创建一个新的更小的栅格，该栅格仅覆盖由面要素重叠的区域。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="fe23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是算法中最复杂的部分:在内存中创建新的空栅格，并将面要素转换为栅格。按照下面代码片段中的注释来理解每一行代码的作用。你可能还会发现查看<a class="ae ky" href="https://live.osgeo.org/en/quickstart/gdal_quickstart.html" rel="noopener ugc nofollow" target="_blank"> GDAL和OGR文档</a>很有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="b3b6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3.将输入数据掩膜到面区域</h1><p id="a645" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">此时我们有两个并发的(重叠的)<code class="fe ni nj nk nl b">numpy</code>数组:<code class="fe ni nj nk nl b">tr_array</code>和<code class="fe ni nj nk nl b">r_array</code>。<code class="fe ni nj nk nl b">tr_array</code>值为1，表示多边形已栅格化的位置。<code class="fe ni nj nk nl b">r_array</code>包含我们要用来计算每个面的分区统计数据的值。</p><p id="2aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，确保输入栅格存在。接下来创建一个遮罩数组。我们希望从<code class="fe ni nj nk nl b">r_array</code>获取数据，其中不包含无数据值，并且<code class="fe ni nj nk nl b">tr_array</code>中的相应值等于1(或<code class="fe ni nj nk nl b">True</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将使用<code class="fe ni nj nk nl b">maskarray</code>来计算每个面要素的区域统计数据。</p><h1 id="51c3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">4.计算每个面范围的分区统计数据</h1><p id="63e0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">再编写一个函数，它接受一些值作为输入，并创建一个值的字典。将此函数与其他函数一起放在区域统计脚本的顶部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e23b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，计算来自<code class="fe ni nj nk nl b">maskarray</code>的值，并将它们传递给<code class="fe ni nj nk nl b">setFeatureStats</code>函数。仅当阵列存在时才这样做(<code class="fe ni nj nk nl b">is not None</code>)。否则，传递no data值来设置统计信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="8c96" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="94a4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">恭喜你！您已经创建了可应用于许多不同应用程序的Python区域统计脚本。以下是完整的脚本。使用自定义的区域统计算法可以让您在使用结果时更加灵活。从这一点来看，很容易将字典列表转换为pandas数据帧进行分析，导出到csv，或者在原始shapefile中创建新字段并将统计数据直接添加到原始数据中。这可以加快、简化和定制您的工作流程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="99e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">原载于2020年11月10日https://opensourceoptions.com</em><a class="ae ky" href="https://opensourceoptions.com/blog/zonal-statistics-algorithm-with-python-in-4-steps/" rel="noopener ugc nofollow" target="_blank"><em class="nt"/></a><em class="nt">。</em></p></div></div>    
</body>
</html>