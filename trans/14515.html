<html>
<head>
<title>A Gentle Introduction To Math Behind Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">神经网络背后的数学简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-math-behind-neural-networks-e8b60dbbdeba?source=collection_archive---------0-----------------------#2020-10-07">https://towardsdatascience.com/introduction-to-math-behind-neural-networks-e8b60dbbdeba?source=collection_archive---------0-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f9db2ffb5c3053d0d28a0281b0d575f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Kn68RFH0QMQ7gPSpulh0A.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由作者使用<a class="ae jd" href="https://www.diagrams.net/" rel="noopener ugc nofollow" target="_blank"><em class="je"/></a>创建</p></figure><div class=""/><div class=""><h2 id="dd63" class="pw-subtitle-paragraph ke jg jh bd b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv dk translated">让我们深入研究神经网络和深度学习背后的数学</h2></div><p id="69da" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，通过开源机器学习软件库，如<a class="ae jd" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>、<a class="ae jd" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>或<a class="ae jd" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>，我们可以只用几行代码创建一个神经网络，即使结构非常复杂。话虽如此，神经网络背后的数学对我们一些人来说仍然是一个谜，拥有神经网络和深度学习背后的数学知识可以帮助我们理解神经网络内部发生的事情。它也有助于架构选择、深度学习模型的微调、超参数调整和优化。</p><h1 id="c2ac" class="ls lt jh bd lu lv lw lx ly lz ma mb mc kn md ko me kq mf kr mg kt mh ku mi mj bi translated">介绍</h1><p id="2901" class="pw-post-body-paragraph kw kx jh ky b kz mk ki lb lc ml kl le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">很长一段时间，我忽略了理解神经网络和深度学习背后的数学，因为我没有很好的代数或微积分知识。几天前，我决定从头开始，推导神经网络和深度学习背后的方法论和数学，以了解它们如何以及为什么工作。我也决定写这篇文章，对我这样觉得很难理解这些概念的人会有用。</p><h1 id="ac55" class="ls lt jh bd lu lv lw lx ly lz ma mb mc kn md ko me kq mf kr mg kt mh ku mi mj bi translated">感知器</h1><p id="7c09" class="pw-post-body-paragraph kw kx jh ky b kz mk ki lb lc ml kl le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">感知机——由Frank Rosenblatt <strong class="ky ji"> </strong>于1958年发明，是最简单的神经网络，由<em class="mp"> n </em>个输入、仅一个神经元和一个输出组成，其中<em class="mp"> n </em>是我们数据集的特征数量。通过神经网络传递数据的过程被称为前向传播，在感知器中执行的前向传播在以下三个步骤中解释。</p><p id="68ad" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ji">第一步</strong>:对于每一次输入，将输入值<strong class="ky ji"> xᵢ </strong>与权重<strong class="ky ji"> wᵢ <em class="mp"> </em> </strong>相乘，并将所有相乘后的值相加。权重——代表神经元之间连接的强度，并决定给定输入对神经元输出的影响程度。如果权重w₁的值大于权重w₂，则输入x₁对输出的影响将大于w₂.</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/b0dfca9225a4767d532a4ca23d782bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*Navmq_99Grhv14UG.png"/></div></figure><p id="90d9" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输入和权重的行向量分别为x = [x₁，x₂，…，xₙ]和w <em class="mp"> = </em> [w₁，w₂，…，wₙ】，它们的<a class="ae jd" href="https://en.wikipedia.org/wiki/Dot_product#Algebraic_definition" rel="noopener ugc nofollow" target="_blank"> <em class="mp">点积</em> </a> <em class="mp"> </em>由下式给出</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/986fd91ce29c7b211748ed7e39b39a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*NU9Yt1R28IergsnK.png"/></div></figure><p id="aab8" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，总和等于矢量<em class="mp"> x </em>和<em class="mp"> w </em>的<em class="mp">点积</em></p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/3faf6f710228a002ad7bc8f6e0270747.png" data-original-src="https://miro.medium.com/v2/resize:fit:220/format:webp/0*FZn9l3M6obcYb5s-.png"/></div></figure><p id="481c" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ji">第二步</strong>:将偏差<strong class="ky ji"> b </strong>加到相乘值的总和上，我们称之为<em class="mp"> z </em>。大多数情况下，偏置(也称为失调)是必需的，它将整个激活函数向左或向右移动，以产生所需的输出值。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/29ccb792d412a53ad0f7b5fdf1eb38f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:270/format:webp/0*fqZ_MzrTbNRu-DEZ.png"/></div></figure><p id="2ccb" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ji">步骤3 </strong>:将<em class="mp"> z </em>的值传递给一个非线性激活函数。激活函数——用于将非线性引入神经元的输出，没有激活函数，神经网络将只是一个线性函数。此外，它们对神经网络的学习速度有重大影响。感知器具有<em class="mp">二元阶跃函数</em>作为其激活函数。然而，我们将使用s <em class="mp"> igmoid — </em>也称为<em class="mp">逻辑</em>函数作为我们的激活函数。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a9a7b7de11201e3e2011e5d3afac0671.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/0*1XFKTD_3jJshI-kd.png"/></div></figure><p id="6166" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<strong class="ky ji"> σ </strong>表示s <em class="mp"> igmoid </em>激活函数，正向延拓后得到的输出称为<em class="mp">预测值</em>t28】ŷ。</p><h1 id="9daf" class="ls lt jh bd lu lv lw lx ly lz ma mb mc kn md ko me kq mf kr mg kt mh ku mi mj bi translated">学习算法</h1><p id="c70b" class="pw-post-body-paragraph kw kx jh ky b kz mk ki lb lc ml kl le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">学习算法由两部分组成——反向传播和优化。</p><p id="91b1" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ji">反向传播:</strong>反向传播，简称<em class="mp">误差反向传播</em>，是指计算损失函数相对于权重的梯度的算法。然而，该术语通常用于指代整个学习算法。在感知器中执行的反向传播在以下两个步骤中解释。</p><p id="10ae" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ji">步骤1 </strong>:使用<em class="mp">损失函数</em>来估计我们离期望的解决方案有多远。通常，回归问题选择<em class="mp">均方误差</em>作为损失函数，分类问题选择<em class="mp">交叉熵</em>。让我们来看一个回归问题，它的损失函数是均方误差，它是<em class="mp">实际值</em> (yᵢ)和<em class="mp">预测值</em> ( ŷᵢ)之差的平方。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/19cdc382fd05a0ef218f33231070cf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/0*sO34-qcRhQq3StPh.png"/></div></figure><p id="b407" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为整个训练数据集计算损失函数，并且它们的平均值被称为<em class="mp">成本函数</em> <strong class="ky ji"> C </strong>。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ff7a1580a76fc6eba05ad63e0d70e8ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/0*Guvo3nnu5TJx97oi.png"/></div></figure><p id="a3ba" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了给我们的感知机找到最佳的权重和偏差，我们需要知道成本函数是如何随着权重和偏差而变化的。这是在<em class="mp">梯度</em> s ( <em class="mp">变化率)</em>的帮助下完成的——一个量如何相对于另一个量变化。在我们的例子中，我们需要找到成本函数相对于权重和偏差的梯度。</p><p id="71b1" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用<em class="mp">偏导数计算成本函数<strong class="ky ji"> C </strong>相对于权重<strong class="ky ji"> wᵢ </strong>的梯度。</em>由于成本函数与权重wᵢ没有直接关系，我们使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Chain_rule" rel="noopener ugc nofollow" target="_blank">链式法则</a>。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/227250079a2828c9bb81c527ee5153c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/0*rmQ7VZAIWfryV9Vj.png"/></div></figure><p id="c9f9" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要找到以下三个梯度</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/524e8a0a19e31de2939b58465fc7856f.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*4M6OmjEC--_V6okT.png"/></div></figure><p id="ff7d" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从c <em class="mp"> ost函数(C) </em>相对于<em class="mp">预测值</em> ( ŷ)的梯度开始</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/75ea0c8527d1e8d604a1a36a9f3eace8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/0*P-acLujppOUibsZj.png"/></div></figure><p id="d832" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设y = [y₁，y₂，… yₙ]和ŷ =[ ŷ₁，ŷ₂，… ŷₙ]为实际值和预测值的行向量。因此，上述等式简化为</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e314b3e350299261134bdb683896ae5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/0*dBXm12AW-z75w8fa.png"/></div></figure><p id="c90d" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们找出<em class="mp">预测值</em>相对于<em class="mp"> z的梯度。</em>这会有点长。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9bc91967b3f0cbead5839e4892dd6d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/0*cvJsRS27oH-CyY18.png"/></div></figure><p id="8d84" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ji"> <em class="mp"> z </em> </strong>相对于重量<strong class="ky ji"> wᵢ </strong>的倾斜度为</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b021d73ffdc7accac150389af63c0e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/0*sw-TBkHIZh3oiKdR.png"/></div></figure><p id="8054" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此我们得到，</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/41d5289a9872f28777df293795aeb9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/0*P9dGUtdx9V9m-tfj.png"/></div></figure><p id="6499" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">偏见呢？—偏置理论上被认为具有恒定值的输入<em class="mp"> 1 </em>。因此，</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a40f3aa62777f253dbc8d84049ea9da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/0*pl9hM5mzpwDk-4qJ.png"/></div></figure><p id="32a8" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ji">优化:</strong>优化是从一组可用选项中选择最佳元素，在我们的例子中，是选择感知器的最佳权重和偏差。让我们选择<em class="mp">梯度下降</em>作为我们的优化算法，其改变<em class="mp">权重</em>和<em class="mp">偏差</em>，与成本函数相对于相应权重或偏差的梯度的负值成比例。<em class="mp">学习率</em> ( <em class="mp"> α </em>)是一个超参数，用于控制权重和偏差变化的幅度。</p><p id="5e66" class="pw-post-body-paragraph kw kx jh ky b kz la ki lb lc ld kl le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下更新权重和偏差，并重复反向传播和梯度下降，直到收敛。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/068e3a390c7f2d6205f0572500e7e598.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/0*JrAyFlaLuWUdt2L9.png"/></div></figure><h1 id="6641" class="ls lt jh bd lu lv lw lx ly lz ma mb mc kn md ko me kq mf kr mg kt mh ku mi mj bi translated">最后的想法</h1><p id="9a69" class="pw-post-body-paragraph kw kx jh ky b kz mk ki lb lc ml kl le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我希望你已经发现这篇文章很有用，并且理解了神经网络和深度学习背后的数学。我在这篇文章中解释了单个神经元的工作。然而，这些基本概念通过一些修改适用于所有类型的神经网络。</p></div></div>    
</body>
</html>