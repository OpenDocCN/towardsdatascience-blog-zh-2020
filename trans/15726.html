<html>
<head>
<title>A Beginners Guide to Logistic Regression in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python逻辑回归初学者指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-beginners-guide-to-logistic-regression-in-python-470bdc57a33?source=collection_archive---------19-----------------------#2020-10-29">https://towardsdatascience.com/a-beginners-guide-to-logistic-regression-in-python-470bdc57a33?source=collection_archive---------19-----------------------#2020-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="94b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">逻辑回归、混淆度量、AOC和使用scikit学习的解算器的基础</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/556c0b54ff62d0ffc181c79b23fee138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c-jg24RcYL4wPiNG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@celpax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Celpax </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="d2a5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="b5df" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在统计学中，逻辑斯蒂模型被用于预测一个<em class="mn">二元因变量</em>。当我们处理需要预测1和0的数据集时，我们通常依赖逻辑回归或其他分类算法。统计学上，逻辑回归用于预测事件发生的概率。基于概率值和相应的阈值，我们指定事件是否会发生。例如，今天下雨的概率是0.73，并且考虑到我们的阈值是0.5，我们可以确认今天会下雨，即输出是1，这转化为事件(在这种情况下“今天会下雨”)为真的事实。</p><blockquote class="mo mp mq"><p id="e440" class="lr ls mn lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated">当我写下这篇文章时，天正在下雨。太巧了！</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/8be809cbd9e997e2906c21afe0b11476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ogWWTUa8puxRMFnp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奥斯曼·拉纳在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bf73" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">现在的问题是这些<strong class="lt iu">概率</strong>和<strong class="lt iu">阈值</strong>是什么？我们如何对数据建模？我们可以用线性回归来代替吗？简而言之，当因变量为1或0时，<em class="mn">线性回归不是一个选项，因为线性回归遵循因变量连续的基本假设。</em>当我们使用线性回归对数据建模时，因变量(Y)可以取任何范围的值。当使用线性模型进行预测时，将因变量的输出分别定标为0和1是具有挑战性的。这就是为什么对于逻辑回归，我们给定独立变量X1、X2、X3等等，来模拟事件Y的概率。<strong class="lt iu">迷茫？</strong></p><p id="bb9a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们用上面的例子来解决这个问题。什么是<strong class="lt iu">概率</strong><strong class="lt iu">会下雨</strong>(这里的Y是今天下雨的概率)给定昨天下雨(X1)，今天气温20度(X2)，月份10月(X3)，湿度20% (X4)。现在，如果我们建立一个回归模型，假设Y = a*X1 + b*X2 + c*X3 + d*X4 +常数，Y的值可以在[A，B]之间，其中A和B可以取任何可能的值集。然而，我们知道<em class="mn">一个概率可以位于【0，1】</em>之间。这要求我们以一种输出总是位于0和1之间的方式对数据建模，因此我们使用如下图所示的sigmoid函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/7ba68f5d116294efb72f521c6d343e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhX8i8J2AilPhtoDskX3PQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。使用Sigmoid函数的逻辑回归方程。作者使用Latex开发的图像。</p></figure><h1 id="27c5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">逻辑回归在哪里？</h1><p id="93f8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们大多数人都会收到品牌或网站的促销信息，这些信息包含我们的电子邮件id和个人信息。你有没有注意到像Dash、Swiggy、Uber Eats这样的移动应用程序定期(当你在他们的平台上不活跃时)为你提供定制的折扣？像优步这样的大机构如何知道你是否应该得到促销优惠或定制折扣？一切都可以归结为使用上面讨论的概念实现的客户分类。这些公司有机器学习模型来理解或预测你粗制滥造的概率。如果模型将你标记为一个不满意的客户，他们会部署这些个性化的策略来留住你。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/59a0aee695db81b572c2873dacebab33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2ug3v121q2NL4ZPO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@abillionveg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> abillionveg </a>拍摄</p></figure><h1 id="ce68" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">分类的概念</h1><p id="b295" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">任何分类问题中的因变量都是0和1的二进制值(也可以是多类，例如产品质量，比如好、中、差)。因此，一旦开发了逻辑回归模型，我们需要将概率转换为0和1。今天下雨的概率是0.72。这意味着今天会下雨(真/ 1)还是不会下雨(假/ 0)？这里的一般思想是<strong class="lt iu">一个事件必须是真(1)或假(0)，而不能像“不确定”那样介于两者之间。</strong>因此，一旦我们对概率值建模，我们需要将概率得分转换为1和0的组合。为了达到同样的目的，大多数机器学习算法使用0.5的阈值。</p><p id="b9c1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> <em class="mn">这意味着如果一个事件发生的概率是&gt; 0.5，我们通常认为该事件会发生，或者换句话说，如果一个事件发生的概率超过50%，那么我们可以声称该事件会发生，也就是说，在这种情况下，会下雨。</em>T15】</strong></p><h2 id="49fd" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">混乱矩阵</h2><p id="4823" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦概率被转换成1和0，我们最终得到一个2 x 2矩阵，通常被称为混淆矩阵。混淆矩阵主要用于模型验证或预测模型的拟合程度，或模型与现有数据的吻合程度。这里值得注意的是，当我们建立一个逻辑模型时，我们需要确保我们的预测与数据中给出的相似。例如，如果数据中最初有100个1和100个0，我们的模型应该将所有1预测为1，所有0和0。这意味着任何错误的分类或不正确的预测都会降低我们的准确性。我们先来看看混淆矩阵。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/598586d4eb5b71166660d5e708a52271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhXK8VtqscbpOr923Kk9Vg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。实际值和预测值的混淆矩阵。所有相应的解释都使用这个混淆矩阵来讨论结果。作者使用Excel开发的图像。</p></figure><ul class=""><li id="9275" class="np nq it lt b lu mr lx ms ma nr me ns mi nt mm nu nv nw nx bi translated"><strong class="lt iu">真阳性</strong> —模型预测为1的值中有多少是原始数据集中的1？真意味着正确的预测，1在这里指的是积极的，所以简而言之，积极的正确预测</li><li id="9b55" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><strong class="lt iu">假阴性</strong> —数据集中有多少被模型预测为0的值是1。False是不正确的预测，这里负数是0。所以对0或负数的错误预测</li><li id="9e84" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><strong class="lt iu">假阳性</strong> —有多少值被模型预测为1，但在数据集中却是0。False是不正确的，这里的正数是1。所以对1的错误预测</li><li id="4a0b" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><strong class="lt iu">真阴性</strong> —模型预测为0的值中有多少是原始数据集中的0？True表示正确的预测，0s在这里指的是否定的，所以简而言之就是否定的正确预测</li></ul><h2 id="ac2a" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">模型验证术语</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/598586d4eb5b71166660d5e708a52271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhXK8VtqscbpOr923Kk9Vg.png"/></div></div></figure><ul class=""><li id="2917" class="np nq it lt b lu mr lx ms ma nr me ns mi nt mm nu nv nw nx bi translated"><strong class="lt iu">准确性:</strong>我们的模型在预测真阳性和真阴性时的准确性，换句话说，我们的预测有多少与数据中的类别变量完全匹配。</li><li id="7114" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><em class="mn">假设数据集中有100个0和1的观察值，其中50个观察值为0，50个观察值为1 </em> <strong class="lt iu"> <em class="mn">(参考实际)</em> </strong></li><li id="7f00" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><em class="mn">运行模型后，数据集中被标记为0的50个观察值中的30个也被模型</em> <strong class="lt iu"> <em class="mn">(指真阴性)</em> </strong>标记为0</li><li id="fe01" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><em class="mn">在数据集中被标记为1的50个观察值中，有25个被模型</em> <strong class="lt iu"> <em class="mn">(指真阳性)</em> </strong> <em class="mn">标记为1。所以我们的准确率是(30+25)/100 =55/100或者55%。所以准确率是(真阳性+真阴性)/(真阳性+真阴性+假阳性+假阴性)</em></li><li id="141b" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><strong class="lt iu">召回率或敏感度或真阳性率:</strong>数据集中原本标记为1的值被模型预测为1的百分比是多少？所以敏感度是真阳性/(真阳性+假阴性)也就是25 / (25+25) = 50%。</li><li id="a51f" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><em class="mn">这告诉我什么？—它告诉我，数据集中只有50%被归类为1的值被模型正确预测到。</em></li><li id="7791" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><strong class="lt iu">特异性或真阴性率:</strong>数据集中原本标记为0的值有百分之多少被模型预测为0？所以敏感度是真阴性/(真阴性+假阳性)也就是30 / (25+25) = 60%。</li><li id="8ce5" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><em class="mn">这告诉我什么？—它告诉我，在数据集中，只有60%归类为0的值被模型正确预测。</em></li><li id="9a3c" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><strong class="lt iu">1-特异性或假阳性率:</strong>数据集中原本标记为0的值有百分之多少被模型预测为1？所以1-灵敏度是假阳性/(真阴性+假阳性)也就是20 / (25+25) = 40%。</li><li id="1d94" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><em class="mn">这告诉我什么？—它告诉我，在数据集中被归类为0的值中，只有40%被模型错误地预测到。</em></li><li id="d996" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><strong class="lt iu">精度:</strong>预测为1s的值有百分之多少是正确的？所以精度是真正/(真正+假正)也就是20 / (20+25) = 44.4%。</li><li id="35cc" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><em class="mn">这告诉我什么？—它告诉我，模型预测为1s的值中只有44.4%是正确的</em></li><li id="d8af" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm nu nv nw nx bi translated"><strong class="lt iu"> F1得分</strong>:是精度和召回率的调和平均值。它的计算方法是2 x(精度*召回率)/(精度+召回率)。在我们的例子中，它是2 * (0.44*0.5) / (0.44+0.5) = 0.46</li></ul><h2 id="be5d" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">使用哪个模型验证指标？</h2><p id="aaf0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们知道了多个度量标准，很难确定使用哪一个。我在这里举个例子。我们先来看看下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/44f8074e4dd73bb6f6313f4be34fa8af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BPP7xRDkpETcNAVzHMXMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。四种不同情景的混淆矩阵及其准确性、回忆/敏感度、精确度和F1分数。作者使用Excel开发的图像。</p></figure><p id="b9fe" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">上图显示了一个经典的场景示例，其中来自不同模型运行的输出产生了相同的准确性分数。当验证一个逻辑模型时，我们需要在进入模型验证度量之前理解业务用例。一个经典的例子是诊断病人的医疗状况。在处理医疗保健行业的问题时，除了准确性，我们还需要关注召回价值。准确度和精确度并不那么重要。我们需要更准确地预测有健康状况的患者，即使这意味着错误地将没有健康状况的患者分类。</p><p id="103f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">这里的基本原理是，即使<strong class="lt iu">的精确度很差，即我们错误地预测健康患者患有某种疾病，也会有后续的医学测试来帮助诊断</strong>。然而，如果我们的<strong class="lt iu">召回率低</strong>，即<strong class="lt iu">我们不能正确预测患者的医疗状况，那么我们就会危及他们的生命</strong>。</p><blockquote class="mo mp mq"><p id="4408" class="lr ls mn lt b lu mr ju lw lx ms jx lz mt mu mc md mv mw mg mh mx my mk ml mm im bi translated">想一想——在营销活动中，我们需要预测客户是否会购买产品，并向他发送一些促销信息，这种情况如何？</p></blockquote><h2 id="5876" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated">我们应该将阈值从0.5更改为不同的值吗？</h2><p id="a433" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在统计学中，如果一个事件发生的概率是0.5，那么就认为是一个<em class="mn">随机事件</em> <strong class="lt iu"> <em class="mn">。</em> </strong>大多数ML算法使用阈值0.5将概率转换为1和0，这转化为随机化因子。如果一个事件的概率大于随机概率值，那么这个事件就有可能发生，否则就不会发生。然而，有时我们需要微调这个阈值来改进模型度量之一。</p><p id="f8a1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu">如果我提高或降低阈值，会有什么变化？</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/598586d4eb5b71166660d5e708a52271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhXK8VtqscbpOr923Kk9Vg.png"/></div></div></figure><ol class=""><li id="6c6e" class="np nq it lt b lu mr lx ms ma nr me ns mi nt mm oe nv nw nx bi translated">始终记住<strong class="lt iu">真阳性+假阴性</strong> <strong class="lt iu">是数据集的</strong> <strong class="lt iu">常数</strong>，这意味着如果其中一个改变，灵敏度也会改变。类似地，数据集的<strong class="lt iu">假阳性+真阴性是常数</strong>，这意味着如果任一变化特异性也发生变化</li><li id="b98a" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm oe nv nw nx bi translated">降低阈值意味着我最终预测1多于0？这意味着什么？<br/> -这意味着<strong class="lt iu">真阳性+假阳性</strong> <strong class="lt iu">通过增加预测1<br/>的数量来增加</strong>-这导致了<strong class="lt iu">假阳性数量增加</strong>的可能性，从而<strong class="lt iu">降低</strong> <strong class="lt iu">精度</strong> <br/> -如果<strong class="lt iu">假阳性增加，真阴性将下降</strong>，从而<strong class="lt iu">降低特异性</strong></li><li id="db34" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm oe nv nw nx bi translated">增加阈值意味着我最终会预测更多的0而不是1 <br/>这意味着什么？<br/> -这意味着<strong class="lt iu">真阴性+假阴性增加</strong>，因为模型预测的0的数量将更高<br/> -这导致假阴性的数量<strong class="lt iu">可能会增加，从而降低灵敏度</strong></li></ol><p id="a3fb" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">如果模型的召回(灵敏度)值很低，您可能希望将阈值从0.5降低到一个较低的值。</p><h2 id="c514" class="nc la it bd lb nd ne dn lf nf ng dp lj ma nh ni ll me nj nk ln mi nl nm lp nn bi translated"><strong class="ak">接收机工作特性曲线</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/250e874b20c5233c4895f72d83166d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*_ycZ8F_1Zbe_6cqIp8Ie-g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4。逻辑回归模型的ROC曲线。作者使用Jupyter笔记本开发的图像。</p></figure><ol class=""><li id="1db9" class="np nq it lt b lu mr lx ms ma nr me ns mi nt mm oe nv nw nx bi translated">当灵敏度/真阳性率为0，1-特异性或假阳性率为0时，意味着什么？<br/> -真阳性为0，这意味着所有的1都被模型<br/>错误地预测到了-假阳性为0，或者我们可以说真阴性为100%，即所有的0都被模型<br/>正确地预测到了-我的模型为0返回了极好的回报，但未能识别1</li><li id="ed70" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm oe nv nw nx bi translated">当灵敏度/真阳性率为1且1-特异性或假阳性为1时意味着什么？<br/> -假阴性为0，这意味着所有的0都被模型<br/>错误地预测到了-真阳性为1，或者我们可以说所有的1都被模型<br/>正确地预测到了-我的模型返回了1的优秀结果，但未能处理0</li><li id="2e96" class="np nq it lt b lu ny lx nz ma oa me ob mi oc mm oe nv nw nx bi translated">上面的曲线意味着什么？<br/> -对于不同的概率阈值，灵敏度和1-特异性值是多少<br/> -面积越大，表示1-特异性低时灵敏度高，之后保持饱和</li></ol><h1 id="eeb2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用Python预测贷款资格</h1><p id="a284" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">信用风险是指借款人拖欠任何贷款。在银行部门，这是在批准申请人的贷款之前要考虑的一个重要因素。X公司经营所有房屋贷款。他们在所有地区都有业务。客户申请贷款，在批准之前，贷款官员会对其进行验证。该分析旨在为客户建模，并确定他们是否合格。</p><p id="1ace" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">实现相同功能的代码片段如下:</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="17b6" class="nc la it oh b gy ol om l on oo">import pandas as pd<br/>from sklearn.linear_model import LogisticRegression</span><span id="9734" class="nc la it oh b gy op om l on oo"># importing ploting libraries<br/>import matplotlib.pyplot as plt<br/># To enable plotting graphs in Jupyter notebook<br/>%matplotlib inline</span><span id="296d" class="nc la it oh b gy op om l on oo">#importing seaborn for statistical plots<br/>import seaborn as sns<br/>sns.set(color_codes=True) # — — — — — — — -adds hue to the color</span><span id="85ca" class="nc la it oh b gy op om l on oo">#Let us break the X and y dataframes into training set and test set. For this we will use<br/>#Sklearn package’s data splitting function which is based on random function</span><span id="4175" class="nc la it oh b gy op om l on oo">from sklearn.model_selection import train_test_split</span><span id="0254" class="nc la it oh b gy op om l on oo">import numpy as np<br/>import os,sys<br/>from scipy import stats</span><span id="5e38" class="nc la it oh b gy op om l on oo">import warnings<br/>warnings.filterwarnings(‘ignore’)</span><span id="8e77" class="nc la it oh b gy op om l on oo"># calculate accuracy measures and confusion matrix<br/>from sklearn import metrics</span><span id="2fc4" class="nc la it oh b gy op om l on oo">from IPython.display import display # — — — — — — — — — — -for displaying multiple data frames in one output</span></pre><p id="35b1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu">读取数据</strong></p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="c221" class="nc la it oh b gy ol om l on oo">df = pd.read_csv(‘CreditRisk.csv’)</span><span id="922e" class="nc la it oh b gy op om l on oo">print(“Shape of the data:”, df.shape)</span><span id="9c4f" class="nc la it oh b gy op om l on oo">display(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/c4bbf28583ea63a5a67d889eb69e93f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxRGei6ENkNmmh-04QbTEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5。来自信用数据的数据元素。作者使用Jupyter笔记本开发的图像。</p></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="4ebf" class="nc la it oh b gy ol om l on oo">cr_df = df.drop(‘Loan_ID’, axis =1 ) # dropping this column as it will be 1–1 mapping anyways</span><span id="abfc" class="nc la it oh b gy op om l on oo">cr_df['Loan_Amount_Term'].value_counts(normalize=True)</span><span id="f4ad" class="nc la it oh b gy op om l on oo">#The Loan_Amount_Term/Credit_History is highly skewed - so we will delete this column</span><span id="cc71" class="nc la it oh b gy op om l on oo">cr_df.drop(['Loan_Amount_Term'], axis=1, inplace=True)</span></pre><p id="55c8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu">缺失值处理</strong></p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="1e71" class="nc la it oh b gy ol om l on oo">for i in list(cr_df.columns[cr_df.dtypes==’object’]): # checking value counts of all object type columns<br/> print(cr_df[i].value_counts(normalize=True))<br/> print()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/f1c2f8b6e181ba7490f54124a340fd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*TRdh5Y_RerRLnL9-TwOqrg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6。按属性分布数据。作者使用Jupyter笔记本开发的图像。</p></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="fc9d" class="nc la it oh b gy ol om l on oo">#filling Null Values</span><span id="f68d" class="nc la it oh b gy op om l on oo">cr_df[‘Self_Employed’].fillna(‘No’,inplace=True) #replacing with mode, as maximum people are not self employed</span><span id="710d" class="nc la it oh b gy op om l on oo">cr_df[‘Dependents’].fillna(‘0’,inplace=True) #replacing with mode</span><span id="e7d2" class="nc la it oh b gy op om l on oo">cr_df[‘Credit_History’].fillna(0.0,inplace=True) #replacing with mode</span><span id="79c8" class="nc la it oh b gy op om l on oo">cr_df['Gender'].fillna('Male',inplace=True) #replacing remaining values with mode as no other relationship found</span><span id="49c9" class="nc la it oh b gy op om l on oo">df.groupby(['Loan_Status','Gender','Property_Area'])['Married'].value_counts()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2a8363be570c19b81176506744235c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*aVSexkzr2j1WPx1eeA5iYA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7。为了取代婚姻状况，我们着眼于属性的组合，以确定插补的类型。作者使用Jupyter笔记本开发的图像。</p></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="d534" class="nc la it oh b gy ol om l on oo">cr_df.loc[104,’Married’] = ‘Yes’<br/>cr_df.loc[228,’Married’] = ‘Yes’<br/>cr_df.loc[435,’Married’] = ‘No’</span></pre><p id="cc45" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu">为模型开发准备数据</strong></p><p id="0f9f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">数据分为训练集和测试集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/59f16f661e1182e93db86b3391297ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RY6gCimkpdt5rD0Wab9cXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8。测试列车概念。作者使用MS Excel开发的图像。</p></figure><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="b742" class="nc la it oh b gy ol om l on oo">## Define X and Y variables</span><span id="a80c" class="nc la it oh b gy op om l on oo">X = cr_df.drop([‘Loan_Status’], axis=1)<br/>Y = cr_df[[‘Loan_Status’]]</span><span id="0a4f" class="nc la it oh b gy op om l on oo">#Convert categorical vriables to dummy variables<br/>X = pd.get_dummies(X, drop_first=True)</span><span id="1789" class="nc la it oh b gy op om l on oo">##Split into training and test set</span><span id="d085" class="nc la it oh b gy op om l on oo">from sklearn.model_selection import train_test_split</span><span id="13b1" class="nc la it oh b gy op om l on oo">X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.30,random_state=1)</span><span id="9697" class="nc la it oh b gy op om l on oo">from sklearn.metrics import confusion_matrix, recall_score, precision_score, f1_score, roc_auc_score, accuracy_score, log_loss<br/>from sklearn.linear_model import LogisticRegression</span><span id="d043" class="nc la it oh b gy op om l on oo">logreg = LogisticRegression(random_state=42);</span><span id="7e1c" class="nc la it oh b gy op om l on oo">logreg.fit(X_train, y_train)</span></pre><p id="d02a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">让我们检查一下测试数据的准确性。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="f17e" class="nc la it oh b gy ol om l on oo">y_predict = logreg.predict(X_train) # — — — — — — — — -Prediction here are 0s and 1s</span><span id="bc3b" class="nc la it oh b gy op om l on oo"># — — — — — — — to get probability values use this snippet</span><span id="5239" class="nc la it oh b gy op om l on oo">y_predict_prob = logreg.predict_proba(X_train)</span><span id="a231" class="nc la it oh b gy op om l on oo">confusion_matrix(y_train,y_predict)</span><span id="a0ec" class="nc la it oh b gy op om l on oo">#-----------------------------------Regression Score--------------------------------------<br/>print("Trainig accuracy",logreg.score(X_train,y_train))  <br/>print()</span><span id="cb4d" class="nc la it oh b gy op om l on oo">print("Testing accuracy",logreg.score(X_test, y_test))<br/>print()</span><span id="690a" class="nc la it oh b gy op om l on oo">print("Recall:",recall_score(y_train,y_predict))<br/>print()</span><span id="27d1" class="nc la it oh b gy op om l on oo">print("Precision:",precision_score(y_train,y_predict))<br/>print()</span><span id="50ad" class="nc la it oh b gy op om l on oo">print("F1 Score:",f1_score(y_train,y_predict))<br/>print()</span><span id="d461" class="nc la it oh b gy op om l on oo">print("Log Loss:",log_loss(y_train,y_predict))<br/>print()</span></pre><p id="8027" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><strong class="lt iu">使用解算器、正则化和类权重微调模型</strong></p><p id="a9dc" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated">在构建逻辑回归时，我们需要考虑三个可用于提高准确性的参数。这包括解算器(如牛顿-cg、lbfgs、liblinear、sag(随机平均梯度下降)、saga、正则化器(这是L1和L2罚函数，用于说明较高数量的变量并防止过度拟合)和正则化器的罚函数。我们还可以微调类平衡，以解决数据中的不平衡。下面的代码使用的默认求解器是lbfgs，惩罚为“l2”，平衡的类权重，惩罚值为25%。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="ec7d" class="nc la it oh b gy ol om l on oo">#Therefore final model is<br/>model = LogisticRegression(random_state=42,penalty=’l2', class_weight=’balanced’,C=0.25)</span><span id="bb96" class="nc la it oh b gy op om l on oo">model.fit(X_train, y_train)</span><span id="0e55" class="nc la it oh b gy op om l on oo">y_predict = model.predict(X_test)</span><span id="59a9" class="nc la it oh b gy op om l on oo">print(“Trainig accuracy”,model.score(X_train,y_train)) <br/>print()<br/>print(“Testing accuracy”,model.score(X_test, y_test))<br/>print()</span><span id="ab83" class="nc la it oh b gy op om l on oo">print(‘Confusion Matrix’)</span><span id="41ee" class="nc la it oh b gy op om l on oo">print()<br/>print(“Recall:”,recall_score(y_test,y_predict))<br/>print()<br/>print(“Precision:”,precision_score(y_test,y_predict))<br/>print()<br/>print(“F1 Score:”,f1_score(y_test,y_predict))<br/>print()<br/>print(“Roc Auc Score:”,roc_auc_score(y_test,y_predict))</span></pre><div class="ou ov gp gr ow ox"><a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">sklearn.linear_model。逻辑回归-sci kit-学习0.23.2文档</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">逻辑回归(又名logit，MaxEnt)分类器。在多类的情况下，训练算法使用一对其余…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">scikit-learn.org</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div><div class="ab cl pm pn hx po" role="separator"><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr"/></div><div class="im in io ip iq"><p id="c422" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mu mc md me mw mg mh mi my mk ml mm im bi translated"><em class="mn">关于作者:高级分析专家和管理顾问，帮助公司通过对组织数据的商业、技术和数学的组合找到各种问题的解决方案。一个数据科学爱好者，在这里分享、学习、贡献；你可以在</em> <a class="ae ky" href="https://www.linkedin.com/in/angel-das-9532bb12a/" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> LinkedIn </em> </a> <em class="mn">和</em><a class="ae ky" href="https://twitter.com/dasangel07_andy" rel="noopener ugc nofollow" target="_blank"><em class="mn">Twitter</em></a><em class="mn">上和我联系。</em></p></div></div>    
</body>
</html>