<html>
<head>
<title>Isolation Forest is the best Anomaly Detection Algorithm for Big Data Right Now</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">隔离森林是目前针对大数据的最佳异常检测算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/isolation-forest-is-the-best-anomaly-detection-algorithm-for-big-data-right-now-e1a18ec0f94f?source=collection_archive---------6-----------------------#2020-11-13">https://towardsdatascience.com/isolation-forest-is-the-best-anomaly-detection-algorithm-for-big-data-right-now-e1a18ec0f94f?source=collection_archive---------6-----------------------#2020-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7428" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/ce3ec6e1e1013eb0059f61040be768de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neVCAZtAXlqXlBlv0_vQyg.jpeg"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@sgodfrey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西蒙·戈弗雷</a>在<a class="ae ko" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b6fc" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Isolation forest或“iForest”是一个非常漂亮、非常简单的算法，可以用很少的参数识别异常。<a class="ae ko" href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf" rel="noopener ugc nofollow" target="_blank">原始论文</a>面向广大读者，包含最少的数学内容。在本文中，我将解释为什么iForest是目前针对大数据的最佳异常检测算法，提供该算法的摘要、该算法的历史，并分享一个代码实现。</p><h1 id="9382" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">为什么iForest是目前大数据的最佳异常检测算法</h1><p id="5250" class="pw-post-body-paragraph kp kq it kr b ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li mp lk ll lm im bi translated"><strong class="kr jd">同类最佳的性能概括了</strong>。基于ROC性能和精度，iForest在各种数据集上的表现优于大多数其他离群点检测(OD)算法。我从<a class="ae ko" href="https://pyod.readthedocs.io/en/latest/pubs.html" rel="noopener ugc nofollow" target="_blank"><strong class="kr jd">Py</strong>thon<strong class="kr jd">O</strong>ut lier<strong class="kr jd">D</strong>detection package</a>(PyOD；<a class="ae ko" href="http://www.jmlr.org/papers/volume20/19-011/19-011.pdf" rel="noopener ugc nofollow" target="_blank">原始论文</a>)并在Excel中应用了逐行绿-红渐变条件格式。深绿色表示数据集的最佳算法，深红色表示性能最差:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi mq"><img src="../Images/c9d5b03b22ee4c57770a928e0335d747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbyjIQ5_WNwM1X9TzxhQGA.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">我从PyOD(<strong class="bd mv">Py</strong>thon<strong class="bd mv">O</strong>ut lier<strong class="bd mv">D</strong>detection toolbox)获取基准数据，并在Excel中应用行范围的绿-红渐变条件格式。绿色表示“好”，红色表示“坏”。我们看到，iForest在大多数数据集和总体上领先，如均值、中值和标准差颜色所示。图片来源:作者。数据来源:<a class="ae ko" href="https://pyod.readthedocs.io/en/latest/benchmark.html" rel="noopener ugc nofollow" target="_blank">https://pyod.readthedocs.io/en/latest/benchmark.html</a></p></figure><p id="9e87" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们看到，iForest在大多数数据集和总体上领先，如我计算的均值、中值和标准差行的颜色所示。iForest的出色结果同样适用于precision @ N性能:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi mq"><img src="../Images/7ec2883734f89106620d18e09cf03087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SmDRIEIUiO7a7mPy8Malhw.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">图片来源:作者。数据来源:【https://pyod.readthedocs.io/en/latest/benchmark.html T2】</p></figure><p id="921a" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd">扩展性</strong>。就其性能而言，iForest是执行速度最快的算法。PCA和基于直方图的异常值分数(HBOS<a class="ae ko" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.401.5686&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">论文</a>、<a class="ae ko" href="https://www.dfki.de/fileadmin/user_upload/import/6431_HBOS-poster.pdf" rel="noopener ugc nofollow" target="_blank">海报</a>)在所有数据集上都比预期的要快。k-最近邻(KNN)要慢得多，并且随着更多的观察而可怕地扩展。</p><blockquote class="na nb nc"><p id="fb0b" class="kp kq nd kr b ks kt ku kv kw kx ky kz ne lb lc ld nf lf lg lh ng lj lk ll lm im bi translated">在集群环境中，我已经成功地用包含100万个观察值的数据集构建了隔离森林，这些观察值有36列，数量级为几分钟。我不能对sk-learn的KNN说同样的话。</p></blockquote><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nh"><img src="../Images/9471adfa01bc9deb39e70d425fcbc7fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WI4K_orYthDiTsIsLKhWxQ.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">图片来源:作者。数据来源:<a class="ae ko" href="https://pyod.readthedocs.io/en/latest/benchmark.html" rel="noopener ugc nofollow" target="_blank">https://pyod.readthedocs.io/en/latest/benchmark.html</a></p></figure><h1 id="c6e4" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">算法要点/总结</h1><p id="bdf0" class="pw-post-body-paragraph kp kq it kr b ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li mp lk ll lm im bi translated">我将提供一份10页纸的简要总结，概述如下:</p><ol class=""><li id="fad3" class="ni nj it kr b ks kt kw kx la nk le nl li nm lm nn no np nq bi translated">大多数其他异常值检测(OD)算法试图建立“正常”实例的轮廓，然后标记不符合该正态轮廓的实例。iForest通过利用异常的固有属性来明确隔离异常记录:它们对于协变量集具有不寻常的值。</li><li id="c939" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">由于计算开销，现有方法局限于低维数据和小数据量。例证:有没有在大数据上尝试过<code class="fe mw mx my mz b"><a class="ae ko" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.neighbors" rel="noopener ugc nofollow" target="_blank">sklearn.neighbo</a>r.KNeighborsClassifier </code>？:)</li><li id="e077" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">此外，iForest具有“低常数和低内存需求”，即低开销。细节:外部节点的数量是<em class="nd"> n </em>，因为每个观察值<em class="nd"> n </em>都是独立的。内部节点总数明明是<em class="nd"> n-1 </em>，节点总数是<em class="nd"> 2n-1。</em>因此，我们看到了为什么内存需求是有限的，并且随着<em class="nd"> n. </em>线性增长</li><li id="4b48" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">隔离树节点定义:<em class="nd"> T </em>或者是无子外部节点，或者是具有一个测试和恰好两个子节点的内部节点(Tₗ，Tᵣ).为了构建一个iTree，我们通过随机选择一个属性<em class="nd"> q </em>和一个分割值<em class="nd"> p </em>来递归分割<em class="nd"> X </em>，直到(I)树达到一个高度限制，(ii)所有的观察值在它们自己的外部节点被隔离，或者(iii)所有的数据对于所有的属性具有相同的值。</li><li id="3c19" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">路径长度。观察值<em class="nd"> x </em>的路径长度<em class="nd"> h(x) </em>由从根节点到外部节点终止的横向遍历iTree的边数<em class="nd"> x </em>测量。<em class="nd"> E(h(x)) </em>是来自隔离树集合的<em class="nd"> h(x) </em>的平均值。异常分数<em class="nd"> s(x，n) </em>可以从平均路径长度<em class="nd"> E(h(x)) </em> : <em class="nd"> s(x，n) = 2^[− E(h(x)) / c(n)】中导出。</em>基本上，<em class="nd"> s </em>和<em class="nd"> E(h(x)) </em>之间存在单调关系(详见最后的附录和说明它们关系的帮助图)<em class="nd">。</em>我不会讨论术语<em class="nd"> c(n) </em>，所以我可以保持简短，但它对于任何给定的静态数据集都是常数<em class="nd">。</em></li><li id="2d60" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">仅要求用户设置两个变量:要构建的树的数量和子采样大小。作者提出了使用生成的高斯分布数据的实验，该实验显示了如何用很少的树和小的子样本相对快速地实现平均路径长度的收敛。</li><li id="e622" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">小的子采样(样本中的样本)解决了淹没和掩蔽问题。淹没和掩蔽是由对于异常检测目的而言太大的输入数据引起的。淹没是当一个“正常”的观察被误认为是一个“异常”的观察，因为它被异常所包围，而掩蔽是相反的。换句话说，当一棵树被提供了一个包含大部分异常的样本时，一个正常的数据点可能看起来是异常的。作者提出了这种现象的乳房x线照片数据的例子。</li><li id="9bb5" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">小的子样本允许每个隔离树特殊化，<br/>因为每个子样本包括一组不同的异常或<br/>甚至没有异常</li><li id="af04" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">iForest不依赖任何基于距离或密度的措施来识别异常，因此它速度快，计算成本低，这就引出了下一点</li><li id="5f5e" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm nn no np nq bi translated">线性时间复杂度，O(n)。通俗地说，这意味着运行<strong class="kr jd">时间</strong>最多随着输入的大小线性增加<strong class="kr jd">。<a class="ae ko" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">这个不错</a>:</strong></li></ol><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi nw"><img src="../Images/dc5a7b9e3043956c1b2200cb2ee030a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NO2H0mLVvo3xcykmP3QCCQ.png"/></div></div></figure><p id="39b8" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">11.对于具有相关背景的读者来说，论文中的以下图表清楚地说明了算法是如何工作的:</p><div class="mr ms mt mu gt ab cb"><figure class="nx kd ny nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><img src="../Images/fc0b83c3cc9a24bfd058e0a9f1e94ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*q-8Awo3vdHujqxBk84Ik4g.png"/></div></figure><figure class="nx kd od nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><img src="../Images/7d48b7f8eedcad4adaf457adc62467ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*oKwUbZZ3PJ1qwtpDYdFFDw.png"/></div></figure><figure class="nx kd oe nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><img src="../Images/a2bd2b876900f78831b34349bb25f5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*MIMx6kYWGY132w04ONoEVw.png"/></div><p class="kk kl gj gh gi km kn bd b be z dk of di og oh translated">图片来源:<a class="ae ko" href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf" rel="noopener ugc nofollow" target="_blank">刘、汀、周</a>的《隔离林》。</p></figure></div><h1 id="275d" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">算法历史</h1><p id="7bb0" class="pw-post-body-paragraph kp kq it kr b ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li mp lk ll lm im bi translated">博览群书的读者都知道，一个伟大的新想法和更广泛的采用之间的时滞可能长达几十年。例如，逻辑函数在1845年被发现，在1922年被重新发现(<a class="ae ko" href="https://papers.tinbergen.nl/02119.pdf" rel="noopener ugc nofollow" target="_blank">阅读更多</a>)，现在被现代数据科学家定期用于逻辑回归。近几十年来，一个新想法和它被更广泛地采用之间的时间差已经缩短了，但仍然可以说是一段很长的时间。iForest于2008年首次共享，商业上可行的应用程序直到2018年底才发布！下面的时间线:</p><p id="89a6" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">2008年12月— iForest发布的原始论文(<a class="ae ko" href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>)<br/>2009年7月—I forest作者最后一次修改他们的代码实现(<a class="ae ko" href="https://medium.com/r?url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fiforest%2Ffiles%2F" rel="noopener">代码</a>)<br/>2018年10月— h2o团队向R和Python用户提供I forest(<a class="ae ko" href="https://github.com/h2oai/h2o-3/commits/d5bc739b47316a94f32cd80f17f788cf4a9d3aa7/h2o-algos/src/main/java/hex/schemas/IsolationForestModelV3.java" rel="noopener ugc nofollow" target="_blank">代码</a>)<br/>2019年1月— PyOD为Python用户发布离群点检测(OD)工具包(<a class="ae ko" href="https://github.com/yzhao062/pyod" rel="noopener ugc nofollow" target="_blank">代码</a>，<a class="ae ko" href="https://www.jmlr.org/papers/volume20/19-011/19-011.pdf" rel="noopener ugc nofollow" target="_blank">论文)</a></p><h1 id="79e7" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">代码实现</h1><p id="0cb9" class="pw-post-body-paragraph kp kq it kr b ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li mp lk ll lm im bi translated">因为本文是关于大数据的，所以我假设一个集群环境。我下面的实现可以处理存储在AWS S3中的数据，但只需稍加修改就可以在其他地方使用。代码搭建(QA对象、调试等的代码。)大多省略。需要为AWS集群环境安装软件包的帮助吗？参见我的中型文章:<a class="ae ko" href="http://bit.ly/2spBaSd" rel="noopener ugc nofollow" target="_blank">如何为SparkSQL设置经济高效的AWS EMR集群和Jupyter笔记本</a></p><p id="172b" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我发现iForest可以轻松快速地处理750万行和36个特征，在几分钟内完成计算。</p><p id="e980" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd"> Python (h2o): </strong></p><figure class="mr ms mt mu gt kd"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="899c" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面的直方图由上面的代码生成。对于我的数据框<code class="fe mw mx my mz b">predictions_fullX</code>中的观察结果，大多数观察结果并不异常，如较大平均路径长度的频率所证明的。</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ok"><img src="../Images/835bbd830981932e9ebe0003d3667d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Z-SFxJEkkrcT2bNoRTRbg.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">图片来源:作者使用专有数据集</p></figure><p id="8445" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您的数据有您想要用iForest确证的标签，您可以将正常实例集的分布与异常实例集的分布进行比较，并与原始数据集进行比较，以便进一步推断。例如，您可以通过原始数据集中要素的不同组合来查看计数，如下所示:</p><pre class="mr ms mt mu gt ol mz om on aw oo bi"><span id="d882" class="op lo it mz b gy oq or l os ot">N = df.count()<br/>df[['v1', 'v2', 'id']].groupby(['v1', 'v2']).count() / N<br/>df[['v1', 'v3', 'id']].groupby(['v1', 'v3']).count() / N<br/>...</span></pre><p id="65bd" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">并与iForest确定的正常/异常实例集进行比较，如下所示:</p><figure class="mr ms mt mu gt kd"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="e8b1" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我完成了所有这些工作，还将我的数据导出到Excel中，以快速生成一些累积分布函数，如下所示:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ou"><img src="../Images/76dea0d0127cf8b8c1b98c0f855d18e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXPZUQLNvG_tBKcqZ__Wcg.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">图片来源:作者本人作品。绿线代表label=1，或已知的正态观测值；红线代表标签=1的观察值，确认为可能异常或可能不异常。</p></figure><p id="e92f" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd"> Python (pyod) </strong>(如果评论中有要求，我会添加代码！)</p><p id="0fa2" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd">更新(2020年12月15日)，PyOD代码:</strong></p><p id="6010" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在PyOD github ( <a class="ae ko" href="https://github.com/yzhao062/pyod/tree/master/examples" rel="noopener ugc nofollow" target="_blank"> link </a>)上有很多很棒的例子，所以我不认为我有必要编造一个。如果你对GitHub repo上没有的PyOD代码有特殊要求，请在评论中告诉我。Github不会向您显示结果应该是什么样子，所以我的增值功能可以向您显示代码应该输出什么，以防您在这方面遇到困难。</p><p id="ff8a" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">https://github . com/yzhao 062/pyod/blob/master/examples/ocsvm _ example . py的输出应该类似于:</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ov"><img src="../Images/680ea3b0c735a9ed6ea0dd42d5e45c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfffWDIqkNB0_yIFSgvPLw.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">图片来源:作者</p></figure><p id="cb5d" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kr jd"> Scala </strong>(即将推出)</p><p id="cf5a" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我使用LinkedIn团队对Scala的iForest ( <a class="ae ko" href="https://github.com/linkedin/isolation-forest" rel="noopener ugc nofollow" target="_blank"> github </a>)实现，因为PyOD和h2o是针对Python的。目前还不能让它工作，但当我可以的时候会更新。</p><h1 id="20ec" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">参考</h1><ul class=""><li id="0d3a" class="ni nj it kr b ks ml kw mm la ow le ox li oy lm oz no np nq bi translated">F.刘铁男、丁国明、周志宏。<a class="ae ko" href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf" rel="noopener ugc nofollow" target="_blank">隔离林</a>。摘自:<strong class="kr jd">《第八届IEEE数据挖掘国际会议论文集》(ICDM'08) </strong>，意大利比萨，2008年，第413–422页。本文获得了2008年IEEE ICDM会议理论/算法亚军最佳论文奖</li><li id="6312" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm oz no np nq bi translated">赵，杨，纳斯鲁拉，和李，2019。PyOD:用于可伸缩异常检测的Python工具箱。机器学习研究杂志(JMLR)，20(96)，第1–7页。</li></ul><h1 id="31a4" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">关于作者</h1><p id="ba98" class="pw-post-body-paragraph kp kq it kr b ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li mp lk ll lm im bi translated">安德鲁·杨是Neustar的R&amp;D数据科学家经理。例如，Neustar是一家信息服务公司，从航空、银行、政府、营销、社交媒体和电信等领域的数百家公司获取结构化和非结构化的文本和图片数据。Neustar将这些数据成分结合起来，然后向企业客户出售具有附加值的成品，用于咨询、网络安全、欺诈检测和营销等目的。在这种情况下，Young先生是R&amp;D一个小型数据科学团队的实践型首席架构师，负责构建、优化和维护一个为所有产品和服务提供信息的系统，该系统为Neustar带来了超过10亿美元的年收入。在LinkedIn 上关注Andrew，了解数据科学的最新趋势！</p><h1 id="6ecd" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">更多热门文章:</h1><ul class=""><li id="3833" class="ni nj it kr b ks ml kw mm la ow le ox li oy lm oz no np nq bi translated"><a class="ae ko" rel="noopener" target="_blank" href="/something-every-data-scientist-should-know-but-probably-doesnt-the-bias-variance-trade-off-25d97a17329d">每个数据科学家都应该知道:偏差-方差权衡推广是错误的</a></li><li id="9045" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm oz no np nq bi translated"><a class="ae ko" rel="noopener" target="_blank" href="/must-know-presentation-tools-for-the-effective-data-scientist-93e618ffc8c2">高效数据科学家必备的演示工具</a></li></ul><h1 id="a574" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">附录</h1><p id="5719" class="pw-post-body-paragraph kp kq it kr b ks ml ku kv kw mm ky kz la mn lc ld le mo lg lh li mp lk ll lm im bi translated">算法要点/总结，第5点细节:</p><ul class=""><li id="ab02" class="ni nj it kr b ks kt kw kx la nk le nl li nm lm oz no np nq bi translated">当E(h(x)) → c(n)，s → 0.5(观测不是明显异常)</li><li id="24cc" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm oz no np nq bi translated">当E(h(x)) → 0，s → 1(异常)</li><li id="4de1" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm oz no np nq bi translated">当E(h(x))→n1，s → 0时(非异常)</li></ul><p id="933b" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以用这篇论文的话来概括上述内容:</p><ul class=""><li id="2539" class="ni nj it kr b ks kt kw kx la nk le nl li nm lm oz no np nq bi translated">(a)如果实例返回的s非常接近1，那么它们肯定是异常，</li><li id="49fa" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm oz no np nq bi translated">(b)如果实例的s远小于0.5，那么它们被视为正常实例是相当安全的，并且</li><li id="c858" class="ni nj it kr b ks nr kw ns la nt le nu li nv lm oz no np nq bi translated">如果所有实例都返回s ≈ 0.5，那么整个样本实际上没有任何明显的异常。</li></ul><p id="2ee6" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">说明异常分数<em class="nd"> s </em>和平均路径长度<em class="nd"> E(h(x)) </em>之间关系的有用图</p><figure class="mr ms mt mu gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi pa"><img src="../Images/3f8926a6e3a0ad3c1ca446275f8b60d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*QhCvxD_liLmMY9MKYwuCAQ.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">图2来自<a class="ae ko" href="https://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/icdm08b.pdf" rel="noopener ugc nofollow" target="_blank">隔离林纸。</a></p></figure></div></div>    
</body>
</html>