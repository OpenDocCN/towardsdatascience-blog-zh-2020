<html>
<head>
<title>5 things you are doing wrong in PyCaret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyCaret中你做错的5件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-things-you-are-doing-wrong-in-pycaret-e01981575d2a?source=collection_archive---------6-----------------------#2020-11-02">https://towardsdatascience.com/5-things-you-are-doing-wrong-in-pycaret-e01981575d2a?source=collection_archive---------6-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fc35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">来自PyCaret的创造者</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/141c45537d1959408ba1a137ed9b6f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cAYv-e3peN7hicwY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">本·怀特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="d59a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">PyCaret</h1><p id="ff9c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">PyCaret是一个用Python编写的开源、低代码的机器学习库，可以自动化机器学习工作流。它是一个端到端的机器学习和模型管理工具，可以加快机器学习实验周期，让你更有效率。</p><p id="d52c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">与其他开源机器学习库相比，PyCaret是一个替代的低代码库，可以用来替换数百行代码。这使得实验快速有效。</p><p id="b690" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">官方:【https://www.pycaret.org】T4</p><p id="2f66" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">文件:<a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://pycaret.readthedocs.io/en/latest/</a></p><p id="8ebc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">https://www.github.com/pycaret/pycaret</p><h1 id="bc6d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉compare_models做的比你想的更多</h1><p id="b56d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我们在2020年4月发布py caret 1.0版本时，<strong class="lq ir"> compare_models </strong>函数正在比较库中的所有模型，以返回平均的交叉验证性能指标。在此基础上，您可以使用<strong class="lq ir"> create_model </strong>来训练性能最佳的模型，并获得可用于预测的训练模型输出。</p><p id="5973" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这种行为后来在2.0版中有所改变。<strong class="lq ir"> compare_models </strong>现在根据<strong class="lq ir"> n_select </strong>参数返回最佳模型，该参数默认设置为1，这意味着它将返回最佳模型(默认)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/54895079b3418ca761a411b643c53708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obEOUaD0sUEihCGF9zRUfw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">比较模型(n_select = 1)</p></figure><p id="6b11" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过将默认的<strong class="lq ir"> n_select </strong>参数更改为3，您可以获得前3个模型的列表。例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/3054bf73884c3a680259d101795bbad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xy64fsxi84gNc8Fa34c8xg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">比较模型(n_select = 3)</p></figure><p id="1fae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">返回的对象是训练好的模型，你真的不需要再调用<strong class="lq ir"> create_model </strong>来训练它们。如果愿意，您可以使用这些模型来生成诊断图，甚至将其用于预测。例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/9e0491b715a34d4b3280f83ccb8d2fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4M8svu86UDZpDgQpHq2eMQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测模型函数</p></figure><h1 id="330b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉你认为你仅限于scikit-learn模型</h1><p id="519b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们收到很多请求，要求将非<em class="ms"> scikit-learn </em>模型包含在模型库中。很多人没有意识到，你并不仅限于默认的模式。<strong class="lq ir"> create_model </strong>函数除了接受模型库中可用模型的ID外，还接受未训练的模型对象。只要你的对象与<em class="ms">scikit-learn</em>fit/predict API兼容，它就能正常工作。例如，这里我们通过简单地导入未训练的NGBClassifier，从<a class="ae kv" href="https://github.com/stanfordmlgroup/ngboost" rel="noopener ugc nofollow" target="_blank"> ngboost </a>库中训练并评估了<strong class="lq ir"> <em class="ms"> NGBClassifier </em> </strong>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/c5832f706773d0126fcd0e8241ab6ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7f4Tj6m4uWDgRTEt8A1kkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用外部模型创建模型</p></figure><p id="1599" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">也可以通过<strong class="lq ir"> compare_models </strong>的<strong class="lq ir"> include </strong>参数中的未训练模型，就可以正常工作了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/45726ff0b5721316276cb7311f7a5b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*cA_mlHO36Qpimzey0d_KmA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将模型与未训练的对象进行比较</p></figure><p id="5b8b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，包含参数包括来自模型库的三个未训练模型的ID，即逻辑回归、决策树和K个邻居以及来自ngboost库的一个未训练对象。另外，请注意，索引表示在include参数中输入的模型的位置。</p><h1 id="c68d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉你不知道pull()函数</h1><p id="bf9b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所有训练功能(创建模型、调整模型、集合模型等。)显示一个乐谱网格，但它不返回乐谱网格。因此，你不能在一个像pandas.DataFrame这样的对象中存储分数网格。但是，有一个名为<strong class="lq ir"> pull </strong>的函数允许你这样做。例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/0afb4d4198e3f011c9e5d5a555f82d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjMa0UvshGShyG1x4P8P7g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带create_model的拉函数</p></figure><p id="2aae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您使用<strong class="lq ir"> predict_model </strong>函数时，这也适用于维持分数网格。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/b2db2c2ff299308f2e26f294310d287b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-nKVygyqZzW_MR1gCqlmQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带预测模型的拉函数</p></figure><p id="3b1e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，您可以像熊猫一样访问指标。DataFrame，你可以创造奇迹。例如，您可以创建一个循环来训练具有不同参数的模型，并使用以下简单代码创建一个比较表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/278720cf8ebbb16ae058b3721d2054da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wT97w3VPixIzRKi46U4viw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建_模型和拉功能</p></figure><h1 id="1f54" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉你认为PyCaret是一个黑盒，它不是。</h1><p id="f730" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">另一个常见的困惑是，所有的预处理都是在后台进行的，用户无法访问。因此，你不能审计当你运行<strong class="lq ir">设置</strong>功能时发生了什么。这不是真的。</p><p id="60c3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">PyCaret <strong class="lq ir"> get_config </strong>和<strong class="lq ir"> set_config </strong>中有两个函数允许您在后台访问和更改一切，从您的训练集到您的模型的随机状态。您可以通过简单地调用<strong class="lq ir"> help(get_config) </strong>来查看<strong class="lq ir"> get_config </strong>函数的文档，以查看您可以访问哪些变量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/c68bd489eb050d3569243c4398578042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vn2xGeVZMH2-w9GKtiW61g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">帮助(获取配置)</p></figure><p id="b5bd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以通过在<strong class="lq ir"> get_config </strong>函数中调用该变量来访问它。例如，要访问<strong class="lq ir"> X_train </strong>转换的数据集，您将编写以下代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/a2487f55066f0c1da3779a58f241729b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyBcvCIm5W60Y9pzcS52qw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">get_config('X_train ')</p></figure><p id="45cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以使用<strong class="lq ir"> set_config </strong>功能来更改环境变量。有了目前为止你所知道的关于<strong class="lq ir"> pull、get_config、</strong>和<strong class="lq ir"> set_config </strong>函数、<strong class="lq ir"> </strong>你可以创建一些非常复杂的工作流。例如，您可以对维持集<strong class="lq ir"> <em class="ms">重新采样N次</em> </strong>来评估平均性能指标，而不是依赖于一个维持集:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="d5bd" class="nf kx iq nb b gy ng nh l ni nj">import numpy as np<strong class="nb ir"><br/></strong>Xtest = get_config('X_test')<br/>ytest = get_config('y_test')</span><span id="9d9b" class="nf kx iq nb b gy nk nh l ni nj">AUC = []</span><span id="55b1" class="nf kx iq nb b gy nk nh l ni nj">for i in np.random.randint(0,1000,size=10):<br/>    Xtest_sampled = Xtest.sample(n = 100, random_state = i)<br/>    ytest_sampled = ytest[Xtest_sampled.index]<br/>    set_config('X_test', Xtest_sampled)<br/>    set_config('y_test', ytest_sampled)<br/>    predict_model(dt);<br/>    AUC.append(pull()['AUC'][0])</span><span id="515b" class="nf kx iq nb b gy nk nh l ni nj">&gt;&gt;&gt; print(AUC)</span><span id="123b" class="nf kx iq nb b gy nk nh l ni nj"><strong class="nb ir">[Output]: </strong>[0.8182, 0.7483, 0.7812, 0.7887, 0.7799, 0.7967, 0.7812, 0.7209, 0.7958, 0.7404]</span><span id="3e15" class="nf kx iq nb b gy nk nh l ni nj">&gt;&gt;&gt; print(np.array(AUC).mean())</span><span id="3ea6" class="nf kx iq nb b gy nk nh l ni nj"><strong class="nb ir">[Output]: 0.77513</strong></span></pre><h1 id="72d5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">👉你没有记录你的实验</h1><p id="f7bc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你没有记录你的实验，你应该现在就开始记录。不管你是否想使用MLFlow后端服务器，你仍然应该记录你所有的实验。当你执行任何实验时，你会产生大量的元数据，而这些元数据是不可能被手动跟踪的。</p><p id="c96e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您使用<strong class="lq ir"> get_logs </strong>函数时，PyCaret的日志功能将生成一个漂亮、轻量级、易于理解的excel电子表格。例如:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="95fa" class="nf kx iq nb b gy ng nh l ni nj"><strong class="nb ir"># loading dataset</strong><br/>from pycaret.datasets import get_data<br/>data = get_data('juice')</span><span id="4960" class="nf kx iq nb b gy nk nh l ni nj"><strong class="nb ir"># initializing setup</strong><br/>from pycaret.classification import *<strong class="nb ir"><br/></strong>s = setup(data, target = 'Purchase', silent = True, log_experiment = True, experiment_name = 'juice1')</span><span id="7eb9" class="nf kx iq nb b gy nk nh l ni nj"><strong class="nb ir"># compare baseline models</strong><br/>best = compare_models()</span><span id="30b0" class="nf kx iq nb b gy nk nh l ni nj"><strong class="nb ir"># generate logs</strong><br/>get_logs()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/7ade0a45ba19553896300b0bdc4e8970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V85dpjnkXPiING4r5f9yGw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">获取日志()</p></figure><p id="651b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个非常短的实验中，我们已经生成了3，000多个元数据点(指标、超参数、运行时间等。).想象一下，您会如何手动跟踪这些数据点？也许，这实际上不可能。幸运的是，PyCaret提供了一种简单的方法。只需在<strong class="lq ir">设置</strong>功能<strong class="lq ir">中将<strong class="lq ir"> log_experiment </strong>设置为真。</strong></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="26da" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用Python中的轻量级工作流自动化库，您可以实现的目标是无限的。如果你觉得这有用，请不要忘记给我们GitHub repo上的⭐️。</p><p id="faef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">想了解更多关于PyCaret的信息，请关注我们的LinkedIn和Youtube。</p><p id="57e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要了解PyCaret 2.2中所有更新的更多信息，请参见<a class="ae kv" href="https://github.com/pycaret/pycaret/releases" rel="noopener ugc nofollow" target="_blank">发行说明</a>或阅读此<a class="ae kv" rel="noopener" target="_blank" href="/pycaret-2-2-is-here-whats-new-ad7612ca63b">公告</a>。</p><h1 id="86c3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">重要链接</h1><p id="5567" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://www.pycaret.org/guide" rel="noopener ugc nofollow" target="_blank">用户指南</a> <br/> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a> <br/> <a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/tutorials" rel="noopener ugc nofollow" target="_blank">官方教程<br/> </a> <a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/examples" rel="noopener ugc nofollow" target="_blank">示例笔记本</a> <br/> <a class="ae kv" href="https://github.com/pycaret/pycaret/tree/master/resources" rel="noopener ugc nofollow" target="_blank">其他资源</a></p><h1 id="414f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">想了解某个特定模块？</h1><p id="b782" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">单击下面的链接查看文档和工作示例。</p><p id="9a80" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/classification.html" rel="noopener ugc nofollow" target="_blank">分类</a> <br/> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/regression.html" rel="noopener ugc nofollow" target="_blank">回归</a> <br/> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/clustering.html" rel="noopener ugc nofollow" target="_blank">聚类</a> <br/> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/anomaly.html" rel="noopener ugc nofollow" target="_blank">异常检测</a> <br/> <a class="ae kv" href="https://pycaret.readthedocs.io/en/latest/api/nlp.html" rel="noopener ugc nofollow" target="_blank">自然语言处理<br/></a>T29】关联规则挖掘</p></div></div>    
</body>
</html>