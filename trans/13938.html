<html>
<head>
<title>Julia’s Big Problem With Namespace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia关于名称空间的大问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/julias-big-problem-with-namespace-996d2e9ed71e?source=collection_archive---------17-----------------------#2020-09-25">https://towardsdatascience.com/julias-big-problem-with-namespace-996d2e9ed71e?source=collection_archive---------17-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="113d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">作为一名Julia开发者，这是一个可能会影响你的重大问题。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3818ed529383f81f93f1474c054392ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIsbACdpHq1zZ06d1y-A-g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="916c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">背景</h1><p id="739e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi mu translated"><span class="l lq lr ls bm lt lu lv lw lx di"> J </span> ulia是一种现代而年轻的编程语言，自2018年8月发布1.0版本以来，它一直在科学计算界掀起风暴。尽管Julia作为一种语言有大量对开发人员有用的奇妙属性，如多态性、极其动态的语法和类型，但由于Julia是一种如此年轻且相对复杂的语言，所以很容易理解为什么编程语言会出现一些问题。</p><p id="0fcd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">为了理解为什么Julia不擅长处理命名冲突，我们需要看看Julian模块是如何工作的。首先，模块的标准标识符是“module”，所以我们可以创建一个类似这样的模块:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8e7a" class="nf kz it nb b gy ng nh l ni nj">module fizz<br/>    function buzz(foo)<br/>        return(foo)<br/>    end</span><span id="ddd3" class="nf kz it nb b gy nk nh l ni nj">end</span></pre><p id="dd0b" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这将使一个叫做fizz的模块具有一个小时候叫做buzz的功能。我们可以通过以下任何一种方式访问buzz:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f557" class="nf kz it nb b gy ng nh l ni nj">using fizz</span><span id="9886" class="nf kz it nb b gy nk nh l ni nj">fizz.buzz(foo)</span><span id="1f4b" class="nf kz it nb b gy nk nh l ni nj">using fizz: buzz</span><span id="94a9" class="nf kz it nb b gy nk nh l ni nj">buzz(foo)</span><span id="1930" class="nf kz it nb b gy nk nh l ni nj">import fizz</span><span id="9eaa" class="nf kz it nb b gy nk nh l ni nj">fizz.buzz(foo)</span><span id="9436" class="nf kz it nb b gy nk nh l ni nj">import fizz: buzz</span><span id="ac76" class="nf kz it nb b gy nk nh l ni nj">buzz.foo</span></pre><p id="3e71" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">每当我们进口buzz而不含fizz时，我们使用的是所谓的直接进口。这意味着我们将只使用这个特定的函数，模块的其余部分不会加载到我们的环境中。这是防止命名冲突的一个很好的方法，因为如果我们只需要来自不同模块的特定方法或结构，那么我们可以相应地获取它们。还应注意“进口”和“使用”之间的区别。每当我们使用“导入”时，我们都是显式地导入模块、函数或类型。这意味着我们计划对它进行扩展。例如，我可以有这样一个调度方法:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4891" class="nf kz it nb b gy ng nh l ni nj">module fizz<br/>    buzz(foo::Int64) = add_5(foo)<br/>    buzz(foo::Bool) = negate(foo)<br/>end</span></pre><p id="fda9" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">然后显式导入它并为更多类型提供操作:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="66c6" class="nf kz it nb b gy ng nh l ni nj">function add_10(foo)<br/>    return(foo + 10)<br/>end</span><span id="7da2" class="nf kz it nb b gy nk nh l ni nj">import fizz: buzz</span><span id="7e5e" class="nf kz it nb b gy nk nh l ni nj">buzz(foo::Float64) = add_10(foo)</span></pre><p id="1050" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">当然，这将使得如果一个float被用于这个方法，我们将调用我的新add_10函数，它被用dispatch路由到这个函数。</p><p id="6bc2" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">通常，这些命名约定不容易发生冲突。在直接导入时，我们不太可能会遇到问题，如果我们在冲突出现时没有意识到冲突，这种情况肯定不会发生。然而，您可能会遇到的问题是，大多数Julia模块完全遵循函数范式。这意味着它们可能会在导出之上使用导出——这将危及您的个人命名约定。考虑以下模块:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b7e1" class="nf kz it nb b gy ng nh l ni nj">module fizz<br/>    buzz(foo::Int64) = add_5(foo)<br/>    buzz(foo::Bool) = negate(foo)</span><span id="e835" class="nf kz it nb b gy nk nh l ni nj">    export buzz<br/>end</span></pre><p id="6585" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">导出参数的不同之处在于，现在只要导入模块fizz，我们就可以直接访问buzz。请注意，这是大多数Julia包的典型约定。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b44f" class="nf kz it nb b gy ng nh l ni nj">using fizz</span><span id="1ca3" class="nf kz it nb b gy nk nh l ni nj">buzz(foo)</span></pre><p id="7c02" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">记住这一点，考虑两个流行的Julia模块:</p><blockquote class="nl"><p id="bee7" class="nm nn it bd no np nq nr ns nt nu mt dk translated">牛虻. jl和剧情. jl</p></blockquote><p id="f122" class="pw-post-body-paragraph ly lz it ma b mb nv ju md me nw jx mg mh nx mj mk ml ny mn mo mp nz mr ms mt im bi translated">这两个都是使用plot()方法的图形库。虽然它们仍然采用完全不同的参数，但这些都是常规函数，而不是调度操作。另一个需要注意的重要事情是，它们都采用了许多关键字参数，这在dispatch中几乎是不可能的。这两个方法都是导出的，这意味着每当我们导入它们时，我们毫无疑问会遇到命名冲突。如果我们使用直接的约定，比如使用<code class="fe oa ob oc nb b">Plots: plot </code>，这可能是不正确的，但是如果我们想一前一后地使用两个包，这仍然是一个问题。</p><p id="ad46" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">另外，如果你想了解更多关于这两个图形库的知识，我写了一些很好的文章，你可以在这两个库上查阅！：</p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/gadfly-jl-the-pure-julia-plotting-library-from-your-dreams-3ee6ca107a5c"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">牛虻. JL——来自你梦中的纯朱莉娅绘图库</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">看看朱莉娅对2020年统计绘图的最佳选择</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/spruce-up-your-gr-visualizations-in-julia-88a964450a7"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">在Julia中美化您的GR可视化</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">没错，又是Julia，我保证R，Scala，Python还在这个爱情圈里</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><h1 id="7980" class="ky kz it bd la lb pd ld le lf pe lh li jz pf ka lk kc pg kd lm kf ph kg lo lp bi translated">截至1.5.1的补救措施</h1><p id="e438" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi mu translated"><span class="l lq lr ls bm lt lu lv lw lx di"> W </span>虽然作为一门语言，这个问题很难解决，但现在Julia中有一些东西可以帮助解决这个问题。首先，在处理命名冲突时，dispatch将会是一个很好的朋友，它有可能帮助您解决在Julia语言中可能遇到的大多数命名问题。然而，正如我在上面提到的，分派带有大量关键字参数的方法是相当困难的，有时甚至是不可能的。因此，尽管派遣可能是避免冲突的较好方法之一，但它肯定不是避免上述冲突的万无一失的方法。</p><p id="26f3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">考虑如何避免编程语言中的命名冲突的一个很好的方法是环顾四周，看看其他编程语言是如何避免冲突的。在很多方面与Julia非常相似的语言的一个很好的例子当然是Python。Python使用可由用户定义的别名来非常有效地避免命名冲突。然而，当我们在Julia中查看这个相同的概念时，我们看到虽然别名是可能的，但它仍然不能使我们绕过名称冲突:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5e2f" class="nf kz it nb b gy ng nh l ni nj"><strong class="nb iu">import</strong> Queryverse <br/><strong class="nb iu">const</strong> qv = Queryverse</span></pre><p id="14e5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">虽然这似乎是一个解决方案，但问题仍然存在，因为您已经定义了Queryverse及其所有导出的标识符，它们将与以相同名称进入您的环境的新标识符冲突。在这方面，我们可能得到的最接近的方法是显式导入一个特定的方法或类型，然后设置一个与该类型相等的常数。</p><p id="e85c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">除了这两个相当简单且不太有用的解决方案之外，真的没有太多的可能来避免命名冲突，就像Julia语言中的瘟疫一样。至少据我所知，这两个是预防的最佳选择，但如果你已经在试图解决这个问题，它们不会让你脱离困境。</p><h1 id="cea5" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">来自C++的解决方案</h1><p id="a21e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">伴随着一些开发人员可能会遇到的这个严重问题，出现了一个非常好的解决方案，Julia语言有可能从C++继承过来。C++使用了一个叫做名字间隔的概念，它允许我们总是指示我们想要使用哪个模块，甚至在任何特定的场景中我们想要使用模块的哪个部分。考虑一下C++中STD的例子:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="aa3f" class="nf kz it nb b gy ng nh l ni nj">#include &lt;iostream&gt;</span><span id="ef2b" class="nf kz it nb b gy nk nh l ni nj">int main()<br/>{<br/>std::cout &lt;&lt;&lt; 0<br/>}</span></pre><p id="28d3" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">STD是名称空间，cout是包含在名称空间中的函数。这些都包含在我们放在顶部的包<iostream>中。对于代码中需要调用cout的每一点，我们都会调用std::cout，而不仅仅是cout。这意味着，如果我们有一个来自不同名称空间的新标识符，比如foo::cout，我们仍然可以以完全相同的方式使用那个函数。此外，我们还可以在命名空间上调用using，使对象或函数在全局和局部范围内都可用:</iostream></p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="691f" class="nf kz it nb b gy ng nh l ni nj">#include &lt;iostream&gt;</span><span id="fdbd" class="nf kz it nb b gy nk nh l ni nj">using std::cout // &lt;- Global Scope<br/>int main()<br/>{</span><span id="37c2" class="nf kz it nb b gy nk nh l ni nj">using std::cout //&lt;- Local Scope<br/>cout &lt;&lt;&lt; 0 //&lt;- Notice we don't need to use the namespace<br/>}</span></pre><p id="776a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我认为这将为Julia中的include()方法增加一些扩展的可用性。而不仅仅是能够包含。JL文件，我们也可以用模块名来调度它。这使得在Julia代码中根据它们所在的模块创建名字空间成为可能。Include可被视为名称空间语法，而using仍以其一贯的方式使用。以下是一些理论代码的示例:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6d3d" class="nf kz it nb b gy ng nh l ni nj">include(Gadfly)<br/>using Plots</span><span id="fece" class="nf kz it nb b gy nk nh l ni nj">Gadfly::plot(x, y) #&lt; -- This would use Gadfly<br/>plot(x, y) #&lt; -- This would use plots</span></pre></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><h1 id="7b12" class="ky kz it bd la lb pd ld le lf pe lh li jz pf ka lk kc pg kd lm kf ph kg lo lp bi translated">当前的解决方案</h1><p id="ba96" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">虽然这些关于语言迁移的理论上的建议可能对Julia的未来迭代有意义，但重要的是要考虑开发人员现在可能拥有的选项——在Julia库之外。这种可取之处当然是以模块的形式出现，这可能有助于避免Julia语言中的命名冲突。为此，考虑使用别名避免冲突的Pythonic示例。请允许我介绍</p><blockquote class="nl"><p id="24fa" class="nm nn it bd no np nq nr ns nt nu mt dk translated">ImportMacros.jl</p></blockquote><div class="pi pj pk pl pm og"><a href="https://github.com/fredrikekre/ImportMacros.jl" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">fredrikekre/ImportMacros.jl</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">提供两个宏:@import和@using，用于加载模块或对象并将其绑定到别名。@导入可以用…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="pn l or os ot op ou ks og"/></div></div></a></div><p id="2692" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">jl允许在加载导出之前使用宏创建Pythonic别名语法。如果我们在这种情况下使用Import宏，我们可以避免在当前范围内定义模块。虽然这不一定适用于导出(因此也不是最好的解决方案)，但是您仍然可以直接调用导出，并相应地为它们起别名。尽管这种解决方案可能不是最好的长期解决方案，但在开发或构想出更好的解决方案时，它可能会让您摆脱困境。</p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><h1 id="b4cc" class="ky kz it bd la lb pd ld le lf pe lh li jz pf ka lk kc pg kd lm kf ph kg lo lp bi translated">结论</h1><p id="78e8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Julia编程语言做了很多非常棒的事情。虽然这种语言很棒，提供了很多有些人可能从来没有想过的东西，但它也带来了一些问题。重要的是要记住，Julia作为一种语言是非常年轻的，开源社区每天都在开发它。因此，这种语言肯定会在未来得到改进和发展，但肯定会不时出现问题。</p><p id="5b58" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我真的很想看看C++对名字间距的处理方式，看看如何在Julia中解决这个问题会很有趣。就解决方案而言，它可能是最连贯的解决方案之一，也不会改变1.5.1中语言核心的功能。</p><p id="7c0f" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">不管怎样，Julia语言是一个不断扩展和引人入胜的东西，我认为它绝对值得一试。感谢您的阅读，我希望至少这些概念是有趣的！</p></div></div>    
</body>
</html>