<html>
<head>
<title>On Demand Materialized Views: A Scalable Solution for Graphs, Analysis or Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按需物化视图:图形、分析或机器学习的可扩展解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/on-demand-materialized-views-a-scalable-solution-for-graphs-analysis-or-machine-learning-w-d3816af28f1?source=collection_archive---------19-----------------------#2020-09-25">https://towardsdatascience.com/on-demand-materialized-views-a-scalable-solution-for-graphs-analysis-or-machine-learning-w-d3816af28f1?source=collection_archive---------19-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/09f527adbe996e1a415d89c68cbf27a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWT5KJ3FgQp5cgsrA6Eodw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者使用Chart.js提供的图片</p></figure><p id="46ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi ld translated">为图表、分析、投资组合甚至机器学习聚集数据可能是一项艰巨的任务，难以扩展。在本文中，我将详细介绍MongoDB的新(ish) <em class="lm"> $merge </em>管道，我认为它解决了许多这样的伸缩问题，并自动化了某些以前需要大量定制开发才能完成的设计实践，然而，Mongo的文档未能提供推断的示例或多个用例。本文将深入探讨MongoDB的聚合操作。它将假设您已经了解如何聚合数据，并将主要关注涵盖可伸缩性、缓存和数据增长的<em class="lm">$合并管道</em>。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="a0d3" class="md me it lz b gy mf mg l mh mi"><strong class="lz iu">Table of Contents<br/></strong><em class="lm">Basic Usage<br/>Incrementing New Subsets of Data<br/>Incrementing or Replacing a Field based off a conditional<br/></em>Aggregating Data from Multiple Collections<br/><em class="lm">Creating a Basic Graph or Machine Learning Data Set</em></span></pre></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="d8a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们用一些模拟数据创建一个简单的例子。在这个例子中，我们将聚集一般职位，并确定每个配置文件有多少职位，然后我们将聚集评论。如果您使用代码片段来阅读本文，您将希望按照下面的风格创建一些数据点。但是，这种解决方案很容易扩展到具有大量数据点的数据库</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="de0b" class="md me it lz b gy mf mg l mh mi">db.posts.insert({profileId: "1", title: "title", body: "body", createdAt: new Date()})</span><span id="9416" class="md me it lz b gy mj mg l mh mi">db.comments.insert({profileId: "1", body: "body", createdAt: new Date()})</span></pre><p id="c095" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们将通过简单的分组来聚合数据</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="abd8" class="md me it lz b gy mf mg l mh mi">db.posts.aggregate([{<br/>  “$group”: {<br/>    “_id”: “$profileId”,<br/>    “totalPostCount”: {“$sum”: 1}<br/>}}])</span></pre><p id="792b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将为我们提供一系列类似这样的文档</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="61e7" class="md me it lz b gy mf mg l mh mi">[<br/>{_id: “1”, totalPostCount: 5}, <br/>{_id: “2”, totalPostCount: 4}, <br/>{_id: “3”, totalPostCount: 9}<br/>]</span></pre><p id="13aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了避免定期运行集合扫描，即扫描整个集合而不是集合子集的操作，我们可以将此信息存储在概要文件中，并偶尔使用cronjob更新它，或者我们可以将内容缓存在某个地方，并重新运行整个聚合来重新同步计数。当有数百万的个人资料和数百万的帖子时，这个问题变得更加明显。突然之间，聚合将占用大量的计算资源和时间，从而推高成本和服务器负载。如果我们显示某种投资组合视图，或者终端用户正在物理地等待这些计数，并且它们需要100%最新，这将变得更糟；更糟糕的是，许多用户可能同时发出这个请求，使我们的服务器和数据库过载，并使我们的应用程序崩溃。</p><h1 id="7c2e" class="mk me it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">按需物化视图</h1><p id="a152" class="pw-post-body-paragraph kf kg it kh b ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky nl la lb lc im bi translated">这就引入了对MongoDB的<a class="ae nm" href="https://docs.mongodb.com/manual/core/materialized-views/" rel="noopener ugc nofollow" target="_blank">按需物化视图</a>的需求。</p><p id="fce8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在计算机科学中，物化视图是与原始数据集分开存储的先前运行的数据查询的结果。在本例中，它描述了$merge操作，以及如何将结果直接输出到另一个集合中，而不是输出到一个游标中以立即返回到应用程序。Mongo的文档页面描述了每次运行时都会更新内容——即按需更新。然而，它没有正确解释当扫描更小、更新的数据子集时，如何显示数据的增量表示。在本文的剩余部分，我将展示几个例子和用例来说明如何做到这一点</p><p id="6bd2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种方法将<em class="lm">$合并管道</em>添加到聚合操作的末尾。它可以将聚合操作的内容输出到为此目的创建的特定集合中，并替换或合并与之匹配的文档。内容将作为返回数组中每个元素的一个文档输出，允许对新的聚合集合进行进一步的聚合和计算。这是对以前的$out管道操作符的巨大升级，它将覆盖所有匹配的条目。$merge添加以前不存在的数据，并替换已经存在的数据。这个链接展示了一个非常清晰的例子。</p><h1 id="5f4b" class="mk me it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">基本用法</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0751" class="md me it lz b gy mf mg l mh mi"><br/>db.posts.aggregate([<br/>{<br/>  “$group”: {<br/>    “_id”: “$profileId”,<br/>    “totalPostCount”: {“$sum”: 1}<br/>  }<br/>},<br/>{<br/>  “$merge”: {<br/>      “into”: “metricAggregates”<br/>  }<br/>}])</span></pre><p id="a1ef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，我们可以使用metricAggregates集合的普通查询来收集数据</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="422f" class="md me it lz b gy mf mg l mh mi">db.metricAggregates.find()<br/>-&gt;<br/>[{_id: “1”, totalPostCount: 5}, <br/>{_id: “2”, totalPostCount: 4}, <br/>{_id: “3”, totalPostCount: 9}]</span></pre><p id="851e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个例子没有涵盖更复杂的用例。它只包括添加新的概要文件，但是在我们的例子中，现有概要文件的新帖子呢？我们如何避免重复扫描之前聚集的数据？拥有数百万的个人资料和数百万的帖子，我们无法承担如此繁重的工作。</p><h1 id="0d30" class="mk me it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">增加新的数据子集</h1><p id="7b8e" class="pw-post-body-paragraph kf kg it kh b ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky nl la lb lc im bi translated">当处理数百万个文档时，我们需要找到一种方法，只聚合最近的数据，并且只聚合我们还没有聚合的数据。我们不想替换已经存在的字段，我们想增加它们。解决方案隐藏在可选的“<strong class="kh iu">匹配时</strong>”字段底部的$merge 的<a class="ae nm" href="https://docs.mongodb.com/manual/reference/operator/aggregation/merge" rel="noopener ugc nofollow" target="_blank">文档中</a></p><blockquote class="nn no np"><p id="b582" class="kf kg lm kh b ki kj kk kl km kn ko kp nq kr ks kt nr kv kw kx ns kz la lb lc im bi translated">用于更新集合中文档的聚合管道。<br/> [ &lt;第一阶段&gt;，&lt;第二阶段&gt; … ]</p><p id="f739" class="kf kg lm kh b ki kj kk kl km kn ko kp nq kr ks kt nr kv kw kx ns kz la lb lc im bi translated">管道只能由以下阶段组成:<br/> <a class="ae nm" href="https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/#pipe._S_addFields" rel="noopener ugc nofollow" target="_blank"> $addFields </a>及其别名<a class="ae nm" href="https://docs.mongodb.com/manual/reference/operator/aggregation/set/#pipe._S_set" rel="noopener ugc nofollow" target="_blank"> $set </a> <br/> <a class="ae nm" href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#pipe._S_project" rel="noopener ugc nofollow" target="_blank"> $project </a>及其别名<a class="ae nm" href="https://docs.mongodb.com/manual/reference/operator/aggregation/unset/#pipe._S_unset" rel="noopener ugc nofollow" target="_blank">$ unset</a><br/><a class="ae nm" href="https://docs.mongodb.com/manual/reference/operator/aggregation/replaceRoot/#pipe._S_replaceRoot" rel="noopener ugc nofollow" target="_blank">$ replace root</a>及其别名<a class="ae nm" href="https://docs.mongodb.com/manual/reference/operator/aggregation/replaceWith/#pipe._S_replaceWith" rel="noopener ugc nofollow" target="_blank"> $replaceWith </a></p></blockquote><p id="315a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过应用<em class="lm"> whenMatched </em>选项，我们可以应用一个<em class="lm"> $project </em>管道操作符，允许我们增加字段</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9a1d" class="md me it lz b gy mf mg l mh mi">db.posts.aggregate([<br/>{ "$match": {"createdAt": {"$gt": aggregationLastUpdatedAt}}},<br/>{<br/>  "$group": {<br/>    "_id": "$profileId",<br/>    "totalPostCount": {"$sum": 1}<br/>  }<br/>},<br/>{<br/>  "$merge": {<br/>    "into": "metricAggregates",<br/>    "whenMatched": [{<br/>      "$project": {<br/>        "_id": "$_id",<br/>        updatedAt: new Date,<br/>        totalPostCount: {<br/>          "$sum": ["$totalPostCount", "$$new.totalPostCount"]<br/>        }<br/>      }<br/>    }]<br/>  }<br/>}])</span></pre><p id="8ce5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们在这次行动中增加了两件事。首先是<em class="lm"> $match </em>。现在我们需要查询最近的<em class="lm"> updatedAt </em>字段，并将其从集合中取出。之后，我们可以将它包含在匹配中，所以我们只拉<strong class="kh iu">自上次调用操作</strong>以来创建的帖子。在<em class="lm"> $merge </em>管道中，我们添加了一个<em class="lm"> $project </em>操作，因此每次在<em class="lm"> _id </em>字段上出现匹配时，<em class="lm"> updatedAt </em>将被刷新，<em class="lm"> totalCount </em>将被<em class="lm">递增</em>而不是被替换。语法<em class="lm"> $$new </em>是一个与我们刚刚执行的聚合操作中的数据相关的关键字</p><blockquote class="nt"><p id="d301" class="nu nv it bd nw nx ny nz oa ob oc lc dk translated">这些数据只需要查看一次，而且是以很小的增量查看</p></blockquote></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="dfee" class="mk me it bd ml mm od mo mp mq oe ms mt mu of mw mx my og na nb nc oh ne nf ng bi translated">基于条件递增或替换字段</h1><p id="32c5" class="pw-post-body-paragraph kf kg it kh b ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky nl la lb lc im bi translated">但是如果更复杂呢？如果我们还需要显示本周发布的帖子的数量呢？其中我们需要根据时间戳或其他信息有条件地增加或替换字段</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="af24" class="md me it lz b gy mf mg l mh mi">let aggregationLastUpdatedAt = //retrieve most recent timestamp in the metricAggregates collection</span><span id="5267" class="md me it lz b gy mj mg l mh mi">let startOfWeekDate = //new Date representing the beginning of the week</span><span id="0d9e" class="md me it lz b gy mj mg l mh mi">db.posts.aggregate([<br/>{<br/>  "$match": {"createdAt": {"$gt": aggregationLastUpdatedAt}}<br/>},<br/>{<br/>  "$group": {<br/>    "_id": "$profileId",<br/>    "totalPostCount": {"$sum": 1},<br/>    "postsThisWeek": {"$sum": {<br/>       "$cond": {<br/>          "if": {"$gte": ["$createdAt", startOfWeekDate]},<br/>          "then": 1, "else": 0}}},<br/>  }<br/>},<br/>{<br/>  "$merge": {<br/>    "into": "metricAggregates",<br/>    "whenMatched": [{<br/>      "$project": {<br/>        "_id": "$_id",<br/>        "updatedAt": new Date,<br/>        "weekStartedAt": startOfWeekDate,<br/>        "totalPostCount": {<br/>          "$sum": ["$totalPostCount", "$$new.totalPostCount"]<br/>         },<br/>        "postsThisWeek": {<br/>          "$cond": {<br/>            "if": {"$eq": ["$weekStartedAt", startOfWeekDate]},<br/>            "then": {<br/>              "$sum": ["$postsThisWeek", "$$new.postsThisWeek"]<br/>            }, <br/>            "else": "$$new.postsThisWeek"<br/>          }<br/>        }<br/>      }<br/>    }]<br/>  }<br/>}<br/>])</span></pre><p id="eb84" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们<em class="lm">有条件地</em>增加<em class="lm"> postsThisWeek </em>如果它匹配<em class="lm"> weekStartedAt </em> date，或者<em class="lm">替换它</em>如果它不匹配</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="8bbd" class="mk me it bd ml mm od mo mp mq oe ms mt mu of mw mx my og na nb nc oh ne nf ng bi translated">聚合来自多个集合的数据</h1><p id="5fc0" class="pw-post-body-paragraph kf kg it kh b ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky nl la lb lc im bi translated">如果我们需要从其他集合中聚合数据呢？以前我们可能必须使用一个<em class="lm"> $lookUp </em>操作符<em class="lm">、</em>，但是<strong class="kh iu">、<em class="lm"> $lookUp </em>失败了，因为它只与基本集合</strong>匹配。例如，如果我们需要从我们的评论集合中收集指标，该怎么办？一个<em class="lm"> $lookup </em>将跳过所有从未发表过帖子的个人资料，导致那些只发表过评论的个人资料从聚合结果中完全消失。<em class="lm"> $merge </em>很容易解决这个问题，它允许我们在不同的时间、地点或服务上聚合不同的集合，并将所有输出到同一个集合和文档中</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="dd40" class="md me it lz b gy mf mg l mh mi">db.comments.aggregate([<br/>{<br/>  "$match": {"createdAt": {"$gt": commentsAggregationLastUpdatedAt}}<br/>},<br/>{<br/>  "$group": {<br/>    "_id": "$profileId",<br/>    "totalComments": {"$sum": 1},<br/>    "commentsThisWeek": {<br/>      "$sum": {"$cond": {<br/>         "if": {"$gte": ["$createdAt", startOfWeekDate]},<br/>         "then": 1, "else": 0}}},<br/>  }<br/>},<br/>{<br/>  "$project": {<br/>    "_id": "$_id",<br/>    "totalComments": 1,<br/>    "commentsThisWeek": 1,<br/>    "weekStartedAt": startOfWeekDate,<br/>    "postsThisWeek": {"$literal": 0}, // explained below<br/>  }<br/>},<br/>{<br/>  "$merge": {<br/>    "into": "metricAggregates",<br/>    "whenMatched": [{<br/>      "$project": {<br/>        "_id": "$_id",<br/>        "commentsUpdatedAt": new Date(),<br/>        "weekStartedAt": startOfWeekDate,<br/>        "totalComments": {<br/>          "$sum": ["$totalComments", "$$new.totalComments"]<br/>        },<br/>        "commentsThisWeek": {"$cond": {<br/>          "if": {"$eq": ["$weekStartedAt", startOfWeekDate]},<br/>          "then": {<br/>            "$sum": ["$commentsThisWeek", "$$new.commentsThisWeek"]<br/>          },<br/>          "else": "$$new.commentsThisWeek"<br/>         }},<br/>         //explained below<br/>        "postsThisWeek": {"$cond": {<br/>          "if": {"$eq": ["$weekStartedAt", startOfWeekDate]},<br/>          "then": {"$sum": ["$thisWeek", "$$new.thisWeek"]}, <br/>          "else": "$$new.thisWeek"<br/>        }},<br/>      }<br/>    }]<br/>  }<br/>}])</span></pre><p id="b0da" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在在comments集合中，我们很快遵循相同的聚合原则，集合将自动按照我们想要的方式进行合并。您可能已经注意到了一个额外的<em class="lm"> $project </em>操作，以及仍然在<em class="lm"> $merge pipeline </em>中的<em class="lm"> postsThisWeek </em>字段。这样做的原因是，如果评论聚合操作发生在新的一周，则<em class="lm">总评论</em>将被准确重置，并且<em class="lm">周开始日期</em>将被正确更新。但是，如果稍后发生post聚合，则不会触发周开始替换，因为<em class="lm"> weekStartedAt </em>已经匹配，导致post字段在应该重置时错误地递增。通过包含这些字段并将该字段设置为{<em class="lm">$ literal 0 }</em>—<em class="lm">$ literal</em>将该字段设置为文字整数值0，而不是解释为排除。代码翻译成<em class="lm">“如果是新的一周，将该字段设置为0，否则递增0”</em></p><p id="e8cc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意，我们还在<em class="lm"> $merge </em>中设置了一个<strong class="kh iu">唯一的</strong>日期字段。我们需要将评论最后一次汇总的时间和帖子分开，否则可能会丢失数据</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="d257" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当最终用户请求数据时，他们只需像任何普通的mongoDB操作一样从输出集合中提取数据。即使数据是多个聚合查询和集合的集合，也可以轻松地对其进行排序、分页、过滤和索引。</p><p id="c7d5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种方法保证了即使对于复杂的计算，我们也只需要扫描一次数据，而且只需要一点点。可以在每次查看页面时额外聚合数据，也可以由cronjob管理数据。它可以跨越任意数量的集合，而不需要<em class="lm"> $lookup </em>，并且复杂度可以根据用例的不同而增加。</p><p id="5304" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，新的输出集合还可以被聚合，以得出不同的有趣度量，这可以极大地帮助各种机器学习应用程序或投资组合视图。</p><h1 id="87e2" class="mk me it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">创建基本图形或机器学习数据集</h1><p id="41ff" class="pw-post-body-paragraph kf kg it kh b ki nh kk kl km ni ko kp kq nj ks kt ku nk kw kx ky nl la lb lc im bi translated">作为最后一个例子，我将包含一个聚合操作，该操作按周对总计数进行排序，这对于创建可视化图形或机器学习数据集非常有用</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f650" class="md me it lz b gy mf mg l mh mi">db.posts.aggregate([<br/>{"$match": {"createdAt": {"$gt": aggregationLastUpdatedAt}}},<br/>{<br/>  "$project": {<br/>    "createdAt": 1,<br/>    "week": {"$trunc": <br/>      {"$divide": [<br/>        {"$divide": [{"$subtract": ["$createdAt", startDate]}, 86400000]},<br/>        7<br/>      ]}<br/>    }<br/>  }<br/>},<br/>{<br/>  "$group": {<br/>    "_id": "$week",<br/>    "week": {"$first": "$week"},<br/>    "totalPostCount": {"$sum": 1}<br/>  }<br/>},<br/>{<br/>  "$merge": {<br/>    "into": "metricsByWeek",<br/>    "on": ["week"], // this requires a unique index on the metricsByWeek collection<br/>    "whenMatched": [{<br/>      "$project": {<br/>        "week": 1,<br/>        "updatedAt": new Date,<br/>        "totalPostCount": {<br/>          "$sum": ["$totalPostCount", "$$new.totalPostCount"]<br/>        }<br/>      }<br/>    }]<br/>  }<br/>}])</span></pre><p id="a628" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="lm">如果您正在实时跟踪代码示例，您将需要在运行上述代码</em>之前复制并粘贴以下代码片段</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4cb5" class="md me it lz b gy mf mg l mh mi">db.metricsByWeek.createIndex({week:1}, {unique:true})</span></pre><p id="5f33" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是因为当您定制<em class="lm"> $merge </em>操作符寻找匹配的字段时，该字段(或字段组合)必须有一个惟一的索引，这样才能保证mongo只找到一个<em class="lm">单个</em>匹配</p><p id="f449" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这样就创建了一个这样的文档集合，可以插入到图形库或任何其他应用程序中</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2137" class="md me it lz b gy mf mg l mh mi">{<br/>  week: 0,<br/>  totalCount: 3<br/>}<br/>{<br/>  week: 1,<br/>  totalCount: 9,<br/>}<br/>{<br/>  week:2,<br/>  totalCount: 25<br/>}</span></pre></div></div>    
</body>
</html>