<html>
<head>
<title>Looking to Nature for Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向自然寻求优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/looking-to-nature-for-optimization-359bc327229c?source=collection_archive---------53-----------------------#2020-11-04">https://towardsdatascience.com/looking-to-nature-for-optimization-359bc327229c?source=collection_archive---------53-----------------------#2020-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b4f6e15e1b7a1593e05a8b7b102ab760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qOhPyXuE8KgLzU65"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">弗朗西斯科·费尔南德斯在<a class="ae jg" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上退火的照片</p></figure><h2 id="3581" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/thoughts-and-theory" rel="noopener" target="_blank">思想与理论</a></h2><div class=""/><div class=""><h2 id="30aa" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">利用宇宙一直知道的东西</h2></div><p id="a404" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">优化问题在现代计算和经济学中无处不在。他们致力于在具有多种可能性的复杂空间中寻找“最佳”解决方案。大自然对此感到不可思议！自从事物存在以来，大自然就一直在寻找尽可能好的做事方式。让我们看看如何利用自然中发现的技术来解决现代问题。</p><p id="46ed" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了形式化一个优化问题，一个<strong class="lj jt">解空间</strong>被认为是解决问题的可能方法。每个解决方案都有一个我们寻求最大化的价值。然而，当解决方案空间如此之大，以至于要花太长时间来检查每个解决方案时，这可能是一个难以置信的挑战。</p><p id="c166" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">优化的一个常见例子是<a class="ae jg" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">旅行推销员问题</a>。在最基本的版本中，地图上有许多随机的点。你必须找到连接它们的总距离最小的路径。在这个微小的变化中，我们寻求<em class="md">最小化</em> <strong class="lj jt"> K </strong>(或者我们可以最大化<strong class="lj jt"> -K)。</strong></p><p id="bc54" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们看一个简单的解空间来帮助我们形象化！</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi me"><img src="../Images/f3a9bdd076b8367c9694af6ce710a6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFk4PdmWf92IOt5nb0aKXQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图1:示例解决方案空间，在<a class="ae jg" href="https://www.desmos.com/" rel="noopener ugc nofollow" target="_blank"> Desmos </a>中制作</p></figure><p id="c0f8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">图1为我们的问题提供了不同的解决方案。我没有包括标度或单位，因为在这个例子中它们是任意的。每个点代表不同的配置。一个解附近的点代表相似解的一个<strong class="lj jt">邻域</strong>。这样做是为了从一个点移动到下一个点只需要对解决方案做最小的改变。对于旅行推销员问题，一个解决方案与另一个解决方案相邻意味着它们是相同的，除了路线上两个相邻的“站”交换了顺序。我们希望相邻的解决方案只有微小的差异，这样它们的K就相似了。</p><p id="e345" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在图1的y轴上，我们有<strong class="lj jt"> K </strong>。这是我们试图最大化的变量。快速浏览一下图表，就会发现点<strong class="lj jt"> B </strong>显然是最佳答案。在点<strong class="lj jt"> D </strong>还有一个局部极大值，我们必须考虑。记住，这是大大简化了的！很多优化问题会有万亿个解，解空间会不止一个维度。</p><p id="9a02" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们有了一个解空间，让我们看看两种不同的算法如何处理这个问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c1ae" class="mq mr jj bd ms mt mu mv mw mx my mz na ky nb kz nc lb nd lc ne le nf lf ng nh bi translated"><span class="l ni nj nk bm nl nm nn no np di">病爬</span></h1><p id="4f5f" class="pw-post-body-paragraph lh li jj lj b lk nq kt lm ln nr kw lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">我们的第一个方法不是在自然界中发现的。然而，这是迄今为止最容易理解的算法，并将作为解决这个问题的起点。我将用伪代码展示它，并附上书面解释。这个代码将简称为<em class="md"> HillClimb </em>。</p><pre class="mf mg mh mi gt nv nw nx ny aw nz bi"><span id="a4f7" class="oa mr jj nw b gy ob oc l od oe">point = RandomPoint<br/>while True<br/>   newpoint = Blank</span><span id="e79e" class="oa mr jj nw b gy of oc l od oe">for p in point.Neighborhood<br/>      if point.k &lt; p.k and newpoint.k &lt; p.k<br/>         newpoint = p</span><span id="e245" class="oa mr jj nw b gy of oc l od oe">if newpoint != Blank<br/>      point = newpoint<br/>   else<br/>      break</span></pre><p id="0d48" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要开始<em class="md">爬山</em>，选择一个随机的解决方案<strong class="lj jt"> S </strong>。然后，检查<strong class="lj jt"> S </strong>邻域内每个点的<strong class="lj jt"> K </strong>(根据问题不同，邻域可以有多种不同的定义方式)。如果<strong class="lj jt"> S </strong>的邻域中的任何点的<strong class="lj jt"> K </strong>比<strong class="lj jt"> S </strong>高，则将该点设置为新的<strong class="lj jt"> S </strong>。如果多个点的<strong class="lj jt"> K </strong>比<strong class="lj jt"> S </strong>高，则选择最高的一个。如果出现平局，从给出的最高分中随机选择一分。继续这样做，直到<strong class="lj jt"> S </strong>的邻域没有比<strong class="lj jt"> S </strong>本身具有更高<strong class="lj jt"> K </strong>的点。</p><p id="2f98" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">爬山有一个非常简单的优点。它也适用于只有一个最大值的解空间。但是，它无法处理具有许多不同最大值的空间，例如图1中的两个最大值<strong class="lj jt"> B </strong>和<strong class="lj jt"> D </strong>。</p><p id="ca7b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们看看<em class="md">爬山</em>如何处理图1中的不同点。</p><p id="6dd6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">假设我们碰巧从最佳方案开始:点<strong class="lj jt"> B </strong>。<em class="md">爬山</em>将检查它旁边的两个点，并查看两个点都没有更高的<strong class="lj jt"> K </strong>并退出。我们完全凭运气找到了正确答案！</p><p id="aad9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是如果<em class="md">爬山</em>从<strong class="lj jt"> D点开始呢？</strong>紧挨着<strong class="lj jt"> D </strong>的两个点都没有更高的<strong class="lj jt"> K </strong>，所以它会停下来说<strong class="lj jt"> D </strong>是最优解，基于解空间这显然是不成立的。这说明了<em class="md">爬山</em>的问题:它没有办法处理局部最大值。相反，<em class="md">爬山</em>必须依靠运气从一个随机点开始，这将导致它达到真正的最大值，例如点<strong class="lj jt"> A </strong>。</p><p id="d4ff" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">基于此<em class="md">爬山</em>演示，如果从图1中的点<strong class="lj jt"> C </strong>开始，会给出什么“最佳”解决方案？答案在本页末给出！</p><p id="d988" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个问题的严重程度取决于问题的性质。如果找到最高的<strong class="lj jt"> K </strong>不是绝对关键，而是只要找到一个相对较高的<strong class="lj jt"> K </strong>的解决方案，<em class="md">爬山</em>就可以了。该算法还可以重复运行，以增加找到更好解决方案的可能性，因为它非常依赖于起始点。<em class="md"> HillClimb </em>确实与非常“锯齿状”的解决方案空间作斗争，如下图2所示。这是因为它通常会很快找到一个“最佳”解决方案，而不是因为大量的局部最大值而搜索更好的解决方案。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/02e6a491aaf1e96b67748b962a805f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*MbZ34kIPtmjf3fk8GZ42_g.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图2:参差不齐的解决方案空间</p></figure><p id="658a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">爬山很好，但肯定有一些问题。主要是它不能处理局部最大值，并且严重依赖于初始起点。我们如何解决这个问题？一种可能的方法是在我们的算法中引入一些随机性。如果有时候，我们的道路没有把我们带到附近更好的地方，而是一个K值更低的地方呢？我们需要小心这一点，我们不能随机地从一个点到另一个点，然后选择一个。我们的新算法应该具有随机的能力，但也仍然以一个合理的答案结束。让我们看看这是如何工作的！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c85f" class="mq mr jj bd ms mt mu mv mw mx my mz na ky nb kz nc lb nd lc ne le nf lf ng nh bi translated">模拟退火</h1><p id="9bdd" class="pw-post-body-paragraph lh li jj lj b lk nq kt lm ln nr kw lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">我们可以从一个自然过程中寻找一种方式来改变<em class="md">爬山</em>。<a class="ae jg" href="https://en.wikipedia.org/wiki/Annealing_(metallurgy)" rel="noopener ugc nofollow" target="_blank">退火</a>是金属从受热状态冷却时发生的过程。当加热时，金属中的原子可以自由移动，当金属冷却时，会寻找更节能的排列方式。高<strong class="lj jt">温度</strong> ( <strong class="lj jt"> T </strong>)意味着原子更有可能四处移动，暂时变得能量效率更低，以可能找到更好的排列。随着T降低，原子变得不太可能进行这种赌博。这种最终状态将比金属最初被加热时更节能。大自然有一个很好的方法来优化金属中原子的排列。</p><p id="0f5d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们如何将此添加到<em class="md">爬山</em>中？让我们有一个变量，<strong class="lj jt"> T </strong>，它表示我们的算法选择一个具有较低<strong class="lj jt"> K </strong>的邻近解的可能性。它还应该取决于我们当前点和新点之间的差异。换句话说，如果一个点比我们现在拥有的差很多，我们的算法就不太可能选择一个更差的点。我将在下面展示算法<em class="md">退火</em>的伪代码。别急，后面会有文字解释！</p><pre class="mf mg mh mi gt nv nw nx ny aw nz bi"><span id="592c" class="oa mr jj nw b gy ob oc l od oe">point = RandomPoint<br/>T = StartingTemperature<br/>delT = ChangeInTemperature</span><span id="473f" class="oa mr jj nw b gy of oc l od oe">while True<br/>   newpoint = Blank<br/>   T = T - delT</span><span id="56e2" class="oa mr jj nw b gy of oc l od oe">for p in point.Neighborhood<br/>      if point.k &gt; p.k<br/>         if random[0,1] &lt; exp((p.k - point.k) / T)<br/>            newpoint = p<br/>            break<br/>      elseif point.k &lt; p.k and newpoint.k &lt; p.k<br/>         newpoint = p</span><span id="f518" class="oa mr jj nw b gy of oc l od oe">if newpoint != Blank<br/>      point = newpoint<br/>   else<br/>      break</span></pre><p id="3bb2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们慢慢地浏览一下<em class="md">退火</em>的伪代码。你首先应该注意的是开头的两个新变量。我们有<strong class="lj jt"> T </strong>，起始温度，和<strong class="lj jt"> delT </strong>，它告诉我们每一步减少<strong class="lj jt"> T </strong>多少。另一个主要的区别发生在循环当前点<strong class="lj jt"> S </strong>附近的点时。如果我们正在检查的点的<strong class="lj jt"> K </strong>比<strong class="lj jt"> S </strong>低，我们运行另一个检查。在0和1之间选择一个随机数，然后检查它是否在下面的表达式中:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/876b4b608566743372b633b143dc56c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wQL8T8bppFjQqutTeCngPg.jpeg"/></div></div></figure><p id="15a1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我将此称为<strong class="lj jt"> prob </strong>。记住<strong class="lj jt"> prob </strong>指的是我们选择一个不太有利的解决方案(较低的<strong class="lj jt"> K </strong>)的概率。如果我们选择了一个不太有利的点，我们停止寻找新的点，移动到那个点，然后重新开始。剩下的<em class="md">退火</em>和<em class="md">爬山</em> <strong class="lj jt"> <em class="md">一样。</em> </strong>最终，附近将不再有具有较高<strong class="lj jt"> K </strong>的点，并且<strong class="lj jt"> prob </strong>将如此之低，以至于不会移动到具有较低<strong class="lj jt"> K </strong>的点。</p><p id="5b79" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> prob </strong>将总是小于1，因为<em class="md"> p.k &lt; point.k </em>使得指数为负。<em class="md"> p.k </em>和<em class="md">p . k</em>之间的巨大差异导致更负的指数，使得<strong class="lj jt"> prob </strong>更小。大的<strong class="lj jt"> T </strong>导致较小的负指数，这使得<strong class="lj jt"> prob </strong>更大。随着<strong class="lj jt"> T </strong>变小(但保持正值)，指数值将趋向于越来越负，使得<strong class="lj jt"> prob </strong>变小。</p><p id="c14e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这很复杂，所以我鼓励你花点时间，确保你理解这个算法。下面有个例子。</p><p id="cfd5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们对<em class="md">退火</em>的行为有很多控制。这里有很多随机性，但我们有一些空间来调整它。主要是，我们可以改变T21如何变化。<em class="md">退火</em>每次迭代减少<strong class="lj jt"> T </strong>达<strong class="lj jt"> delT </strong>。我们可以调整<strong class="lj jt"> T </strong>和<strong class="lj jt"> delT </strong>的尺寸。这将影响<em class="md">退火</em>的持续时间，以及移动到不太有利的解决方案的自由度。另一种可能是让<strong class="lj jt"> T </strong>以指数函数递减，只要它在递减。记住<strong class="lj jt"> T </strong>必须始终保持正值。我没有将它包含在<em class="md">退火</em>的伪代码中，但是如果它变得太小，应该有检查来保持<strong class="lj jt"> T </strong>为正。</p><p id="94d9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们重新检查一下图1，我把它复制到这里，这样您就不用来回滚动了。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi me"><img src="../Images/f3a9bdd076b8367c9694af6ce710a6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFk4PdmWf92IOt5nb0aKXQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图1的副本</p></figure><p id="0486" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我们看看从点<strong class="lj jt"> B </strong>开始时会发生什么。早在<em class="md">退火</em>的时候，<strong class="lj jt">的概率</strong>就很高。我们可能会远离<strong class="lj jt"> B </strong>，然后随着<strong class="lj jt"> prob </strong>减少，移回<strong class="lj jt">B</strong>，然而，我们总是有可能过于靠近<strong class="lj jt"> D </strong>，一旦<strong class="lj jt"> prob </strong>变得非常低，<em class="md"> Anneal </em>将卡在该区域，并在<strong class="lj jt"> D </strong>处结束。这是<em class="md">退火</em>的权衡。虽然我们更有可能获得具有更高<strong class="lj jt"> K </strong>的最终点，但我们也更有可能跳过具有真正高值<strong class="lj jt"> K </strong>的点。从某种意义上来说，<em class="md">退火</em>使我们的最终<strong class="lj jt"> K </strong>相对于<em class="md">爬坡居中。我们很少得到很低和很高的K值。有趣的是，我们的算法有更多的随机性，<em class="md">退火</em>，导致最终点的随机性减少。</em></p><p id="eee5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从<strong class="lj jt"> A </strong>开始通常会导致<strong class="lj jt"> B </strong>的最终答案，但是仍然有可能会向右移动太多，并在<strong class="lj jt"> D </strong>处结束。</p><p id="7462" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们来看看<strong class="lj jt"> C </strong>，这将揭示出我给出的<em class="md">退火</em><strong class="lj jt"><em class="md"/></strong>pseuodcode中的一个缺陷。<em class="md">退火</em>在<strong class="lj jt"> C </strong>时<strong class="lj jt">总是</strong>右移，不管<strong class="lj jt"> prob </strong>是什么。这是因为<em class="md">退火</em>仅在相邻点的<strong class="lj jt"> K </strong>低于我们当前点时检查<strong class="lj jt"> prob </strong>。如果所有相邻的点都有一个更高的<strong class="lj jt"> K </strong>，那么<em class="md">退火</em>也会选择最高的一个来移动。这也意味着从点<strong class="lj jt"> D </strong>开始永远不会导致在<strong class="lj jt"> B </strong>结束。</p><p id="d962" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">看看能不能写点伪代码解决这个问题！下面是一个潜在解决方案的简要描述。如果我们生成一个小于<strong class="lj jt">概率</strong>的随机数，总是移动到比另一个相邻点具有更低<strong class="lj jt"> K </strong>的相邻点。如果是一条领带，随便挑一条。那里！现在我们的算法不会卡在<strong class="lj jt"> C </strong>上，如果它从<strong class="lj jt"> D </strong>开始，可能会移动到<strong class="lj jt"> B </strong>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="78d3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有许多其他方法可以解决这个问题。他们中的许多人也从其他自然过程中获得灵感！例如，<a class="ae jg" href="https://en.wikipedia.org/wiki/Quantum_annealing" rel="noopener ugc nofollow" target="_blank">量子退火</a>使用<strong class="lj jt">概率</strong>函数，如下所示:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/5f27dffb0bcbc03b0d920114bc972b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sb3YwZR_5N0wqi4tlDEBCw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><strong class="bd oi">探针</strong>用于量子退火</p></figure><p id="9671" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该函数还考虑了分隔这两点的最大宽度。量子退火更有可能穿过非常高但也非常薄的局部极大值。这种算法还有其他变体！</p><p id="2a98" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我个人最喜欢的是那套<a class="ae jg" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank">遗传算法</a>。这些算法从物种的自然进化中获得灵感。这个过程将从大量的随机解开始，而不是从一个随机解开始。这叫第一代。每个解决方案都有一个K值，我们称之为“适应性”有一个概率函数<strong class="lj jt">再现</strong>随<strong class="lj jt"> K </strong>增加，随时间减少。对于每个“步骤”，对照<strong class="lj jt">检查每个解决方案，在当前世代中再现</strong>。因此，更“适合”的解决方案有更高的重现机会。将通过的解决方案随机配对。对于每一对，以某种方式组合解决方案，产生一个具有双亲特征的后代。此外，检查每一个后代是否有<strong class="lj jt">突变</strong>的概率，如果通过了，就会对其进行随机改变。现在对新一代的后代重复这个过程！</p><p id="a9d7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">遗传算法有很多种。虽然它可能非常有效，但有许多步骤，可能比攀爬或退火需要更长的时间。还有如何组合解决方案的问题。有些问题有明显的组合，有些问题就模糊得多。</p><p id="1524" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其他一些有趣方法包括<a class="ae jg" href="https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms" rel="noopener ugc nofollow" target="_blank">蚁群优化</a>、<a class="ae jg" href="https://en.wikipedia.org/wiki/Particle_swarm_optimization" rel="noopener ugc nofollow" target="_blank">粒子群集</a>以及<a class="ae jg" href="https://en.wikipedia.org/wiki/List_of_metaphor-based_metaheuristics#Political_Optimizer_(PO)_(Qamar_Askari,_Irfan_Younas_&amp;_Mehreen_Saeed_2020)" rel="noopener ugc nofollow" target="_blank">更多</a>！尽情探索吧！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="664b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">感谢阅读！如果您对本文有任何想法或问题，请发表评论。</p><p id="7a51" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你喜欢我的作品，那就考虑用<a class="ae jg" href="https://medium.com/@colefp/membership" rel="noopener">这个链接</a>报名成为一个中等会员吧！每月只需5美元，使用该链接直接支持我。你也可以<a class="ae jg" href="https://www.buymeacoffee.com/colefp" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a>！如果有的话，先谢谢你了！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="5487" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">解决<em class="md">爬山</em>问题的方法是点<strong class="lj jt"> D </strong>。尽管事实上与<strong class="lj jt"> C </strong>相邻的两个点都较高，但它总是向右移动，因为那是最高的。该算法将最终停留在<strong class="lj jt"> D. </strong></p></div></div>    
</body>
</html>