<html>
<head>
<title>How to solve escalation issues on your database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决数据库的升级问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/escalating-your-database-1f945adf67ec?source=collection_archive---------37-----------------------#2020-10-23">https://towardsdatascience.com/escalating-your-database-1f945adf67ec?source=collection_archive---------37-----------------------#2020-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="44aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">了解当您遇到性能问题时升级数据库的最佳技术</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f86fe296f34190fc1c3da8e667d27218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i3kHH_otpEftIsp5"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@ev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ev </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6fe6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当项目增长时，最常见的瓶颈之一是在数据库方面。这可能是因为程序的复杂性由于新的需求而增加，或者更常见的是，由于应用程序应该处理的流量的增加。</p><h2 id="9325" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">之前的考虑</h2><p id="0c13" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">像在许多其他情况下一样，您应该根据指标升级您的数据库。一般来说，在没有首先研究数据库、应用程序和基础设施指标的情况下，我不会建议应用任何数据库升级。此规则的唯一例外是当您的应用程序出现故障时，经常出现超出范围、性能和/或延迟问题，甚至数据库过载和锁定。</p><p id="9e4c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">此外，我的建议是，除非必要，否则不要应用这些技巧。如果您不希望或没有面临数据库问题，您不应该过度扩展您的系统。您必须意识到不同升级选项的权衡以及它们带来的后果，例如系统复杂性的增加、维护中的问题、调试难度的增加等等。</p><p id="053d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们一起回顾一下可用的主要选项:</p><h1 id="80ec" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated"><strong class="ak">添加一个索引</strong></h1><p id="929b" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">为应用程序所需的搜索向表中添加额外的索引将降低查询的延迟。</p><p id="0b02" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种解决方案的缺点是您将消耗更多的数据库硬盘空间。创建新索引时，会创建一个记录数与原始表相同的新表。</p><p id="c939" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">此外，请注意，使用这种解决方案时，对数据库的写操作会比较慢，因为您需要在索引表中执行额外的搜索和写操作。一般来说，这不会是一个问题，除非您的IOPS操作在写入方面非常不平衡(尤其是在包含几百万条记录的大型表中)，或者/或者您滥用了这个解决方案，在同一个表中添加了几个索引。</p><h1 id="ff52" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated"><strong class="ak">使用缓存解决方案</strong></h1><p id="b458" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">基本上，当您缓存一个查询时，数据库引擎不会在下一次被请求时重复相同的查询。当然，这可以节省时间、减少延迟并提高性能。您可以在不同级别应用缓存:</p><ul class=""><li id="1243" class="nf ng it lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated">在数据库引擎级别。当查询到达数据库时，如果该查询之前已经完成，引擎提供缓存版本。虽然在数据库级别处理缓存的方式因系统而异，但是当查询的任何元素有任何修改时，整个查询都会被清除。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/74f1c2b3fff73dcad2bd43dbe0a1bd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*7eUuMUAvIUyPYDB5Y_rNeg.jpeg"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><ul class=""><li id="e49c" class="nf ng it lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated">在应用程序级别。应用程序接受一个请求，但是它不是获取数据库的信息，而是提供一个缓存响应(例如，使用Memcache或Redis)。该系统为开发人员提供了完全的所有权，因为他们可以控制何时清理缓存并以编程方式配置TTL。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/01ad99ef8d4fa5b244d38547c964f4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*Mte9fzDXVs7beUvIYLB8Zg.jpeg"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><ul class=""><li id="1562" class="nf ng it lc b ld le lg lh lj nh ln ni lr nj lv nk nl nm nn bi translated">在基础设施层面。一旦用户调用应用程序，而不是运行代码，就会提供一个缓存的响应(例如，使用Varnish)。这种解决方案避免了应用程序，但是作为一种折衷，清理缓存更加困难。同时，它没有连接到应用程序，应该依赖于适当的TTL配置。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/13df1bd662dccefc6a8b7b891d23e616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*pRv_sMNIKN_383eC-Vny1w.jpeg"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><h1 id="9eb1" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated"><strong class="ak">使用复制品</strong></h1><p id="4a87" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">该选项背后的想法是设置一个或多个将与主数据库实例同步的副本。然后，您可以导出副本的读取流量。这样，您减少了主实例的写操作流量，从而提高了整个系统的性能。</p><p id="d0f7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个解决方案的权衡包括复杂性和成本的增加(您应该至少加倍实例)。此外，您应该在数据库端有一个健壮的基础设施，确保正确的复制，没有错误或严重的滞后。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi np"><img src="../Images/baf604ed22e32dce22b8349d8c881e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*2lZkwrh9G8vtdhupzkrSkQ.jpeg"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><h1 id="b837" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated"><strong class="ak">应用分片</strong></h1><p id="0612" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">基本上，这个解决方案将主数据库分成多个更小的数据库，称为碎片。虽然不同的操作将由不同的(更小的)碎片来处理，但在大多数情况下，性能和延迟将显著改善，从而结束几乎所有的数据库瓶颈。</p><p id="016c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">分片有两种不同的实现方式，垂直共享和水平分片:</p><p id="3ab0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">水平分片</strong>:每个原始表的内容被拆分到不同的机器上，保持它们之间相同的表结构(列、索引等)。)</p><p id="0425" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">垂直分割</strong>:表格在列级分割。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nq"><img src="../Images/415ac04428a777f2ca700044c0fe2465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1B9v9dx6haBqWqIdapkrFQ.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><p id="cfc0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">虽然每个分片中的数据集更小，但是任何原子查询都会运行得更快；此外，写操作失败和并发问题的风险更低。请注意，情况并不总是如此，当您需要连接来自不同碎片的值时，尤其是当您还按多个列进行分组或排序时，性能会受到严重影响。</p><p id="0de6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">分片数据库为您提供了几个好处，但是它也带来了巨大的复杂性。当您需要将您的系统从非分片转移到分片时，它的初始实现需要一个详细的计划和实现。然后，维护需要对现有的新基础设施以及分片架构有深入的了解。任何新的开发都应该记住分片架构，并且需要更多的时间进行规划。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1a64497b767d4212040781c018ca7bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*MecVOTTQvND8yaqpYbJbxw.jpeg"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">简化分片App- DB工作流-作者图片</p></figure><h1 id="6dad" class="mu lx it bd ly mv mw mx mb my mz na me jz nb ka mh kc nc kd mk kf nd kg mn ne bi translated">最后的想法</h1><p id="39b5" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">升级数据库从来都不是一项简单的任务。让我坚持两点:首先，在开始之前，你需要精确的度量。其次，您需要深入理解您的应用程序、需求和缺陷，不仅包括纯技术方面，还包括产品和用户期望。</p><p id="65c6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，请注意，我保持文章的一般性。升级数据库问题是一件严肃的事情。我并没有特意介绍代理实现、Viper或MariaDB缓存系统——只是提到一些您可以考虑的潜在情况。本文的目的是让您对可以应用的关键解决方案有一个大致的了解。细节和实现同样取决于您的指标和应用。</p></div></div>    
</body>
</html>