<html>
<head>
<title>⚡️ Load the same CSV file 10X times faster and with 10X less memory⚡️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">⚡️加载相同CSV文件的速度提高了10倍，memory⚡️减少了10倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/%EF%B8%8F-load-the-same-csv-file-10x-times-faster-and-with-10x-less-memory-%EF%B8%8F-e93b485086c7?source=collection_archive---------2-----------------------#2020-10-05">https://towardsdatascience.com/%EF%B8%8F-load-the-same-csv-file-10x-times-faster-and-with-10x-less-memory-%EF%B8%8F-e93b485086c7?source=collection_archive---------2-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3fff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">熊猫，达克，多重加工，等等…</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/605444673ceba74ef491799e5a4b3c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I8sDqvRwyH3u3J8f"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@caraventurera?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡拉·富勒</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a> ( <strong class="bd ld">最快的哺乳动物</strong>)上拍摄</p></figure><p id="46d3" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">即使我们有1TB的磁盘存储、8GB/16GB的RAM，许多其他数据加载API仍然难以加载2GB的文件。</p><p id="db07" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是因为当进程请求内存时，内存以两种方式分配:</p><ol class=""><li id="2ae3" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated">连续内存分配(分配连续的块)</li><li id="0c85" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">非连续内存分配(不同位置的独立块)</li></ol><p id="c1ff" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Pandas使用连续内存将数据加载到RAM中，因为RAM上的读写操作必须比磁盘(或SSD)快。</p><ul class=""><li id="c2e1" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mo mg mh mi bi translated">固态硬盘读数:~16，000纳秒</li><li id="3b84" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mo mg mh mi bi translated">从RAM中读取:~100纳秒</li></ul><p id="d05d" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在进入多处理&amp; GPUs等之前…让我们看看如何有效地使用<em class="mp"> pd.read_csv() </em>。</p><blockquote class="mq"><p id="f4f2" class="mr ms iq bd mt mu mv mw mx my mz lz dk translated">Pandas可以很好地加载数据和预处理，但是要训练你的模型，从<a class="ae lc" href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>或<a class="ae lc" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>或任何你运行模型的地方开始使用DataLoader。</p></blockquote><figure class="nb nc nd ne nf kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi na"><img src="../Images/1af565c16265bbd16a1078d9ca107084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k3JnCz15uVLILmMY"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">塞巴斯蒂安·耶佩斯在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="mq"><p id="788a" class="mr ms iq bd mt mu ng nh ni nj nk lz dk translated">注意:如果您在手机上阅读，您可能无法滚动浏览代码。(打开要点可读性更好。)</p></blockquote><h2 id="ca37" class="nl nm iq bd nn no np dn nq nr ns dp nt ln nu nv nw lr nx ny nz lv oa ob oc od bi translated"><strong class="ak"> <em class="oe"> 1。使用列:</em> </strong></h2><p id="2a06" class="pw-post-body-paragraph le lf iq lg b lh of jr lj lk og ju lm ln oh lp lq lr oi lt lu lv oj lx ly lz ij bi translated">而不是加载数据并删除处理数据时无用的不必要的列。只加载有用的列。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">🔥内存使用与您使用的列数成比例。🔥</p></figure><h2 id="6fbc" class="nl nm iq bd nn no om dn nq nr on dp nt ln oo nv nw lr op ny nz lv oq ob oc od bi translated"><strong class="ak"> 2 <em class="oe">。</em>使用正确的</strong> <code class="fe or os ot ou b"><strong class="ak">dtypes</strong></code> <strong class="ak">进行数值数据:</strong></h2><p id="fdae" class="pw-post-body-paragraph le lf iq lg b lh of jr lj lk og ju lm ln oh lp lq lr oi lt lu lv oj lx ly lz ij bi translated">在熊猫数据框架中，每一列都有自己的<code class="fe or os ot ou b">dtype</code>，例如，整数有<code class="fe or os ot ou b">int64</code>、<code class="fe or os ot ou b">int32</code>、<code class="fe or os ot ou b">int16</code>等</p><ul class=""><li id="b9b2" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mo mg mh mi bi translated"><code class="fe or os ot ou b">int8</code>可以存储-128到127的整数。</li><li id="aea7" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mo mg mh mi bi translated"><code class="fe or os ot ou b">int16</code>可以存储从-32768到32767的整数。</li><li id="ee70" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mo mg mh mi bi translated"><code class="fe or os ot ou b">int64</code>可以存储-9223372036854775808到9223372036854775807的整数。</li></ul><p id="9f27" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">默认情况下，熊猫将<code class="fe or os ot ou b">int64</code>分配给整数<code class="fe or os ot ou b">datatype</code>，因此通过定义正确的<code class="fe or os ot ou b">dtypes</code>，我们可以显著减少内存使用。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">🔥内存使用减少了75%。🔥</p></figure><p id="e718" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ir">🔥Pro提示:</strong>在加载数据时使用<code class="fe or os ot ou b">converters</code>来替换缺失值或nan，特别是对于使用<code class="fe or os ot ou b">dtype.</code>预定义了数据类型的列</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/006000411a026665c6b5b00d8c1d4e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*kwUv9LSh0L-XDmj_Znu6YA.png"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ow"><img src="../Images/f69099691a73c19c2d2873dbad2675e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t-CCHL-k0UmRIQAM"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae lc" href="https://unsplash.com/@sam_girven?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞缪尔·吉文</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="c3ab" class="nl nm iq bd nn no om dn nq nr on dp nt ln oo nv nw lr op ny nz lv oq ob oc od bi translated"><strong class="ak"> <em class="oe"> 3。使用正确的</em> </strong> <code class="fe or os ot ou b"><strong class="ak"><em class="oe">dtypes</em></strong></code> <strong class="ak"> <em class="oe">进行分类列:</em> </strong></h2><p id="0006" class="pw-post-body-paragraph le lf iq lg b lh of jr lj lk og ju lm ln oh lp lq lr oi lt lu lv oj lx ly lz ij bi translated">在我的数据集中，我有一个列<code class="fe or os ot ou b">Thumb</code>，默认情况下它被解析为一个字符串，但是它只包含固定数量的值，这些值对于任何数据集都保持不变。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ox"><img src="../Images/4ff61fae205cc79279a660e126e5ac10.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*9nZXro8upEt_2cxPepCRKw.png"/></div></div></figure><p id="7593" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">还有性别等栏目..可存储为<a class="ae lc" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html" rel="noopener ugc nofollow" target="_blank">分类</a>值，将内存从约1000 KB减少至约100 KB。(检查sat)</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">🔥内存使用减少了97%。🔥</p></figure><p id="9d4d" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ir">🔥专业提示:</strong>如果你的数据帧包含大量空值、缺失值或nan，你可以通过将它们转换成<a class="ae lc" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/sparse.html" rel="noopener ugc nofollow" target="_blank">稀疏序列</a>来减少它们的内存占用。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="1f6c" class="nl nm iq bd nn no om dn nq nr on dp nt ln oo nv nw lr op ny nz lv oq ob oc od bi translated"><strong class="ak"> <em class="oe"> 4。nrows，跳过行</em>和</strong></h2><p id="e1c9" class="pw-post-body-paragraph le lf iq lg b lh of jr lj lk og ju lm ln oh lp lq lr oi lt lu lv oj lx ly lz ij bi translated">甚至在将所有数据加载到RAM之前，使用小数据集测试您的函数和工作流总是一个好的做法，pandas使精确选择行数变得更加容易(您甚至可以跳过不需要的行。)</p><p id="2871" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在大多数情况下，出于测试目的，当一个样本可以做得很好时，您不需要加载所有数据。</p><p id="0989" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe or os ot ou b">nrows</code>从文件中读取的行数。</p><pre class="kn ko kp kq gt oy ou oz pa aw pb bi"><span id="3a64" class="nl nm iq ou b gy pc pd l pe pf">&gt;&gt;&gt; Import pandas as pd<br/>&gt;&gt;&gt; df = pd.read_csv("train.csv", nrows=1000)<br/>&gt;&gt;&gt;len(df)<br/>1000</span></pre><p id="21c7" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe or os ot ou b">skiprows</code>文件开头要跳过的行数(0-索引)或要跳过的行数(int)。</p><pre class="kn ko kp kq gt oy ou oz pa aw pb bi"><span id="d09d" class="nl nm iq ou b gy pc pd l pe pf"># Can be either list or first N rows.<br/>df = pd.read_csv('train.csv', skiprows=[0,2,5]) <br/># It might remove headings</span></pre><p id="c56d" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ir">🔥提示:</strong><code class="fe or os ot ou b">nrows</code>的一个有效用法是当您有超过100个列时，检查并为每一列定义正确的数据类型。所有这些开销都可以使用如下所示的<code class="fe or os ot ou b">nrows</code>来减少。</p><pre class="kn ko kp kq gt oy ou oz pa aw pb bi"><span id="750f" class="nl nm iq ou b gy pc pd l pe pf">sample = pd.read_csv("train.csv", nrows=100) # Load Sample data</span><span id="2407" class="nl nm iq ou b gy pg pd l pe pf">dtypes = sample.dtypes # Get the dtypes<br/>cols = sample.columns # Get the columns</span><span id="790a" class="nl nm iq ou b gy pg pd l pe pf">dtype_dictionary = {} <br/>for c in cols:<br/>    """<br/>    Write your own dtypes using <br/>    # rule 2<br/>    # rule 3 <br/>    """<br/>    if str(dtypes[c]) == 'int64':<br/>        dtype_dictionary[c] = 'float32' # Handle NANs in int columns<br/>    else:<br/>        dtype_dictionary[c] = str(dtypes[c])</span><span id="e2d7" class="nl nm iq ou b gy pg pd l pe pf"># Load Data with increased speed and reduced memory.<br/>df = pd.read_csv("train.csv", dtype=dtype_dictionary, <br/>                 keep_default_na=False, <br/>                 error_bad_lines=False,<br/>                 na_values=['na',''])</span></pre><p id="2a3f" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ir">注意:</strong>由于nan在pandas中被认为是float，所以如果您的列包含nan，不要忘记将integer data _ types转换为float。</p><p id="6761" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ir"> 5。分块加载数据:</strong></p><p id="ae68" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">熊猫read_csv()中的内存<a class="ae lc" href="https://wesmckinney.com/blog/update-on-upcoming-pandas-v0-10-new-file-parser-other-performance-wins/" rel="noopener ugc nofollow" target="_blank">问题</a>长期存在。因此，加载大型数据集的最佳变通方法之一是分块加载。</p><p id="c757" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ir">注意:</strong>分块加载数据实际上比直接读取整个数据要慢，因为您需要再次<code class="fe or os ot ou b">concat</code>分块，但是您可以轻松加载超过10 GB的文件。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ph"><img src="../Images/1333fb080561694e9d8ec111eb0f3eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oEpCfYqPO304EJhb"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@irinablok?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊琳娜·布洛克</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="89cb" class="nl nm iq bd nn no om dn nq nr on dp nt ln oo nv nw lr op ny nz lv oq ob oc od bi translated">6.使用pandas的多重处理:</h2><p id="1a0e" class="pw-post-body-paragraph le lf iq lg b lh of jr lj lk og ju lm ln oh lp lq lr oi lt lu lv oj lx ly lz ij bi translated">因为pandas没有njobs变量来利用多处理能力。我们可以利用<code class="fe or os ot ou b">multiprocessing</code>库在多线程上异步处理块大小操作，这可以将运行时间减少一半。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">古塔曼巴拉拉曼</p></figure><blockquote class="pi pj pk"><p id="1515" class="le lf mp lg b lh li jr lj lk ll ju lm pl lo lp lq pm ls lt lu pn lw lx ly lz ij bi translated"><strong class="lg ir">注意:</strong>您只需要在__main__中定义<code class="fe or os ot ou b">pool</code>，因为只有main可以在多个处理器之间异步分配池。</p></blockquote><h2 id="2ca5" class="nl nm iq bd nn no om dn nq nr on dp nt ln oo nv nw lr op ny nz lv oq ob oc od bi translated">7.Dask代替熊猫:</h2><p id="38bb" class="pw-post-body-paragraph le lf iq lg b lh of jr lj lk og ju lm ln oh lp lq lr oi lt lu lv oj lx ly lz ij bi translated">虽然Dask没有像pandas那样提供广泛的数据预处理功能，但它支持并行计算，加载数据比pandas更快</p><pre class="kn ko kp kq gt oy ou oz pa aw pb bi"><span id="97eb" class="nl nm iq ou b gy pc pd l pe pf">import dask.dataframe as dd</span><span id="938b" class="nl nm iq ou b gy pg pd l pe pf">data = dd.read_csv("train.csv",dtype={'MachineHoursCurrentMeter': 'float64'},assume_missing=True)<br/>data.compute()</span></pre><p id="54ec" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">🔥<strong class="lg ir">专业提示:</strong>如果你想知道jupyter细胞运行所需的时间，只需在细胞开始处添加<code class="fe or os ot ou b">%%time</code>魔法函数</p><p id="6962" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">试题库:<a class="ae lc" href="https://github.com/wiseio/paratext" rel="noopener ugc nofollow" target="_blank"><strong class="lg ir">Paratext</strong></a><strong class="lg ir">，</strong><a class="ae lc" href="https://github.com/h2oai/datatable" rel="noopener ugc nofollow" target="_blank"><strong class="lg ir">Datatable</strong></a><strong class="lg ir">。</strong></p><blockquote class="pi pj pk"><p id="a106" class="le lf mp lg b lh li jr lj lk ll ju lm pl lo lp lq pm ls lt lu pn lw lx ly lz ij bi translated">他们的是另一种方式，你可以在云中租一台虚拟机，64个内核和432GB内存，每小时3美元左右，甚至更好的价格。</p><p id="bf3a" class="le lf mp lg b lh li jr lj lk ll ju lm pl lo lp lq pm ls lt lu pn lw lx ly lz ij bi translated"><strong class="lg ir">警告</strong>:你需要花下一周的时间来配置它。</p></blockquote><p id="354d" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">谢谢你坚持到最后，我希望你学到了新的东西。快乐装货…✌️.（👏如果你喜欢的话。)</p><blockquote class="mq"><p id="7d8b" class="mr ms iq bd mt mu mv mw mx my mz lz dk translated">在下面评论你用来更快加载数据的技巧，我会把它们添加到列表中。</p></blockquote><p id="1c93" class="pw-post-body-paragraph le lf iq lg b lh po jr lj lk pp ju lm ln pq lp lq lr pr lt lu lv ps lx ly lz ij bi translated"><strong class="lg ir"> <em class="mp">(把他们添加到你的博客列表中):</em> </strong></p><p id="be4a" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">🔥<a class="ae lc" href="https://pythonspeed.com" rel="noopener ugc nofollow" target="_blank"> Itamar Turner-Trauring </a> —速度巨蟒大师(必须✅).</p><p id="d4f1" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">🔥<a class="ae lc" href="http://gouthamanbalaraman.com/" rel="noopener ugc nofollow" target="_blank"> Gouthaman Balaraman </a> —用python进行量化金融(必须✅).</p><p id="b395" class="pw-post-body-paragraph le lf iq lg b lh li jr lj lk ll ju lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在<a class="ae lc" href="https://www.linkedin.com/in/prudhvi-vajja-22079610b/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上与我联系。</p></div></div>    
</body>
</html>