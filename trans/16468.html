<html>
<head>
<title>SQL Window Functions — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL窗口函数—第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-window-functions-part-2-bbdcd16c1ff7?source=collection_archive---------30-----------------------#2020-11-13">https://towardsdatascience.com/sql-window-functions-part-2-bbdcd16c1ff7?source=collection_archive---------30-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="31e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不同类型的SQL窗口函数。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0885bec6ec9ce30a04b03f69f5aaf059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u9pGRivjh534RbQF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者:<a class="ae kv" href="https://unsplash.com/@franki" rel="noopener ugc nofollow" target="_blank">弗兰奇</a>|【Unsplash.com】T2</p></figure><p id="f391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">简介:</strong></p><p id="2a4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">窗口函数跨一组与当前行有某种关系的表行执行数据分析计算。地址可比较类型的计算可以用一个聚合函数来完成，该函数给出一行或按条件分组(参见图1)。</p><p id="c1fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Window函数不会导致行组合成一个输出行。保留其单独标识的行也能够访问查询结果的当前行以外的内容。(参见图1)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5ce6" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">Window Function Syntax:</strong><br/>Window_Function([All] expression) <br/>OVER( [PARTITION BY expression_list] [ORDER BY order_list Row_or_ Range clause] )</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/b92debea8edc9a9113eb1a69a8cc6c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JJpNcDN88_wlGz9W.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1 —聚合函数和窗口函数的区别</p></figure><p id="3fc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多信息请访问我的上一篇博客，我在第一部分介绍了SQL窗口函数，并概述了不同类型的SQL窗口函数。</p><p id="847a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博客中，我将解释所有三种主要类型的SQL窗口函数以及例子。</p><p id="54b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用来解释以下概念的数据库。</p><p id="633d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据集:可从Github获得:<a class="ae kv" href="https://github.com/GDhasade/Medium.com_Contents/blob/master/SQL/Retails.csv" rel="noopener ugc nofollow" target="_blank"> Retails.csv </a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/41962077899c550e6ffab146db4b0754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMpm2f9Q763ulJwkSf0NOQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">零售表截图。</p></figure><p id="c64a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">SQL窗口函数的类型:</strong></p><ol class=""><li id="33f9" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated"><strong class="ky ir">窗口聚合函数</strong></li><li id="8673" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated"><strong class="ky ir">窗口排名聚合函数</strong></li><li id="8126" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated"><strong class="ky ir">窗口分析功能</strong></li></ol></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="1f33" class="na ly iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated"><strong class="ak"> 1。窗口聚合函数</strong></h1><p id="11b7" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">包含一个支持聚合函数，即AVG()、计数()、最小值()、最大值()、总和()。</p><p id="38f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">AVG():</strong></p><ul class=""><li id="b5b3" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">返回输入表达式值的平均值。</li><li id="d2fe" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">该函数处理数值，并忽略空值。</li></ul><p id="ec5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">例如:</strong></p><p id="a47a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写一个查询来计算平均订单价格。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="87e1" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">Query:<br/></strong>SELECT order_id, product_id, price, AVG(price) OVER (PARTITION BY order_id) AS Average_Order_Price <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/c450b4b85fb6871fc3fbd5d417eaa53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MEAhFUEwSBH82Uw-J8n5uA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询-AVG()</p></figure><p id="15a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释:</strong></p><ul class=""><li id="4288" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">为了计算平均订单价格，window函数对价格列使用了AVG()，对order_id使用了分区依据</li><li id="bc9f" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">考虑订单id: 1112 —包含3种产品(即1、2、5)。这三个乘积的平均值为(866 + 163 +173) / 3 = 400.667</li></ul><p id="73c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">b. COUNT(): </p><ul class=""><li id="8294" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">如果列或表达式中有空值，也计算空值的行数。</li><li id="a69d" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">在数据集中创建新要素时，此窗口函数非常有用。像计数属于每个客户的条目数。</li></ul><p id="99d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">例如:</strong></p><p id="d1b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询1: </strong>计算客户在订单中购买的产品数量。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5284" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, COUNT(*) OVER (Partition BY order_id) AS Number_of_Products <br/>FROM retails</span></pre><p id="0f05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询2: </strong>计算客户购买的产品销售数量(累计)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="acdd" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, COUNT(*) OVER (Order BY order_id) AS Number_of_Products <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/ac6f5f8611697d08eeaf292806549612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AohJxnCXcseOU70wJU2Eg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出—查询1和2 —计数()</p></figure><p id="06bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">说明:</strong></p><p id="6655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询1: </strong></p><ul class=""><li id="628f" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">按order_id划分计数属于特定order_id的记录数。</li><li id="bba5" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">在输出中，我们可以看到每个订单显示了几个产品。</li></ul><p id="b091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询二:</strong></p><ul class=""><li id="f1f2" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">Order by order_id计算记录数和特定的order_id，然后将连续顺序的记录数相加。</li><li id="fb8e" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">输出:我们可以看到计数随着与特定order_id相关的记录数量的增加而增加。</li></ul><p id="fc63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> c. Min()或Max(): </strong></p><ul class=""><li id="12ea" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">Min()或Max()分别返回输入值中表达式的最小值或最大值。</li><li id="8fef" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">两个窗口函数都处理数值，并忽略空值。</li></ul><p id="7183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">举例:</strong></p><p id="7c58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的查询向结果集添加了一个新特性，即在各自的订单中购买的产品的最低和最高价格。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="da02" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">Query:</strong><br/>SELECT order_id, name, product_id, price, <br/>MIN(price) OVER (Partition BY order_id) AS Minimum_Price_Product,<br/>MAX(price) OVER (Partition BY order_id) AS Maximum_Price_Product <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/6d9bcb1fe86750d1b5e40222651fb25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_nlyO2qjWZU5gG4K9wy3g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Output- Query- MIN()或MAX()</p></figure><p id="ed63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">说明:</strong></p><ul class=""><li id="cba9" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">对于每个order_id记录，已经添加了产品的最低和最高价格。</li><li id="994a" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">我们也可以单独使用每个功能。</li></ul><p id="aaa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> d. Sum(): </strong></p><ul class=""><li id="3f9e" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">返回所有输入值的总和/合计表达式。</li><li id="4567" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">该函数处理数值，并忽略空值。</li></ul><p id="31d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><p id="96e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的查询返回每个order_id的总价。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f5d5" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">Query:</strong><br/>SELECT order_id, name, product_id, price, <br/>SUM(price) OVER (PARTITION BY order_id) AS Average_Order_Price <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/ec02f28fb4e20bcdfc9caa3cd948d771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1kRoZsWS3ZacS4umxUwrg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询-总和()</p></figure><p id="fd92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">说明:</strong></p><ul class=""><li id="eb14" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">为每个order_id添加了带有total_order_price的新列。</li><li id="d979" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">有助于分析数据，我们有许多记录，属于每个订单id。</li></ul></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="3119" class="na ly iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">2.<strong class="ak">窗口排名聚合函数:</strong></h1><p id="ac24" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">包括支持排名函数之一，即RANK()、DENSE_RANK()、ROW_NUMBER()。</p><p id="cc52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">排名():</p><ul class=""><li id="fe16" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">基于OVER子句中的<strong class="ky ir"> ORDER BY </strong>表达式的值在一组值中的排名(请参考查询1)。</li><li id="3bc7" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">每个值在其<strong class="ky ir">分区内由</strong>表达式进行排序(参考查询2)。</li><li id="7f08" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">等级标准值相等的行将获得相同的等级。</li><li id="12c1" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">并列或相同的排名跳过连续的排名，如排名():1，1，3，4，5。</li></ul><p id="8fc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">例如:</strong></p><p id="6688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询1: </strong>根据价格对产品进行排名。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="4775" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>RANK() OVER (ORDER BY price) AS Rank_Product_Price <br/>FROM retails</span></pre><p id="7627" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询2: </strong>根据每个订单中的价格对产品进行排序(即按order_id进行划分)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e07a" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>RANK() OVER (PARTITION BY order_id ORDER BY price) AS Rank_Product_Price <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/41f6edd3e7abefb5d6a63df12299234d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLwvDwN84aMn53ORvKkzLg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出—查询1和2 —排名()</p></figure><p id="8e63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释:</strong></p><p id="78bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在两个查询中所看到的，ORDER BY表示用于对值进行排序的表达式。</p><p id="3e66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询1: </strong></p><ul class=""><li id="37e0" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">排名是基于product_price完成的。</li><li id="6df6" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">另请注意，具有相同值的9行的等级为1。</li><li id="b098" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">所以下一个等级值从10开始。</li></ul><p id="2ba6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询2: </strong></p><ul class=""><li id="5345" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">已通过ORDER BY表达式(即价格列)完成排名。</li><li id="2abc" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">检查order_id 114，我们可以看到前两个产品价格的等级是相同的。因此分配给它等级是1。</li><li id="dd78" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">下一个产品价格在order_id中排名为3。</li></ul><p id="8283" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> b. DENSE_RANK(): </strong></p><ul class=""><li id="b17f" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">与Rank()函数类似，根据由表达式和OVER子句确定的<strong class="ky ir">顺序，对一组值中的值进行排序，每个值在其由</strong>表达式确定的<strong class="ky ir">分区内进行排序。</strong></li><li id="7361" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">不同之处在于，具有相等值的行获得相同的等级和平局，或者相同的等级不跳过连续的等级。</li><li id="dff3" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated"><em class="oc">示例:</em> Dense_Rank(): 1，1，2，3，4</li></ul><p id="4d20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">举例:</strong></p><p id="acfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询:</strong> Dense_Rank根据每个订单中的价格对产品进行排序(即按order_id进行划分)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="45e8" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>DENSE_RANK() OVER (PARTITION BY order_id ORDER BY price) AS Dense_Rank_Product_Price <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/709d09311386d59e5113060a0ab3216f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCCZg9PKjx8OEMBHlxl_XQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询Dense _ Rank()</p></figure><p id="7152" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">说明:</strong></p><ul class=""><li id="e2c0" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">我们可以看到，对每一行的排序是基于ORDER BY表达式完成的，即价格值也在每个order_id内，即(按order_id划分)。</li><li id="44b2" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">order_id 1114有5个产品，其中2个产品价格相同，因此排名相同，即1。</li><li id="17e6" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">下一个秩从2开始(这是rank()和Desne_Rank()函数的主要区别)。</li><li id="4697" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">Dense_Rank()不跳过连续的秩数。</li></ul><p id="a01d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">CUME DIST():</strong></p><ul class=""><li id="6802" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">根据下面的<strong class="ky ir">公式:</strong>计算当前行在窗口分区内的<strong class="ky ir">相对等级</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/cb48c2bd572061d50ebeae123e5203ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1grFEn70Qxmmt1sZXZh5Q.png"/></div></div></figure><p id="24b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><p id="259c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询:</strong> CUME_DIST，即根据每个订单中的价格对产品进行相对排名(即按order_id划分)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d3a8" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>CUME_DIST() OVER (PARTITION BY order_id ORDER BY price) AS Dense_Rank_Product_Price <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/3085081a62fec1bedd13edd16348b748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FcLvftJcnU5I8UCIg_YNcg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询-CUME _ DIST()即相对等级</p></figure><p id="9b70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释:</strong></p><p id="3801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑具有3个产品的order_id 1112，按照下面讨论的公式计算相对等级:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/cb48c2bd572061d50ebeae123e5203ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1grFEn70Qxmmt1sZXZh5Q.png"/></div></div></figure><ul class=""><li id="d1fc" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">第3行—第一个产品:1/3 = 0.3333</li><li id="9710" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">第4行—第二个乘积:2/3 = 0.666</li><li id="bba8" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">第5行—第三个产品:3/3 = 1</li></ul><p id="a1ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，如果产品具有相同的价值或价格，则相对等级也与输出屏幕截图中的检查order_id 1114相同。</p><p id="1b9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> d. ROW_NUMBER(): </strong></p><ul class=""><li id="6e23" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">基于OVER子句中的<strong class="ky ir"> ORDER BY </strong>表达式的当前行在其分区内的序号。</li><li id="1859" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">每个值在其<strong class="ky ir">分区内由</strong>表达式排序。</li><li id="4759" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">ORDER BY表达式的值相等的行会不确定地收到不同的行号。</li></ul><p id="7c04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">例如:</strong></p><p id="bb4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询:</strong>根据产品在每个订单中的价格将Row_Number分配给产品(即按order_id划分)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="cdbd" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>ROW_NUMBER() OVER (PARTITION BY order_id ORDER BY price) AS Row_Number_Product_Price <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/6cf497ed2c3331475ffecbbc74cb4946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlecNTNbEY2QF-D6Q0m3rA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询-行编号()</p></figure><p id="744c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释:</strong></p><ul class=""><li id="be7f" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">正如我们在输出屏幕截图中看到的，行号是根据每个订单(按order_id划分)中的价格(ORDER BY expression)分配的。</li><li id="f5fb" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">不考虑值是否相同，只将row_number赋给表达式中的每一行。</li></ul><p id="b902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">e. NTILE(): </p><ul class=""><li id="e3b4" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">将每个窗口分区的行尽可能平均地分成指定数量的分级组。</li><li id="71eb" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated"><strong class="ky ir"> <em class="oc">要求OVER子句中的</em> </strong> ORDER BY子句。</li><li id="7464" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">ORDER BY子句中指定的列或表达式，首先所有值按升序排序，然后平均分配组号。</li></ul><p id="55a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">举例:</strong></p><p id="9f2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询:</strong>根据产品价格将<strong class="ky ir"> </strong>组/簇/桶编号分配给10个不同组的所有行。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9845" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>NTILE(10) OVER (ORDER BY price) AS NTile_Product_Price <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/b319078bd41a86823dd2041c9b29bae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTZECW2zVXUspmEM3DBcEA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询NTILE()</p></figure><p id="b9ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释:</strong></p><ul class=""><li id="50ae" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">在这个数据集中，我们总共有50条记录。</li><li id="49c2" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">因此，每个集群由5行组成，如输出屏幕截图所示。</li><li id="003c" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">首先，所有行都已按价格排序，然后给每一行分配一个组号。</li></ul><p id="e46d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> f. PERCENT_RANK() </strong></p><ul class=""><li id="4e98" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">使用以下公式计算当前行的百分比排名:</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/1942bfc85b1506f908d10a579d8a350b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtybJSKbatosqIjhXJsO1w.png"/></div></div></figure><p id="aac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><p id="4804" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询:</strong>根据产品价格计算或分配所有行的百分比排名。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="90b3" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>PERCENT_RANK() OVER (PARTITION BY order_id ORDER BY price) AS Row_Number_Product_Price <br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/6f8aa85bbbab338a5634fd3b08294eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTFvN8hrONOG0NTpwx3FVA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询-百分比排名()</p></figure><p id="e878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">说明:</strong></p><p id="e0fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑具有5个产品的order_id 1114，按照下面讨论的公式计算相对等级:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/1942bfc85b1506f908d10a579d8a350b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtybJSKbatosqIjhXJsO1w.png"/></div></div></figure><ul class=""><li id="1eb7" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">第9行—第一个产品:(1–1)/(5–1)= 0</li><li id="2a83" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">第10行—第二个乘积:(1–1)/(5–1)= 0</li><li id="501a" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">第11行—第三个产品:(3–1)/(5–1)= 0.5</li><li id="de9b" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">第12行—第四个产品:(4–1)/(5–1)= 0.75</li><li id="0345" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">第13行—第五个产品:(5–1)/(5–1)= 1</li></ul></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="12ae" class="na ly iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated"><strong class="ak"> 3。窗口分析功能:</strong></h1><p id="6f74" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">包括一个支持排名函数，即LAG()、LEAD()、FIRST_VALUE()、LAST_VALUE()。</p><p id="51fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> a .滞后()或超前():</strong></p><p id="6e66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">语法:</strong></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="63c2" class="lx ly iq lt b gy lz ma l mb mc">LAG | LEAD (expression)<br/>    OVER ([ PARTITION BY expression_list] [ORDER BY order_list] )</span></pre><ul class=""><li id="8222" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">滞后或超前返回时，值为当前行的值<strong class="ky ir"><em class="oc"/></strong>前或<strong class="ky ir"><em class="oc"/></strong><em class="oc"/>后分别在一个分区中。</li><li id="4263" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">如果不存在任何行，则返回null。</li></ul><p id="4614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">例如:</strong></p><p id="579d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询:</strong>添加新功能1步滞后或超前每个订单内的产品价格(即按order_id划分)</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="fd97" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>LAG(price,1) OVER (PARTITION BY order_id ORDER BY price) AS LAG_Product_Price,<br/>LEAD(price,1) OVER (PARTITION BY order_id ORDER BY price) AS LEAD_Product_Price<br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/927ccf976e7e1ae95d8260287439ede4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IezQeDXpe6ZNL2Ig3LL7DA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询-滞后()或超前()</p></figure><p id="5c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释:</strong></p><ul class=""><li id="3125" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">正如我们可以看到的，在order_id的分区中，lag和lead列分别给出1个步长值。</li><li id="fd7c" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">当它在LAG()中的第一行被估算为NULL时。</li><li id="7dd6" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">类似地，在LEAD()中，最后一行用NULL进行估算。</li></ul><p id="8ef5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> b. FIRST_VALUE()或LAST_VALUE(): </strong></p><p id="f0af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">语法:</strong></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="4d3f" class="lx ly iq lt b gy lz ma l mb mc">FIRST_VALUE | LAST_VALUE ( expression ) <br/>      OVER ( [PARTITION BY expression_list ] [ ORDER BY order_list ][ row_or_range_clause ] )</span></pre><ul class=""><li id="1dcc" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">FIRST_VALUE或LAST_VALUE分别返回指定表达式相对于窗口框架(分区)的第一行或最后一行值。</li></ul><p id="f526" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">举例:</strong></p><p id="2e13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询:</strong>在每个订单内添加新功能FIRST_VALUE或LAST_VALUE产品价格(即按order_id划分)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="82fe" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>FIRST_VALUE(price) OVER (PARTITION BY order_id) AS FIRST_VALUE_Product_Price,<br/>LAST_VALUE(price) OVER (PARTITION BY order_id) AS LAST_VALUE_Product_Price<br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/2fcb87bcb9c1434df8e3f3b596fb3ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4NJVtpCpzrEfjtpOaLsbw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询-第一个值()或最后一个值()</p></figure><p id="89b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释:</strong></p><ul class=""><li id="fdaa" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">正如我们所看到的，First_Value()和Last_Value()列分别给出第一行值和最后一行值。</li></ul><p id="8b18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> c .第n个值():</strong></p><p id="945e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">语法:</strong></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="c6d3" class="lx ly iq lt b gy lz ma l mb mc">NTH_VALUE (expression, nth_value ) <br/>      OVER ( [PARTITION BY expression_list ] [ ORDER BY order_list ][ row_or_range_clause ] )</span></pre><ul class=""><li id="20eb" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">NTH_VALUE返回分别用表达式分配给窗框(分区)的第n个值。</li><li id="1b3c" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">如果nth_value不可用，则使用NULL对其进行估算。</li></ul><p id="446c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">举例:</strong></p><p id="a705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">查询:</strong>在每个订单内增加新功能n _ VALUE产品价格(即按order_id划分)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e1f6" class="lx ly iq lt b gy lz ma l mb mc">SELECT order_id, name, product_id, price, <br/>NTH_VALUE(price,3) OVER (PARTITION BY order_id) AS NTH_VALUE_Product_Price<br/>FROM retails</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/3b6a55b7258470bf1d92ec2ae9d607f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3B0SKUFGOcsWyN1EUh6SIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出-查询-第n个值()</p></figure><p id="8cae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解说:</strong></p><ul class=""><li id="5b54" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr nw ml mm mn bi translated">在查询中，我们将第n个值指定为3，它返回第3行值，该值按order_id进行分区。</li><li id="0dbc" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr nw ml mm mn bi translated">对于order_id 1111，只有2种产品，因此该列被估算为空值。</li></ul></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="7aa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论:</strong></p><p id="1902" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博客中，我试图解释SQL中窗口函数的主要类型。</p><p id="e5dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">窗口函数在使用SQL进行数据分析时非常有用，并且易于使用。</p><p id="3cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">窗口函数围绕OVER、PARTITION BY和ROW或RANGE子句。</p><p id="e20a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这个博客，欢迎随时加入我的LinkedIn。我很想知道你对这篇文章的想法和反馈。</p><p id="2342" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p><p id="a7ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">资源:</strong></p><p id="65b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据集和SQL脚本可从<a class="ae kv" href="https://github.com/GDhasade/Medium.com_Contents/tree/master/SQL" rel="noopener ugc nofollow" target="_blank"> GITHUB </a>获得。</p><p id="4d58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献:</strong></p><ol class=""><li id="e8b0" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated">postgresql.org(2019年)。<em class="oc"> PostgreSQL:文档:9.1:窗口函数</em>。[在线]Postgresql.org。可在:<a class="ae kv" href="https://www.postgresql.org/docs/9.1/tutorial-window.html." rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/9.1/tutorial-window.html.</a></li><li id="d38b" class="mf mg iq ky b kz mo lc mp lf mq lj mr ln ms lr mk ml mm mn bi translated">drill.apache.org(未标出)。<em class="oc"> SQL窗口函数介绍— Apache Drill </em>。[在线]drill.apache.org。可在:<a class="ae kv" href="https://drill.apache.org/docs/sql-window-functions-introduction/" rel="noopener ugc nofollow" target="_blank">https://drill . Apache . org/docs/SQL-window-functions-introduction/</a>获取。</li></ol></div></div>    
</body>
</html>