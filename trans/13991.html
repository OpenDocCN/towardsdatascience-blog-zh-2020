<html>
<head>
<title>Solving a Social Distancing Problem using Genetic Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用遗传算法解决社会距离问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-a-social-distancing-problem-using-genetic-algorithms-e5f1709c87a1?source=collection_archive---------19-----------------------#2020-09-26">https://towardsdatascience.com/solving-a-social-distancing-problem-using-genetic-algorithms-e5f1709c87a1?source=collection_archive---------19-----------------------#2020-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="059e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用DEAP python包的遗传算法应用示例。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/ce80a5576d9fb86a8bbac1cd3d17411a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yol8YWIfsXdYG-dOF8QX9A.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">来源:<a class="ae kw" href="https://en.wikipedia.org/wiki/File:Plasma_fractal_theartproblem_1935.jpg" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/File:Plasma _ fractal _ the art problem _ 1935 . jpg</a></p></figure><p id="6119" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">“社交距离”如今变得非常流行，但这些规则如何适应我们的日常生活并不总是显而易见的。在这个故事中，我们将研究一个社会距离问题，并用遗传算法找到解决方案。在设定了问题及其约束条件之后，在将这些原则应用于我们的问题之前，我将总结一下遗传算法(GA)的原则。</p><h1 id="36a6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">问题是</h1><p id="9d6f" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">今年夏天(2020年8月)，来自<a class="ae kw" href="https://medium.com/neo4j" rel="noopener"> Neo4j </a>(图形数据库)的人们提出了要用图形解决的每周挑战。第一周的<a class="ae kw" href="https://medium.com/neo4j/summer-of-nodes-week-1-the-barbecue-ead98d441a91" rel="noopener">高级烧烤挑战</a>包括一项社交距离任务，其规则如下:</p><ul class=""><li id="3d19" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">来自11个家庭的20名客人被邀请参加一次烧烤(用婚礼、感恩节晚餐、任何派对，取决于一年中的时间来代替烧烤)。数据是CSV文件，格式为:</li></ul><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="146b" class="ne lu iq na b gy nf ng l nh ni">Guest,Family  # headers added for clarity<br/>Host,A<br/>Jane,B<br/>Jun,C<br/>Oliver,C<br/>....</span></pre><ul class=""><li id="2e62" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">你可以把它们放在6张桌子上，每张桌子有6个座位，其中两个连续的座位相距1米(我们认为桌子是圆形的)</li><li id="1355" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">每张桌子必须包含来自至少两个不同家庭的客人</li><li id="4614" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">每桌不得有两个以上来自同一家庭的客人</li><li id="0bf3" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">来自不同家庭的客人必须坐在相距至少两米的地方</li></ul><p id="9442" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然这个问题可以用图来解决(参见这里提出的解决方案:<a class="ae kw" href="https://medium.com/neo4j/summer-of-nodes-week-1-the-barbecue-ead98d441a91" rel="noopener">https://medium . com/neo4j/summer-of-nodes-week-1-the-barbecue-EAD 98d 441 a 91</a>)，但在我看来，这像是一个可以用其他技术解决的约束问题。在这篇文章中，我研究了使用遗传算法来解决这个特定的问题。</p><p id="1c3c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">谈到遗传算法，让我们把重点放在这项技术背后的主要原则，以及这种算法如何帮助解决上述问题。</p><h1 id="a243" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">简而言之，遗传算法原理</h1><p id="9e5c" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">与一般的方法不同，遗传算法不考虑单一的解，而是根据某些条件(梯度等)进行更新。).取而代之的是，GA会考虑一个<strong class="kz ir">解群体</strong>，并基于偏向“最佳”个体的选择过程，在几个<strong class="kz ir">代</strong>中进化它们。这包括能够通过适应度函数来确定一个解决方案“有多好”，或者它离最佳解决方案有多远。因此，算法的步骤是:</p><ol class=""><li id="88d4" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls no mw mx my bi translated">对于群体中的每个<strong class="kz ir">个体</strong>，一个<strong class="kz ir">适应度函数决定了该个体离解</strong>有多近</li><li id="8b41" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls no mw mx my bi translated">一个<strong class="kz ir">选择</strong>过程产生下一代可能的解决方案，偏向于“最佳个体”，意思是具有最高适应性的个体</li><li id="46ec" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls no mw mx my bi translated"><strong class="kz ir">个体被突变</strong>，这意味着解基于一些规则而改变(例如:交换两个位置)并且<strong class="kz ir">交换</strong>发生，这基本上是将一个个体的某个部分与另一个交换(突变和交换的区别在这里<a class="ae kw" href="https://ai.stackexchange.com/a/9079" rel="noopener ugc nofollow" target="_blank">解释</a>)。</li><li id="2dca" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls no mw mx my bi translated">迭代过程从步骤1重新开始，直到满足停止标准(迭代次数、适应度函数达到给定阈值……)</li></ol><p id="b68b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在让我们回到我们的社交距离问题。</p><h1 id="767c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">问题定式化</h1><p id="d777" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">对我们来说，一个解决方案是列出分配给每位客人的座位。座位是一个整数，其值等于</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="a105" class="ne lu iq na b gy nf ng l nh ni">table_number * 10 + seat_number</span></pre><p id="7d99" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，表4中的座位2对应于整数42。</p><blockquote class="np nq nr"><p id="1b08" class="kx ky ns kz b la lb jr lc ld le ju lf nt lh li lj nu ll lm ln nv lp lq lr ls ij bi translated">只要我们每张桌子的座位少于10个，这种方法就很好。</p></blockquote><p id="f2bf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，<em class="ns">一个</em>解可以写成:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="77e0" class="ne lu iq na b gy nf ng l nh ni">[10, 31, 19, 20, 23, 35, 22, 5, 6, 13, 3, 17, 33, 8, 1, 28, 27, 24, 25, 15]</span></pre><p id="8d4f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">索引为0的来宾(主机)被分配到表1(基于0的索引)和座位4。相应的表格转载如下:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="f5c0" class="ne lu iq na b gy nf ng l nh ni">[[-1, 'Ren', -1, 'Mohamed', -1, 'Jeremy'],<br/> ['Avery', -1, 'Rowan', -1, 'Host', -1],<br/> [-1, 'Hugo', -1, 'Isabella', -1, 'Maria'],<br/> [-1, 'Jun', 'Oliver', -1, 'Milan', 'Mia'],<br/> ['Fatima', 'Marc', -1, 'Hannah', 'Ali', -1],<br/> [-1, 'Jane', -1, 'Aarav', -1, 'Sophie']]</span></pre><p id="0943" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nw nx ny na b">-1</code>是空座位的默认值。</p><p id="a249" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们有了每个解的表示，让我们定义它的适合度，即它与满意解的“接近度”。</p><h1 id="8935" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">适合度定义</h1><p id="5aa6" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">为了定义适合度，我们必须考虑问题定义部分中定义的三个约束中的每一个，再加上每个座位只能分配一次的事实。每次违反一个约束，适应度将相应地增加。</p><h2 id="8afa" class="ne lu iq bd lv nz oa dn lz ob oc dp md lg od oe mf lk of og mh lo oh oi mj oj bi translated">每个座位分配给一个客人</h2><p id="96db" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">为了统计座位被分配的次数，我们使用了<code class="fe nw nx ny na b">collections.Counter</code> python对象，并检查每个值出现的次数是否少于一次。否则，我们返回一个高适应值:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="2487" class="ne lu iq na b gy nf ng l nh ni">c = Counter(solution)<br/>if any( v &gt; 1 for v in c.values()):<br/>    return 100</span></pre><p id="afaa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">之后，我们可以创建表，一个2D矩阵，它的<em class="ns"> ij </em>元素包含表<em class="ns"> i </em>的座位<em class="ns"> j </em>的客人家庭。例如:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="b81b" class="ne lu iq na b gy nf ng l nh ni">[[-1, 'I', -1, 'G', -1, 'D'],<br/> ['E', -1, 'I', -1, 'A', -1],<br/> [-1, 'F', -1, 'K', -1, 'H'],<br/> [-1, 'C', 'C', -1, 'D', 'D'],<br/> ['K', 'K', -1, 'J', 'J', -1],<br/> [-1, 'B', -1, 'H', -1, 'D']]</span></pre><h2 id="5a74" class="ne lu iq bd lv nz oa dn lz ob oc dp md lg od oe mf lk of og mh lo oh oi mj oj bi translated">每桌必须包含来自至少两个家庭的客人</h2><p id="d44f" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">对于每个表(行),我们可以计算代表了多少个族，如果该表上的族少于两个，则将该表的违规数增加1:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="7491" class="ne lu iq na b gy nf ng l nh ni">c = Counter([k for k in table if k != -1])<br/>if len(c) &lt; 2:  # allow for empty tables (extra rule)<br/>    v += 1</span></pre><h2 id="db19" class="ne lu iq bd lv nz oa dn lz ob oc dp md lg od oe mf lk of og mh lo oh oi mj oj bi translated">来自同一家庭的每桌客人不得超过2人</h2><p id="0e07" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">使用同一个计数器，我们可以计算同一个家庭中有多少人坐在同一张桌子上，如果太多的人在场，就可以提高健康程度:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="c662" class="ne lu iq na b gy nf ng l nh ni">s = sum(v &gt; 2 for k, v in c.items())<br/>v += s</span></pre><p id="f88b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后是最复杂的部分:来自不同家庭的客人之间的社交距离。</p><h2 id="0e73" class="ne lu iq bd lv nz oa dn lz ob oc dp md lg od oe mf lk of og mh lo oh oi mj oj bi translated">来自不同家庭的人必须至少相隔两个座位</h2><p id="6c05" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">为了计算这个约束，我们将使用带有实用的<code class="fe nw nx ny na b">.rotate()</code>方法的<code class="fe nw nx ny na b">collections.deque</code>对象。实际是因为我们为坐在同一张桌子的0号和5号座位上的客人设置了边界条件，这两个座位相距仅1米(而不是5米)。首先，我们创造了<code class="fe nw nx ny na b">deque</code>:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="2fc1" class="ne lu iq na b gy nf ng l nh ni">td = deque(table)</span></pre><p id="6178" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们用相同的输入列表创建另一个实例，但是这个<code class="fe nw nx ny na b">deque</code>是循环的:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="845a" class="ne lu iq na b gy nf ng l nh ni">tdr = deque(table)  # table rotated<br/>tdr.rotate()</span></pre><p id="1f2e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，从表格开始:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="670f" class="ne lu iq na b gy nf ng l nh ni">table = [-1, 'I', -1, 'G', -1, 'D']</span></pre><p id="1c50" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nw nx ny na b">td</code>和<code class="fe nw nx ny na b">tdr</code>变量将包含:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="fade" class="ne lu iq na b gy nf ng l nh ni">deque([-1, 'I', -1, 'G', -1, 'D'])  # td<br/>deque(['D', -1, 'I', -1, 'G', -1])  # tdr</span></pre><p id="4bed" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从那里，我们可以迭代两个<code class="fe nw nx ny na b">deque</code>。如果这两个值等于<code class="fe nw nx ny na b">-1</code>(意味着没有客人被分配到那个座位)，我们什么也不做。否则，我们检查坐在彼此旁边的两个客人是否来自同一个家庭，否则我们增加适合度:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="b06c" class="ne lu iq na b gy nf ng l nh ni">for seat, prev_seat in zip(td, tdr):<br/>    if seat == -1 or prev_seat == -1:<br/>        continue<br/>    if seat != prev_seat:<br/>       v += 1</span></pre><p id="9b02" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">开始了，我们的健身功能终于准备好了！</p><p id="5677" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然我们只完成了一半的工作，因为我们需要配置遗传算法的参数。希望我们不必自己编写所有的代码，因为非常聪明的人已经为我们做了(谢谢！).</p><h1 id="596d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">完整代码和解决方案</h1><p id="8930" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">为了实现我们问题的GA部分，我们将依赖于DEAP(Python中的<em class="ns">分布式进化算法)Python包。</em></p><p id="5e47" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">主要步骤如下:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="3020" class="ne lu iq na b gy nf ng l nh ni"># start algorithm configuration<br/>toolbox = base.Toolbox()</span><span id="2318" class="ne lu iq na b gy ok ng l nh ni"># our objective is to minimize the fitness<br/>creator.create("FitnessMin", base.Fitness, weights=(-1.0,))</span><span id="c965" class="ne lu iq na b gy ok ng l nh ni"># create the Individual class (list of integers)<br/>creator.create("Individual", list, typecode='i', fitness=creator.FitnessMin)</span><span id="f5ec" class="ne lu iq na b gy ok ng l nh ni"># create an operator that generates randomly shuffled indices<br/>toolbox.register("randomOrder", lambda : random.sample(range(NUM_TABLES * NUM_SEATS_PER_TABLE), k=len(GUESTS)))<br/># create the 'individual creation' operator to fill up an Individual instance with shuffled indices<br/>toolbox.register("individualCreator", tools.initIterate, creator.Individual, toolbox.randomOrder)<br/># create the 'initial population creation' operator to generate a list of individuals<br/>toolbox.register("populationCreator", tools.initRepeat, list, toolbox.individualCreator)</span><span id="bdfe" class="ne lu iq na b gy ok ng l nh ni"># fitness calculation - compute the total distance of the list of cities represented by indices<br/># 'get_fitness' is our own fitness function containing the rules defined above<br/>toolbox.register("evaluate", get_fitness)<br/># Genetic operators<br/>toolbox.register("select", tools.selTournament, tournsize=10)<br/>toolbox.register("mate", tools.cxTwoPoint)<br/>toolbox.register("mutate", tools.mutShuffleIndexes, indpb=1.0/len(GUESTS))</span><span id="c5fa" class="ne lu iq na b gy ok ng l nh ni"># create initial population (generation 0):<br/>population = toolbox.populationCreator(n=POPULATION_SIZE)</span></pre><p id="7d55" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">更多细节:</p><ul class=""><li id="a715" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">初始种群生成，随机选择<code class="fe nw nx ny na b">NB_GUESTS</code>个席位(在0和<code class="fe nw nx ny na b">NUM_TABLES * NUM_SEATS_PER_TABLE</code>之间)</li><li id="27b0" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">使用上面定义的函数进行适应性计算</li><li id="b398" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">选择<a class="ae kw" href="https://deap.readthedocs.io/en/master/api/tools.html#deap.tools.selTournament" rel="noopener ugc nofollow" target="_blank">锦标赛</a>:两个两个地比较解决方案，将适应性最低的方案留给下一代(另请查看:<a class="ae kw" href="https://en.wikipedia.org/wiki/Tournament_selection" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</li><li id="809f" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">交叉:<a class="ae kw" href="https://deap.readthedocs.io/en/master/api/tools.html#deap.tools.cxTwoPoint" rel="noopener ugc nofollow" target="_blank"> cxTwoPoint </a>:从两个随机选择的解决方案中交换零件，如下图所示:</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ol"><img src="../Images/8e61590742b6179317f1fa03ba22abc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqEcLTc1rGMS-VTkfADOxw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">来源:<a class="ae kw" href="https://commons.wikimedia.org/wiki/File:TwoPointCrossover.svg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:two point crossover . SVG</a></p></figure><ul class=""><li id="dd5a" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">变异:<a class="ae kw" href="https://deap.readthedocs.io/en/master/api/tools.html#deap.tools.mutShuffleIndexes" rel="noopener ugc nofollow" target="_blank"> mutShuffleIndexes </a>:以概率<code class="fe nw nx ny na b">P_MUTATION</code>对每个解中的索引进行混洗</li></ul><p id="820b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">算法的核心被封装成:</p><pre class="kh ki kj kk gt mz na nb nc aw nd bi"><span id="d822" class="ne lu iq na b gy nf ng l nh ni">population, logbook = algorithms.eaSimple(<br/>    population,  # initial population<br/>    toolbox,   # above defined rules<br/>    # extra parameters:<br/>    cxpb=P_CROSSOVER, <br/>    mutpb=P_MUTATION,  <br/>    ngen=MAX_GENERATIONS, <br/>    # results:<br/>    stats=stats, <br/><strong class="na ir">    halloffame=hof, </strong><br/>    verbose=False<br/>)</span></pre><p id="5e00" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">名人堂包括表现最好的个人，不管他们属于哪一代。它们是我们感兴趣的解决方案。</p><p id="205c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在运行完整的代码(在GitHub 上有<a class="ae kw" href="https://github.com/stellasia/medium/blob/master/social_distancing/social_distancing_genetic_algorithm.ipynb" rel="noopener ugc nofollow" target="_blank">)后，我们可以看到名人堂中10个表现最好的个人都有一个0适应度，这意味着没有违反约束。其中一个被复制在这里:</a></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi om"><img src="../Images/63ed0c78a6ce21ecf787ca177ed30cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1s7rrU7MGESqPs21iqQcw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">来自名人堂的第一个解决方案</p></figure><p id="0873" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可以看到:</p><ul class=""><li id="6e15" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">表1包含来自3个家庭的客人，每个家庭只有一个客人，他们都被至少一个空座位隔开。</li><li id="5d15" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">对表2、3和6的观察结果相同</li><li id="a56e" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">4号桌有来自两个家庭(C和D)的客人，每个家庭两个客人。六月和奥利弗坐在彼此旁边，但是他们来自同一个家庭(C ),所以这很好，来自D家庭的米兰和米娅也一样。没有来自C的客人直接坐在来自D的客人旁边，所以最后一个约束也得到满足。</li><li id="7798" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">这同样适用于具有来自家族K和j的成员的表5。</li></ul><p id="81f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这里，我们用遗传算法的力量解决了一个社会距离问题。<em class="ns">你将能够在烤肉时遇见你的朋友，同时限制与新冠肺炎相关的风险！</em></p><p id="b8e1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以下载此代码，尝试修改参数，并查看求解器的行为。输入参数(客人、桌子数量……)和模型参数(群体大小、突变概率、交换类型……)都可以改变。</p><h1 id="b4b2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">进一步阅读</h1><p id="a39c" class="pw-post-body-paragraph kx ky iq kz b la ml jr lc ld mm ju lf lg mn li lj lk mo lm ln lo mp lq lr ls ij bi translated">喜欢这篇文章吗？查看以下相关阅读以了解更多信息。</p><ul class=""><li id="e58c" class="mq mr iq kz b la lb ld le lg ms lk mt lo mu ls mv mw mx my bi translated">https://deap.readthedocs.io/en/master/<a class="ae kw" href="https://deap.readthedocs.io/en/master/" rel="noopener ugc nofollow" target="_blank">DEAP文档</a></li><li id="9eae" class="mq mr iq kz b la nj ld nk lg nl lk nm lo nn ls mv mw mx my bi translated">Eyal Wiransky，"<a class="ae kw" href="https://www.amazon.com/Hands-Genetic-Algorithms-Python-intelligence-ebook/dp/B0842372RQ/" rel="noopener ugc nofollow" target="_blank">动手遗传算法</a> " (2020)，<em class="ns"> Packt </em>:这本书提供了许多可以用遗传算法解决的问题的例子，从组合问题到机器学习。从中我学到了很多，只能推荐！</li></ul></div></div>    
</body>
</html>