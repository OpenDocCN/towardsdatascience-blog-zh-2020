<html>
<head>
<title>Building a memory based collaborative filtering recommender</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建基于记忆的协同过滤推荐器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-does-collaborative-filtering-work-da56ea94e331?source=collection_archive---------7-----------------------#2020-10-29">https://towardsdatascience.com/how-does-collaborative-filtering-work-da56ea94e331?source=collection_archive---------7-----------------------#2020-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a4da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于记忆的协同过滤技术综述及电影推荐器的实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/26358632c11b6f8b9668b20422fc339d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H064OUQv7hFXV9wCGTpWYw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弗洛伦西亚·维亚达纳在<a class="ae ky" href="https://unsplash.com/s/photos/vynil?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章<a class="ae ky" rel="noopener" target="_blank" href="/content-based-recommender-systems-28a1dbd858f5">使用tf-idf </a>构建基于电影内容的推荐器中，我解释了如何基于流派构建一个简单的电影推荐器。</p><p id="2848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将实现一个基于内存的协同过滤模型，并讨论基于用户和基于项目的方法在概念和实现上的主要区别。</p><p id="ab6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在jupyter笔记本<a class="ae ky" href="https://github.com/AlexanderNixon/Machine-learning-reads/blob/master/Collaborative-filtering-recommenders.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到重现结果的所有代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e70a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="4544" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">协同过滤是推荐系统中最常见的技术。顾名思义，它是一种以协作方式帮助用户筛选出项目的技术，也就是说，基于相似用户的偏好。</p><p id="c0fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说Lizzy刚刚看了《<em class="mz">降临</em>》和《<em class="mz">银翼杀手2049 </em>》，现在想被推荐一些类似的电影，因为她很喜欢这些。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/56625fc8d7fe40ba8c6730ad8521a88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z1z_1Ox7TA7SAgXGM4EmEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">协同过滤(图片由作者提供)</p></figure><p id="26b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协同过滤方法背后的主要思想是找到也喜欢这些电影的用户，并根据他们的偏好推荐未看过的电影。在这个例子中，模型可能会发现喜欢这些电影的其他用户也喜欢“<em class="mz">星际</em>”，这可能是对Lizzy的一个不错的推荐。</p><p id="7ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是主要思想，但有许多方法可以解决这个问题，选择更合适的方法将取决于多种因素，例如我们正在处理的数据集的<strong class="lb iu">大小</strong>及其<strong class="lb iu">稀疏度</strong>。</p><h2 id="38a0" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">协作过滤方法的类型</h2><p id="a1e7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如上所述，有许多协同过滤(简称CF)方法，下面是我们可以找到的主要类型:</p><ul class=""><li id="cafb" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">基于记忆的</strong></li></ul><p id="df59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于记忆的方法使用用户评级历史数据来计算用户或项目之间的相似性。这些方法背后的思想是定义用户或项目之间的相似性度量，并找到最相似的来推荐未见过的项目。</p><ul class=""><li id="1111" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">基于模型的</strong></li></ul><p id="55be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于模型的CF使用机器学习算法来预测用户对未评级项目的评级。基于模型的CF算法有很多，最常用的有<a class="ae ky" href="https://en.wikipedia.org/wiki/Matrix_factorization_(recommender_systems)" rel="noopener ugc nofollow" target="_blank">矩阵分解</a>模型，如应用<a class="ae ky" href="https://en.wikipedia.org/wiki/Singular_value_decomposition" rel="noopener ugc nofollow" target="_blank"> SVD </a>重构评级矩阵，潜在狄利克雷分配或基于马尔可夫决策过程的模型。</p><ul class=""><li id="7a73" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">杂交</strong></li></ul><p id="dc3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法旨在结合基于记忆和基于模型的方法。上述方法的主要缺点之一是，你会发现自己必须在<strong class="lb iu">历史用户评级数据</strong> <em class="mz"> </em>和<strong class="lb iu">用户或物品属性</strong> <em class="mz">之间做出选择。</em>混合方法使我们能够利用两者，因此在大多数情况下表现更好。现在最广泛使用的方法是<a class="ae ky" href="https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf" rel="noopener ugc nofollow" target="_blank">因式分解机</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="1249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们更深入地研究一下基于内存的方法，因为这是我们将在这篇文章中实现的方法。</p><h2 id="6be9" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">基于内存的CF</h2><p id="7f5d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">基于<strong class="lb iu">内存的</strong>协同过滤算法主要有两种类型:<strong class="lb iu">基于用户的</strong>和<strong class="lb iu">基于项目的。</strong>虽然它们的区别很微妙，但在实践中它们会导致非常不同的方法，所以知道哪种方法对每种情况最方便是至关重要的。让我们快速浏览一下这些方法:</p><ul class=""><li id="0e28" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">基于用户的</strong></li></ul><p id="5535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们找到了看过/评价过类似内容的用户，并使用他们的偏好来推荐新项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1a81839f3948c108ec41a965944bba3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*A4GczTgjSNe6ZWmsp5dAuA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于用户的协同过滤(图片由作者提供)</p></figure><p id="cb79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个缺点是，用户往往比项目多得多，这导致更大的用户相似性矩阵(这在下一节可能会很清楚)，从而导致更大数据集上的性能和内存问题，这迫使依赖并行化技术或其他方法。</p><p id="c7dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个常见的问题是，我们会遭遇<a class="ae ky" href="https://en.wikipedia.org/wiki/Cold_start_(recommender_systems)" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a><strong class="lb iu">:</strong>可能没有或几乎没有关于新用户偏好的信息，因此没有什么可以比较的。</p><ul class=""><li id="0993" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">基于项目的</strong></li></ul><p id="f236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想法是相似的，但是相反，从一部给定的电影(或一组电影)开始，我们根据其他用户的偏好找到相似的电影。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5f0a44bc9d64033f589133953bad1fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*KBsundBuOAyTKhtzy564ig.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于项目的协同过滤(图片由作者提供)</p></figure><p id="e375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与基于用户的方法相反，项目相似性矩阵往往更小，这将减少在我们的相似性矩阵中寻找邻居的成本。</p><p id="db3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，由于一个<em class="mz">单个项目足以</em>推荐其他类似的项目，这种方法将不会遭受冷启动问题。</p><p id="1eeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于项目的方法的缺点是，与基于用户的CF相比，它们在推荐中倾向于较低的多样性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a632" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">履行</h1><h2 id="cec1" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">数据</h2><p id="d36c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将使用与<a class="ae ky" rel="noopener" target="_blank" href="/content-based-recommender-systems-28a1dbd858f5">上一篇</a>相同的数据集，即<a class="ae ky" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"> MovieLens数据集</a>，它包含来自<a class="ae ky" href="http://movielens.org/" rel="noopener ugc nofollow" target="_blank"> MovieLens网站</a>的评分数据集。它包含6000名MovieLens用户制作的约4000部电影的100万匿名评级，这些电影于2003年2月上映。</p><p id="5cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将和三个人一起工作。csv文件:<strong class="lb iu">收视率</strong>、<strong class="lb iu">用户</strong>、<strong class="lb iu">电影。</strong> <em class="mz">请查看</em> <a class="ae ky" rel="noopener" target="_blank" href="/content-based-recommender-systems-28a1dbd858f5"> <em class="mz">以前的帖子</em> </a> <em class="mz">了解更多关于数据集的详细信息。</em></p><h2 id="58be" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">用户-项目矩阵</h2><p id="25b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要做的第一件事是创建用户-项目矩阵。这实际上是一个来自评级数据的旋转表，其中行是用户，列是电影，数据框填充了用户给出的评级(如果存在，否则为<code class="fe ny nz oa ob b">0</code>):</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="f6b9" class="nb md it ob b gy og oh l oi oj">user_item_m = ratings.pivot('user_id','movie_id','rating').fillna(0)<br/>print(f'Shape: {user_item_m.shape}')<br/>&gt; Shape: (29909, 5840)</span></pre><p id="484a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来像这样(我已经加入了电影表，所以标题也可以在这里看到):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/2ca9a0fcab6abc9c814a6f5bf72084a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxf5oKGlGr-21o2O1O6yFQ.png"/></div></div></figure><h2 id="d400" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">相似矩阵</h2><p id="149c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我们将定义一个<strong class="lb iu">相似度矩阵。</strong>按照上一篇关于基于内容的推荐器的文章的思路，参见章节<a class="ae ky" rel="noopener" target="_blank" href="/content-based-recommender-systems-28a1dbd858f5"> <em class="mz">向量之间的相似性</em> </a> <em class="mz">，</em>我们想要在用户-项目矩阵<em class="mz">中找到所有用户(或项目)之间的邻近性度量。</em>常用的度量是<a class="ae ky" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦相似度</a>。</p><p id="a425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们也看到的，这种相似性度量因其等于被比较的两个向量之间的角度的余弦而得名，在这种情况下，这两个向量是得分的用户(或项目)相似性向量。两个向量之间的角度越小，余弦值就越高，从而产生更高的相似性因子。有关这方面的更多详细信息，请参见前面提到的部分。</p><p id="a292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe ny nz oa ob b">sklearn's</code> <code class="fe ny nz oa ob b">metrics.pairwise</code>子模块进行成对距离或相似性度量，在这种情况下，我们将使用<code class="fe ny nz oa ob b">cosine_similarity</code>。</p><p id="5fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，该函数具有签名:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="78a9" class="nb md it ob b gy og oh l oi oj">sklearn.metrics.pairwise.<strong class="ob iu">cosine_similarity</strong>(<em class="mz">X</em>, <em class="mz">Y=None</em>, <em class="mz">dense_output=True</em>)</span></pre><p id="c4e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa ob b">Y</code>预计在哪里:</p><blockquote class="ol om on"><p id="2d5b" class="kz la mz lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated"><strong class="lb iu">Y:</strong>n array或稀疏数组，形状:(n_samples_Y，n_features)。如果<code class="fe ny nz oa ob b">None</code>，输出将是<code class="fe ny nz oa ob b">X</code>中所有样本之间的成对相似度。</p></blockquote><p id="b54b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，通过仅指定<code class="fe ny nz oa ob b">X</code>，这将从<code class="fe ny nz oa ob b">X</code>中的样本生成相似性矩阵:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="5952" class="nb md it ob b gy og oh l oi oj">from sklearn.metrics.pairwise import cosine_similarity</span><span id="a204" class="nb md it ob b gy or oh l oi oj">X_user = cosine_similarity(user_item_m)<br/>print(X_user.shape)<br/>(6040, 6040)</span><span id="28c7" class="nb md it ob b gy or oh l oi oj">print(X_user)<br/>array([[1.   , 0.063, 0.127, 0.116, 0.075, 0.15 , 0.035, 0.102],<br/>       [0.063, 1.   , 0.111, 0.145, 0.107, 0.105, 0.246, 0.161],<br/>       [0.127, 0.111, 1.   , 0.127, 0.066, 0.036, 0.185, 0.086],<br/>       [0.116, 0.145, 0.127, 1.   , 0.052, 0.016, 0.1  , 0.072],<br/>       [0.075, 0.107, 0.066, 0.052, 1.   , 0.052, 0.106, 0.18 ],<br/>       [0.15 , 0.105, 0.036, 0.016, 0.052, 1.   , 0.067, 0.085],<br/>       [0.035, 0.246, 0.185, 0.1  , 0.106, 0.067, 1.   , 0.202],<br/>       [0.102, 0.161, 0.086, 0.072, 0.18 , 0.085, 0.202, 1.   ],<br/>       [0.174, 0.156, 0.1  , 0.092, 0.242, 0.078, 0.125, 0.217],<br/>       [0.209, 0.162, 0.158, 0.096, 0.079, 0.124, 0.091, 0.109]])</span></pre><p id="7157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将生成形状为<code class="fe ny nz oa ob b">(n_users, n_users)</code>的用户相似度矩阵。</p><p id="d11f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe ny nz oa ob b">X</code>预计为:</p><blockquote class="ol om on"><p id="4cd0" class="kz la mz lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated"><strong class="lb iu">X</strong>:n数组或稀疏数组，形状:(n_samples_X，n_features)</p></blockquote><p id="6ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过转置用户项目矩阵，我们的样本现在将是用户项目矩阵的列，即<em class="mz">电影</em>。因此，如果我们的原始用户项矩阵的形状是<code class="fe ny nz oa ob b">(n,m)</code>，通过在转置矩阵上找到余弦相似性，我们将得到一个<code class="fe ny nz oa ob b">(m,m)</code>矩阵:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="2757" class="nb md it ob b gy og oh l oi oj">X_item = cosine_similarity(user_item_m.T)<br/>X_item.shape<br/>(3706, 3706)</span></pre><p id="1b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将表示项目相似性矩阵。</p><h2 id="6129" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">该算法</h2><p id="1753" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建了相似性矩阵之后，我们现在可以定义一些逻辑来查找相似的用户。在<strong class="lb iu">基于用户的</strong>推荐的情况下，我们想要找到与我们想要推荐电影的新用户相似的用户，并且因为我们已经有了相似性分数，我们只需要搜索给定用户行中的最高值，并且从那里选择最高的<strong class="lb iu"> k </strong>。一旦我们有了<strong class="lb iu"> k </strong>最接近的用户，我们就可以找到该用户还没有看过的评分最高的电影。</p><p id="e3f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在这种情况下更简单，因为我们已经计算了所有用户之间的相似性矩阵。在实际场景中，我们必须用新用户更新相似度矩阵，然后<em class="mz">和</em>找到最相似的用户<em class="mz">。</em></p><p id="631b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于<strong class="lb iu">使用的CF </strong>的算法可以总结为:</p><ol class=""><li id="5f51" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu os nt nu nv bi translated"><em class="mz">计算新用户与所有其他用户之间的相似性(如果还没有完成)</em></li><li id="08e8" class="nn no it lb b lc ot lf ou li ov lm ow lq ox lu os nt nu nv bi translated"><em class="mz">计算</em> <strong class="lb iu"> <em class="mz"> k </em> </strong> <em class="mz">最相似用户</em>所有电影的平均评分</li><li id="c5bf" class="nn no it lb b lc ot lf ou li ov lm ow lq ox lu os nt nu nv bi translated"><em class="mz">推荐其他用户未看过的排名前</em> <strong class="lb iu"> <em class="mz"> n </em> </strong> <em class="mz">的电影</em></li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="1e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个逐步解释的实现基于用户的CF推荐器的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="8f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，基于用户和基于项目的CF系统之间的实现差异非常小。因此，将这两种方法包装在一个类中可能是一个好主意，一旦实例化，我们将使用该类向给定用户推荐电影或项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="0b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在用一些例子测试推荐器之前，定义一个函数来查看用户的偏好以了解推荐是否有意义可能是有用的。在这里，我对用户观看的电影进行分级，取前10名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="d7e0" class="nb md it bd me nc nd dn mi ne nf dp mm li ng nh mo lm ni nj mq lq nk nl ms nm bi translated">测试推荐器</h2><p id="67f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">测试一个推荐者实际上比看起来更难。在movielens数据集中，许多用户将会看到<em class="mz">所有的东西，</em>在某种意义上，他们可能会给多种类型的电影很高的评级，而不仅仅是他们最喜欢的。</p><p id="f4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试该模型的一个有用的方法是找到一些具有特定品味的用户的具体例子，例如，对一两个流派有明确的偏好。我所做的是找到已经看过几部电影的用户，但这些电影的类型很少，这意味着他们显然对这些电影有偏好。因此，推荐器被期望推荐来自相同类型的电影。</p><ul class=""><li id="facd" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">让我们从一些基于<strong class="lb iu">用户的</strong>建议开始:</li></ul><p id="20de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试一个似乎偏爱《T4》剧的用户:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="76e1" class="nb md it ob b gy og oh l oi oj">rec = CfRec(user_item_m, X_user, movies)<br/>because_user_liked(user_item_m, movies, ratings, 69)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/873da6e5e440538fac45bbfc6d14de6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*zio15Fb_2rcVE-KxQWw55Q.png"/></div></figure><p id="4727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到该用户评价最高的电影是<em class="mz">剧情</em>电影。让我们看看推荐者的建议:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="2561" class="nb md it ob b gy og oh l oi oj">rec.recommend_user_based(69)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/d8769b33f94f9d64ce48b4c7d0f24a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*AiDsIuUKrLbkcQR-g_RBPw.png"/></div></figure><p id="092b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推荐看起来不错！很难说用户是否会完全同意特定的电影，但是用户的类型偏好清楚地反映在推荐中。</p><p id="356f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们和一个恐怖电影的粉丝一起试试:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="31e6" class="nb md it ob b gy og oh l oi oj">because_user_liked(user_item_m, movies, ratings, 2155)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/b89c57fb377d02f466548adc426657f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*nMekKAAF9ihaCjbmRuJ8iw.png"/></div></figure><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="fd02" class="nb md it ob b gy og oh l oi oj">rec.recommend_user_based(2155)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/d0a573d3486f3689e36d8a45a40df1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*EMUQNMVbD1pOWXa03SJ9fg.png"/></div></figure><p id="9617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mz">《闪灵》</em>，<em class="mz">《异形》</em> …听起来这个用户错过了这些恐怖经典！</p><ul class=""><li id="199e" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">现在让我们尝试一些基于<strong class="lb iu">项目的</strong>建议</li></ul><p id="b6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的第一件事是创建该类的另一个实例，但是这次使用项目相似性矩阵作为相似性矩阵:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="80a8" class="nb md it ob b gy og oh l oi oj">rec = CfRec(user_item_m, X_item, movies)</span></pre><p id="72a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，这里的逻辑是根据其他电影推荐电影。来看看推荐者给喜欢科幻经典<strong class="lb iu"> <em class="mz">沙丘</em> : </strong>的用户什么建议</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="cf9a" class="nb md it ob b gy og oh l oi oj">rec.recommend_item_based(2021)<br/>&gt;&gt; Because you liked <strong class="ob iu">Dune (1984)</strong>, we'd recommend you to watch:</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/4e9cb082815f9cd6010a77254b89fa4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*L0rKu1SHBMoxAL9HNqdM5w.png"/></div></figure><p id="4be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，所有推荐的电影都来自同一类型，看起来都是不错的建议。</p><p id="7851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们喜欢<strong class="lb iu"> <em class="mz"> Se7en </em> </strong>，一部<em class="mz">犯罪</em>和<em class="mz">惊悚</em>电影<em class="mz">，</em>我们会被推荐去看<em class="mz"> : </em></p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="1d1d" class="nb md it ob b gy og oh l oi oj">rec.recommend_item_based(47)<br/>&gt;&gt; Because you liked <strong class="ob iu">(Se7en) (1995)</strong>, we'd recommend you to watch:</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/344644fb473a03f35fdc5cca0d9fd6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*p5MhnVJd4gN7QsH_PLVoWw.png"/></div></figure><p id="b537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，对于一部经典的<em class="mz">动画</em>电影，<strong class="lb iu"> <em class="mz">斑比</em> </strong>:</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="7732" class="nb md it ob b gy og oh l oi oj">rec.recommend_item_based(2018)<br/>&gt;&gt; Because you liked Bambi (1942), we'd recommend you to watch:</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/81917547720f403e6c59a9189ea62ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*kiJk-FQVSlzNL5hQNl78fA.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="6276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在这两种情况下，实现的协同过滤模型似乎提供了很好的推荐。</p><p id="5f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多可以改进的地方。例如，我们可以考虑这样一个事实，即在给电影分级时，用户可以表现得非常不同。一些用户可能对所有电影评价很高，而其他用户可能更挑剔。这可以通过减去每个用户的平均分来完成，然后我们就有了每个用户的标准化分数。</p><p id="8351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，我希望这个例子能够说明协同过滤方法是如何工作的。我鼓励你把它作为一个起点，也许可以稍微调整一下或者增加一些改进。</p><p id="546f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢你花时间阅读这篇文章，希望你喜欢:)</p></div></div>    
</body>
</html>