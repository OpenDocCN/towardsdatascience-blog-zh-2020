<html>
<head>
<title>Ultimate Guide to Reinforcement Learning Part 1 — Creating a Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强化学习终极指南第1部分——创建游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ultimate-guide-for-reinforced-learning-part-1-creating-a-game-956f1f2b0a91?source=collection_archive---------5-----------------------#2020-11-12">https://towardsdatascience.com/ultimate-guide-for-reinforced-learning-part-1-creating-a-game-956f1f2b0a91?source=collection_archive---------5-----------------------#2020-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6ab6" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="2774" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">在这个全面的文章系列中，我们将构建自己的环境。稍后，我们将使用强化学习来训练一个神经网络。最后，我们将创建一个视频，展示人工智能播放环境。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/898d2735f3930dd5a81a3eb91bbed071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTqXpsAOUkXhRejG0d742A.jpeg"/></div></div></figure><p id="341c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">环境、培训和展示的完整代码可以在<strong class="lc ja">GitHub</strong>:<a class="ae lw" href="https://github.com/danuo/rocket-meister/" rel="noopener ugc nofollow" target="_blank">https://github.com/danuo/rocket-meister/</a>上找到</p><h1 id="044c" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">我们将涵盖的内容:</h1><p id="7f3d" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated"><strong class="lc ja">第1部分——用<em class="mu"> Pygame </em> </strong>创建一个可玩的环境</p><ul class=""><li id="c609" class="mv mw iq lc b ld le lg lh lj mx ln my lr mz lv na nb nc nd bi translated">创造一个环境作为<strong class="lc ja">健身房。Env </strong>子类。</li><li id="bb67" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">通过<code class="fe nj nk nl nm b">step()</code>函数实现环境逻辑。</li><li id="208a" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">用<strong class="lc ja"> Pygame </strong>获取用户输入，使环境适合人类玩。</li><li id="2e26" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">用<strong class="lc ja"> Pygame </strong>实现一个<code class="fe nj nk nl nm b">render()</code>函数来可视化环境状态。</li><li id="d9c1" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">用<strong class="lc ja"> Matplotlib </strong>实现交互级设计。</li></ul><p id="6ee5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">第2部分——用强化学习训练神经网络</strong></p><p id="1572" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae lw" href="https://medium.com/@d.brummerloh/ultimate-guide-for-ai-game-creation-part-2-training-e252108dfbd1" rel="noopener">https://medium . com/@ d . brummer loh/ultimate-guide-for-ai-game-creation-part-2-training-e 252108 DFB D1</a></p><ul class=""><li id="eac0" class="mv mw iq lc b ld le lg lh lj mx ln my lr mz lv na nb nc nd bi translated">在理解可能性和挑战的同时，定义合适的观察。</li><li id="c30b" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">定义合适的奖励。</li><li id="93cb" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">用<code class="fe nj nk nl nm b">gym</code>环境训练神经网络。</li><li id="f7d5" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated">对结果的讨论</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7320" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是这个系列的第一部分。我们将实现游戏逻辑，为控件获取用户输入数据，并实现渲染，使人类有可能玩游戏。为此，我们将使用一个叫做<em class="mu"> Pygame </em>的流行python包。</p><h2 id="c859" class="np ly iq bd lz nq nr dn md ns nt dp mh lj nu nv mj ln nw nx ml lr ny nz mn iw bi translated">要求</h2><p id="f588" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">由于我们要训练的模型相对较小，因此可以在合理的时间内(不到一天)在消费级桌面CPU上进行训练。你不需要一个强大的GPU或访问云计算网络。本指南中使用的python包如下所示:</p><pre class="kp kq kr ks gt oa nm ob oc aw od bi"><span id="6392" class="np ly iq nm b gy oe of l og oh"><strong class="nm ja">Python </strong>3.8.x<br/><strong class="nm ja">ray 1.0</strong><br/><strong class="nm ja">tensorflow </strong>2.3.1<br/><strong class="nm ja">tensorflow-probability</strong> 0.11<br/><strong class="nm ja">gym 0.17.3<br/>pygame 2.0.0</strong></span></pre></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="8d2c" class="lx ly iq bd lz ma op mc md me oq mg mh kf or kg mj ki os kj ml kl ot km mn mo bi translated">环境</h1><p id="17dc" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">在强化学习的背景下，环境可以被看作是一个互动的问题，需要以最好的方式来解决。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/6643626806844ef85abc7c72a4c5e031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6djKCwIBbU0XTqpMmVZmg.jpeg"/></div></div><p class="ov ow gj gh gi ox oy bd b be z dk translated">代理与环境的相互作用。</p></figure><p id="7821" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了量化成功，在环境中定义了一个奖励函数。代理可以看到所谓的观察，这些观察给出了关于环境当前状态的信息。然后，它可以采取特定的行动，返回观察结果和下一个环境状态的标量奖励。代理人的目标是在有限的步骤中获得最大的回报。</p><p id="f2a6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">从技术角度来看，有许多不同的方式来构建环境。不过最好的方法是采用<code class="fe nj nk nl nm b">gym</code>包中定义的结构。<code class="fe nj nk nl nm b">gym</code>包是一个现成环境的集合，为强化学习提供了事实上的标准API。所有的<code class="fe nj nk nl nm b">gym</code>环境共享相同的函数和变量名称，这使得环境和代理很容易互换。为了采用<code class="fe nj nk nl nm b">gym</code>结构，我们将使我们的环境成为<strong class="lc ja">体育馆的子类。Env </strong>类。该类的基本和强制元素如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><p id="6b5e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些函数和变量中的大部分将在后面进行更深入的讨论。下面是一个简短的总结，首先列出了最重要的项目:</p><ul class=""><li id="31a1" class="mv mw iq lc b ld le lg lh lj mx ln my lr mz lv na nb nc nd bi translated"><strong class="lc ja">动作(对象):</strong>在<code class="fe nj nk nl nm b">step()</code>功能中要执行的动作。在国际象棋比赛中，这个动作是由一个玩家执行的特定的、合法的移动。</li><li id="6c65" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated"><strong class="lc ja">观察(对象):</strong>这是可供代理选择下一个动作的所有信息。该观察仅基于环境的当前状态。</li><li id="852b" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated"><strong class="lc ja">奖励(浮动):</strong>分别是上一次执行动作或上一步得到的奖励。人工智能将试图最大化总回报。回报也可能是负的。</li><li id="10e8" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated"><strong class="lc ja"> done (boolean): </strong>如果设置为true，则环境到达终点。无法执行更多操作，需要重置环境。</li><li id="dda0" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated"><strong class="lc ja"> info (dict): </strong>允许提取环境数据用于调试目的。数据对代理不可见。</li><li id="22b9" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated"><strong class="lc ja"> env_config(dict): </strong>这个可选的字典可以用来配置环境。</li><li id="0bdd" class="mv mw iq lc b ld ne lg nf lj ng ln nh lr ni lv na nb nc nd bi translated"><strong class="lc ja">观察_空间和行动_空间:</strong>正如你所想象的，对于特定的环境，只有某些行动和观察是有效的。为了定义格式，需要将<code class="fe nj nk nl nm b">observation_space</code>和<code class="fe nj nk nl nm b">action_space</code>变量分配给各自的<strong class="lc ja"> gym.space </strong>类。空间可以有不同的维度和值范围。连续空间和离散空间都是可能的。有关健身房空间的更多信息，请查看<a class="ae lw" href="http://gym.openai.com/docs/#spaces" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae lw" href="https://github.com/openai/gym/tree/master/gym/spaces" rel="noopener ugc nofollow" target="_blank">健身房GitHub </a>。</li></ul><pre class="kp kq kr ks gt oa nm ob oc aw od bi"><span id="06e4" class="np ly iq nm b gy oe of l og oh">self.observation_space = &lt;gym.space&gt;<br/>self.action_space = &lt;gym.space&gt;</span></pre><h2 id="6388" class="np ly iq bd lz nq nr dn md ns nt dp mh lj nu nv mj ln nw nx ml lr ny nz mn iw bi translated">示例:动作空间的定义</h2><p id="8918" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">正如在视频中看到的，我们想要控制一个可以向前/向后加速(动作1)和向左/向右旋转(动作2)的火箭。因此，我们将动作定义为大小为2的线性向量。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pa"><img src="../Images/10200da4cce1e2f8951dc44d6e8c4e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9cslloMot22jpNwcpbESg.png"/></div></div></figure><p id="2f68" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">每个数组单元格的值都是连续的，并且必须在[-1，1]的范围内。相应的健身房空间在下面一行代码中定义:</p><pre class="kp kq kr ks gt oa nm ob oc aw od bi"><span id="ce0f" class="np ly iq nm b gy oe of l og oh">gym.spaces.Box(low=-1., high=1., shape=(2,), dtype=np.float32)</span></pre></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="b597" class="lx ly iq bd lz ma op mc md me oq mg mh kf or kg mj ki os kj ml kl ot km mn mo bi translated">Pygame实现</h1><p id="25bf" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated"><code class="fe nj nk nl nm b">Pygame</code>是一个为创建简单游戏而设计的Python库。主要特性是2d渲染能力、用户输入采集和音频输出选项。下一节将介绍一个非常基本的<code class="fe nj nk nl nm b">Pygame</code>实现，只包含最少的功能。如果你更有野心，你可以考虑实现动态帧速率或动态分辨率等功能。</p><h2 id="926d" class="np ly iq bd lz nq nr dn md ns nt dp mh lj nu nv mj ln nw nx ml lr ny nz mn iw bi translated">翻译</h2><p id="f14d" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">为了在Pygame中渲染，我们需要创建一个窗口(也称为表面)来绘制视觉输出。</p><pre class="kp kq kr ks gt oa nm ob oc aw od bi"><span id="dac7" class="np ly iq nm b gy oe of l og oh">window = pygame.display.set_mode((window_width, window_height))</span></pre><p id="c4e1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，我们可以为创建的窗口排队draw调用。你可以在<a class="ae lw" href="https://www.pygame.org/docs/ref/draw.html" rel="noopener ugc nofollow" target="_blank"> Pygame纪录片</a>中找到可用抽奖呼叫的概述。我们将在添加到我们的<strong class="lc ja"> CustomEnv </strong>类的新函数中实现几个示例性的绘制调用。该函数名为<strong class="lc ja"> render() </strong>，如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><p id="6fe2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在进行绘制调用后，需要用<code class="fe nj nk nl nm b">pygame.display.update()</code>命令更新并实际呈现窗口。</p><h2 id="677a" class="np ly iq bd lz nq nr dn md ns nt dp mh lj nu nv mj ln nw nx ml lr ny nz mn iw bi translated">基本渲染循环</h2><p id="37f5" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">现在是时候通过创建一个渲染循环例程来让我们的环境保持运行了。我们用<code class="fe nj nk nl nm b">pygame.init()</code>初始化Pygame，然后创建一个时钟对象，它可以与<code class="fe nj nk nl nm b">tick(fps)</code>一起保持静态帧速率。我们为视觉输出创建一个大小为1000*500像素的窗口。然后我们开始一个while循环，在用<code class="fe nj nk nl nm b">update()</code>生成一帧之前，执行一次<code class="fe nj nk nl nm b">step()</code>和<code class="fe nj nk nl nm b">render()</code><strong class="lc ja"/>。显然，这个渲染循环只有在<code class="fe nj nk nl nm b">render()</code>实际上反映了<code class="fe nj nk nl nm b">step()</code>引起的变化时才有意义。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><h2 id="47fc" class="np ly iq bd lz nq nr dn md ns nt dp mh lj nu nv mj ln nw nx ml lr ny nz mn iw bi translated">用户输入</h2><p id="73a3" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">Pygame提供了两种从键盘获取用户输入数据的方法:</p><ul class=""><li id="86d1" class="mv mw iq lc b ld le lg lh lj mx ln my lr mz lv na nb nc nd bi translated">第一个名为<strong class="lc ja"> pygame.event.get() </strong>和<strong class="lc ja">将在按键状态从未按下变为按下</strong>时生成一个事件，反之亦然。其他事情，比如关闭Pygame窗口，也会创建一个事件。后者(<code class="fe nj nk nl nm b">event.type == pygame.QUIT</code>)使我们能够在不崩溃的情况下结束while循环和Python脚本。在<a class="ae lw" href="https://www.pygame.org/docs/ref/key.html" rel="noopener ugc nofollow" target="_blank"> Pygame文档</a>中可以找到密钥常量列表。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><ul class=""><li id="a7a7" class="mv mw iq lc b ld le lg lh lj mx ln my lr mz lv na nb nc nd bi translated">第二个方法叫做<strong class="lc ja">py game . key . get _ pressed()</strong>和<strong class="lc ja">将返回一个布尔类型的元组，每个条目代表键盘上的一个键。</strong>未按下的键的值为0，按下的键的值为1。为了评估键状态，我们需要知道哪些键映射到元组的哪个索引。例如，向上箭头键位于索引273处。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><h2 id="c2cf" class="np ly iq bd lz nq nr dn md ns nt dp mh lj nu nv mj ln nw nx ml lr ny nz mn iw bi translated">运动学</h2><p id="6e72" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">接下来，我们将实现火箭的运动学。当我们用一个简单的方法来处理旋转时，平移运动将有惯性。数学上，火箭的轨迹就是运动方程的解，是平滑的。位置不能跳，反而需要不断变化。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/31f45bce299ecfe4f0b72ffbbc58f4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmBg1vmZwtl5HqgcW1qGbw.jpeg"/></div></div></figure><p id="c5c1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因为我们对近似解很满意，所以我们可以用欧拉向前法进行时间离散来计算轨迹。下面的代码显示了一个简单的二维实现:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><p id="eb1a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们将所有东西(游戏逻辑、输入和渲染)合并到我们之前定义的<code class="fe nj nk nl nm b">CustomEnv</code>类中。我们还将把所有与Pygame相关的东西移到<code class="fe nj nk nl nm b">render()</code>和一个单独的<code class="fe nj nk nl nm b">init()</code>函数中。这样，我们可以用<code class="fe nj nk nl nm b">step()</code>和<code class="fe nj nk nl nm b">reset()</code>执行机器学习例程，而不用加载更重的Pygame包。如果为AI训练加载了环境，则不需要渲染，并且可以提高性能。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><p id="52c2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面是上面运行的代码，带有一些键盘输入:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pc no l"/></div></figure><h2 id="4a73" class="np ly iq bd lz nq nr dn md ns nt dp mh lj nu nv mj ln nw nx ml lr ny nz mn iw bi translated">水平设计</h2><p id="bd4e" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">现在，我们将使用手动创建的静态级别。创建一个可能是一项单调乏味的任务。我们将使用Matplotlib让我们的生活变得更简单。使用<strong class="lc ja"> plt.ginput() </strong>函数，可以通过在图形内部点击来获取坐标。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><p id="f0b9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些坐标将被打印到控制台中，您可以从那里将它们复制到您的代码中。稍微重新格式化应该可以将它们包含到我们的环境中，例如将它们存储在numpy数组中，如<code class="fe nj nk nl nm b">rocket_gym.py</code>所示。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pd no l"/></div></figure><p id="a429" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">碰撞检测</strong></p><p id="fc92" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">假设我们将级别边界存储为大小为n*4的数组，每行保存一个段的点:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><p id="06ad" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">两条直线是否相交可以通过下面的函数来检查。如果线相交，则返回交点的坐标。如果没有交集，则不返回任何交集。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><p id="5e33" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，我们可以将公式应用于我们的问题。我们通过检查是否有任何环境边界与运动向量相交来做到这一点</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oz no l"/></div></figure><h2 id="912a" class="np ly iq bd lz nq nr dn md ns nt dp mh lj nu nv mj ln nw nx ml lr ny nz mn iw bi translated">继续第2部分</h2><p id="624e" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">在第二部分中，我们将讨论并实现环境返回的观察和奖励。之后，进行实际训练。请在这里阅读:</p><p id="14de" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae lw" href="https://medium.com/@d.brummerloh/ultimate-guide-for-ai-game-creation-part-2-training-e252108dfbd1" rel="noopener">https://medium . com/@ d . brummer loh/ultimate-guide-for-ai-game-creation-part-2-training-e 252108 DFB D1</a></p></div></div>    
</body>
</html>