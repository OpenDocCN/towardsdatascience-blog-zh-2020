<html>
<head>
<title>Learning to Learn More: Meta Reinforcement Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学会学习更多:元强化学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-to-learn-more-meta-reinforcement-learning-f0cc92c178c1?source=collection_archive---------21-----------------------#2020-10-09">https://towardsdatascience.com/learning-to-learn-more-meta-reinforcement-learning-f0cc92c178c1?source=collection_archive---------21-----------------------#2020-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5c85" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">建造一个人造大脑</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/710baa15f5c1c1c4ab6fd4dc5394e329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uqouhWEEYF95go7D"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">摄影爱好在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</p></figure><p id="8b52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">强化学习的<a class="ae kv" href="https://www.dictionary.com/e/slang/eli5/" rel="noopener ugc nofollow" target="_blank"> ELI5 </a>定义是通过从以前的错误中反复学习来训练一个模型表现得更好。强化学习为代理提供了一个框架来解决现实世界中的问题。他们能够学习规则(或<em class="ls">策略</em>)来解决特定的问题，但是这些代理的主要限制之一是他们不能将学习到的策略推广到新的问题。先前学习的规则只适合特定的问题，对于其他(甚至类似的)情况通常是无用的。</p><p id="b29e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，一个好的元学习模型被期望推广到模型在训练中没有遇到的新任务或环境。适应这种新环境的过程可以被称为<em class="ls">小型学习会议</em>，在有限接触新配置的情况下进行测试。在缺乏明确的微调模型的情况下，可以观察到元学习能够自主地调整内部状态以推广到更新的环境。</p><blockquote class="lt lu lv"><p id="65bc" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">元强化学习就是应用于强化学习的元学习</p></blockquote><p id="221c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<a class="ae kv" href="https://arxiv.org/abs/1611.05763" rel="noopener ugc nofollow" target="_blank"> Wang et al. </a>将元学习描述为“使用递归模型的元学习的特殊类别，应用于学习”，这似乎比上面的定义更全面。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="0d74" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我们开始吧</h1><p id="31fe" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在强化学习中，代理在每一步接收<strong class="ky ir">观察</strong> <em class="ls"> </em>(例如视频游戏中角色的位置)，并基于这些观察输出<strong class="ky ir">动作</strong> <em class="ls"> </em>，如“向前移动”或“向右转”。基于这些行动的结果，代理会收到<strong class="ky ir">奖励</strong>或<strong class="ky ir">惩罚</strong>，这将在培训中进一步指导它，帮助它为以后的步骤做出更有意义的观察。该模型的目标是最大化奖励和最小化惩罚。</p><p id="b4f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<em class="ls">元强化学习</em>中，训练和测试任务是不同的，但是来自同一个问题家族。一个很好的例子是不同布局的迷宫，或者不同概率的多臂强盗问题(解释如下)。</p><h2 id="0c12" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">一个简单的实验</h2><p id="b83b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://lilianweng.github.io/lil-log/2018/01/23/the-multi-armed-bandit-problem-and-its-solutions.html" rel="noopener ugc nofollow" target="_blank">多臂强盗问题</a>是一个经典问题，它很好地展示了探索与开发的两难困境。你可以想象自己在一个只有两个杠杆的房间里，其他什么都没有。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/13a1de258a74044564d4ba10dc23c496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gk1BX_yx1Iza8TsC1bnbVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多兵种土匪问题；作者图片</p></figure><ol class=""><li id="57f5" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">拉左边的杠杆<em class="ls"> A1 </em>会给你一个概率<em class="ls"> p </em>来获得奖励<em class="ls"> r </em>。</li><li id="9730" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">拉右边的杆<em class="ls"> A2 </em>会给你一个概率<em class="ls"> (1-p) </em>来获得奖励<em class="ls"> r. </em></li></ol><p id="ff03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了从逻辑上回答这个问题，你必须知道概率p的值。较高的<em class="ls"> p </em>值将保证从杠杆<em class="ls"> A1 </em>获得奖励的较高机会，而较低的<em class="ls"> p </em>值将保证从杠杆<em class="ls"> A2获得奖励的较高机会。这正是meta-RL如此有趣的原因。如果你在你的模型上投入足够的价值，在与环境互动并从中学习之后，它会越来越好地选择正确的杠杆。传统的基于RL的方法将无法处理变化的概率，并且通常会因不同的<em class="ls"> p </em>值而失败。</em></p><p id="3a23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://hackernoon.com/learning-policies-for-learning-policies-meta-reinforcement-learning-rl%C2%B2-in-tensorflow-b15b592a2ddf" rel="noopener ugc nofollow" target="_blank">实际上</a>，受过不同概率的两级问题训练的meta-RL智能体能够从两级中选择正确的一级，从而使用非常少量的数据点获得最高的回报。它使用对联<em class="ls">(行动，回报)</em>来计算每个杠杆的“风险与回报”因子。</p><p id="ffd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个示例，左边是一个未经过训练的<strong class="ky ir">代理(p<em class="ls">p</em>= 0.92)，右边是一个经过训练的<strong class="ky ir">meta-RL代理(p<em class="ls">p</em>= 0.76)</strong></strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/64d4f772596a8210d3b35625dd2529f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*zqFpk911ZwOpmAXd.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">未经训练和经过训练的meta-RL代理；<a class="ae kv" href="https://hackernoon.com/learning-policies-for-learning-policies-meta-reinforcement-learning-rl%C2%B2-in-tensorflow-b15b592a2ddf" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h2 id="9762" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">关键组件</h2><p id="0aaf" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">meta-RL涉及三个关键组件。下面将对它们进行详细描述。</p><p id="2d4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">有记忆的模型:</strong>没有记忆，meta-RL模型就没用了。它需要记忆来从直接环境中获取和存储关于当前任务的知识，这将有助于它更新其隐藏状态。一个<em class="ls">递归神经网络</em>维护meta-RL模型的隐藏状态。</p><p id="743e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个好的RNN的动力对于本文的范围来说太宽泛了。然而，meta-RL和meta-RL都使用LSTM来管理它们的隐藏状态。</p><p id="1d35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">元学习算法:</strong>元学习算法将定义我们如何根据它所学习的内容来更新模型的权重。该算法的主要目标是帮助优化模型，以在最短的时间内解决一个看不见的任务，应用它从以前的任务中学到的东西。以往的研究通常使用普通梯度下降更新的LSTM细胞。</p><p id="3bc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://hackernoon.com/learning-policies-for-learning-policies-meta-reinforcement-learning-rl%C2%B2-in-tensorflow-b15b592a2ddf" rel="noopener ugc nofollow" target="_blank"/>和<a class="ae kv" href="https://arxiv.org/abs/1803.02999" rel="noopener ugc nofollow" target="_blank">爬行动物</a>，都是经过验证的方法，能够更新模型参数，以便在新的和未知的任务上实现良好的泛化性能。</p><p id="2d98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">一个合适的MDPs分布:</strong>一个<em class="ls">马尔可夫决策过程(MDP) </em>是指智能体观察环境输出的整个过程，由一个奖励和下一个状态组成，然后在此基础上做出进一步的决策。由于代理在其培训期间会暴露于许多不同类型的环境和任务，因此它需要能够快速适应不断变化的条件和不同的MDP。</p><p id="c849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这三个组件中，这是研究最少的组件，也可能是关于meta-RL的最具体的组件。由于每个任务都是一个MDP，我们可以通过修改<em class="ls">奖励配置</em>或<em class="ls">环境来构建MDP的分布。</em></p><p id="8f19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Evolutionary_algorithm" rel="noopener ugc nofollow" target="_blank">进化算法</a>是保证生成良好环境的一个很棒的方法。它们通常是启发式的，受自然选择过程的启发。一群随机产生的解会经历一个评估、选择、突变(如果我们把遗传算法也加入进来)和繁殖的循环；好的解决方案能坚持到最后。王等人的《诗人》是一个基于进化算法的框架的好例子。</p><p id="6dab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面展示了一对开放式开拓者(POET ),最初从一个普通的环境和一个随机初始化的代理开始。然后，它增长并维护一对一配对环境和代理的群体。根据作者的观点，POET旨在实现两个目标，进化环境的多样性和复杂性；以及优化代理以解决它们的并行环境。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e863d52127a9596f6ca1d69860a36df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*qxvfGGV2yg8G7GIk.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">POET:基于进化算法的框架；<a class="ae kv" href="https://eng.uber.com/poet-open-ended-deep-learning/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><blockquote class="lt lu lv"><p id="6554" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">没有奖励函数的MDP被称为</em>受控马尔可夫过程<em class="iq"> (CMP)给定预定义的CMP，我们可以通过生成奖励函数R的集合来学习关于各种任务的知识，这鼓励了有效的元学习策略的训练。</em></p><p id="ece9" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><a class="ae kv" href="https://arxiv.org/abs/1806.04640" rel="noopener ugc nofollow" target="_blank"> Gupta等人</a>提出了两种在CMP环境下增长任务分布的无监督方法。假设有一个潜在的潜在变量与每个任务相关联，它将奖励函数参数化为潜在变量的函数以及鉴别器函数(用于从状态中提取潜在变量)。<em class="iq"> — </em> <a class="ae kv" href="https://lilianweng.github.io/lil-log/2019/06/23/meta-reinforcement-learning.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="a607" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">研究论文描述了构造鉴别器函数的两种主要方法:</p><ol class=""><li id="03af" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">对鉴别器的随机权重进行采样</li><li id="7005" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">学习鉴别器功能以鼓励多样性驱动的探索。如果你正在寻找关于这个主题的更全面的分析，你可以参考他们的另一篇论文，“DIAYN(多样性是你所需要的)。</li></ol><p id="e135" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在CMP环境中增加任务分布的复杂性超出了本文的范围，我强烈推荐任何感兴趣的人深入研究这篇文章以获得更深入的观点。</p><h2 id="874c" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">与强化学习的比较</h2><p id="29a8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">meta-RL系统非常类似于普通RL算法的系统，除了最后的奖励以及最后的动作也包括在策略观察中，以及当前状态。这种改变的目的是馈送并跟踪所有任务和观察的历史，以便模型可以基于当前MDP在内部更新状态、动作和奖励之间的动态，并相应地调整其针对其他MDP的策略。</p><p id="4462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">meta-RL和meta-RL都实现了LSTM策略，其中LSTM的隐藏状态作为记忆来跟踪特征的变化。该策略本质上是循环的，不需要显式输入最终值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/f93d45f516f6c06b746a4c02d93b7f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TlAuz9f2OveMCzGj.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">meta-RL论文中使用的不同演员-评论家架构(全部都是循环模型)；<a class="ae kv" href="https://arxiv.org/abs/1611.05763" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="2f6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">训练程序如下进行:</p><ol class=""><li id="17af" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">品尝新MDP</li><li id="be77" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">重置模型的隐藏状态</li><li id="357e" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">收集多个轨迹并更新模型的权重</li><li id="023c" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">从步骤1开始重复</li></ol><h2 id="eec7" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">超出</h2><p id="5169" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">训练RL算法有时会很困难。如果一个元学习代理能够变得如此聪明，以至于它能够根据在特定任务上接受训练时推断出的知识来解决的任务分布变得非常广泛，那么我们将朝着广义智能(或新的流行词——人工通用智能{AGI})的方向前进，本质上是建立一个能够解决所有类型的RL问题的大脑。</p><p id="7174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为旁注，我还想指出meta-RL和<a class="ae kv" href="https://arxiv.org/abs/1905.10985" rel="noopener ugc nofollow" target="_blank">AI-GAs</a>(J . Clune著)之间毫不奇怪的相似之处，后者提出通往AGI的有效途径是让学习自主。它基于三个支柱:元学习架构、元学习算法和有效学习的自动生成算法。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h2 id="f259" class="nd mh iq bd mi ne nf dn mm ng nh dp mq lf ni nj ms lj nk nl mu ln nm nn mw no bi translated">参考资料和进一步阅读</h2><p id="4ec2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">没有亚瑟·朱利安尼的努力，这项工作是不可能完成的。你可以在这里查看他对meta-RL算法的出色实现。王等人的这篇<a class="ae kv" href="https://arxiv.org/abs/1611.05763" rel="noopener ugc nofollow" target="_blank">研究论文</a>也让我对meta-RL的一些核心概念有了很好的见解，如果你想有一个更全面的看法，我强烈推荐阅读它。最后，Clune、Stanley、Lehman和Wang在工程博客上发表的这篇文章也帮助我理解了这些领域的开放性，以及如何克服极其困难的挑战。Lilian Weng的这个博客也是一个很好的进一步阅读的资源。</p></div></div>    
</body>
</html>