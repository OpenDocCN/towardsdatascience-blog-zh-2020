<html>
<head>
<title>Efficient Implementation of Conditional Logic on Pandas DataFrames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas数据帧上条件逻辑的高效实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce?source=collection_archive---------3-----------------------#2020-11-03">https://towardsdatascience.com/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce?source=collection_archive---------3-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b308" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学，编程，熊猫，效率</h2><div class=""/><div class=""><h2 id="98f8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">是时候停止过于依赖。iterrows()和。应用()</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f71ec6b61c6370ccab043a7c58607baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7SOe2uC6xIast1ON"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="ae64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python可以说是目前最酷的编程语言(感谢机器学习和数据科学)，但与最好的编程语言之一c相比，它的效率并不太为人所知。条件逻辑就是一个例子。当开发机器学习模型时，很常见的是，我们需要根据从统计分析或前一次迭代的结果中得出的硬编码规则，以编程方式更新标签。承认这一点并不丢人:我一直用Pandas apply编写代码，直到有一天我厌倦了嵌套块，于是我决定研究(也就是谷歌)替代的、更易维护和更有效的方法(也就是其他方法)</p><h1 id="780f" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">演示数据集</h1><p id="a65f" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们将要使用的数据集是虹膜数据集，您可以通过pandas或seaborn免费获得。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/85b23d042084e8ebc7c28938a7a3d5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3qsiqERsG9IbCyGYAvkhg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">虹膜数据集的前5行</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/3608073f76ae7c7d229f291d72a8229b.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*EFmJGlQ3PQG_Tvn2qCckEA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">150排，听起来有点业余…</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/2bd73a73a1d70cab0fdfd429e4a0633f.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*pOCwYROp7SHOQxXDniSuLA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">150，000行，现在我们更认真了</p></figure><p id="17fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设在我们的初始分析之后，我们想要用以下逻辑来标记数据集:</p><ul class=""><li id="a730" class="ng nh it lk b ll lm lo lp lr ni lv nj lz nk md nl nm nn no bi translated">如果萼片长度&lt; 5.1, then label 0;</li><li id="e01b" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated">otherwise if sepal width &gt; 3.3，萼片长度&lt; 5.8, then label 1;</li><li id="3aaf" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated">otherwise if sepal width &gt; 3.3，花瓣长度&gt; 5.1，则标注2；</li><li id="35d0" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated">否则，如果萼片宽度&gt; 3.3，花瓣长度&lt; 1.6 and either sepal length &lt; 6.4 or petal width &lt; 1.3, then label 3;</li><li id="9d00" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated">otherwise if sepal width &gt; 3.3且任一萼片长度&lt; 6.4 or petal width &lt; 1.3, then label 4;</li><li id="15da" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated">otherwise if sepal width &gt; 3.3，则标记为5；</li><li id="dc83" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated">否则标记为6</li></ul><p id="d502" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在深入研究代码之前，让我们快速地将新的标签列设置为None:</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="df71" class="nz mf it nv b gy oa ob l oc od">iris['label'] = None</span></pre><h1 id="e0ab" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">熊猫。iterrows() +嵌套的If-Else块</h1><p id="2c06" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果你还在用这个，这篇博文绝对是适合你的地方！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="6670" class="nz mf it nv b gy oa ob l oc od">1min 29s ± 8.91 s per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="f90c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有跑的时间…好了，我们继续…</p><h1 id="cf45" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">熊猫。应用()</h1><p id="82a2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Pandas <code class="fe oe of og nv b"><a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank">.apply()</a></code>直接用于沿数据帧或<strong class="lk jd">的轴对序列</strong>的值应用函数<strong class="lk jd">。例如，如果我们有一个函数f，它对一个可迭代的数求和(即可以是一个<code class="fe oe of og nv b">list</code>、<code class="fe oe of og nv b">np.array</code>、<code class="fe oe of og nv b">tuple</code>等等)。)，并将其传递给如下所示的数据帧，我们将对一行求和:</strong></p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="771c" class="nz mf it nv b gy oa ob l oc od">def f(numbers):<br/>    return sum(numbers)</span><span id="6159" class="nz mf it nv b gy oh ob l oc od">df['Row Subtotal'] = df.apply(f, axis=1)</span></pre><p id="e748" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码片段中，<code class="fe oe of og nv b">axis=1</code>表示应用函数的方向。<code class="fe oe of og nv b">.apply()</code>会默认有<code class="fe oe of og nv b">axis=0</code>，即逐列应用该功能；而<code class="fe oe of og nv b">axis=1</code>将逐行应用该函数。</p><p id="c6e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们对熊猫<code class="fe oe of og nv b">.apply()</code>有了一个基本的了解，让我们编写分配标签的逻辑代码，看看它会运行多长时间:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="787f" class="nz mf it nv b gy oa ob l oc od">1.43 s ± 115 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="24cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于150，000行来说，1.43秒是一个非常大的进步，但仍然非常慢。想象一下，如果您需要处理一个包含数百万交易数据或信用审批的数据集，每次我们想要应用一组规则并将设计好的功能分配给一个列时，将会花费超过14秒的时间。运行足够多的专栏，你就可以在下午剩下的时间里放松下来。</p><h1 id="6b1b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">熊猫。loc[]索引</h1><p id="6610" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果你熟悉SQL，用<code class="fe oe of og nv b">.loc[]</code>给一个新列赋值实际上只是一个带有大量<code class="fe oe of og nv b">WHERE</code>条件的<code class="fe oe of og nv b">UPDATE</code>语句。因此，这肯定比对每一行或每一列应用一个函数要好得多。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="b801" class="nz mf it nv b gy oa ob l oc od">13.3 ms ± 837 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="e9b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们花的时间只有以前的十分之一，这意味着当你在家工作时，你有更少的借口离开办公桌开始网飞。然而，我们现在只使用内置的熊猫功能。虽然pandas为我们提供了一个非常方便的高级接口来与数据表交互，但效率可能会因为抽象层而降低。</p><h1 id="1207" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">Numpy。哪里()</h1><p id="b6ea" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Numpy有一个低级接口，允许与n维可迭代对象(即向量、矩阵、张量等)进行更有效的交互。它的方法通常是基于C语言的，当涉及到更复杂的计算时，它使用优化的算法，这使得它比我们重新发明的轮子要快得多。根据numpy的官方文档，<code class="fe oe of og nv b">np.where()</code>接受以下语法:</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="4810" class="nz mf it nv b gy oa ob l oc od"><strong class="nv jd">np.where</strong>(<em class="oi">condition, return value if True, return value if False</em>)</span></pre><p id="111d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本质上，这是一个二分逻辑，其中条件将被评估为布尔值，并相应地返回值。这里的诀窍是条件实际上可以是可迭代的(即布尔ndarray类型)。这意味着我们完全可以将<code class="fe oe of og nv b">df['feature'] == 1</code>作为条件传入，并将where逻辑编码为:</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="3804" class="nz mf it nv b gy oa ob l oc od"><strong class="nv jd">np.where</strong>(<em class="oi"><br/>    </em><em class="oi">df['feature'] == 1</em><em class="oi">, <br/>    'It is one', <br/>    'It is not one'<br/></em>)</span></pre><p id="c89f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以你可能会问，我们如何用一个像<code class="fe oe of og nv b">np.where()</code>这样的二分法函数来实现我们上面陈述的逻辑呢？答案很简单，却令人不安。嵌套<code class="fe oe of og nv b">np.where()</code>……(剧透:这个片段可能会触发)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="2b2d" class="nz mf it nv b gy oa ob l oc od">3.6 ms ± 149 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="a8aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">恭喜，你挺过来了。我不能告诉你我花了多少时间来计算右括号，但是嘿，这就完成了任务！我们又砍掉了熊猫的10ms。然而，这个片段是不可维护的，这意味着，它是不可接受的。</p><h1 id="c3ab" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">Numpy。选择()</h1><p id="b34d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Numpy <code class="fe oe of og nv b">.select()</code>，与<code class="fe oe of og nv b">.where()</code>不同的是，该函数旨在实现多通道逻辑。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="dc3e" class="nz mf it nv b gy oa ob l oc od"><strong class="nv jd">np.select</strong><strong class="nv jd">(</strong><em class="oi">condlist</em><strong class="nv jd">, </strong><em class="oi">choicelist</em><strong class="nv jd">, </strong><em class="oi">default=0</em><strong class="nv jd">)</strong></span></pre><p id="adbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它使用与<code class="fe oe of og nv b">np.where()</code>相似的语法，除了第一个参数现在是一个条件列表，它应该与选项具有相同的长度。使用<code class="fe oe of og nv b">np.select()</code>时要记住的一件事是，一旦满足第一个条件，就会选择一个 <strong class="lk jd">选项。这意味着，如果列表中某个超集规则位于某个子集规则之前，则该子集选项将永远不会被选中。具体来说:</strong></p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="315c" class="nz mf it nv b gy oa ob l oc od">condlist = [<br/>    df['A'] &lt;= 1,<br/>    df['A'] &lt; 1<br/>]</span><span id="8ab9" class="nz mf it nv b gy oh ob l oc od">choicelist = ['&lt;=1', '&lt;1']</span><span id="2a88" class="nz mf it nv b gy oh ob l oc od">selection = np.select(condlist, choicelist, default='&gt;1')</span></pre><p id="006e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为命中<code class="fe oe of og nv b">df['A'] &lt; 1</code>的所有行也将被<code class="fe oe of og nv b">df['A'] &lt;= 1</code>捕获，所以没有行将被标记为<code class="fe oe of og nv b">'&lt;1'</code>。为了避免这种情况发生，请确保在制定更具体的规则之前先制定一个不太具体的规则:</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="41bf" class="nz mf it nv b gy oa ob l oc od">condlist = [<br/>    df['A'] &lt; 1, # &lt; ───┬ swapped here<br/>    df['A'] &lt;= 1 # &lt; ───┘<br/>]</span><span id="904d" class="nz mf it nv b gy oh ob l oc od">choicelist = ['&lt;1', '&lt;=1'] # remember to update this as well!!</span><span id="b649" class="nz mf it nv b gy oh ob l oc od">selection = np.select(condlist, choicelist, default='&gt;1')</span></pre><p id="9ec7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你从上面看到的，你将需要更新<code class="fe oe of og nv b">condlist</code>和<code class="fe oe of og nv b">choicelsit</code>来确保代码运行顺畅。但是说真的，当网飞触手可及的时候，谁有时间做这些呢？好吧，我抓住你了，伙计！通过将其更改为字典，我们将获得大致相同的时间和内存复杂度，但代码片段更易于维护:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nb nc l"/></div></figure><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="e303" class="nz mf it nv b gy oa ob l oc od">6.29 ms ± 475 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="14c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大约是嵌套的<code class="fe oe of og nv b">np.where()</code>的两倍，但是这不仅将你从翻表括号调试中拯救出来，而且还改变了心不在焉的<code class="fe oe of og nv b">choicelist</code>。我将是第一个咬紧牙关的人，我已经忘记更新<code class="fe oe of og nv b">choicelist</code>太多次了，我已经花了四倍多的时间来调试我的机器学习模型。相信我，<code class="fe oe of og nv b">np.select()</code>跟<code class="fe oe of og nv b">dict</code>。值得！</p><h1 id="2685" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">荣誉提名</h1><ol class=""><li id="8f65" class="ng nh it lk b ll mw lo mx lr oj lv ok lz ol md om nm nn no bi translated"><strong class="lk jd"> Numpy的矢量化运算</strong>:如果您的代码涉及循环和评估一元函数、二元函数或对数字序列进行运算的函数。您肯定应该通过将数据转换成numpy ndarray来重构代码，并充分利用numpy的矢量化运算来极大地提高脚本的速度。<strong class="lk jd">结论:这是一个情境赢家！在Numpy的官方文档中查看</strong> <a class="ae lh" href="https://www.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/VectorizedOperations.html#NumPy%E2%80%99s-Mathematical-Functions" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">此处</strong> </a> <strong class="lk jd">的一元函数、二元函数或运算数字序列的函数示例！</strong></li><li id="af8d" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md om nm nn no bi translated"><code class="fe oe of og nv b"><strong class="lk jd">np.vectorize</strong></code>:不要被这个函数的名字所迷惑。这只是一个方便的函数，实际上并没有让代码运行得更快。要使用这个函数，您需要首先将您的逻辑编码成一个可调用的函数，然后运行<code class="fe oe of og nv b">np.vectorize(your_function)(your_data_series)</code>。另一个大的缺点是，为了传递给“矢量化”函数，您需要将数据帧转换成一维的可迭代对象。<strong class="lk jd">结论:如果不方便用</strong> <code class="fe oe of og nv b"><strong class="lk jd">np.vectorize</strong></code> <strong class="lk jd">，想都别想。</strong></li><li id="bc80" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md om nm nn no bi translated"><code class="fe oe of og nv b"><strong class="lk jd">numba.njit</strong></code>:这才是真正的业务，真正的向量化。当谈到优化循环时，没有超级天才的hacky移动，你根本无法轻松击败numba。它试图将任何numpy评估移动到尽可能接近C以提高效率。虽然它可以加快数字计算的速度，但它也将自己限制在数字计算上，这意味着没有pandas系列，没有字符串索引，只有numpy的ndarray，类型有<code class="fe oe of og nv b">int</code>、<code class="fe oe of og nv b">float</code>、<code class="fe oe of og nv b">datetime</code>、<code class="fe oe of og nv b">bool</code>和<code class="fe oe of og nv b">category</code>。<strong class="lk jd">结论:如果你习惯于只使用Numpy的ndarray，并且把你的逻辑转换成数值计算，那么你就是一个真正的冠军。从</strong> <a class="ae lh" href="https://numba.pydata.org/numba-doc/dev/user/5minguide.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">这里了解更多</strong> </a> <strong class="lk jd">。</strong></li></ol><h1 id="c943" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">你可能也喜欢这个</h1><p id="90e8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果你对其他Python技巧感兴趣，我为你整理了一份简短博客列表:</p><ul class=""><li id="9c42" class="ng nh it lk b ll lm lo lp lr ni lv nj lz nk md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/python-tricks-flattening-lists-75aeb1102337"> Python技巧:扁平化列表</a></li><li id="7460" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/python-tricks-how-to-check-table-merging-with-pandas-cae6b9b1d540"> Python技巧:如何检查与熊猫合并的表格</a></li><li id="84b0" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/python-tricks-simplifying-if-statements-boolean-evaluation-4e10cc7c1e71"> Python技巧:简化If语句&amp;布尔求值</a></li><li id="5387" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/python-tricks-check-multiple-variables-against-single-value-18a4d98d79f4"> Python技巧:对照单个值检查多个变量</a></li></ul><p id="864a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想了解更多关于Python、数据科学或机器学习的知识，你可能想看看这些帖子:</p><ul class=""><li id="b678" class="ng nh it lk b ll lm lo lp lr ni lv nj lz nk md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2">改进数据科学工作流程的7种简单方法</a></li><li id="3bcd" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce">熊猫数据帧上的高效条件逻辑</a></li><li id="7179" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/memory-efficiency-of-common-python-data-structures-88f0f720421">常见Python数据结构的内存效率</a></li><li id="4da3" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/parallelism-with-python-part-1-196f0458ca14">与Python并行</a></li><li id="979b" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72">数据科学的基本Jupyter扩展设置</a></li><li id="7dd8" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/mastering-root-searching-algorithms-in-python-7120c335a2a8">Python中高效的根搜索算法</a></li></ul><p id="2dff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想了解更多关于如何将机器学习应用于交易和投资的信息，这里有一些你可能感兴趣的帖子:</p><ul class=""><li id="9753" class="ng nh it lk b ll lm lo lp lr ni lv nj lz nk md nl nm nn no bi translated"><a class="ae lh" href="https://pub.towardsai.net/genetic-algorithm-for-trading-strategy-optimization-in-python-614eb660990d" rel="noopener ugc nofollow" target="_blank">用Python实现交易策略优化的遗传算法</a></li><li id="ef50" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/towards-artificial-intelligence/genetic-algorithm-stop-overfitting-trading-strategies-5df671d5cde1" rel="noopener">遗传算法——停止过度拟合交易策略</a></li><li id="f205" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" href="https://pub.towardsai.net/ann-recommendation-system-for-stock-selection-c9751a3a0520" rel="noopener ugc nofollow" target="_blank">人工神经网络选股推荐系统</a></li></ul><h1 id="b06e" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">在你走之前…</h1><p id="f187" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果可能的话，去找<code class="fe oe of og nv b">numba.njit</code>；否则，<code class="fe oe of og nv b">np.select</code>带着<code class="fe oe of og nv b">dict</code>会帮你远航，我的朋友。记住，每一点点的改进都是有帮助的！如果你从这里学到了新的东西，请告诉我！也请让我知道我是否还遗漏了其他一些巧妙的技巧！</p><p id="406c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">再见！</p><div class="on oo gp gr op oq"><a href="https://www.linkedin.com/in/louis-chan-b55b9287" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jd gy z fp ov fr fs ow fu fw jc bi translated">Louis Chan—FTI Consulting | LinkedIn数据科学总监</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">www.linkedin.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe lb oq"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://www.buymeacoffee.com/louischan"><div class="gh gi pf"><img src="../Images/8a2d23afacc637bce02ed32abb15069d.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/0*gssDeo_hlPDu8DK3.png"/></div></a></figure></div></div>    
</body>
</html>