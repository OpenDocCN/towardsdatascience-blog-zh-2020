<html>
<head>
<title>10 Awesome Python 3.9 Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个令人惊叹的Python 3.9特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-awesome-python-3-9-features-b8c27f5eba5c?source=collection_archive---------0-----------------------#2020-10-04">https://towardsdatascience.com/10-awesome-python-3-9-features-b8c27f5eba5c?source=collection_archive---------0-----------------------#2020-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">必须了解的Python 3.9特性</h2></div><p id="551e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最新的Python 3.9.0最终版本将于2020年10月5日星期一发布</p><p id="047d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像大多数Python爱好者一样，我对探索和使用最新的特性感到非常兴奋。本文将概述Python 3.9的必备特性。</p><blockquote class="le"><p id="9074" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">对于Python程序员来说，这又是一个激动人心的时刻。</p></blockquote><figure class="lp lq lr ls lt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lo"><img src="../Images/eca1693b10f0c81032a097f17d20b8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49w_B1vpnCgQx8C2TA7CUw.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">作者图片</p></figure><p id="31b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我通读了Python 3.9发行说明和相关讨论。基于这些信息，我想写一个全面的指南，这样每个人都可以对这些功能及其详细的工作原理有所了解。</p><p id="153f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我开始之前，我必须说，我非常兴奋地探索3.9版本，因为一些功能肯定会在我的应用程序中使用。</p><h1 id="0374" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">简单地</h1><p id="5030" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">从字典更新/合并到添加新的字符串方法，再到引入zoneinfo库，已经添加了许多新特性。此外，还引入了一种新的稳定、高性能的解析器。</p><p id="d4c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着新模块<code class="fe nc nd ne nf b">zoneinfo </code>和<code class="fe nc nd ne nf b">graphlib</code>的加入，标准库更新了许多新特性。许多模块也得到了改进，例如<code class="fe nc nd ne nf b">ast</code>、<code class="fe nc nd ne nf b">asyncio</code>、<code class="fe nc nd ne nf b">concurrent.futures</code>、<code class="fe nc nd ne nf b">multiprocessing</code>、<code class="fe nc nd ne nf b">xml </code>等等。</p><blockquote class="le"><p id="ca49" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">这个版本进一步稳定了Python标准库。</p></blockquote><p id="ea8c" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">现在让我们来探索Python 3.9的特性。</p><h1 id="3c1c" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">1.特性:字典更新和合并操作符</h1><p id="a40c" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">内置的<code class="fe nc nd ne nf b">dict </code>类中增加了两个新的操作符<code class="fe nc nd ne nf b">|</code>和<code class="fe nc nd ne nf b">|=</code>。</p><p id="19fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">|</code>操作符用于合并字典，而<code class="fe nc nd ne nf b">|=</code>操作符可用于更新字典。</p><h2 id="f335" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">人教版:584</h2><h2 id="4439" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">代码:</h2><p id="194c" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">用于合并:<code class="fe nc nd ne nf b">|</code></p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="f69c" class="nl mg it nf b gy of og l oh oi">&gt;&gt;&gt; a = {‘farhad’: 1, 'blog’: 2, 'python’: 3}<br/>&gt;&gt;&gt; b = {’farhad’: 'malik’, 'topic’: 'python3.9’}<br/>&gt;&gt;&gt; a | b<br/>{’blog’: 2, 'python’: 3, ’farhad’:’malik’,  'topic’: 'python3.9’}<br/>&gt;&gt;&gt; b | a<br/>{’farhad’: 1,’blog’: 2, 'python’: 3, 'topic’:’python3.9’ }</span></pre><p id="f89f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">求更新:<code class="fe nc nd ne nf b">|=</code></p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="a0dd" class="nl mg it nf b gy of og l oh oi">&gt;&gt;&gt; a |= b<br/>&gt;&gt;&gt; a<br/>{’blog’: 2, 'python’: 3,’farhad’:’malik’}</span></pre><p id="538e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要记住的关键规则是，如果有任何键冲突，那么将保留最右边的值。这意味着最后看到的值总是有效的。这也是其他<code class="fe nc nd ne nf b">dict </code>操作的当前行为。</p><h2 id="8bea" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">详细解释:</h2><p id="dbca" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">正如我们在上面看到的，两个新的操作符<code class="fe nc nd ne nf b">|</code>和<code class="fe nc nd ne nf b">|=</code>已经被添加到内置的<code class="fe nc nd ne nf b">dict </code>类中。</p><p id="7725" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">|</code>操作符用于合并字典，而<code class="fe nc nd ne nf b">|=</code>操作符可用于更新字典。</p><p id="6a4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以认为<code class="fe nc nd ne nf b">|</code>是列表中的<code class="fe nc nd ne nf b">+</code>(连接)，我们可以认为<code class="fe nc nd ne nf b">|=</code>是列表中的<code class="fe nc nd ne nf b">+=</code>操作符(扩展)。</p><p id="f7d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们评估3.8版本，我们会注意到合并和更新字典的方法很少。</p><p id="7f38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，我们可以做<code class="fe nc nd ne nf b">first_dict.update(second_dict)</code>。这种方法的问题是它在适当的位置修改了<code class="fe nc nd ne nf b">first_dict </code>。解决这个问题的一个方法是将<code class="fe nc nd ne nf b">first_dict </code>复制到一个临时变量中，然后执行更新。然而，它添加了额外的不必要的代码，只是为了让更新/合并工作。</p><p id="6a44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以用<code class="fe nc nd ne nf b">{**first_dict, **second_dict}</code>。这种方法的问题是它不容易被发现，并且更难理解代码打算执行什么。这种方法的另一个问题是映射类型被忽略，类型总是dict。作为一个例子，如果<code class="fe nc nd ne nf b">first_dict </code>是一个<code class="fe nc nd ne nf b">defaultdict </code>并且<code class="fe nc nd ne nf b">second_dict </code>是dict类型，那么它将失败。</p><p id="5cc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<code class="fe nc nd ne nf b">collections </code>库包含一个<code class="fe nc nd ne nf b">ChainMap </code>函数。它可以接受两个字典，比如<code class="fe nc nd ne nf b">ChainMap(first_dict, second_dict)</code>，并返回一个合并的字典，但是这个库并不常见。</p><p id="54d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于具有不兼容的<code class="fe nc nd ne nf b">__init__ </code>方法的<code class="fe nc nd ne nf b">dict </code>的子类，它也会失败。</p><h2 id="cada" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">更多信息:<a class="ae oj" href="https://www.python.org/dev/peps/pep-0584" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-0584</a></h2><figure class="nx ny nz oa gt lu gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c1f282d66c63277fff60f196053e5220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*yZZ_S_sHRxjnMqPTCsS6eA.png"/></div><p class="mb mc gj gh gi md me bd b be z dk translated">作者图片</p></figure><h1 id="d2a1" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">2.特性:新的灵活的高性能基于PEG的解析器</h1><p id="a9bb" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">Python 3.9版本提议用一种新的基于PEG的高性能和稳定的解析器取代当前基于LL(1)的Python解析器。</p><h2 id="e2c6" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">人教版:617</h2><h2 id="7220" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">详细解释:</h2><p id="3c69" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">当前的CPython解析器是基于LL(1)的。随后，该语法是基于LL(1)的，以允许它被LL(1)解析器解析。LL(1)解析器是一个自顶向下的解析器。此外，它从左到右解析输入。当前的语法是上下文无关的语法，因此没有考虑标记的上下文。</p><p id="1ebe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python 3.9版本提议用一个新的基于PEG的解析器来代替它，这意味着它将取消当前的LL(1)语法Python限制。此外，当前的解析器已经修补了许多将被删除的漏洞。因此，从长远来看，这将降低维护成本。</p><p id="4ff2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，尽管LL(1)解析器和语法实现起来很简单，但是这些限制不允许它们以自然的方式向语言设计者和读者表达常见的结构。解析器只查看前面的一个标记来区分可能性。</p><p id="0824" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择运算符<code class="fe nc nd ne nf b">|</code>是命令。对于一个实例，如果编写了以下规则:</p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="44d2" class="nl mg it nf b gy of og l oh oi">rule: A|B|C</span></pre><p id="2f50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">LL(1)解析器是一个上下文无关的语法解析器，它将生成这样的构造，即给定一个输入字符串，它将推断出是否需要扩展A或B或c。它将检查第一个选项是否成功。如果仅失败一次，它将继续第二次或第三次。</p><p id="fcf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PEG解析器只为一个字符串生成一个有效的树。因此，它不像LL(1)解析器那样不明确。</p><p id="5efb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PEG解析器还通过语法动作直接生成规则的<code class="fe nc nd ne nf b">AST </code>节点。这意味着它避免了中间步骤的产生。</p><p id="b33c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键是PEG解析器已经过广泛的测试和验证。PEG解析器的性能得到了微调。因此，对于大多数指令来说，它只占用当前解析器10%的内存和速度。这主要是因为没有构造中间语法树。</p><p id="d3a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了保持文章的简单和可读性，我删除了对底层细节的提及。如果需要了解更多信息，底部提供了链接。</p><h2 id="09f1" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">更多信息:<a class="ae oj" href="https://www.python.org/dev/peps/pep-0617" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-0617</a></h2><figure class="nx ny nz oa gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ol"><img src="../Images/fd63a000deee3040ece4c15e26dd9936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSMo_P7nRlR6w7fmMptt9Q.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">作者图片</p></figure><h1 id="1492" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">3.特性:新的字符串功能，以消除前缀和后缀</h1><p id="1c8d" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">两个新功能被添加到<code class="fe nc nd ne nf b">str </code>对象中。</p><ul class=""><li id="1d3a" class="om on it kk b kl km ko kp kr oo kv op kz oq ld or os ot ou bi translated">第一个函数删除前缀。是<code class="fe nc nd ne nf b">str.removeprefix(prefix)</code>。</li><li id="99ef" class="om on it kk b kl ov ko ow kr ox kv oy kz oz ld or os ot ou bi translated">第二个函数删除后缀。正是<code class="fe nc nd ne nf b">str.removesuffix(suffix)</code>。</li></ul><h2 id="98e3" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">人教版:616</h2><h2 id="97c7" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">代码:</h2><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="2bf3" class="nl mg it nf b gy of og l oh oi">'farhad_python'.removeprefix('farhad_')<br/>#returns python</span><span id="c769" class="nl mg it nf b gy pa og l oh oi">'farhad_python'.removesuffix('_python')<br/>#returns farhad</span></pre><h2 id="1f8c" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">详细解释:</h2><p id="1e4c" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">数据科学应用程序中涉及操作文本的常见任务之一是删除字符串的前缀/后缀。<code class="fe nc nd ne nf b">str </code>对象增加了两个新功能。这些函数可以用来删除字符串中不需要的前缀和后缀。</p><p id="d5f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个函数删除前缀。第二个函数是<code class="fe nc nd ne nf b">str.removeprefix(prefix).</code>删除后缀。是<code class="fe nc nd ne nf b">str.removesuffix(suffix).</code></p><p id="26bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住字符串是字符的集合，每个字符在字符串中都有一个索引。我们可以使用索引和冒号<code class="fe nc nd ne nf b"> :</code>来返回字符串的子集。这个特性被称为字符串切片。</p><p id="f6d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们研究函数，它们在内部检查字符串是否以前缀开始(或以后缀结束),如果是，那么它们使用<code class="fe nc nd ne nf b">str[:]</code>切片特性返回一个没有前缀(或在后缀之后)的字符串。</p><p id="dd4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着这些函数成为标准库的一部分，我们得到了一个一致的、不太脆弱的、高性能的、更具描述性的API。</p><h2 id="57e9" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">更多信息:<a class="ae oj" href="https://www.python.org/dev/peps/pep-0616" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-0616</a></h2><h1 id="4e12" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">4.特性:内置泛型类型的类型提示</h1><p id="8712" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在此版本中，通过移除Python中的并行类型层次，注释程序变得更加简单。</p><p id="8428" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该版本支持类型模块中当前可用的所有标准集合中的泛型语法。</p><p id="3c3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe nc nd ne nf b">list </code>或<code class="fe nc nd ne nf b">dict </code>内置集合类型作为泛型类型，而不是在函数签名中使用<code class="fe nc nd ne nf b">typing.List or typing.Dict</code>。</p><p id="1ff4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，代码现在看起来更清晰，并且更容易理解/解释代码。</p><h2 id="011a" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">PEP: 585</h2><h2 id="7595" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">详细解释:</h2><p id="e7f9" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">虽然Python是一种动态类型语言，但是Python程序中的类型注释支持类型的自省。随后，该注释可用于运行时类型检查的API生成。</p><p id="8407" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个版本支持类型模块中当前可用的所有标准集合中的泛型语法。</p><p id="b6f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般类型通常是一个容器，例如list。它是一种可以参数化的类型。参数化泛型是具有容器元素的预期类型的泛型的实例，例如list[str]</p><p id="35aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe nc nd ne nf b">list </code>或<code class="fe nc nd ne nf b">dict </code>内置集合类型作为泛型类型，而不是使用<code class="fe nc nd ne nf b">typing.List or typing.Dict.</code></p><p id="8b57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过注释代码来指导Python运行时类型检查:</p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="6ea4" class="nl mg it nf b gy of og l oh oi">def print_value(input: str):<br/>  print(input)<br/># We would get notified  if the input is not a string</span></pre><p id="fa77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在过去的几个版本中，已经在现有Python运行时的基础上逐步构建了许多静态类型特性。其中一些功能受到现有语法和运行时行为的限制。因此，由于泛型，在类型模块中存在重复的集合层次结构。</p><p id="e281" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们将看到<code class="fe nc nd ne nf b">typing.List</code>、<code class="fe nc nd ne nf b">typing.Dictionary </code>以及内置的<code class="fe nc nd ne nf b">list</code>、<code class="fe nc nd ne nf b">dictionary</code>等等。这使我们能够编写代码:</p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="2873" class="nl mg it nf b gy of og l oh oi"><strong class="nf iu">def</strong> read_blog_tags(tags: list[str]) -&gt; <strong class="nf iu">None</strong>:<br/>    <strong class="nf iu">for</strong> tag <strong class="nf iu">in</strong> tags:<br/>        print("Tag Name", tag)</span></pre><h2 id="f232" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">更多信息:<a class="ae oj" href="https://www.python.org/dev/peps/pep-0585" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-0585</a></h2><h1 id="aec1" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">5.特性:支持IANA时区</h1><p id="33ba" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">已经创建了模块<code class="fe nc nd ne nf b">zoneinfo </code>来支持<code class="fe nc nd ne nf b">IANA </code>时区数据库。对<code class="fe nc nd ne nf b">IANA </code>时区数据库的支持已经被添加到标准库中。</p><figure class="nx ny nz oa gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi pb"><img src="../Images/c74074e64b2128d0735ec077dfc807fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KPNB10F2Qg4JQEw5XhkYw.png"/></div></div></figure><h2 id="bd25" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">人教版:615</h2><p id="7570" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated"><code class="fe nc nd ne nf b">IANA </code>时区通常被称为<code class="fe nc nd ne nf b">tz </code>或<code class="fe nc nd ne nf b">zone info</code>。有许多IANA时区使用不同的搜索路径来为日期时间对象指定IANA时区。例如，我们可以将搜索路径的名称作为洲/城市传递给一个<code class="fe nc nd ne nf b">datetime </code>对象来设置它的<code class="fe nc nd ne nf b">tzinfo</code>。</p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="9927" class="nl mg it nf b gy of og l oh oi">dt = datetime(2000, 01, 25, 01, tzinfo=ZoneInfo("Europe/London"))</span></pre><p id="8da1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们传入一个无效的键，那么<code class="fe nc nd ne nf b">zoneinfo.ZoneInfoNotFoundError</code>将被抛出。</p><h2 id="40ed" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">详细解释:</h2><p id="d9c7" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">我们使用<code class="fe nc nd ne nf b">datetime </code>库来创建一个<code class="fe nc nd ne nf b">datetime </code>对象，并通过设置tzinfo属性来指定它的时区。然而，当使用<code class="fe nc nd ne nf b">datetime.tzinfo</code>基线时，我们最终会创建复杂的时区规则。</p><p id="1036" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数时候，我们只需要设置对象并将其时区设置为UTC、系统本地时区或IANA时区。</p><p id="47ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建一个<code class="fe nc nd ne nf b">zoneinfo.ZoneInfo(key) </code>对象，其中的键是string类型的，表示系统时区数据库中时区文件的搜索路径。可以创建<code class="fe nc nd ne nf b">zoneinfo.ZoneInfo(key)</code>对象，并将其设置为<code class="fe nc nd ne nf b">datetime </code>对象的<code class="fe nc nd ne nf b">tzinfo </code>属性。</p><h2 id="b236" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">代码:</h2><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="3bbd" class="nl mg it nf b gy of og l oh oi"><strong class="nf iu">from</strong> <strong class="nf iu">zoneinfo</strong> <strong class="nf iu">import</strong> ZoneInfo<br/><strong class="nf iu">from</strong> <strong class="nf iu">datetime</strong> <strong class="nf iu">import</strong> datetime<br/><br/>dt = datetime(2000, 01, 25, 01, tzinfo=ZoneInfo("America/Los_Angeles"))</span></pre><h2 id="935a" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">欲知详情:<a class="ae oj" href="https://www.python.org/dev/peps/pep-0615" rel="noopener ugc nofollow" target="_blank">https://www.python.org/dev/peps/pep-0615</a></h2><h1 id="a047" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">6.功能:取消并发期货的能力</h1><p id="9c56" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">一个新的参数<code class="fe nc nd ne nf b"> cancel_futures</code>被添加到<code class="fe nc nd ne nf b">concurrent.futures.Executor.shutdown()</code>中。</p><p id="d397" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此参数<code class="fe nc nd ne nf b">cancels </code>所有未开始的未决期货。在3.9版本之前，进程会在关闭执行器之前等待它们完成。</p><h2 id="ba24" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">解释:</h2><p id="fbdd" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">新参数<code class="fe nc nd ne nf b">cancel_futures </code>已经添加到<code class="fe nc nd ne nf b">ThreadPoolExecutor </code>和<code class="fe nc nd ne nf b">ProcessPoolExecutor</code>中。它的工作方式是当参数的值为True时，那么当调用shutdown()函数时，所有未决的期货都将被取消。</p><p id="b2e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，当执行<code class="fe nc nd ne nf b"> shutdown()</code>时，解释器检查执行器是否没有被垃圾收集。如果它仍然在内存中，那么它将获得所有挂起的工作项，然后取消期货。</p><p id="298b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦没有挂起的工作项，它就会关闭工作线程。</p><h2 id="c502" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">链接:<a class="ae oj" href="https://bugs.python.org/issue30966" rel="noopener ugc nofollow" target="_blank">https://bugs.python.org/issue30966</a></h2><h1 id="b90f" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">7.特性:异步和多处理改进</h1><p id="fcbe" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在这个版本中，对asyncio和多处理库进行了许多改进。</p><p id="63ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，</p><ol class=""><li id="052b" class="om on it kk b kl km ko kp kr oo kv op kz oq ld pc os ot ou bi translated">由于严重的安全问题，不再支持<code class="fe nc nd ne nf b">asyncio.loop.create_datagram_endpoint() </code>的<code class="fe nc nd ne nf b">reuse_address </code>参数。</li><li id="0fe7" class="om on it kk b kl ov ko ow kr ox kv oy kz oz ld pc os ot ou bi translated">新增了<code class="fe nc nd ne nf b">coroutines, shutdown_default_executor() </code>和协程<code class="fe nc nd ne nf b">asyncio.to_thread()</code>。<code class="fe nc nd ne nf b">shutdown_default_executor </code>为等待<code class="fe nc nd ne nf b">ThreadPoolExecutor </code>完成关闭的默认执行器安排关闭。<code class="fe nc nd ne nf b">asyncio.to_thread()</code>主要用于在单独的线程中运行IO绑定的函数，以避免阻塞事件循环。</li></ol><p id="0d90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于多重处理库的改进，一个新的方法<code class="fe nc nd ne nf b">close()</code>被添加到了<code class="fe nc nd ne nf b"> multiprocessing.SimpleQueue </code>类中。</p><p id="4272" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此方法显式关闭队列。这将确保队列被关闭，并且不会停留超过预期的时间。要记住的关键是，一旦队列关闭，就不能调用方法<code class="fe nc nd ne nf b">get(), put(), empty()</code>。</p><h2 id="afe3" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">链接:<a class="ae oj" href="https://bugs.python.org/issue30966" rel="noopener ugc nofollow" target="_blank">https://bugs.python.org/issue30966</a></h2><h1 id="bc87" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">8.功能:一致的包导入错误</h1><p id="01e5" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在3.9版本之前导入Python库的主要问题是，当相对导入越过其顶级包时，Python中的导入行为不一致。</p><p id="19d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">builtins.__import__()</code>升高<code class="fe nc nd ne nf b">ValueError </code>同时<code class="fe nc nd ne nf b">importlib.__import__() </code>升高ImportError。</p><p id="4bc7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在已经修好了。__import__()现在会引发<code class="fe nc nd ne nf b">ImportError </code>而不是<code class="fe nc nd ne nf b">ValueError</code>。</p><h2 id="3486" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">欲知详情:<a class="ae oj" href="https://bugs.python.org/issue37444" rel="noopener ugc nofollow" target="_blank">https://bugs.python.org/issue37444</a></h2><h1 id="0452" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">9.功能:随机字节生成</h1><p id="0a26" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">3.9版本中增加的另一个特性是功能<code class="fe nc nd ne nf b">random.Random.randbytes()</code>。该函数可用于生成随机字节。</p><p id="c845" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以生成随机数，但是如果我们需要生成随机字节呢？在3.9版本之前，开发人员必须发挥创造力来生成随机字节。虽然我们可以使用<code class="fe nc nd ne nf b">os.getrandom(), os.urandom() or secrets.token_bytes() </code>但是我们不能生成伪随机模式。</p><p id="f896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，为了确保随机数以预期的行为生成，并且该过程是可重复的，我们通常使用随机的种子。随机模块。</p><p id="2a67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe nc nd ne nf b">random.Random.randbytes()</code>法被引入。它也能以可控的方式生成随机字节。</p><h2 id="836d" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">更多信息:<a class="ae oj" href="https://bugs.python.org/issue40286" rel="noopener ugc nofollow" target="_blank">https://bugs.python.org/issue40286</a></h2><h1 id="c64e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">10.功能:字符串替换功能修复</h1><p id="bcee" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">在Python版本之前，<code class="fe nc nd ne nf b">“”.replace(“”,s,n)</code>返回空字符串，而不是所有非零n的s</p><p id="3a92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个错误让用户感到困惑，并导致应用程序的行为不一致。</p><p id="9167" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.9版本已经修复了这个问题，现在与<code class="fe nc nd ne nf b">"".replace("", s)</code>保持一致。</p><p id="a3d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">replace </code>函数的工作方式是，对于给定的max replace occurrence参数，它用一组新的字符替换字符串中的一组字符。</p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="2e95" class="nl mg it nf b gy of og l oh oi">string.replace(s, old, new[, maxreplace])</span><span id="7e11" class="nl mg it nf b gy pa og l oh oi">Return a copy of string s with all occurrences of substring old replaced by new. If the optional argument maxreplace is given, the first maxreplace occurrences are replaced.</span></pre><p id="0b2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进一步解释这个问题，在3.9版本之前，<code class="fe nc nd ne nf b">replace </code>函数的行为不一致</p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="d24e" class="nl mg it nf b gy of og l oh oi">"".replace("", "blog", 1)<br/>Returns ’'<br/>One would expect to see blog</span><span id="6697" class="nl mg it nf b gy pa og l oh oi">"".replace("", "|", 1)<br/>Returns ’'<br/>One would expect to see |</span><span id="4931" class="nl mg it nf b gy pa og l oh oi">"".replace("", "prefix")<br/>Howver returns ’prefix'</span></pre><p id="9ba5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，现在的变化是，如果我们进入:</p><pre class="nx ny nz oa gt ob nf oc od aw oe bi"><span id="c135" class="nl mg it nf b gy of og l oh oi">“”.replace(“”,s,n) returns s instead of empty string for all non-zero n</span></pre><h2 id="cf2f" class="nl mg it bd mh nm nn dn ml no np dp mp kr nq nr mr kv ns nt mt kz nu nv mv nw bi translated">更多信息:<a class="ae oj" href="https://bugs.python.org/issue28029" rel="noopener ugc nofollow" target="_blank">https://bugs.python.org/issue28029</a></h2><figure class="nx ny nz oa gt lu gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/ebf76086559270511435690782a51414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*SEDFUpCNKyzB5pFSWZKyKQ.png"/></div><p class="mb mc gj gh gi md me bd b be z dk translated">作者图片</p></figure><p id="a991" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python 3.9中也删除了许多冗余特性，比如<code class="fe nc nd ne nf b">Py_UNICODE_MATCH.</code></p><p id="c31a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我对探索3.9版感到非常兴奋，因为其中的一些特性肯定会在我的应用程序中使用。</p><p id="e443" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想了解更多关于这些改进的信息，请点击阅读官方指南<a class="ae oj" href="https://docs.python.org/3.9/whatsnew/3.9.html" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>