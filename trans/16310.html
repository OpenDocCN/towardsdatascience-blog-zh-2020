<html>
<head>
<title>All The NumPy You Need To Supercharge Your Deep Learning Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强深度学习代码所需的所有数字</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-the-numpy-you-need-to-supercharge-your-deep-learning-code-e7a22fe4ede2?source=collection_archive---------28-----------------------#2020-11-10">https://towardsdatascience.com/all-the-numpy-you-need-to-supercharge-your-deep-learning-code-e7a22fe4ede2?source=collection_archive---------28-----------------------#2020-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9002004ae3e349e6b275c027fc9225a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bIssvB3yFfGqdX40"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">米克·豪普特在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><p id="d91c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NumPy或Numerical Python是一个开源的Python库，使复杂的数值运算变得容易。使用机器学习和深度学习应用程序涉及大型数据集的复杂数值运算。与纯Python实现相比，NumPy使得实现这些操作相对简单和有效。</p><p id="f2be" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在其核心，NumPy实现了它的(n维数组)数据结构，这类似于一个常规的Python列表。大多数编程语言只有数组的概念。Python实现了列表，列表作为数组工作，但还是有区别的。</p><p id="d7d3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">常规python列表和NumPy之间的一个关键区别是python列表可以包含各种数据类型。相反，NumPy数组只能包含相同数据类型的对象。换句话说，数据结构是同质的。虽然这看起来像是一个缺点，但它允许NumPy操作更快，因为它们可以在进行计算时避免转换和约束。</p><h2 id="41a5" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">为什么要关心NumPy，为什么专门针对深度学习？</h2><p id="401f" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我将在本文中讨论几个具体的用例，但是与其他python数据结构相比，NumPy最重要的特性之一是速度。NumPy比使用常规Python列表快几个数量级。性能提升是可能的，因为NumPy函数是用C实现的，这除了使执行更快之外，还使NumPy能够分解大型作业并并行执行多个作业。深度学习涉及处理大型数据集，当处理这些大型数据集时，NumPy数组可能是一种有效的技术。</p><h2 id="ff36" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">创建NumPy数组</h2><p id="b7bc" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">创建NumPy数组有几种不同的方法，一种直接的方法是使用<code class="fe mc md me mf b">array()</code>函数创建它们。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="7f48" class="le lf jj mf b gy mo mp l mq mr">#import NumPy<br/>import numpy as np</span><span id="657d" class="le lf jj mf b gy ms mp l mq mr">#create a NumPy array<br/>a = np.array([1,2,3])</span><span id="8a49" class="le lf jj mf b gy ms mp l mq mr">#check the shape of the array<br/>a.shape</span><span id="1b4d" class="le lf jj mf b gy ms mp l mq mr">#get the dimensions <br/>a.dim</span></pre><p id="cf60" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，你可以直接从标准的<strong class="ki jk"> <em class="mt"> Python列表</em> </strong>中创建。Numpy阵列是智能的。如果您将一个Python列表传递给<code class="fe mc md me mf b">array()</code>函数，它将自动执行操作并返回一个Numpy数组。您不必先显式转换为NumPy数组。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="af06" class="le lf jj mf b gy mo mp l mq mr">#python List<br/>my_list = [1,2,3,4,5]</span><span id="c1e9" class="le lf jj mf b gy ms mp l mq mr">#creating a NumPy array from a list<br/>np.array(my_list)</span></pre><p id="d210" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以使用pandas函数将Pandas数据帧转换为NumPy数组。<code class="fe mc md me mf b">to_numpy()</code></p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="7bf2" class="le lf jj mf b gy mo mp l mq mr">#import Pandas<br/>import pandas as pd</span><span id="c6a5" class="le lf jj mf b gy ms mp l mq mr">#create a DataFrame<br/>df = pd.DataFrame({"A":[1, 2],"B":[3, 4]})</span><span id="9782" class="le lf jj mf b gy ms mp l mq mr">#convert DataFrame to NumPy array<br/>df.to_numpy()</span></pre><p id="a414" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得注意的是，由于NumPy数组只能包含相同数据类型的元素。默认情况下，当您转换数据帧时，返回数组的<code class="fe mc md me mf b">dtype</code>将是数据帧中所有类型的公共NumPy <code class="fe mc md me mf b">dtype</code>。</p><h2 id="f7a3" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">NumPy热爱数学</h2><p id="020b" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">NumPy数组是专门用来做数学的。该软件包包括几个辅助数学函数，允许你做这些计算，而不需要自己快速编写。</p><p id="3d9b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">常见的例子包括用于获得平方根的<code class="fe mc md me mf b">sqrt()</code>函数、用于计算对数的<code class="fe mc md me mf b">log()</code>函数和用于计算双曲正切的<code class="fe mc md me mf b">tanh()</code>函数，后者通常用作深度神经网络中的激活函数。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="6662" class="le lf jj mf b gy mo mp l mq mr">a = np.array([1,2,3])</span><span id="d1e8" class="le lf jj mf b gy ms mp l mq mr">#get the square root<br/>np.sqrt(a)</span><span id="8839" class="le lf jj mf b gy ms mp l mq mr">#get log<br/>np.log(a)</span><span id="1521" class="le lf jj mf b gy ms mp l mq mr">#find the tanh<br/>np.tanh(a)</span></pre><h2 id="7bb7" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">线性代数</h2><p id="33e7" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">线性代数广泛用于机器学习和深度学习应用。在处理深度学习时，你会发现自己正在处理高维数组，这些数组可以很容易地转化为线性方程，以分析给定空间中特征的相互作用。</p><p id="5c95" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NumPy有几个内置的线性代数算法，作为<code class="fe mc md me mf b">linalg</code>子模块中的方法。</p><p id="9367" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个常用的线性代数函数是<code class="fe mc md me mf b">norm()</code>一个用于计算向量长度的函数，也被称为向量范数或向量幅度。向量范数作为一种归一化技术被应用于解决机器学习和深度学习应用中的过度填充问题。NumPy的<code class="fe mc md me mf b">linalg</code>子模块有<code class="fe mc md me mf b">norm()</code>函数来计算向量范数</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="826a" class="le lf jj mf b gy mo mp l mq mr">a = np.array([1,2,3])</span><span id="8169" class="le lf jj mf b gy ms mp l mq mr">#getting a norm of the vector<br/>np.linalg.norm(a)</span></pre><p id="d924" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用线性代数时，遇到数学错误并不罕见。一些数学运算是不允许的。处理这些错误的一个好方法是使用<code class="fe mc md me mf b">linalg.LinAlgError</code>异常处理，这是一个从Python的异常类派生的通用异常类。</p><p id="ba9b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们试图对一个奇异矩阵求逆，这个操作是不允许的，并且会抛出一个错误。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="7da5" class="le lf jj mf b gy mo mp l mq mr">x=np.ones((2,2)) </span><span id="f8b7" class="le lf jj mf b gy ms mp l mq mr">np.linalg.inv(x) #this will throw an error</span><span id="117c" class="le lf jj mf b gy ms mp l mq mr">#exception handling using LinAlgError<br/>try:<br/>    np.linalg.inv(x)<br/>except np.linalg.LinAlgError:<br/>    print("Linear Algebra Error")</span></pre><p id="fb2e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果将几个矩阵堆叠在同一个数组上，这些线性代数函数可以计算出它们的结果。</p><h2 id="0abf" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">广播</h2><p id="fd2d" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">NumPy进行算术计算的基本特征之一是通过广播。广播允许不同形状和大小的NumPy阵列之间的操作。</p><p id="f137" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">广播通过比较拖尾维度来工作，广播有效有两个主要规则。</p><ul class=""><li id="9527" class="mu mv jj ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated">尺寸相等，或</li><li id="d30f" class="mu mv jj ki b kj nd kn ne kr nf kv ng kz nh ld mz na nb nc bi translated">其中一个维度是1</li></ul><p id="3177" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您在NumPy中执行元素操作时，比如向np.array添加一个标量，这实际上就是广播。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="a6d2" class="le lf jj mf b gy mo mp l mq mr">x = np.ones((2,2))<br/>y = np.ones((3,2,1))<br/>a = np.ones((2,3,3))</span><span id="2d0d" class="le lf jj mf b gy ms mp l mq mr">x+y #Broadcasting will work; trailing dimensions match<br/>x+a #Broadcasting will fail; trailing dimensions do not match</span></pre><h2 id="2dae" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">数字和矩阵</h2><p id="daa4" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">NumPy的真正潜力来自于处理矩阵。Numpy支持各种易于使用的方法来进行标准矩阵运算，如点积、转置、获取对角线等。</p><p id="0936" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">矩阵乘法，具体来说，计算度量的<strong class="ki jk"> <em class="mt">点积</em> </strong>，是深度学习中的常见任务，尤其是在处理卷积神经网络时。NumPy函数<code class="fe mc md me mf b">dot()</code>计算两个指标的点积。在NumPy的更高版本中，您还可以使用<code class="fe mc md me mf b">@</code>操作符来计算点积。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3fdd" class="le lf jj mf b gy mo mp l mq mr">x = np.array([[1,2],[3,4]])<br/>y = np.array([[5,6],[7,8]])</span><span id="b1b7" class="le lf jj mf b gy ms mp l mq mr">#dot product with dot()<br/>x.dot(y)</span><span id="87a7" class="le lf jj mf b gy ms mp l mq mr">#dot product with @<br/>x@y</span></pre><p id="b081" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">深度学习中接下来两个常用的矩阵运算是<strong class="ki jk"> <em class="mt">求逆和</em> </strong>转置。</p><p id="ca2e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们先来看逆。什么是逆？一个数乘以它的倒数等于1。重要的是要记住，不是所有的矩阵都有逆矩阵，在这种情况下，你会得到一个错误。你可以用<code class="fe mc md me mf b">linalg.inv()</code>函数得到一个矩阵的逆矩阵。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="7e39" class="le lf jj mf b gy mo mp l mq mr">x = np.array([[1, 2], [3, 4]])</span><span id="ce40" class="le lf jj mf b gy ms mp l mq mr">#getting the inverse<br/>np.linalg.inv(x)</span></pre><p id="a73f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">矩阵的转置是一种在矩阵对角线上翻转矩阵的操作。也就是说，它切换矩阵的行和列索引。在NumPy中，你可以用<code class="fe mc md me mf b">T</code>得到一个矩阵的转置</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="086f" class="le lf jj mf b gy mo mp l mq mr">x = np.array([[1, 2], [3, 4]])</span><span id="42ac" class="le lf jj mf b gy ms mp l mq mr">#getting the transpose<br/>x.T</span></pre><p id="4935" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在深度学习中，<strong class="ki jk"> <em class="mt">特征值和特征向量</em> </strong>在实现主成分分析(PCA)等降维方法时很有用</p><p id="0f91" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以使用<code class="fe mc md me mf b">linalg.eignvals()</code>函数计算一个向量或矩阵的特征值。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="4c88" class="le lf jj mf b gy mo mp l mq mr">x = np.array([[1, 2], [3, 4]])</span><span id="c55a" class="le lf jj mf b gy ms mp l mq mr">#getting the eigenvectors<br/>np.linalg.eigvals(x)</span></pre><p id="cdf3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用矩阵时，一定要记住不要使用NumPy类中的matrix函数，而要使用常规数组。</p><h2 id="482a" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">改变形状</h2><p id="f06c" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">使用深度学习时，您会经常遇到需要改变数组或矩阵形状的情况。您可以使用<code class="fe mc md me mf b">reshape()</code>功能<strong class="ki jk">重塑</strong>NumPy数组。该函数返回具有新形状的新NumPy数组。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="093d" class="le lf jj mf b gy mo mp l mq mr">x = np.array([[1, 2], [3, 4]])</span><span id="d839" class="le lf jj mf b gy ms mp l mq mr">#Reshape 2X2 to 4X1<br/>x.reshape(4,1)</span></pre><p id="60ed" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果需要改变原始NumPy数组的形状，可以使用<code class="fe mc md me mf b">resize()</code>函数。它的工作方式与<code class="fe mc md me mf b">reshape()</code>函数相似，但它改变了原始对象，而不是创建一个新对象。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="0397" class="le lf jj mf b gy mo mp l mq mr">x = np.array([[1, 2], [3, 4]]</span><span id="1ad9" class="le lf jj mf b gy ms mp l mq mr">#Resize the original array 2X2 to 4X1<br/>x.resize(4,1)</span></pre><p id="bbfb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> <em class="mt">扁平化</em> </strong>是另一种标准的深度学习操作，用于将数据或输入传递到你的神经网络的不同层。<code class="fe mc md me mf b">flatten()</code> NumPy功能将展平一个<code class="fe mc md me mf b">ndarray</code>。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="1482" class="le lf jj mf b gy mo mp l mq mr">x = np.array([[1, 2], [3, 4]]</span><span id="df67" class="le lf jj mf b gy ms mp l mq mr">#flatten the array<br/>x.flatten()</span></pre><p id="6954" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了使用<code class="fe mc md me mf b">flatten()</code>之外，你还可以使用<code class="fe mc md me mf b">ravel()</code>方法来做同样的事情。<code class="fe mc md me mf b">flatten()</code>和<code class="fe mc md me mf b">ravel()</code>的区别在于，<code class="fe mc md me mf b">ravel()</code>可以直接用于常规链表，并将返回一个NumPy数组。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="01c1" class="le lf jj mf b gy mo mp l mq mr">x_list = [[1, 2],[3, 4]]</span><span id="65f8" class="le lf jj mf b gy ms mp l mq mr">#flatten a list<br/>np.ravel(x_list)</span></pre><p id="7c00" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">整形的一种形式是<strong class="ki jk"> <em class="mt">给一个数组增加一个新的维度</em> </strong>。例如，您可以通过使用关键字添加一个新维度<code class="fe mc md me mf b">newaxis</code>来取消展平</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="5dab" class="le lf jj mf b gy mo mp l mq mr">y = np.array([1,2,3,4,5])</span><span id="63cb" class="le lf jj mf b gy ms mp l mq mr">#add a new dimension<br/>y[:,np.newaxis]</span></pre><p id="eb64" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重塑NumPy数组的另一种方法是使用函数拆分它。该函数采用，并根据指定的索引或节返回子数组。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="9320" class="le lf jj mf b gy mo mp l mq mr">x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8])</span><span id="2d66" class="le lf jj mf b gy ms mp l mq mr">#split array into 3 sections<br/>np.split(x,3)</span></pre><h2 id="43f9" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用NumPy生成数据</h2><p id="380f" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">NumPy为数值运算提供了强大的工具包；但是，NumPy也可以生成数据。让我们看看一些常见的场景。</p><p id="2f17" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<strong class="ki jk"> <em class="mt">单位矩阵</em> </strong>是一个任意阶的正方形矩阵，沿主对角线为1，所有其他元素为0。NumPy函数创建指定阶数的单位矩阵。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="8f40" class="le lf jj mf b gy mo mp l mq mr">#generate a identity matrix 5<br/>np.identity(5)</span></pre><p id="9795" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在深度学习中，你会遇到需要一个<strong class="ki jk"><em class="mt">0&amp;1</em></strong>的矩阵的情况。NumPy有方便的函数<code class="fe mc md me mf b">zeros()</code>和<code class="fe mc md me mf b">ones()</code>可以用来生成0或1的矩阵。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="dff6" class="le lf jj mf b gy mo mp l mq mr">#generate a 2X3 matrix of 0s<br/>np.zeros((2,3))</span><span id="61d3" class="le lf jj mf b gy ms mp l mq mr">#generate a 2X3 matrix of 1s<br/>np.ones((2,3))</span></pre><p id="cd59" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用NumPy <code class="fe mc md me mf b">random.rand()</code>函数，您可以创建一个由随机数元素组成的指定顺序的数组。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="da07" class="le lf jj mf b gy mo mp l mq mr">#generate a 2X3 matrix of random numbers<br/>np.random.rand(2,3)</span><span id="44f3" class="le lf jj mf b gy ms mp l mq mr">#generate a 2X3 matrix of random integers<br/>np.random.randint(2,3)</span></pre><p id="6cce" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，如果您想要随机整数，您可以使用<code class="fe mc md me mf b">random.randint()</code>函数获得一个包含随机整数的NumPy数组。</p><p id="7193" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面讨论的数据生成方法可以与它们的<code class="fe mc md me mf b">_like</code>对应物一起使用，例如<code class="fe mc md me mf b">zeros_like</code>、<code class="fe mc md me mf b">ones_like</code>来生成数组，这些数组采用作为参数传递给函数的数组的形状。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="419a" class="le lf jj mf b gy mo mp l mq mr">x = np.array([[1, 2],[3, 4]])</span><span id="d4f7" class="le lf jj mf b gy ms mp l mq mr">#generate a matrix of 1s based on dimensions of x <br/>np.ones_like(x)</span></pre><p id="c789" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，当使用函数的<code class="fe mc md me mf b">_like</code>形式时，我们不指定形状，而是传递一个现有的NumPy数组。产生的NumPy数组采用传递的数组的形状。</p><h2 id="d403" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">总结想法</h2><p id="44c1" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在这篇文章中，我涵盖了你需要开始的所有必要的数字。NumPy比这里介绍的内容更多，但是我们在这里介绍的内容应该足以让您在深度学习项目中开始使用NumPy。最好的学习方法是建立。当你开始从事深度学习项目时，你会遇到需要你使用额外技术和学习更多知识的情况。快乐大厦！</p></div></div>    
</body>
</html>