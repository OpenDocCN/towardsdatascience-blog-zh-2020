<html>
<head>
<title>How to change semi-structured text into a Pandas dataframe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将半结构化文本转换成熊猫数据框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-change-semi-structured-text-into-a-pandas-dataframe-ef531d6baab4?source=collection_archive---------17-----------------------#2020-11-13">https://towardsdatascience.com/how-to-change-semi-structured-text-into-a-pandas-dataframe-ef531d6baab4?source=collection_archive---------17-----------------------#2020-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dacf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python和Pandas，我将面向人类读者的文本文档转换成机器可读的数据帧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7576ee922e20f48bf3d67f77772f8e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FUTjze8awhnBc0IV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">左边是半结构化数据，右边是熊猫数据框和图表——图片由作者提供</p></figure><p id="1ed7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如今，你在互联网上找到的许多数据都被很好地格式化为JSON、Excel文件或CSV。但有些不是。</p><p id="f525" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我需要一个简单的数据集来说明我在<a class="ae lu" rel="noopener" target="_blank" href="/plotting-with-pandas-an-introduction-to-data-visualization-8bd7c0831650"> Python </a>和<a class="ae lu" rel="noopener" target="_blank" href="/starting-data-visualization-with-the-julia-langauge-and-jupyter-notebooks-289bc9f0cd09"> Julia </a>中关于数据可视化的<a class="ae lu" href="https://technofile.substack.com/" rel="noopener ugc nofollow" target="_blank">文章，并决定使用英国气象局公开发布的天气数据(英国伦敦)。</a></p><p id="6d74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题是，这是一个文本文件，看起来像一个CSV文件，但它实际上是为人类读者格式化的。因此，我需要做一些清理和整理，以便能够创建一个熊猫数据框架和绘图。</p><p id="4286" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章是关于我用来将这个半结构化文本文件转换成Pandas数据框架的不同技术，我可以用它来执行数据分析和绘制图表。</p><p id="a5cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">毫无疑问，我可以用文本编辑器转换文件——那会非常乏味。但是我认为用Python和Pandas编程会更有趣。此外，也许更重要的是，编写一个程序来下载和格式化数据意味着我可以自动更新数据，而不需要额外的努力。</p><p id="d83d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有许多问题。首先，是文件的结构。数据被制成表格，但之前有一个自由格式描述，所以这是第一件必须要做的事情。其次，列名在两行中，而不是电子表格文件中常见的一行。然后，尽管它看起来有点像CSV文件，但没有分隔符:数据由数量可变的空格分隔。</p><p id="5577" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，数据列的数量在文件中发生了部分变化。数据范围从1948年到现在，但2020年的数据在另一栏中被标注为“临时的”。</p><p id="204f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后是数据的形式。早些年，一些数据丢失，丢失的数据用一串破折号表示。其他列有一个“#”附加到本来是数字的数据上。这些都不能被熊猫识别为数字数据。</p><p id="55ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让熊猫理解这些数据，这些问题都必须解决。</p><h2 id="1348" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">读取数据</h2><p id="a28f" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">这些数据属于公共领域，由英国气象局以简单的文本文件形式提供。您可以在本文顶部的图片中看到这种格式(以及生成的数据帧和从数据中绘制的图表)。</p><p id="7e2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Pandas中读取csv文件非常简单，虽然这不是一个传统的csv文件，但我将使用该功能作为起点。</p><p id="1bd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas的函数<em class="mt"> read_csv </em>通常用于读取本地文件或远程文件。不幸的是，这并不适用于Met Office文件，因为网站拒绝连接。我不是100%确定，但我猜想这是因为它不喜欢该函数提供的HTTP头中的“用户代理”(用户代理通常是访问网页的浏览器的名称/描述——我不知道，随便，什么<em class="mt"> read_csv </em>设置它)。</p><p id="611f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不知道有什么机制可以让我更改<em class="mt"> read_csv </em>的用户代理，但是有一个相当简单的方法:使用<em class="mt"> requests </em>库。(<em class="mt">请求</em>库允许您设置包括用户代理在内的HTTP头。)</p><p id="777f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<em class="mt">请求</em>您可以将文件下载到一个Python文件对象，然后使用<em class="mt"> read_csv </em>将其导入一个数据帧。这是代码。</p><p id="67c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先导入我们将使用的库:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ddcd" class="lv lw it mv b gy mz na l nb nc">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import requests<br/>import io</span></pre><p id="6cbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(如果您有任何缺失，您必须<em class="mt"> conda </em> / <em class="mt"> pip安装</em>它们。)</p><p id="be6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是下载数据的代码:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3490" class="lv lw it mv b gy mz na l nb nc">url = 'https://www.metoffice.gov.uk/pub/data/weather/uk/climate/stationdata/heathrowdata.txt'</span><span id="5a9a" class="lv lw it mv b gy nd na l nb nc">file = io.StringIO(requests.get(url).text)</span></pre><p id="0a36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等一下，我不是说要设置用户代理吗？好吧，碰巧的是，<em class="mt">请求</em>使用的默认设置似乎是Met Office网站可以接受的，所以没有任何进一步的调查，我只是使用了上面看到的简单函数调用。<em class="mt">请求</em>调用获取文件并返回文本。然后由StringIO 转换成一个文件对象。</p><h2 id="f0eb" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">固定结构</h2><p id="7e9c" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">现在我们差不多准备好读取文件了。我需要先看一下原始文件，它显示前5行是非结构化的文本。我需要跳过这些行来读取csv格式的文件。</p><p id="6fd1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来的两行是列名。我也决定跳过这些，提供我自己的名字。那些名字是<em class="mt">‘年’，‘月’，‘Tmax’，‘Tmin’，‘AF’，‘雨’，‘太阳’</em>。前两个很明显，Tmax和Tmin是一个月的最高和最低温度，AF是一个月中有空气霜冻的天数，Rain是降雨量的毫米数，Sun是日照的小时数。</p><p id="40e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我用这样的变量记录了这些事情:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0ad3" class="lv lw it mv b gy mz na l nb nc">col_names = ('Year','Month','Tmax','Tmin','AF','Rain','Sun')<br/>comment_lines = 5<br/>header = 2</span></pre><p id="5bed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些将在read_csv调用中使用。</p><p id="f844" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mt"> read_csv </em>需要为该特定作业设置一些其他参数。它需要知道文件中使用的分隔符，默认是逗号(还有什么？)但是这里的分隔符是一个空格字符，事实上不止一个空格字符。所以，我需要告诉熊猫这个(<em class="mt">分隔符=` </em>)。而且因为字段之间有几个空格，熊猫需要知道忽略这些(<em class="mt"> skipinitialspace=True </em>)。</p><p id="e10d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我需要告诉它应该跳过前几行(<em class="mt">skiprows = comment _ lines</em>+<em class="mt">header</em>)，不要把文件中的任何一行当作标题(<em class="mt"> header= </em> None)和列名(<em class="mt"> names=col_names </em>)。</p><p id="db04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我知道到了2020年，列数会发生变化。这通常会引发异常，并且不会返回任何数据帧。但是设置<em class="mt"> error_bad_lines=False </em>会抑制错误并忽略坏行。</p><p id="648b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是创建数据帧<em class="mt">天气</em>的结果代码。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="5541" class="lv lw it mv b gy mz na l nb nc">weather = pd.read_csv(file,<br/>   skiprows=comment_lines + header,<br/>   header=None,<br/>   names=col_names,<br/>   delimiter=' ',<br/>   skipinitialspace=True,<br/>   error_bad_lines=False)</span></pre><p id="bb23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将产生一个dataframe，其中包含第一个坏行(有额外列的行)的所有数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/06c0f1de0c932c7634c2179a5c8d9918.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/0*fKYDjS359WobnoQt"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第一个数据帧—作者提供的图像</p></figure><p id="45b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">个别数据项需要修复，但下一步工作是追加文件的其余部分。这一次，我将使用类似的参数再次读取该文件，但我将找到我刚刚读取的数据帧的长度，并跳过所有这些行。文件的剩余部分包含8列，所以我也需要添加一个新的列名。否则对<em class="mt"> read_csv </em>的调用与之前类似。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c140" class="lv lw it mv b gy mz na l nb nc">file.seek(0)</span><span id="5357" class="lv lw it mv b gy nd na l nb nc">col_names = ('Year','Month','Tmax','Tmin','AF','Rain','Sun', 'Status')<br/>rows_to_skip = comment_lines+header+len(weather)</span><span id="d472" class="lv lw it mv b gy nd na l nb nc">weather2 = pd.read_csv(file,<br/>   skiprows=rows_to_skip,<br/>   header=None,<br/>   names=col_names,<br/>   delimiter=' ',<br/>   skipinitialspace=True,<br/>   error_bad_lines=False)</span></pre><p id="4e51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，请注意，我必须使用<em class="mt"> seek(0) </em>将指针设置回文件的开头，否则将没有任何内容可以读取，因为我们已经到达了文件的末尾。</p><p id="f1b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6f0ee0714e0bb4d3834821ff7b5db10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/0*nhSOsmzNTM4DdU1M"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第二个数据框架—作者提供的图像</p></figure><p id="0458" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似于其他数据帧，但增加了一列。</p><p id="c07a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个技巧是合并两个数据帧，为了正确地完成这个，我必须使它们具有相同的形状。因此，我有一个选择，删除第二个数据帧中的状态栏，或者在第一个数据帧中添加一个。出于本练习的目的，我决定不丢失状态信息，并在第一个。额外的一列称为状态，对于2020年的数据，其值为“临时”。因此，我将在第一个数据帧中创建一个状态列，并将所有值设置为“Final”。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7b1e" class="lv lw it mv b gy mz na l nb nc">weather['Status']='Final'</span></pre><p id="e419" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我将第二个数据帧追加到第一个数据帧，并添加参数<em class="mt"> ignore_index=True </em>，以便不复制索引，而是为组合的数据帧创建一个新的索引。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="057a" class="lv lw it mv b gy mz na l nb nc">weather = weather.append(weather2, ignore_index=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/67058bf0ca7ff8f0d6f971c71e5c09ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/0*-WvZLREMRaz-4ShT"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">组合数据框架—作者提供的图像</p></figure><h2 id="5ab7" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">修复数据类型</h2><p id="54ae" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">现在我们必须处理每一列中的数据。让我们来看看数据类型。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c7b1" class="lv lw it mv b gy mz na l nb nc">weather.dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3c49fb831a6e9d204b4b37e4a17f0ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/0*VHsqaY0B8iJgoKOg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始数据类型—按作者分类的图像</p></figure><p id="995e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，Pandas已经尽了最大努力来解释数据类型:Tmax、Tmin和Rain被正确地识别为floats，Status是一个对象(基本上是一个字符串)。但是AF和Sun也被解释为字符串，尽管实际上它们应该是数字。这是因为Sun和AF列中的一些值是字符串'— -'(表示没有数据)或者数字附有#符号。</p><p id="eef0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有太阳一栏的日照时数带有#符号，所以第一件事就是去掉那一栏中的那个字符。字符串替换完成了这项工作；下面的代码通过用空字符串替换来删除字符。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b417" class="lv lw it mv b gy mz na l nb nc">weather['Sun']=weather['Sun'].str.replace('#','')</span></pre><p id="5b67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，Sun列中的数字格式正确，但Pandas仍然将Sun和AF列数据视为字符串，因此我们无法将该列读取为数字，因此无法使用该数据绘制图表。</p><p id="839a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">改变数据的表示很简单；我们使用函数to_numeric将字符串值转换成数字。使用这个函数，字符串将把字符串“123.4”转换成浮点数123.4。但是我们要转换的列中的一些值是字符串'— -'，不能合理地解释为数字。</p><p id="3a71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">诀窍是将参数<em class="mt">错误</em>设置为<em class="mt">强制</em>。这将把任何不能被解释为数字的字符串强制转换为值<em class="mt"> NaN </em>(不是数字)，这在Python中相当于空数值。这正是我们想要的，因为这个数据帧中的字符串“--”表示“没有数据”。</p><p id="f23f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是更正这两列中的值的代码。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="107c" class="lv lw it mv b gy mz na l nb nc">weather['AF']=pd.to_numeric(weather['AF'], errors='coerce')<br/>weather['Sun']=pd.to_numeric(weather['Sun'], errors='coerce')</span></pre><p id="86de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据帧现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b6c62a042c30196d370c2d51d80fdbc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/0*0hPR2mTJHn8bSVwX"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调整了数据类型的数据框架—按作者分类的图像</p></figure><p id="6437" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到NaN值，如果我们再次查看数据类型，我们会看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/46b48719b7516635aab8c4c9e2aef54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/0*UJyxsezbyIRPbfm2"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新的数据类型—按作者分类的图像</p></figure><p id="4022" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在所有的数字数据都是浮点值——这正是我们所需要的。</p><h2 id="69b1" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">使用数据</h2><p id="6802" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">为了说明这就是我们想要的，这里画了一张2000年的降雨量图。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4a55" class="lv lw it mv b gy mz na l nb nc">weather[weather.Year==2000].plot(x='Month', y='Rain')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5fd600819b2fd14d90c6f27599f7f943.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/0*WwcMD3rG2tMhHXeI"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个简单的图形——作者的图像</p></figure><p id="1838" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务完成。</p><p id="e3cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想知道这篇文章顶部的图表是从哪里来的，这是绘制1950年、1960年、1970年、1980年、1990年、2000年和2010年每月最高温度的代码。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a3d2" class="lv lw it mv b gy mz na l nb nc">ax = weather[weather.Year==1950].plot(x='Month', y='Tmax',<br/>   label='1950')<br/>ax = weather[weather.Year==1960].plot(x='Month', y='Tmax', <br/>   label='1960',ax=ax)<br/>ax = weather[weather.Year==1970].plot(x='Month', y='Tmax',  <br/>   label='1970',ax=ax)<br/>ax = weather[weather.Year==1980].plot(x='Month', y='Tmax', <br/>   label='1980',ax=ax)<br/>ax = weather[weather.Year==1990].plot(x='Month', y='Tmax', <br/>   label='1990',ax=ax)<br/>ax = weather[weather.Year==2000].plot(x='Month', y='Tmax', <br/>   label='2000',ax=ax)<br/>weather[weather.Year==2019].plot(x='Month', y='Tmax', label = <br/>   '2010', ax=ax, figsize=(15,10));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/bd63b8f9380232374b307400cb47bcbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4Q3lenC6jId8mSJd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">稍微详细一点的图表——作者提供的图片</p></figure><p id="8e3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您不太可能会发现需要对我在这里演示的文本文件进行完全相同的操作，但是我希望您可能会发现我的经验很有用，并且您能够将我在这里使用的技术用于您自己的目的。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="1e6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读，如果你想了解我发表的文章，请考虑在这里订阅我的免费简讯<a class="ae lu" href="https://technofile.substack.com/" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="bb2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mt">更新:我在这里</em>  <em class="mt">写了一个新的更通用版本的上述程序</em> <a class="ae lu" href="https://projectcodeed.blogspot.com/2021/02/an-alternative-method-for-changing-semi.html" rel="noopener ugc nofollow" target="_blank"> <em class="mt">。</em></a></p></div></div>    
</body>
</html>