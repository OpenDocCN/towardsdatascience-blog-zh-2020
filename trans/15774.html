<html>
<head>
<title>Databases: An Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库:概述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/databases-an-overview-97c54628b824?source=collection_archive---------19-----------------------#2020-10-30">https://towardsdatascience.com/databases-an-overview-97c54628b824?source=collection_archive---------19-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/78f4bc029030ee0fdda213038b5d30f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyeNmhElsADd237nBkeoMQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@campaign_creators?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae jd" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="b7f8" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">第2部分:MongoDB和HBase分布式文件系统的底层架构以及Python中的数据库操作</h2></div><p id="20d6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将讨论当今世界提供大数据解决方案所基于的架构，即分布式文件系统，并了解它们实际上是如何实现的。在本系列的<a class="ae jd" rel="noopener" target="_blank" href="/databases-an-overview-cdb5ca696e1b">第1部分中，我们已经讨论了基本的数据库概念和安装过程。作为先决条件，请随意检查。</a></p><p id="a268" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MongoDB和Hbase都是分布式NoSQL数据库，广泛用于处理大型数据问题。让我们进入架构和实现细节。</p><h2 id="33ab" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">MongoDB</h2><p id="b244" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">MongoDB是一个基于文档的NoSQL数据库。它不需要固定的模式定义。Mongo DB将数据存储为二进制JSON或BSON。它支持水平缩放。几个服务器实例组成一个集群来支持Mongo DB作为一个分布式系统。</p><p id="0f72" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MongoDB使用MongoDB查询语言，并支持即席查询、复制和分片。分片是MongoDB的一个特性，有助于它作为分布式数据系统运行。让我们看看MongoDB是如何实现这些特性的。</p><p id="e4dd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">Mongo中的复制</strong></p><p id="5ab7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">复制是一项非常重要的功能，可以防止一台服务器上的数据丢失，提高数据的可用性，并提供故障保护。</p><p id="bc73" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MongoDB使用概念副本集实现复制。副本集是一组托管相同数据集的mongod实例。选择其中一个节点作为主要节点。这称为主节点。所有其他节点称为次节点。主节点接收来自用户的所有操作，并且通过使用相同的操作从主节点更新辅助节点以保持一致性。如果主节点关闭，则选择一个次节点作为主节点，并继续执行操作。当故障节点恢复时，它作为辅助节点加入集群。我们可以使用<strong class="kx jh"> mongo Atlas来控制我们的Mongo实例集群。</strong> Mongo集群是基于水平扩展和添加实例的思想创建的。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/9b2f79a16c7ccba0ed8b78e0982e6a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*b9_Dh8TWsY8aZpcVQSxigg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">副本集示意图:作者提供的图像</p></figure><p id="f9e7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">Mongo DB中的分片</strong></p><p id="3c6e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MongoDB使用分片来跨多台机器存储数据。它使用水平扩展来添加更多的机器，以根据负载和需求的增长来分发数据和操作。</p><p id="2f99" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MongoDB中的分片安排主要有三个组件:</p><ol class=""><li id="73ec" class="mu mv jg kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated"><strong class="kx jh">碎片或副本集:</strong>每个碎片充当一个单独的副本集。他们存储所有的数据。他们的目标是提高数据的一致性和可用性。</li><li id="fdec" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><strong class="kx jh">配置服务器:</strong>它们就像集群的管理者。这些服务器包含集群的元数据。他们实际上拥有集群数据到碎片的映射。当查询到来时，查询路由器使用来自配置服务器的这些映射来定位所需的碎片。</li><li id="b98f" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><strong class="kx jh">查询路由器:</strong>查询路由器是作为用户应用程序接口的mongo实例。它们接受来自应用程序的用户查询，并向应用程序提供所需的结果。通常，每个集群有多个查询路由器用于负载分布。</li></ol><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/185377cbbb8eaede76582382f50f438c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcgfYCgejWrmKh0sS7BdAw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="110a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上图展示了MongoDB的分片安排。尽管该映像只有2个查询服务器和分片，但实际集群中通常有更多，尽管默认情况下集群中有3个配置服务器。</p><p id="087a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们上面谈到的思想是MongoDB操作及其分布式数据系统架构背后的两个最重要的思想。</p><p id="152a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们看看Apache HBase是如何实现分布式系统的思想的。</p><h2 id="207a" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">Apache HBase</h2><p id="4ecc" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Apache HBase是一个基于列值的NoSQL数据库。它基本上存储了基于表或模式的MySQL数据库所存储内容的转置。不同的行或记录有不同数量的列或字段。在操作过程中，可以在任何地方插入或更新列。该模式是完全动态的，因此不需要预先声明。最适合非结构化数据。它是水平可伸缩的，特别适合稀疏数据。</p><p id="4b17" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">HBase实际上是为处理海量数据而设计的，广泛用于社交媒体运营，每天都会产生大量数据。因此，HBase通常用于集群中至少有5台服务器，并且复制系数至少为3的情况。</p><p id="9504" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Apache HBase是使用MapReduce和Google FileTable背后的思想开发的，作为一个由Apache保护伞支持的开源数据库。Apache HBase使用了几个有趣的概念，作为领先的技术巨头使用的其他数据库的基本思想。</p><p id="3ee3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> MapReduce </strong></p><p id="859f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MapReduce是一个框架，它的目标是以一种更快、更好维护的方式处理大量数据。它还打算引入并行访问，以便加快速度。MapReduce的思想主要包含两个部分:映射和简化，正如它的名字所描述的那样。</p><p id="4923" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">映射部分由称为映射器的组件执行。映射器检查数据库中插入的每一行数据，并将它们分解成一种键值对。因此，它接收原始输入数据并创建更小的数据块。这是第一阶段。</p><p id="6b33" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还原部分基本包含洗牌和还原两个部分。这些操作由称为减速器的部件来完成。reducers的功能是将映射器的输出进一步分解成更紧凑的键值对。Reducers的输出存储在底层文件系统中。</p><p id="7a1c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输入数据进入文件系统，从那里它被发送到映射器，然后到缩减器。缩减器的输出被保存回文件系统。文件系统中有控制转发流量和网络流量的主节点。</p><p id="a036" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整个系统是用JAVA开发的。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/1cb8e2b5db4eb89859255146a4a9a86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4UvgV1Dpji7ekxpkJ_u2g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">MapReduce架构:作者图片</p></figure><p id="5225" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> Hadoop文件系统</strong></p><p id="bd65" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">HBase使用Hadoop文件系统作为底层架构。Hadoop文件系统是由Apache开发人员在Google的文件表论文中提出这个想法后构建的。让我们检查一下文件系统架构的工作基础。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/d7f65301df336605b7d0e6a73ffb66e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YC-y1ekiQxkO-jHUCf3U7Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="a211" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上图描述了HBase底层的Hadoop文件系统。它有一些基本组件:</p><p id="4565" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">Namenode:</strong>Namenode是一个包含Hadoop集群元数据的Linux系统。它管理客户端数据访问，也管理文件系统的命名空间。</p><p id="a119" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">数据节点:</strong>数据节点是Linux系统，它根据用户或客户端的请求对数据进行读写指令，并根据Namenodes的请求进行创建、删除和复制。</p><p id="3f99" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">系统中还有其他重要部分，如Jobtracker和TaskTracker。在启动Hbase之前，我们需要运行HDFS系统，并使名称和数据节点联机。</p><p id="730b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看HBase的架构组件:</p><p id="5560" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> HBase架构</strong></p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/f61d59d9fdd3aff343b35c1e19b1263e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*nrApj8qLmhLB6Uhixvto8A.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="3b3a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上图显示了HBase的架构。它主要包含两个主要部分:</p><ol class=""><li id="d43a" class="mu mv jg kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated"><strong class="kx jh"> HMaster </strong>:组件不存储数据。它是一种控制器。它控制HRegion服务器和客户端请求。它有元数据，充当集群的主节点。</li><li id="e044" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><strong class="kx jh"> HBase客户端:</strong>这是HBase通过其与应用程序进行交互的组件。</li><li id="4edf" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><strong class="kx jh"> HRegion Server: </strong>这个组件实际存储数据。一个集群有多个HRegion服务器。数据基于块分布在多个HRegion服务器上。</li></ol><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/b2175766aa4bcb0d2a3d3388339d960e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UsnQ7Na2ay1wx-59rqTe9g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="2480" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，基本上，插入的数据块被分解成块，这些块分布在HRegion服务器中，并由集群的HMaster管理。</p><p id="ef62" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">读/写架构</strong></p><p id="3dac" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">写作:</strong></p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7461c19aeac7e3c089410fd3cb2f6877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*lrziXccfo_wA0tvbm1JUiw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="3c21" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在HBase中，写操作如上图所示。HBase创建一个名为Memstore的有限内存缓存。客户端在Memstore中写入。现在，由于内存有限，Memstore很快就满了。每当Memstore完全填满时，就会创建一个Memstore快照并保存为HFile。HFile随后被转移到磁盘上进行永久存储。Memstore是临时存储器。因此，如果出现故障，可能会丢失数据。为了防止Hbase维护称为WAL或预写日志的东西。它是保存在光盘中的记录或日志。如果一些记录丢失了，就从磁盘上的WAL中检索出来。</p><p id="910e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">阅读:</strong></p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6d1727b4c3010e09505383628c7646e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*zraiacB88yoQ4nRmRrnySQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="8822" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">阅读就是这样做的。一旦内存存储的快照保存为HFile，内存存储就会被刷新。因此，必须搜索所有的HFile和光盘来获取信息。这就导致了大量的时间消耗。因此，为了节省时间，创建了称为块缓存的东西来保存频繁访问的信息。因此，首先搜索Memstore来访问数据，然后在失败时，搜索块缓存。之后，搜索Hfiles。</p><p id="be93" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">更新和删除</strong></p><p id="4ad4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更新和删除不是在客户端传递命令的瞬间完成的。这些命令被保存为标志、更新标志或删除标志。Hfiles是不可变的，也就是说，一旦写入，就不能更改。因此，当这些Hfiles被合并以写入光盘时，这些值被更新或删除。因此，为了访问数据，HBase还需要检查Hfiles，以在返回查询结果之前查看是否有这样的标志。</p><p id="3585" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经讨论了HBase的所有整体思想和概念。</p><p id="a3e2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到的Hbase和MongoDB的概念是大多数当前NoSQL数据库使用的一般概念。</p><h2 id="a6b7" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">用Python实现</strong></h2><p id="0b10" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们看看python如何使用和访问数据库。首先，我们需要了解MySQL、MongoDB和HBase之间的基本结构差异。</p><p id="8ff6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MySQL在最顶层有数据库。在第二层，有表格。在最低级别或最后一级，有记录或行。所以，每个数据库都有表，每个表都有记录</p><p id="438e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MongoDB有数据库。每个数据库都有集合而不是表。每个集合都有最低层的文档，描述键值对。</p><p id="2247" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">HBase的最高级别只有表。然后它有行索引或索引，就像每个记录的主键。要在HBase中执行任何操作，我们需要知道必须是唯一的行或记录id。HBase也有柱族的概念。它没有固定的模式，但是列族有助于全面了解表的数据记录中的列。每个表只能有一个列族。</p><p id="6d9c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> MySQL: </strong></p><p id="c1b7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实现MySQL-python和mysql-connector-python是为了从python提示符或使用python代码访问正在运行的MySQL数据库。</p><p id="c044" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">MySQL-python可以从<a class="ae jd" href="https://pypi.org/project/MySQL-python/" rel="noopener ugc nofollow" target="_blank"> <em class="np">这里</em> </a>安装。</p><p id="67d2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">mysql-connector-python可以从<a class="ae jd" href="https://pypi.org/project/mysql-connector-python/" rel="noopener ugc nofollow" target="_blank">这里的<em class="np">安装。</em> </a></p><p id="107a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">语法:</p><p id="6d20" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关系</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="6eb0" class="lr ls jg nr b gy nv nw l nx ny"><strong class="nr jh">import</strong> <strong class="nr jh">MySQLdb</strong><br/><strong class="nr jh">import</strong> <strong class="nr jh">mysql.connector</strong><br/>conn= mysql.connector.connect(host="localhost",user="abhijit",passwd="1234",db="users" )<br/>mycursor = conn.cursor()</span></pre><p id="c9e4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">插入:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="dab3" class="lr ls jg nr b gy nv nw l nx ny">mycursor = conn.cursor()<br/>mycursor.execute('INSERT INTO user_details (id,email,password) VALUES("<strong class="nr jh">%s</strong>","<strong class="nr jh">%s</strong>","<strong class="nr jh">%s</strong>")'%(id1,email,passwd))<br/>conn.commit()</span></pre><p id="f2ca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="8597" class="lr ls jg nr b gy nv nw l nx ny">query="""SELECT * FROM user_details WHERE email='<strong class="nr jh">%s</strong>'"""%(email)<br/>mycursor = conn.cursor()<br/>mycursor.execute(query)<br/>dup=mycursor.fetchall()<br/>i=mycursor.rowcount</span></pre><p id="daf8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> MongoDB </strong></p><p id="d7e1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">PyMongo库用于从Python提示符访问MongoDB。</p><p id="6404" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">pymongo库可以从这里的<a class="ae jd" href="https://pypi.org/project/pymongo/" rel="noopener ugc nofollow" target="_blank"> <em class="np">安装。</em>T13】</a></p><p id="8afc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Pymongo的官方教程可以在这里 找到<a class="ae jd" href="https://api.mongodb.com/python/current/tutorial.html" rel="noopener ugc nofollow" target="_blank"> <em class="np">。</em></a></p><p id="d25a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">语法:</p><p id="71fa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">连接:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="867b" class="lr ls jg nr b gy nv nw l nx ny"><strong class="nr jh">import</strong> <strong class="nr jh">pymongo</strong><br/><strong class="nr jh">from</strong> <strong class="nr jh">pymongo</strong> <strong class="nr jh">import</strong> MongoClient<br/>client = MongoClient()<br/>client = MongoClient('localhost', 27017)<br/>db_mongo = client['user_connections']   #selecting database<br/>m_user_recs= db_mongo['user_records']   #selecting collections</span></pre><p id="2000" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">插入:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="0ab0" class="lr ls jg nr b gy nv nw l nx ny">data={<br/>	'c_id':'abhi',<br/>	'connections':['123','myac.a','abhir'],<br/>	'posts':[]}<br/>m_user_recs.insert(data)</span></pre><p id="f7b8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们可以在mongo文档中插入任何数据类型。它可以是列表，甚至是子文档。</p><p id="3e32" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="0c92" class="lr ls jg nr b gy nv nw l nx ny">recs=m_user_recs.find({"c_id":id1})     #(1)<br/>f<strong class="nr jh">or</strong> r <strong class="nr jh">in</strong> recs: <br/>   frnds=r['connections']               #(2)</span></pre><p id="9be6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询(1)返回字段“c_id”的值为id1的文档。(2)代码片段从返回的文档中选择“连接”字段。</p><p id="3828" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更新:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="1b0a" class="lr ls jg nr b gy nv nw l nx ny">myquery = { "c_id": id1 }<br/>new_val={"$set": { "req_sent": cons }}<br/>            <br/>m_user_recs.update(myquery, new_val)</span></pre><p id="eefc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该查询将“req_sent”字段的值设置为由变量“cons”给出，其中字段“c_id”具有由变量id1给出的值。</p><p id="6eb3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> HBase </strong></p><p id="63d6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">HappyBase库用于从Python访问Apache HBase。</p><p id="88e2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Happybase可以从<a class="ae jd" href="https://pypi.org/project/happybase/" rel="noopener ugc nofollow" target="_blank"> <em class="np">这里</em> </a>安装。</p><p id="ba66" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Hbase的官方教程是<a class="ae jd" href="https://happybase.readthedocs.io/en/happybase-0.4/tutorial.html" rel="noopener ugc nofollow" target="_blank"> <em class="np">这里是</em> </a> <em class="np">。</em></p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="da46" class="lr ls jg nr b gy nv nw l nx ny">$ create 'table_name', 'column-family' </span></pre><p id="745d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述语法可用于从HBase shell创建HBase表。</p><p id="8bd4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">语法:</p><p id="601f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">连接:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="f968" class="lr ls jg nr b gy nv nw l nx ny"><strong class="nr jh">import</strong> <strong class="nr jh">happybase</strong><br/>conn=happybase.Connection('localhost')<br/>table=conn.table('users')</span></pre><p id="cc49" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">插入:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="570f" class="lr ls jg nr b gy nv nw l nx ny">table.put(id_u, {b'cf_user_1:name': record[1],b'cf_user_1:from': record[2],b'cf_user_1:Education': record[3],b'cf_user_1:Profession': record[4],b'cf_user_1:location': record[5],b'cf_user_1:birthday': record[6],b'cf_user_1:profile_pic': record[7]})</span></pre><p id="1612" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述语法可用于从python插入HBase表。这里的“id_u”是具有行键的变量。b'cf_user_1 '是列系列，而' name '、' from '是行的字段。</p><p id="b465" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询:</p><pre class="mq mr ms mt gt nq nr ns nt aw nu bi"><span id="29c0" class="lr ls jg nr b gy nv nw l nx ny">row_f=table.row("Roy Key")<br/>                <br/>loc=(row_f[b'cf_user_1:location'])<br/>fr=(row_f[b'cf_user_1:from'])<br/>edu=(row_f[b'cf_user_1:Education'])</span></pre><p id="b7ca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代码片段的第一行可以访问该行。接下来的几行访问相应的字段。</p><p id="a35e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经看到了这些库以及它们在python中的相应用法。</p><h2 id="1b25" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">结论</h2><p id="ee10" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在当前世界中，随着社交媒体网站和云的概念日益发展，大数据的概念越来越受到关注。每天都有大量的数据上传到云端。所以，我们已经越过了这个点，数据量可以由世界各地的一百或一千台计算机来处理。现在，分布式系统将会越来越受欢迎。像Cassandra、FileTable、CouchDB和Hadoop这样的数据库开始被Linkedin和脸书这样的普通和最大的社交媒体网站所使用。</p><p id="56c3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们已经看到了python中的概念及其工作方式和库。如果你想要一个工作实例，请在这里 找到我的GitHub库<a class="ae jd" href="https://github.com/abr-98/Database_ops_with_python" rel="noopener ugc nofollow" target="_blank"> <em class="np">。</em></a></p><p id="822b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望这有所帮助。</p></div></div>    
</body>
</html>