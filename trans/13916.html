<html>
<head>
<title>Vectorizing code matters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向量化代码很重要</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/vectorizing-code-matters-66c5f95ddfd5?source=collection_archive---------38-----------------------#2020-09-24">https://towardsdatascience.com/vectorizing-code-matters-66c5f95ddfd5?source=collection_archive---------38-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我来自MATLAB和数值计算的世界，在那里，for循环被删除，向量为王。在UVM攻读博士学位期间，<a class="ae kl" href="http://www.cems.uvm.edu/~tlakoba/" rel="noopener ugc nofollow" target="_blank">拉科巴</a>教授的数值分析课是我上过的最具挑战性的课程之一，对数值代码的深入了解至今仍让我记忆犹新。我最喜欢的矢量化例子是，一位同事在写了一篇非常酷的关于它的论文，并在脚注中提到了所涉及的大量计算之后，与我分享了他的Lorenz 96代码。内循环的矢量化速度快了4倍，所以现在脚注只是一个碳足迹。</p><p id="a596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如今，快速数字代码让机器学习成为可能，尽管我不确定现在有多少孩子能用C语言编写一个<a class="ae kl" href="https://www.academia.edu/4902724/Numerical_Recipes_in_C_The_Art_of_Scientific_Computing_2nd_Ed_William_H_Press" rel="noopener ugc nofollow" target="_blank"> QR分解。我是在开玩笑，因为我没有做过，但是我确信我可以用MATLAB(在某一点上)或者Numpy或者Julia(我将坚持只使用R语言中的magrittr和dplyr)来编写它。我在MassMutual做的很多工作基本上都是数值计算，耗时几小时甚至几分钟的管道与耗时几秒钟的管道之间的差别是很大的。几秒钟意味着我们可以迭代，尝试更多的选项，并且行动更快。尽管如此，很多数字代码还是用纯Python写的(没有Cython，没有Numba)，为了<em class="km">的灵活性</em>。我要说这是个坏主意！这是一封转述自同事的电子邮件:</a></p><blockquote class="kn ko kp"><p id="c9c0" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><em class="iq">在伪代码中，这是我几个月前遇到的‘精算’编码困境:</em></p><p id="3d6b" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><code class="fe kt ku kv kw b"><em class="iq">EOM = 0<br/>for months in years: <br/> PREM = 50 <br/> BOM = EOM + PREM <br/> WIT = 5 <br/> EOM = BOM – WIT</em></code></p><p id="ee38" class="jn jo km jp b jq jr js jt ju jv jw jx kq jz ka kb kr kd ke kf ks kh ki kj kk ij bi translated"><em class="iq">一个简单的例子，但我认为显示了BOM/EOM的相互依赖性(还有一些其他变量具有类似的关系。)不了解EOM就无法矢量化BOM，了解BOM就无法矢量化EOM。那么你可能会遇到这样的情况，如果WIT &gt; 0，PREM = 0。基本上出现了许多相互依赖。现在很多函数都不容易向量化。</em></p></blockquote><p id="9e3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可以把它矢量化，我做到了。以下是Python中的非矢量化版本:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="adb6" class="lf lg iq kw b gy lh li l lj lk">import numpy as np<br/>years = 10<br/>bom = np.zeros(years*12)<br/>eom = np.zeros(years*12)<br/>for month in range(1, years*12):<br/>    prem = 50<br/>    bom[month] = eom[month-1] + prem<br/>    wit = 5<br/>    eom[month] = bom[month] - wit</span></pre><p id="8556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是矢量化版本:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="fc99" class="lf lg iq kw b gy lh li l lj lk">import numpy as np<br/>years = 10<br/>prem = 50<br/>wit = 5</span><span id="1cc4" class="lf lg iq kw b gy ll li l lj lk">eom = np.arange(years*12)*prem - np.arange(years*12)*wit<br/># and if you still want bom as an array:<br/>bom = eom + np.arange(years*12)*wit</span></pre><p id="baee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还通过使用一个字典列表更加灵活地编写了for循环:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="4c48" class="lf lg iq kw b gy lh li l lj lk">years = 10<br/>prem = 50<br/>wit = 5<br/>result = [{'bom': 0, 'eom': 0}]<br/>for month in range(1, years*12):<br/>    inner = {}<br/>    inner.update({'bom': result[month-1]['eom'] + prem})<br/>    inner.update({'eom': inner['bom'] - wit})<br/>    result.append(inner)</span></pre><p id="6bf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面这个返回一个不同类型的东西，一个字典列表…不是两个数组。</p><p id="8e1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以导入Pandas来填充以上三个项目的结果(因此它们是一致的输出，我们可以保存到excel，等等)。如果我们加载了Pandas，我们可以使用一个空的数据帧进行迭代，因此多了一个选项:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="3148" class="lf lg iq kw b gy lh li l lj lk">import numpy as np<br/>import pandas as pd<br/>years = 10<br/>prem = 50<br/>wit = 5<br/>df = pd.DataFrame(data={'bom': np.zeros(years*12), 'eom': np.zeros(years*12)})<br/>for i, row in df.iterrows():<br/>    if i &gt; 0:<br/>        row.bom = df.loc[i-1, 'eom']<br/>        row.eom = row.bom - wit</span></pre><p id="0d9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过所有这些类型的迭代，以及返回数据帧作为结果的选项，我们得到了以下结果:</p><figure class="kx ky kz la gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi lm"><img src="../Images/823420c0fd55ef7b874bef1c93d18cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWJKsBFR3z8f39AbQK5whQ.png"/></div></div></figure><p id="cece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Cython和Numba </strong></p><p id="b9ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还添加了几个<a class="ae kl" href="https://cython.readthedocs.io/en/latest/src/tutorial/cython_tutorial.html" rel="noopener ugc nofollow" target="_blank"> Cython </a>版本的代码，展示了通过使用c，您可以在没有numpy的情况下获得矢量化的性能。)和速度。</p><p id="1480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Numba也可以保持相同的加速比(它可能和cy thon/矢量化Numpy一样快)。在这两种情况下(Cython/Numba ),您必须小心使用哪些数据类型(不要使用字典或熊猫！).我认为，如果你<a class="ae kl" href="https://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html#memoryviews" rel="noopener ugc nofollow" target="_blank">更聪明地知道如何整合它们</a>，让Cython + Numpy循环和矢量化Numpy循环一样快是可能的。</p><p id="e33f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终，你<em class="km">可以</em>鱼和熊掌兼得:可读的for-loops(是的，矢量化版本可以变得更神秘)，用Python编写，具有类似C语言的矢量化速度。</p><p id="4df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的代码，包括Cython，都可以在这里找到:<a class="ae kl" href="https://github.com/andyreagan/vectorizing-matters" rel="noopener ugc nofollow" target="_blank">https://github.com/andyreagan/vectorizing-matters</a>。</p></div></div>    
</body>
</html>