<html>
<head>
<title>Don’t underestimate these Python dunder methods!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要小看这些Python dunder方法！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-underestimate-these-python-dunder-methods-c7bc36a8c1c1?source=collection_archive---------46-----------------------#2020-11-11">https://towardsdatascience.com/dont-underestimate-these-python-dunder-methods-c7bc36a8c1c1?source=collection_archive---------46-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/07213958221de8c98fde808de4981f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y4Qb_hh_-7hPi6n7"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@rhett__noonan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞德·卫斯理</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><div class=""/><p id="ef9a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有大量关于使用Python进行面向对象编程的文章、书籍和视频，其中许多都涉及到了<em class="lb"> dunder </em>(也称为<em class="lb"> magic </em>)方法。在本文的最后，我会提供一些我认为对自己有用的资源的链接。</p><p id="d8a0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，请原谅我。</p><p id="61cf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我现在要表明我的观点:在我看到它们有多有用之前，下面列出的这些方法似乎与我毫不相干。</p><figure class="ld le lf lg gt is gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/1fce67b31fdefd3373694091517a077a.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*N_YgRzZiGlGXIHkMz5A8iw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来源:<a class="ae jd" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/reference/datamodel.html</a></p></figure><p id="0e4e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些被称为<strong class="kf jh"> <em class="lb">富比较</em> </strong>的方法。现在，事后看来，它们似乎有点多余，甚至毫无用处，因为python本身也提供了比较对象的函数。</p><p id="ef10" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事情是这样的，当你构建一个<a class="ae jd" href="https://docs.python.org/3/tutorial/classes.html" rel="noopener ugc nofollow" target="_blank">类</a>时，你可能希望它以某种特定的方式运行。现在，行为在许多方面不同于功能。</p><p id="7de6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看它如何应用于数据科学的问题。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="45ca" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设你正在为一个分类问题测试不同的监督学习<strong class="kf jh"> <em class="lb">技术</em> </strong>。为简单起见，我假设您熟悉这些术语。</p><p id="6c10" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，您会有一组原始要素用作训练算法的输入变量。然而，重要的转换，比如填充缺失值、标准化变量等等，几乎肯定会发生。</p><p id="0cb4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像在<a class="ae jd" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.pipeline" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> scikit-learn的管道</strong> </a> <em class="lb">，</em>中一样，你可以为<strong class="kf jh"> <em class="lb">，</em> </strong>，<strong class="kf jh"> <em class="lb">逻辑回归构建不同的变形金刚。</em> </strong></p><p id="9a8d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，即使这些步骤是相同的，并且具有相同的名称，也不可能说它们与Python中的常规比较是相等的。</p><pre class="ld le lf lg gt lo lp lq lr aw ls bi"><span id="aaaa" class="lt lu jg lp b gy lv lw l lx ly">&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, MinMaxScaler<br/>&gt;&gt;&gt; from sklearn.impute import SimpleImputer<br/>&gt;&gt;&gt; from sklearn.pipeline import Pipeline<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; mean_transformer_1 = Pipeline(steps=[<br/>...     ('imputer', SimpleImputer(strategy='mean')),<br/>...     ('scaler', StandardScaler())])<br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; mean_transformer_2 = Pipeline(steps=[<br/>...     ('imputer', SimpleImputer(strategy='mean')),<br/>...     ('scaler', StandardScaler())])<br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; mean_transformer_1==mean_transformer_2<br/>False</span></pre><p id="6093" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就对了。在应用不同的管道之前和之后比较模型可能相当麻烦。</p><p id="ad9c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比较它们的一种方法是比较每个步骤的类，看它们是否相同:</p><pre class="ld le lf lg gt lo lp lq lr aw ls bi"><span id="fa25" class="lt lu jg lp b gy lv lw l lx ly">&gt;&gt;&gt; class_1 = mean_transformer_1.steps[0][1].__class__<br/>&gt;&gt;&gt; class_2 = mean_transformer_2.steps[0][1].__class__<br/>&gt;&gt;&gt; class_1 == class_2<br/>True</span></pre><p id="8859" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，除了难看和冗长，如果你有一个更大的管道，这可能是相当冗长的。老实说，这么小的管道在现实生活中很少投入生产。</p><blockquote class="lz ma mb"><p id="5beb" class="kd ke lb kf b kg kh ki kj kk kl km kn mc kp kq kr md kt ku kv me kx ky kz la ij bi translated"><strong class="kf jh">警告:</strong>为了注意广度，我只保留了类别的比较。但是传递的参数比如<code class="fe mf mg mh lp b">'mean'</code>如果真的要深究比较的话也要比较一下。</p></blockquote><p id="c051" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如<a class="ae jd" href="https://github.com/rhettinger" rel="noopener ugc nofollow" target="_blank">雷蒙德</a>的名言所说:一定有更好的方法！确实有。</p><p id="8934" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们制作一个类来比较这些:</p><pre class="ld le lf lg gt lo lp lq lr aw ls bi"><span id="5278" class="lt lu jg lp b gy lv lw l lx ly">&gt;&gt;&gt; class SmartCompare:<br/>...     def __init__(self, pipeline):<br/>...         self.pipeline = pipeline<br/>...<br/>...     def __eq__(self, other):<br/>...         return [m1.__class__ for m1 in self.pipeline]==[m2.__class__ for m2 in other.pipeline]<br/>... <br/>&gt;&gt;&gt; mean_transformer_1_c = SmartCompare(mean_transformer_1)<br/>&gt;&gt;&gt; mean_transformer_2_c = SmartCompare(mean_transformer_2)<br/>&gt;&gt;&gt; mean_transformer_1_c==mean_transformer_2_c<br/>True</span></pre><p id="ea4c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这并没有好到哪里去，但是这说明了一个问题！</p><p id="c789" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以继承<code class="fe mf mg mh lp b">Pipeline</code>类，而不是让它成为您的类的一个属性。或者甚至使用其他方法进行比较。</p><p id="aa72" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在任何情况下，dunder方法都超越了常规的比较方法，使您的代码更具可读性和愉悦性。</p><p id="6a12" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的耐心！！！欢迎批评，请随意发表评论。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="b92b" class="lt lu jg bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">一些有用的资源:</h2><div class="ip iq gp gr ir mz"><a href="https://dbader.org/blog/python-dunder-methods" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jh gy z fp ne fr fs nf fu fw jf bi translated">用Dunder(神奇的，特殊的)方法丰富你的Python类——dbader.org</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Python的“神奇方法”是什么，以及如何使用它们使一个简单的account类更加Python化。在Python中…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">dbader.org</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ix mz"/></div></div></a></div><div class="ip iq gp gr ir mz"><a href="https://medium.com/swlh/welcome-to-python-meet-the-dunders-41026b2a7e36" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jh gy z fp ne fr fs nf fu fw jf bi translated">欢迎来到Python，认识一下邓德尔一家</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">python中几种__magic__方法的快速介绍</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="no l nk nl nm ni nn ix mz"/></div></div></a></div><figure class="ld le lf lg gt is"><div class="bz fp l di"><div class="np nq l"/></div></figure></div></div>    
</body>
</html>