<html>
<head>
<title>5 tips for data aggregation in pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据汇总的5个技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-tips-for-data-aggregation-in-pandas-7eaa8476dc75?source=collection_archive---------34-----------------------#2020-09-21">https://towardsdatascience.com/5-tips-for-data-aggregation-in-pandas-7eaa8476dc75?source=collection_archive---------34-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高数据处理技能的实用技巧</h2></div><p id="fb6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在做数据分析的时候，能够熟练的聚合数据起到了很重要的作用。Pandas提供了许多有用的方法，其中一些可能没有其他方法受欢迎。此外，即使对于众所周知的方法，我们也可以通过进一步调整它的参数或用其他方法补充它来增加它的效用。考虑到这些因素，如果你以前没有遇到过，这里有5个关于熊猫数据聚合的技巧:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/84cc6f917b24be59513478f7010518ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*kzBuHnsVh16Qm5prglNEDA.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">作者图片</p></figure><p id="522b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将通过例子展示它们是如何有用的。我也希望这些技巧能帮助你写出清晰、简洁、易读的代码。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="c4d3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">0.Python设置🔧</h1><p id="9424" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我假设读者(👀是的，你！)拥有:<br/> ◼️访问并熟悉Python，包括安装包、定义函数和其他基本任务<br/> ◼️使用pandas的工作知识，包括基本的数据操作。</p><p id="d952" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你还没有安装的话，确保你已经安装了<a class="ae mu" href="https://pandas.pydata.org/pandas-docs/stable/getting_started/install.html" rel="noopener ugc nofollow" target="_blank">熊猫</a>和<a class="ae mu" href="https://seaborn.pydata.org/installing.html" rel="noopener ugc nofollow" target="_blank">海龟</a>。</p><p id="02be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你是Python新手，<a class="ae mu" href="https://www.python.org/about/gettingstarted/" rel="noopener ugc nofollow" target="_blank">这个</a>是一个入门的好地方。如果你以前没有用过熊猫，<a class="ae mu" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html" rel="noopener ugc nofollow" target="_blank">这个</a>是一个很好的参考资料。</p><p id="7b56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mv">我在Jupyter Notebook中使用并测试了Python 3.7.1中的脚本。</em></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="fe6f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">1.数据📦</h1><p id="af7b" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我们将使用<em class="mv"> seaborn的提示</em>数据集来说明我的提示。</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="c044" class="nb ly it mx b gy nc nd l ne nf"># Import packages<br/>import pandas as pd<br/>from seaborn import load_dataset</span><span id="a787" class="nb ly it mx b gy ng nd l ne nf"># Import data <br/>df = load_dataset('tips').rename(columns={'sex': 'gender'})<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6f1317851dadc77ca0839e3b67db7a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*yircMV0yg7Qn8mPM9dvOng.png"/></div></figure><p id="f980" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于这个数据集(包括数据字典)的细节可以在这里<a class="ae mu" href="https://vincentarelbundock.github.io/Rdatasets/doc/reshape2/tips.html" rel="noopener ugc nofollow" target="_blank">找到</a>(这个源实际上是针对R的，但是它看起来是指同一个底层数据集)。为了便于快速查阅，我在下面引用了他们的数据描述:</p><blockquote class="ni nj nk"><p id="27e5" class="ki kj mv kk b kl km ju kn ko kp jx kq nl ks kt ku nm kw kx ky nn la lb lc ld im bi translated"><a class="ae mu" href="https://vincentarelbundock.github.io/Rdatasets/doc/reshape2/tips.html" rel="noopener ugc nofollow" target="_blank">“一名服务员记录了他在一家餐馆工作几个月期间收到的每一笔小费的信息。”</a></p></blockquote></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="fdfb" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">2.技巧🌟</h1><h2 id="06a4" class="nb ly it bd lz no np dn md nq nr dp mh kr ns nt mj kv nu nv ml kz nw nx mn ny bi translated">📍技巧1:对多变量计数/百分比使用crosstab()</h2><p id="7fb5" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">你可能已经熟悉这个系列函数:<code class="fe nz oa ob mx b">value_counts()</code>。运行<code class="fe nz oa ob mx b">df['day'].value_counts()</code>将给出<em class="mv">日</em>变量中唯一值的计数。如果我们在方法中指定<code class="fe nz oa ob mx b">normalize=True</code>，它将给出百分比。这对于单个变量很有用，但有时我们需要查看多个变量的计数。例如，如果我们想通过<em class="mv">日</em>和<em class="mv">时间</em>获得计数，一种方法是使用<code class="fe nz oa ob mx b">groupby()</code> + <code class="fe nz oa ob mx b">size()</code> + <code class="fe nz oa ob mx b">unstack()</code>:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="6b68" class="nb ly it mx b gy nc nd l ne nf">df.groupby(['time', 'day']).size().unstack()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b153b6e1dd826842e1d2705b9409571c.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*sKSZd0WEECfnTlal-eFDZw.png"/></div></figure><p id="c4c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种更灵活的方式是使用<code class="fe nz oa ob mx b">crosstab()</code>:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="a4a3" class="nb ly it mx b gy nc nd l ne nf">pd.crosstab(df['time'], df['day'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d5329a8629614adf8729fe468f8bfc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*6zmphK00biNdBkhQSJbBsQ.png"/></div></figure><p id="e8b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe nz oa ob mx b">crosstab()</code>有一些好处。首先，很容易得到行和列的小计——我们只需加上<code class="fe nz oa ob mx b">margins=True</code>:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="0ee0" class="nb ly it mx b gy nc nd l ne nf">pd.crosstab(df['time'], df['day'], margins=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/fc79fc7fa1057d3dbb2f7ec1fae4f627.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*B_F9a2GZ2KKI4i45aA-goQ.png"/></div></figure><p id="cf1c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是不是很牛逼？其次，通过调整<code class="fe nz oa ob mx b">normalize</code>参数，我们可以很容易地得到百分比而不是计数:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="0830" class="nb ly it mx b gy nc nd l ne nf">pd.crosstab(df['time'], df['day'], margins=True, normalize=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ae49e03526a707fb4d44c9392cd3a556.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*GSAjhoajgQ2TQb5huvr98Q.png"/></div></figure><p id="74ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们通过设置<code class="fe nz oa ob mx b">normalize=True</code>获得了表格百分比。这相当于将其设置为<code class="fe nz oa ob mx b">normalize='all'</code>。对于行百分比，我们使用<code class="fe nz oa ob mx b">normalize='index'</code>和<code class="fe nz oa ob mx b">normalize='columns'</code>表示列百分比。我们还可以进一步扩展列和行的变量集:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="0d21" class="nb ly it mx b gy nc nd l ne nf">pd.crosstab([df['time'], df['gender']], [df['day'], df['smoker']], <br/>            margins=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/78bea4950b1f9390aba07a8530f66b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*CcAspxvifzSoWigLizjZvQ.png"/></div></div></figure><p id="1189" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发现<code class="fe nz oa ob mx b">crosstab()</code>后，我现在用熊猫的时候也经常用。</p><h2 id="c7c2" class="nb ly it bd lz no np dn md nq nr dp mh kr ns nt mj kv nu nv ml kz nw nx mn ny bi translated">📍技巧2:使用groupby()和describe()进行分组汇总统计</h2><p id="6cd1" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">你可能已经知道了<code class="fe nz oa ob mx b">groupby()</code>和<code class="fe nz oa ob mx b">describe()</code>。但是你们一起用过吗？通过结合使用这两种方法，我们可以通过分类列中的唯一值来检查数值变量的汇总统计信息，只需一行代码，如下所示:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="ab00" class="nb ly it mx b gy nc nd l ne nf">df.groupby('day')['tip'].describe()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/ed443a85ed1e7a3d1d835cfe92a373ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*zeexkL6yaiX8TUg5yuJ87A.png"/></div></figure><p id="bb4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到<em class="mv">提示</em>的汇总统计如何在<em class="mv">天</em>进行比较。</p><h2 id="97b4" class="nb ly it bd lz no np dn md nq nr dp mh kr ns nt mj kv nu nv ml kz nw nx mn ny bi translated">📍技巧3:使用agg()/aggregate()进行灵活的聚合</h2><p id="9fdd" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated"><em class="mv">在本帖中，我们将使用</em> <code class="fe nz oa ob mx b"><em class="mv">agg()</em></code> <em class="mv">，</em> <code class="fe nz oa ob mx b"><em class="mv">aggregate()</em></code> <em class="mv">的别名。然而，两者可以互换使用。</em></p><p id="9f9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能知道基本的聚合语法，如下所示:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="f191" class="nb ly it mx b gy nc nd l ne nf">df.groupby('day')[['tip']].mean()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi om"><img src="../Images/a397eb519407108186afee6725999b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:262/format:webp/1*1aH5QTNseW2GJYcLCpGv3g.png"/></div></figure><p id="055e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是用<code class="fe nz oa ob mx b">agg()</code>获得相同输出的一些替代方法:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="1e2e" class="nb ly it mx b gy nc nd l ne nf">df.groupby('day')[['tip']].agg('mean')<br/>df.groupby('day').agg({'tip': 'mean'})</span></pre><p id="8b71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个简单的例子中，没有明显的优势说明为什么应该使用<code class="fe nz oa ob mx b">agg()</code>而不是第一种选择。然而，当我们想要查看多个聚合函数的输出时，使用<code class="fe nz oa ob mx b">agg()</code>给了我们更多的灵活性。例如，通过向<code class="fe nz oa ob mx b">agg()</code>传递一个列表或一个字典，我们可以一次得到均值和标准差。</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="4142" class="nb ly it mx b gy nc nd l ne nf">df.groupby('day')[['tip']].agg(['mean', 'std']) # list<br/>df.groupby(['day']).agg({'tip': ['mean', 'std']}) # dictionary</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi on"><img src="../Images/61e0af5bdb840d1db2d730f445ad25f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*JDYNmNDpaZo4UGXfewxKFw.png"/></div></figure><p id="7a63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们必须重命名输出列，而不是这样做:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="ede6" class="nb ly it mx b gy nc nd l ne nf">df.groupby('day')[['tip']].agg(['mean', 'std']).rename(columns={'mean': 'avg', 'std': 'sd'})</span></pre><p id="856e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以更简洁地做到这两点:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="f6ac" class="nb ly it mx b gy nc nd l ne nf">df.groupby(['day'])[['tip']].agg([('avg', 'mean'), ('sd', 'std')])<br/>df.groupby(['day']).agg({'tip': [('avg', 'mean'), ('sd', 'std')]})</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a8f80150a61ccf9312b4a32f90816168.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*A-OmRDJYFfOl2xj2FWWxpQ.png"/></div></figure><p id="e405" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，使用列表或字典都同样有效。但是，如果我们想要检查多个变量的同一组汇总统计信息，使用list会更简洁。</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="ebfb" class="nb ly it mx b gy nc nd l ne nf">df.groupby('day')[['tip', 'size']].agg(['mean', 'std'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9e7399d4e09b07ade5fdb93be0cc5391.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*3wc0tSCEwZ1i4Bx0zu1BFQ.png"/></div></figure><p id="86e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，有时使用字典是可行的方法。使用dictionary，我们可以为每个变量指定不同的集合函数:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="b99d" class="nb ly it mx b gy nc nd l ne nf">df.groupby(['day']).agg({'tip': ['mean', 'std'], <br/>                         'size': ['median']})</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0c30bea33cd8ba2c08c8a3bd0448794a.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*zmrGe3N0gJISMQI5Z2CX1g.png"/></div></figure><p id="34b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多聚合函数可供使用:</p><p id="7ed1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">◼️频率/计数:<code class="fe nz oa ob mx b">size()</code>，<code class="fe nz oa ob mx b">count()</code> <br/> ◼️中央倾向:<code class="fe nz oa ob mx b">mean()</code>，<code class="fe nz oa ob mx b">median()</code> <br/> ◼️方差:<code class="fe nz oa ob mx b">std()</code>，<code class="fe nz oa ob mx b">var()</code> <br/> ◼️其他:<code class="fe nz oa ob mx b">min()</code>，<code class="fe nz oa ob mx b">max()</code>，️ <code class="fe nz oa ob mx b">sum()</code>，<code class="fe nz oa ob mx b">prod()</code>，<code class="fe nz oa ob mx b">quantile()</code>等等。</p><p id="a9f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，我们可以在<code class="fe nz oa ob mx b">agg()</code>中使用任何Series或DataFrame方法。例如，要查看<em class="mv">日</em>前最高的两个<em class="mv">提示</em>，我们使用:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="4a82" class="nb ly it mx b gy nc nd l ne nf">df.groupby('day')['tip'].nlargest(2)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi or"><img src="../Images/571b1ed50405597e5ae8ee82ec2ac84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*Gga9uCMCfjlyofj8R_Z2LQ.png"/></div></figure><p id="1702" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到一些最大的提示是在周六。💰</p><p id="79dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们也可以使用lambda函数:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="78f0" class="nb ly it mx b gy nc nd l ne nf">df.groupby(['day']).agg({'tip': [('range', lambda x: x.max() - x.min()), <br/>                                 ('IQR', lambda x: x.quantile(.75) - x.quantile(.25))]})</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi os"><img src="../Images/43319307632ab29f2b3ce009f6dc64d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*vd-0JluakMZxStSWHMLwJw.png"/></div></div></figure><p id="1349" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这扩展了我们可以做什么的可能性！😎</p><h2 id="eee6" class="nb ly it bd lz no np dn md nq nr dp mh kr ns nt mj kv nu nv ml kz nw nx mn ny bi translated">📍技巧4:利用pivot_table()</h2><p id="5a91" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">假设我们需要得到两个变量的平均值<em class="mv">提示</em>。一种常见的方法是使用<code class="fe nz oa ob mx b">groupby()</code>:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="736f" class="nb ly it mx b gy nc nd l ne nf">df.groupby(['time', 'day'])['tip'].mean().unstack()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/04c36cdaeb2c26ffc11bc52baecd3149.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*WVkj23GzRb5J7GESfak7Aw.png"/></div></figure><p id="0c08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是更好的方法是使用<code class="fe nz oa ob mx b">pivot_table()</code>:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="c35e" class="nb ly it mx b gy nc nd l ne nf">df.pivot_table('tip', 'time', 'day')</span></pre><p id="c9bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们没有指定参数，因为我们已经按照正确的顺序为方法提供了值。下面是相同代码的另一个版本，其中所有参数都被显式指定:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="0bad" class="nb ly it mx b gy nc nd l ne nf">df.pivot_table(values='tip', index='time', columns='day')</span></pre><p id="eac3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个版本可能可读性更强。我认为，如果我们省略第一个参数名称，使其稍微简洁一些，可读性不会受到影响:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="4eb4" class="nb ly it mx b gy nc nd l ne nf">df.pivot_table('tip', index='time', columns='day')</span></pre><p id="2774" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将保持这种形式向前发展。</p><p id="45ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，<code class="fe nz oa ob mx b">pivot_table()</code>给出平均值。然而，我们可以通过将它指定为<code class="fe nz oa ob mx b">aggfunc</code>参数来轻松地更改为我们喜欢的函数，例如<code class="fe nz oa ob mx b">sum()</code>:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="26a4" class="nb ly it mx b gy nc nd l ne nf">df.pivot_table('tip', index='time', columns='day', aggfunc='sum')</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/91470e4b977c63c824eab707ed4e083e.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*P75I1aFXSxnBYSuXjpGmPA.png"/></div></figure><p id="84b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于<code class="fe nz oa ob mx b">crosstab()</code>，用<code class="fe nz oa ob mx b">pivot_table()</code>也很容易得到小计。</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="c57b" class="nb ly it mx b gy nc nd l ne nf">df.pivot_table('tip', index='time', columns='day', aggfunc='sum', <br/>               margins=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/150c9ca01a11f075acc4dab407e11415.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*CQF3Ha1wDNllALkxODWwag.png"/></div></figure><p id="8507" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以将字典传递给<code class="fe nz oa ob mx b">aggfunc</code>，为传递给<code class="fe nz oa ob mx b">values</code>参数的每个变量定制聚合函数。另一个有用的参数是<code class="fe nz oa ob mx b">fill_value</code>,在这里我们指定如果输出丢失，我们希望看到什么值。让我们看一个例子来说明这些观点:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="fe71" class="nb ly it mx b gy nc nd l ne nf">df.pivot_table(['tip', 'size'], index=['time', 'smoker'], <br/>               columns='day', fill_value=0, margins=True,<br/>               aggfunc={'tip': 'sum', 'size': 'max'})</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi ow"><img src="../Images/d02481c5f5d64c8ad75cc72297b85245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*bS9JOYBlp0lJbwox7P8GqQ.png"/></div></div></figure><p id="5998" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe nz oa ob mx b">pivot_table()</code>，您可以准确地知道哪些变量将出现在行和列中，并且不需要对数据进行整形。</p><h2 id="928a" class="nb ly it bd lz no np dn md nq nr dp mh kr ns nt mj kv nu nv ml kz nw nx mn ny bi translated">📍技巧5:使用transform()向数据添加聚合统计信息</h2><p id="1bfc" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">当我们希望将分组聚合度量值追加回未分组的数据时，这个技巧很有用。这里有一个例子来说明这一点:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="5691" class="nb ly it mx b gy nc nd l ne nf">df['avg_tip_by_gender'] = df.groupby('gender')['tip'].transform('mean')</span><span id="8418" class="nb ly it mx b gy ng nd l ne nf">df.head()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/dbadbe828cb40a537c2c4ec6327d7df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*Ij9ETaqB66RcOP-PHkdDDg.png"/></div></figure><p id="c810" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，新创建的变量<em class="mv"> avg_tip_by_gender </em>显示了按<em class="mv">性别</em>分类的平均<em class="mv"> tip </em>。换句话说，来自下方的平均<em class="mv">提示</em>由<em class="mv">性别</em>添加回未分组数据。</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="1efe" class="nb ly it mx b gy nc nd l ne nf">df.groupby('gender')['tip'].agg(['mean', 'std'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/67c8411e22ebad79473a44e7ce49a80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*JMLfs3Aja1BXMp3ik2d3AA.png"/></div></figure><p id="b7eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们举一个稍微高级一点的例子:</p><pre class="lf lg lh li gt mw mx my mz aw na bi"><span id="9e9c" class="nb ly it mx b gy nc nd l ne nf">df['n_sd_from_gender_avg_tip'] = df.groupby('gender')['tip'].transform(lambda x: (x-x.mean())/x.std())</span><span id="d7af" class="nb ly it mx b gy ng nd l ne nf">df.head()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi oz"><img src="../Images/b13f15853903d3f1e096d901e45f2621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGzplP7b3Oz4QUnESx4GCw.png"/></div></div></figure><p id="000a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，使用<code class="fe nz oa ob mx b">lambda</code>函数，我们为变量<em class="mv">提示</em>做了3件事:</p><p id="098b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nz oa ob mx b">x.mean():</code>按<em class="mv">性别</em>找均值。<br/> <code class="fe nz oa ob mx b">x-x.mean():</code>通过<em class="mv">性别</em>求距离平均值。<br/> <code class="fe nz oa ob mx b">(x-x.mean())/x.std():</code>以标准差为单位求距离。</p><p id="f7fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们以第一条记录(index=0)为例，为了简单起见，将数字四舍五入到小数点后两位:<code class="fe nz oa ob mx b">x=1.01</code>、<code class="fe nz oa ob mx b">x.mean()=2.83</code>、<code class="fe nz oa ob mx b">x.std()= 1.16</code></p><p id="921e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，<em class="mv">n _ SD _ from _ gender _ avg _ tip</em>=(1.01-2.83)/1.16 =-1.57</p><p id="652f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们在<em class="mv"> n_sd_from_gender_avg_tip第一行找到的。</em>对于此<em class="mv"> </em>记录，<em class="mv">小费</em>金额比女性顾客的平均<em class="mv">小费</em>低约1.57个标准差。</p><p id="31be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Voila❕:这些是我目前关于熊猫的顶级数据汇总技巧！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi pa"><img src="../Images/82beb509b151c6f79587e56ba3e7c950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bYN0Zp_rkspDdXDr"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">照片由<a class="ae mu" href="https://unsplash.com/@bolotohodova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">宝琳娜·剃刀洛娃</a>在<a class="ae mu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3f20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mv">您想访问更多这样的内容吗？媒体会员可以无限制地访问媒体上的任何文章。如果您使用</em> <a class="ae mu" href="https://zluvsand.medium.com/membership" rel="noopener"> <em class="mv">我的推荐链接</em></a><em class="mv">成为会员，您的一部分会费将直接用于支持我。</em></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="6985" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你看我的帖子。希望我的建议对你有用，✂️.如果你有兴趣了解更多关于熊猫的信息，这里有我其他帖子的链接:<br/> ◼️️ <a class="ae mu" rel="noopener" target="_blank" href="/writing-5-common-sql-queries-in-pandas-90b52f17ad76">在熊猫中编写5个常见的SQL查询</a> <br/> ◼️️ <a class="ae mu" rel="noopener" target="_blank" href="/5-tips-for-pandas-users-e73681d16d17">给熊猫用户的5个提示</a> <br/> ◼️️ <a class="ae mu" rel="noopener" target="_blank" href="/transforming-variables-in-a-pandas-dataframe-bce2c6ef91a1">如何在熊猫数据框架中转换变量</a></p><p id="a116" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再见🏃💨</p></div></div>    
</body>
</html>