<html>
<head>
<title>A Gentle Introduction: Automating Machine Learning Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个温和的介绍:自动化机器学习管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-gentle-introduction-automating-machine-learning-pipelines-71f97192eabf?source=collection_archive---------27-----------------------#2020-11-05">https://towardsdatascience.com/a-gentle-introduction-automating-machine-learning-pipelines-71f97192eabf?source=collection_archive---------27-----------------------#2020-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="fe2c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/16c499232aa171bf27dd23f5383e0b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMnXJ6R0uukYxeN1oZnu8g.jpeg"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated"><a class="ae kl" href="https://unsplash.com/@er1end?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">昂斯佩上的厄伦德·埃克塞斯</a></p></figure><h1 id="a62c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">部署很难</h1><p id="e29a" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">定期可靠地部署软件很难。定期可靠地部署利用机器学习(ML)模型的软件可能更加困难。最终，您最新模型管道的长期价值将(部分)取决于您的公司或客户对最终服务的信任程度，以及您通过迭代管道解决不断变化的客户需求的速度。</p><p id="f2fd" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">这就是自动化可以派上用场的地方:<em class="mi">ML管道的仔细的</em>自动化可以通过允许您快速迭代管道以考虑新的业务逻辑或建模变化，同时还确保这些变化在投入与您的利益相关者/客户的服务之前满足关键性能标准<em class="mi">，从而大大提高您的生产力。</em></p><p id="e717" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">听起来很酷，对吧？但是<em class="mi">你</em>需要自动化的ML流水线吗？这个问题很大程度上可以归结为以下问题</p><ul class=""><li id="103d" class="mo mp iq lm b ln mj lr mk lv mq lz mr md ms mh mt mu mv mw bi translated">你<em class="mi">能够</em>(作为一个ML实践者)<em class="mi">快速</em>并且<em class="mi">自信地</em>通过一次<code class="fe mx my mz na b">git</code>提交发布变更“进入生产”吗？</li></ul><p id="5ddc" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">换句话说:您能快速自信地发布模型和管道的更新吗？你有一个系统的过程来评估和测试你的模型<em class="mi">和</em>管道(包括业务逻辑，转换等等)的行为吗？</p><p id="27f1" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">如果这类问题的答案是“不”(或者你不确定！)，那这个帖子就送给你了！</p><h1 id="89ce" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">你会学到什么</h1><p id="9623" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">以下是你应该从这篇文章中得到的:</p><ul class=""><li id="eca5" class="mo mp iq lm b ln mj lr mk lv mq lz mr md ms mh mt mu mv mw bi translated">对运动背后的一些关键思想和动机的理解集中于提高ML系统(通常称为MLOps)的可靠性和自动化水平。</li><li id="b89c" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh mt mu mv mw bi translated">了解如何使用GitHub Actions和Google Cloud来自动化一个基本的ML管道。你将使用免费服务(或免费等级/介绍性服务)，所以它不应该花你一毛钱！</li><li id="1618" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh mt mu mv mw bi translated">这是一个演示项目，允许您将Scikit-Learn管道部署为“生产就绪”的无服务器功能！它也是一个模板项目，所以你可以用它作为你自己的ML项目的基础！</li></ul><p id="2cd3" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">和往常一样，对于那些想要深入了解代码的人，请查看这里的GitHub工作流文件(<code class="fe mx my mz na b">.github/workflows/pipeline.yml</code>):</p><div class="ng nh gp gr ni nj"><a href="https://github.com/markdouthwaite/serverless-scikit-learn-demo" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ja gy z fp no fr fs np fu fw iz bi translated">markdouthwaite/无服务器-scikit-learn-demo</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">一个提供演示代码的存储库，用于部署基于轻量级Scikit-Learn的ML管道心脏病建模…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kf nj"/></div></div></a></div><p id="67f1" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">如果你知道MLOps是什么，只是想按照教程，请随意跳过。</p><h1 id="1bc8" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么是MLOps？</h1><p id="42dc" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">在过去十年左右的时间里,“DevOps”运动在软件工程领域获得了大量专业人士的支持，大量专门的DevOps角色在世界各地的开发团队中涌现出来。这一运动的动机是将软件开发(Dev)的各个方面与操作(Ops)软件活动的元素相结合，目的是在持续的基础上加速可靠的、工作的软件的交付。</p><p id="ef64" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">DevOps运动的主要焦点是建立和维护持续集成和持续交付(CI/CD)管道。在实践中，设计良好且实施干净的CI/CD管道为团队提供了持续修改其软件系统的能力，以(原则上)显著减少新软件补丁和功能的价值实现时间，同时最小化与发布这些补丁和功能相关的错误和中断带来的负面风险。运行这种交付机制的成熟实现的团队通常每小时发布一次更新(或者更快！)能够在变更引入bug时快速、干净地回滚变更(尽管大多数这些<em class="mi">应该在管道中的某个地方被捕获)。</em></p><p id="8429" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">相比之下，发布软件的“传统”方法本质上是为预定义的发布窗口(可能是每周、每月或每季度)储备补丁和特性。虽然这种方法并不是<em class="mi">一致认为</em>一个糟糕的方法，但它确实在发布窗口周围引入了很多压力，会在产品集成和发布过程周围产生很多复杂性，并最终增加了严重服务中断的风险，进而损害品牌。</p><h1 id="1a45" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">这对机器学习意味着什么？</h1><p id="5c99" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">在这一点上，你可能会想‘这一切都很好，但这与机器学习有什么关系？’。就像成功的商业软件产品一样，成功的商业机器学习(ML)项目<em class="mi">需要</em>ML服务的用户信任他们消费的服务的<em class="mi">有效性</em>和<em class="mi">稳定性</em>。重要的是，<em class="mi">这必须持续进行</em>——可能一次持续数年。</p><p id="34b4" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">因此，<em class="mi">临时</em>模型培训和评估活动需要大量人工干预，类似于数据科学团队的“传统”软件交付流程——这在数据科学领域是司空见惯的——可能会给服务的生命周期带来严重的技术和业务风险，应被视为特别有害的技术债务形式。</p><blockquote class="ny nz oa"><p id="85c6" class="lk ll mi lm b ln mj lp lq lr mk lt lu ob ml lx ly oc mm mb mc od mn mf mg mh ij bi translated">与成功的商业软件产品非常相似，成功的商业机器学习(ML)项目要求ML服务的用户信任他们所消费的服务的有效性和稳定性。</p></blockquote><p id="569a" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">这就是MLOps的用武之地。这个新生的运动可以被视为DevOps运动的超集:它的目标是在持续的基础上加速可靠的、工作的<em class="mi"> ML </em>软件的交付。因此，它以与DevOps非常相似的方式关注CI/CD管道，但也增加了这些CI/CD问题的特定变化。<a class="ae kl" href="https://cloud.google.com/solutions/machine-learning/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning#mlops_level_1_ml_pipeline_automation" rel="noopener ugc nofollow" target="_blank">最值得注意的是，持续培训(CT)的概念被加入到组合中。</a>你问CT是什么？</p><ul class=""><li id="02ee" class="mo mp iq lm b ln mj lr mk lv mq lz mr md ms mh mt mu mv mw bi translated"><strong class="lm ja">持续培训</strong> —许多ML服务需要在某个固定的基础上或在特定事件发生时(如数据变化、上游模型更新)对其基础ML模型进行再培训。此外，重要的是，这些新重新训练的模型符合定义有问题的模型的先前版本的基本假设和行为。因此，持续培训是关于建立<em class="mi">健壮的、自动化的</em>流程，用于培训和部署模型，作为传统持续交付管道的一个专门变体，包括作为更广泛的软件服务的一部分的ML模型的预处理、评估、选择和服务。</li></ul><p id="9cd9" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">这里的目标是允许ML从业者快速自信地将他们最新最好的模型部署到生产中，同时保持依赖它们的服务的稳定性。</p><h1 id="1ffd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">胸怀大志</h1><p id="d188" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">整个ML世界越来越认识到需要能够开发和部署“生产级”ML解决方案的团队——特别是在以产品为中心的ML应用中——以及由此产生的拥有组织孤立的ML/技术能力的潜在技术(和商业)风险。在许多方面，这与更广泛的软件工程社区认识到“传统”软件应用程序的类似需求(和风险)的知识是一致的。</p><blockquote class="ny nz oa"><p id="8a22" class="lk ll mi lm b ln mj lp lq lr mk lt lu ob ml lx ly oc mm mb mc od mn mf mg mh ij bi translated"><em class="iq">与之前更广泛的软件工程生态系统一样，ML工具链正在商品化:进入壁垒(成本、专业知识)正在逐渐降低，市场竞争越来越激烈。</em></p></blockquote><p id="5fbf" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">这种认识导致了一个围绕上述许多问题的新兴生态系统。每个月都有新的工具和平台推出，明确针对ML/MLOps挑战。正如之前更广泛的软件工程生态系统一样，ML工具链正在商品化:进入壁垒(成本、专业知识)正在逐渐降低，市场竞争越来越激烈。对于那些希望开始MLOps(或一般意义上的ML)的人来说，这是一个非常令人兴奋的参与时机:你可以以很低的成本走一条<em class="mi">漫长的</em>道路，实现“生产就绪”的ML管道。以下是方法。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="6122" class="km kn iq bd ko kp ol kr ks kt om kv kw kx on kz la lb oo ld le lf op lh li lj bi translated">创建ML管道</h1><p id="fe7a" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">好了，该上教程了！</p><p id="30d6" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">这里展示的ML管道是使用<a class="ae kl" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank">GitHub Actions</a>——GitHub的工作流自动化工具构建的。如果你注册了一个GitHub账户，你就可以免费使用这个功能<em class="mi"/>。有<a class="ae kl" href="https://docs.github.com/en/actions/getting-started-with-github-actions/about-github-actions" rel="noopener ugc nofollow" target="_blank">使用</a>和<a class="ae kl" href="https://docs.github.com/en/actions/reference/virtual-environments-for-github-hosted-runners" rel="noopener ugc nofollow" target="_blank">资源</a>限制(如你所料)，但作为免费提供，这些限制出奇的慷慨。如果你能保持你的模型相对轻量级，你可以单独在免费提供的基础上构建一个小产品，所以对于那些有一些很酷的MVP想法的人来说，这可能是一个很好的起点。此外，如果免费资源不适合你，<a class="ae kl" href="https://github.blog/2020-08-04-github-actions-self-hosted-runners-on-google-cloud/" rel="noopener ugc nofollow" target="_blank">你也可以创建“自主”行动</a>。</p><p id="8e29" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">那么这里给出的管道示例将会做什么呢？该管道将是一个基本的CT/CD管道，构建在<a class="ae kl" href="https://mark.douthwaite.io/serverless-machine-learning/" rel="noopener ugc nofollow" target="_blank">上，即上一篇文章</a>中讨论的无服务器ML示例之上。如果你还没有读过，值得一读:</p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/serverless-ml-deploying-lightweight-models-at-scale-886443d88426"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ja gy z fp no fr fs np fu fw iz bi translated">无服务器ML:大规模部署轻量级模型</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">将ML模型作为可伸缩的API“部署到生产中”可能会很棘手。这篇文章着眼于一个选择，使模型…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="oq l nu nv nw ns nx kf nj"/></div></div></a></div><p id="f12f" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">以下是您的新管道将完成的工作:</p><ol class=""><li id="4229" class="mo mp iq lm b ln mj lr mk lv mq lz mr md ms mh or mu mv mw bi translated">设置您的环境并安装依赖项。</li><li id="2545" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh or mu mv mw bi translated">下载数据集的最新可用版本。</li><li id="8ed1" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh or mu mv mw bi translated">在最新数据集上训练和评估模型的新版本。</li><li id="c95e" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh or mu mv mw bi translated">上传新模型和评估结果。</li><li id="801c" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh or mu mv mw bi translated">如果前面的步骤成功，那么触发新模型作为API的重新部署。</li></ol><p id="9c4b" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">此外，您将看到如何<em class="mi">安排</em>这个工作流作为<code class="fe mx my mz na b"><a class="ae kl" href="https://en.wikipedia.org/wiki/Cron" rel="noopener ugc nofollow" target="_blank">cron</a></code>作业定期运行(同样使用GitHub动作)。</p><h1 id="bf57" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">开始之前</h1><p id="d8ce" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">如果你想运行演示项目，你需要注册一个谷歌云账户。在撰写本文时，您的帐户中将增加300美元的信用点数。这将<em class="mi">比运行本教程中代码的成本还要多</em>(无论如何，这基本上是免费的！).您可以在此找到更多信息:</p><div class="ng nh gp gr ni nj"><a href="https://cloud.google.com/free" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ja gy z fp no fr fs np fu fw iz bi translated">GCP免费等级免费扩展试用和永远免费|谷歌云</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">20多种免费产品免费体验热门产品，包括计算引擎和云存储，最高可达…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">cloud.google.com</p></div></div><div class="ns l"><div class="os l nu nv nw ns nx kf nj"/></div></div></a></div><p id="bc17" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">和往常一样，如果你注册了，但不想继续使用谷歌云，<em class="mi">确保取消你的帐户</em>！</p><p id="06d4" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">以下是您将需要的模板库:</p><div class="ng nh gp gr ni nj"><a href="https://github.com/markdouthwaite/serverless-scikit-learn-demo" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ja gy z fp no fr fs np fu fw iz bi translated">markdouthwaite/无服务器-scikit-learn-demo</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">一个提供演示代码的存储库，用于部署基于轻量级Scikit-Learn的ML管道心脏病建模…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kf nj"/></div></div></a></div><p id="b3e7" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">接下来，您应该<a class="ae kl" href="https://docs.github.com/en/free-pro-team@latest/github/getting-started-with-github/fork-a-repo" rel="noopener ugc nofollow" target="_blank">在您的个人GitHub帐户中创建一个模板库的分支</a>，或者<a class="ae kl" href="https://docs.github.com/en/free-pro-team@latest/github/creating-cloning-and-archiving-repositories/creating-a-new-repository" rel="noopener ugc nofollow" target="_blank">从模板</a>创建一个新的库。完成这些后，您需要设置几个GitHub秘密来允许您的管道访问您的Google云服务。你可以在GitHub文档中找到如何<a class="ae kl" href="https://docs.github.com/en/free-pro-team@latest/rest/reference/actions#secrets" rel="noopener ugc nofollow" target="_blank">设置秘密。具体来说，您需要添加:</a></p><ul class=""><li id="5a37" class="mo mp iq lm b ln mj lr mk lv mq lz mr md ms mh mt mu mv mw bi translated"><code class="fe mx my mz na b">GCP_PROJECT_ID</code> -唯一的谷歌云项目ID。你可以在谷歌云控制台找到你的项目ID。如果您不确定，Google <a class="ae kl" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects" rel="noopener ugc nofollow" target="_blank">提供了一个文档来查找这个值</a>。</li><li id="3f61" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh mt mu mv mw bi translated"><code class="fe mx my mz na b">GCP_SA_KEY</code> -服务账户(SA)密钥。这是一个安全密钥，用于访问项目中的特定云服务。在本例中，为了简单起见，您将使用一个具有提升权限的默认SA。在实践中，<a class="ae kl" href="https://cloud.google.com/iam/docs/granting-changing-revoking-access" rel="noopener ugc nofollow" target="_blank">您应该考虑创建一个特权减少的服务协议</a>。<em class="mi">您需要为您的SA创建一个新密钥，并将其作为一个秘密复制到GitHub。</em>同样，<a class="ae kl" href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys" rel="noopener ugc nofollow" target="_blank"> Google有一个关于如何生成这个密钥</a>的详细文档。</li></ul><p id="c3c8" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated"><strong class="lm ja">注意</strong>:像对待机密/安全信息一样，不要与任何人共享您的SA密钥！理想情况下，当您完成这个示例时，删除它(当然，除非您想在自己的项目中继续使用它)。</p><p id="52b4" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">完成这些设置后，您需要启用您的Google云构建、云功能和云存储API。要做到这一点，只需浏览谷歌云控制台左侧的导航栏，并选择相关的云服务。如果相关的API没有被激活，当你点击服务的时候，你可以选择激活它。</p><p id="06f2" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">最后，在下面的管道定义中，您需要在您的Google云存储中定义一个唯一的<em class="mi">bucket名称。示例管道定义(如下)中使用的名称是<code class="fe mx my mz na b">pipeline-example</code>。您应该在分叉之后，但在</em>尝试运行示例之前，用您自己的bucket的名称替换它。此外，您还需要将存储库中的<code class="fe mx my mz na b">datasets/default.csv</code>数据集上传到<code class="fe mx my mz na b">{your-bucket-name}/heart-disease/dataset.csv</code>。</p><p id="21aa" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">现在，不管是好是坏，是时候来点YAML了——云的语言。</p><h1 id="1ac6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">管道定义</h1><p id="8247" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated"><a class="ae kl" href="https://github.com/markdouthwaite/serverless-scikit-learn-demo/blob/master/.github/workflows/pipeline.yml" rel="noopener ugc nofollow" target="_blank">管道被定义为YAML文件</a>。如果你想看得更透彻，你也应该看看GitHub的<a class="ae kl" href="https://docs.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow" rel="noopener ugc nofollow" target="_blank">工作流文件格式介绍</a>。如果你喜欢YAML，这可能很容易做到，但不管怎样，下面是它的分解方式:</p><h1 id="ba54" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">0.作业设置和调度</h1><p id="b098" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">文件的这一部分将工作流命名为<code class="fe mx my mz na b">Train and Deploy</code>(这将是GitHub如何在GitHub UI中显示您的工作流)，然后提供<em class="mi">事件触发器</em>来触发您的管道运行。在这种情况下，您会看到有两个触发器:<code class="fe mx my mz na b">push</code>和<code class="fe mx my mz na b">schedule</code>。</p><p id="c988" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">在<code class="fe mx my mz na b">push</code>的情况下，管道将在每次更新您的存储库的<code class="fe mx my mz na b">master</code>分支时运行(具体的分支可以在<code class="fe mx my mz na b">branches</code>字段中列出)。实际上，这意味着每当您将库中的代码变更合并到<code class="fe mx my mz na b">master</code>中时，管道将重新训练模型并重新部署它。这对于将代码变更立即传播到活动的ML服务是非常有用的。</p><p id="43d2" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">对于<code class="fe mx my mz na b">schedule</code>触发器，您只需为您的管道设置一个运行的<code class="fe mx my mz na b">cron</code>时间表。换句话说:管道运行的固定时间表。下面提供的示例值将在每个工作日早上08:00运行管道。如果你不确定如何配置一个<code class="fe mx my mz na b">cron</code>时间表，这里有<a class="ae kl" href="https://crontab.guru/" rel="noopener ugc nofollow" target="_blank">一个很棒的交互式编辑器</a>供你使用。</p><pre class="ot ou ov ow gt ox na oy oz aw pa bi"><span id="406d" class="pb kn iq na b gy pc pd l pe pf">name: Train and Deploy</span><span id="a5ad" class="pb kn iq na b gy pg pd l pe pf">on:<br/>  push:<br/>    branches:<br/>      - master<br/>  schedule:<br/>    - cron:  '0 8 * * MON-FRI'</span></pre><p id="dc46" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">随意玩<a class="ae kl" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">其他触发</a>。此外，你也可以编写自定义触发器，<a class="ae kl" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_dispatch" rel="noopener ugc nofollow" target="_blank">如果你觉得有趣的话</a>。这些自定义触发器可以帮助您建立一个“真正的”事件驱动架构。只是一个想法。</p><h1 id="82a2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1.环境设置</h1><p id="1261" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">现在是无聊但非常重要的一步。键<code class="fe mx my mz na b">train</code>定义了步骤的名称。在这里你有一个单一的工作。在其中，您必须定义将要在其上运行作业的虚拟机(<code class="fe mx my mz na b">runs-on</code>)。在这种情况下，示例使用的是<code class="fe mx my mz na b">ubuntu-latest</code>。接下来，定义作业中的每个<code class="fe mx my mz na b">steps</code>。</p><p id="5514" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">首先，运行<code class="fe mx my mz na b">actions/checkout@v2</code>。这将运行GitHub提供的<code class="fe mx my mz na b">checkout</code>动作。这将克隆并检出您的存储库的默认(通常是<code class="fe mx my mz na b">master</code>)分支。</p><p id="be56" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">接下来，作业设置<code class="fe mx my mz na b">gcloud</code> <a class="ae kl" href="https://cloud.google.com/sdk/gcloud" rel="noopener ugc nofollow" target="_blank">命令行工具</a>。这一步使用Google Cloud 提供的动作<a class="ae kl" href="https://github.com/GoogleCloudPlatform/github-actions" rel="noopener ugc nofollow" target="_blank">让你的生活变得更简单。这允许后续步骤访问<code class="fe mx my mz na b">gcloud</code>和<code class="fe mx my mz na b">gsutils</code>命令行工具。稍后，您将使用这些工具从/向Google Cloud下载/上传数据，并重新部署您的模型API。</a></p><p id="ee31" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">在这之后，您有两个Python相关的步骤。第一部分设置了一个基本的Python 3.7环境。第二步安装顶层<code class="fe mx my mz na b">requirements.txt</code>文件中的所有依赖项。这样，您的工作就可以正确地运行您的管道了。现在是有趣的部分。</p><pre class="ot ou ov ow gt ox na oy oz aw pa bi"><span id="fc76" class="pb kn iq na b gy pc pd l pe pf">train:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>    - uses: actions/checkout@v2</span><span id="5342" class="pb kn iq na b gy pg pd l pe pf">    - name: Setup GCP client<br/>      uses: GoogleCloudPlatform/github-actions/setup-gcloud@master<br/>      with:<br/>        version: '290.0.1'<br/>        project_id: ${{ secrets.GCP_PROJECT_ID }}<br/>        service_account_key: ${{ secrets.GCP_SA_KEY }}<br/>        export_default_credentials: true<br/>    <br/>    - name: Set up Python<br/>      uses: actions/setup-python@v2<br/>      with:<br/>        python-version: 3.7<br/>    <br/>    - name: Install Python dependencies<br/>      run: |<br/>        python -m pip install --upgrade pip<br/>        pip install -r requirements.txt</span></pre><p id="3ea3" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">注意，<code class="fe mx my mz na b">run</code>键允许你在虚拟机的外壳中执行命令——这里是默认的Ubuntu外壳。</p><h1 id="ec62" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2.下载数据集</h1><p id="6dba" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">首先，作业从<code class="fe mx my mz na b">pipeline-example</code>桶下载最新的可用数据集。在实践中，管道将在提供的路径上获得最新版本的数据集。这允许您创建一个独立于<em class="mi">的</em>数据管道来加载和转换数据集，以便ML管道在下次运行时拾取。</p><pre class="ot ou ov ow gt ox na oy oz aw pa bi"><span id="3ce1" class="pb kn iq na b gy pc pd l pe pf">- name: Download the latest dataset<br/>      run: |<br/>        gsutil cp gs://pipeline-example/heart-disease/dataset.csv datasets/default.csv</span></pre><p id="01b6" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">你会看到这个步骤使用了<code class="fe mx my mz na b">gsutil</code>，谷歌的<a class="ae kl" href="https://cloud.google.com/storage/docs/gsutil" rel="noopener ugc nofollow" target="_blank">云存储命令行实用程序</a>。这让你可以从谷歌云复制文件。简单！</p><h1 id="c621" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3.训练和评估模型</h1><p id="590b" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">现在作业已经加载了最新的数据集，是时候运行“核心”训练任务了。在这种情况下，这与<a class="ae kl" href="https://mark.douthwaite.io/serverless-machine-learning/" rel="noopener ugc nofollow" target="_blank">之前的无服务器ML教程</a>中给出的示例相同。</p><pre class="ot ou ov ow gt ox na oy oz aw pa bi"><span id="5840" class="pb kn iq na b gy pc pd l pe pf">- name: Run training task<br/>      run: |<br/>        python steps/train.py --path=datasets/default.csv</span></pre><p id="4fed" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">另外，<code class="fe mx my mz na b">steps/train.py</code>脚本将以下元数据和指标写入<code class="fe mx my mz na b">artifacts/metrics.json</code>路径。正如您将看到的，这也会上传到Google Cloud，因此您可以查看模型性能(和训练持续时间)如何随时间变化。这可以派上用场！</p><pre class="ot ou ov ow gt ox na oy oz aw pa bi"><span id="f37b" class="pb kn iq na b gy pc pd l pe pf">metrics = dict(<br/>    elapsed = end - start,<br/>    acc = acc,<br/>    val_acc = val_acc,<br/>    roc_auc = roc_auc,<br/>    timestamp = datetime.now().strftime(TIMESTAMP_FMT)<br/>)</span></pre><p id="46f0" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">新训练的模型被写入<code class="fe mx my mz na b">artifacts/pipeline.joblib</code>。这也将上传到谷歌云存档。</p><h1 id="5723" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">4.上传模型和指标</h1><p id="97e5" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">下一步是将您的新模型和指标推送到Google云存储。您将看到管道上传了三个文件:</p><ul class=""><li id="6aa7" class="mo mp iq lm b ln mj lr mk lv mq lz mr md ms mh mt mu mv mw bi translated"><code class="fe mx my mz na b">latest.joblib</code> -模型的“最新”版本。这将是管道生产的最新“有效”模型。</li><li id="2362" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh mt mu mv mw bi translated"><code class="fe mx my mz na b">${{ env.GITHUB_RUN_ID }}.joblib</code> -上述模型的存档版本(由生产它的惟一GitHub运行ID标识)。</li><li id="9425" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh mt mu mv mw bi translated"><code class="fe mx my mz na b">metrics/${{ env.GITHUB_RUN_ID }}.json</code> -上述模型指标的存档版本(由产生它的唯一GitHub运行ID标识)。可以按创建日期对它们进行排序，以生成显示模型性能随时间变化的时间序列。</li></ul><pre class="ot ou ov ow gt ox na oy oz aw pa bi"><span id="4683" class="pb kn iq na b gy pc pd l pe pf">- name: Upload new model and associated metrics<br/>      run: |<br/>        gsutil cp artifacts/pipeline.joblib gs://pipeline-example/heart-disease/models/latest.joblib<br/>        gsutil cp artifacts/pipeline.joblib gs://pipeline-example/heart-disease/models/${{ env.GITHUB_RUN_ID }}.joblib<br/>        gsutil cp artifacts/metrics.json gs://pipeline-example/heart-disease/models/metrics/${{ env.GITHUB_RUN_ID }}.joblib</span></pre><p id="8f1a" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">现在你有了一个新的模型，一些指标，所有这些都整齐地存档在谷歌云存储中。</p><h1 id="401d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">5.将模型部署为云功能</h1><p id="7adf" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">最后，完成所有这些工作后，是时候重新部署您的最新模型了。</p><pre class="ot ou ov ow gt ox na oy oz aw pa bi"><span id="74d4" class="pb kn iq na b gy pc pd l pe pf">- name: Deploy model as Cloud Function<br/>      run: | <br/>        gcloud functions deploy heart-disease --entry-point=predict_handler --runtime=python37 --project=${{ secrets.GCP_PROJECT_ID }} --allow-unauthenticated --trigger-http</span></pre><p id="622a" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">这将触发您的模型的云功能与您的最新模型一起重新部署。如果你想了解传递给<code class="fe mx my mz na b">gcloud</code>的参数是做什么的，请确保<a class="ae kl" href="https://mark.douthwaite.io/serverless-machine-learning/" rel="noopener ugc nofollow" target="_blank">查看本系列的前一篇文章</a>。几分钟后，你的新型号将被投入使用。</p><h1 id="7efc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">收尾工作</h1><p id="e1c9" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">仅此而已。如果您的管道成功完成，您将能够为每个成功的步骤看到一个漂亮的绿色勾号列表。</p><figure class="ot ou ov ow gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ph"><img src="../Images/7f9b341ff09783321ba8053d8c046347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lWcMRCCXUY_9DTLj.png"/></div></div></figure><p id="5ddf" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">现在，您已经有了一个自动化的管道来加载新数据、重新训练模型、归档新模型及其指标，然后按照固定的时间表重新部署您的模型API。很酷，是吧？</p><h1 id="9b6c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">后续步骤</h1><p id="9a07" class="pw-post-body-paragraph lk ll iq lm b ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">这只是一个婴儿ML管道。你可以做很多事情让它变得更复杂。一些初步想法可能是:</p><ul class=""><li id="6f49" class="mo mp iq lm b ln mj lr mk lv mq lz mr md ms mh mt mu mv mw bi translated">创建一个云函数，当模型性能下降到给定值以下时，它会在上传模型指标时触发，以通知您(可能通过Slack或电子邮件)。</li><li id="998f" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh mt mu mv mw bi translated">如果评估结果比先前的模型(或者一些测试用例)更差，添加一个步骤来中止模型重新部署。</li><li id="9a9c" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh mt mu mv mw bi translated">添加自定义云函数触发器，以便在数据集更新时运行工作流(而不是在固定的基础上运行，这可能是不必要的)。</li><li id="5b8f" class="mo mp iq lm b ln nb lr nc lv nd lz ne md nf mh mt mu mv mw bi translated">添加一个StreamLit控制面板，以便随时查看模型和指标。</li></ul><p id="191b" class="pw-post-body-paragraph lk ll iq lm b ln mj lp lq lr mk lt lu lv ml lx ly lz mm mb mc md mn mf mg mh ij bi translated">如果你有任何问题，请随时联系我们！</p></div></div>    
</body>
</html>