<html>
<head>
<title>Three ways to use custom validation metrics in tf.keras / TF2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在tf.keras / TF2中使用自定义验证指标的三种方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/three-ways-to-use-custom-validation-metrics-in-tf-keras-tf2-bb9c40a3076?source=collection_archive---------17-----------------------#2020-09-28">https://towardsdatascience.com/three-ways-to-use-custom-validation-metrics-in-tf-keras-tf2-bb9c40a3076?source=collection_archive---------17-----------------------#2020-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e222" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在TensorFlow 2中使用自定义验证指标</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee83f7a55333b247e01a6591e05362f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ha2MKkkQdjiUbUSA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@valeon" rel="noopener ugc nofollow" target="_blank">米切尔·布茨</a>拍摄</p></figure><p id="4950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Keras提供了一系列指标来验证测试数据集，如准确性、MSE或AUC。然而，有时您需要一个定制的指标来验证您的模型。在这篇文章中，我将展示三种不同的方法来实现您的指标并在Keras中使用它。</p><p id="6695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然最初Keras中只包含少数指标，但现在已经有了很多不同的指标。对于TensorFlow 2捆绑的Keras版本，所有指标都可以在<a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/metrics" rel="noopener ugc nofollow" target="_blank"> tf.keras.metrics </a>中找到。</p><h2 id="17c4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用tensorflow插件</h2><p id="1e0d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Tensoflow插件库提供了一些额外的指标。在开始自己实现之前，最好检查一下你的度量标准是否可用。要使用tensorflow插件，只需通过pip安装即可:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8d3d" class="lv lw it mu b gy my mz l na nb">pip install tensorflow-addons</span></pre><p id="40b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有找到您的指标，我们现在可以看看这三个选项。函数、回调和度量对象。</p><h2 id="9963" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">简单的度量函数</h2><p id="fdb6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Keras中定义指标最简单的方法是简单地使用函数回调。该函数有两个参数。第一个参数是地面实况(y_true ),第二个参数是来自模型的预测(y_pred)。在运行验证时，这些参数是张量，所以我们必须使用Keras后端进行计算。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="274c" class="lv lw it mu b gy my mz l na nb">import tf.keras.backend as K<br/>def matthews_correlation(y_true, y_pred):<br/>    y_pred_pos = K.round(K.clip(y_pred, 0, 1))<br/>    y_pred_neg = 1 - y_pred_pos<br/><br/>    y_pos = K.round(K.clip(y_true, 0, 1))<br/>    y_neg = 1 - y_pos<br/><br/>    tp = K.sum(y_pos * y_pred_pos)<br/>    tn = K.sum(y_neg * y_pred_neg)<br/><br/>    fp = K.sum(y_neg * y_pred_pos)<br/>    fn = K.sum(y_pos * y_pred_neg)<br/><br/>    numerator = (tp * tn - fp * fn)<br/>    denominator = K.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn))<br/><br/>    return numerator / (denominator + K.epsilon())</span></pre><p id="72b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将此函数用于Keras模型:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8433" class="lv lw it mu b gy my mz l na nb">model.compile(optimizer='rmsprop',<br/>              loss='binary_crossentropy',<br/>              metrics=[matthews_correlation])</span></pre><p id="a59a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用fit()现在输出:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0b52" class="lv lw it mu b gy my mz l na nb">245063/245063 [==============================] - 63s 256us/step - matthews_correlation: 0.0032 - val_matthews_correlation: 0.0039</span><span id="afa6" class="lv lw it mu b gy nc mz l na nb">(Note that the name is the function name, while for validation data there is always the val_ prefix)</span></pre><h2 id="8e2e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用回调的间隔评估</h2><p id="4b86" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您想要每N个时期在一个单独的数据集上评估模型，您可以使用自定义回调。在这种情况下，使用来自<a class="ae ky" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>的AUC分数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a6a0" class="lv lw it mu b gy my mz l na nb">from sklearn.metrics import roc_auc_score<br/>from tf.keras.callbacks import Callback<br/><br/>class IntervalEvaluation(Callback):<br/>    def __init__(self, validation_data=(), interval=10):<br/>        super(Callback, self).__init__()<br/><br/>        self.interval = interval<br/>        self.X_val, self.y_val = validation_data<br/><br/>    def on_epoch_end(self, epoch, logs={}):<br/>        if epoch % self.interval == 0:<br/>            y_pred = self.model.predict_proba(self.X_val, verbose=0)<br/>            score = roc_auc_score(self.y_val, y_pred)<br/>            print("interval evaluation - epoch: {:d} - score: {:.6f}".format(epoch, score))</span></pre><p id="a2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了用这个评估设置训练模型，对象的实例作为<a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/Callback" rel="noopener ugc nofollow" target="_blank">回调</a>传递给Keras。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8902" class="lv lw it mu b gy my mz l na nb">ival = IntervalEvaluation(validation_data=(x_validate, y_validate), interval=10)<br/>model.fit(x_train, y_train,<br/>          batch_size=8196,<br/>          epochs=25,<br/>          validation_data=[x_test, y_test],   <br/>          class_weight=class_weight,<br/>          callbacks=[ival],<br/>          verbose=1 )</span></pre><p id="4b18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是这样的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3a22" class="lv lw it mu b gy my mz l na nb">interval evaluation - epoch: 0 - score: 0.545038<br/>interval evaluation - epoch: 10 - score: 0.724098<br/>interval evaluation - epoch: 20 - score: 0.731381</span></pre><h2 id="9654" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">扩展tf.keras.metrics.Metric</h2><p id="f483" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最后，可以扩展度量对象本身。(从<a class="ae ky" href="https://stackoverflow.com/questions/59305514/tensorflow-how-to-use-tf-keras-metrics-in-multiclass-classification" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>到Geeocode的积分)</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="895e" class="lv lw it mu b gy my mz l na nb">class CategoricalTruePositives(tf.keras.metrics.Metric):<br/>    def __init__(self, num_classes, batch_size,<br/>                 name="categorical_true_positives", **kwargs):<br/>        super(CategoricalTruePositives, self).__init__(name=name, **kwargs)<br/>        self.batch_size = batch_size<br/>        self.num_classes = num_classes    <br/>        self.cat_true_positives = self.add_weight(name="ctp", initializer="zeros")<br/>    def update_state(self, y_true, y_pred, sample_weight=None):     <br/>        y_true = K.argmax(y_true, axis=-1)<br/>        y_pred = K.argmax(y_pred, axis=-1)<br/>        y_true = K.flatten(y_true)<br/>        true_poss = K.sum(K.cast((K.equal(y_true, y_pred)), dtype=tf.float32))<br/>        self.cat_true_positives.assign_add(true_poss)<br/>    def result(self):<br/>        return self.cat_true_positives</span></pre><p id="e304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与第一个例子只有一个显著的不同。结果函数返回，update_state方法必须被覆盖(这是计算发生的地方)。它还需要一个额外的参数(sample_weight)。最后用re result方法返回结果张量。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="aa04" class="lv lw it mu b gy my mz l na nb">model.compile(optimizer='adam',<br/>              loss='binary_crossentropy',<br/>              metrics=[<!-- -->CategoricalTruePositives<!-- -->(num_classes, batch_size)])</span></pre><p id="e5ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了实现定制验证指标的三种不同方式。希望这有助于决定哪种方式适合您的用例，并且不要忘记检查您的度量是否已经在tf.keras.metrics中的大量预定义的度量中可用。</p><p id="da87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章最初发表于<a class="ae ky" href="http://digital-thinking.de/keras-three-ways-to-use-custom-validation-metrics-in-keras/" rel="noopener ugc nofollow" target="_blank">digital-thinking . de</a>(2018年12月19日)</p></div></div>    
</body>
</html>