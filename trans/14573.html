<html>
<head>
<title>12 Ways to Apply a Function to Each Row in Pandas DataFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据框中每行应用函数的12种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apply-function-to-pandas-dataframe-rows-76df74165ee4?source=collection_archive---------0-----------------------#2020-10-08">https://towardsdatascience.com/apply-function-to-pandas-dataframe-rows-76df74165ee4?source=collection_archive---------0-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b86eaef196eff9f5a0bf790ef988ee60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsfQIDGZrdGLsjA5vrafWA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://www.pexels.com/photo/person-holding-cup-of-coffees-on-table-832823/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae jg" href="https://www.pexels.com/@victorfreitas" rel="noopener ugc nofollow" target="_blank"> Victor Freitas </a></p></figure><h2 id="fa23" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">编程技巧</h2><div class=""/><div class=""><h2 id="3edb" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">如何有效地遍历Pandas数据帧中的行，并对每一行应用一个函数。</h2></div><p id="ba6c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<a class="ae jg" href="https://en.wikipedia.org/wiki/Data_wrangling" rel="noopener ugc nofollow" target="_blank">数据争论</a>期间，对<a class="ae jg" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>和<a class="ae jg" href="https://pandas.pydata.org/docs/reference/frame.html" rel="noopener ugc nofollow" target="_blank">数据帧</a>中的所有行应用函数是最常见的操作之一。熊猫DataFrame <code class="fe md me mf mg b"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank">apply</a></code>函数是做这件事最明显的选择。它将一个函数作为参数，并沿着数据帧的轴应用它。然而，它并不总是最好的选择。</p><p id="9dc9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，您将测量12个备选方案的性能。有了配套的代码实验室，你可以在你的浏览器中全部尝试。不需要在你的机器上安装任何东西。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="d3d7" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">问题</h1><p id="ea53" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">最近，我在为一个电子商务应用程序分析用户行为数据。根据用户进行文本和语音搜索的次数，我将每个用户分为四组:</p><ul class=""><li id="b822" class="nl nm jj lj b lk ll ln lo lq nn lu no ly np mc nq nr ns nt bi translated"><strong class="lj jt">没有搜索:</strong>根本没有搜索的用户</li><li id="d996" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated"><strong class="lj jt">仅文本:</strong>仅进行文本搜索的用户</li><li id="6b7c" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated"><strong class="lj jt">仅语音:</strong>仅进行语音搜索的用户</li><li id="7a2e" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated"><strong class="lj jt"> Both: </strong>同时进行文本和语音搜索的用户</li></ul><p id="3874" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个巨大的数据集，根据选择的时间片，有10万到100万用户。用Pandas <code class="fe md me mf mg b">apply</code>函数计算它非常慢，所以我评估了其他选择。这篇文章是从中提炼出来的经验教训。</p><p id="383b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我不能分享那个数据集。所以我挑选了另一个类似的问题来展示解决方案:艾森豪威尔方法。</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/58ddfb79a7ea87cd633f9ad22ee5f72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*_44gqprR6NYVRn38zgo9vA.jpeg"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">艾森豪威尔方法:根据重要性和紧急程度将任务分成4个部分。</p></figure><p id="b9b2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">根据任务的重要性和紧迫性，艾森豪威尔方法将其分配到4个箱中的一个。每个框都有一个关联的操作:</p><ul class=""><li id="f462" class="nl nm jj lj b lk ll ln lo lq nn lu no ly np mc nq nr ns nt bi translated">重要而紧急的事情:马上做</li><li id="987a" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">重要但不紧急:<strong class="lj jt">安排</strong>留待以后</li><li id="3b34" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">不重要但紧急:<strong class="lj jt">委派</strong>给别人</li><li id="3951" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">既不重要也不紧急:<strong class="lj jt">删除</strong>浪费时间。</li></ul><p id="82b8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将使用下图所示的布尔矩阵。重要性和紧急性布尔值为每个动作生成二进制整数值:DO(3)，SCHEDULE(2)，DELEGATE(1)，DELETE(0)。</p><p id="2330" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将<strong class="lj jt">分析</strong>将任务映射到某个操作的<strong class="lj jt">性能</strong>。我们将测量12个选项中哪一个花费的时间最少。我们将为<strong class="lj jt">多达一百万个任务</strong>绘制性能图。</p><p id="0ade" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<a class="ae jg" href="https://colab.research.google.com/github/scgupta/ml4devs-notebooks/blob/master/ml/pandas/pandas_apply_fn_on_dataframe.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt"> Google Colab </strong> </a>或<a class="ae jg" href="https://www.kaggle.com/scgupta/efficient-alternatives-to-pandas-dataframe-apply" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt"> Kaggle </strong> </a>打开<strong class="lj jt">伴侣笔记本</strong>正是时候。如果您想查看运行中的代码，可以在阅读时执行代码实验室中的单元格。继续执行设置部分中的所有单元格。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="df3d" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">测试数据</h1><p id="2757" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">Faker是一个方便的生成数据的库。在代码实验室中，它用于生成包含一百万个任务的数据帧。每个任务都是数据帧中的一行。它由任务名称(<code class="fe md me mf mg b">str</code>)、截止日期(<code class="fe md me mf mg b">datetime.date</code>)和优先级(<code class="fe md me mf mg b">str</code>)组成。优先级可以是以下三个值之一:低、中、高。</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6b5b45c54c8fb20320b14743e56b63dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*EshpxVJlCG8Jb0gBKc4lvQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">生成的数据帧中的前5个任务</p></figure><h2 id="568a" class="og mp jj bd mq oh oi dn mu oj ok dp my lq ol om na lu on oo nc ly op oq ne jp bi translated">优化数据帧存储</h2><p id="3ef9" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">我们将最小化存储大小，以消除其对任何替代方案的影响。大约200万行的数据帧占用48MB:</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="f5b9" class="og mp jj mg b gy ov ow l ox oy"><strong class="mg jt">&gt;&gt;&gt;</strong> test_data_set.info()</span><span id="8511" class="og mp jj mg b gy oz ow l ox oy">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 2097153 entries, 0 to 2097152<br/>Data columns (total 3 columns):<br/> #   Column     Dtype <br/>---  ------     ----- <br/> 0   task_name  object<br/> 1   due_date   object<br/> 2   priority   object<br/>dtypes: object(3)<br/>memory usage: 48.0+ MB</span></pre><p id="ed75" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">代替<code class="fe md me mf mg b">str</code>，优先级可以存储为熊猫<code class="fe md me mf mg b">categorical</code>类型:</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="a007" class="og mp jj mg b gy ov ow l ox oy">priority_dtype = pd.api.types.CategoricalDtype(<br/>  categories=['LOW', 'MEDIUM', 'HIGH'],<br/>  ordered=True<br/>)</span><span id="112a" class="og mp jj mg b gy oz ow l ox oy">test_data_set['priority'] = test_data_set['priority'].astype(priority_dtype)</span></pre><p id="b878" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在让我们来看看数据帧的大小:</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="45cd" class="og mp jj mg b gy ov ow l ox oy"><strong class="mg jt">&gt;&gt;&gt;</strong> test_data_set.info()</span><span id="8683" class="og mp jj mg b gy oz ow l ox oy">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 2097153 entries, 0 to 2097152<br/>Data columns (total 3 columns):<br/> #   Column     Dtype   <br/>---  ------     -----   <br/> 0   task_name  object  <br/> 1   due_date   object  <br/> 2   priority   category<br/>dtypes: category(1), object(2)<br/>memory usage: 34.0+MB</span></pre><p id="155b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">大小减少到34MB。</p><h2 id="995d" class="og mp jj bd mq oh oi dn mu oj ok dp my lq ol om na lu on oo nc ly op oq ne jp bi translated">艾森豪威尔行动函数</h2><p id="dfea" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">给定重要性和紧急程度，<code class="fe md me mf mg b">eisenhower_action</code>计算0到3之间的整数值。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="bd8f" class="og mp jj mg b gy ov ow l ox oy">def eisenhower_action(is_important: bool, is_urgent: bool) -&gt; int:<br/>  return 2 * is_important + is_urgent</span></pre><p id="909a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本练习中，我们将假设<strong class="lj jt">优先级高的任务</strong>是<strong class="lj jt">重要的任务</strong>。如果<strong class="lj jt">截止日期</strong>在<strong class="lj jt">接下来的两天</strong>内，那么任务就是<strong class="lj jt">紧急</strong>。</p><p id="3533" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过使用<code class="fe md me mf mg b">due_date</code>和<code class="fe md me mf mg b">priority</code>列计算任务(即数据帧中的一行)的艾森豪威尔行动:</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="6bca" class="og mp jj mg b gy ov ow l ox oy"><strong class="mg jt">&gt;&gt;&gt;</strong> cutoff_date = datetime.date.today() + datetime.timedelta(days=2)</span><span id="5b92" class="og mp jj mg b gy oz ow l ox oy"><strong class="mg jt">&gt;&gt;&gt;</strong> eisenhower_action(<br/>  test_data_set.loc[0].priority == 'HIGH',<br/>  test_data_set.loc[0].due_date &lt;= cutoff_date<br/>)</span><span id="be58" class="og mp jj mg b gy oz ow l ox oy">2</span></pre><p id="1ab7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">整数2表示需要的动作是调度。</p><p id="b158" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文的其余部分，我们将评估将<code class="fe md me mf mg b">eisenhower_action</code>函数应用于数据帧行的12种备选方案。首先，我们将测量100k行样本的时间。然后，我们将测量和绘制多达一百万行的时间。</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/fb38afcca4d7b03f2ec8e5ce1f93c4f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQ6Z3Yqm84fyiSME_2P8Bw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Pandas DataFrame:对每一行应用一个函数来计算一个新列</p></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="a8cd" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法一。循环遍历数据帧的所有行</h1><p id="8c2f" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">在传统的Python循环中处理每一行的最简单方法。这显然是最糟糕的方法，任何头脑正常的人都不会这么做。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="0f90" class="og mp jj mg b gy ov ow l ox oy">def loop_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)</span><span id="b1a8" class="og mp jj mg b gy oz ow l ox oy">  result = []<br/>  for i in range(len(df)):<br/>    row = df.iloc[i]<br/>    result.append(<br/>      eisenhower_action(<br/>        row.priority == 'HIGH', row.due_date &lt;= cutoff_date)<br/>    )</span><span id="7bbd" class="og mp jj mg b gy oz ow l ox oy">  return pd.Series(result)</span></pre><p id="5f0e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不出所料，这花费了惊人的时间:56.6秒。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="ba98" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_loop'] = loop_impl(data_sample)</span><span id="5ffd" class="og mp jj mg b gy oz ow l ox oy">1 loop, best of 5: 56.6 s per loop</span></pre><p id="1053" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它建立了最坏情况下的性能上限。由于其成本是线性的，即O(n ),因此它为比较其他替代方案提供了一个很好的基线。</p><h2 id="9837" class="og mp jj bd mq oh oi dn mu oj ok dp my lq ol om na lu on oo nc ly op oq ne jp bi translated">线级剖析</h2><p id="40af" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">让我们使用<a class="ae jg" href="https://github.com/pyutils/line_profiler" rel="noopener ugc nofollow" target="_blank"> line_profiler </a>来看看是什么花费了这么长时间，但是对于一个100行的小样本:</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="07f5" class="og mp jj mg b gy ov ow l ox oy">%lprun -f loop_impl  loop_impl(test_data_sample(100))</span></pre><p id="11c4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其输出如下图所示:</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/eb3351243008b83bb7fd05dc13bb46e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxs1duzzGjBGuJ7yWpm5Jg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">用于在Python循环中处理100行数据帧的行级探查器的输出。</p></figure><p id="ed0a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从数据帧中提取一行(第6行)需要90%的时间。这是可以理解的，因为Pandas DataFrame的存储是<a class="ae jg" href="https://en.wikipedia.org/wiki/Row-_and_column-major_order" rel="noopener ugc nofollow" target="_blank"><strong class="lj jt"/></a>【column-major】:一列中的连续元素按顺序存储在内存中。因此，将一行中的元素放在一起是非常昂贵的。</p><p id="e196" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">即使我们从100k行的56.6秒中去掉90%的成本，也需要5.66秒。这仍然很多。</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/d2247bf0e68e41e443c89ccb976b9fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvE68kH5EX-UZcdJkqnYKA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">行为主和列为主的数据存储布局。Pandas Dataframe使用以列为主的存储，因此获取一行是一项开销很大的操作。图片由作者根据<a class="ae jg" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener ugc nofollow" target="_blank">Creative Commons BY-NC-ND 4.0 International</a>许可发布。</p></figure><h1 id="3e0f" class="mo mp jj bd mq mr pc mt mu mv pd mx my ky pe kz na lb pf lc nc le pg lf ne nf bi translated">方法二。用<code class="fe md me mf mg b">iterrows</code>函数遍历行</h1><p id="8bb4" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">让我们试试Pandas <code class="fe md me mf mg b"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html" rel="noopener ugc nofollow" target="_blank">iterrows</a></code>函数，而不是在Python循环中处理每一行。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="41f2" class="og mp jj mg b gy ov ow l ox oy">def iterrows_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)</span><span id="e7f3" class="og mp jj mg b gy oz ow l ox oy">  return pd.Series(<br/>    eisenhower_action(<br/>      row.priority == 'HIGH', row.due_date &lt;= cutoff_date)<br/>    for index, row in df.iterrows()<br/>  )</span></pre><p id="00a4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">大约需要9.04秒。循环所用时间的四分之一:</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="2eb4" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_iterrow'] = iterrows_impl(data_sample)</span><span id="1c13" class="og mp jj mg b gy oz ow l ox oy">1 loop, best of 5: 9.04 s per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="23da" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法三。用<code class="fe md me mf mg b">itertuples</code>函数遍历行</h1><p id="c444" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">Pandas有另一种方法，<code class="fe md me mf mg b"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html" rel="noopener ugc nofollow" target="_blank">itertuples</a></code>，它将行作为元组来处理。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="0ff5" class="og mp jj mg b gy ov ow l ox oy">def itertuples_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)</span><span id="0430" class="og mp jj mg b gy oz ow l ox oy">  return pd.Series(<br/>    eisenhower_action(<br/>      row.priority == 'HIGH', row.due_date &lt;= cutoff_date)<br/>    for row in df.itertuples()<br/>  )</span></pre><p id="868a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它的表现令人惊讶，只用了211毫秒。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="7c0f" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_itertuples'] = itertuples_impl(data_sample)</span><span id="dfd6" class="og mp jj mg b gy oz ow l ox oy">1 loops, best of 5: 211 ms per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="bded" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法四。熊猫<code class="fe md me mf mg b">apply</code>作用于每一排</h1><p id="26a0" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">Pandas DataFrame <code class="fe md me mf mg b"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank">apply</a></code>功能相当多才多艺，是热门选择。要让它处理这些行，您必须传递<code class="fe md me mf mg b">axis=1</code>参数。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="8005" class="og mp jj mg b gy ov ow l ox oy">def apply_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  return df.apply(<br/>      lambda row:<br/>        eisenhower_action(<br/>          row.priority == 'HIGH', row.due_date &lt;= cutoff_date),<br/>      axis=1<br/>  )</span></pre><p id="2261" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这也给了我一个惊喜。用了1.85秒。比<code class="fe md me mf mg b">itertuples</code>差10倍！</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="0b99" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_impl'] = apply_impl(data_sample)</span><span id="1351" class="og mp jj mg b gy oz ow l ox oy">1 loop, best of 5: 1.85 s per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="7099" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法五。Python列表理解</h1><p id="864b" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">DataFrame中的列是一个系列，可用作<a class="ae jg" href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noopener ugc nofollow" target="_blank">列表理解</a>表达式中的列表:</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="5ad0" class="og mp jj mg b gy ov ow l ox oy">[ foo(x) for x in df['x'] ]</span></pre><p id="7d91" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果需要多个列，那么可以用<code class="fe md me mf mg b">zip</code>来做一个元组列表。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="6306" class="og mp jj mg b gy ov ow l ox oy">def list_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  return pd.Series([<br/>    eisenhower_action(priority == 'HIGH', due_date &lt;= cutoff_date)<br/>    for (priority, due_date) in zip(df['priority'], df['due_date'])<br/>  ])</span></pre><p id="81a2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这也抛出了一个惊喜。只用了78.4毫秒，甚至比<code class="fe md me mf mg b">itertuples</code>还要好！</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="4e40" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_list'] = list_impl(data_sample)</span><span id="3d17" class="og mp jj mg b gy oz ow l ox oy">10 loops, best of 5: 78.4 ms per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="0e41" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法六。Python地图函数</h1><p id="c9da" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">Python的<code class="fe md me mf mg b"><a class="ae jg" href="https://docs.python.org/3/library/functions.html#map" rel="noopener ugc nofollow" target="_blank">map</a></code>函数接受函数和可迭代的参数，并产生结果。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="990e" class="og mp jj mg b gy ov ow l ox oy"><strong class="mg jt">def</strong> map_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  <strong class="mg jt">return</strong> pd.Series(<br/>    map(eisenhower_action,<br/>      df['priority'] == 'HIGH',<br/>      df['due_date'] &lt;= cutoff_date)<br/>  )</span></pre><p id="9d0a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这比列表理解稍微好一点。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="eccf" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_map'] = map_impl(data_sample)</span><span id="cb11" class="og mp jj mg b gy oz ow l ox oy">10 loops, best of 5: 71.5 ms per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="a60b" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法七。…向量化…</h1><p id="5f02" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">熊猫的真正力量体现在矢量化上。但是它需要将函数解包为向量表达式。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="9098" class="og mp jj mg b gy ov ow l ox oy">def vec_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  return (<br/>    2*(df['priority'] == 'HIGH') + (df['due_date'] &lt;= cutoff_date))</span></pre><p id="7a87" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它提供了最好的性能:只有20毫秒。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="8145" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_vec'] = vec_impl(data_sample)</span><span id="b81d" class="og mp jj mg b gy oz ow l ox oy">10 loops, best of 5: 20 ms per loop</span></pre><p id="ce9b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">根据函数的复杂程度，向量化可能需要很大的努力。有时候，甚至可能不可行。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="219d" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法八。NumPy <code class="fe md me mf mg b">vectorize</code>功能</h1><p id="1a68" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">Numpy为通过向量化从Python迁移到NumPy提供了替代方案<a class="ae jg" href="https://www.labri.fr/perso/nrougier/from-python-to-numpy/" rel="noopener ugc nofollow" target="_blank">。例如，它有一个<code class="fe md me mf mg b">vectorize()</code>函数，可以向量化任何标量函数来接受和返回NumPy数组。</a></p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="4321" class="og mp jj mg b gy ov ow l ox oy">def np_vec_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  return np.vectorize(eisenhower_action)(<br/>    df['priority'] == 'HIGH',<br/>    df['due_date'] &lt;= cutoff_date<br/>  )</span></pre><p id="ad84" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">毫不奇怪，它的性能仅次于熊猫矢量化:35.7毫秒。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="db29" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_np_vec'] = np_vec_impl(data_sample)</span><span id="7e44" class="og mp jj mg b gy oz ow l ox oy">10 loops, best of 5: 35.7 ms per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="5659" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法九。Numba装饰公司</h1><p id="9b83" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">到目前为止，只使用了熊猫和NumPy包。但是如果你愿意接受额外的包依赖，还有更多选择。</p><p id="2eaa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae jg" href="https://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Numba </a>常用于加速应用数学函数。它有各种用于JIT编译和矢量化的装饰器。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="01ff" class="og mp jj mg b gy ov ow l ox oy">import numba</span><span id="41d5" class="og mp jj mg b gy oz ow l ox oy"><a class="ae jg" href="http://twitter.com/numba" rel="noopener ugc nofollow" target="_blank">@numba</a>.vectorize<br/>def eisenhower_action(is_important: bool, is_urgent: bool) -&gt; int:<br/>  return 2 * is_important + is_urgent</span><span id="8e1f" class="og mp jj mg b gy oz ow l ox oy">def numba_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  return eisenhower_action(<br/>    (df['priority'] == 'HIGH').to_numpy(),<br/>    (df['due_date'] &lt;= cutoff_date).to_numpy()<br/>  )</span></pre><p id="875a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它的<code class="fe md me mf mg b">vectorize</code>装饰器类似于NumPy <code class="fe md me mf mg b">vectorize</code>函数，但是提供了更好的性能:18.9毫秒(类似于熊猫矢量化)。但是它也会给出缓存警告。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="fc59" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_numba'] = numba_impl(data_sample)</span><span id="c475" class="og mp jj mg b gy oz ow l ox oy">The slowest run took 11.66 times longer than the fastest. This could mean that an intermediate result is being cached.<br/>1 loop, best of 5: 18.9 ms per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="e54c" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法10。使用<code class="fe md me mf mg b">pandarallel</code>进行多重处理</h1><p id="f94b" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated"><code class="fe md me mf mg b">pandarallel</code>包使用多个CPU，并将工作分成多个线程。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="5344" class="og mp jj mg b gy ov ow l ox oy">from pandarallel import pandarallel</span><span id="93ea" class="og mp jj mg b gy oz ow l ox oy">pandarallel.initialize()</span><span id="71f7" class="og mp jj mg b gy oz ow l ox oy">def pandarallel_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  return df.parallel_apply(<br/>    lambda row: eisenhower_action(<br/>      row.priority == 'HIGH', row.due_date &lt;= cutoff_date),<br/>    axis=1<br/>  )</span></pre><p id="c252" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在2个CPU的机器上，用了2.27秒。对于100k条记录和2个CPU，拆分和簿记开销似乎没有回报。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="ba12" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_pandarallel'] = pandarallel_impl(data_sample)</span><span id="6e9c" class="og mp jj mg b gy oz ow l ox oy">1 loop, best of 5: 2.27 s per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="6706" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法11。使用Dask并行化</h1><p id="c14e" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">Dask 是一个并行计算库，支持扩展NumPy、Pandas、Scikit-learn和许多其他Python库。它为在多节点集群上处理大量数据提供了高效的基础设施。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="a199" class="og mp jj mg b gy ov ow l ox oy">import dask.dataframe as dd</span><span id="9f88" class="og mp jj mg b gy oz ow l ox oy">def dask_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  return dd.from_pandas(df, npartitions=CPU_COUNT).apply(<br/>    lambda row: eisenhower_action(<br/>      row.priority == 'HIGH', row.due_date &lt;= cutoff_date),<br/>    axis=1,<br/>    meta=(int)<br/>  ).compute()</span></pre><p id="bf6c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在2个CPU的机器上，用了2.13秒。像<code class="fe md me mf mg b">pandarallel</code>一样，只有在许多机器上处理大量数据时，收益才有意义。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="05e2" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_dask'] = dask_impl(data_sample)</span><span id="abce" class="og mp jj mg b gy oz ow l ox oy">1 loop, best of 5: 2.13 s per loop</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="7743" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">方法12。利用Swifter实现机会并行化</h1><p id="b745" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated"><a class="ae jg" href="https://github.com/jmcarpenter2/swifter" rel="noopener ugc nofollow" target="_blank"> Swifter </a>自动决定哪个更快:使用Dask并行处理还是简单的Pandas应用。使用起来非常简单:只需一个词就能说明熊猫的功能:<code class="fe md me mf mg b">df.<strong class="lj jt">swifter</strong>.apply</code>。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="b9cc" class="og mp jj mg b gy ov ow l ox oy">import swifter</span><span id="388a" class="og mp jj mg b gy oz ow l ox oy">def swifter_impl(df):<br/>  cutoff_date = datetime.date.today() + datetime.timedelta(days=2)<br/>  return df.<strong class="mg jt">swifter</strong>.apply(<br/>    lambda row: eisenhower_action(<br/>      row.priority == 'HIGH', row.due_date &lt;= cutoff_date),<br/>    axis=1<br/>  )</span></pre><p id="a81b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它在这个用例中的性能预计非常接近熊猫矢量化。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="68c6" class="og mp jj mg b gy ov ow l ox oy">%timeit data_sample['action_swifter'] = swifter_impl(data_sample)</span><span id="c09c" class="og mp jj mg b gy oz ow l ox oy">10 loops, best of 5: 22.9 ms per loop+</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="fe4b" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">Pandas数据帧行的迭代性能比较</h1><p id="dc3b" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">绘图有助于理解备选方案相对于输入大小的相对性能。Perfplot 是一个方便的工具。它需要一个设置来生成给定大小的输入和一个要比较的实现列表。</p><pre class="oa ob oc od gt or mg os ot aw ou bi"><span id="2933" class="og mp jj mg b gy ov ow l ox oy">kernels = [<br/>  loop_impl,<br/>  iterrows_impl,<br/>  itertuples_impl,<br/>  apply_impl,<br/>  list_impl,<br/>  vec_impl,<br/>  np_vec_impl,<br/>  numba_impl,<br/>  pandarallel_impl,<br/>  dask_impl,<br/>  swifter_impl<br/>]</span><span id="9d27" class="og mp jj mg b gy oz ow l ox oy">labels = [str(k.__name__)[:-5] for k in kernels]</span><span id="1c76" class="og mp jj mg b gy oz ow l ox oy">perfplot.show(<br/>  setup=lambda n: test_data_sample(n),<br/>  kernels=kernels,<br/>  labels=labels,<br/>  n_range=[2**k for k in range(K_MAX)],<br/>  xlabel='N',<br/>  logx=True,<br/>  logy=True,<br/>  #equality_check=None<br/>)</span></pre><p id="bd41" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它生成如下所示的图。</p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/2ec71224dca2e89b9f474c9931f1335a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdvdk0gxLOPtFr0Dlb7h-g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">熊猫数据框应用功能的替代方案。左图:对熊猫数据帧的100，000行应用函数所用的时间。右图:在Pandas数据框架中，以对数比例绘制多达一百万行。图片由作者根据<a class="ae jg" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener ugc nofollow" target="_blank">Creative Commons BY-NC-ND 4.0 International</a>许可发布。</p></figure><p id="0c13" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以下是对该地块的一些观察:</p><ul class=""><li id="2da8" class="nl nm jj lj b lk ll ln lo lq nn lu no ly np mc nq nr ns nt bi translated">对于这个用例，渐近性能顺序稳定在数据帧中大约10k行。</li><li id="11c3" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">由于图中的所有线条都变得平行，性能差异在双对数标度图中可能不明显。</li><li id="b099" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated"><code class="fe md me mf mg b">itertuples</code>和<code class="fe md me mf mg b">apply</code>一样简单易用，但性能却提升了10倍。</li><li id="4a54" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">列表理解比<code class="fe md me mf mg b">itertuples</code>好2.5倍，尽管对于一个复杂的函数来说写起来有些冗长。</li><li id="367c" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">NumPy <code class="fe md me mf mg b">vectorize</code>比List理解力强2倍，使用起来和<code class="fe md me mf mg b">itertuples</code>和<code class="fe md me mf mg b">apply</code>函数一样简单。</li><li id="2139" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">Pandas矢量化比NumPy <code class="fe md me mf mg b">vectorize</code>要好大约2倍。</li><li id="4c41" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc nq nr ns nt bi translated">只有在许多机器上处理大量数据时，并行处理的开销才有回报。</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="15eb" class="mo mp jj bd mq mr ms mt mu mv mw mx my ky mz kz na lb nb lc nc le nd lf ne nf bi translated">高效迭代Pandas数据帧行的建议</h1><p id="7e58" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ni ls lt lu nj lw lx ly nk ma mb mc im bi translated">对所有熊猫行独立执行操作是一种常见的需求。以下是我的建议:</p><ol class=""><li id="2bf2" class="nl nm jj lj b lk ll ln lo lq nn lu no ly np mc ph nr ns nt bi translated"><strong class="lj jt">向量化数据帧表达式:</strong>尽可能这样做。</li><li id="6742" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc ph nr ns nt bi translated"><strong class="lj jt"> NumPy </strong> <code class="fe md me mf mg b"><strong class="lj jt">vectorize</strong></code> <strong class="lj jt"> : </strong>它的API不是很复杂。它不需要额外的软件包。它提供了几乎最好的性能。如果矢量化数据框架并非不可行，请选择此项。</li><li id="61f5" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc ph nr ns nt bi translated"><strong class="lj jt">列表理解:</strong>当只需要2-3个数据帧列，并且数据帧向量化和NumPy向量化由于某种原因不可行时，选择此选项。</li><li id="820e" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc ph nr ns nt bi translated"><strong class="lj jt">熊猫</strong> <code class="fe md me mf mg b"><strong class="lj jt">itertuples</strong></code> <strong class="lj jt">功能:</strong>其API类似<code class="fe md me mf mg b">apply</code>功能，但性能比<code class="fe md me mf mg b">apply</code>高10倍。这是最简单、可读性最强的选择。它提供了合理的性能。如果前面三个都不行，就这么做。</li><li id="7bd5" class="nl nm jj lj b lk nu ln nv lq nw lu nx ly ny mc ph nr ns nt bi translated"><strong class="lj jt"> Numba或Swift: </strong>使用它来开发并行化而不增加代码复杂性。</li></ol><p id="bd51" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">了解各种替代方案的成本对于做出明智的选择至关重要。使用<code class="fe md me mf mg b">timeit</code>、<code class="fe md me mf mg b">line_profiler</code>和<code class="fe md me mf mg b">perfplot</code>来测量这些备选方案的性能。平衡性能和易用性，为您的使用案例确定最佳替代方案。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="a895" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你喜欢这个，请:</p><div class="oa ob oc od gt ab cb"><figure class="pi iv pj pk pl pm pn paragraph-image"><a href="https://ml4devs.substack.com/subscribe"><img src="../Images/c0b3ff1cd100b0d083b64ab62d80415e.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*5WJhoEqI8dgVeCQdXcISzA.png"/></a></figure><figure class="pi iv pj pk pl pm pn paragraph-image"><a href="https://twitter.com/intent/follow?user_id=29633907"><img src="../Images/bac2c0b02e577402bc596ec11cb947ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*23xdhWOYiyv7oyEyiHBFyA.png"/></a></figure><figure class="pi iv pj pk pl pm pn paragraph-image"><a href="http://www.linkedin.com/comm/mynetwork/discovery-see-all?usecase=PEOPLE_FOLLOWS&amp;followMember=scgupta"><img src="../Images/e264d4e0ccfd62b7b649f4ddbf47cc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*_37VjowTkhzWFS1v6qpTSA.png"/></a></figure></div><div class="ab cb"><figure class="pi iv po pk pl pm pn paragraph-image"><a href="https://twitter.com/intent/follow?user_id=29633907"><img src="../Images/bac2c0b02e577402bc596ec11cb947ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*23xdhWOYiyv7oyEyiHBFyA.png"/></a></figure><figure class="pi iv po pk pl pm pn paragraph-image"><a href="https://www.linkedin.com/in/scgupta/"><img src="../Images/e264d4e0ccfd62b7b649f4ddbf47cc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*_37VjowTkhzWFS1v6qpTSA.png"/></a></figure></div><p id="3464" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">与此信息图分享:</strong></p><figure class="oa ob oc od gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pp"><img src="../Images/bad661a1cb0a1ff7f4103eba6518efa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsvrn-NPyDO18HkN_3F6fw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">熊猫DataFrame apply()函数的5个简单快速的替代方法。不需要脂肪库。图片由作者提供，并在<a class="ae jg" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener ugc nofollow" target="_blank">Creative Commons BY-NC-ND 4.0 International</a>许可下发布。</p></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="39da" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="pq">原载于</em><a class="ae jg" href="https://www.ml4devs.com/articles/pandas-dataframe-apply-function-iterate-over-rows/" rel="noopener ugc nofollow" target="_blank"><em class="pq">ML4Devs.com</em></a><em class="pq">。</em></p></div></div>    
</body>
</html>