<html>
<head>
<title>pydantic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pydantic</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pydantic-688e897cfd3a?source=collection_archive---------5-----------------------#2020-11-01">https://towardsdatascience.com/pydantic-688e897cfd3a?source=collection_archive---------5-----------------------#2020-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c64" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果你篡改数据，你必须知道这个库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/75b2cfa1102ea1fbe9c286496927c76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdqgwkO9B5A29LP9Vb9rHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d819" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">拥有复杂的嵌套数据结构很难。在Python中存储这种数据的传统方法是嵌套字典。虽然<a class="ae lu" href="https://www.youtube.com/watch?v=npw4s1QTmPg" rel="noopener ugc nofollow" target="_blank"> Python字典很神奇</a>，但通常会出现两个问题:(1)作为开发人员，我如何知道传递的字典中应该有哪种数据;( 2)我如何防止输入错误？</p><p id="2cfc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用类，您的编辑器或mypy可以防止属性名中的拼写错误。对于字典，任何有效的字符串都可以是一个键。</p><p id="ed0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决这两个问题的方法是使用一个库:<a class="ae lu" href="https://pypi.org/project/pydantic/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> pydantic </strong> </a>。它是一个验证和解析库，将数据映射到Python类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bfb1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="61c1" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">安装pydantic via</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="299e" class="ne md it na b gy nf ng l nh ni">pip install pydantic</span></pre><p id="29ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于本文，我假设您的数据是<code class="fe nj nk nl na b"><a class="ae lu" href="https://gist.github.com/MartinThoma/517d20998501afc4fff72be032782d41" rel="noopener ugc nofollow" target="_blank">people.json</a></code>中的一个人的网络。他们有一个ID，一个名字，一个由他们的ID给出的朋友列表，一个生日，以及他们银行账户上的金额。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ee0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们想通过这个例子来计算每个人比他们的中位朋友多拥有多少财富。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3f03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们想要解决的问题是:</p><ul class=""><li id="73cf" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><strong class="la iu">丑陋无</strong>:把<code class="fe nj nk nl na b">None</code>作为朋友的值是相当丑陋的。在某些情况下，<code class="fe nj nk nl na b">None</code>不同于空列表。在这种情况下，我们就假设它的意思是一样的。用其他东西替换缺失数据被称为<a class="ae lu" href="https://en.wikipedia.org/wiki/Imputation_(statistics)" rel="noopener ugc nofollow" target="_blank">插补</a>，有几种技术。</li><li id="739b" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la iu">丑Any </strong>:类型注释有<code class="fe nj nk nl na b">Dict[str, Any]</code>，因为它被认为太复杂甚至不可能知道代表一个人的字典也能映射哪些值。</li><li id="96b4" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la iu">难看的索引</strong>:只是语法，但是<code class="fe nj nk nl na b">["id"]</code>比<code class="fe nj nk nl na b">.id</code>长50%。这就是<a class="ae lu" href="https://pypi.org/project/bunch/" rel="noopener ugc nofollow" target="_blank">帮</a> / <a class="ae lu" href="https://pypi.org/project/munch/" rel="noopener ugc nofollow" target="_blank">蒙克</a>存在的原因。</li><li id="0811" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la iu">错别字</strong>:如果你在字典的任何一个字符串索引中出现了错别字，没有静态代码分析工具可以帮你检测出来。没有自动完成将正常工作。</li><li id="fbb7" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la iu">后期错误</strong>:好的软件将职责模块化。一个模块负责业务逻辑，一个模块负责输入/输出。当我写“模块”时，我指的是一个代码单元——它可以是一个Python模块、一个类、一个函数、一个方法。简单地用一个函数来处理这些不同类型的复杂性是不好的。获得正确的业务逻辑本质上不同于确保您的输入/输出看起来像预期的那样。一个是关于定义和验证适当的接口，另一个是关于理解领域。</li><li id="5f45" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la iu">文档</strong>:新开发人员必须定期阅读更大应用程序的代码。通常，没有时间让对应用程序了如指掌的人详细解释每一个部分。大多数时候，甚至没有一个人什么都知道——即使项目是由一个开发人员完成的。我总是忘记部分代码。因此记录是至关重要的。在Python中，记录预期的参数类型及其返回值至关重要。有<code class="fe nj nk nl na b">Dict[str, Any]</code>总比没有好，但比<code class="fe nj nk nl na b">Person</code>差得多。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0750" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建一个pydantic模型</h1><p id="599e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们为一个人的ID创建了一个新的类型，仅仅是因为PersonId比T2更有意义。然后我们子类化<code class="fe nj nk nl na b"><a class="ae lu" href="https://pydantic-docs.helpmanual.io/usage/models/#basic-model-usage" rel="noopener ugc nofollow" target="_blank">pydantic.BaseModel</a></code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a17f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将其用于输入解析</h1><p id="b3bf" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">接下来，我们使用<code class="fe nj nk nl na b"><a class="ae lu" href="https://pydantic-docs.helpmanual.io/usage/models/#parsing-data-into-a-specified-type" rel="noopener ugc nofollow" target="_blank">parse_file_as</a></code>来读取JSON文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="97e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，<a class="ae lu" href="https://pydantic-docs.helpmanual.io/usage/types/#datetime-types" rel="noopener ugc nofollow" target="_blank"> datetime </a>和Decimal是自动解析的——您仍然应该经常查看它是如何完成的。尽早进行数据验证是有好处的，这样错误也会在已知的地方尽早发生。这意味着pydantic轻推你到一个好的设计。我喜欢它😍</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c5e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">约束类型</h1><p id="3a8c" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><a class="ae lu" href="https://pydantic-docs.helpmanual.io/usage/types/#constrained-types" rel="noopener ugc nofollow" target="_blank">约束类型</a>是某个取值范围内的整数/浮点数或与正则表达式匹配的字符串😃</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="98c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缺少数据:使用默认值</h1><p id="11c5" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果您的JSON可能缺少一些您想要的属性，那么您需要使用默认值。典型的默认值是<code class="fe nj nk nl na b">None</code>，这意味着您需要将类型更改为<code class="fe nj nk nl na b">Optional[what it was before]</code>。这通常很难看，因为您需要在代码的后面检查<code class="fe nj nk nl na b">None</code>。</p><p id="aceb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">特别是对于列表，您可能要考虑使用空列表。你这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1b60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于不可变的数据类型，比如字符串、整数、浮点数、元组，可以简单地赋值。对于可变列表，您需要使用带有<code class="fe nj nk nl na b">default_factory</code>的Field，每次都会生成一个新列表。<a class="ae lu" href="https://docs.python-guide.org/writing/gotchas/#mutable-default-arguments" rel="noopener ugc nofollow" target="_blank">如果你还不知道的话，学习一下为什么可变缺省是邪恶的</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7c62" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">附加数据:忽略、允许或禁止</h1><p id="7a86" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">有时在开发时不可能知道JSON对象具有哪些属性。尽管如此，你还是需要把它们传来传去。这是非常不幸的，应该受到挑战，但这是可能发生的。</p><p id="0bc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pydantic称那些<strong class="la iu">为临时演员</strong>。如果忽略它们，读取的pydantic模型将不会知道它们。<strong class="la iu">被忽略的额外参数被丢弃</strong>。允许他们意味着接受这个不幸的设计是必要的。<strong class="la iu">允许的额外内容将是解析对象</strong>的一部分。最后，<strong class="la iu">禁止</strong>额外参数意味着如果出现额外参数，将抛出<code class="fe nj nk nl na b">pydantic.ValidationError</code> <strong class="la iu">异常</strong>。</p><p id="ed95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是通过向pydantic模型添加一个名为<code class="fe nj nk nl na b">Config</code>的子类来配置的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4aea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">重命名属性</h1><p id="b2e1" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">名字很重要。<a class="ae lu" href="https://www.python.org/dev/peps/pep-0020/" rel="noopener ugc nofollow" target="_blank">可读性计数</a>。在Python中，变量应该遵循一个<code class="fe nj nk nl na b">snake_case</code>命名方案，而在JavaScript中，变量应该遵循一个<code class="fe nj nk nl na b">camelCase</code>命名方案。为了实现这两个目标，pydantic提供了<code class="fe nj nk nl na b"><a class="ae lu" href="https://pydantic-docs.helpmanual.io/usage/model_config/" rel="noopener ugc nofollow" target="_blank">allow_population_by_field_name</a></code>作为配置参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec90" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">验证器</h1><p id="6e14" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">有时候，简单的类型是不够的。你想检查更复杂的东西。</p><p id="07ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">文件已经给出了一个很好的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="84c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以检查几乎任何东西，只要你只需要类本身。请不要对数据库运行查询来进行一致性检查；例如，如果您希望用户名是唯一的或类似的。尽管您可能会运行此操作，但通过创建“数据容器”来触发数据库查询将是意想不到的。</p><p id="8b7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中，我们可能想要阻止人们成为自己的朋友:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="204a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了抛出异常，我们还可以简单地修复它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d3f5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用Pydantic进行基于属性的测试</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/ed0793a904bd8761f07d1fae52dcfcb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lF5tdh_5CjjsGaJt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lu" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清</a>摄影</p></figure><p id="0407" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于属性的测试自动生成被测函数的输入，并确保满足某个属性。在最简单的情况下，这个属性是测试中的函数不会崩溃。如果你想了解更多关于这种类型的测试，请阅读我的关于基于属性的测试和假设的文章。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="898a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便说一下，这个测试实际上指出了一个潜在的问题:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f5a8" class="ne md it na b gy nf ng l nh ni">Falsifying example: test_two_people(<br/>    person_a=Person(id=0, name='', bank_account=Decimal('NaN'), birthdate=datetime.date(2000, 1, 1), friends=[]),<br/>    person_b=Person(id=0, name='', bank_account=Decimal('NaN'), birthdate=datetime.date(2000, 1, 1), friends=[]),<br/>)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="309e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更整洁的东西</h1><p id="caac" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Pydantic非常棒:</p><ul class=""><li id="6523" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">您可以从它的模型中生成一个模式(<a class="ae lu" href="https://pydantic-docs.helpmanual.io/usage/schema/" rel="noopener ugc nofollow" target="_blank"> source </a>)，</li><li id="3d88" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">mypy插件提供了更好的类型检查</li><li id="9af4" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">对字典的序列化可以用<code class="fe nj nk nl na b">.dict()</code>方法完成，对JSON字符串的序列化可以用<code class="fe nj nk nl na b">.json()</code>方法完成。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8bf5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">操作安全</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a22d07a9b1b4a1e873b361a68e87cdf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fdsabhkbM69RDDI2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae lu" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本工程图</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8470" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我通常担心的一部分是普遍支持。以下是pydantic拥有健康社区的一些指标:</p><ul class=""><li id="5bc2" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">✔️ <a class="ae lu" href="https://github.com/samuelcolvin/pydantic" rel="noopener ugc nofollow" target="_blank"> GitHub </a> : 4.5k星，404叉，172贡献者</li><li id="bea9" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">✔️用法:<a class="ae lu" href="https://fastapi.tiangolo.com/#example-upgrade" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>使用它。微软的Onefuzz 使用它。<a class="ae lu" href="https://github.com/awslabs/aws-lambda-powertools-python" rel="noopener ugc nofollow" target="_blank"> AWS Lambda Powertools </a>也是如此。许多机器学习项目</li><li id="856e" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">✘ <a class="ae lu" href="https://pypi.org/project/pydantic/" rel="noopener ugc nofollow" target="_blank"> PyPI项目</a>:很遗憾，这个只有一个维护者。如果有两个，我会更喜欢一点。只是为了防止有人丢失密码。</li><li id="af55" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">✔️Self-decided项目状态:维护者认为pydantic可以投入生产/稳定。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8868" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="37fa" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">pydantic是一个非常棒的数据解析和验证库。它可以很好地支持你在Python 中获得更好的<a class="ae lu" href="https://medium.com/analytics-vidhya/type-annotations-in-python-3-8-3b401384403d" rel="noopener">类型注释。用它！</a></p></div></div>    
</body>
</html>