<html>
<head>
<title>Train Your Mind to Think Recursively in 5 Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">训练你的思维，用5个步骤进行递归思考</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/train-your-mind-to-think-recursively-in-5-steps-8f85c0e0eb81?source=collection_archive---------2-----------------------#2020-10-31">https://towardsdatascience.com/train-your-mind-to-think-recursively-in-5-steps-8f85c0e0eb81?source=collection_archive---------2-----------------------#2020-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e94c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何轻松解决递归问题？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f368a53ef8a82fc74faae950ff45f063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6G1YjV6scScyno9v"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@reidzura?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">里德·祖拉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的编程之旅中，有几个里程碑是您需要克服的。例如，熟悉类，理解指针，掌握代码函数化的艺术，等等。对于新手来说，最难学的编程概念之一是<em class="lv">递归</em>，对于已经编程一段时间的人来说，这是需要掌握的。</p><p id="5095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次开始编码的时候——大约十年前——我很难理解递归。虽然有些人可以自然地递归思考，但其他人——包括我自己——却不能。</p><p id="29b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">但是，</em> </strong></p><p id="c23d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归思维是你可以训练你的大脑去做和掌握的事情，即使你天生没有这种能力。</p><p id="541c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到2012年，我看到一本非常酷的书，叫做《像程序员一样思考》。这本书教会我开发一个思维过程，帮助我解决多年来的各种编程问题。它给了我一个程序员在职业生涯中取得成功所需的正确思维过程的基础。</p><p id="c804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些年来，我扩展了书中提出的那些技术，以便熟悉各种编程概念。</p><p id="3ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您介绍我用来解决任何递归问题的不同步骤。虽然我将使用Python来演示这些步骤，但是这些步骤可以应用于任何编程语言。他们的逻辑不是特定于语言的。</p><p id="1d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们—让我们，让我们，让我们—开始吧！</p><h1 id="b1ff" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">训练你递归思考的步骤</h1><p id="ea30" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了演示这个过程，我们来看一个简单的问题。假设我们需要对任何给定数字的位数求和。例如，123的和是6，for 57190是22，以此类推。</p><p id="3a12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我需要写一个代码，用递归来解决这个问题。在你说之前，我知道有其他方法可以解决这个问题——可以说是更好更容易的递归方法。但是，为了这篇文章，让我们考虑递归解决方案。</p><h1 id="6d81" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">1-首先使用iterable方法。</h1><p id="4af7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这一步对大多数人来说相对简单。我们有一个数字，想用循环对它的数字求和。基本上，我们需要知道如何计算数字中有多少位数，然后逐一求和。</p><p id="65df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是将包含数字的变量转换为str，这样更容易迭代。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2b4e" class="my lx it mu b gy mz na l nb nc">num = 123 #The variable containing the number we want to sum its digits<br/>num = str(num) #Casting the number to a str<br/>s = 0 #Initialize a varible to accumulate the sum<br/>#Loop over the digits and add them up<br/>for i in range(len(num)):<br/>  s += int(num[i])</span></pre><h1 id="4a97" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">2-提取函数的参数。</h1><p id="bd17" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使用循环解决问题将有助于我们理解答案，并找出它的所有非递归方面。现在我们有了答案，我们可以剖析它，提取我们需要继续前进的信息。</p><p id="05e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们需要问自己一个问题，<em class="lv">如果我把它写成一个函数形式，函数参数会是什么？</em></p><p id="0d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的答案取决于你使用的编程语言。对于Python，我们可以说只需要<strong class="lb iu">一个</strong>参数，就是变量<code class="fe nd ne nf mu b">num</code>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a7d4" class="my lx it mu b gy mz na l nb nc">def sumOfDigitsIter(num):<br/>    num = str(num)<br/>    s = 0<br/>    for i in range(len(num)):<br/>        s += int(num[i])<br/>    return s</span></pre><h1 id="2c8e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">3-扣除最小的问题实例。</h1><p id="d278" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一旦我们得到了函数参数，我们将对它们进行更深入的研究。在我们的例子中，我们只有一个参数num。</p><p id="61fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要做的是根据参数找到最小的问题实例。回想一下，我们的目的是对一个给定数字的位数求和。这个问题最简单的例子是如果数字只有一个数字。</p><p id="6b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果<code class="fe nd ne nf mu b">num = 3</code>，那么答案将等于变量本身，因为没有更多的数字相加。</p><h1 id="1ae6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">4-将解决方案添加到最小问题实例中。</h1><p id="e4b6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们再来看看我们刚刚写的函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f801" class="my lx it mu b gy mz na l nb nc">def sumOfDigitsIter(num):<br/>    num = str(num)<br/>    s = 0<br/>    for i in range(len(num)):<br/>        s += int(num[i])<br/>    return s</span></pre><p id="662e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照这个函数的逻辑，如果参数num只有一个数字，那么仍然会执行循环。为了避免这种情况，我们可以添加一个条件语句，该语句只在输入数字的位数为1时执行。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="86d5" class="my lx it mu b gy mz na l nb nc">def SumOfDigitsIter(num):<br/>    num = str(num)<br/>    if len(num) == 1:<br/>      return num<br/>    else:<br/>      s = 0<br/>      for i in range(len(num)):<br/>          s += int(num[i])<br/>      return s</span></pre><h1 id="5048" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">5-扩展你的功能。</h1><p id="6662" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是递归发生的步骤。到目前为止，我们并不太关心递归；我们在合乎逻辑地解决这个问题。这是从递归开始，从逻辑上考虑，然后转化为递归解决方案的最佳方法。</p><p id="6eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们考虑一下函数的<code class="fe nd ne nf mu b">else</code>部分。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a0ef" class="my lx it mu b gy mz na l nb nc">else:<br/>      s = 0<br/>      for i in range(len(num)):<br/>          s += int(num[i])<br/>      return s</span></pre><p id="60a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以把递归想象成展开一个问题实例，然后再次滚动它。我们可以从另一个角度来看这个问题，我们可以说123的和是1+23的和，23的和是2 +和3——也就是3。</p><p id="1f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，回滚到123 = 1 +2 +3 =6。</p><p id="24fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它转换成代码。我们已经写好了最后一部分，它处理一位数。我们需要做的是将num个变量分解成一位数。</p><p id="3165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是递归。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="146a" class="my lx it mu b gy mz na l nb nc">def SumOfDigits2(num):<br/> num = str(num)<br/> if len(num) == 1:<br/>   return num<br/> else:<br/>   return num[0] + sumOfDigits(num[1:])</span></pre><p id="1068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，每次，我都调用相同的函数，但是输入更少。一旦到了最后一位数，我最终会得到1 + 2 + 3这样的数，最终加起来就是6。</p><p id="cb9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧，我得到了一个递归函数。</p><h1 id="346f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">另一个例子</h1><p id="629e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们考虑另一个例子，假设我们想要得到两个相同长度的整数列表的绝对差的和。例如，如果我们有[15，-4，56，10，-23]和[14，-9，56，14，-23]，答案将是10。</p><p id="83c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步:用循环求解</strong></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4629" class="my lx it mu b gy mz na l nb nc">    assert len(arr1) == len(arr2)<br/>    diffSum = 0<br/>    for i in range(len(arr1)):<br/>        diffSum += abs(arr1[i]-arr2[i])<br/></span></pre><p id="eb14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二步:提取参数</strong></p><p id="ffcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数表= [arr1，arr2]。</p><p id="6198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第三步:扣除最小实例</strong></p><p id="0939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的最小实例是当两个列表为空时；在这种情况下，没有区别，所以答案是0。</p><p id="ee54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第四步:求解最小实例。</strong></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a81f" class="my lx it mu b gy mz na l nb nc">if len(arr1) == 0:<br/>  return 0</span></pre><p id="b5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可能会说，为什么不确保len(arr2) == 0呢？assert语句已经确保了两个列表具有相同的长度，这意味着如果我想检查它们是否为空，我只需要检查其中一个的长度。</p><p id="835f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第五步:递归</p><p id="052c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像digits sum示例一样，如果我想对两个列表之间的绝对差求和，我可以得到前两个元素之间的差，然后是第二个，然后是第三个，依此类推，直到我用完所有的元素。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4a5a" class="my lx it mu b gy mz na l nb nc">def recDiff(arr1,arr2):<br/>    assert len(arr1) == len(arr2)<br/>    if len(arr1) == 0:<br/>        return 0<br/>    else: <br/>        return abs(arr1[0]-arr2[0]) + recDiff(arr1[1:],arr2[1:])</span></pre><h1 id="b59c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">外卖食品</h1><p id="33c8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">递归被认为是程序员在成为“优秀程序员”的过程中需要经历的高级技术之一然而，一开始把一个人的脑袋包起来是相当棘手的，许多人发现很难掌握。</p><p id="5230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循简单明了的五个步骤，你可以轻松解决任何递归问题:</p><ol class=""><li id="0001" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">首先使用循环解决问题。</li><li id="0091" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">从中提取可能的输入，如果你想把它变成一个函数的话。</li><li id="005b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">演绎问题最简单的版本。</li><li id="1e24" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">写一个函数来解决这个问题的最简单的例子。</li><li id="c6f0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">使用该函数编写一个新的递归函数。</li></ol><p id="35a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我提出了5个步骤，但是你不需要明确地经历所有的5个步骤，因为你会更加精确。随着时间的推移和练习，你将能够在头脑中执行这些步骤，而不用明确地写下来。</p><p id="af76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把这个留给你，递归是一个需要掌握的具有挑战性的编程概念。所以，只要坚持下去，有耐心，多多练习；这是你真正掌握诀窍的唯一方法。</p></div></div>    
</body>
</html>