<html>
<head>
<title>Downloading Tableau crosstabs like a boss using Python and Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和熊猫下载像老板一样的Tableau交叉表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/querying-tableau-view-data-as-a-crosstab-using-python-and-pandas-ca71a4be5be0?source=collection_archive---------11-----------------------#2020-10-12">https://towardsdatascience.com/querying-tableau-view-data-as-a-crosstab-using-python-and-pandas-ca71a4be5be0?source=collection_archive---------11-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5605" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">TABLEAU REST API: TABLEAU-API-LIB教程</h2><div class=""/><div class=""><h2 id="172a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何下载Tableau视图数据而不丢失原始的表结构</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/fdfc4916dda21a245c632d41f3c1becd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JO7XTmyNACQdJwwR"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">有时你只需要行和列。(照片由<a class="ae lh" href="https://unsplash.com/@nhillier?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·希利尔</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄)</p></figure><p id="1769" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<a class="ae lh" href="https://medium.com/snake-charmer-python-and-analytics/query-your-tableau-view-data-like-a-boss-using-python-and-pandas-68483abac86" rel="noopener">的另一篇文章</a>中，我们介绍了如何像老板一样查询Tableau视图数据，我收到了一个人的反馈，他们想往兔子洞的更深处滚。</p><p id="dfeb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就引出了本文，在本文中，我们将演示如何在Tableau中下载表(交叉表)的视图数据，并重建该数据在Tableau中的形状。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="8a1f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本教程介绍了如何使用Python <a class="ae lh" href="https://github.com/divinorum-webb/tableau-api-lib" rel="noopener ugc nofollow" target="_blank"> tableau-api-lib </a>包，并且是如何像使用小桶一样使用tableau服务器的系列教程的一部分，让您能够控制Tableau服务器的REST API。</p><p id="5cbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些教程假设您已经安装了Python 3。如果您还没有Python 3，这将帮助您入门:<a class="ae lh" href="https://wiki.python.org/moin/BeginnersGuide/Download" rel="noopener ugc nofollow" target="_blank">安装Python的指南</a>。</p><h2 id="1450" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">搭建舞台</h2><p id="fa70" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">假设您在Tableau中有一个交叉表，出于某种原因您需要下载它。如果你用Tableau REST API做这件事，你会得到你想要的数据…只是不一定是你需要的格式。</p><p id="e499" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">主要问题是，当您下载视图数据时，您不会以“数据透视表”或交叉表的形式获得数据。您将拥有一个数据库格式的原始表，其中所有维度都显示为列。</p><p id="66bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看如何下载数据，并把它重新做成您想要的表格或交叉表。</p><p id="c684" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面快速浏览一下Tableau视图，我们将下载它的数据:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/64b48438745a0cd19fd9e54e12715032.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*CXk_3v_OfKf7yWluTxiSyg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们希望下载它并保留它的行/列结构。</p></figure><h2 id="de53" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">步骤1:确保你已经安装了tableau-api-lib</h2><p id="3525" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">即使你是这些教程的专家，帮自己一个忙，下载最新版本的库。</p><p id="d2a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nj nk nl nm b">pip install --upgrade tableau-api-lib</code></p><p id="324a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不熟悉Python这个东西？别担心，你会很快明白的。遵循<a class="ae lh" href="https://medium.com/snake-charmer-python-and-analytics/tableau-server-on-tap-getting-started-89bc5f0095fa" rel="noopener">本入门教程</a>。该教程将引导您使用tableau-api-lib连接到Tableau服务器。</p><h2 id="df16" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">步骤2:进入Tableau服务器环境</h2><p id="b162" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">使用下面的代码作为连接到您的服务器的模板。在接下来的步骤中，我们将使用一次性代码行来构建这个样板文件。在本文的最后，您会发现一个合并的代码块，为了方便起见，您可以复制/粘贴它。</p><pre class="ks kt ku kv gt nn nm no np aw nq bi"><span id="e8c0" class="ml mm it nm b gy nr ns l nt nu">from tableau_api_lib import TableauServerConnection<br/>from tableau_api_lib.utils import querying</span><span id="1335" class="ml mm it nm b gy nv ns l nt nu">tableau_server_config = {<br/>        'my_env': {<br/>                'server': '<a class="ae lh" href="https://tableaupoc.interworks.com%27/" rel="noopener ugc nofollow" target="_blank">https://YourTableauServer.com'</a>,<br/>                'api_version': '&lt;YOUR_API_VERSION&gt;',<br/>                'username': '&lt;YOUR_USERNAME&gt;',<br/>                'password': '&lt;YOUR_PASSWORD&gt;',<br/>                'site_name': '&lt;YOUR_SITE_NAME&gt;',<br/>                'site_url': '&lt;YOUR_SITE_CONTENT_URL&gt;'<br/>        }<br/>}</span><span id="9394" class="ml mm it nm b gy nv ns l nt nu">conn = TableauServerConnection(tableau_server_config, env='my_env')<br/>conn.sign_in()</span></pre><p id="3778" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有趣的事实:你也可以使用个人访问令牌，假设你在Tableau Server 2019.4或更新版本上。如果你对访问令牌很感兴趣，可以看看我的文章，了解如何使用它们的细节。</p><h2 id="9cc1" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">第三步:找到你要找的机器人</h2><p id="f635" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们想要查询一个视图，所以首先我们需要获取所需视图的ID值。</p><pre class="ks kt ku kv gt nn nm no np aw nq bi"><span id="9787" class="ml mm it nm b gy nr ns l nt nu">site_views_df = querying.get_views_dataframe(conn)</span></pre><p id="1e24" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是我生成的数据帧的样子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/202095b09878b2859c3e6b1e760825b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArCORiywqaB0nP7OeLK2CA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">这是一个熊猫的数据框架，包含了我们所有观点的细节。</p></figure><p id="ff39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们愿意，我们可以手动搜索并复制/粘贴相关的“id”值。但是，如果您在一个大的Tableau环境中工作，那么您可能会有许多同名的视图。</p><p id="4bd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">出于这个原因，让我们以正确的方式来做这件事，并在我们的“工作簿”列中打开细节，这样我们就可以根据工作簿名称进行过滤，以确保我们确实得到了我们正在寻找的droid。</p><h2 id="a0ec" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">步骤4:提取工作簿的详细信息，这样我们可以缩小范围</h2><p id="f0fa" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">使用一个方便的tableau-api-lib函数，我们可以很容易地解开工作簿的细节。通过参考文章末尾提供的完整代码，可以看到这个函数是如何导入的。</p><pre class="ks kt ku kv gt nn nm no np aw nq bi"><span id="47f3" class="ml mm it nm b gy nr ns l nt nu">site_views_detailed_df = flatten_dict_column(<br/>site_views_df, keys=['name', 'id'], col_name='workbook')</span></pre><p id="30df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以快速验证生成的数据帧是否包含工作簿的详细信息:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/eefcd37a807918240a72cc26366ee03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*5kKXP2fJfQvBY72bq8CkoA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">存在两个新列:“工作簿名称”和“工作簿标识”</p></figure><p id="2dbc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以轻松地过滤我们关心的工作簿名称。在我的例子中，工作簿被命名为“query_view_as_crosstab ”,我想下载的视图被命名为“Visual C”。为了重申之前的观点，我们希望对工作簿进行过滤，因为视图名称在整个Tableau站点中很可能不是唯一的，但是在工作簿中它们总是唯一的。</p><pre class="ks kt ku kv gt nn nm no np aw nq bi"><span id="eff3" class="ml mm it nm b gy nr ns l nt nu">relevant_views_df = site_views_detailed_df[site_views_detailed_df['workbook_name'] == 'query_view_as_crosstab']</span></pre><h2 id="10c5" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">第5步:查询视图数据</h2><p id="e353" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">既然我们已经将我们的视图隔离到我们感兴趣的工作簿，让我们获得目标视图的视图ID。</p><pre class="ks kt ku kv gt nn nm no np aw nq bi"><span id="4594" class="ml mm it nm b gy nr ns l nt nu">visual_c_id = relevant_views_df[relevant_views_df['name'] == 'Visual C']['id'].to_list()[0]</span></pre><p id="b913" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了视图ID，我们现在可以查询视图数据:</p><pre class="ks kt ku kv gt nn nm no np aw nq bi"><span id="73ca" class="ml mm it nm b gy nr ns l nt nu">view_data_raw = querying.get_view_data_dataframe(conn, view_id=visual_c_id)</span></pre><p id="9ace" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">tableau-api-lib查询函数' get_view_data_dataframe()'返回一个Pandas DataFrame，我的是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0fd0b4c3a6c514ad1e8fc14c7d56152b.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*AM8S_89YwVQ313CK1M6ZjA.png"/></div></figure><p id="a02a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个好的开始，但是我们需要透视这些数据，以便“子类别”定义我们的行，“订单日期年”定义我们的列，并且“销售”填充透视表的值。</p><h2 id="7f26" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">步骤6:旋转数据框以生成所需的表格</h2><p id="6886" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在我们执行旋转表的最后一步之前，让我们快速地对数据应用一个可选的改进:将奇怪命名的“订单日期年份”列重命名为“年份”。</p><pre class="ks kt ku kv gt nn nm no np aw nq bi"><span id="95e1" class="ml mm it nm b gy nr ns l nt nu">view_data_raw.rename(columns={'Year of Order Date': 'Year'}, inplace=True)</span></pre><p id="c413" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">啊，这样好多了。现在让我们结束这一切吧！</p><pre class="ks kt ku kv gt nn nm no np aw nq bi"><span id="9e3b" class="ml mm it nm b gy nr ns l nt nu">view_data_raw.pivot_table(values=['Sales'], index=['Sub-Category'], columns=['Year'])</span></pre><p id="21da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们结束今天的工作之前，让我们快速剖析一下这最后一点代码。Pandas DataFrame 'pivot_table()'函数为我们提供了一种重新定义数据结构的简单方法。</p><p id="2d16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">“值”参数定义了什么将填充表格的值，而“索引”值定义了行，“列”定义了…列！</p><p id="1d00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们现在的样子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/88f21d102b575b4ed84a8034407e8cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*nLTHLtc-PqafvJVirw22Ig.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">现在我们有了一张和最初在Tableau中看到的一样的桌子。</p></figure><p id="6c0c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个总结！</p><h1 id="472f" class="oa mm it bd mn ob oc od mq oe of og mt ki oh kj mw kl oi km mz ko oj kp nc ok bi translated">合并代码</h1><p id="93de" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">使用GitHub gist作为修改我们在本教程中介绍的步骤的起点，供您自己使用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure></div></div>    
</body>
</html>