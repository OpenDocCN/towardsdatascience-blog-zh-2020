<html>
<head>
<title>GPU-Optional Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GPU-可选Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gpu-optional-python-be36a02b634d?source=collection_archive---------41-----------------------#2020-11-11">https://towardsdatascience.com/gpu-optional-python-be36a02b634d?source=collection_archive---------41-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="18b3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写代码，在GPU可用和需要时利用它，但在不可用时在CPU上运行良好</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/effc4396e8fa702244923b2f08bb760c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0I68wa2MMqPyl22H"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@frdx?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗雷德里克·滕东</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">奇妙的CuPy库允许你在NVIDIA GPU上轻松运行NumPy兼容代码。然而，有时</p><ul class=""><li id="1bb0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">您(或您的用户)没有兼容的GPU，或者</li><li id="e1c1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">你没有兼容CuPy的Python环境，或者</li><li id="8926" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">您的代码在我们的GPU上运行比在您的多个CPU上运行慢。</li></ul><p id="cfff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过定义三个简单的实用函数，您可以使您的代码<em class="mg"> GPU可选。(</em>在<a class="ae kv" href="https://github.com/CarlKCarlK/gpuoptional/" rel="noopener ugc nofollow" target="_blank">这个小的GitHub项目</a>中找到实用函数的定义。)</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="ea63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们试图使用CuPy为我们的开源基因组包<a class="ae kv" href="https://fastlmm.github.io/" rel="noopener ugc nofollow" target="_blank"> FaST-LMM </a>添加GPU支持时，我们遇到了三个问题。我们用一个简单的效用函数解决了每个问题。让我们看看每个问题，解决它的效用函数，以及例子。</p><h2 id="0de2" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">问题1:控制使用NumPy还是CuPy</h2><p id="08c5" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">假设您想要生成一组简单的随机DNA数据。行代表个人。列代表DNA位置。值代表“等位基因计数”，可以是0、1、2或NaN(代表缺失)。此外，您希望</p><ul class=""><li id="691b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">默认生成一个NumPy数组</li><li id="3339" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过字符串、数组模块或环境变量请求时生成CuPy数组</li><li id="c18a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">当对CuPy的请求失败时，回退到NumPy例如，因为您的计算机不包含GPU或者因为没有安装CuPy。</li></ul><p id="c148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">效用函数<code class="fe nm nn no np b">array_module</code>(在<a class="ae kv" href="https://github.com/CarlKCarlK/gpuoptional/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中定义)解决了这个问题。下面是使用<code class="fe nm nn no np b">array_module</code>生成的数据生成器:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="d48d" class="mo mp iq np b gy nu nv l nw nx">def gen_data(size, seed=1, <strong class="np ir">xp=None</strong>):<br/>    <strong class="np ir">xp = array_module(xp)</strong><br/>    rng = xp.random.RandomState(seed=seed)<br/>    a = rng.choice([0.0, 1.0, 2.0, xp.nan], size=size)<br/>    return a</span></pre><p id="11ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输入:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="e2e2" class="mo mp iq np b gy nu nv l nw nx">a = gen_data((1_000,100_000))# Python 3.6+ allows _ in numbers<br/>print(type(a))<br/>print(a[:3,:3]) # print 1st 3 rows &amp; cols</span></pre><p id="c263" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输出:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="fb38" class="mo mp iq np b gy nu nv l nw nx">&lt;class 'numpy.ndarray'&gt;<br/>[[ 1. nan  0.]<br/> [ 0.  2.  2.]<br/> [nan  1.  0.]]</span></pre><p id="17b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据需要，DNA生成器默认返回一个<code class="fe nm nn no np b">numpy</code>数组。</p><p id="5f17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe nm nn no np b">gen_data</code>的可选<code class="fe nm nn no np b">xp</code>参数。当<code class="fe nm nn no np b">xp</code>通过<code class="fe nm nn no np b">array_module</code>效用函数时，会发生以下情况:</p><ul class=""><li id="763a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果你还没有安装CuPy包，<code class="fe nm nn no np b">xp</code>就会是<code class="fe nm nn no np b">numpy</code>。</li><li id="3949" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">否则；如果您指定了字符串<code class="fe nm nn no np b">'cupy'</code>或<code class="fe nm nn no np b">'numpy'</code>，那么您的规范将会得到遵守。</li><li id="d996" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">否则；如果您指定数组模块<code class="fe nm nn no np b">cupy</code>或<code class="fe nm nn no np b">numpy</code>，您的规范将会得到尊重。</li><li id="e988" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">否则，如果您将<code class="fe nm nn no np b">'ARRAY_MODULE'</code>环境变量设置为<code class="fe nm nn no np b">'cupy'</code>或<code class="fe nm nn no np b">'numpy'</code>，您的规范将会得到遵守。</li><li id="65b5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">否则，<code class="fe nm nn no np b">xp</code>就是<code class="fe nm nn no np b">numpy</code>。</li></ul><p id="97de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看它在我安装了GPU和CuPy的机器上的工作情况:</p><p id="f015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输入:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="734b" class="mo mp iq np b gy nu nv l nw nx">a = gen_data((1_000,100_000),xp='cupy')<br/>print(type(a))<br/>print(a[:3,:3]) # print 1st 3 rows &amp; cols</span></pre><p id="ad5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输出:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="4609" class="mo mp iq np b gy nu nv l nw nx">&lt;class 'cupy.core.core.ndarray'&gt;<br/>[[ 0. nan  0.]  <br/> [ 2.  2.  2.]<br/> [ 0. nan  1.]]</span></pre><p id="d713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如所料，它按照要求生成一个<code class="fe nm nn no np b">cupy</code>数组。</p><blockquote class="ny nz oa"><p id="07ea" class="kw kx mg ky b kz la jr lb lc ld ju le ob lg lh li oc lk ll lm od lo lp lq lr ij bi translated">旁白:注意NumPy和CuPy生成不同的随机数，即使给定相同的种子。</p></blockquote><p id="4baf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们通过环境变量请求CuPy。</p><p id="ceaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输入:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="121f" class="mo mp iq np b gy nu nv l nw nx"># 'patch' is a nice built-in Python function that can temporarily<br/># add an item to a dictionary, including os.environ.<br/>from unittest.mock import patch</span><span id="1aea" class="mo mp iq np b gy oe nv l nw nx">with patch.dict("<strong class="np ir">os.environ", {"ARRAY_MODULE": "cupy"}</strong>) as _:<br/>    a = gen_data((5, 5))<br/>    print(type(a))</span></pre><p id="3a6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输出:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="6497" class="mo mp iq np b gy nu nv l nw nx">&lt;class 'cupy.core.core.ndarray'&gt;</span></pre><p id="340b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如所料，我们可以通过环境变量请求一个<code class="fe nm nn no np b">cupy</code>数组。(同样，使用<code class="fe nm nn no np b">patch</code>，我们可以临时设置一个环境变量。)</p><h2 id="d919" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">问题2:从数组中提取“<code class="fe nm nn no np b">xp</code>”数组模块</h2><p id="4196" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">假设您想要“标准化”一组DNA数据。这里的“标准化”是指使每一列的值具有平均值0.0和标准差1.0，并用0.0填充缺失值。此外，您希望这能起作用</p><ul class=""><li id="e3bf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">对于NumPy阵列，即使您还没有或不能安装CuPy包</li><li id="39e0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对于NumPy阵列和CuPy阵列</li></ul><p id="c20f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">效用函数<code class="fe nm nn no np b">get_array_module</code>(在<a class="ae kv" href="https://github.com/CarlKCarlK/gpuoptional/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中定义)解决了这个问题。以下是使用<code class="fe nm nn no np b">get_array_module</code>的标准化器:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="b7e8" class="mo mp iq np b gy nu nv l nw nx">def unit_standardize(a):<br/>    """<br/>    Standardize array to zero-mean and unit standard deviation.<br/>    """<br/><strong class="np ir">    xp = get_array_module(a)</strong></span><span id="1a37" class="mo mp iq np b gy oe nv l nw nx">    assert a.dtype in [<br/>        np.float64,<br/>        np.float32,<br/>    ], "a must be a float in order to standardize in place."</span><span id="ccac" class="mo mp iq np b gy oe nv l nw nx">    imissX = xp.isnan(a)<br/>    snp_std = xp.nanstd(a, axis=0)<br/>    snp_mean = xp.nanmean(a, axis=0)<br/>    # avoid div by 0 when standardizing<br/>    snp_std[snp_std == 0.0] = xp.inf</span><span id="a8c8" class="mo mp iq np b gy oe nv l nw nx">    a -= snp_mean<br/>    a /= snp_std<br/>    a[imissX] = 0</span></pre><p id="caca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们如何使用<code class="fe nm nn no np b">get_array_module</code>将<code class="fe nm nn no np b">xp</code>设置为数组模块(或者<code class="fe nm nn no np b">numpy</code>或者<code class="fe nm nn no np b">cupy</code>)。然后我们用<code class="fe nm nn no np b">xp</code>调用<code class="fe nm nn no np b">xp.isnan</code>之类的函数。</p><p id="1024" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们标准化一个NumPy数组:</p><p id="e2b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输入:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="f6c2" class="mo mp iq np b gy nu nv l nw nx">a = gen_data((1_000,100_000))<br/>unit_standardize(a)<br/>print(type(a))<br/>print(a[:3,:3]) #1st 3 rows and cols</span></pre><p id="546f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输出:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="ca6f" class="mo mp iq np b gy nu nv l nw nx">&lt;class 'numpy.ndarray'&gt;<br/>[[-0.0596511   0.         -1.27903946]<br/> [-1.32595873  1.25433129  1.21118591] <br/> [ 0.          0.05417923 -1.27903946]]</span></pre><p id="b943" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的电脑上，这运行得很好，大约在5秒钟内返回一个答案。</p><p id="af01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们标准化一个CuPy阵列:</p><p id="198e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输入:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="5fe2" class="mo mp iq np b gy nu nv l nw nx">a = gen_data((1_000,100_000), xp='cupy')<br/>unit_standardize(a)<br/>print(type(a))<br/>print(a[:3,:3]) #1st 3 rows and cols</span></pre><p id="4c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输出:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="ae49" class="mo mp iq np b gy nu nv l nw nx">&lt;class 'cupy.core.core.ndarray'&gt;<br/>[[-1.22196758  0.         -1.23910541]<br/> [ 1.24508589  1.15983351  1.25242913]<br/> [-1.22196758  0.          0.00666186]]</span></pre><p id="f7dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的电脑上，标准化在CuPy阵列上运行得更快，大约在1秒钟内返回一个答案。</p><blockquote class="ny nz oa"><p id="a9fa" class="kw kx mg ky b kz la jr lb lc ld ju le ob lg lh li oc lk ll lm od lo lp lq lr ij bi translated">旁白:那么GPU是不是更快了？不一定。上面运行的CPU只用了我六个CPU中的一个。当我使用其他技术——例如，Python多处理或多线程C++代码——在所有6个CPU上运行时，运行时变得可比。</p></blockquote><h2 id="59fd" class="mo mp iq bd mq mr ms dn mt mu mv dp mw lf mx my mz lj na nb nc ln nd ne nf ng bi translated">问题3:在NumPy和"<code class="fe nm nn no np b">xp</code>"之间转换</h2><p id="a542" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">假设您的数据以NumPy数组开始，您需要将它转换成您想要的<code class="fe nm nn no np b">xp</code>数组模块。稍后，假设您的数据是一个<code class="fe nm nn no np b">xp</code>数组，您需要将它转换成一个NumPy数组。(使用熊猫等知道NumPy但不知道CuPy的包时会出现这些情况。)</p><p id="d0b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">内置函数<code class="fe nm nn no np b">xp.asarray</code>和实用函数<code class="fe nm nn no np b">asnumpy</code>(在<a class="ae kv" href="https://github.com/CarlKCarlK/gpuoptional/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中定义)解决了这个问题。这里有一个例子:</p><p id="996b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输入:</em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="aa25" class="mo mp iq np b gy nu nv l nw nx">a = gen_data((1_000,100_000))<br/>print(type(a)) # numpy<br/>xp = array_module(xp='cupy')<br/><strong class="np ir">a = xp.asarray(a)</strong><br/>print(type(a)) # cupy<br/>unit_standardize(a)<br/>print(type(a)) # still, cupy<br/><strong class="np ir">a = asnumpy(a)</strong><br/>print(type(a)) # numpy<br/>print(a[:3,:3]) # print 1st 3 rows and cols</span></pre><p id="79ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输出1: </em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="3ca9" class="mo mp iq np b gy nu nv l nw nx">&lt;class 'numpy.ndarray'&gt;<br/>&lt;class 'cupy.core.core.ndarray'&gt;<br/>&lt;class 'cupy.core.core.ndarray'&gt;<br/>&lt;class 'numpy.ndarray'&gt;<br/>[[-0.0596511   0.         -1.27903946]<br/> [-1.32595873  1.25433129  1.21118591]<br/> [ 0.          0.05417923 -1.27903946]]</span></pre><p id="5b69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例生成一个随机NumPy数组。将其转换为CuPy(如果可能的话)。标准化它。转换(如有必要)为NumPy。在我的电脑上，它大约运行2秒钟。</p><p id="b749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有安装CuPy，代码仍然运行良好(大约5秒钟)，产生以下输出:</p><p id="3f0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">输出2: </em></p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="15fc" class="mo mp iq np b gy nu nv l nw nx">WARNING:root:Using numpy. (No module named 'cupy')<br/>&lt;class 'numpy.ndarray'&gt;<br/>&lt;class 'numpy.ndarray'&gt;<br/>&lt;class 'numpy.ndarray'&gt;<br/>&lt;class 'numpy.ndarray'&gt;<br/>[[-0.0596511   0.         -1.27903946] <br/> [-1.32595873  1.25433129  1.21118591] <br/> [ 0.          0.05417923 -1.27903946]]</span></pre><blockquote class="ny nz oa"><p id="3bb7" class="kw kx mg ky b kz la jr lb lc ld ju le ob lg lh li oc lk ll lm od lo lp lq lr ij bi translated">旁白:请注意，无论是否安装了CuPy，我们现在看到的结果都是一样的。为什么？因为这个例子总是使用NumPy来生成随机数据。</p></blockquote><h1 id="ff21" class="of mp iq bd mq og oh oi mt oj ok ol mw jw om jx mz jz on ka nc kc oo kd nf op bi translated">结论</h1><p id="5c5b" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我们已经看到了三个实用函数如何使您能够编写使用或不使用GPU都可以工作的代码。</p><ul class=""><li id="9017" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nm nn no np b">array_module </code> —如果可能，根据用户输入(包括环境变量)设置<code class="fe nm nn no np b">xp</code>。默认并在必要时回退到NumPy。</li><li id="9c2e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nm nn no np b">get_array_module</code> —根据数组设置<code class="fe nm nn no np b">xp</code>。即使没有或不能安装<code class="fe nm nn no np b">cupy</code>包也能工作。</li><li id="209d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nm nn no np b">xp.asarray</code>和<code class="fe nm nn no np b">asnumpy </code> —与NumPy相互转换</li></ul><p id="52cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了支持使用或不使用GPU的代码之外，编写GPU可选的代码还有一个额外的好处。GPU有时会无法加速你的工作。通过让你的代码成为可选的GPU，你可以在GPU不起作用的时候关闭它。</p><p id="b8e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这个小小的GitHub项目中找到这些实用函数的定义。</p></div></div>    
</body>
</html>