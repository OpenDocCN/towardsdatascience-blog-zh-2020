<html>
<head>
<title>Getting Familiar With Loops In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熟悉Julia中的循环</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-familiar-with-loops-in-julia-cfbcc344728c?source=collection_archive---------22-----------------------#2020-10-11">https://towardsdatascience.com/getting-familiar-with-loops-in-julia-cfbcc344728c?source=collection_archive---------22-----------------------#2020-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b231" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">朱莉娅综合教程</h2><div class=""/><div class=""><h2 id="7aef" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Julia编程语言中循环和条件一起使用的介绍。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/482b2a50f0977a664a62ab1eacf1e9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBtYeCEtxMl922hmsyrqPA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="lh li l"/></div></figure><blockquote class="lj"><p id="6ea9" class="lk ll it bd lm ln lo lp lq lr ls lt dk translated"><a class="ae lu" href="https://github.com/emmettgb/JuliaLessons" rel="noopener ugc nofollow" target="_blank"> Github回购</a></p><p id="4cf0" class="lk ll it bd lm ln lv lw lx ly lz lt dk translated"><a class="ae lu" href="https://github.com/emmettgb/JuliaLessons/blob/master/3/Comprehensive%20Julia%20Tutorial%203(%20Completed%20NB%20).ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><h1 id="7333" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated">介绍</h1><p id="c736" class="pw-post-body-paragraph ms mt it mu b mv mw kd mx my mz kg na nb nc nd ne nf ng nh ni nj nk nl nm lt im bi translated">如果一个人想进一步提高他们在软件工程方面的技能，仅仅通过观看是很难学会的。即使对文献或多媒体中的所有概念都了如指掌，如果不实际创建代码并查看代码如何与数据交互，也很难学习。大约十五年前，我一头扎进了C++这门美丽的语言。为了学习C++，我会花几个小时研究和复制粘贴代码，以找出它是做什么的。问题是我没有自己写代码，即使它是直接复制的。</p><p id="9e90" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">需要澄清的是，我并不是说复制和粘贴代码是一件坏事，我总是从我以前的笔记本、我当前的项目，甚至是万维网上复制和粘贴代码片段。然而，很多工程是关于学习如何学习的。其中一部分是知道什么时候复制和粘贴，而不是什么时候你需要进一步研究材料。在我的C++例子中，我记得使用了STD库和&lt;</p><p id="b394" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">有趣的是，在地球上所有的语言中，我从未真正对Python感兴趣，直到大约三年前。虽然没错——它确实比C++容易学得多，但我发现许多不同之处令人震惊。不管这种语言与其祖先相比有多简单，我发现自己陷入了一个陷阱，从谷歌上转移大量我并不真正理解的代码，这阻碍了我对这种新语言的学习能力。</p><p id="3e9a" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">所有这些证据都是为了支持一个说法:</p><blockquote class="lj"><p id="963d" class="lk ll it bd lm ln lv lw lx ly lz lt dk translated">想学编程，需要写代码。</p></blockquote><p id="3a88" class="pw-post-body-paragraph ms mt it mu b mv ns kd mx my nt kg na nb nu nd ne nf nv nh ni nj nw nl nm lt im bi translated">我有一个导师，他参考了Zed Shaw的书《艰难地学习Python》。这本书里的观点反映了我所讨论的内容的重要性，并且让我真正认识到，只要有互动，教育就变得简单多了。我也认为自己是一个视觉学习者，所以对我来说，这可以适用于任何试图学习计算机编程的人。</p><p id="20d2" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">带着这些想法，我想如果我要提供具体和充分的教程，将一个人从一个绝对的初学者变成一个绝对的专业人士，那么我当然应该包括学生自己学习的资源。Github repo中现在提供了笔记本的空副本，我坚持让较新的程序员自己键入代码！</p><h1 id="af0f" class="ma mb it bd mc md me mf mg mh mi mj mk ki nx kj mm kl ny km mo ko nz kp mq mr bi translated">环</h1><p id="9b6b" class="pw-post-body-paragraph ms mt it mu b mv mw kd mx my mz kg na nb nc nd ne nf ng nh ni nj nk nl nm lt im bi translated">在编程领域，开发人员可以使用一些不同的操作来处理数据。最常用的两种操作是循环和条件。循环是一种编程技术，它不仅允许检查、比较和计算类型内部的元素，而且是程序本身的基础。</p><p id="9ba7" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">编程中使用的循环主要有三种类型，一些独特的应用与特定的语言有关，例如Julia的语法循环。在Julia中，我们有以下循环应用程序供我们使用:</p><ul class=""><li id="2a0f" class="oa ob it mu b mv nn my no nb oc nf od nj oe lt of og oh oi bi translated">迭代循环</li><li id="b26d" class="oa ob it mu b mv oj my ok nb ol nf om nj on lt of og oh oi bi translated">循环时</li><li id="470d" class="oa ob it mu b mv oj my ok nb ol nf om nj on lt of og oh oi bi translated">递归循环</li><li id="34d3" class="oa ob it mu b mv oj my ok nb ol nf om nj on lt of og oh oi bi translated">语法循环</li></ul><p id="ee98" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">也就是说，语法循环<strong class="mu jd">仍然使用迭代器，</strong>只是在迭代器旁边使用语法表达式，用更多的表达式进行更快的循环——迭代也是如此。</p><p id="8e41" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">让我们来看看一个迭代循环。迭代循环不同于递归循环和while循环，因为它们需要dim来循环。包含这种dim的类型的一个例子是数组。在数组的例子中，我们可以使用迭代循环连续地逐个循环每个元素。这也可以使用生成器类型来完成，它只是一种能够自己创建类型的类型。一个基本的例子是一个范围，其中范围类型生成一个位于范围的给定边界之间的dims数组。在这个例子中，我们将遍历一个由10到20之间的所有整数组成的数组:</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="2eff" class="ot mb it op b gy ou ov l ow ox"><strong class="op jd">for</strong> number in 10:20<br/>    println(number)<br/><strong class="op jd">end</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/d2bf1c0acd4d1bcc9eadeef6d6909b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*G_70Lvye3I9c2BD8yZum_w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><p id="c3e9" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">while循环将采用bool类型，这是一个读取true或false的条件，并将其用作循环的中断。只要不满足提供的条件，循环就会停止。而循环实际上是在机器上运行的大多数应用程序的基础。这是因为，只要你想让他们执行任务，他们就能始终如一地执行任务。当然，为了创建while循环，我们将使用关键字“while”，后跟一个条件。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="ade0" class="ot mb it op b gy ou ov l ow ox"><em class="oz"># while loop</em><br/>number = 1<br/><strong class="op jd">while</strong> number &lt;= 5<br/>    number += 1<br/>    print(number)<br/><strong class="op jd">end</strong></span></pre><p id="0e19" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">另一个要看的是打破循环的能力。这通常是在有条件的情况下完成的，但它使用了关键字“break”例如，虽然上面的循环将打印1到6之间的每个数字，但如果我们打破它，我们将得不到任何打印结果。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="c893" class="ot mb it op b gy ou ov l ow ox"><em class="oz"># while loop</em><br/>number = 1<br/><strong class="op jd">while</strong> number &lt;= 5</span><span id="ca5d" class="ot mb it op b gy pa ov l ow ox">    break<br/>    number += 1<br/>    print(number)<br/><strong class="op jd">end</strong></span></pre><p id="a89d" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">最后，还有递归循环。递归以及何时使用它是一个完全不同的讨论。一般来说，递归会降低性能，但是，有许多函数式算法是利用递归的现代计算的基础。也就是说，在迭代和while循环不能完成工作的情况下，递归有一些很好的用途。阶乘的计算是递归在科学、高级计算中合理应用的一个完美例子。大多数递归算法将使用一个条件来决定是否应该用一个返回来中断一个循环。在阶乘函数中，我们要做的第一件事是检查我们想要阶乘的数字是否为1。如果是这样的话，1的阶乘当然只是1，所以我们将返回1。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="ef7c" class="ot mb it op b gy ou ov l ow ox"><strong class="op jd">function</strong> fact(n)<br/>    <strong class="op jd">if</strong> n == 1<br/>        <strong class="op jd">return</strong>(1)</span></pre><p id="7129" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">这会打破我们的循环。考虑递归循环的一个很好的方法是想象函数本身既是循环又是循环的初始化。接下来，我们要把这个数乘以它本身的阶乘减一。这在数学上本质上是非常递归的，因此计算中的应用程序也应该是递归的。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="1b7e" class="ot mb it op b gy ou ov l ow ox"><strong class="op jd">else</strong><br/>        <strong class="op jd">return</strong> n * fact(n-1)</span></pre><p id="6fb2" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">只要满足else条件，这个函数就会调用自己。如果n-1不等于1，那么它将再次调用自己——这就是递归。这是我们的最终结果:</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="68ed" class="ot mb it op b gy ou ov l ow ox"><strong class="op jd">function</strong> fact(n)<br/>    <strong class="op jd">if</strong> n == 1<br/>        <strong class="op jd">return</strong>(1)<br/>    <strong class="op jd">else</strong><br/>        <strong class="op jd">return</strong> n * fact(n-1)<br/>    <strong class="op jd">end</strong><br/><strong class="op jd">end</strong></span></pre><blockquote class="pb pc pd"><p id="f920" class="ms mt oz mu b mv nn kd mx my no kg na pe np nd ne pf nq nh ni pg nr nl nm lt im bi translated">有趣的事实:</p><p id="63e4" class="ms mt oz mu b mv nn kd mx my no kg na pe np nd ne pf nq nh ni pg nr nl nm lt im bi translated">Julia的基本阶乘函数factorial()实际上并没有使用递归来计算阶乘。相反，它使用查找表将值与相应的阶乘相匹配。这意味着大于一个数的值，在Julia的例子中是22，是无法计算的。虽然这可能是一个缺点，但这也意味着数字小于22的运算要比其他情况快得多。</p></blockquote><h1 id="e99c" class="ma mb it bd mc md me mf mg mh mi mj mk ki nx kj mm kl ny km mo ko nz kp mq mr bi translated">拉链环</h1><p id="cbfa" class="pw-post-body-paragraph ms mt it mu b mv mw kd mx my mz kg na nb nc nd ne nf ng nh ni nj nk nl nm lt im bi translated">zip循环是一个很好的工具，当你想同时遍历多个数组的时候可以使用它。这对于阈值以及跨数组比较或操作值都很有用。Julia中的zip语法与大多数语言略有不同，所以确保应用正确的语法很重要，使用zip作为方法，两个dim成对使用。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="128d" class="ot mb it op b gy ou ov l ow ox">array2 = [30, 40, 50, 60]<br/><strong class="op jd">for</strong> (i, w) in zip(array, array2)<br/>    println(i, w)<br/><strong class="op jd">end</strong></span></pre><h1 id="3154" class="ma mb it bd mc md me mf mg mh mi mj mk ki nx kj mm kl ny km mo ko nz kp mq mr bi translated">把我们知道的和循环结合起来</h1><p id="3fd9" class="pw-post-body-paragraph ms mt it mu b mv mw kd mx my mz kg na nb nc nd ne nf ng nh ni nj nk nl nm lt im bi translated">现在我们已经有了循环、条件和函数的坚实基础知识，让我们把所有这些技能结合起来。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="3673" class="ot mb it op b gy ou ov l ow ox">newarray = []<strong class="op jd"><br/>for</strong> element in array<br/>    <strong class="op jd">if</strong> element == 10<br/>        append!(newarray, element)<br/>    <strong class="op jd">elseif</strong> element == 20<br/>        append!(newarray, element)<br/>    <strong class="op jd">end</strong><br/><strong class="op jd">end</strong></span></pre><p id="dcb1" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">在这个例子中，我们循环遍历一个数组。如果它满足等于10的条件，那么我们将把它附加到新的空数组中。如果数字不等于10和等于20，我们也将这样做。然而，如果它等于10和20，那么它将只运行初始if。</p><h1 id="a25a" class="ma mb it bd mc md me mf mg mh mi mj mk ki nx kj mm kl ny km mo ko nz kp mq mr bi translated">你自己试试！</h1><blockquote class="pb pc pd"><p id="b342" class="ms mt oz mu b mv nn kd mx my no kg na pe np nd ne pf nq nh ni pg nr nl nm lt im bi translated">你能创建一个函数来遍历字符串“Hello World”中的每个字母，并且只打印H、W、l、r、o或D中的一个字母吗？</p></blockquote><p id="a5f3" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">我们要做的第一件事当然是定义我们的hello world字符串变量。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="cab7" class="ot mb it op b gy ou ov l ow ox">Hello = "hello world"</span></pre><p id="34fa" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">接下来，让我们写一个函数。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="8780" class="ot mb it op b gy ou ov l ow ox"><strong class="op jd">function</strong> filterstring(input)</span></pre><p id="a67b" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">该方法的下一步是遍历字符串中的每个字符。为此，我们可以用for循环调用字符串。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="d4d1" class="ot mb it op b gy ou ov l ow ox"><strong class="op jd">for</strong> character in input</span></pre><p id="2fe5" class="pw-post-body-paragraph ms mt it mu b mv nn kd mx my no kg na nb np nd ne nf nq nh ni nj nr nl nm lt im bi translated">接下来，我们需要检查该值是否在我们想要打印的值列表中。每当我们想要检查某个东西时，我们很可能会使用条件。对于这个例子，你可以使用to方法。其中一个是新手方法，另一个要简单得多。创建一个可接受值的列表并检查循环元素是否在该列表中，或者为每个单独的字符创建一个条件。无论哪种方式，都会产生相同的结果，坦率地说，只是简单和容易得多。</p><pre class="ks kt ku kv gt oo op oq or aw os bi"><span id="7cbc" class="ot mb it op b gy ou ov l ow ox"><strong class="op jd">function</strong> filterstring(input)<br/>    validchars = ['H', 'W', 'l', 'r', 'o', 'd']<br/>    <strong class="op jd">for</strong> character in input<br/>        <strong class="op jd">if</strong> character in validchars<br/>            print(character)<br/>        <strong class="op jd">end</strong><br/>    <strong class="op jd">end</strong><br/><strong class="op jd">end</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/6719023667f4b978c7c9de64de928863.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*Z-c9U7V3j5m4womfToohvw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="5e16" class="ma mb it bd mc md me mf mg mh mi mj mk ki nx kj mm kl ny km mo ko nz kp mq mr bi translated">结论</h1><p id="6b0b" class="pw-post-body-paragraph ms mt it mu b mv mw kd mx my mz kg na nb nc nd ne nf ng nh ni nj nk nl nm lt im bi translated">恭喜你！你正在成为一名优秀的Julia开发者。虽然事情在开始时看起来很复杂，但是您需要获得的大部分知识，至少在开始时，将会学习更多使用操作符、条件、类型和循环来处理数据的方法。虽然还有更多的东西需要学习，但是在这些教程中已经介绍了用Julia语言编程的基础知识。</p></div></div>    
</body>
</html>