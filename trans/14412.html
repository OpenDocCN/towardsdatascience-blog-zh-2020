<html>
<head>
<title>Stop Sign Detection Using Logistic Regression — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于逻辑回归的停车标志检测——第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/stop-sign-detection-using-logistic-regression-part-i-315f7c0c8636?source=collection_archive---------37-----------------------#2020-10-04">https://towardsdatascience.com/stop-sign-detection-using-logistic-regression-part-i-315f7c0c8636?source=collection_archive---------37-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d9b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将使用二进制逻辑回归来训练Python中的红色分类器。</p><p id="3ecb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持教程相对简短，我将它分为两部分——第一部分:使用逻辑回归创建颜色分类器。第二部分:使用从颜色分类器获得的二值掩码检测停车标志。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6f6212eb60ec4e5385ec4ab3114c38a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bz43csMCLMaKNMs8NlE68g.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@freetousesoundscom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">免费使用声音</a>在<a class="ae lc" href="https://unsplash.com/s/photos/stop-sign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="2da1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi ld translated">任何机器学习问题的第一步都涉及到访问一个好的训练数据集——在我们的例子中，我们需要仅由红色组成的图像(正样本)，以及包含除红色之外的其他颜色的图像(负样本)。我能够创建一个数据集，它有一个不同的红色图像池，这些图像是在不同的照明条件下从停车标志中提取的。这些光照变化将允许我们训练相对健壮的颜色分类器。除了红色之外的颜色被包括在训练集中作为负样本。你可以在我的GitHub上找到数据集:<a class="ae lc" href="https://github.com/MariaHarris24/StopSign_detection" rel="noopener ugc nofollow" target="_blank">https://github.com/MariaHarris24/StopSign_detection</a>。</p><p id="8568" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我说明本教程的编码部分之前，我们首先需要理解逻辑回归的基本原理和训练它所涉及的数学。</p><h1 id="252c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">作为分类问题的颜色分割</h1><p id="847f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">逻辑回归是一种判别模型，即，它模拟条件概率分布<strong class="jp ir">P(y | x；w) </strong>使用Sigmoid函数:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/fef63722ebd262ee3c21019008279a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*eejz-nLW2JfvybIbuDmETQ.png"/></div></figure><p id="c2a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，'<strong class="jp ir"> x </strong>是指单个像素值，而'<strong class="jp ir"> y </strong>'是标量(-1或1)，是与像素x相关联的标签，'<strong class="jp ir"> ω </strong>'是训练时需要学习的权重参数。</p><p id="5778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面您可以看到sigmoid函数的数学和图形表示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mq"><img src="../Images/71d89b7cf92f1930ed90eea61f95dd89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRPmabwtUjp-jifYrvh95w.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">Sigmoid函数——作者图片</p></figure><p id="b385" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">sigmoid函数具有将连续值转换为伯努利(离散)分布的特性，而伯努利分布又可用于分类目的。从上图中我们可以看到，对于k 的较大值，该函数将产生1，对于k 的较小值，该函数将产生0。需要注意的是，当我们处理两个类之间的分类时，即二元分类(这是我们的情况)时，使用sigmoid。对于两个以上/多类分类，使用softmax函数。</p><p id="7d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经对sigmoid如何工作有了直观的了解，我们现在需要估计权重参数“ω”,以便我们能够最大化条件概率P(y | x；ω) —从数学上讲，这可以写成如下形式:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/65b7993417b584a75943646774d48e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*eaYs0_RykTS3fy0gqsUzdg.png"/></div></figure><blockquote class="ms mt mu"><p id="17b6" class="jn jo kl jp b jq jr js jt ju jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj kk ij bi translated">上面的等式是MLE版本，我不会在文章中涉及这个主题。我只是想提一下，这样你就可以验证这个等式的来源了。</p></blockquote><p id="40c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于上面的等式，可以通过使用梯度下降来获得‘ω’的最佳值。由于梯度下降涉及到<strong class="jp ir"> <em class="kl">最小化</em> </strong>一个函数；因此，我们将使用log p的<strong class="jp ir"> <em class="kl">负</em></strong>(y | x；ω)作为最小化的函数，这在数学上等同于上面的等式。我们现在可以为我们的问题写出梯度下降方程如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/e5ea0afbf631f7f8d72648106b68e059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*rwAcRxWKgeiKYMYiYLpUVQ.png"/></div></figure><p id="59e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给出梯度下降的快速入门；这是一种优化技术，可用于迭代寻找函数的最小值。这个最小值可能是/可能不是全局最小值。梯度下降背后的直觉是，我们对我们试图寻找最小值的函数求导。这个导数本质上是函数的切线/斜率，我们的目标是向与此相反的方向移动，即负梯度的方向，直到我们达到最小值。收敛速度由称为学习速度"<strong class="jp ir">α"-</strong>的参数决定，这决定了每次迭代过程中的步长(移动量)。</p><p id="0d41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">太好了！我们已经奠定了这一切背后的基础数学，现在我们可以实际编写代码来训练我们的颜色分类器。</em></p><h1 id="69cf" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">导入数据集:</h1><p id="215f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">首先，我们需要加载和重塑我们的训练数据。下面你可以找到一个函数的代码，这个函数将从指定的文件夹中读取图像，并将它们堆叠成一个Nx3矩阵。这里，单独的三个通道(RGB)将用作特征，三个RGB通道中每个通道的像素值将填充特征空间，这就是为什么我们有一个Nx3矩阵。此外，该函数还将为每个像素值生成适当的标签:红色为1，其他颜色为-1。请确保为“label_val”参数传入正确的值，因为这决定了对应于像素的标签将占用什么值。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="4b54" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">培训:</h1><p id="18bc" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">一旦我们加载了训练数据，下一步就是使用梯度下降来训练颜色分类器(参考下面的代码)。该函数返回参数“ω”的向量(3x1)。我们将使用这个参数来描述我们在测试部分中解释的分类边界。您可以更改学习率和迭代次数。为了检查收敛性，我绘制了以前的ω和现在的ω之间的差异。如果它们之间的绝对差异在几次迭代中非常小，这表明我们很可能已经获得了最小值。但是，一定不要通过大量迭代训练分类器来过度拟合数据。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一点要澄清的是，梯度下降的代码实现与我之前引用的公式不同；这是因为代码是矢量化的格式(效率要高得多)，而不是前面提到的基于元素的公式。</p><h1 id="7373" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">测试:</h1><p id="755f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">逻辑回归生成一个线性决策边界，由等式<strong class="jp ir">x .ω= 0</strong>(x和ω的点积)描述。因此，对于<strong class="jp ir"> x.ω≥0，</strong>即位于或高于线性边界的像素值将被预测为红色正像素，而对于<strong class="jp ir"> x.ω &lt; 0，</strong>该像素将被预测为红色负像素。这可以通过参考下图的两个特征来更好地理解:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nb"><img src="../Images/3c0d35f9cb287480d4689c05232976b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sd-8-N6lb33kYiytlJmD4Q.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">使用x.w=0的点分类示例-按作者分类的图像</p></figure><p id="29b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一步的代码非常简单。我们将测试图像和ω发送到一个函数，该函数执行两者之间的点积，然后根据前面提到的点积标准对像素进行分类。对于分类步骤，我们将为预测为红色的像素分配值255，为预测为非红色的像素分配值0，这样我们将获得二进制掩码。该函数的代码如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d397" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原始图像及其二进制遮罩如下所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nc"><img src="../Images/30d62f3cd6702dae1e05181e66a64409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbBuwsQtcmV9-iUX7XUCbA.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">左图:原图(照片由<a class="ae lc" href="https://unsplash.com/@will0629?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威尔·波拉达</a>在<a class="ae lc" href="https://unsplash.com/s/photos/stop-sign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)。右图:二进制掩码</p></figure><p id="4455" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，我们的分类器能够分割红色像素。接下来，我们需要使用某种形状检测标准来辨别停车标志的形状。这将在第二部分讨论。感谢您的阅读！</p></div></div>    
</body>
</html>