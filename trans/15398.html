<html>
<head>
<title>Implementing Naive Bayes Algorithm from Scratch — Python.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始实现朴素贝叶斯算法。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-naive-bayes-algorithm-from-scratch-python-c6880cfc9c41?source=collection_archive---------5-----------------------#2020-10-23">https://towardsdatascience.com/implementing-naive-bayes-algorithm-from-scratch-python-c6880cfc9c41?source=collection_archive---------5-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3ef1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我将展示朴素贝叶斯分类器的一个基本实现，以及它是如何工作的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5195ad127d2c89e4feb589f04644b69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0a2wA8H1nbyEXILf0WBcHA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自www.i2tutorials.com</p></figure><h2 id="fdb1" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">简介</strong></h2><p id="98af" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">朴素贝叶斯分类器是一种非常流行的基于贝叶斯定理的监督机器学习算法。这是一种简单但非常强大的算法，适用于大型数据集和稀疏矩阵，如预处理的文本数据，它根据字典中的单词数创建了数千个向量。它在文本数据项目(如情感数据分析)中工作得非常好，在文档分类项目中表现良好，并且在预测分类数据(如垃圾邮件分类)中也非常出色。</p><p id="0404" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">它用于解决许多不同的问题陈述，并且在训练模型时非常快，因为朴素贝叶斯分类器完全在概率上工作，所以转换发生得很快。</p><h2 id="1f0b" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">理解背后的数学和统计学</h2><p id="ab99" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">贝叶斯定理描述了一个事件发生的概率，基于可能与该事件相关的条件的先验知识。</p><p id="58ef" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">首先，我们来看一个条件概率的公式，并尝试推导贝叶斯定理:</p><p id="7f4d" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">P(B|A) = P(A∩B)/P(B)，</p><p id="af57" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">其中，给定A的B的概率，即事件A已经发生时事件B的概率，等于交集B的概率(即A和B事件都发生的概率)除以B的概率。</p><p id="9da4" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">或者P(A|B) = P(B∩A)/P(A)，</p><p id="ea25" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">其中，给定B的概率，即事件B已经发生时事件A的概率，等于B交集A的概率(即B和A事件都发生的概率)除以A的概率。</p><p id="6671" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们再仔细看看，我们看到P(A∩B)和P(B∩A)基本相同，可以写成P(A∩B) = P(B∩A)。由于它们是相同的，我们可以得到两个公式，并将分母移到等式的左边:</p><p id="1008" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">P(A∩B) = P(A|B) * P(B)，P(B∩A) = P(B|A) * P(A)并使它们相等:</p><p id="f2bb" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">P(A|B) * P(B) = P(B|A) * P(A)。</p><p id="b920" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">所以，当我们想找到给定B的概率时，我们可以这样写方程:</p><p id="0412" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><strong class="lt ir"> P(A|B) = P(B|A) * P(A) / P(B) </strong>，这是贝叶斯定理的方程式。</p><h2 id="a8dd" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">贝叶斯定理方程在算法中的应用</h2><p id="826e" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">让我们打破我们的等式，了解它是如何工作的:</p><ul class=""><li id="5cf4" class="mp mq iq lt b lu mk lx ml le mr li ms lm mt mj mu mv mw mx bi translated"><strong class="lt ir"> P(A|B) </strong>是给定<em class="my">预测器</em> ( <em class="my">属性</em>)的<em class="my">类</em> ( <em class="my">目标</em>)的后验概率。</li><li id="78eb" class="mp mq iq lt b lu mz lx na le nb li nc lm nd mj mu mv mw mx bi translated"><strong class="lt ir"> P(B) </strong>是<em class="my">类</em>的先验概率。</li><li id="3bbe" class="mp mq iq lt b lu mz lx na le nb li nc lm nd mj mu mv mw mx bi translated"><strong class="lt ir"> P(B|A) </strong>为似然性，即<em class="my">预测器</em>给定<em class="my">类</em>的概率。</li><li id="b206" class="mp mq iq lt b lu mz lx na le nb li nc lm nd mj mu mv mw mx bi translated"><strong class="lt ir"> P(A) </strong>是<em class="my">预测器</em>的先验概率。</li></ul><p id="72d6" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">为了计算后验概率，首先我们需要计算每个属性相对于目标的频率。然后，将频率转换为似然值，最后使用朴素贝叶斯方程计算每类的后验概率。具有最高后验概率的类是预测的结果。</p><p id="df03" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">在我的例子中，我使用了两个数据集:</p><ol class=""><li id="3695" class="mp mq iq lt b lu mk lx ml le mr li ms lm mt mj ne mv mw mx bi translated"><a class="ae nf" href="http://archive.ics.uci.edu/ml/datasets/Iris/" rel="noopener ugc nofollow" target="_blank"> Iris </a>数据集预测花的类型</li><li id="e5d6" class="mp mq iq lt b lu mz lx na le nb li nc lm nd mj ne mv mw mx bi translated"><a class="ae nf" href="https://archive.ics.uci.edu/ml/datasets/spambase" rel="noopener ugc nofollow" target="_blank">垃圾邮件数据库</a>用于检测电子邮件是否包含垃圾邮件的数据集</li></ol><p id="4e02" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">由于两个数据集都有连续的属性，我选择了高斯分布来估计朴素贝叶斯分类器中似然概率的参数。该分布由两个参数表征，均值和方差。高斯密度函数的公式，来源于维基百科，看起来是这样的:<strong class="lt ir">(1/√2pi *σ)* exp((-1/2)*((x-μ))/(2 *σ))</strong>，其中μ是均值，σ是方差，σ是方差的平方根(标准差)。</p><p id="5388" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">首先，我们需要计算每一列的平均值和方差，并将其转换为numPy数组，以便将来计算:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算每列的平均值和方差</p></figure><p id="6d60" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">接下来，让我们将高斯密度函数转换为代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从高斯密度函数计算概率</p></figure><p id="f7c9" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">最后一步是计算先验和后验概率:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="1ecb" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">做预测</h2><p id="dac4" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">最后，所有的助手方法现在都可以在fit和predict方法中使用了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拟合和预测方法</p></figure><p id="f050" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">在对鸢尾花分类数据训练我的模型后，我得到了非常好的92%的准确率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/9f54617ce01d7b66336daf02646d2619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZhCXkfqASn5mNUYhTn8aWA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">鸢尾花分类中的真实与预测</p></figure><p id="27e4" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我将它与scikit-learn高斯贝叶斯分类器进行了比较，得到了相同的结果，这非常令人印象深刻，因为我的算法只是准系统，需要很多改进。</p><p id="f410" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">对于电子邮件垃圾分类问题，我的模型仅执行了78%的准确率，然而它与scikit-learn高斯贝叶斯分类器的准确率81.8%相差不远。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/7272cad6eb15d23d70b3f7ed784140ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGB7lZywEdAYgB8lr36mTA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">垃圾邮件分类中的真实值与预测值</p></figure><h2 id="60f1" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h2><p id="31bc" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我的朴素贝叶斯分类器算法实现远非理想，它需要许多改进和修改才能做出更好的预测，尤其是对文本数据，然而，与sklearn库的算法相比，它的性能仍然非常好。</p><p id="d6de" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">注意:</p><p id="cbbe" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">这个项目是为<strong class="lt ir"> Lambda学校(Bloom Technology now) </strong>做的，作为<strong class="lt ir">计算机</strong> <strong class="lt ir">科学</strong>课程的一部分。</p><p id="d56c" class="pw-post-body-paragraph lr ls iq lt b lu mk jr lw lx ml ju lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">代码实现的Github链接:<a class="ae nf" href="https://github.com/tigju/Naive-Bayes-Classifier-from-scratch" rel="noopener ugc nofollow" target="_blank">从头开始的朴素贝叶斯分类器</a></p></div></div>    
</body>
</html>