<html>
<head>
<title>5 advanced Pytest tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个高级Pytest技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-advanced-pytest-tricks-c5d733b2acc7?source=collection_archive---------40-----------------------#2020-11-02">https://towardsdatascience.com/5-advanced-pytest-tricks-c5d733b2acc7?source=collection_archive---------40-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ea56" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="c419" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Pytest是一个非常强大的工具，但是很多项目没有利用它提供的所有特性。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7758891f593d3951f57e9491d80e1eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pcuSODH_Anc89QPuxVAAMw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="d837" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们编写测试是因为它们帮助我们建立对代码的信心。它们还帮助我们编写干净和可维护的代码。然而，编写测试需要一些努力。幸运的是，我们可以利用一些库。例如，Pytest附带了许多经常不被使用的便利特性。在这篇文章中，我将向你介绍其中的5种。</p><h2 id="e352" class="ma mb iq bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr iw bi translated">用caplog设备测试测井</h2><p id="947b" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">有时，日志记录是您的功能的一部分，您希望确保以预期的日志记录级别记录正确的消息。</p><p id="a10a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您可以利用一个名为caplog的内置设备。<a class="ae mx" href="https://docs.pytest.org/en/stable/reference.html#caplog" rel="noopener ugc nofollow" target="_blank">这个固定装置</a>允许你访问和控制日志捕获。</p><p id="ea9b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们通过一个基本示例来看看它的实际应用。假设你有一个函数可以将一种语言中的动物名称翻译成另一种语言。如果翻译词典中缺少一种动物，您需要确保记录该动物，以便最终将其添加到词典中。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9227" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这里我们使用了<code class="fe na nb nc nd b">record_tuples</code>，一个由记录器名称、级别和消息组成的元组列表。这是一个简单的例子，但是你可以做得更好。</p><h2 id="d7d4" class="ma mb iq bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr iw bi translated">引发了测试异常</h2><p id="fb11" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">测试允许您验证代码在面临边缘情况时的行为。当涉及到边缘情况时，您经常会抛出异常。Pytest帮助您<a class="ae mx" href="https://docs.pytest.org/en/reorganize-docs/new-docs/user/pytest_raises.html" rel="noopener ugc nofollow" target="_blank">验证异常是否如预期的那样被引发</a>。</p><p id="ed49" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们用一个真实的例子来看看它是如何工作的。比方说，您想要编写一个CLI应用程序的身份验证层。验证电子邮件地址格式可能是个好主意。</p><p id="a64e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您的CLI应用程序使用<a class="ae mx" href="https://click.palletsprojects.com/en/7.x/" rel="noopener ugc nofollow" target="_blank"> Click </a>，这是一个帮助您更快构建CLI应用程序的包。Click附带了很多便利的功能，比如通过<a class="ae mx" href="https://click.palletsprojects.com/en/7.x/parameters/#parameter-types" rel="noopener ugc nofollow" target="_blank">输入</a>进行输入验证。然而，电子邮件地址不是内置的点击类型，所以我们需要自己进行输入验证。我们将使用<a class="ae mx" href="https://click.palletsprojects.com/en/7.x/options/#callbacks-for-validation" rel="noopener ugc nofollow" target="_blank">验证回调</a>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="dfe4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因此，您所要做的就是使用<code class="fe na nb nc nd b">pytest.raises()</code>上下文管理器，然后调用函数，Pytest会处理剩下的事情！</p><h2 id="de60" class="ma mb iq bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr iw bi translated">测试时间相关函数</h2><p id="a8bd" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">操纵日期总是困难的。编写测试可以给我们很大帮助。然而，当你调用像<code class="fe na nb nc nd b">today()</code>或<code class="fe na nb nc nd b">now()</code>这样的方法时，你会遇到测试依赖于时间的棘手情况。为了解决这个问题，你可以使用<a class="ae mx" href="https://pypi.org/project/pytest-freezegun/" rel="noopener ugc nofollow" target="_blank"> pytest-freezegun </a>插件，而不是从标准库中打补丁。这个插件让事情变得简单。</p><p id="a178" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">又是一个例子的时候了！这一次，您需要实现一个函数来计算自用户订阅您的服务以来的天数。幸运的是，你已经阅读了这篇文章，并且知道了<code class="fe na nb nc nd b">pytest-freezegun</code>插件😉</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="30fa" class="ma mb iq bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr iw bi translated">用不同的参数组合测试相同的函数</h2><p id="004f" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">大多数时候，您希望针对不同的输入来测试您的函数。在这种情况下，最简单的解决方案是为所有参数组合复制代码。但是，这不是一个好的做法，你应该避免这样做。假设你想对你的测试做一个小的调整，你需要复制你的代码多少次就复制多少次。第二，在性能方面，测试是顺序运行的，速度很慢。您可以并行执行。</p><p id="69e4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">避免这些常见问题的解决方案是使用<a class="ae mx" href="https://docs.pytest.org/en/stable/example/parametrize.html" rel="noopener ugc nofollow" target="_blank">参数化测试</a>。让我们回到电子邮件验证的例子。你可能想过<em class="ne">“很多情况没有覆盖”</em>。嗯，我同意，是时候解决这个问题了！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="58ee" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">看，你可以用<code class="fe na nb nc nd b">pytest.mark.parmaetrize</code>来描述你的输入，避免代码重复。</p><p id="94e5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果您运行这个测试，您将看到它失败了，这很好，因为它证明了我们的测试是有用的，并且有很好的覆盖率！</p><h2 id="5e04" class="ma mb iq bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr iw bi translated">额外小费</h2><p id="a3ac" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">因为你几乎一直读到最后，我想给你一个额外的提示来感谢你🙂</p><p id="2d21" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">上一个例子中的一种情况导致测试失败。现在您想要更正代码并重新运行失败的测试。如果您有一个大型的测试套件，重新运行整个测试套件是非常耗时的。相反，您可以运行:</p><pre class="kp kq kr ks gt nf nd ng nh aw ni bi"><span id="b41d" class="ma mb iq nd b gy nj nk l nl nm">pytest --last-failed test_parametrized.py</span></pre><p id="2e78" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">它将只执行最后一个失败的测试，从而允许您快速迭代并修复那个bug。一旦测试通过，不要忘记运行所有测试以避免任何回归。</p><h2 id="1442" class="ma mb iq bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr iw bi translated">结论</h2><p id="c256" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">这是一个总结！Pytest非常强大，一篇博文太短，无法涵盖所有特性。这是另一个教程的绝佳机会！🤗</p><h2 id="4226" class="ma mb iq bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr iw bi translated">参考</h2><p id="5828" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">[1] Pytest官方文档</p><div class="nn no gp gr np nq"><a href="https://docs.pytest.org/en/stable/contents.html" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ja gy z fp nv fr fs nw fu fw iz bi translated">完整的pytest文档</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">测试中断言的编写和报告</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">docs.pytest.org</p></div></div></div></a></div><p id="08cd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[2] Dane Hillard，<a class="ae mx" href="https://realpython.com/pytest-python-testing/" rel="noopener ugc nofollow" target="_blank">有效的Python与Pytest </a> (2020)，真正的Python</p><div class="nn no gp gr np nq"><a href="https://realpython.com/pytest-python-testing/" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ja gy z fp nv fr fs nw fu fw iz bi translated">用Pytest - Real Python进行有效的Python测试</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">在本教程中，您将学习如何使用pytest将您的测试提升到一个新的水平。你将负责中级和…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">realpython.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ky nq"/></div></div></a></div></div></div>    
</body>
</html>