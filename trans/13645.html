<html>
<head>
<title>Generative Adversarial Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成对抗网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generative-adversarial-networks-6a17673db367?source=collection_archive---------13-----------------------#2020-09-19">https://towardsdatascience.com/generative-adversarial-networks-6a17673db367?source=collection_archive---------13-----------------------#2020-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="18fb" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">深度学习</h2><div class=""/><div class=""><h2 id="19f4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用解读甘博弈</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/8ce8a6342c6e41bacf83851e9c6c20c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YitjqXaAUO-97D2x"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">阿曼达·达尔比约恩在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="a246" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是生成性对抗网络？</h1><p id="d564" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">由<a class="ae lh" href="https://en.wikipedia.org/wiki/Ian_Goodfellow" rel="noopener ugc nofollow" target="_blank"> Ian Goodfellow </a>和他的同事在2014年设计的GANs由两个神经网络组成，它们在零和游戏中一起训练，其中一个玩家的损失是另一个玩家的收益。</p><p id="8985" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了理解GANs，我们需要熟悉生成模型和判别模型。T9】</p><p id="f7f2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd"> <em class="nb">创成式模型</em> </strong> <em class="nb">尝试使用训练集中的分布输出新的数据点。这些模型生成新的数据实例。这些模型捕捉联合概率p(X，Y) </em></p><p id="e066" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">生成模型的类型<br/> </strong> 1。显式密度模型<br/> 2。隐式密度模型</p><p id="70b0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nb">显式密度模型定义了显式密度函数，而隐式密度模型定义了可直接生成数据的随机程序。</em></p><p id="c185" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果您有兴趣阅读更多关于生成模型的内容，请查看下面这个流行的GitHub知识库。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/wiseodd/generative-models" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jd gy z fp nk fr fs nl fu fw jc bi translated">wise odd/生成模型</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">生成模型的集合，例如GAN、Pytorch中的和Tensorflow。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt lb nf"/></div></div></a></div><p id="108e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd"> <em class="nb">另一方面，判别模型</em> </strong> <em class="nb">捕捉条件概率p(X/Y)，它们区分不同的数据实例。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/043632c96a02750e5b4be7c9300384b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*wYEVmlHOfaV1YekJUf4Orw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://developers.google.com/machine-learning/gan/generative" rel="noopener ugc nofollow" target="_blank">图片来源:谷歌开发者。</a>根据知识共享署名4.0许可证进行许可。</p></figure><p id="76c5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">生成模型解决困难的任务。与辨别模型相比，注意力细节的水平更高。简单地说，生成模型做更多的工作。生成模型试图尽可能接近真实的数据分布。</p><p id="58fa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在上图中，我们可以看到判别模型试图分离0和1的数据空间。而生成模型非常接近0和1的数据空间。</p><blockquote class="nv"><p id="eb9f" class="nw nx it bd ny nz oa ob oc od oe mv dk translated">现在你知道了生成模型和判别模型的基本定义，让我们来学习一下gan。</p></blockquote></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="b842" class="li lj it bd lk ll om ln lo lp on lr ls ki oo kj lu kl op km lw ko oq kp ly lz bi translated">鉴别器和发生器网络GAN游戏</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/9506fb74afb15136ed9f315315c20ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YX9elEWQh5lPqjZ7"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="nv"><p id="ecb4" class="nw nx it bd ny nz os ot ou ov ow mv dk translated">生成对抗网络是一种生成模型。它们并行生成完整的图像。GANs由两个网络组成:鉴别器和发电机网络</p></blockquote><figure class="oy oz pa pb pc kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/d439045235aad4d32386aa025044b585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNPLBYjVDIAinfI5MPMOjg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://developers.google.com/machine-learning/gan/gan_structure" rel="noopener ugc nofollow" target="_blank">图片来源:谷歌开发者。</a>根据知识共享署名4.0许可证获得许可。</p></figure><p id="867e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd"> <em class="nb">甘斯使用了一个可微函数。这通常是一个神经网络。我们称之为发电机网络。</em> </strong> <em class="nb">本发电机网络采用随机输入。这些输入是噪声。这种噪声被提供给一个可微分函数，该函数将其转换和整形为一个可识别的结构。这可能是一个镜像，它高度依赖于可微分函数输入端的噪声。</em></p><p id="56d8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对于各种噪声输入，我们可以生成许多图像。然而，生成器网络不会立即给出真实的图像。我们需要训练它。</p><blockquote class="nv"><p id="3d22" class="nw nx it bd ny nz oa ob oc od oe mv dk translated">我们如何训练这个发电机网络？可能和其他网络一样？其实没有！</p></blockquote><p id="6576" class="pw-post-body-paragraph ma mb it mc b md pd kd mf mg pe kg mi mj pf ml mm mn pg mp mq mr ph mt mu mv im bi translated">生成器网络看到许多图像，并试图输出类似于相同概率分布的东西。这是怎么做到的？👀</p><p id="98b0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd"> <em class="nb">鉴别器来了，常规的神经网络分类器。鉴别器引导我们的发电机网络。</em>T11】</strong></p><p id="1a1f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为简单起见，我们称发电机网络的<strong class="mc jd">输出图像为假图像。</strong>发生器的输出，即假图像，作为输入提供给鉴别器。<strong class="mc jd">鉴别器还从训练数据中看到所谓的真实图像。</strong>鉴别器然后输出输入是真实图像的概率。所以1代表真实图像，0代表虚假图像。与此同时，生成器还试图输出可能被鉴别器赋予概率为1的图像。</p><p id="0e5e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">大多数机器学习模型试图通过优化参数来最小化一些成本函数。如果我们给GANs分配成本函数，我们可以说鉴别器的成本是发电机成本的负数，反之亦然。</p><p id="3ef0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，让我们通过假设鉴别器和生成器是两个参与者，a是一个函数f，来理解GANs是如何工作的。</p><p id="95eb" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">发生器试图减少函数f的输出值，而鉴别器试图增加它。让我们假设这样做，直到我们达到一个平衡，在这个平衡中，发生器不能减少函数f的输出值，鉴别器也不能增加它。由于我们同时使用两种优化算法，一种用于发生器，另一种用于鉴别器，我们可能永远达不到平衡。亚当优化器是一个很好的选择。</p><p id="1b42" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">简单来说，发生器和鉴别器竞争，发生器给鉴别器假数据。鉴别器也看到训练数据，预测接收到的图像是真的还是假的。</p><p id="4129" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">看看下面这个来自谷歌开发者机器学习速成班的例子。</p><p id="38c3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">生成器从不切实际的图像开始，很快学会了愚弄鉴别者。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/e58a79b433b99fc142d2ff157ae1386b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgRW9RZTPMnl4c3mDqlHkw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://developers.google.com/machine-learning/gan/gan_structure" rel="noopener ugc nofollow" target="_blank">图片来源:谷歌开发者。</a>根据知识共享署名4.0许可证获得许可。</p></figure><p id="a3f2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，随着时间的推移，生成器被训练来欺骗鉴别器，使其看起来像鉴别器看到的真实图像一样。</p><h2 id="7241" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">那么训练过程是怎样的呢？</h2><p id="fe3a" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在鉴别器的训练过程中，显示真实图像并使用计算鉴别器损失。它对来自生成器的真实和虚假图像进行分类，如果任何图像被错误分类，鉴别器损失惩罚鉴别器。通过反向传播，鉴别器更新其权重。</p><p id="a491" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">类似地，发生器被给予噪声输入以产生假图像。这些图像被提供给鉴别器，并且发生器损耗惩罚发生器产生被鉴别器网络分类为假的样本。权重通过从鉴别器到生成器的反向传播来更新。</p><p id="d3e8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">需要注意的是，在鉴频器训练阶段，发生器必须保持不变。同样，鉴别器在发电机训练阶段保持不变。因此，GAN训练以交替的方式进行。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="02c4" class="li lj it bd lk ll om ln lo lp on lr ls ki oo kj lu kl op km lw ko oq kp ly lz bi translated">甘</h1><blockquote class="nv"><p id="c17b" class="nw nx it bd ny nz oa ob oc od oe mv dk translated">在本节中，我们将学习设计一个GAN，它可以生成手写数字的新图像。我们将使用著名的MNIST数据集。<a class="ae lh" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank">拿过来。</a></p></blockquote><h2 id="6dcd" class="pj lj it bd lk pk pu dn lo pm pv dp ls mj pw pp lu mn px pr lw mr py pt ly iz bi translated">鉴别器架构</h2><p id="3bc2" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">鉴别器将会是一个典型的线性分类器。</p><p id="8326" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们将使用的激活函数是<a class="ae lh" href="https://pytorch.org/docs/stable/nn.html#torch.nn.LeakyReLU" rel="noopener ugc nofollow" target="_blank">泄漏ReLu </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/7eeaa54735c486142d1ab65c18c682a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*apKmKLQ0PXZrEVe7H-cx0w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://pytorch.org/docs/stable/generated/torch.nn.LeakyReLU.html#torch.nn.LeakyReLU" rel="noopener ugc nofollow" target="_blank">图片来自PyTorch文档</a>。(开源)</p></figure><p id="a824" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">为什么会漏ReLu？我们应该使用一个泄漏的ReLU来允许梯度不受阻碍地通过图层回流。泄漏的ReLU类似于正常的ReLU，除了对于负输入值有一个小的非零输出。</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa qb l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者代码。</p></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h2 id="2d4b" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">发电机架构</h2><p id="2298" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">生成器使用潜在样本制作假图像。这些潜在样本是映射到伪图像的向量。一个<strong class="mc jd"> </strong>潜在向量只是一个图像的压缩的特征级表示！</p><p id="df57" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了理解什么是潜在样本，考虑一个自动编码器。连接网络的编码器和解码器部分的输出由压缩表示组成，该压缩表示也可以称为<strong class="mc jd">潜在向量。</strong></p><p id="22c9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">所有层的激活函数保持不变，除了我们将在输出中使用<a class="ae lh" href="https://pytorch.org/docs/stable/generated/torch.nn.Tanh.html#torch.nn.Tanh" rel="noopener ugc nofollow" target="_blank"> Tanh </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qc"><img src="../Images/103b1f2a62cba3c8a3255fd30677891c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pq3FdNAzvu_TFAP3j5r3ZA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://pytorch.org/docs/stable/generated/torch.nn.Tanh.html#torch.nn.Tanh" rel="noopener ugc nofollow" target="_blank">图片来自PyTorch文档</a>。(开源)</p></figure><p id="c15f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">为什么在输出端出现Tanh？</strong> <br/>已经发现，对于发电机输出的𝑡𝑎𝑛ℎtanh，发电机表现最佳，其将输出缩放到-1和1之间，而不是0和1。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa qb l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者代码。</p></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h2 id="89a7" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated"><strong class="ak">缩放图像</strong></h2><p id="49e4" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们希望生成器的输出与真实图像的像素值相当，后者是0到1之间的归一化值。因此，当我们训练鉴别器时，我们还必须缩放我们的实际输入图像，使像素值在-1和1之间。<br/>这将在培训阶段完成。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h2 id="4c4d" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">一般化</h2><p id="c78b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为了帮助鉴别器更好地归纳，标签<strong class="mc jd">从1.0减少到0.9 </strong>。为此，我们将使用参数smooth如果是真的，那么我们应该平滑我们的标签。在PyTorch中，这看起来像:<br/> <code class="fe qd qe qf qg b">labels = torch.ones(size) * 0.9</code></p><p id="e3ae" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们还利用了脱落层来避免过度拟合。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h2 id="fccf" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">损失计算</h2><p id="7811" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">鉴别器的目标是为真实图像输出1，为虚假图像输出0。另一方面，生成器希望制作与真实图像非常相似的假图像。</p><p id="0871" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="nb">由此我们可以说如果</em><strong class="mc jd"><em class="nb">【D】</em></strong><em class="nb">代表了对于鉴别器的损失，那么下面可以陈述:<br/> </em> <strong class="mc jd"> <em class="nb">鉴别器的目标:</em></strong><em class="nb">D(real _ images)= 1&amp;D(fake _ images)= 0<br/></em><strong class="mc jd"><em class="nb">目标生成器:</em> </strong> <em class="nb"> D(real_images)=)</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa qb l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者代码</p></figure><p id="f9a6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们将使用<a class="ae lh" href="https://pytorch.org/docs/stable/nn.html#bcewithlogitsloss" rel="noopener ugc nofollow" target="_blank"> BCEWithLogitsLoss </a>，它结合了一个sigmoid激活函数(我们希望鉴别器输出一个0–1的值，指示一个图像是<em class="nb">真实的还是伪造的</em>)和二进制交叉熵损失。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qh"><img src="../Images/ce6b6dc52bb305d02fc6ed69137a76ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*1I9MpiCXDgoY2XvY42tYQA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Binar交叉熵损失方程。图片由作者提供。</p></figure></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h2 id="6a16" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">培养</h2><p id="2ad0" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如前所述，Adam是一个合适的优化器。</p><p id="7946" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">生成器接收一个向量z并输出假图像。鉴别器在真实图像的训练和由生成器产生的伪图像的训练之间交替。</p><h2 id="d6d6" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">鉴别器培训中涉及的步骤:</h2><ol class=""><li id="1831" class="qi qj it mc b md me mg mh mj qk mn ql mr qm mv qn qo qp qq bi translated">我们首先计算真实图像的损失</li><li id="f696" class="qi qj it mc b md qr mg qs mj qt mn qu mr qv mv qn qo qp qq bi translated">生成假图像</li><li id="9c25" class="qi qj it mc b md qr mg qs mj qt mn qu mr qv mv qn qo qp qq bi translated">计算假图像的损失</li><li id="e243" class="qi qj it mc b md qr mg qs mj qt mn qu mr qv mv qn qo qp qq bi translated">添加真实和虚假图像的损失</li><li id="e97e" class="qi qj it mc b md qr mg qs mj qt mn qu mr qv mv qn qo qp qq bi translated">执行反向传播并更新鉴别器的权重</li></ol><h2 id="904f" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">发电机培训涉及的步骤:</h2><ol class=""><li id="554f" class="qi qj it mc b md me mg mh mj qk mn ql mr qm mv qn qo qp qq bi translated">生成假图像</li><li id="b1b4" class="qi qj it mc b md qr mg qs mj qt mn qu mr qv mv qn qo qp qq bi translated">计算带有反向标签的伪图像的损失</li><li id="008b" class="qi qj it mc b md qr mg qs mj qt mn qu mr qv mv qn qo qp qq bi translated">执行反向传播并更新生成器的权重。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa qb l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者代码。</p></figure><h2 id="7bd9" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">培训损失</h2><p id="5c2e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们将绘制发生器和鉴频器损耗与历元数的关系图。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa qb l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者代码。</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qw"><img src="../Images/bb87df2efe00c8e8b752ff85fea81554.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*ecT7umpag5-76EFjfqySpw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">培训损失。图片由作者提供。</p></figure><h2 id="a450" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">生成器生成的样本</h2><p id="3865" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><strong class="mc jd">开始时</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa qb l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者代码。</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qx"><img src="../Images/481855ac5309c6b929dda8a96ba57627.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*MCaDJSr7SeBcNMUWsJMexw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供。</p></figure><p id="9bc1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">加班</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa qb l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者代码。</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qy"><img src="../Images/146c02d6c84a790051ee21461d2834c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*rfpUrVtCrwKIVTJa3IMKuw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供。</p></figure><p id="d86c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这样，生成器从有噪声的图像开始，并随着时间的推移而学习。</p><blockquote class="qz ra rb"><p id="d71f" class="ma mb nb mc b md mw kd mf mg mx kg mi rc my ml mm rd mz mp mq re na mt mu mv im bi translated">您也可以在我的GitHub个人资料上查看代码和自述文件。</p></blockquote><div class="nc nd gp gr ne nf"><a href="https://github.com/NvsYashwanth/MNIST-GAN" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jd gy z fp nk fr fs nl fu fw jc bi translated">NvsYashwanth/MNIST甘</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">了解MNIST实施的GANs。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="rf l nq nr ns no nt lb nf"/></div></div></a></div></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="c4c3" class="li lj it bd lk ll om ln lo lp on lr ls ki oo kj lu kl op km lw ko oq kp ly lz bi translated">结论</h1><p id="a91a" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">自从蒙特利尔大学的Ian Goodfellow和他的同事设计出GANs以来，它们就大受欢迎。申请的数量惊人。GAN通过许多变体得到进一步改进，其中一些变体是循环GAN、条件GAN、渐进GAN等。<a class="ae lh" href="https://developers.google.com/machine-learning/gan/applications" rel="noopener ugc nofollow" target="_blank">要了解更多信息，请点击此链接</a>。现在打开一个Jupyter笔记本，尝试实现你所学到的任何东西。</p><h2 id="503f" class="pj lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">谢谢你。下一场见。</h2></div></div>    
</body>
</html>