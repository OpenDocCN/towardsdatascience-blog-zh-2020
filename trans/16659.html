<html>
<head>
<title>Practice With Python Comprehensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">练习Python理解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practice-with-python-comprehensions-af6f484a6e1e?source=collection_archive---------60-----------------------#2020-11-16">https://towardsdatascience.com/practice-with-python-comprehensions-af6f484a6e1e?source=collection_archive---------60-----------------------#2020-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a03c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于数据准备和特征提取</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0a2167bad247a7baab2a54f4fc2b563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uogTxM0a-lVa__VkjFBjew.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@hiteshchoudhary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>拍摄的照片</p></figure><p id="9501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们在数据准备和特征提取的各种例子上练习Python理解。我们希望让读者了解使用这种Python机制可以完成的各种任务。这篇文章也会引起数据科学新手的兴趣。</p><p id="e877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们先列举两个在数据科学建模中重复出现的核心数据模式。在数据准备和特征提取中。即使在机器学习算法中，尤其是对向量和矩阵进行操作的算法中。</p><p id="a9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图案是<em class="lv">聚合器</em>和<em class="lv">变压器</em>。两者都在python集合上操作。</p><p id="201b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个聚合器从一个集合中计算一个标量，这个集合概括了它的某些方面。例子包括对列表中的值求和、查找列表中的最大值、查找列表的长度等。</p><p id="e063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转换器将一个集合映射到另一个集合。一个例子是将计数向量转换成概率向量。变换器模式在特征提取中是有用的。</p><p id="c5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这些模式在概念上看起来很简单，但是用Python练习编码将帮助读者认识到何时应用它们，然后轻松地实现它们。</p><p id="863e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python理解在实现转换器时尤其有用。</p><p id="aae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧。首先，让我们做好准备。我们将关注三种类型的数据。</p><ol class=""><li id="61ec" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">一个特征向量。</li><li id="a0e2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">代表文本文件的一包单词。</li><li id="0cc7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">一种二进制图像的表示。</li></ol><p id="cfbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征向量只是一个集合，它捕获了我们希望建模的一些固定属性的值。比方说我们要用三个特征来描述一个房子:<em class="lv">卧室数量</em>，<em class="lv">卫生间数量</em>，<em class="lv">面积</em>。我们可以将其建模为一个python列表，其元素是三个特性的值。因此[4，2，2000]代表一栋有四间卧室、两间浴室的房子，其面积为2000平方英尺。</p><p id="5d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文本文档的单词包表示捕获每个单词在其中出现的次数。在python中，用字典表示一袋单词很方便。这里有一个例子。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="a48d" class="mp mq it ml b gy mr ms l mt mu">bag = { ‘the ’: 5, ‘art’ : 2, ‘of’ : 2, … }</span></pre><p id="bb4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过二维python列表来表示二进制图像。这里有一个例子。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="0e9a" class="mp mq it ml b gy mr ms l mt mu">image = [[1,1,1],[1,0,1],[1,1,1]]</span></pre><p id="b3a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">聚合器示例</strong></p><p id="7a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想从文档的包中知道文档的总字数。在python中，我们就是这样做的</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="800d" class="mp mq it ml b gy mr ms l mt mu">sum(bag.values())</span></pre><p id="5a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想计算图像中黑色像素的数量。在python中，我们会做</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="1fdc" class="mp mq it ml b gy mr ms l mt mu">import numpy as np<br/>np.sum(image)</span></pre><p id="0f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用NumPy，因为它支持任意形状数组上的聚合器。我们的图像是二维的。</p><p id="081e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">变压器实例</strong></p><p id="5d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要将文档的单词包表示转换为单词的概率分布。后者是长度规范化的，这一特性在某些用例中很有吸引力。在python中，我们会做</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="413d" class="mp mq it ml b gy mr ms l mt mu">denom = sum(bag.values())<br/>pbag = { word : float(count)/denom for word, count in bag.items() }</span></pre><p id="3e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二行使用了<em class="lv">字典理解</em>。</p><p id="f326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑我们的图像，想象它是灰度的。这只是意味着image[i][j]是一个介于0和1之间的值，而不仅仅是它的极值。对于下游处理，我们可能希望将此图像转换为二进制图像。在python中，我们可以</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="df71" class="mp mq it ml b gy mr ms l mt mu">def binarize(x):<br/>   if x &gt;= 0.5:<br/>     return 1<br/>   else:<br/>     return 0</span><span id="4747" class="mp mq it ml b gy mv ms l mt mu">binarized_image = [[binarize(pixel) for pixel in pixel_row] for pixel_row in image]</span></pre><p id="2936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后一行，我们正在做的可能被称为<em class="lv">二维列表理解</em>。</p><p id="4c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">特征提取作为一种变换</strong></p><p id="5e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个输入向量数组。我们想把它转换成一组特征向量。</p><p id="86c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以我们的房子为例。有理由推测各个维度是相互关联的。也就是说，更大的房子会有更多的卧室、更多的浴室和更大的面积。我们可能对从这三个特征中派生出一个特征感到好奇。或许，它可以很好地区分大小房屋。</p><p id="20ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们将我们的特征定义为输入向量中三个值的乘积。所以我们正在从三维空间向一维空间转变。(有时候，少可以多。)在python中，我们可以将输入向量数组转换为特征向量数组，如下所示。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="4e51" class="mp mq it ml b gy mr ms l mt mu">feature_vectors = [x[0]*x[1]*x[2] for x in input_vectors]</span></pre><p id="05eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，特征提取比我们在简单例子中看到的要复杂得多。我们可以将所有的复杂性抽象成一个函数<code class="fe mw mx my ml b">to_feature_vector(x)</code>，它将输入向量x作为一个参数。然后我们在理解中简单地使用这个函数</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="3165" class="mp mq it ml b gy mr ms l mt mu">feature_vectors = [to_feature_vector(x) for x in input_vectors]</span></pre><p id="3e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看一个涉及缺失数据的例子</p><p id="f588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">特征向量的相似度(有缺失数据)</strong></p><p id="da7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有两个相同维数的数值向量X和Y，并且缺少一些值。在python中，X和Y可能是长度相同的列表，有些值是<code class="fe mw mx my ml b">None</code>。我们想要计算两个向量的相似性度量，考虑它们的缺失值。</p><p id="23ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们将在忽略X或Y的值为None的维度后计算所谓的点积。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="5443" class="mp mq it ml b gy mr ms l mt mu">def dp(x,y):<br/>  return sum([x[i]*y[i] for i in range(len(x)) if x[i] and y[i]])</span></pre><p id="2e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个数字例子。让我们看看我们的房屋示例中的三个特征向量:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="26de" class="mp mq it ml b gy mr ms l mt mu">X = [4,2,2000]<br/>Y = [4,None,1800]<br/>Z = [None,1,500]</span></pre><p id="42ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dp(X，Y)和dp(X，Z)分别是3600016和1000002。这表明X和Y比X和z更相似。这有直观的意义。</p><p id="f531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，如果输入向量没有被适当地归一化，dp会给出非常误导的结果。这是因为矢量的分量处于不同的尺度。在我们的例子中，卧室的数量和浴室的数量通常在0到6之间，而面积可能在100到1000之间。</p><p id="ea1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">规格化一个数字特征的列</strong></p><p id="8feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以我们的房子为例。正如上一段所讨论的，平方英尺与前两个(卧室的数量，浴室的数量)有很大的不同。让我们看一个这种规模差异导致的问题的例子。</p><p id="802b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">认为</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="01c4" class="mp mq it ml b gy mr ms l mt mu">X = [4,2,2000]<br/>Y = [1,0,2000]<br/>Z = [4,2,1800]</span></pre><p id="3291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dp(X，Y)，dp(X，Z)，dp(Y，Z)分别约为400K，360K，360K。x和Z像Y和Z一样相似没有意义。</p><p id="f9fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，正常化吧！这种规范化将对要素列进行操作，每个要素一列。我们将特征列中的值除以该列的L2范数。什么是L2规范？您在下面包含<code class="fe mw mx my ml b">denom</code>的行的rhs上看到的内容。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="37ba" class="mp mq it ml b gy mr ms l mt mu">import math<br/>def normalize(fc):<br/>   denom = math.sqrt(sum([v**2 for v in fc]))<br/>   return [v/denom for v in fc]</span></pre><p id="73f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mw mx my ml b">normalize(fc)</code>输入一个特征列，并将其标准化。</p><p id="a3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们准备三个特性列，以便可以使用normalize(fc)。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="387a" class="mp mq it ml b gy mr ms l mt mu">fcs = [[xyz[i] for xyz in [X,Y,Z]] for i in range(3)]</span></pre><p id="8bc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到fcs等于</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="e803" class="mp mq it ml b gy mr ms l mt mu">[[4, 1, 4], [2, 0, 2], [2000, 2000, 1800]]</span></pre><p id="09ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以fcs[i]是特性I的值列表。</p><p id="2c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在让我们正常化</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="2b96" class="mp mq it ml b gy mr ms l mt mu">nfcs = [normalize(fc) for fc in fcs]</span></pre><p id="1342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看NFC。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="3367" class="mp mq it ml b gy mr ms l mt mu">[<br/>[0.6963106238227914, 0.17407765595569785, 0.6963106238227914], [0.7071067811865475, 0.0,                 0.7071067811865475], <br/>[0.5965499862718936, 0.5965499862718936,  0.5368949876447042]<br/>]</span></pre><p id="3275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三栋房子的标准平方英尺大致相同。第二所房子的卧室和浴室的标准数量远远低于第一所和第三所房子。理应如此。</p><p id="a60d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是在标准化的特征向量上使用dp。为此，我们首先需要将规范化的特征列转换成规范化的特征向量。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="5b67" class="mp mq it ml b gy mr ms l mt mu">XYZ = list(zip(nfcs[0],nfcs[1],nfcs[2])<br/>X,Y,Z = [list(XYZ[i]) for i in range(3)]</span></pre><p id="0baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">x、Y和Z现在是三个房屋的特征向量的归一化版本。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="07b3" class="mp mq it ml b gy mr ms l mt mu">X = [0.6963106238227914, 0.7071067811865475, 0.5965499862718936]<br/>Y = [0.17407765595569785, 0.0, 0.5965499862718936]<br/>Z = [0.6963106238227914, 0.7071067811865475, 0.5368949876447042]</span></pre><p id="0368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到dp(X，Y)，dp(X，Z)，dp(Y，Z)分别是0.477，1.30，0.44。好多了。X和Z比Y和Z(或者Y和X)更相似。</p><p id="5d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论</strong></p><p id="6f51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们用简单的例子讨论了在数据表示、准备和特征提取中反复出现的一些核心问题。我们讨论了涉及数字特征向量的例子，以及如何归一化它们，考虑丢失的数据。我们还介绍了单词示例和二进制图像操作。</p><p id="9804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些例子的共同点是我们使用了Python理解。从中得出的信息是，在Python中学习和实践这一机制在数据科学环境中非常有帮助。</p></div></div>    
</body>
</html>