<html>
<head>
<title>Exploring the Softmax Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Softmax函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-the-softmax-function-578c8b0fb15?source=collection_archive---------52-----------------------#2020-09-30">https://towardsdatascience.com/exploring-the-softmax-function-578c8b0fb15?source=collection_archive---------52-----------------------#2020-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ddc1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Wolfram语言发展直觉</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f1e951654ae311c3617d94081a84698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qG74tGvWJyNMgXXdQcgxtw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡伦·艾姆斯利在<a class="ae ky" href="https://unsplash.com/s/photos/exploring?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在机器学习中，分类问题通常用神经网络来解决，神经网络给出它被训练识别的每个类别或类型的概率。一个典型的例子是图像分类，其中神经网络的输入是图像，输出是图像用概率表示的可能事物的列表。</p><p id="bb1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Wolfram语言(WL)带有一个大型的预训练神经网络库，包括解决<a class="ae ky" href="https://resources.wolframcloud.com/NeuralNetRepository/tasktype/Classification/" rel="noopener ugc nofollow" target="_blank">分类问题</a>的网络。例如，内置的系统功能<a class="ae ky" href="https://reference.wolfram.com/language/ref/ImageIdentify.html" rel="noopener ugc nofollow" target="_blank"> ImageIdentify </a>使用了一个<a class="ae ky" href="https://resources.wolframcloud.com/NeuralNetRepository/resources/Wolfram-ImageIdentify-Net-V1" rel="noopener ugc nofollow" target="_blank">预训练的网络</a>，它可以识别图像中的4000多个对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/01704e5015ce43aa0d985a1a236b39ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*vu5B-sqi-smMtjIlKDdFCA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在<a class="ae ky" href="https://unsplash.com/s/photos/cat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上使用了<a class="ae ky" href="https://unsplash.com/@jamessutton_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">詹姆斯·萨顿</a>的照片</p></figure><p id="128e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lw">边注:由于Wolfram notebook界面独特的排版功能(例如将代码与图像混合)，所有代码都用屏幕截图显示。在这个故事的结尾有一个笔记本，里面有完整的代码。</em></p><p id="7e3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以直接使用底层神经网络来访问4000多个可能对象中每一个的概率。显然，“家猫”在这种情况下以几乎1的概率轻松获胜。其他类型的猫以较低的概率紧随其后。“浴帘”的结果可能是因为图像的背景。将所有4，000+个概率相加得出数字1.0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/3a38947f6a155647ed71595e51498425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDqipBAvlTn8QZfGJxkxJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者在<a class="ae ky" href="https://unsplash.com/s/photos/cat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上使用了<a class="ae ky" href="https://unsplash.com/@jamessutton_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">詹姆斯·萨顿</a>的照片</p></figure><p id="e334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你详细检查神经网络并查看它的组成层时，你会注意到最后一层是一种叫做<a class="ae ky" href="https://reference.wolfram.com/language/ref/SoftmaxLayer.html" rel="noopener ugc nofollow" target="_blank"> SoftmaxLayer </a>的东西。这一层在神经网络中非常常用，用于将一系列概率分配给一系列对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/43ab86cd631482d488754730498e4ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3tXgvWa-N96V1cu_3Jddg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="6c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SoftmaxLayer使用softmax函数，该函数将一个数字列表作为输入，并将一个规范化的数字列表作为输出。更具体地说，输入列表中的每个元素都被取幂并除以或归一化为所有取幂元素的总和。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/e84670f90d5f26d91908939897ae1b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T6TC4cgI5kZcfiHdIovFyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="cb46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从函数定义中可以清楚地看出，输出元素的总和总是1。原因是输出中的每个元素都是一个分数，其中分母是所有分子的总和。不太清楚的是任意输入列表如何与输出列表相关，因为softmax函数是非线性的。</p><p id="a51d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了对此有所帮助并获得直觉，我编写了一个WL函数来理解softmax函数的输入和输出。它简单地创建了两个条形图，一个绘制输入列表，一个绘制输出列表。</p><pre class="kj kk kl km gt ma mb mc md aw me bi"><span id="6c5b" class="mf mg it mb b gy mh mi l mj mk">understand[list_List] := Row[{<br/> BarChart[list], <br/> Style[" \[Rule] ", 32],<br/> BarChart[SoftmaxLayer[][list]]<br/>}]</span></pre><p id="ff09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从三个零的简单输入开始。在这种情况下，输出也有三个相等的元素，因为它们的总和是1，所以它们都是0.333…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/32bed5cd1939bdd9ed7923efb5ccc3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scO06QNYntht0MrbgnrLTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这适用于所有元素都相同的任何列表。例如，7的四元素列表将产生所有元素都为0.25的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/1e9480b877ee09b4dbbab9fb96c14aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKWop2b2f_zOwlP-GCiHbA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="eb63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当输入元素不完全相等时，事情变得更加有趣。让我们从线性增加的元素列表开始。输出是指数函数的缩小版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/b7954538a8ffb250c8cb5781f8dd1793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZUO7ia3xE-0SYn3OtPFfQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，线性递减元素的列表产生递减的指数函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/24bf5a7605f924a77a8389d8cb306943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jBNvcx7dnlQ3CEBGn26iZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="8d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个向下开口的抛物线会产生一条看起来像正态分布的输出“曲线”(可能正是如此？).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/ab84b93ff89a9df2792d03b43d72cd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1m3e1EwHpRWKtk0Umnq5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="7506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向上开口的抛物线给出更极端的输出，端点值占主导地位。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/d3280f8ee3bbd202510404e85051d1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJznUXRAENFQpXTKHNvxzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="5e1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，主要是为了好玩，周期函数以某种重新调整的形式保持其周期性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/ab1c144a70113810f4c9f4159d1bf9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ul5NeMt6z38xXrqX7POHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在笔记本中探索这一点和更多内容是非常有教育意义的。理解softmax函数如何工作有助于理解神经网络如何计算它们的最终分类概率分配。如果你想亲自体验更多，请从Wolfram Cloud下载<a class="ae ky" href="https://www.wolframcloud.com/obj/arnoudb/Published/softmax-01.nb" rel="noopener ugc nofollow" target="_blank">这款笔记本</a>。如果你对WL完全陌生，我推荐你阅读我最近的一篇名为“<a class="ae ky" rel="noopener" target="_blank" href="/learning-wolfram-from-zero-to-hero-2ac4fd6914d9">学习Wolfram:从零到英雄</a>”的文章。</p></div></div>    
</body>
</html>