<html>
<head>
<title>Understanding Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解动态编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-dynamic-programming-75238de0db0d?source=collection_archive---------5-----------------------#2020-10-04">https://towardsdatascience.com/understanding-dynamic-programming-75238de0db0d?source=collection_archive---------5-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="da9f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">流行优化技术的直观指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e783a677ba646038ed888f1628e8095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEugK-e5TyuSMPsjLDpb1Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="16e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">动态编程</strong>，或称DP，是一种优化技术。它被用于多个领域，尽管本文主要关注它在算法和计算机编程领域的应用。这是算法面试中经常被问到的话题。</p><p id="29f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于DP不是很直观，大多数人(包括我自己！)经常发现将问题建模为动态编程模型很棘手。在这篇文章中，我们将讨论什么时候使用DP，然后讨论它的类型，最后通过一个例子。</p><h1 id="9b89" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">目录</h1><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="f8d6" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">When is DP used?<br/></strong>  - Overlapping Sub-problems<br/>  - Optimal Substructure</span><span id="55ad" class="mo ls iq mk b gy mt mq l mr ms"><strong class="mk ir">The Two kinds of DP<br/></strong>  - The top-down approach<br/>  - The bottom-up approach</span><span id="5802" class="mo ls iq mk b gy mt mq l mr ms"><strong class="mk ir">An example<br/></strong>  - The Problem<br/>  - The analysis<br/>  - A recursive Solution<br/>  - The base case<br/>  - A dynamic programming approach<br/>  - Improving the Algorithm</span></pre><h1 id="6786" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么时候使用DP？</h1><p id="ce74" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">要使DP工作，问题必须满足两个必要条件。</p><ul class=""><li id="7f9d" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">重叠子问题</li><li id="fdf9" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">最优子结构</li></ul><p id="c77b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们更详细地看一下这些。</p><h2 id="b53c" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated">重叠子问题</h2><p id="31ef" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">这个属性正是它听起来的样子:重复的子问题。但是为了使这个有意义，我们需要知道什么是子问题。</p><p id="22fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个<strong class="kx ir">子问题</strong>只是手头问题的一个较小版本。在大多数情况下，这意味着传递给递归函数的参数值更小。</p><p id="5048" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你在找一本书的某一页，你会怎么做？你可以把书翻到某一页，然后把你所在的页码和你要找的页码进行比较。</p><p id="5873" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果当前页面比要求的页面小，您将开始在当前页面和最后一页之间查找。另一方面，如果当前页码更大，您将开始在书的开头和当前页面之间搜索。</p><p id="cd4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你会继续下去，直到你找到那一页。</p><p id="adf0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你必须把它建模成一个递归函数，那会是什么样子？可能是这样的。</p><p id="05dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注:</strong> <em class="ny">以下代码片段以伪代码的形式编写，以提高可读性</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7f9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">非常简单。有一个<strong class="kx ir"> <em class="ny"> getpage </em> </strong>函数返回我们正在寻找的页面(<strong class="kx ir"> <em class="ny"> target_page </em> </strong>，此处)。该函数查看从_页 到_页<strong class="kx ir"> <em class="ny">到_页</em> </strong>之间的中间页，并检查是否匹配。</p><p id="47dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">否则，该函数会查看我们正在查看的部分的左半部分或右半部分。</p><p id="17d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是那两个对<strong class="kx ir"> <em class="ny"> getpage </em> </strong>的递归调用代表什么呢？您会注意到，在每次递归调用时，我们都将搜索空间减少了一半。我们现在做的是解决同一个问题，就是在更小的空间里，寻找一个特定的页面。我们在解决子问题。</p><p id="3bcd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">分而治之，</strong>或<strong class="kx ir"> DAC </strong>算法通过子问题的原理工作。“划分”部分指的是将一个问题分成子问题。像mergesort和quicksort这样的排序算法就是很好的例子。请注意，二分搜索法并不完全是DAC算法，原因很简单，它没有“合并”步骤，而实际的分治算法会合并其子问题的结果，以获得最终的解决方案。</p><p id="89c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们已经回答了什么是子问题的问题，我们继续讨论另一个词:“<strong class="kx ir">重叠</strong>”。</p><p id="f2a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当这些子问题需要解决不止一次时，就称之为重叠问题。查看调用图，计算第n个斐波那契项的值。</p><p id="0c53" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">递归关系是:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="74b5" class="mo ls iq mk b gy mp mq l mr ms">the relation<strong class="mk ir"><br/>f(n) = f(n - 1) + f(n-2)</strong></span><span id="98e4" class="mo ls iq mk b gy mt mq l mr ms">the base case<br/><strong class="mk ir">f(0) = 0<br/>f(1) = 1</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/2de99b37c8d22abb8df3508e1c2bdbb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-g5eJ6XhOVp0cm0EdE-Ag.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">递归斐波纳契调用树。f(n)是第n个斐波那契数——作者使用<a class="ae oc" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图像。</p></figure><p id="6437" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些调用用阴影表示重叠的子问题。相比之下，二分搜索法的子问题并不重叠。</p><h2 id="3f6f" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated">最优子结构性质</h2><p id="4080" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">最优子结构属性稍微复杂一些:它指的是在计算总体最优解时可以直接考虑子问题的最优解的场景。</p><p id="22aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">举个简单的例子？说你要找从<strong class="kx ir"> <em class="ny"> A </em> </strong>到<strong class="kx ir"> <em class="ny"> B </em> </strong>的最短路径。设<strong class="kx ir"> <em class="ny"> X </em> </strong>为<strong class="kx ir"> <em class="ny"> A </em> </strong>和<strong class="kx ir"> <em class="ny"> B </em> </strong>之间的中间点，用<strong class="kx ir">单边</strong>将其连接到<strong class="kx ir"><em class="ny"/></strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/554549176e5ac0af01fe55264ab489e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efUCb45YaKrBQR9XBF0qOg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用中间节点寻找最短路径—作者使用<a class="ae oc" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图像。</p></figure><p id="6df7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了解决这个问题，我们可以找到从所有中间节点(<strong class="kx ir"> <em class="ny"> X </em> </strong>)到B的最短路径，然后找到从A到X的路径加上从X到B的最短路径，这是所有X中最短的。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="ba8c" class="mo ls iq mk b gy mp mq l mr ms">shortest(A, B) = min(AX + shortest(X, B)) for all intermediate nodes X.</span></pre><p id="b66a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在这里做的是使用一个最优的中间解(<strong class="kx ir"> <em class="ny">【最短(X，B)】</em></strong>)并使用它(而不是考虑子问题的每个解)来找到最终的最优答案。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="517c" class="lr ls iq bd lt lu ol lw lx ly om ma mb jw on jx md jz oo ka mf kc op kd mh mi bi translated"><strong class="ak">两种DP </strong></h1><h2 id="5925" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated">自上而下(记忆化)方法</h2><p id="3494" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">在自上而下的方法中，我们从问题的最高层开始。在这种方法中，我们首先检查是否已经解决了当前的子问题。如果有，我们就返回那个值。如果没有，我们解决子问题。我们使用递归调用来解决我们的子问题。</p><p id="e9fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于这些调用需要解决我们以前没有见过的更小的子问题，我们继续这样做，直到我们遇到一个我们已经解决或知道答案的子问题。</p><h2 id="54fb" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated">自下而上(制表)的方法</h2><p id="9059" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">在这种方法中，我们从最底层开始，然后一路向上。因为我们从“基本情况”开始，并使用我们的递归关系，我们真的不需要递归，所以，这种方法是迭代的。</p><p id="4553" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两种方法的主要区别在于自底向上计算所有的解，而自顶向下只计算那些需要的解。例如，为了找到源和目的地之间的最短路径，使用自顶向下的方法，我们只计算最短路径附近的中间点的距离，在每个阶段选择最小值。</p><p id="57e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，在自底向上的方法中，我们最终计算网格上每个点和目的地之间的最短距离，最终返回从起点到终点的最短距离。</p><p id="9cbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">作为比较，让我们看一个可能的自顶向下和自底向上的函数，它返回第n个斐波那契项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">C++中自顶向下的动态编程解决方案</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自底向上的动态规划解决方案</p></figure><p id="c3f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这两种方法具有相同的渐近时间复杂度，但是自顶向下实现中的递归调用可能导致堆栈溢出，由于自底向上方法的迭代性质，这不是问题。</p><p id="4141" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，尽管我们迭代地实现了后者，但您的逻辑仍然会使用非常基本的递归方法中的递归关系，正如我们将在本例中看到的那样。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="6bfb" class="lr ls iq bd lt lu ol lw lx ly om ma mb jw on jx md jz oo ka mf kc op kd mh mi bi translated"><strong class="ak">一个例子</strong></h1><p id="8ab0" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">让我们来看一个问题，我们将使用两种动态编程方法来解决这个问题。</p><h2 id="9453" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated">问题是</h2><p id="2206" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">找出一个数组中元素的最大和，确保不包括相邻的元素。让我们假设没有元素是负的。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="2671" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">example 1:<br/>[1, 2, 3]    =&gt; 1 + 3 = 4</strong></span><span id="bd18" class="mo ls iq mk b gy mt mq l mr ms"><strong class="mk ir">example 2:<br/>[1, 1, 1, 1] =&gt; 1 + 1 = 2</strong></span><span id="ed30" class="mo ls iq mk b gy mt mq l mr ms"><strong class="mk ir">example 3:<br/>[2, 5, 2]    =&gt; 5 = 5</strong></span></pre><h2 id="65ee" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated"><strong class="ak">分析</strong></h2><p id="780a" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">首先，让我们试试<strong class="kx ir">贪婪的方法。</strong></p><p id="d334" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们的目标是最大化我们选择的元素的总和，我们可以希望通过选择最大的元素，忽略它的邻居，然后继续这样做来实现这一点。在这里，我们确保每一步都有一个最大值。但是，这只有在局部情况下才是正确的，当然，我们正在寻找全球性的解决办法。</p><p id="18d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法在某些情况下是可行的。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="82e5" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">[1, 5, 1, 10, 1, 5, 1]</strong></span></pre><p id="ac14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，我们首先选择10，因为它是最大的元素。然后我们忽略它的邻居，这样我们就不会违反不允许选择相邻元素的条件。</p><p id="4257" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们选择两个5，因为它们是下一个最大的元素，然后忽略它们的邻居。我们的算法到此结束，因为没有任何元素了。我们得到的结果——10+5+5——实际上是正确的答案。</p><p id="8037" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是这并不总是有效的。举以下例子:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="78f8" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">[1, 1, 9, 10, 9, 1, 1]</strong></span></pre><p id="09ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在每一步，如果你选择了最大的元素，忽略了它的邻居，并继续这样下去，你最终会选择10，然后1，然后在忽略了两个9之后再次选择1，这样加起来就是12，但正确的答案应该是1 + 9 + 9 + 1，也就是20。</p><p id="aa08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很明显，这种方法是不正确的。让我们从一个基本的递归解决方案开始，逐步发展到一个使用动态编程的解决方案。</p><p id="763e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是贪婪和动态编程方法之间的区别。贪婪方法关注的是尽最大努力在每一步实现目标，而DP则着眼于全局。与DP不同，使用贪婪的方法，不能保证最终会得到最优解。贪婪算法经常陷入局部最大值，导致次优解。</p><h2 id="1b66" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated"><strong class="ak">递归解</strong></h2><p id="b3e8" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">稍微思考一下，你可能会发现我们有一个条件需要记住:<strong class="kx ir">没有相邻元素</strong>。你可能会发现:</p><ul class=""><li id="ccda" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">我们可以选择考虑求和中的一个元素，也可以忽略它</li><li id="75cc" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">如果我们考虑它，我们将不得不忽略它的相邻元素</li></ul><p id="8c47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了简洁起见，让<strong class="kx ir"> <em class="ny"> f(a..b) </em> </strong>代表调用到<strong class="kx ir"> <em class="ny"> f </em> </strong>我们的数组从索引<strong class="kx ir"> <em class="ny"> a </em> </strong>到索引<strong class="kx ir"> <em class="ny"> b </em> </strong>(含两者)。那个函数<strong class="kx ir"> <em class="ny"> f </em> </strong>将代表我们的递归函数，它将解决这个问题。</p><p id="c7d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以<strong class="kx ir"> <em class="ny"> f(0..4) </em> </strong>表示从索引0到索引4运行该功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6ba51d7ef6a4f68231241477b5fae877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*Y8zXc6mPImLyFPeB2Ae_8g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的函数调用表示—作者使用<a class="ae oc" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图像。</p></figure><p id="b4be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从一个单元格指向的两个箭头代表我们对后续函数调用的选择。因为这是一个最大化问题，我们必须从这些选项中选择最大值。</p><p id="887d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们回到我们的数组。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="a414" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">[5, 10, 100, 10, 5]</strong></span></pre><p id="0a88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记住上面讨论的条件，让我们实际写下我们将要做的事情。</p><p id="498d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的第一个调用将在整个数组上进行，如上所示，数组长度为5。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="c07c" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">f(0..4)</strong></span></pre><p id="39c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于索引为0的元素(这里恰好是5)，我们可以选择:</p><ul class=""><li id="e360" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><strong class="kx ir">将其包含在我们的总和中:</strong>我们当前的总和将是5 +数组其余部分的最大总和，但不包括下一个元素(索引1)。这样，我们的和就变成了<strong class="kx ir"> <em class="ny"> 5 + f(2..4) </em> </strong>。或者概括一下，<strong class="kx ir"> <em class="ny"> arr[0] + f(2..4) </em> </strong></li><li id="a160" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><strong class="kx ir">排除它:</strong>我们当前的和将正好等于剩余数组的最大和。这可以写成:<strong class="kx ir"> <em class="ny"> 0 + f(1..4) </em> </strong>。请注意，我们的下一个调用来自索引1，而不是上一个案例中的2。因为我们不考虑索引0处的元素，所以我们可以自由地考虑索引1处的元素——我们不会被迫忽略它。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/5cd6149bb0e060ba277cad28a92070a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16XvPir53Yo38Kd1r1wz6Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们函数的最初几次调用——作者使用<a class="ae oc" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图像。</p></figure><p id="2525" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的图表直观地解释了这一点。如前所述，给定级别的所有箭头代表我们的选择，我们从中选择最大的一个。</p><p id="a356" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们最终的答案是:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="38c4" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">f(0..4) = max(arr[0] + f(2..4), f(1..4))</strong></span></pre><p id="b9cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在下一次迭代中对此进行扩展。</p><p id="a9cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将为左边的树做这件事，它是<strong class="kx ir"> <em class="ny"> f(2..4)</em>T11】。这就像我们第一次调用f时做的一样，记住<strong class="kx ir"> <em class="ny"> arr[0] + </em> </strong>部分还在。它将被加到<strong class="kx ir"> <em class="ny"> f的值(2..4) </em> </strong>在返回调用树的途中。</strong></p><p id="b3fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的选择:</p><ul class=""><li id="f25b" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><strong class="kx ir">考虑<em class="ny"> arr[2] </em>在我们的sum: </strong>我们这个阶段的sum就变成了<strong class="kx ir"> <em class="ny"> arr[2] + f(4..4) </em> </strong>。记住，因为我们考虑的是索引2处的元素，所以我们必须忽略下一个元素——索引3。</li><li id="fc21" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><strong class="kx ir">忽略<em class="ny"> arr[2] </em> : </strong>我们这里的sum与剩余数组的最大结果相同，无需忽略相邻元素。所以，那就是<strong class="kx ir"> <em class="ny"> f(3..4) </em> </strong>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/32f136a70336dc58198c035c48e7a17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLrX5BoNJSRF_ZR3P1sbow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">调用树的第三层——作者使用<a class="ae oc" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图像。</p></figure><p id="104e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像以前一样，<strong class="kx ir">的值为<em class="ny"> f(2..4) </em> </strong>将是我们两个选择中的最大值。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="7700" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">f(2..4) = max(arr[2] + f(4..4), f(3..4))</strong></span></pre><h2 id="e9a2" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated"><strong class="ak">基地案例</strong></h2><p id="e04a" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">你认为<strong class="kx ir"> <em class="ny"> f(4..4) </em> </strong>会评价到什么？按照我们的符号，它是我们对从索引4到索引4的数组进行函数调用的结果。这意味着我们在单个元素上调用函数。单个元素的最大和就是它本身。</p><p id="0e9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一件要记住的事情是:在<strong class="kx ir"> <em class="ny"> f(a..b) </em> </strong>，a永远不应该大于b。因为这个调用表示从索引a开始，一直到索引b，所以如果<strong class="kx ir"><em class="ny"/></strong>比<strong class="kx ir"><em class="ny"/></strong>大，我们就必须返回0。没有元素就没有最大和。</p><p id="3812" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在这里有我们的基本情况。我们的函数<strong class="kx ir"> <em class="ny"> f </em> </strong>在单个元素上调用时，会直接返回该元素，如果不在有效范围内，则返回0。没有进一步的递归调用。这就是为什么它被称为基础案例。</p><p id="1a11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，我们把<strong class="kx ir">称为<em class="ny"> f(3..4) </em> </strong>导致对<strong class="kx ir"> <em class="ny"> f的无效调用(5..4) </em> </strong>，我们通过返回0来处理。我们稍后将概括这一点。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="3b2a" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">f(4..4) = arr[4]<br/>f(5..4) = 0</strong></span></pre><h2 id="4417" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated"><strong class="ak">递归关系</strong></h2><p id="12ba" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">让我们再看看我们的结果。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="6c3d" class="mo ls iq mk b gy mp mq l mr ms">first call:<strong class="mk ir"><br/>f(0..4) = max(arr[0] + f(2..4), f(1..4))</strong></span><span id="3822" class="mo ls iq mk b gy mt mq l mr ms">second call:<br/><strong class="mk ir">f(2..4) = max(arr[2] + f(4..4), f(3..4))</strong></span><span id="d028" class="mo ls iq mk b gy mt mq l mr ms">the base case:<br/><strong class="mk ir">f(4..4) = arr[4]<br/>f(5..4) = 0</strong></span></pre><p id="590f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意到前两个结果中的模式了吗？如果我们概括这些，我们得到:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="b69e" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">f(a..b) = max(arr[a] + f(a+2 .. b), f(a+1, b))</strong></span></pre><p id="b9ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这还不是我们关系的最简化版本。注意这里出现的<strong class="kx ir"> <em class="ny"> b </em> </strong>。实际上，回过头来看看我们在前一个块中的具体调用。</p><p id="fb58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">他们不会改变。没有<strong class="kx ir"> <em class="ny"> b + 1 </em> </strong>或<strong class="kx ir"> <em class="ny"> b + 2 </em> </strong>。总是<strong class="kx ir"> <em class="ny"> b </em> </strong>。而我们第一次调用中的<strong class="kx ir"> <em class="ny"> b </em> </strong>的值是多少？最后一个索引。由于<strong class="kx ir"> <em class="ny"> b </em> </strong>在我们整个算法中是常数，所以可以去掉。</p><p id="b00c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的递归关系变成:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="5bd0" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">f(a) = max(arr[a] + f(a+2), f(a+1))</strong></span></pre><p id="97af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<strong class="kx ir"> <em class="ny"> f(a) </em> </strong>是从索引<strong class="kx ir"> <em class="ny"> a </em> </strong>起对数组的调用。</p><p id="e83d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一件要意识到的事情是，类似于我们如何移除<strong class="kx ir"><em class="ny"/></strong>b，因为它总是等于数组中的最后一个索引，引用单个元素的基本情况只有在该元素是数组中的最后一个元素时才会发生。</p><p id="e896" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们基本情况的概括版本是:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="b9d5" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">f(n-1) = arr[n-1] </strong>where<strong class="mk ir"> n </strong>is the size of the array<br/><strong class="mk ir">f(a) = 0</strong> if <strong class="mk ir">a</strong> &gt;= <strong class="mk ir">n</strong> where <strong class="mk ir">n</strong> is the size of the array</span></pre><p id="8f59" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们有我们的关系:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="1f07" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">f(a) = max(arr[a] + f(a+2), f(a+1))<br/>f(n-1) = arr[n-1] </strong>where<strong class="mk ir"> n </strong>is the size of the array<br/><strong class="mk ir">f(a) = 0</strong> if <strong class="mk ir">a</strong> &gt;= <strong class="mk ir">n</strong> where <strong class="mk ir">n</strong> is the size of the array</span></pre><p id="eb6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们基于这个关系实现递归方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5a29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数可以这样调用:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="3d61" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">array := [1, 5, 2, 4, ...]<br/>return f(array, 0)</strong></span></pre><p id="25ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这会有多复杂？</p><p id="8240" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们根据数组的大小(<strong class="kx ir"> <em class="ny"> n </em> </strong>)来估算复杂度，我们会得到这样的结果:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="f341" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">T(n) = T(n-2) + T(n-1) + O(1)</strong></span><span id="63e6" class="mo ls iq mk b gy mt mq l mr ms"><strong class="mk ir">T(0) = O(1)</strong></span></pre><p id="53c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">直观地说，对大小为n的数组f的每个调用(表示为<strong class="kx ir"><em class="ny">【T(n)】</em></strong>)都会导致对大小为<strong class="kx ir"> <em class="ny"> n-2 </em> </strong>和<em class="ny"> n-1 </em> 的数组f的两个调用。也就是说，在每个阶段，我们对<strong class="kx ir"> <em class="ny"> f </em> </strong>的调用次数都会翻倍。</p><p id="cb34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">渐近时间复杂度是指数级的。用上面的推理，我们得到<strong class="kx ir">o(2^n).<em class="ny"/>T73】</strong></p><p id="a901" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是对上限的一个宽松估计，因为<strong class="kx ir"> <em class="ny"> n-2 </em> </strong>树必然会在<strong class="kx ir"> <em class="ny"> n-1 </em> </strong>树之前结束，所以我们做的比加倍调用略少。实际的复杂度是<strong class="kx ir"><em class="ny">o(phi^n)—φ</em></strong>是黄金比例—或者<strong class="kx ir"><em class="ny">【o(1.618^n】，</em> </strong>比我们原来的估计略小，但是还是坚持<strong class="kx ir"> O(2^n) </strong>。</p><p id="cdd2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一件要注意的事情是，上面的递归关系类似于第n个斐波那契项，因此会给出类似的复杂性。</p><h2 id="266f" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated">动态规划方法</h2><p id="49c4" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">这就是动态编程发挥作用的地方。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/a63eb88d5530f4dde64c33bd38cb8063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yH_GlIjc8O1Ehy7LvU4Stg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">注意调用图中重复出现的子问题——作者使用<a class="ae oc" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图像。</p></figure><p id="7383" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你仔细观察，你会看到我们之前谈到的重叠的子问题。</p><p id="cce2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在到了重要的部分——将这种递归实现转换成动态编程方法。如果我们存储正在重复的函数调用的值会怎么样？</p><p id="6d17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们维护一个数组，其中第I个元素是<strong class="kx ir"> <em class="ny"> f(i) </em> </strong>的值，依次是从索引<strong class="kx ir"> <em class="ny"> i </em> </strong>到结尾的数组的最大和。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="6f4c" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">dp[i] = f(i..n) = f(i)</strong></span></pre><p id="1a53" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们已经有了f(i)的结果，</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="8074" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">dp[i] = max(arr[i] + f(i + 2), f(i + 1))</strong></span></pre><p id="b955" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了这个关系，我们可以走两条不同的路。要么我们走自顶向下的路线，在这里我们的函数仍然是递归的，就像上面的结果一样，要么我们去掉所有的递归调用，走自底向上的路线。</p><p id="c025" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将关注自底向上的路线，但是让我们讨论自顶向下的方法。</p><h2 id="69a1" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated">-自上而下的方法</h2><p id="a555" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">看看我们之前的结果。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="03bb" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">dp[i] = max(arr[i] + f(i + 2), f(i + 1))</strong></span></pre><p id="27a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们实现自顶向下方法所需要的。对于任何对<strong class="kx ir"> <em class="ny"> f </em> </strong>的调用，我们将首先在我们的数组<strong class="kx ir"> <em class="ny"> dp </em> </strong>中检查我们之前是否已经进行了那个调用，如果已经进行了，我们将直接使用预先计算的值。</p><p id="f0d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一方面，如果我们正在进行的调用以前从未做过，我们必须计算整个事情。在这种情况下，一旦我们得到一个值，我们确保将它存储在我们的数组<strong class="kx ir"> <em class="ny"> dp </em> </strong>中，这样我们就不必重复整个过程。</p><p id="3017" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">调用树应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/fa1de2f8c5cab3aebdf72754b759a3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8EpjkUlVOchxAy9F4G8_7g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自顶向下动态编程方法中的调用树—作者使用<a class="ae oc" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图像。</p></figure><p id="6b09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们实现这个算法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1a90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">存储子问题结果所需的额外空间随着输入数组的大小而线性增长。因此，除了递归堆栈所需的<strong class="kx ir"> <em class="ny"> O(n) </em> </strong>空间之外，我们还有一个<strong class="kx ir"> <em class="ny"> O(n) </em> </strong>空间用于<strong class="kx ir"> <em class="ny"> dp </em> </strong>数组，n是输入数组的大小。</p><p id="639b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">时间复杂度虽然更难计算，但与输入大小成线性关系。这是因为我们正在存储我们已经解决的子问题的答案，因此，我们有<strong class="kx ir"><em class="ny">【O(n)</em></strong>个独特的子问题需要解决。这个结果也可以用我们使用自底向上方法得到的复杂度来验证。</p><h2 id="31b8" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated">-自下而上的方法</h2><p id="f523" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">回想一下，在这种方法中，我们试图通过遵循迭代方法来消除所有的递归调用，其中我们从基本情况或“底部”开始，并向上进行。</p><p id="5372" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用访问<strong class="kx ir"> <em class="ny"> dp </em> </strong>的元素来替换对<strong class="kx ir"> <em class="ny"> f </em> </strong>的其他调用。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="7887" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">dp[i] = max(arr[i] + dp[i + 2], dp[i + 1])</strong></span></pre><p id="6ba8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基例呢，<strong class="kx ir"><em class="ny">f(n-1)= arr【n-1】</em></strong>？这将是数组<strong class="kx ir"> <em class="ny"> dp </em> </strong>的最后一个元素。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="d3cb" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">dp[n-1] = arr[n-1]</strong></span></pre><p id="b1fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就这样，我们有了自下而上<strong class="kx ir"> <em class="ny"> dp </em> </strong>方法的解决方案！</p><p id="eefe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们实现它，就像我们对递归方法所做的那样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7c8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数可以这样调用:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="54bc" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">array := [1, 5, 2, 4, ...]<br/>output(f(array))</strong></span></pre><p id="ca38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的复杂性在空间和时间上都是线性的。</p><p id="2f5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么？</p><p id="c4cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们正在运行单个for循环<strong class="kx ir"> <em class="ny"> n-1 </em> </strong>次，并且在每次迭代中，我们都在执行常数时间操作——线性时间复杂度。</p><p id="0a89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于数组<strong class="kx ir"> <em class="ny"> dp </em> </strong>的大小取决于输入数组的大小——当然，这是可变的——我们的空间复杂度也是线性的。</p><h2 id="6cda" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated"><strong class="ak">改进算法</strong></h2><p id="b4a8" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">但是我们能做得更好吗？让我们看看。</p><p id="3af2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在渐近时间复杂度方面，我们做不到更好。为了找到答案，我们必须检查数组的每个元素。所以我们做不到比线性时间更好。</p><p id="1057" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是空间复杂度呢？我们需要维护一个大小为<strong class="kx ir"> <em class="ny"> n </em> </strong>的数组来解决问题吗？</p><p id="d00c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">仔细观察for循环中的代码行:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="736c" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">dp[i] = max(arr[i] + dp[i + 2], dp[i + 1])</strong></span></pre><p id="a8a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在任何时间点，我们需要填充的<strong class="kx ir"><em class="ny">DP【I】</em></strong>就是<strong class="kx ir"> <em class="ny"> dp </em> </strong>中的下两个元素——在索引<strong class="kx ir"> <em class="ny"> i +1 </em> </strong>和<strong class="kx ir"> <em class="ny"> i + 2 </em> </strong>。没有理由保持我们所有的结果。我们只需要跟踪最后两次迭代。</p><p id="8455" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在这里使用三个变量。为了便于联系，我们将它们命名为<strong class="kx ir"><em class="ny">i0</em></strong><strong class="kx ir"><em class="ny">i1</em></strong>和<strong class="kx ir"><em class="ny">I2</em></strong>。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="0163" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">dp[i]   --&gt; i_0<br/>dp[i+1] --&gt; i_1<br/>dp[i+2] --&gt; i_2</strong></span></pre><p id="ae3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，在我们循环的下一次迭代中，我们的循环计数器<strong class="kx ir"> i </strong> <em class="ny">，</em>变成了<strong class="kx ir"> <em class="ny"> i + 1 </em> </strong>，因为我们在每次迭代中都在递减<strong class="kx ir"> <em class="ny"> i </em> </strong>。<strong class="kx ir"><em class="ny">DP【I+1】</em></strong>将是下一个<strong class="kx ir"><em class="ny">DP【I+2】</em></strong><strong class="kx ir"><em class="ny">DP【I】</em></strong>将是下一个<strong class="kx ir"><em class="ny">DP【I+1】</em></strong>和<strong class="kx ir"><em class="ny">DP【I+2】</em></strong>——因为<strong class="kx ir"><em class="ny">DP【I+1】我们就不需要它了</em></strong></p><p id="841c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用我们的三个新变量替换它，循环中的代码变成:</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="8a05" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">i_0 := max(arr[i] + i_2, i_1)<br/>i_2 := i_1<br/>i_1 := i_0</strong></span></pre><p id="cc5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们初始化这些变量就像我们的数组实现一样。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="7b1a" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">dp[n-1] = arr[n-1] --&gt; i_1 = arr[n-1]<br/>dp[n] = 2          --&gt; i_2 = 0</strong></span></pre><p id="c2a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要记住的最后一件事是:如果输入数组只有一个元素会怎样？我们的循环，从<strong class="kx ir"> <em class="ny"> n-2 </em> </strong>到<strong class="kx ir"> <em class="ny"> 0 </em> </strong>，一次都不会运行。</p><p id="42e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们用值<strong class="kx ir"> <em class="ny"> i_1 </em> </strong>初始化<strong class="kx ir"> <em class="ny"> i_0 </em> </strong>。因此，如果循环从不运行—输入数组只有一个元素—返回<strong class="kx ir"> <em class="ny"> i_0 </em> </strong>将返回<strong class="kx ir"> <em class="ny"> i_1 </em> </strong>的值，这是数组中唯一的元素。</p><p id="f0f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后我们返回<strong class="kx ir"> <em class="ny"> i_0 </em> </strong>而不是<strong class="kx ir"><em class="ny">DP【0】</em></strong>。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="3a8d" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">return dp[0] --&gt; return i_0</strong></span></pre><p id="6fc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们最终的算法应该是这样的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ac2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像前面的动态编程方法一样，只需传入一个数组或对数组的引用就可以调用这个函数。</p><pre class="kg kh ki kj gt mj mk ml mm aw mn bi"><span id="c722" class="mo ls iq mk b gy mp mq l mr ms"><strong class="mk ir">array := [1, 5, 2, 4, ...]<br/>return f(array)</strong></span></pre><p id="a237" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于任意长度的数组，我们只需要三个变量。这样，我们算法的空间复杂度现在是<strong class="kx ir"> <em class="ny"> O(1) </em> </strong> —常数。</p><p id="1636" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总结我们的结果，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/da10798bb408a9ddfc3b91dc7c681c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4M0loVZVUoAhWTCKb-KAw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的实现摘要—作者使用<a class="ae oc" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank"> draw.io </a>创建的图像。</p></figure><p id="81d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">比较递归方法和我们的自顶向下方法，很明显<strong class="kx ir">我们是在用空间复杂度换取更好的时间复杂度</strong>。当然，因为两者都是递归的，所以它们有递归调用栈所需的额外空间。</p><p id="8d94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，最低的两行是我们自底向上方法的结果。它们是迭代的，所以它们不需要在堆栈上递归存储函数记录。由于它们本质上与自顶向下方法的算法相同，所以它们具有相同的线性时间复杂度。</p><p id="9e02" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最好的情况是<strong class="kx ir">自底向上的方法，需要O(1)个空间</strong>——这意味着我们的dp算法使用的空间不会随着输入大小n而改变。</p><h2 id="5fcd" class="mo ls iq bd lt nn no dn lx np nq dp mb le nr ns md li nt nu mf lm nv nw mh nx bi translated"><strong class="ak">代码</strong></h2><p id="6e3e" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">让我们用C++实现我们的<strong class="kx ir">常数空间自底向上动态规划</strong>的最终算法。变量名和函数名与之前相同。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="cfd1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>最后的空间复杂度优化步骤看起来稍微难一点，但是正如我们刚刚看到的，它极大地提高了您的空间利用率。看看你是否能在第n个斐波那契项的自下而上方法中找到类似的关系。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="7bbf" class="lr ls iq bd lt lu ol lw lx ly om ma mb jw on jx md jz oo ka mf kc op kd mh mi bi translated">结论</h1><p id="0120" class="pw-post-body-paragraph kv kw iq kx b ky mu jr la lb mv ju ld le mw lg lh li mx lk ll lm my lo lp lq ij bi translated">动态编程通常不太直观或简单。话说回来，大多数复杂的事情都不是。但是通过练习，事情会变得更容易。网上有大量的动态编程练习题，这将帮助你更好地了解何时应用动态编程，以及如何更好地应用它。希望这篇文章是一个好的起点。</p></div></div>    
</body>
</html>