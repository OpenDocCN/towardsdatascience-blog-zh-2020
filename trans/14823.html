<html>
<head>
<title>Train and Build a Classification Machine Learning App Using Loan Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用贷款数据训练和构建分类机器学习应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-loan-data-to-train-and-build-a-classification-machine-learning-app-174c2f1058e3?source=collection_archive---------55-----------------------#2020-10-12">https://towardsdatascience.com/using-loan-data-to-train-and-build-a-classification-machine-learning-app-174c2f1058e3?source=collection_archive---------55-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2343" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建应用程序以服务分类模型、将应用程序容器化并进行部署的简要指南。</h2></div><p id="74ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作者:<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/douglas-franklin-1a3a2aa3/" rel="noopener ugc nofollow" target="_blank">道格拉斯·富兰克林</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/f28766ee1fc80c811d55224dfacab5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ni79KGU-PfcXIT4_OLhvw.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由Unsplash上的纽约公共图书馆拍摄</p></figure><p id="9b91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请点击此处查看该项目中使用的所有代码！</p><div class="lv lw gp gr lx ly"><a href="https://github.com/edkrueger/python-classification-labs" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">edkrueger/python-分类-实验室</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在GitHub上创建一个帐户，为edkrueger/python-classification-labs的开发做出贡献。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm lp ly"/></div></div></a></div><p id="f498" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用GCP来编码这个项目，它配置了Docker。如果您有兴趣了解预配置的云虚拟机，请阅读本文开始学习！</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/using-gcp-ai-platform-notebooks-as-reproducible-data-science-environments-964cba32737"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用GCP人工智能平台笔记本作为可复制的数据科学环境</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用预配置的云托管虚拟机解决Python和Jupyter笔记本电脑的再现性问题。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm lp ly"/></div></div></a></div><p id="7108" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的数据来自一本叫做《ISLR》的书。查看这项工作的机器学习和统计信息！</p><h1 id="81d6" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题</h1><p id="eba9" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">我们可以想象一家银行想知道谁是安全的贷款接受者，但是我们如何在只知道一些关于某人的事情的情况下判断他是否值得信任呢？</p><p id="b4f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的数据集包含代表具有默认状态的个人的行，以及我们将用来预测默认状态的一些其他信息。换句话说，这就是监督学习。</p><p id="43d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将清理数据，使其更适合分类模型。</p><h1 id="d068" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">数据</h1><p id="7205" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">让我们看看我们的数据。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nl"><img src="../Images/b713059b9fb756388605bf5556604cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QznQeUmSqfg_1kqyFDAfBg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">原始数据</p></figure><p id="5f9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来我们有四列和一个索引，包括银行余额、年收入、学生状态和贷款违约状态。可以清理这些数据以更好地适应分类模型，所以让我们做一些更改。</p><h2 id="61a0" class="nm mp it bd mq nn no dn mu np nq dp my kr nr ns na kv nt nu nc kz nv nw ne nx bi translated">数据清理和EDA</h2><p id="ddd4" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">为了清理我们的数据，我们使用pandas和一些lambda函数来删除索引，并将我们的yes/no字符串更改为True/False布尔值。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">data_cleaning.ipynb</p></figure><p id="990e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们的干净数据看起来像这样。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oa"><img src="../Images/57d97132acd358c29ba2df27be46759d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NGEvRZesvFgIzNGmWXvsQ.png"/></div></div></figure><p id="c988" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们为训练模型设置数据之前，让我们最后看一眼熊猫。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/f3c05c9789e5e34bc2274c5923a25d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*COkNO-SXR483-uBzL3HG1g.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">EDA值和数据类型</p></figure><p id="bdbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们用<code class="fe oc od oe of b">value_counts()</code>来看看我们有多少真和假。这让我们看到有多少人拖欠贷款，有多少人没有。值得注意的是，虚假比真实多得多，几乎多30倍。这意味着我们的数据包含了更多的非违约者的例子，而不是违约者，这是一种阶级不平衡。</p><p id="4510" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在审查我们的模型指标时，记住样本数据中的这种差异是很重要的。我们可以想象一个<strong class="kk iu">虚拟模型</strong>，它总是猜测错误或无违约，同时它将具有96.67%的准确率，是一个可怕的模型。要知道我们的模型是否运行良好，我们需要密切关注它何时出错。我们对错误分类感兴趣。</p><h1 id="b89a" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">预处理</h1><p id="3021" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">现在，我们将设置我们的笔记本来运行一些机器学习模型。首先，我们要准备将输入模型的变量。</p><p id="a533" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe oc od oe of b">X</code>或独立变量将是学生身份、银行存款余额和年收入。这些是我们用来预测个人是否可能违约的变量。</p><pre class="lg lh li lj gt og of oh oi aw oj bi"><span id="21ec" class="nm mp it of b gy ok ol l om on">X = df[["student", "balance", "income"]].values</span></pre><p id="e9d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">个人是否拖欠贷款将是我们的<code class="fe oc od oe of b"> y</code>或因变量。</p><pre class="lg lh li lj gt og of oh oi aw oj bi"><span id="3818" class="nm mp it of b gy ok ol l om on">y = df["default"].values</span></pre><p id="dc64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们假设我们的三个自变量与因变量之间存在某种因果关系。换句话说，我们假设银行存款余额、收入和学生身份有助于预测某人是否会拖欠贷款。</p><h1 id="8586" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">建筑模型</h1><p id="327b" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">使用我们上面设置的X和y变量，我们可以建立一些模型并分析它们的度量。然而，首先让我们回顾一下当前问题背景下的模型度量精度和召回率。</p><h2 id="ae34" class="nm mp it bd mq nn no dn mu np nq dp my kr nr ns na kv nt nu nc kz nv nw ne nx bi translated">模型度量:精确度和召回率</h2><p id="6e0b" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">我们如何判断哪种模型最有效地解决了这个问题？</p><p id="d36f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">精密</strong>试图回答以下问题:</p><p id="efa7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，有多少比例的肯定识别是正确的？</p><p id="2193" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">精确度是对预测违约的<strong class="kk iu">个人和实际违约的</strong>个人的度量。</p><p id="a06d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">回想一下</strong>试图回答以下问题:</p><p id="01fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oo">正确识别实际阳性的比例是多少？</em></p><p id="7873" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">召回衡量被正确分类的<strong class="kk iu">违约个人</strong>的比率。</p><p id="288d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要全面评估一个模型的有效性，你必须同时检查<strong class="kk iu">精确度和召回率。不幸的是，精确度和召回率经常处于紧张状态。也就是说，提高精度通常会降低召回率，反之亦然。</strong></p><p id="c587" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们想象了一个准确率为96.67%的虚拟模型，它永远不会说“真”精度和召回允许我们放大模型归类为“真实”的值，以便我们可以看到我们的模型在对我们重要的时候是如何表现的！</p><p id="b7d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个问题都是不一样的，所以你需要知道对于你的情况，精确和回忆哪个更重要？这将是一个基于价值的决定，你决定哪个成本更高，假阳性或假阴性。</p><p id="e95d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看使用scikit-learn构建的几个模型。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/55bf256320dddd8695b840a977324be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*1a8iDrRaGgYXdbscGgY9Xg.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">决策图表</p></figure><p id="36c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在决策分析中，决策树可以直观、明确地表示决策和决策制定。顾名思义，它使用树状决策模型。</p><p id="86a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们可以看到我们的准确性几乎是我们的虚拟模型，总是说假。这是由于数据集中存在大量错误，即类别不平衡。</p><p id="91ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们观察<code class="fe oc od oe of b">cv_recall</code>和<code class="fe oc od oe of b">cv_precision</code>时，事情变得更加有趣。这些低分数表明该模型很难识别实际的“真实”值，precision告诉我们，我们的模型预测“违约”的时间只有三分之一左右是正确的回忆告诉我们，当它确实将一个人归类为“真实”时，它只在大约三分之一的情况下是正确的。不是一个很好的模型，</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6f101b910ce90fcdbb747a2b48abf50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*d2e41hkX3cuXwBp4ML-k0g.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">k-最近邻</p></figure><p id="4231" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">k-最近邻(KNN)算法是一种简单的监督机器学习算法，可用于解决分类和回归问题。</p><p id="3f1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到我们的准确性略有提高，但我们再次对<code class="fe oc od oe of b">cv_recall</code>和<code class="fe oc od oe of b">cv_precision</code>更感兴趣。我们看到这里的精度更高，这意味着我们的模型预测的“真实”值中，有一半是正确的。这意味着，我们的模型认为会违约的人中，有一半真的会违约。</p><p id="89ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们也看到召回率的相应下降。这意味着我们的模型只确定了15%的“真实”值。当我们说“真”的时候，似乎我们更经常是对的，但是我们也忽略了许多“真”的价值。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/71549942692e003b741918f187b616d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*dXNrSr0D2ldMtLjx3QRKRw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">随机森林</p></figure><p id="5741" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顾名思义，随机森林由大量单独的决策树组成，这些决策树作为一个整体运行。随机森林中的每一棵特定的树都会产生一个类别预测，拥有最多票数的类别将成为我们模型的预测。该模型的一些实现让每棵树提交一个平均值而不是一个投票，这可以提高准确性。</p><p id="0788" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随机森林背后的基本概念简单而强大——群体的智慧。用数据科学的话来说，随机森林模型如此有效的原因是，大量相对不相关的树作为一个委员会运行，将胜过任何单个的组成树。</p><p id="6d5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再一次看到我们的准确度略有提高，但是我们再一次对<code class="fe oc od oe of b">cv_recall</code>和<code class="fe oc od oe of b">cv_precision</code>更感兴趣，与单个KNN模型相比，它们在随机森林中都有所提高。我们看到这里的精度稍高，这意味着在我们的模型预测的“真实”值中，有57%被正确选择。我们看到一个<code class="fe oc od oe of b">cv_recall</code>远高于KNN，但略低于一个单一的决策树。尽管如此，我们仍然只能用这个模型识别出大约三分之一的“真实”价值。</p><p id="f13b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这三个模型中，随机森林具有最佳的整体指标，因此我们将继续推进该模型，并将其构建到一个应用程序中。</p><h2 id="8c96" class="nm mp it bd mq nn no dn mu np nq dp my kr nr ns na kv nt nu nc kz nv nw ne nx bi translated">保存您的模型</h2><p id="38fe" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">一旦你决定了一个模型，把它保存为一个. joblib，就像下面我们对随机森林模型所做的那样。</p><pre class="lg lh li lj gt og of oh oi aw oj bi"><span id="7430" class="nm mp it of b gy ok ol l om on">dump(rf, "clf.joblib")</span></pre><p id="2841" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经将贷款分类器保存为. joblib文件，该文件将出现在我们的目录中。</p><h1 id="25b4" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">构建应用程序</h1><p id="163f" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">服务于这个模型的应用程序很简单。我们需要将我们的模型导入到应用程序中，接收POST请求并返回模型对该POST的响应。</p><p id="9496" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是应用程序代码。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fce3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到有一条简单的<code class="fe oc od oe of b">/home</code>路线让我们知道应用程序已经准备好了。我们的<code class="fe oc od oe of b">/predict</code>路线才是真正起作用的。请注意，它使用了一个<code class="fe oc od oe of b">POST</code>从帖子中提取变量，然后将这些变量作为<code class="fe oc od oe of b">X_predict</code>提供给我们的模型。然后，该路径将该模型的响应返回为真或假，并将违约概率返回为浮点数。</p><p id="e061" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们有了一个可以为我们的模型服务的应用程序，我们需要用Docker封装我们的应用程序，这样我们就可以轻松地部署它。</p><h1 id="c2ba" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">Docker和我们的docker文件</h1><p id="24c8" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">Docker是将应用程序投入生产的最佳方式。Docker使用docker文件来构建容器。构建的容器存储在Google Container Registry中，可以在这里进行部署。Docker容器可以在本地构建，并将在任何运行Docker <strong class="kk iu">的系统上运行。</strong></p><p id="390b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是用于此项目的docker文件:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ny nz l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Dockerfile文件</p></figure><h1 id="0afd" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用Docker进行本地测试</h1><p id="a948" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">请注意，您需要安装Docker才能在本地运行。或者，您可以使用已经配置了Docker的云平台(参见本文开头链接的文章)。</p><p id="9b09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oc od oe of b">docker build</code>命令将docker文件的每一行视为一个“步骤”,并提供一个终端输出，指示每个步骤何时运行，如上所示。</p><p id="d919" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们运行命令<code class="fe oc od oe of b">docker build . -t loan-classifier</code>并看到输出确认，即每个步骤都是按顺序完成的。一旦我们的docker容器构建完成，我们就可以使用下面的命令在容器中运行应用程序。</p><pre class="lg lh li lj gt og of oh oi aw oj bi"><span id="c157" class="nm mp it of b gy ok ol l om on">PORT=8000 &amp;&amp; docker run -p 80:${PORT} -e PORT=${PORT} <!-- -->loan-classifier</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi os"><img src="../Images/8481539a70828c46097aac1b99260adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v785L438XHB5Gedvxp-D6Q.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">码头运行</p></figure><p id="cf55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来我们的容器化应用程序正在本地主机地址上运行。太好了，我们成功建造了码头。现在让我们的应用程序向公众发布。</p><h1 id="7247" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">Docker图像和谷歌云注册表</h1><p id="82d9" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">GCP云构建允许您使用docker文件中包含的指令远程构建容器。</p><p id="2264" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们准备好docker文件，我们就可以使用Cloud Build构建我们的容器映像。</p><p id="5377" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从包含Dockerfile文件的目录中运行以下命令:</p><pre class="lg lh li lj gt og of oh oi aw oj bi"><span id="1d12" class="nm mp it of b gy ok ol l om on">gcloud builds submit --tag gcr.io/<strong class="of iu">PROJECT-ID</strong>/<strong class="of iu">container-name</strong></span></pre><p id="50eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:用您的GCP项目ID替换项目ID，用您的容器名称替换容器名称。您可以通过运行命令<code class="fe oc od oe of b">gcloud config get-value project</code>来查看您的项目ID。</p><p id="d56c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该Docker图像现在可在GCP集装箱注册处或GCR访问，并可通过云运行的URL访问。</p><h1 id="6380" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用CLI部署容器映像</h1><p id="51d1" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">如果您更喜欢使用GUI，请跳过这一部分！</p><ol class=""><li id="e870" class="ot ou it kk b kl km ko kp kr ov kv ow kz ox ld oy oz pa pb bi translated">使用以下命令进行部署:</li></ol><pre class="lg lh li lj gt og of oh oi aw oj bi"><span id="1de5" class="nm mp it of b gy ok ol l om on">gcloud run deploy --image gcr.io/<strong class="of iu">PROJECT-ID</strong>/<strong class="of iu">container-name </strong>--platform managed</span></pre><p id="03bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:用您的GCP项目ID替换项目ID，用您的容器名称替换容器名称。您可以通过运行命令<code class="fe oc od oe of b">gcloud config get-value project</code>来查看您的项目ID。</p><p id="d18f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.将提示您输入服务名称和区域:选择您所选择的服务名称和区域。</p><p id="4fe9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.您将被提示<strong class="kk iu">允许未认证的调用</strong>:如果您想要公共访问，响应<code class="fe oc od oe of b">y</code>，并且<code class="fe oc od oe of b">n </code>限制对同一google项目中的资源的IP访问。</p><p id="1139" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.稍等片刻，直到部署完成。如果成功，命令行会显示服务URL。</p><p id="b991" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5.通过在web浏览器中打开服务URL来访问您部署的容器。</p><h1 id="da8e" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">使用GUI部署容器映像</h1><p id="3c2c" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">现在我们已经在GCR存储了一个容器映像，我们已经准备好部署我们的应用程序了。访问<a class="ae le" href="https://console.cloud.google.com/run?_ga=2.112811590.313737761.1591368161-572251819.1590763098&amp;amp;_gac=1.61558494.1591368161.CjwKCAjw2uf2BRBpEiwA31VZj5hm5tgEHH-Ldim6HaH954LjVPoeEdbL9XkMUnSw3yKCOv1UYdvGdRoCzasQAvD_BwE" rel="noopener ugc nofollow" target="_blank"> GCP云运行</a>并点击创建服务，确保按要求设置计费。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pc"><img src="../Images/0995d2e9a9606f14e61bc2566e13da14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yg_UDqmiQrFsTq78.png"/></div></div></figure><p id="9880" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择您想服务的地区，并指定一个唯一的服务名称。然后通过分别选择未经身份验证或经过身份验证，在对应用程序的公共访问和私有访问之间进行选择。</p><p id="6f6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们使用上面的GCR容器图像URL。粘贴URL或单击选择并使用下拉列表查找。检查高级设置以指定服务器硬件、容器端口和附加命令、最大请求数和扩展行为。</p><p id="9f53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您准备好构建和部署时，请单击创建！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pd"><img src="../Images/c6fc3c039ea371b527ff0d33108af371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pDuEZo4-Ag7N2LM8.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">从GCR选择一个容器图像</p></figure><p id="a63e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将进入GCP云运行服务详细信息页面，在此您可以管理服务、查看指标和构建日志。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pe"><img src="../Images/761a2753db8c736a723e955d63de43fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D2cU2KVXcpIm5FCD.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">服务详情</p></figure><p id="4c40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单击URL查看您部署的应用程序！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pf"><img src="../Images/ef8cd1e54bc4f1265e104bd6e6d749fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Csi5OJKDllsO4XxM.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">优秀</p></figure><p id="dd88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你！您刚刚将一个打包在容器中的应用程序部署到云环境中。</p><p id="96ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您只需为请求处理过程中消耗的CPU、内存和网络资源付费。也就是说，当你不想付费时，一定要关闭你的服务！</p><h1 id="1f38" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="bc06" class="pw-post-body-paragraph ki kj it kk b kl ng ju kn ko nh jx kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">正如我们所看到的，决定一个模型是好是坏有其复杂性和细微差别。请记住，我们已经用简单的数据解决了一个简单的问题。随着问题复杂性的增加，进行EDA和分析模型输出变得更加复杂和相关。一旦你有了一个“足够好”的模型，下一步就是为这个模型服务。</p><p id="2536" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速开发出任何像样的好模型都有巨大的商业和技术价值。拥有人们可以立即使用的东西和部署数据科学家可以稍后调整的软件的价值。部署软件可能是一个挑战，但这是一个越早越好的障碍；尽早部署，经常部署。此外，Docker等服务简化了部署过程。</p><p id="1e7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望这些内容是有益的；让我们知道你想在软件、开发和机器学习领域了解更多的东西！</p></div></div>    
</body>
</html>