<html>
<head>
<title>Practical Guide to Entity Resolution — part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体解析实用指南—第5部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practical-guide-to-entity-resolution-part-5-5ecdd0005470?source=collection_archive---------21-----------------------#2020-11-07">https://towardsdatascience.com/practical-guide-to-entity-resolution-part-5-5ecdd0005470?source=collection_archive---------21-----------------------#2020-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="43e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">匹配评分迭代</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6a0601f70eb2280c2703510bab5a0755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0qWXV_wUH8mA_S8n"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">劳拉·奥克尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d2b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是关于实体解析的小型系列的第5部分。如果你错过了，请查看<a class="ae kv" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-1-f7893402ea7e" rel="noopener">第1部分</a>、<a class="ae kv" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-2-ab6e42572405" rel="noopener">第2部分</a>、<a class="ae kv" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-3-1b2c262f50a7" rel="noopener">第3部分</a>、<a class="ae kv" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-4-299ac89b9415" rel="noopener">第4部分</a></p><p id="4e6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大多数真实的ER用例中，没有关于哪个候选对应该匹配，哪个不应该匹配的基本事实。获得良好匹配精度的唯一方法是在迭代学习循环中引入人工判断，并逐步改进评分算法。在这篇文章中，我们将讨论如何建立这个学习循环。</p><p id="b485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概括地说，这个过程看起来像</p><ol class=""><li id="9a17" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">初始朴素得分函数输出的示例</li><li id="4739" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">手动检查并标记采样的候选对</li><li id="f03a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过比较手动标签和分数分布来评估分数准确性</li><li id="ae75" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通过在有保证和适当的情况下引入额外的比较功能来改进决策标准</li><li id="c2a0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将标签和特征输入分类算法，以学习最佳评分函数</li><li id="d5cb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">重复进行，直到达到可接受的精度水平</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/f2a80f4b58d5b4c693e41ee92eace3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRokOvNUlhS1pv13lrOMwQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分数迭代学习循环</p></figure><p id="6175" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从初始评分函数中取样并手动检查输出相当简单，但是有一些实际的东西值得注意</p><ol class=""><li id="b515" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">完全匹配和完全不匹配不值得研究。实际上，这意味着得分为0(没有任何特征匹配)和1(所有特征完全匹配)的对应该被过滤掉。</li><li id="8f43" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">值得思考的是通过最佳的视觉布局，让人工审核和标注尽可能的容易。有像<a class="ae kv" href="https://snorkel.readthedocs.io/en/v0.9.3/packages/labeling.html" rel="noopener ugc nofollow" target="_blank">通气管</a>这样的工具来帮助这种类型的工作流程。在我们的示例中，我们选择了一种相对较低的方法，即将候选对之间的对应特征堆叠到一个组合的字符串值中，以便更容易比较它们。</li><li id="7d38" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">可能会有需要使用分层抽样的用例。例如，您可能希望更多地关注来自不同源系统的记录之间的候选对，而花费较少的时间来审查来自相同源的候选对。您可能还想对相似性得分的不同范围进行不同的加权。我们在示例代码中没有这样做，但是使用PySpark方法<code class="fe mh mi mj mk b">sampleBy</code>实现并不困难</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/63113672c00f83f08ccc4fff73db7093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XT8AslWjcIVoYeYHP4Q5ug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自采样候选对的示例输出</p></figure><p id="9a22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过查看采样输出，我们可以立即看到，我们使用的简单评分函数远非完美。<code class="fe mh mi mj mk b">adobe creative suite cs3 web standard upsell</code> <br/>和<code class="fe mh mi mj mk b">adobe creative suite cs3 web standard [mac]</code>之间的最高分候选对之一显然不匹配。事实上，有很多这种不匹配的例子，产品的升级版本看起来与原始产品非常相似。解决这个问题的一个潜在方法是引入另一个特征，该特征指示产品是否是扩展/升级/追加销售而不是全功能版本。</p><p id="c2b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在此之前，我们可以将现有的特征和手动输入的<code class="fe mh mi mj mk b">human_label</code>输入到ML分类算法中，该算法可以学习如何以最佳方式将各个相似性度量组合到评分函数中。下面是实现这一点的PySpark代码示例。</p><p id="7dba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几件值得注意的实际事情</p><ol class=""><li id="31af" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">即使有好的阻挡策略，大部分候选对也可能是明显的不匹配。在应用模型之前将它们过滤掉是有用的。这减少了匹配与非匹配类的不平衡，这种不平衡会对模型的功效产生负面影响。在我们的示例中，我们这样做是为了过滤掉低于阈值0.06的任何对。这是通过手动检查采样的候选对来任意选择的，并且可以根据需要进行调整。</li><li id="a75e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在可能的情况下，使用基于编程规则的附加标签来补充人工标签是很有帮助的。算法需要学习的标签数据越多，它的表现就越好。在我们的例子中，我们选择将<code class="fe mh mi mj mk b">overall_sim</code>为1或者<code class="fe mh mi mj mk b">name_tfidf_sim</code>为1的候选对标记为程序化匹配。这里的直觉是，如果名称完全匹配，我们可以很有把握地认为这两个列表是同一产品。另一方面，我们已经选择标记具有小于0.12的<code class="fe mh mi mj mk b">overall_sim</code>的候选对。这也是根据采样输出任意选择的。这些阈值可以而且应该作为迭代的一部分进行调整。</li><li id="6f2e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">对于我们的示例用例，我们选择使用<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn </a>的随机森林分类器实现，因为它提供了围绕超参数调整和评估的更灵活的API。但是对于单个节点上的内存无法容纳的大规模用例，可能有必要使用<a class="ae kv" href="https://spark.apache.org/docs/latest/api/python/pyspark.ml.html#module-pyspark.ml.classification" rel="noopener ugc nofollow" target="_blank"> PySpark ML库</a>，它实现了许多分类算法，可以很好地与PySpark生态系统的其余部分集成。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="1034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦模型得到调整，我们有了适当的交叉验证指标，我们将希望应用该模型对更广泛的领域进行评分，并检查输出匹配概率与人类判断的对比。PySpark代码示例如下。</p><p id="290d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是<code class="fe mh mi mj mk b">pandas_udf</code>的使用，它可以通过Apache Arrow实现更高效的序列化，通过numpy实现更高效的矢量化计算，从而获得比标准UDF更好的性能。要了解更多关于<code class="fe mh mi mj mk b">pandas_udf</code>的信息，我推荐阅读中的<a class="ae kv" href="https://spark.apache.org/docs/latest/sql-pyspark-pandas-with-arrow.html" rel="noopener ugc nofollow" target="_blank">示例。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/d03221891daef220711260e78da71c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ilNg_Z_iEmWmpP1k6HInA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基于匹配概率建模的采样输出</p></figure><p id="b0cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从新的样本中，我们可以看到模型在挑选匹配对方面做得更好，即使初始天真评分函数给出的相似性较低。这样，我们通过更新的评分函数和来自新评分分布的更新样本，有效地结束了学习循环。基于与人类判断的进一步比较的结果，我们可能想要添加额外的特征，以标记工作为目标，更新模型/评分函数，并且再重复该过程几次，直到达到期望的准确度水平。</p><p id="f816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看<a class="ae kv" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-6-e5d969e72d89" rel="noopener">实体生成</a>的最后部分</p></div></div>    
</body>
</html>