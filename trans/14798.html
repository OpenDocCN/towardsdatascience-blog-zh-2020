<html>
<head>
<title>How to use the SimpleImputer Class in Machine Learning with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python在机器学习中使用SimpleImputer类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-the-simpleimputer-class-in-machine-learning-with-python-10b321c94861?source=collection_archive---------30-----------------------#2020-10-12">https://towardsdatascience.com/how-to-use-the-simpleimputer-class-in-machine-learning-with-python-10b321c94861?source=collection_archive---------30-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c287" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简单地使用简单估算器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d35ae2f4e394c3c850e9de12ef58ae0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7FmLppqmHwkkqKViQyOcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由罗斯·斯奈登<a class="ae ky" href="https://unsplash.com/photos/sWlDOWk0Jp8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>提供</p></figure><h2 id="a6c5" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">缺失值插补</h2><p id="43c8" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">数据集经常有缺失值，这可能会给机器学习算法带来问题。在执行预测建模之前，识别并替换数据集每一列中缺失的值被认为是一种良好的做法。这种缺失数据替换的方法被称为数据插补。</p><p id="bcc6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">数据集中的缺失值可能是由多种原因造成的。这些通常包括但不限于:测量设备故障、不一致数据集的整理以及实验期间数据收集的变化。</p><p id="1e5c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">缺失数据插补的一个方便策略是用一列中其他值计算出的统计值替换所有缺失值。这种策略通常可以带来令人印象深刻的结果，并避免在构建机器学习算法时丢弃有意义的数据。常用的统计包括计算列的平均值、中值和众数，并为缺失值输入该值。此外，可以输入一个常数值来补充上述方法。</p><p id="63a1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">本教程旨在演示简单估算类在统计估算中的用法。</p><h2 id="d07f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">数据集和缺失数据评估</h2><p id="fdfc" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">本教程中使用的数据集是“<em class="mt">逻辑回归预测心脏病</em>数据集，可通过这里的<a class="ae ky" href="https://www.kaggle.com/dileep070/heart-disease-prediction-using-logistic-regression" rel="noopener ugc nofollow" target="_blank"> kaggle </a>或我的<a class="ae ky" href="https://github.com/StephenFordham/scikit-learn_tutorials" rel="noopener ugc nofollow" target="_blank"> github页面</a>获得。</p><p id="6ac4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该数据集来自一项正在进行的对马萨诸塞州弗雷明汉镇居民的心血管研究。分类目标是预测患者是否有未来冠心病(CHD)的10年风险。数据集提供了患者的信息。它包括4000多条记录和15个属性。这些属性可以通过kaggle找到。我在这里的主要目的不是深入研究这个数据集，而是展示一个使用SimpleImputer类进行预测建模的用例。</p><p id="630c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">首先导入所需的库，并执行一些探索性数据分析(EDA)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="12b7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">dataframe上调用的dataframe和columns属性的头显示了所有15个数据属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/279886ff300dd22e7a1aa7511e57686a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIqkdKhcznBHcJdqf1DcPA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/80910b72d0faf4cf56673de1595e561b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgDfRoZwEAYQXRhj59lRVw.png"/></div></div></figure><p id="907e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了计算缺失值的数量以及它们相对于列的百分比，我首先对列进行迭代。对于每一列，我使用isna()方法调用来评估NaN值的数量，并通过方法链接对这些值求和。</p><p id="6e55" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">然后，我计算总行数中缺失值的数量，得到每列缺失值的百分比，并打印出这些数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/4bef1581c3e93d5d47e22b007321ef4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqUOITtUbdXIYcXoRQyoUA.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0508" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">虽然这是信息性的，但需要一些阅读来完全解释结果。确定缺失结果的更好方法可能是使用seaborn热图制作一个有用的图形。</p><p id="d150" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们首先传入dataframe.isna()，如果缺少值，它将返回True。然后，我们可以将cbar和ytickslabels都设置为False，选择一个颜色映射(这里是字符串viridis)，并可视化结果。</p><p id="c58c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在我们有了一个快速参考图，它可以有效地告诉我们，哪些列缺少数据。在这里，我们可以看到葡萄糖列丢失的数据值最多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/215a5c70f6375a0df11994a5d5bbe0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bv9GCSzDB59qDO-ownK0iA.png"/></div></div></figure><h2 id="8f78" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">简单估算类的统计估算</h2><p id="24a3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">sci-kit learn机器学习库提供了实现统计插补的SimpleImputer类。</p><p id="05fd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">要使用SimpleImputer，首先导入该类，然后用传递给策略参数的字符串参数实例化该类。为了清楚起见，我在这里包含了‘mean ’,这是默认的，因此没有必要显式包含。</p><p id="abf5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我通过调用dataframe上的值将dataframe转换成一个numpy数组(不必要)，但这是我喜欢的习惯。然后我选择我的特征并把它们赋给变量X，选择我的目标变量并把它赋给变量y。</p><p id="3044" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">估算值适合数据集，用于计算每列的统计数据。然后将拟合估算值应用于数据集，以创建数据集的副本，其中每列的所有缺失值都用计算出的均值统计数据替换。</p><p id="f42d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了确认数据插补有效，我们可以评估应用和不应用数据转换的数据集上缺失值的数量。当应用数据转换时，已经估算了645个列值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1dd90ba604e4b53723473ca796517694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*kh59E0TKN3a9yyElqMNfBA.png"/></div></figure><h2 id="d23d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模型评估</h2><p id="cc70" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">模型评估最好使用重复的<em class="mt"> k- </em>折叠交叉验证。要求首先在训练数据集上计算每列的计算统计量，然后应用于数据集中每个折叠的训练集和测试集。</p><p id="ee26" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了实现这一点，我们可以创建一个建模管道，其中第一步是统计插补，第二步是模型本身。</p><p id="ccfd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">以下管道使用均值策略进行统计插补，并使用RandomForestClassifier进行模型预测。</p><p id="6d36" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们达到了84.7%的准确率，标准偏差为0.007。这是一个合理的结果，但了解哪种插补策略最适合预测建模性能会很有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/91efdd3dca529bd549afeb8f811569c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFvsyPsWvguUiZH_e80y6A.png"/></div></div></figure><h2 id="537c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试插补策略</h2><p id="6618" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">为了测试不同的插补策略，我们可以遍历这些策略。对于每个管道，我们可以构建一个新的策略，计算交叉值分数，并将它们添加到结果列表中。</p><p id="8339" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们可以使用结果列表中的数组和策略类型来生成一个盒须图，以解读哪种数据插补策略是最佳的。我已经决定检查每种策略类型的平均分数和最高分数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/d6ae39e1fdfcb459e452a551d885ed4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GFToQExOsz2kk9owwz04_Q.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="43e6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">盒状图和须状图表明使用常数(0)插补策略获得了最佳准确度分数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/ff117414b8c764a6bef6357872f9c33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUbA_A34RypXsGga8_sp4Q.png"/></div></div></figure><h2 id="aa0a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">对样品进行测试</h2><p id="137d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在可以使用最佳插补策略进行预测。根据所有可用数据定义和拟合管道。</p><p id="b440" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们可以获取数组中的第一行，对其进行整形，将其赋给变量名sample，并将其作为参数传递给管道上调用的predict方法调用。</p><p id="d947" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了确认这是正确的结果，我们可以检查第一个y目标变量标签。我们的模型预测了一个0类，而这个类实际上也是一个0类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9e3d02ce9d389e516624d81cbed0347d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFFcEaYmBmYy2At26p06kw.png"/></div></div></figure><h2 id="f4bc" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h2><p id="be22" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">简单估算类是使用计算统计数据估算缺失值的有效方法。通过使用<em class="mt"> k </em> -fold交叉验证，我们可以快速确定传递给SimpleImputer类的哪个策略给出了最佳的预测建模性能。</p><h2 id="3819" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">链接到完整的Jupyter笔记本</h2><p id="a6a3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这个教程的完整Jupyter笔记本的链接可以在<a class="ae ky" href="https://github.com/StephenFordham/scikit-learn_tutorials/blob/main/heart%20disease%20model.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>