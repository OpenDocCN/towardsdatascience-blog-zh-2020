<html>
<head>
<title>Building a user classifier using Twitter data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Twitter数据构建用户分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-user-classifier-using-twitter-data-283dfd0c0e59?source=collection_archive---------31-----------------------#2020-11-04">https://towardsdatascience.com/building-a-user-classifier-using-twitter-data-283dfd0c0e59?source=collection_archive---------31-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="aae8" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="f6a5" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用随机森林学习方法构建分类器。用Twitter数据训练它。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f6be3f605f68625f952938024d467596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8W5ga8ss34DT1OJQUItyA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">德国巴伐利亚的森林。我拍的照片。</p></figure><p id="fa54" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Twitter平台提供了大量的数据。一个机器学习算法需要大量的数据来建立一个好的模型。因此，我们通过使用Twitter数据进行训练来构建ML预测器是一个好主意。</p><p id="f84e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">无论用户是否有特定的政治观点，我们都将建立一个分类器。我们使用Twitter推文、用户和朋友数据来构建分类器。此外，我们将使用随机森林作为我们的学习算法，使用Python作为我们的开发平台。</p><h1 id="ff2b" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">步骤:</h1><ol class=""><li id="f968" class="ms mt iq lg b lh mu lk mv ln mw lr mx lv my lz mz na nb nc bi translated">识别和收集Twitter数据。</li><li id="4089" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">给数据贴标签。</li><li id="419e" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">做特色工程。</li><li id="5da3" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">转换数据。</li><li id="72d8" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">训练模型。</li><li id="52ab" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">评估模型。</li></ol><h1 id="8a37" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">识别和收集Twitter数据</h1><p id="c459" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">我们需要收集推文、用户和用户的朋友。我们以前的文章已经讨论了如何实现这一点。结果在关系数据库中。下图显示了数据库模式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/26bf90d097c24009800b4183391ec828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoZNnEl9U8aDRwezW056dg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">收集Twitter数据库模式。由dbdiagram.io构建和生成</p></figure><p id="780e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这里我们有<strong class="lg ja"> Tweet </strong>表存储所有的Tweet(和retweets)。<strong class="lg ja">标签</strong>表保存了推文中发现的标签。<strong class="lg ja">用户</strong>表包含所有发tweet或retweet的用户。<strong class="lg ja"> User_Friend </strong>表存储每个用户和他们的朋友(他或她关注的用户)之间的关系。有<strong class="lg ja"> Hashtag </strong>和<strong class="lg ja"> Tweet </strong>表和<strong class="lg ja"> Tweet </strong>和<strong class="lg ja"> User </strong>表等表关系。我们将使用这些关系编写一个SQL查询来将三个表连接在一起。</p><p id="f036" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">稍后，我们将在下一节讨论<strong class="lg ja"> User_class0 </strong>和<strong class="lg ja"> User_class1 </strong>。</p><h1 id="06aa" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">给数据贴标签</h1><p id="2fa7" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">我们把用户分成两类，保守的和非保守的。我们需要一种给用户贴标签的方式。我们是这样做的:</p><ul class=""><li id="714b" class="ms mt iq lg b lh li lk ll ln nm lr nn lv no lz np na nb nc bi translated">首先，我们列出流行的标签。</li><li id="b081" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz np na nb nc bi translated">然后，我们识别这些词中哪些可能与我们感兴趣的用户类别相关，保守。</li><li id="8509" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz np na nb nc bi translated">接下来，我们可以在数据库中查询包含这些单词的推文。发布推文的用户会很保守。</li><li id="e75c" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz np na nb nc bi translated">其余的用户可能是非保守的。</li></ul><p id="2ebe" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将保守派放入<strong class="lg ja"> User_class1 </strong>，将非保守派放入<strong class="lg ja"> User_class0 </strong>。</p><p id="094c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们收集了2020年10月22日的Twitter推文、标签和用户，地点是泰国。我们收到了240万条推文。通过使用该标准，我们发现了3463名保守用户和47775名非保守用户。在我们的数据集中，我们从班级1中随机选择3000人，从另一个班级中随机选择5000人。将它们混洗并分成训练和测试数据集。训练得到了70%，测试得到了所有数据的30%。</p><h1 id="0fe9" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">做特征工程</h1><p id="a9ba" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">我们有一个基本的想法，即观点相似的用户可能会追随或倾听同一组影响者。对于每个用户，我们使用用户的朋友作为特征。因为一些用户可能有大量的用户(在Twitter上被称为朋友)，我们会将功能中的朋友数量限制在某个特定的数量，如500。</p><p id="183d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们根据训练数据集中的追随者数量选择前500位朋友作为我们的特征。</p><h1 id="08e6" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">转换数据</h1><p id="2df1" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">我们需要做一些工作来将数据转换成特征向量。我们从Twitter收到的朋友数据如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7ba1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">假设我们的数据包括A、B和c。此外，最好的朋友是W、X、Y和z。要转换这一点，我们需要执行以下操作:</p><ul class=""><li id="e5a8" class="ms mt iq lg b lh li lk ll ln nm lr nn lv no lz np na nb nc bi translated">只保留我们数据集上的用户。例如，删除包含用户D和e的行。</li><li id="64c0" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz np na nb nc bi translated">只保留朋友向量中的朋友(顶级朋友)。例如，删除包含朋友U和v的行，输出应该如下所示:</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="9abe" class="ms mt iq lg b lh li lk ll ln nm lr nn lv no lz np na nb nc bi translated">做交叉列表。输出将是我们需要的特征向量。例如，如果用户A跟随W、X和Y。用户B跟随W和Y。用户C跟随Y和z。特征向量应该是这样的:</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="e8fd" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">训练模型</h1><p id="54df" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">一旦我们得到了用于训练和标签输出的特征向量，训练分类器就简单了。以下是部分Python代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7f5d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja"> X_train </strong>表示训练数据的特征向量。<strong class="lg ja"> y_train </strong>是已知输出</p><ul class=""><li id="0a0c" class="ms mt iq lg b lh li lk ll ln nm lr nn lv no lz np na nb nc bi translated">我们实例化了随机森林分类器。</li><li id="50ad" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz np na nb nc bi translated">我们传递训练数据和已知输出来拟合模型。</li></ul><p id="56b3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">就是这样。分类器准备好了。</p><h1 id="0781" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">评估模型</h1><p id="6ae7" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">下一步是使用测试数据运行模型，获得预测，并将结果与已知输出进行比较。<strong class="lg ja"> X_test </strong>代表测试数据的特征向量。<strong class="lg ja"> y_test </strong>为已知输出。最后，<strong class="lg ja"> y_pred </strong>是模型预测。从结果来看:</p><ul class=""><li id="7a5d" class="ms mt iq lg b lh li lk ll ln nm lr nn lv no lz np na nb nc bi translated"><strong class="lg ja"> ROC AUC </strong>得分为0.93。这很好。</li><li id="1ee9" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz np na nb nc bi translated">一级精度为92%。这意味着在所有的模型中，92%的模型显示它们是1类。</li><li id="fc6d" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz np na nb nc bi translated">一级召回率为79%。这意味着该模型可以识别79%的第一类。</li><li id="51b1" class="ms mt iq lg b lh nd lk ne ln nf lr ng lv nh lz np na nb nc bi translated">准确率相当不错，达到了89%。但这意义不大，因为数据不平衡。</li></ul><h2 id="1fc3" class="ns mb iq bd mc nt nu dn mg nv nw dp mk ln nx ny mm lr nz oa mo lv ob oc mq iw bi translated">特征重要性</h2><p id="9b54" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">随机森林算法也可以识别特征的相对重要性。每个值的范围从0到1。所有重要度之和为1。以下Python代码显示了如何从学习模型中检索要素重要性，并绘制最高值图表。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d9b0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因为在我们的模型中，特征是用户的朋友，所以这张图显示了影响者的重要性。正如我们所看到的，前几个特性的值明显高于其余的，然后逐渐降低，最后接近零。</p><p id="3f98" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">此外，只要再多一点代码，我们应该能够列出顶级用户的屏幕名称。因此，我们可以看到这些影响者的相对重要性。</p><h2 id="969c" class="ns mb iq bd mc nt nu dn mg nv nw dp mk ln nx ny mm lr nz oa mo lv ob oc mq iw bi translated">特征数量</h2><p id="f1ab" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">我们将功能(朋友)的数量设置为500。我们可以使用更少或更多吗？最佳值是多少？我们有一些代码来获得下面不同数量特征的ROC AUC得分:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f4c3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从图中可以看出，<strong class="lg ja"> ROC AUC </strong>分数在特征数超过500后没有太大的提高。所以，500应该没问题。</p><h1 id="30f4" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">结论</h1><p id="869e" class="pw-post-body-paragraph le lf iq lg b lh mu ka lj lk mv kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">我们从Twitter上收集推文、标签、用户和用户的朋友。使用标签将用户分为两类。我们使用用户的朋友作为我们的特征。将收集的数据转换成适当的特征向量。我们使用随机森林分类器作为学习算法，并用我们的数据训练它。<br/>测试成绩看起来不错。<strong class="lg ja"> ROC AUC </strong>，精度，召回率高。这意味着我们的方法运行良好，应该能够自信地预测结果。</p><p id="1b3b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">本文完整python代码<a class="ae od" href="https://gist.github.com/mananai/03e446675b2729e52e3bce5e90a40c47" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>