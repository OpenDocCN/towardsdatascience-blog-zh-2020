<html>
<head>
<title>Manage Files and Database Connections in Python Like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专家一样管理Python中的文件和数据库连接</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/manage-files-and-database-connections-in-python-like-a-pro-73e8fc0b7967?source=collection_archive---------9-----------------------#2020-09-30">https://towardsdatascience.com/manage-files-and-database-connections-in-python-like-a-pro-73e8fc0b7967?source=collection_archive---------9-----------------------#2020-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8cd3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用自定义上下文管理器管理Python中的外部资源</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ad74c159077ad0c53612c3fcecb5bd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KNM9oxkJRayijMeYyqawg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@psad?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">余伟</a>从<a class="ae ky" href="https://www.pexels.com/photo/greyscale-photo-of-people-walking-inside-tunnel-2081168/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</p></figure><p id="4bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据工程和数据科学中，我们经常需要从数据库或平面文件中检索数据。但是，使用来自外部资源的数据而不关闭与底层数据库或文件的连接可能会导致不必要的后果。在本文中，我们将讨论如何构建定制的上下文管理器，帮助我们以安全有效的方式使用这些资源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8d41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">上下文管理器</h1><p id="0d5f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">多亏了<a class="ae ky" href="https://docs.python.org/3/library/contextlib.html" rel="noopener ugc nofollow" target="_blank">上下文管理器</a>，我们可以从外部资源读取数据，并确保与底层数据库或文件的连接已关闭，即使我们在代码中遇到一些未处理的异常。</p><blockquote class="mz na nb"><p id="d6ed" class="kz la nc lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">上下文管理器的典型用途包括保存和恢复各种全局状态、锁定和解锁资源、关闭打开的文件等[1]</p></blockquote><p id="7d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关闭资源至关重要，因为同时打开的文件或数据库连接的数量是有限制的。可以同时打开的文件数量取决于相应操作系统允许的文件描述符数量。在Linux和macOS上，我们可以通过使用<code class="fe ng nh ni nj b">ulimit -n</code> [2]来检查这个数字:</p><pre class="kj kk kl km gt nk nj nl nm aw nn bi"><span id="21fb" class="no md it nj b gy np nq l nr ns">➜  ~ ulimit -n<br/>256</span></pre><p id="2656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，并发数据库连接的数量也有限制。例如，默认情况下，开放PostgreSQL连接的最大数量限制为100 [3]。</p><h2 id="9b55" class="no md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">上下文管理器的典型用法</h2><p id="e601" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面的代码显示了上下文管理器的典型用法:</p><ul class=""><li id="ca48" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">将数据写入文件</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><ul class=""><li id="3951" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">从同一文件中读取数据:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="349a" class="no md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">上下文管理器背后的原因</h2><p id="75b6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能会问:为什么不直接向文件写入和读取数据，而不添加这个<code class="fe ng nh ni nj b">with</code>？我们可以编写如下相同的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是想象一下，如果我们在写入这个文件时遇到错误，会发生什么？连接永远不会关闭。我们可以通过将代码包含在<code class="fe ng nh ni nj b">try-finally</code>块中来改进这一点，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="72a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这可能写起来很乏味，我们的代码变得冗长。因此，上下文管理器是很棒的——我们可以在仅仅两行代码中完成更多的工作，并且我们的代码变得更具可读性。</p><p id="8cc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结起来，上下文管理器的理由是:</p><ul class=""><li id="b3ff" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">确保资源被释放，即使我们遇到一些未处理的异常</li><li id="4942" class="oe of it lb b lc op lf oq li or lm os lq ot lu oj ok ol om bi translated">可读性</li><li id="2fb2" class="oe of it lb b lc op lf oq li or lm os lq ot lu oj ok ol om bi translated">便利——我们让自己变得更容易，因为我们不再<em class="nc">忘记</em>关闭与外部资源的连接。</li></ul><h1 id="0294" class="mc md it bd me mf ou mh mi mj ov ml mm jz ow ka mo kc ox kd mq kf oy kg ms mt bi translated">自定义上下文管理器</h1><p id="05b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有两种定义上下文管理器的方法:使用定制类，或者使用生成器[4]。让我们看看生成器选项，创建一个上下文管理器，让我们管理一个MySQL数据库连接。</p><h2 id="a37c" class="no md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">用上下文管理器处理MySQL数据库连接</h2><p id="845e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">该逻辑与使用<code class="fe ng nh ni nj b">try-finally</code>块的逻辑相似，除了我们<strong class="lb iu">产生</strong>连接对象，而不是返回它——这是由于生成器在需要时会延迟返回对象的性质(<em class="nc">即，当我们迭代它们时</em>)。在我们的例子中，上下文管理器将产生一个值——连接对象。</p><p id="311c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们所要做的就是添加一个装饰器<code class="fe ng nh ni nj b">@contextlib.contextmanager</code>，并在<code class="fe ng nh ni nj b">try</code>块中使用<code class="fe ng nh ni nj b">yield</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="1037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用这个上下文管理器将MySQL中的数据检索到pandas数据框中，我们只需通过上下文管理器导入并应用这个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="a8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们的<em class="nc"> bus_logic.py </em>脚本变得多么简单！</p><p id="ef39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">try</code>块可以包含任何定制的设置代码，比如从secrets manager、环境变量或配置文件中检索配置细节和凭证。同样，在<code class="fe ng nh ni nj b">finally</code>-块中，您可以定义任何拆卸逻辑，比如删除临时文件、关闭连接或改回工作目录。这是我们接下来要做的。</p><h2 id="59da" class="no md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">使用上下文管理器临时更改工作目录</h2><p id="d7c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设您在<code class="fe ng nh ni nj b">src</code>目录中，但是当您从S3下载文件时，您想将它们存储在<code class="fe ng nh ni nj b">data</code>目录中。在这种情况下，我们可能希望暂时将工作目录更改为<code class="fe ng nh ni nj b">data</code>文件夹，并在功能完成后将其更改回之前的目录。以下上下文管理器可以实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="83a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用上面的上下文管理器，我们可以确保我们在下载文件时位于正确的目录(<em class="nc"> data </em>)。然后，一旦下载完成，我们就变回原来的工作目录。</p><h1 id="6ea1" class="mc md it bd me mf ou mh mi mj ov ml mm jz ow ka mo kc ox kd mq kf oy kg ms mt bi translated">结论</h1><p id="4823" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们研究了Python中的上下文管理器，它让我们能够以更优雅的方式处理外部资源。当未处理的异常导致我们的脚本在拆卸代码有机会执行之前结束时，它们还可以防止可能发生的错误。这样，上下文管理器可以防止离开锁定的资源、打开的文件或数据库连接。最后，通过抽象出安装和拆卸代码，它们使我们的代码更具可读性。</p><p id="ff5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！如果这篇文章有帮助，请随时关注我的下一篇文章。</p><p id="5b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">资源:</strong></p><p id="8359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]<a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html#context-managers" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/reference/data model . html # context-managers</a></p><p id="3834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="https://stackoverflow.com/questions/2425084/how-many-files-can-i-have-opened-at-once" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2425084/我能一次打开多少个文件</a></p><p id="c9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]<a class="ae ky" href="https://www.postgresql.org/docs/current/runtime-config-connection.html" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/docs/current/runtime-config-connection . html</a></p><p id="ecca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://book.pythontips.com/en/latest/context_managers.html" rel="noopener ugc nofollow" target="_blank">https://book.pythontips.com/en/latest/context_managers.html</a></p></div></div>    
</body>
</html>