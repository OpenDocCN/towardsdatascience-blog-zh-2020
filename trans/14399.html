<html>
<head>
<title>6 Mathematical Functions For Algorithm Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6个用于算法分析的数学函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/6-functions-you-need-for-algorithm-analysis-482a2f69ac0e?source=collection_archive---------24-----------------------#2020-10-04">https://towardsdatascience.com/6-functions-you-need-for-algorithm-analysis-482a2f69ac0e?source=collection_archive---------24-----------------------#2020-10-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ab19" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">理解计算时间复杂度所需的基本函数</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/03d037345f07e6815bd6d0c7ded04648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJYo_EDhLwvkPoC4ly2R2g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">unspalsh.com<a class="ae kz" href="https://unsplash.com/photos/BXOXnQ26B7o" rel="noopener ugc nofollow" target="_blank">上</a>的<a class="ae kz" href="https://unsplash.com/@aronvisuals" rel="noopener ugc nofollow" target="_blank"> Aron视觉效果图</a></p></figure><p id="b5f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">设计和实现算法时需要考虑的最重要的因素之一是算法分析期间计算的时间复杂度。</p><p id="628a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">时间复杂度对应于算法在所提供的输入上运行以生成所需输出所需的时间量。在本文中，我们将讨论算法分析中最常用的函数。此外，还提供了一些代码示例，以帮助读者理解这些功能如何与计算机执行的常见操作相关联，作为算法执行的一部分。</p><h1 id="6b8c" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">常值函数</h1><p id="a21d" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">这可能是最简单的函数，对于任何参数<strong class="lc iv"> <em class="mt"> n </em> </strong> <em class="mt">，</em>常量函数赋值<strong class="lc iv"> <em class="mt"> c </em> </strong>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mu"><img src="../Images/5d366d2649b1bca8b136c9db293118f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/format:webp/1*D75hYHdPBleFj7TBt1bdjA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">常数函数</p></figure><p id="19a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我们需要计算一个算法执行的基本操作的数量时，常量函数是很有用的。一些例子可以是整数加法或减法以及变量赋值或比较。</p><pre class="kk kl km kn gu mv mw mx my aw mz bi"><span id="30c1" class="na lx iu mw b gz nb nc l nd ne"># Examples of basic operations</span><span id="d6a5" class="na lx iu mw b gz nf nc l nd ne">x = 10<br/>name = 'Andrew'<br/>is_verified = True</span></pre><h1 id="8f97" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">线性函数</h1><p id="1b76" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">另一个在我们的上下文中很重要的简单函数是线性函数，它非常类似于常数函数，但是线性函数不是给函数分配一个常数值，而是简单地分配给它自己的输入。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/7e2d9c1c435e044b81beb1c2dad08efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/format:webp/1*7PFtS20NGfqY_AnunO0aDw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">线性函数</p></figure><p id="20d4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当分析需要在所有n个元素上执行的操作时，线性函数非常有用。一个例子是读取未存储在计算机内存中的n个元素序列的过程(即，要读取所有元素，我们需要执行<strong class="lc iv"> n </strong>操作)。</p><p id="37c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">复杂度为N的操作示例:</p><pre class="kk kl km kn gu mv mw mx my aw mz bi"><span id="aa9e" class="na lx iu mw b gz nb nc l nd ne">my_list = [1, 2, 3, 4, 5]</span><span id="3eab" class="na lx iu mw b gz nf nc l nd ne">for i in my_list:<br/>    print(i == 2)</span></pre><h1 id="a45c" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">对数函数</h1><p id="330d" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">对数函数是算法分析中最常用的函数之一。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nh"><img src="../Images/32433962d46a20cbcc51dd5a90493039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*15IpLp4Ain1LW4sc4g1Dig.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">对数函数</p></figure><p id="5b6c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">如何近似对数</strong></p><p id="ecdd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了计算任何整数的精确对数，我们需要应用微积分。然而，在算法分析的上下文中，我们不一定需要精确的值，因为一个好的近似值就足以满足我们的目的。为了做到这一点，我们通常使用<strong class="lc iv">上限</strong>，即大于或等于对数的最小整数。例如，log16的ceil是4，因为((((16/2)/2)/2)= 1。同样，log 18的ceil是5，因为((((((18/2)/2)/2)/2)= 0.5625≤1。</p><p id="8ee0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，在每次迭代中将问题分成两半的算法对应于时间复杂度的对数级。这样的例子可能是下面显示的流行的二分搜索法算法。</p><pre class="kk kl km kn gu mv mw mx my aw mz bi"><span id="b91b" class="na lx iu mw b gz nb nc l nd ne">def binary_search(numbers, item):<br/>    first_index = 0<br/>    last_index = len(numbers)-1<br/><br/>    while first_index &lt;= last_index:<br/>        mid_index = (first_index + last_index)//2<br/>        if numbers[mid_index] == item:<br/>            return True<br/>        else:<br/>            if item &lt; numbers[mid_index]:<br/>                last_index = mid_index - 1<br/>            else:<br/>                first_index = mid_index + 1<br/><br/>    return False</span></pre><p id="4275" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意:在计算机科学中，我们通常使用以2为基数的对数，这是因为计算机的本质是用来存储二进制的。这可能有点令人困惑，因为在数学中“默认”基数是10，而大多数计算器都假定基数为10。在算法分析中，当底数被省略时，我们通常用底数等于2来解析对数函数。</p><h1 id="a952" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">二次函数</h1><p id="1865" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">另一个在复杂性分析中常见的函数是二次函数，它将输入<strong class="lc iv"> <em class="mt"> n </em> </strong>的平方指定给自己。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/4288dc0a2c4362ed7a069bcbd39ed190.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*oVV4WUyQYVv3U4plZxmNmQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">二次函数</p></figure><p id="deca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在算法分析中，用二次函数来描述<strong class="lc iv">嵌套循环</strong>的复杂度，即执行n次的n次运算序列。下面提供了一个例子，在给定一个列表的情况下，该算法试图找到并报告重复项。请注意，这绝对不是解决此类问题的最佳方法(就时间复杂性而言)。</p><pre class="kk kl km kn gu mv mw mx my aw mz bi"><span id="963c" class="na lx iu mw b gz nb nc l nd ne"># Example with n^2 time complexity</span><span id="81d2" class="na lx iu mw b gz nf nc l nd ne">n = [1, 2, 3, 4, 5]</span><span id="58cb" class="na lx iu mw b gz nf nc l nd ne">for i in n:<br/>    for j in n:<br/>        if i != j and n[i] == n[j]:<br/>            print(f'{n[i]} is a duplicate')</span></pre><h1 id="1545" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">立方函数</h1><p id="be08" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">与二次函数类似的一个函数是三次函数，它给自己分配输入<strong class="lc iv"> <em class="mt"> n </em> </strong>的立方。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/9cdf62baa490ac5d456c9608ce66918f.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*g3WRmyVt5XJD17Q4nals3w.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">三次函数</p></figure><p id="66fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">三次函数在算法分析中非常罕见，通常表示算法的设计性能很差。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="d394" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">常数、线性、二次和三次函数属于形式为的<strong class="lc iv">多项式函数的更大家族</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/0f553402f214a0e95b0ec7877243b125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOW9TYNepgvDPgZ-vTgLbg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">多项式函数</p></figure><p id="7b49" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其中<strong class="lc iv"> α </strong>是系数，而<strong class="lc iv"> d </strong>对应于<strong class="lc iv">多项式的次数。</strong>显然，次数较少的多项式的时间复杂度代表比次数较多的多项式更有效的实现。</p><h1 id="7973" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">指数函数</h1><p id="35f8" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">指数函数是衡量算法时间复杂度的另一个有用的函数。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nr"><img src="../Images/f12d3e1efb1459ed2b6846912203b3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*SAFWAABmP1ktYKS34-myLA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">指数函数</p></figure><p id="47a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该函数由基数<strong class="lc iv"> b </strong>和指数<strong class="lc iv"> n </strong>组成，后者被赋予输入值。与对数函数类似，我们假设指数函数的默认基数等于2。</p><p id="95d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">指数时间复杂度算法的一个非常常见的例子是下面给出的计算斐波那契数的递归函数(即调用自身的函数)</p><pre class="kk kl km kn gu mv mw mx my aw mz bi"><span id="a68b" class="na lx iu mw b gz nb nc l nd ne">def fibonacci(n):<br/>    if n &lt;= 1:<br/>        return n</span><span id="e221" class="na lx iu mw b gz nf nc l nd ne">    return fibonacci(n-1) + fibonacci(n-2)</span></pre><h1 id="6d07" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">为什么我们需要时间复杂性？</h1><p id="c446" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">现在让我们说，对于同一个问题，已经实现了许多不同的算法，我们需要决定哪一个更好(至少在时间复杂度方面)。测量每种算法的时间复杂度可以帮助我们决定哪种算法是最有效的，从而在性能方面更好。</p><p id="b1b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下表说明了输入大小和描述算法复杂性的函数对时间复杂性的影响。</p><pre class="kk kl km kn gu mv mw mx my aw mz bi"><span id="25b7" class="na lx iu mw b gz nb nc l nd ne">+---------+-----+-------+---------+-------+-----------+------------+<br/>| input n |  n  | log n | n log n |  n^2  |   n^3     |    2^n     |<br/>+---------+-----+-------+---------+-------+-----------+------------+<br/>| 8       | 8   |   3   |   24    | 64    | 512       | 256        |<br/>| 32      | 32  |   5   |   160   | 1024  | 32768     | 4294967296 |<br/>| 128     | 128 |   7   |   896   | 16384 | 2097152   | 3.4*10^38  |<br/>| 512     | 512 |   9   |   4608  | 262144| 134217728 | 1.34*10^154|<br/>+---------+-----+-------+---------+-------+-----------+------------+</span></pre><p id="615c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在很清楚，算法的设计应该确保它尽可能高效地完成工作，否则，时间复杂度会迅速增加，从而使实现效率低下，并且在许多情况下不可用。</p><h1 id="76e9" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">结论</h1><p id="37c8" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">在本文中，我们讨论了在计算算法的时间复杂度时最有用的基本函数。我们引入了许多多项式函数和Log函数，并研究了一些与上述每个函数相对应的代码示例。</p><p id="4ad9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">选择增长率尽可能低的算法很重要。以线性或n次登录时间运行的算法被认为是非常高效的，而诸如二次或三次之类的更高多项式阶的算法通常表示具有高增长率的低效算法，即，当它们需要在大型数据集上运行时，它们可能成为噩梦。</p></div></div>    
</body>
</html>