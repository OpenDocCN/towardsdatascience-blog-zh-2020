<html>
<head>
<title>Credit Card Customer Clustering with K-means</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于K均值的信用卡客户聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/credit-card-customer-clustering-with-k-means-b9ec023a7d6e?source=collection_archive---------16-----------------------#2020-10-19">https://towardsdatascience.com/credit-card-customer-clustering-with-k-means-b9ec023a7d6e?source=collection_archive---------16-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eed1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于信用卡数据集的k-means聚类和PCA的商业智能营销</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/86d448f4f7f3b1139416864ad21cff81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*SUdqcAwzZ0_U2xzQ8mGqoA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自pixabay的Img通过<a class="ae ku" href="https://pixabay.com/illustrations/tent-leaves-camping-icons-5635679/" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="22cd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在之前的<a class="ae ku" rel="noopener" target="_blank" href="/credit-card-fraud-detection-9bc8db79b956">帖子</a>中，我们试图使用各种模型来检测信用卡交易中的欺诈。这里我们将转向另一个热门话题——客户聚类。这个帖子旨在帮助市场部的朋友。像往常一样，它被分成5个部分。</p><ol class=""><li id="7511" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">问题陈述</li><li id="9151" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">数据审查</li><li id="bfb7" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">数据处理</li><li id="4f15" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">k均值聚类</li><li id="2baa" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">外卖食品</li></ol><p id="04f2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们开始旅程🏃‍♀️🏃‍♂️.</p><p id="f198" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 1。问题陈述</strong></p><p id="4dac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">众所周知，营销对于任何企业的发展和可持续性都是至关重要的。然而，对于任何营销专业人士来说，一个关键的痛点是了解客户并确定他们的需求。市场部的同事分配给你的任务是创建一个模型来执行客户分组。</p><p id="df26" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 2。数据回顾</strong></p><p id="ca5b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据集包含17个要素和8，950条记录。如图1所示，它是关于客户的购买和支付习惯，例如客户多久进行一次一次性或分期付款购买，或者他们多久进行一次现金预付，支付多少，等等。通过检查每个顾客，我们可以发现他/她喜欢哪种类型的购买，或者他/她是否喜欢预付现金而不是购买。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ki"><img src="../Images/45e36318089f17103a17853312badfcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*VuMjwxEJZ7-A5JFQa7HxfQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图1数据集列定义概述(图片由作者提供)</p></figure><p id="458a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 3。数据处理</strong></p><p id="1234" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一般来说，为了深入了解任何原始数据并获得初步发现，我们会执行探索性数据分析(EDA)。我在几篇文章中讨论了这个主题和一般步骤。如果你是EDA新手，看看我之前的<a class="ae ku" rel="noopener" target="_blank" href="/demystify-employee-leaving-with-eda-2ed96525f3a7">文章</a>。在这里，我们将重点关注以下建模所需的一些步骤。</p><p id="f082" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 3.1填充缺失值</strong></p><p id="24fc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由于各种原因，原始数据中经常出现缺失值。要检查每列中缺少多少值，</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0fc7" class="mo mp it mk b gy mq mr l ms mt">creditcard_df = pd.read_csv(‘Marketing_data.csv’)<br/>creditcard_df.isnull().sum()</span></pre><p id="f775" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如图2所示，列<em class="mu">‘信用额度’</em>有1个缺失值，而‘最小支付’有313个缺失值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/7725ce44ba43b564bf4f5efcd4555070.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*Er6bwtwIZFYw8JKoNCo_vg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图2缺失值计数(作者图片)</p></figure><p id="57a4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">处理缺失值的方法有很多，包括:</p><ul class=""><li id="9ace" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq mw lx ly lz bi translated">删除缺少值的列</li><li id="28c2" class="lr ls it kx b ky ma lb mb le mc li md lm me lq mw lx ly lz bi translated">插补，用某个数字填充缺失值，例如每列的平均值。</li><li id="fc73" class="lr ls it kx b ky ma lb mb le mc li md lm me lq mw lx ly lz bi translated">插补的扩展。插补是标准方法。但是，估算值可能高于或低于其实际值。为了帮助model做出更好的预测，我们可以添加一个列，将缺失的值标记为True或False。</li></ul><p id="b6ab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这种情况下，我们将填充缺失值列的平均值。具体来说，</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="f6d1" class="mo mp it mk b gy mq mr l ms mt">creditcard_df.loc[(creditcard_df[‘MINIMUM_PAYMENTS’].isnull() == True), ‘MINIMUM_PAYMENTS’] = creditcard_df[‘MINIMUM_PAYMENTS’].mean()</span><span id="ef99" class="mo mp it mk b gy mx mr l ms mt">creditcard_df.loc[(creditcard_df[‘MINIMUM_PAYMENTS’].isnull() == True), ‘MINIMUM_PAYMENTS’] = creditcard_df[‘MINIMUM_PAYMENTS’].mean()</span></pre><p id="23a4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 3.2跌落特性</strong></p><p id="e9fc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据集包含17个要素。现在我们需要考虑是否所有这些都是训练模型所必需的。在我们这种情况下，<em class="mu">‘CUST _ ID’</em>是无济于事的。所以我们会放弃。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="aa4e" class="mo mp it mk b gy mq mr l ms mt">creditcard_df.drop(‘CUST_ID’, axis = 1, inplace = True)</span></pre><p id="44b8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 3.3秤特点</strong></p><p id="ec31" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有些特征如<em class="mu">‘购买’</em>变化范围很大，而其他特征如<em class="mu">‘购买_频率’</em>在0到1之间变化。我们需要在同一范围内缩放所有功能。这里我们使用来自<strong class="kx iu"> sklearn </strong>的<strong class="kx iu"> StandardScaler() </strong>来移除平均值并缩放至单位方差。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="7122" class="mo mp it mk b gy mq mr l ms mt">scaler = StandardScaler()<br/>creditcard_df_scaled = scaler.fit_transform(creditcard_df)</span></pre><p id="8e77" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 4。k均值聚类</strong></p><p id="f1e5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">k-means聚类是一种无监督的机器学习算法。根据维基百科，它旨在将观测值划分为k个集合，以最小化组内平方和(WCSS)。WCSS表示聚类中所有点到质心的距离的总和。它从一组随机初始化的质心开始，然后执行迭代计算以优化质心的位置，直到质心稳定，或者达到定义的迭代次数。</p><p id="4bd9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 4.1找K </strong></p><p id="c39e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">k-means的第一步是挑选聚类数。肘法是最受欢迎的方法之一。为了实现它，我们对不同数量的聚类应用k-means并比较它们的WCSS。具体来说，</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="d106" class="mo mp it mk b gy mq mr l ms mt">score_1 = []<br/>range_values = range(1, 20)<br/>for i in range_values:<br/>    kmeans = KMeans(n_clusters = i)<br/>    kmeans.fit(creditcard_df_scaled)<br/>    score_1.append(kmeans.inertia_)</span></pre><p id="ef4c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">图3显示了WCSS随集群数量的变化。为了确定聚类的最佳数量，<strong class="kx iu">我们必须选择“弯头”处的k值，即在该点之后失真/惯性开始以线性方式降低</strong>。因此，我们得出结论，最佳聚类数是8。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/bba3c1350b909010c00d00eb54d9b362.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*nUM5x_jRDV9KcdgWdsxQ9w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图3 WCSS随聚类数的变化(图片由作者提供)</p></figure><p id="6950" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 4.2应用k均值</strong></p><p id="b37d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">确定了最佳聚类数后，让我们应用k-means并预测每个样本的聚类。具体来说，</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="c4fd" class="mo mp it mk b gy mq mr l ms mt">kmeans = KMeans(n_clusters = 8, init = ‘k-means++’, max_iter = 300, n_init = 10, random_state = 0)</span><span id="7604" class="mo mp it mk b gy mx mr l ms mt">labels = kmeans.fit_predict(creditcard_df_scaled)</span></pre><p id="138c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意，我们将k均值的运行次数设置为10。这意味着k-means将使用不同的质心种子运行10次，最终结果将是WCSS方面的最佳输出。此外，我们将单次运行的k均值的最大迭代次数设置为300。</p><p id="b77b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 4.3可视化集群</strong></p><p id="2337" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有了预测结果，第一个可视化是检查每个聚类的特征分布。</p><p id="d000" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，让我们以集群4为例进行分析。<strong class="kx iu">如图4所示，与其他聚类相比，我们发现聚类4中的客户倾向于具有高账户余额，并且非常频繁地更新余额，但是他们的购买金额非常偏向0。这表明客户对预借现金更感兴趣，如图5 </strong>所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/5cff93fc745d29710eb4c576bb15f5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*_Kh6rtnUFpAL5M3xQ4tn9Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图4将聚类3的特征与其余聚类进行比较</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ee6e5c5c24ea4a759b55a1a972a15878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*cHV6HgkoFGIqcy8v77V0ZQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图5比较集群之间的<em class="nb">‘CASH _ ADVANCE’</em>(图片由作者提供)</p></figure><p id="252d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">作为一名信用卡用户，我经常购物，但不喜欢预支现金。因此，我发现自己可能属于第0类，它代表经常进行一次性购买，但不热衷于分期付款和预付现金的客户。但是如果你分期付款购物，而不是预付现金，你可能属于第二类。</p><p id="d8af" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">就我个人而言，我发现分析不同客户群体在交易中的表现非常有趣✨✨.也许试一试，看看你适合哪里📣📣？</p><p id="f091" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 4.4 PCA </strong></p><p id="4dad" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">显然，直方图对于分析聚类特征很有用，但对于可视化总体聚类分布却没那么有用。因为我们有17个特征，所以我们必须压缩自由度的维度，以便直观地观察集群分布。为此，我们使用主成分分析(PCA)将特征压缩到2D空间中。</p><p id="e6a3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于那些不熟悉PCA的人来说，PCA通常用于降维，通过将数据仅投影到第一主分量上来获得低维数据，同时保留或最大化沿投影方向的方差(顺便说一句，这来自<a class="ae ku" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank">维基百科</a>🤭).</p><p id="e801" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">所以，为了实现PCA，</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e9be" class="mo mp it mk b gy mq mr l ms mt">from sklearn.decomposition import PCA<br/>pca = PCA(n_components = 2)<br/>principal_comp = pca.fit_transform(creditcard_df_scaled)<br/>pca_df = pd.DataFrame(data = principal_comp, columns = [‘pca1’, ‘pca2’])<br/>pca_df = pd.concat([pca_df, pd.DataFrame({‘cluster’: labels})], axis = 1)</span></pre><p id="48d6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，将17个特征压缩为2个特征，图6显示了k均值预测结果的散点图。你可能会注意到红色星团分散在蓝色星团、粉色星团和绿色星团中。这可能表明红色聚类与其他聚类具有特征相似性。也许我们可以用新技术再造一个新的集群🤔🤔？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e459a0d90a9d2e7dc4d86165b93a15f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*RO6SJWH9zKilXaWXjBHoCw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图6主成分分析空间上的聚类分布(图片由作者提供)</p></figure><p id="7974" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 5。外卖</strong></p><p id="a1a9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们创建了一个k-means模型，成功地将信用卡客户分为8类。我们发现集群0、2和4的一些有趣的购买和支付模式，还有更多有待探索。我们还注意到集群之间有一些重叠，表明还有改进的空间。</p><p id="9f24" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">太好了。希望你觉得这次旅行很有趣。为了继续这个话题，我将在下一篇文章中进一步挖掘，看看我们是否可以改进聚类结果。在那里见💕💕。</p></div></div>    
</body>
</html>