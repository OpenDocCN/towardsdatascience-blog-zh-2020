<html>
<head>
<title>Creating Custom Aggregations to Use with Pandas groupby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建用于熊猫分组的自定义聚合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-custom-aggregations-to-use-with-pandas-groupby-e3f5ef8cb43e?source=collection_archive---------6-----------------------#2020-11-07">https://towardsdatascience.com/creating-custom-aggregations-to-use-with-pandas-groupby-e3f5ef8cb43e?source=collection_archive---------6-----------------------#2020-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我开始使用带有自定义聚合的groupby，我想与您分享我所学到的东西。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6af2dc149bf7ad20148e36c088d2c736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvWX4Ld-ilKko1slYoiqmw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://unsplash.com/@djmle29n" rel="noopener ugc nofollow" target="_blank">黛比·莫勒</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</p></figure><p id="245b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas <code class="fe lv lw lx ly b">groupby</code>是一个函数，你可以在数据帧上使用它来分割对象，应用一个函数，并组合结果。当您想要将大量数据分组并为每个组计算不同的操作时，此函数非常有用。如果您将聚合函数与您的<code class="fe lv lw lx ly b">groupby</code>一起使用，则每次函数运行时，该聚合将为每个组返回一个值。形成组后，可以对分组的数据运行一个或多个聚合。</p><p id="2a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我今天使用的数据集是Kaggle上的<a class="ae ky" href="https://www.kaggle.com/sootersaalu/amazon-top-50-bestselling-books-2009-2019" rel="noopener ugc nofollow" target="_blank">亚马逊50大畅销书</a>。这个数据集有一些我们可以使用的很好的数字列和类别。导入数据集后，我们可以快速查看一个使用<code class="fe lv lw lx ly b">head(1)</code>抓取第一行并用<code class="fe lv lw lx ly b">.T</code>转置数据的例子。这里我们可以看到流派是<code class="fe lv lw lx ly b">groupby,</code>的一个很好的分类栏，我们可以汇总用户评级、评论、价格和年份。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="36f6" class="md me it ly b gy mf mg l mh mi">df = pd.read_csv("bestsellers_with_categories.csv")<br/>print(df.head(1).T)</span><span id="5c46" class="md me it ly b gy mj mg l mh mi">&gt;&gt;&gt; 0<br/>&gt;&gt;&gt; Name         10-Day Green Smoothie Cleanse<br/>&gt;&gt;&gt; Author                            JJ Smith<br/>&gt;&gt;&gt; User Rating                            4.7<br/>&gt;&gt;&gt; Reviews                              17350<br/>&gt;&gt;&gt; Price                                    8<br/>&gt;&gt;&gt; Year                                  2016<br/>&gt;&gt;&gt; Genre                          Non Fiction</span></pre><p id="cca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经快速浏览了这些列，我们可以使用<code class="fe lv lw lx ly b">groupby</code>对Genre的数据进行分组。在应用<code class="fe lv lw lx ly b">groupby</code>之前，我们可以在这个数据集中看到两个体裁类别，非小说和小说，这意味着我们将有两组数据要处理。如果我们想考虑作者或书名，我们可以和小组一起玩，但我们现在将坚持流派。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f6b8" class="md me it ly b gy mf mg l mh mi">df.Genre.unique()</span><span id="b88e" class="md me it ly b gy mj mg l mh mi">&gt;&gt;&gt; array(['Non Fiction', 'Fiction'], dtype=object)</span><span id="54aa" class="md me it ly b gy mj mg l mh mi">group_cols = ['Genre']<br/>ex = df.groupby(group_cols)</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="fc85" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">为系列数据创建自定义聚合</h1><p id="92cd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在设置我们的组之后，我们可以开始创建自定义聚合。我曾在类似这样的函数中使用自定义聚合，在不同条件下执行计算或聚合之前过滤掉特定的值。当我测试聚合函数时，我喜欢从一个小系列开始来验证输出，如下图所示。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="20f3" class="md me it ly b gy mf mg l mh mi">ser = pd.Series([1,10,4,2,10,10])</span></pre><p id="c098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了一系列要测试的数据，我们就可以开始创建聚合函数了。下面我创建了三个聚合函数。第一个和第二个函数是<code class="fe lv lw lx ly b">non_nan_mean</code>和<code class="fe lv lw lx ly b">standard_deviation</code>，它们验证序列不为空，移除任何NA值，并执行平均值或标准偏差计算。最后一个聚合是一个<code class="fe lv lw lx ly b">mean_lower_rating</code>，它消除任何大于5的上限值，并计算下限值的平均值。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="abe5" class="md me it ly b gy mf mg l mh mi">def non_nan_mean(x):<br/>    if x.empty:<br/>        return None<br/>    else: <br/>        x = x.dropna()<br/>        return np.mean(x)</span><span id="5720" class="md me it ly b gy mj mg l mh mi">def standard_deviation(x):<br/>    if x.empty:<br/>        return None <br/>    else: <br/>        x = x.dropna()<br/>        return np.nanstd(x)<br/>    <br/>def mean_lower_rating(x):<br/>    upper = []<br/>    for val in x:<br/>        if val &gt; 5:<br/>            continue <br/>        else: <br/>            upper.append(val)<br/>    return np.mean(upper)</span></pre><p id="b2c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你定义了你的聚合函数，根据你的需要，你可以应用你的序列来测试。我打印出我的值来查看，如下所示。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5e0d" class="md me it ly b gy mf mg l mh mi">print(non_nan_mean(ser))<br/>print(standard_deviation(ser))<br/>print(mean_lower_rating(ser))</span><span id="6cde" class="md me it ly b gy mj mg l mh mi">&gt;&gt;&gt; 6.166666666666667<br/>&gt;&gt;&gt; 3.9334745737353156<br/>&gt;&gt;&gt; 2.3333333333333335</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8028" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">通过Groupby应用聚合</h1><p id="f350" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在理解了您正在使用的数据集并使用少量数据测试了聚合函数之后，您可以应用使用前面提到的<code class="fe lv lw lx ly b">agg</code>函数创建的聚合函数。这个函数作用于dataframes，它允许我们聚合指定轴上的数据。应用这些聚合的一个简单方法是创建一个列表，并将该列表作为参数传递。此方法会将您的聚合应用到组数据框架中的所有数字列，如下面的示例一所示。在这个例子中，你可以看到我正在调用<code class="fe lv lw lx ly b">ex</code>，这是前面的分组输出。</p><h2 id="5482" class="md me it bd ms nn no dn mw np nq dp na li nr ns nc lm nt nu ne lq nv nw ng nx bi translated">示例1:</h2><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b99e" class="md me it ly b gy mf mg l mh mi">aggs = [non_nan_mean, standard_deviation,mean_lower_rating]<br/>ex2 = ex.agg(aggs)<br/>print(ex2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/bf9343f09bd5ef647a2fe4ed0d2a2226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qhwMTYW2FaUPQARbqE9u6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jupyter notebook中生成的字典聚合的输出。</p></figure><p id="25e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从输出中可以看出，<code class="fe lv lw lx ly b">mean_lower_rating</code>聚合在特定的列上表现不佳，这是由为特定列设计的函数(即用户评级)造成的。考虑到这一点，我们可以看看将聚合参数传递到<code class="fe lv lw lx ly b">agg</code>函数的不同方式，这将清理输出。</p><p id="c716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将参数传递给<code class="fe lv lw lx ly b">agg</code>的另一种方法是开发一个字典。字典将列名映射到要运行的聚合函数。这种方法的一个例子见例二。</p><h2 id="5711" class="md me it bd ms nn no dn mw np nq dp na li nr ns nc lm nt nu ne lq nv nw ng nx bi translated">示例2:</h2><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9414" class="md me it ly b gy mf mg l mh mi">aggs_by_col = {'Reviews': [non_nan_mean], <br/>               'Price': [non_nan_mean,standard_deviation],<br/>               'User Rating': [mean_lower_rating]}<br/>ex1 = ex.agg(aggs_by_col)<br/>print(ex1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/4960cdea4bb053c1f5e0440677b72419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ega1tAws9OMGqU2w5-O9yg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jupyter notebook中生成的字典聚合的输出。</p></figure><p id="d7e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，如果您不想使用<code class="fe lv lw lx ly b">mean_lower_rating</code>聚合将所有聚合应用于所有列，则首选此方法。定义聚合应用于哪些列的过程对于大型数据集非常有益，因为它清理了输出，只提供了您想要查看的数据。这种应用聚合的方法允许我只为用户评级指定<code class="fe lv lw lx ly b">mean_lower_rating</code>聚合，并将其他聚合指定到它们各自的列。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b065" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">最后的想法</h1><p id="1a73" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">将Pandas <code class="fe lv lw lx ly b">groupby</code>与<code class="fe lv lw lx ly b">agg</code>函数一起使用将允许您将数据分组到不同的类别中，并将您的数字列聚合到每个聚合函数的一个值中。如果您有创建自定义聚合函数的用例，您可以编写这些函数来接收一系列数据，然后使用列表或字典将它们传递给<code class="fe lv lw lx ly b">agg</code>。如果希望所有的聚合都应用于所有的数字列，可以传递一个列表；如果要指定哪些聚合应用于哪些列，可以传递一个字典。如果您愿意，还可以使用lambda函数来创建聚合，这一点我在本文中没有涉及。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="bd3d" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">附加阅读</h1><ul class=""><li id="2f92" class="oa ob it lb b lc ni lf nj li oc lm od lq oe lu of og oh oi bi translated"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html" rel="noopener ugc nofollow" target="_blank">熊猫。DataFrame.groupby </a>文档</li><li id="4eb2" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html" rel="noopener ugc nofollow" target="_blank">pandas . core . group by . data frame group by . aggregate</a>文档</li><li id="c886" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html" rel="noopener ugc nofollow" target="_blank">分组依据:分解-应用-合并</a>文档</li><li id="c2cd" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">熊猫。DataFrame.agg 文档</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="0d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想阅读更多，看看我下面的其他文章吧！</p><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/top-8-skills-for-every-data-scientist-79e6b1faf3e1"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">每位数据科学家的8大技能</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">当我参加大学讲座时，最常被问到的问题是“我需要具备什么技能？”</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/stop-wasting-your-time-and-consult-a-subject-matter-expert-f6ee9bffd0fe"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">停止浪费你的时间，咨询一个主题专家</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">在从事数据科学项目时，请一位主题专家来审查您的工作可能会有所帮助。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/keys-to-success-when-adopting-a-pre-existing-data-science-project-9f1225fb0275"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">采用现有数据科学项目的成功关键</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">代码本来可能不是你的，但现在是你的了。那么接下来呢？</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="ph l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/dont-be-too-proud-to-ask-for-help-76f21d16f318"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">不要太骄傲而不愿寻求帮助</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">如果你被一个bug卡住了或者感到不知所措，你可以寻求你需要的帮助。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="pi l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/top-3-articles-for-data-visualization-956a08a54b04"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">数据可视化的前3篇文章</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">如果您想更好地构建数据可视化，这些文章很有帮助。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="pj l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>