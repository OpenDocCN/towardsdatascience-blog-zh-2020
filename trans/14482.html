<html>
<head>
<title>Building a network graph from Twitter data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Twitter数据中构建网络图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-network-graph-from-twitter-data-a5e7b8672e3?source=collection_archive---------15-----------------------#2020-10-06">https://towardsdatascience.com/building-a-network-graph-from-twitter-data-a5e7b8672e3?source=collection_archive---------15-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5d54" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写Java应用程序来收集Twitter数据，并以图表的形式显示出来。</h2></div><p id="e923" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将构建一个数据科学项目。我们从Twitter上收集数据，因为它有大量的数据，这让我们可以获得这些数据。我们更喜欢Java，因为它是一种编译语言，并且有强大的并发库。最后，我们使用开源图形平台Gephi对这些数据进行总结。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/f102cb10e030d4f496ed3537ff2bff2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98TiiP08BfCdqznHMMM8Sg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">使用Gephi从9/14/20的样本推文中生成的图表。语言是TH</p></figure><p id="792e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要以下做这个项目:</p><ul class=""><li id="d510" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">Java IDE。我们的选择是日蚀。</li><li id="7c0c" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">Twitter4j库。从<a class="ae mf" href="http://twitter4j.org/en/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>获取jar文件和教程。</li><li id="a753" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">Twitter开发者账号。我们需要这个来调用Twitter API。有一些资源提到了如何获得访问权限。</li><li id="784a" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">任何符合JDBC标准的数据库。我们使用Sqlite。它很轻。不需要安装软件。没有守护进程。只需将Sqlite jar文件复制到项目中。但是，有一些限制需要解决。</li><li id="02e4" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">Gephi是一个开源的图形工具。从<a class="ae mf" href="https://gephi.org" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</li></ul><p id="d7fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下，读者可以使用他们喜欢的任何语言或平台，Python或Node.js。</p><p id="d0db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是构建Twitter网络图的步骤:</p><ul class=""><li id="d76e" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">收集推文和用户，并保存到数据库中。</li><li id="8630" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">检索用户的朋友。从上一步的用户列表中，获取这些用户的朋友。我们将把这些保存到表格中</li><li id="b8c6" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">筛选我们希望在图表中看到的数据</li><li id="cf43" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">将数据导出到CSV文件</li><li id="6d46" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">将CSV文件导入Gephi。做一些格式化，布局。我们会得到一个twitter社交图</li></ul><h1 id="f764" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">收集推文和用户</h1><p id="2a75" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">第一步，我们收集样本tweets，然后将它们写到表中。为此:</p><ul class=""><li id="36d2" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">创建一个twitter流对象。对溪流进行采样。API提供了所有tweets的随机子集。</li><li id="00e2" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">对于收到的每条tweet，向executor服务提交一个可调用的任务。该任务将执行数据库操作和/或进一步的处理。</li></ul><p id="561a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是代码:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="89ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可调用任务中的代码会将tweets和相关对象(如用户)保存到表中。通过使用executor服务，我们分离了tweet处理和数据库相关的任务。即使有时推文的速度超过了数据库的处理速度，我们的应用程序仍然不会错过任何东西。此外，因为我们使用Sqlite数据库，并且在一个时刻只能有一次对数据库的写入，所以executor服务必须是单线程Executor。以下是该任务的部分代码:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="7c47" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">检索用户的朋友</h1><p id="6834" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">从上一步，我们得到了一个用户列表，我们想知道他们所有的朋友。Twitter API返回指定用户的朋友id，但单次请求不会超过5000个id。如果该用户拥有更多，我们需要多次呼叫。此外，Twitter有费率限制。它只允许每个15分钟的窗口有15个请求。基本上每分钟1个请求。</p><p id="94b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们得到了朋友id。需要其他API调用来将用户id转换为用户对象。Twitter为此提供了API。对于每个请求，我们可以查询多达100个用户id。对此速率限制是每15分钟窗口300个请求。所以，是每分钟20个请求。</p><p id="0e39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Twitter API和速率限制的更多细节<a class="ae mf" href="https://developer.twitter.com/en/docs/api-reference-index" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="0136" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了有效地处理速率限制，我们将有两个线程。第一个线程将调用朋友id查询。第二个线程将执行用户查找部分。朋友查找线程将通过阻塞队列将用户id传递给用户查找线程。基本上，我们在这里使用生产者-消费者模式。</p><h2 id="d7ad" class="nf mh iq bd mi ng nh dn mm ni nj dp mq ko nk nl ms ks nm nn mu kw no np mw nq bi translated">朋友查找线程</h2><p id="4e13" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">以下代码是FriendsLookupRunnable的一部分。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bc81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些要点:</p><ul class=""><li id="789a" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">这个runnable的run方法将从要处理的用户id阻塞队列中轮询一个用户id。</li><li id="70c7" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">对于每个id，调用getFriendIds方法。这个方法返回朋友id列表。每个用户id和朋友id对都被插入到User_friend表中。</li><li id="ac88" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">得到朋友id也被放入另一个阻塞队列。这些id将由另一个线程检索并进行处理。</li><li id="4886" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">getFriendIds方法跟踪最后一次调用它的时间，并通过使用Thread.sleep()确保每次调用之间有足够的延迟(1分钟)。</li><li id="70c2" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">即使我们这样做了，也很少有超出速率限制的异常情况发生。因此，我们捕获TwitterException并比较异常状态代码。如果超过了速率限制，我们就重试查询。</li><li id="2dd8" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">还有一些其他的例外。例如，当用户受到保护时，twitter API会给你一个未经授权的错误。</li></ul><p id="f865" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是创建User_Friend表的命令，该表存储第一个线程的结果:</p><pre class="lc ld le lf gt nr ns nt nu aw nv bi"><span id="8ad0" class="nf mh iq ns b gy nw nx l ny nz">CREATE TABLE User_Friend (</span><span id="94b5" class="nf mh iq ns b gy oa nx l ny nz">    user_id       INT (8),</span><span id="d8ec" class="nf mh iq ns b gy oa nx l ny nz">    friend_id     INT (8),</span><span id="eaef" class="nf mh iq ns b gy oa nx l ny nz">    PRIMARY KEY (user_id,friend_id)</span><span id="23fe" class="nf mh iq ns b gy oa nx l ny nz">);</span></pre><h2 id="b555" class="nf mh iq bd mi ng nh dn mm ni nj dp mq ko nk nl ms ks nm nn mu kw no np mw nq bi translated">用户查找线程</h2><p id="edf4" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">下面的代码是UsersLookupRunnable类。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5555" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是一些要点:</p><ul class=""><li id="aad7" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">在run方法中，有一个while循环从队列中检索用户id。然后它将调用lookupUsers方法进行实际的查找</li><li id="5f93" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">因为Twitter lookupUsers API一次只能处理不超过100个用户id，所以在调用Twitter API之前，我们将把一个用户id数组分割成包含100个或更少元素的数组。</li><li id="a995" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">lookupUsers方法跟踪上次调用它的时间，并通过使用Thread.sleep()确保每次调用之间有足够的延迟(3秒)。</li><li id="7955" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">该方法返回将被插入到用户表中的用户列表。表格的结构应该类似于Twitter用户界面。</li></ul><p id="9d31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是创建存储第二个线程结果的用户表的命令:</p><pre class="lc ld le lf gt nr ns nt nu aw nv bi"><span id="377f" class="nf mh iq ns b gy nw nx l ny nz">CREATE TABLE User (</span><span id="666e" class="nf mh iq ns b gy oa nx l ny nz">    id              INT (8)       PRIMARY KEY,</span><span id="4f5a" class="nf mh iq ns b gy oa nx l ny nz">    name            VARCHAR (100),</span><span id="453f" class="nf mh iq ns b gy oa nx l ny nz">    screen_name     VARCHAR (100),</span><span id="ae7d" class="nf mh iq ns b gy oa nx l ny nz">    description     VARCHAR (255),</span><span id="6328" class="nf mh iq ns b gy oa nx l ny nz">    email           VARCHAR (50),</span><span id="aef5" class="nf mh iq ns b gy oa nx l ny nz">    favorites_count INT,</span><span id="14c4" class="nf mh iq ns b gy oa nx l ny nz">    followers_count INT,</span><span id="668c" class="nf mh iq ns b gy oa nx l ny nz">    friends_count   INT,</span><span id="1b8f" class="nf mh iq ns b gy oa nx l ny nz">    statuses_count  INT,</span><span id="4060" class="nf mh iq ns b gy oa nx l ny nz">    lang            VARCHAR (10),</span><span id="aa4f" class="nf mh iq ns b gy oa nx l ny nz">    location        VARCHAR (255),</span><span id="bf4e" class="nf mh iq ns b gy oa nx l ny nz">    url             VARCHAR (255),</span><span id="962e" class="nf mh iq ns b gy oa nx l ny nz">    imageurl        VARCHAR (255),</span><span id="2636" class="nf mh iq ns b gy oa nx l ny nz">    is_protected    INT (1),</span><span id="a141" class="nf mh iq ns b gy oa nx l ny nz">    is_verified     INT (1),</span><span id="55e3" class="nf mh iq ns b gy oa nx l ny nz">    created         VARCHAR (20),</span><span id="0e0a" class="nf mh iq ns b gy oa nx l ny nz">    last_modified   VARCHAR (20)</span><span id="840a" class="nf mh iq ns b gy oa nx l ny nz">);</span></pre><p id="d7db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要的方法是:</p><ul class=""><li id="b74b" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">设置数据库连接</li><li id="82b3" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">创建2个阻塞队列</li><li id="6656" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">准备用户id列表。将其添加到第一个阻塞队列中。</li><li id="ccf7" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">创建2个可运行线程和2个线程。</li><li id="d964" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">启动两个线程。</li><li id="652f" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">添加关机挂钩。所以，当进程终止时，它会中断两个线程。</li><li id="bd5a" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">等到两个线程都完成。</li><li id="c581" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">清理数据库</li></ul><p id="e5bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码应该如下所示:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="4661" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">过滤数据(可选)</h1><p id="d4d3" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">有时，我们希望只看到全部数据的一部分。这样做很简单，因为数据已经在SQL表中了。假设我们想看看在我们的样本推文中拥有最多关注者的前100名用户是如何相互关注的。以下是要做的事情:</p><ul class=""><li id="8b1f" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">创建用于存储结果的表格。下面是使用的SQL语句:</li></ul><pre class="lc ld le lf gt nr ns nt nu aw nv bi"><span id="c040" class="nf mh iq ns b gy nw nx l ny nz">CREATE TABLE Graph_Friend_Edge (</span><span id="6e59" class="nf mh iq ns b gy oa nx l ny nz">    Source      INT,</span><span id="bba9" class="nf mh iq ns b gy oa nx l ny nz">    Target      INT </span><span id="82b8" class="nf mh iq ns b gy oa nx l ny nz">);<br/>CREATE TABLE Graph_Friend_Node (</span><span id="c741" class="nf mh iq ns b gy oa nx l ny nz">    id              INT      PRIMARY KEY,</span><span id="396d" class="nf mh iq ns b gy oa nx l ny nz">    label           VARCHAR (50),</span><span id="a649" class="nf mh iq ns b gy oa nx l ny nz">    name            VARCHAR (100),</span><span id="6d0d" class="nf mh iq ns b gy oa nx l ny nz">);</span></pre><ul class=""><li id="995f" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">仅用顶级用户填充边缘表。以下是SQL语句:</li></ul><pre class="lc ld le lf gt nr ns nt nu aw nv bi"><span id="64c7" class="nf mh iq ns b gy nw nx l ny nz">insert into graph_friend_edge(source, target)</span><span id="b5d8" class="nf mh iq ns b gy oa nx l ny nz">select user_id, friend_id from user_friend</span><span id="4381" class="nf mh iq ns b gy oa nx l ny nz">join user u1 on friend_id=u1.id</span><span id="e0ba" class="nf mh iq ns b gy oa nx l ny nz">join user u2 on user_id=u2.id</span><span id="530c" class="nf mh iq ns b gy oa nx l ny nz">where user_id in</span><span id="75bf" class="nf mh iq ns b gy oa nx l ny nz">(select friend_id from user_friend</span><span id="69bc" class="nf mh iq ns b gy oa nx l ny nz">group by friend_id order by count(*) desc limit 100)</span><span id="7579" class="nf mh iq ns b gy oa nx l ny nz">and friend_id in</span><span id="7ebd" class="nf mh iq ns b gy oa nx l ny nz">(select friend_id from user_friend </span><span id="f232" class="nf mh iq ns b gy oa nx l ny nz">group by friend_id order by count(*) desc limit 100);</span></pre><ul class=""><li id="a9c8" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">然后，用以下SQL填充节点表:</li></ul><pre class="lc ld le lf gt nr ns nt nu aw nv bi"><span id="f340" class="nf mh iq ns b gy nw nx l ny nz">insert into graph_friend_node(id, label, name)</span><span id="f7d4" class="nf mh iq ns b gy oa nx l ny nz">select n.id, u.screen_name, u.name</span><span id="8d46" class="nf mh iq ns b gy oa nx l ny nz">from(</span><span id="da08" class="nf mh iq ns b gy oa nx l ny nz">select source id from graph_friend_edge</span><span id="4a6d" class="nf mh iq ns b gy oa nx l ny nz">union</span><span id="74a0" class="nf mh iq ns b gy oa nx l ny nz">select target id from graph_friend_edge</span><span id="ffc0" class="nf mh iq ns b gy oa nx l ny nz">) n join user u on n.id = u.id;</span></pre><h1 id="8afb" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">将数据导出到CSV文件</h1><p id="1570" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">这部分很简单。使用数据库工具将数据导出到CSV文件。</p><ul class=""><li id="51d4" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">将user_friend表导出到edge CSV文件。</li><li id="4f13" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">将用户表导出到节点CSV文件。</li></ul><h1 id="17a2" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">创建网络图</h1><p id="da46" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">Gephi是一个开源的图形分析和可视化工具。外面有很多Gephi教程。看一看<a class="ae mf" href="https://gephi.org/users/" rel="noopener ugc nofollow" target="_blank">这里</a>。导入CSV文件教程，在这里找到<a class="ae mf" href="https://github.com/gephi/gephi/wiki/Import-CSV-Data" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0ed3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是在我们的项目中要做的步骤概述:</p><ul class=""><li id="8029" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">打开Gephi。创建新项目。</li><li id="e1da" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">导入边和节点CSV文件。最初的图表可能看起来不像这样:</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ob"><img src="../Images/879585bf7b630404168328e5237605c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdprcNIq4ZhyJvShnsm8dQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">9/14/20应用样本推文布局前的前100名用户好友图表。语言是TH</p></figure><p id="2f04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要显示节点标签。配置节点大小和颜色。应用一些布局。</p><ul class=""><li id="2876" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">启用节点标签</li><li id="b350" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">配置与入度(传入边的数量)成比例的节点大小和标签大小</li><li id="2530" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">选择“ForceAtlas2”的布局并运行它。</li><li id="b51d" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">运行社区检测算法</li><li id="ec60" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">根据模块等级设置节点颜色。这将根据它检测到的社区给节点着色。</li></ul><p id="ddec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成这些后，图表看起来更有意义:</p><ul class=""><li id="ce2e" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">用户的屏幕名称显示为节点标签。</li><li id="1d37" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">该组中拥有更多追随者的节点看起来更大。</li><li id="214c" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">边，箭头线，代表跟随关系</li><li id="3ba5" class="lr ls iq kh b ki ma kl mb ko mc ks md kw me la lw lx ly lz bi translated">根据图算法，具有相同颜色的节点在相同的社区中。</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oc"><img src="../Images/3c3f11700f10dfe872fd253e2e448117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYQv9ljMZzrsGnFNPJxPVQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">使用Gephi从9/14/20的样本推文中生成的前100名用户的朋友图。语言是TH</p></figure><h1 id="5f60" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="1a57" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们构建了Java应用程序来从Twitter收集推文、用户和朋友数据，并将其放入关系数据库。我们对数据做了一些过滤。然后，导入到Gephi，图形平台和可视化工具，产生一个社会网络图。</p><p id="f68e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是我们利用Twitter数据所能做的很小一部分。Gephi能给我们提供更多的东西。此外，还有更多图形分析平台。例如，Neo4j可以让我们将数据存储到它的数据库中，并运行图形算法。</p></div></div>    
</body>
</html>