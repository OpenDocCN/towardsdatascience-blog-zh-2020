<html>
<head>
<title>Efficient Data Visualization with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React实现高效的数据可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/efficient-data-visualization-with-react-f55f67a2d2fa?source=collection_archive---------39-----------------------#2020-10-13">https://towardsdatascience.com/efficient-data-visualization-with-react-f55f67a2d2fa?source=collection_archive---------39-----------------------#2020-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何高效处理amCharts图表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbcc0123a0630eba82d865fc7678d104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEKeysJC2pbmXC-kSNmNkg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/graph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@kmuza?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Carlos Muza </a>拍摄的照片</p></figure><p id="9871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.amcharts.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> amCharts </strong> </a> <strong class="lb iu">是一个用于数据可视化的JavaScript库</strong>，内置了对TypeScript和ES6模块的支持。也完全兼容<a class="ae ky" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank">角度</a>、<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a>、<a class="ae ky" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>。amCharts提供了多种图表类型供选择，如这里的<a class="ae ky" href="https://www.amcharts.com/javascript-charts/" rel="noopener ugc nofollow" target="_blank">所示</a>。</p><p id="d29b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经使用amCharts几个月了，现在我知道它的主要优点和缺点。当用于静态图表时，简直令人惊叹。动态图表呢？</p><p id="b48e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">初始化amCharts图表需要大量的时间和资源</strong>。想象一下，每当我们需要改变可视化的数据时，例如，作为事件的结果，都要这样做。这很容易成为web应用程序的瓶颈，尤其是在同一个页面上有很多图表的情况下。这就是<a class="ae ky" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆</a>发挥作用的地方！</p><p id="bc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，本文的主要目的不是展示amCharts是如何工作的，或者什么是记忆化。这就是为什么<strong class="lb iu">我强烈推荐阅读</strong> <a class="ae ky" href="https://www.amcharts.com/docs/v4/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">这个</strong> </a> <strong class="lb iu">和</strong> <a class="ae ky" href="https://medium.com/@trekinbami/using-react-memo-and-memoization-1970eb1ed128" rel="noopener"> <strong class="lb iu">这个</strong> </a> <strong class="lb iu">第一个</strong>。</p><p id="042e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们构建一个高效的<a class="ae ky" href="https://codeburst.io/a-complete-guide-to-props-children-in-react-c315fab74e7c" rel="noopener" target="_blank"> React组件来包装</a>任何类型的amCharts图表。</p><div class="lv lw gp gr lx ly"><a href="https://codeburst.io/a-complete-guide-to-props-children-in-react-c315fab74e7c" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">反应中的道具.儿童完全指南</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">掌握React组件组成</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">codeburst.io</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="7844" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak">构建图表组件</strong></h1><p id="27df" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们的通用组件可以定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="21ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b"><a class="ae ky" href="https://www.amcharts.com/docs/v4/reference/instance_module/#create_method" rel="noopener ugc nofollow" target="_blank">am4core.create</a></code>函数返回<strong class="lb iu">图表实例</strong>，这允许我们操纵图表本身的行为。图表的创建，即它的初始化，应该只在组件第一次呈现时执行<strong class="lb iu">。否则，这个组件会变得<strong class="lb iu">极其低效</strong>。这就是为什么我们将初始化函数包装在一个<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> useMemo </a>回调中。这样，<strong class="lb iu">我们就记住了返回char实例的函数，只有在第一次调用组件时才会调用它</strong>。每次组件重新呈现时，都会使用<code class="fe nm nn no np b">chart</code>缓存值，避免初始化开销。</strong></p><p id="b29b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望图表可以被操作，而不是每次都重新创建，我们需要公开它对父组件的引用。为此，我们添加了<code class="fe nm nn no np b">onInitialization</code>道具。有了它，<strong class="lb iu">父级可以直接在它的实例上改变图表的外观、数据和行为</strong>。</p><p id="8cfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的主要优势有两个:</p><ul class=""><li id="a68d" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><strong class="lb iu">通过为每个图表类型创建一个组件来避免代码重复</strong></li><li id="317b" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">允许父组件<strong class="lb iu">随时随地与图表</strong>直接交互</li></ul><h1 id="341e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">运行中的图表组件</h1><p id="b8d8" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">假设我们想要创建一个时态演变<a class="ae ky" href="https://www.amcharts.com/docs/v4/reference/lineseries/" rel="noopener ugc nofollow" target="_blank">折线图</a>，就像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/3e9a67a88498c85170131dde3c0e8dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OHafNpncSzMxOrJD-yhGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用amCharts制作的时间演变线图</p></figure><p id="7551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要可视化的数据将从AJAX调用中检索，其结果取决于用户选择的时间跨度。首先，我们来定义一下<code class="fe nm nn no np b">TemporalEvolutionChart</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">父组件负责调用检索要在图表中显示的数据，并将其传递给它。这是通过将AJAX调用的结果赋给图表实例的<code class="fe nm nn no np b"><a class="ae ky" href="https://www.amcharts.com/docs/v4/concepts/data/" rel="noopener ugc nofollow" target="_blank">data</a></code>属性来实现的。<strong class="lb iu"> amCharts图表会自动呈现新的数据</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧啊。一旦用户更改了感兴趣的时间跨度，就会发出一个AJAX调用(这要感谢这里引入的API定义层<a class="ae ky" href="https://codeburst.io/avoiding-code-duplication-by-adding-an-api-requests-definition-layer-in-javascript-6e5d7b409896" rel="noopener" target="_blank"/>),图表也会相应地更新。这是一种非常有效的方式，不需要每次都初始化图表。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="d5b4" class="mn mo it bd mp mq om ms mt mu on mw mx jz oo ka mz kc op kd nb kf oq kg nd ne bi translated">结论</h1><p id="c13c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在本文中，我们展示了一种使用amCharts和React的有效方法。初始化amCharts图表是一项耗时的操作，应仅在绝对必要时执行。这种方法是一个很好的例子，说明了如何节省资源，并防止用户因非常慢的网页而感到沮丧。感谢阅读！我希望这篇文章对你有所帮助。如有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>