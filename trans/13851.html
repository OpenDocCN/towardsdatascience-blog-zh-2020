<html>
<head>
<title>4 Hidden Gems for Idiomatic Pandas Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地道熊猫代码的4个隐藏的宝石</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-hidden-gems-for-idiomatic-pandas-code-99c706e6ce93?source=collection_archive---------24-----------------------#2020-09-23">https://towardsdatascience.com/4-hidden-gems-for-idiomatic-pandas-code-99c706e6ce93?source=collection_archive---------24-----------------------#2020-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e0bd3ac313b98ec796d3f305a9259332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0hRg1_cdQuepujU4aXciVw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来源:<a class="ae jg" href="https://www.pexels.com/photo/woman-holding-six-polished-stones-1147946/" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><div class=""/><div class=""><h2 id="e269" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">分享更多熊猫提示来提高你的数据处理水平</h2></div><p id="0871" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的上一篇文章，<a class="ae jg" rel="noopener" target="_blank" href="/6-lesser-nown-yet-awesome-tricks-in-pandas-32236f3785c8">熊猫的6个鲜为人知但令人敬畏的技巧</a>，希望已经给你一些熊猫高效编码的味道。继续这个话题，如果你还不知道的话，让我们来探索更多关于熊猫的小技巧和窍门。</p><p id="ae9e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇博客将使用我们在<a class="ae jg" rel="noopener" target="_blank" href="/6-lesser-nown-yet-awesome-tricks-in-pandas-32236f3785c8">上一篇博客</a>中讨论过的html技巧，使用直接从维基页面<a class="ae jg" href="https://en.wikipedia.org/wiki/Table_of_food_nutrients" rel="noopener ugc nofollow" target="_blank">食物营养成分表</a>中抓取的乳制品表。这是一张表格的快照，显示了食物名称、度量单位/克数以及相应的热量值。</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/e5ffe1f843d58ff5940e4da4b0b31794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*km0HEukgayaymXDrHq-Q_g.png"/></div></figure><p id="cf1f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 1。</strong> <code class="fe lz ma mb mc b"><strong class="la jk">Pandas series</strong></code> <strong class="la jk">或</strong> <code class="fe lz ma mb mc b"><strong class="la jk">list</strong></code> <strong class="la jk">或</strong> <code class="fe lz ma mb mc b"><strong class="la jk">series of lists</strong></code></p><p id="040c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单来说，Pandas中的series是一个带有索引标签的一维数组。与设计用于指示元素位置的列表索引不同，序列中的索引标签可以是用户定义的任何内容。这当然在使用序列时提供了灵活性，但是如果你不熟悉索引标签在pandas中是如何工作的，这也“设置了一个陷阱”。</p><p id="460b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们今天的任务#1是检查一个值(例如，<code class="fe lz ma mb mc b">skim, instant</code>)是否存在于一个序列中(例如，<code class="fe lz ma mb mc b">dairy_table[‘Food’]</code>)。如果是，则返回true否则为假。很简单，这个任务只需要一行代码，如下图所示，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="132a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">惊讶和困惑？用最直观的<code class="fe lz ma mb mc b"> in </code>操作符，我们的第一个代码返回<strong class="la jk">假</strong>，然而第二个代码返回<strong class="la jk">真</strong>？为什么Python告诉我<strong class="la jk">食物</strong>一栏不含<code class="fe lz ma mb mc b">skim, instant</code>，含<code class="fe lz ma mb mc b">index6</code>？</p><p id="b939" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，原因是使用<code class="fe lz ma mb mc b">in</code>直接检查熊猫系列将检查<code class="fe lz ma mb mc b">skim, instant</code>是否存在于<strong class="la jk">索引</strong>标签中，而不是我们的食物列的<strong class="la jk">值</strong>。因此，为了避免落入这个“陷阱”，我们必须指定<strong class="la jk">值/值列表</strong>作为我们的搜索空间，下面演示了几种方法，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="7d79" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当在Pandas中处理系列时，继续下一个潜在的“陷阱”,也就是说，允许一个单独的系列包含列表/元组，并且需要额外的步骤将它们解析到它们自己的列中。例如，让我们将我们的dairy表修改为一个包含值元组的数据帧，作为一个新的列<strong class="la jk"> Nums </strong>，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4f9b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们的任务#2是将<strong class="la jk"> Nums </strong>列分成两个单独的列。同样，最直观的方式是通过索引来访问元组中的每个元素，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8886" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，对于每个元组中只有两个值的例子来说，这是可行的。如果我们有数百个值，而无法手动访问每个元素，该怎么办？另外，正如我们从输出中看到的，这个list comprehension返回一个必须进一步转换为整数值的字符串列表。相当多的基本细节！</p><p id="acee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么有没有一个简单的方法来实现它呢？答案是肯定的，而且非常简单，如下所示，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="fbdc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"><em class="mf">* * *更新2022:加入我们的YouTube社区🎦</em> </strong> <a class="ae jg" href="https://www.youtube.com/channel/UCbGx9Om38Ywlqi0x8RljNdw" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> <em class="mf">【数据说话带吉】</em> </strong> </a> <strong class="la jk"> <em class="mf">😄</em> </strong></p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="deee" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 2。宁滨值潇洒地用</strong> <code class="fe lz ma mb mc b"><strong class="la jk">map</strong></code> <strong class="la jk">或</strong> <code class="fe lz ma mb mc b"><strong class="la jk">applymap</strong></code></p><p id="dd91" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的任务#3是将食物值分为三类——牛奶、布丁和奶油，定义如下:</p><figure class="lv lw lx ly gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mh"><img src="../Images/51f32c619d05f7200db224643f8da482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SK7qRtVabqTemS8Z-e0U_g.png"/></div></div></figure><p id="c300" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与其单调乏味地创建多个<code class="fe lz ma mb mc b">if</code>语句或<code class="fe lz ma mb mc b">isin()</code>函数，不如通过利用映射技巧以更智能的方式来实现。首先，我们将值组织到一个映射字典中，其中每个值属于其对应的bin，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="cb57" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们使用<code class="fe lz ma mb mc b">map</code>或<code class="fe lz ma mb mc b">applymap</code>来替换原始值，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3718" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有两点需要注意:</p><p id="9e19" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(1)我们交换了原始映射字典中的键和值，以便它的键与数据集中的实际食物名称匹配。</p><p id="49b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(2)我们演示了两种实现方式:<code class="fe lz ma mb mc b">map</code>和<code class="fe lz ma mb mc b">applymap</code>，我经常被问到这两个概念的区别。简单来说，<code class="fe lz ma mb mc b"><strong class="la jk">map</strong></code> <strong class="la jk"> </strong>取入并返回<strong class="la jk">系列</strong>，而<code class="fe lz ma mb mc b"><strong class="la jk">applymap</strong></code>取入并返回<strong class="la jk">数据帧</strong>。例如，上面代码中的<code class="fe lz ma mb mc b">map()</code>函数用于<em class="mf">食物</em>序列，它用序列方法<code class="fe lz ma mb mc b">fillna()</code>将字典中没有的值重新编码为<em class="mf">‘其他’</em>。</p><p id="9fd2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相比之下，第二个函数<code class="fe lz ma mb mc b">applymap()</code>用于整个数据帧，搜索与字典关键字匹配的值(即食物名称)，然后用相应的字典值(即bin名称)替换它们。如果没有找到匹配的键，代码将保持原始值不变。</p><p id="6601" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，<code class="fe lz ma mb mc b">map()</code>或<code class="fe lz ma mb mc b">applymap()</code>都可以工作，上面的一行代码写起来简洁且易于维护，更不用说它应该比遍历每个食物名称的组要快得多。</p><p id="3d15" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 3。</strong> <code class="fe lz ma mb mc b"><strong class="la jk">where</strong></code> <strong class="la jk">用作相当于</strong> <code class="fe lz ma mb mc b"><strong class="la jk">ifelse</strong></code> <strong class="la jk">中的R </strong></p><p id="8064" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">R中我最喜欢的一个函数是<code class="fe lz ma mb mc b">ifelse</code>；类似地，Pandas提供了<code class="fe lz ma mb mc b">where</code>函数来做同样的事情:当指定的布尔条件不满足时替换值。</p><p id="735d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，下面显示了一个食品名称列表，我们的目标是用<em class="mf">‘其他’</em>替换列表中省略的食品名称。现在，让我们看看<code class="fe lz ma mb mc b">where(other)</code>如何方便地完成这个数据操作任务，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="84c3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> 4。</strong>类型<code class="fe lz ma mb mc b"><strong class="la jk">category </strong></code>类型<strong class="la jk">保存内存</strong></p><p id="ab1f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后但同样重要的是，我想讨论一个关于Pandas中的<strong class="la jk">分类</strong>数据类型的技巧，这是为<strong class="la jk">对象</strong>数据节省空间的另一种选择。保存为<code class="fe lz ma mb mc b">object-dtype</code>的字符串通常会占用大量内存，而<code class="fe lz ma mb mc b">category-dtype</code>在后端使用整数值来表示原始值，因此更节省空间和时间。现在，让我们仔细看看我们刚刚创建的object-dtype<strong class="la jk">Food _ Category</strong>列，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ef1f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有几个注意事项，(1)一旦被转换为类别类型，<strong class="la jk"> Food_Category </strong>被编码为整数；(2)通过将对象数据类型转换成类别数据类型，存储器使用从1051字节减少到427字节(即，<strong class="la jk"> </strong>减少60%)。</p><p id="d4b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，关于category-dtype的两个警告不能被忽略。首先，就像R中的<code class="fe lz ma mb mc b">factors</code>，<code class="fe lz ma mb mc b">category-dtype</code>在新值赋值方面不像<code class="fe lz ma mb mc b">object-dtype</code>那样灵活。例如，如果我们想用下面的代码向<strong class="la jk"> Food_Category </strong>列添加一个新的类别/级别，我们将得到臭名昭著的ValueError msg。该错误指示新级别(即，另一个_类别)在被分配给任何行之前必须首先被添加到容器中，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="7f48" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，正确的方法是首先使用<code class="fe lz ma mb mc b">add_categories()</code>方法设置电平值，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6e96" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于<code class="fe lz ma mb mc b">category-dtype</code>的另一个警告是，对于具有较少重复值的列，极端情况是所有的值都是唯一的，<code class="fe lz ma mb mc b">category-dtype</code>将比<code class="fe lz ma mb mc b">object-dtype</code>占用更多的内存。让我们以<strong class="la jk">食物</strong>列为例，这里所有的值都是唯一的，</p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="0f16" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，一旦<strong class="la jk">食物</strong>列被转换为<code class="fe lz ma mb mc b">category-dtype</code>，memory_usage从1605字节增加到2262字节(即增加了41%)。因此，当一个<code class="fe lz ma mb mc b">object-dtype </code>列包含许多重复值时，分类将最有利于高效存储。</p><p id="3be3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">上前练习</strong></p><p id="67c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总而言之，我已经分享了我的熊猫小贴士和技巧，我希望我能早点知道。<a class="ae jg" href="https://github.com/YiLi225/Pandas_Tricks/blob/master/Top10_Pandas_Tricks.py" rel="noopener ugc nofollow" target="_blank">完整代码链接在我的Github </a>里。现在轮到你开始编码了！😃</p><blockquote class="mi mj mk"><p id="e0a2" class="ky kz mf la b lb lc kk ld le lf kn lg ml li lj lk mm lm ln lo mn lq lr ls lt im bi translated">没有不断的练习，就不会有优秀的音乐[熊猫]。</p><p id="045f" class="ky kz mf la b lb lc kk ld le lf kn lg ml li lj lk mm lm ln lo mn lq lr ls lt im bi translated">简·奥斯汀《傲慢与偏见》中的凯瑟琳夫人(第31章)</p></blockquote><p id="1f09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这个博客！<strong class="la jk"> <em class="mf">想要更多数据科学和编程技巧？使用</em> </strong> <a class="ae jg" href="https://yilistats.medium.com/membership" rel="noopener"> <strong class="la jk"> <em class="mf">我的链接</em> </strong> </a> <strong class="la jk"> <em class="mf">注册Medium，获得我所有内容的全部访问权限。</em>T13】</strong></p><p id="b679" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="mf">还订阅我新创建的YouTube频道</em> </strong> <a class="ae jg" href="https://www.youtube.com/channel/UCbGx9Om38Ywlqi0x8RljNdw" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> <em class="mf">《数据与吉谈》</em></strong></a><strong class="la jk"><em class="mf"/></strong></p><figure class="lv lw lx ly gt iv"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="da66" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是我的其他博客，你可能也会觉得很有启发性。</p><div class="is it gp gr iu mo"><a rel="noopener follow" target="_blank" href="/6-sql-tricks-every-data-scientist-should-know-f84be499aea5"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jk gy z fp mt fr fs mu fu fw ji bi translated">每个数据科学家都应该知道的6个SQL技巧</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">提高分析效率的SQL技巧</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ja mo"/></div></div></a></div><div class="is it gp gr iu mo"><a rel="noopener follow" target="_blank" href="/data-reshaping-in-sql-r-and-python-d44ca19e71b8"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jk gy z fp mt fr fs mu fu fw ji bi translated">SQL、R和Python中的数据整形</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">从Python vs. R到Python &amp; R</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc ja mo"/></div></div></a></div></div></div>    
</body>
</html>