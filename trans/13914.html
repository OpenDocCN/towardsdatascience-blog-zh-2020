<html>
<head>
<title>Unsupervised image mapping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无监督图像映射</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unsupervized-image-clusterization-7ff7fadcf358?source=collection_archive---------36-----------------------#2020-09-24">https://towardsdatascience.com/unsupervized-image-clusterization-7ff7fadcf358?source=collection_archive---------36-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="12ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索大量图像的简单有效的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e7753262c1085f1169d12ed26fb30974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*alp8vdiV9Lka3oCE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jontyson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔恩·泰森</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bef9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名数据科学家，我经常参与反欺诈调查任务。因此，探索是调查的重要组成部分。它允许一个人熟悉分析的主题。<br/>我将在这里详细介绍一种简单、快速、高效且可重复的方法，让你对你所拥有的图像有一个整体的概念。这是我的第一篇文章，所以请不要犹豫，提出你的问题和意见。享受😉</p><h1 id="25c3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">内容</h1><ol class=""><li id="960e" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">先决条件</li><li id="b16f" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">数据</li><li id="eda2" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">描述图像</li><li id="7623" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">推断</li><li id="2a42" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">(英)可视化(= visualization)</li></ol></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="531a" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">先决条件</h1><p id="a123" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">该算法使用Python 3.6.8和库keras(版本2.2.4)、pandas(版本0.24.1)、scikit-learn(版本0.22.2.post1)、numpy(版本1.18.2)和matplotlib(版本3.0.3)。</p><p id="73c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要安装Python，如果你在Windows或Mac上，你可以在这里下载安装程序<a class="ae kv" href="https://www.python.org/downloads/release/python-368/" rel="noopener ugc nofollow" target="_blank">。对于linux用户，下面的bash命令将安装Python 3.6: <code class="fe np nq nr ns b">sudo apt-get install python3.6</code></a></p><p id="fccb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于库，终端中的以下命令(bash、powershell等。)将安装它们:<code class="fe np nq nr ns b">pip install keras==2.2.4 pandas==0.24.1 scikit-learn==0.22.2.post1 matplotlib==3.0.3 numpy==1.18.2</code></p><p id="0318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，使用Tableau软件对结果进行可视化。这是一个付费软件，但你可以在这里免费试用。</p><p id="72cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以导入库并指定图像的路径:</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="5e80" class="nx lt iq ns b gy ny nz l oa ob">## Imports<br/>from datetime import datetime<br/>from keras.applications.resnet50 import preprocess_input, ResNet50<br/>from keras.models import Model<br/>from keras.preprocessing import image<br/>from pandas import DataFrame<br/>from random import sample<br/>from sklearn.manifold import TSNE</span><span id="3217" class="nx lt iq ns b gy oc nz l oa ob">import matplotlib.pyplot as plt<br/>import numpy as np<br/>import os<br/>import time</span><span id="137d" class="nx lt iq ns b gy oc nz l oa ob">## Parameters<br/>INPUT_DIRECTORY = 'UIC_dataset/'<br/>assert os.path.exists(INPUT_DIRECTORY), 'Directory does not exist'</span></pre></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="4e0f" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">数据</h1><p id="4ee1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在这个例子中，我选择使用EuroSAT (RGB)数据集，这里是<a class="ae kv" href="https://github.com/phelber/eurosat" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/ccf23b44e90fdb5298c7364cb3ce289f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sNtwvndjnTOkWQqS2eCwSg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">EuroSAT数据集以Sentinel-2卫星图像为基础，覆盖13个光谱带，由10类27，000个带标签和地理参考样本组成——euros at:一种用于土地利用和土地覆盖分类的新型数据集和深度学习基准，作者:Helber、Patrick和Bischke、Benjamin和Dengel、Andreas和Borth、Damian，载于2019年《IEEE应用地球观测和遥感专题杂志》</p></figure></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="c632" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">描述图像</h1><p id="9f22" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">第一步是找到一种方法来丰富地描述图像。一种快速简单的方法是使用已经在一般分类任务上训练过的神经网络作为编码器。我们的目标不是分类，而是使用网络提取的特征将相似的图像分组在一起。在ImageNet数据集上训练的ResNet50残差神经网络是一个非常好的开始。</p><p id="acd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oe">想了解更多关于残差神经网络的知识？第一部分</em> <a class="ae kv" rel="noopener" target="_blank" href="/an-overview-of-resnet-and-its-variants-5281e2f56035"> <em class="oe">这篇文章</em> </a> <em class="oe">解释得很好。</em></p><p id="3b2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么在ImageNet数据集上训练ResNet50？ImageNet项目是一个大型视觉数据库，设计用于视觉对象识别软件研究。该项目已经对超过1400万张图像进行了手工注释，以指示所拍摄的对象，并且在至少100万张图像中，还提供了边界框。ImageNet包含20，000多个类别，其中一个典型的类别，如“气球”或“草莓”，由数百个图像组成。<br/>因此，经过训练对ImageNet图像进行分类并获得良好分数的神经网络将学会正确区分图像的形状和特征。这种能力对我们来说非常珍贵。问题是我们的ResNet50目前只知道如何从ImageNet类列表中预测一个类。<br/>为了克服这一点，我们必须移除用于分类的网络的最后一层。网络的输出将是维度2048的特征向量。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="6bed" class="nx lt iq ns b gy ny nz l oa ob">## Model<br/># Retrieve the base model trained on ImageNet<br/>base_model = ResNet50(weights='imagenet')</span><span id="3d0e" class="nx lt iq ns b gy oc nz l oa ob"># Removing the last layer by selecting the layers from the first to the penultimate one.<br/>model = Model(inputs=base_model.input, outputs=base_model.get_layer('avg_pool').output)</span><span id="3159" class="nx lt iq ns b gy oc nz l oa ob"># Display layers<br/>print(model.summary())</span><span id="25e9" class="nx lt iq ns b gy oc nz l oa ob">## Get image paths<br/>image_file_names = list()<br/>image_file_paths = list()</span><span id="bffb" class="nx lt iq ns b gy oc nz l oa ob">for root_path, directory_names, file_names in os.walk(INPUT_DIRECTORY):<br/>    for file_name in file_names:<br/>        if file_name.lower().endswith(('.jpg', '.jpeg', '.png')):<br/>            image_file_names.append(file_name)<br/>            image_file_paths.append(os.path.join(root_path, file_name))<br/>              <br/>print('{} images found'.format(len(image_file_paths)))</span><span id="39e3" class="nx lt iq ns b gy oc nz l oa ob">## Sampling<br/>image_file_names, image_file_paths = zip(*sample(list(zip(image_file_names, image_file_paths)), 1000))<br/>image_file_names = list(image_file_names)<br/>image_file_paths = list(image_file_paths)</span><span id="23a2" class="nx lt iq ns b gy oc nz l oa ob">## Get image features<br/>image_features = list()</span><span id="f1f2" class="nx lt iq ns b gy oc nz l oa ob">start_time = time.time()</span><span id="2476" class="nx lt iq ns b gy oc nz l oa ob">for index, image_file_path in enumerate(image_file_paths.copy()):<br/>    try:<br/>        img = image.load_img(image_file_path, target_size=(224, 224))<br/>        x = image.img_to_array(img)<br/>        x = np.expand_dims(x, axis=0)<br/>        x = preprocess_input(x)</span><span id="e403" class="nx lt iq ns b gy oc nz l oa ob">        image_features.append(model.predict(x)[0])<br/>    except OSError:<br/>        del image_file_paths[index]<br/>        del image_file_names[index]<br/>        print("ERROR: Can't load image {}".format(os.path.basename(image_file_path)))</span><span id="e167" class="nx lt iq ns b gy oc nz l oa ob">image_features = np.array(image_features)</span><span id="81cd" class="nx lt iq ns b gy oc nz l oa ob">print('Done ({:.0f} min)'.format((time.time() - start_time) / 60))</span></pre></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="e62a" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">推断</h1><p id="ec17" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们人类发现很难掌握超过3个维度。所以想象一下2048年…</p><p id="4060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最喜欢的可视化大矢量的方法之一是t-SNE算法。t-SNE代表t-分布式随机邻居嵌入。<br/>是一种基于随机近邻嵌入的可视化机器学习算法。这是一种非线性降维技术，非常适合于在二维或三维的低维空间中嵌入用于可视化的高维数据。具体而言，它通过二维或三维点对每个高维对象进行建模，以这种方式，相似的对象通过附近的点进行建模，而不相似的对象通过远处的点以高概率进行建模。<br/>t-SNE算法包括两个主要阶段。首先，t-SNE在高维对象对上构建概率分布，使得相似的对象被分配较高的概率，而不同的点被分配较低的概率。第二，t-SNE在低维图中的点上定义了类似的概率分布，并且它最小化了关于图中点的位置的两个分布之间的Kullback-Leibler散度(KL散度)。</p><p id="f898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像许多算法一样，参数必须仔细选择。<a class="ae kv" href="https://distill.pub/2016/misread-tsne/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>很好地解释了t-SNE不同参数的影响。<br/>在我们的案例中，以下参数值使我们获得了令人满意的结果。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="7786" class="nx lt iq ns b gy ny nz l oa ob">## Compute t-SNE<br/>start_time = time.time()</span><span id="77c4" class="nx lt iq ns b gy oc nz l oa ob">t_SNE = TSNE(n_components=2,<br/>             perplexity=20,<br/>             n_iter=2000,<br/>             metric='euclidean', <br/>             random_state=8,<br/>             n_jobs=-1).fit_transform(image_features)</span><span id="5d54" class="nx lt iq ns b gy oc nz l oa ob">print('Done ({:.3f} s)'.format(time.time() - start_time))</span></pre></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="d491" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">(英)可视化(= visualization)</h1><p id="3587" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">一旦投射完成，我们就可以想象结果。</p><h2 id="bfbf" class="nx lt iq bd lu of og dn ly oh oi dp mc lf oj ok me lj ol om mg ln on oo mi op bi translated"><strong class="ak"> Matplotlib </strong></h2><p id="0954" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">一个简单的散点图已经可以用来确定一些分组。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="fc92" class="nx lt iq ns b gy ny nz l oa ob">## Plot results<br/># Increase plot size<br/>plt.figure(figsize=(12, 12))</span><span id="48ef" class="nx lt iq ns b gy oc nz l oa ob"># Set title<br/>plt.title('t-SNE plot')</span><span id="886a" class="nx lt iq ns b gy oc nz l oa ob"># Plot and show<br/>plt.scatter(t_SNE[:, 0], t_SNE[:, 1], marker='.')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c94176cebf7b1e2a7ceec04ec408bb77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*OjH9tez8E96puP_P_x2lLA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们已经可以区分出一组与众不同的图片——作者的图片</p></figure><p id="b9bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个简单图形的缺点是，它不允许您查看由点表示的图像。为此，需要更高级的可视化解决方案，如Power BI或Tableau软件，详情如下。</p><h2 id="59a4" class="nx lt iq bd lu of og dn ly oh oi dp mc lf oj ok me lj ol om mg ln on oo mi op bi translated"><strong class="ak"> Tableau软件</strong></h2><p id="2788" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">Tableau是一个付费的数据可视化软件，使用起来相当简单，允许大量不同类型的可视化，包括交互式可视化。</p><p id="2319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须首先保存t-SNE的结果。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="99e9" class="nx lt iq ns b gy ny nz l oa ob">## Save results<br/>data_frame = DataFrame(data={'Image_file_names': image_file_names,<br/>                             'Image_file_paths': image_file_paths,<br/>                             'Image_features': [str(vector).replace('\n', '') for vector in image_features], <br/>                             'X': t_SNE[:, 0], <br/>                             'Y': t_SNE[:, 1]})<br/>data_frame = data_frame.set_index('Image_file_names')</span><span id="94e7" class="nx lt iq ns b gy oc nz l oa ob">data_frame.to_csv(path_or_buf='Unsupervised_image_cluterization_run_{}.csv'.format(datetime.now().strftime("%Y_%m_%d-%H_%M")),<br/>                  sep=';',<br/>                  encoding='utf-8')</span></pre><p id="cb21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在Tableau软件中，点击“新数据源”&gt;“文本文件”，选择你的CSV文件打开。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/14fea3410dcd5ba0631453546d585dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBuoVqSr4YR1lN5EJosPtg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau加载页面-作者提供的图像</p></figure><p id="4166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据加载后，转到“第1页”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/9a540d546a6870a14aae1ea64860c471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DHe7GgjD_CW4lYGw1g-hxQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau数据页面-作者图片</p></figure><p id="22d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，右击“X”&gt;“转换为尺寸”。对“Y”做同样的操作。<br/>通过拖放将“X”和“Y”分别添加到“列”和“行”字段中。<br/>点击将鼠标移到“列”字段中的“X”上时出现的小箭头，然后点击“连续”。对“Y”做同样的操作。您应该得到一个类似于散点图的视觉效果。<br/>预计到以后，将“图像文件路径”拖放到“标记”窗格的“细节”框中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/0946dacb1ec6946153436d8f817496a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwTYfGZX9kooYrgUPerofA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau表单页面-作者提供的图像</p></figure><p id="61e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使视觉更美观，你可以让网格、轴和工作表的名称消失。为此，右键单击网格&gt;“格式”，然后在右侧的“格式字体”窗格中，单击“线条”图标，并通过选择“无”来禁用不同的线条。<br/>然后，右击轴，您可以禁用“显示标题”选项。右键单击标题激活“隐藏标题”选项。<br/>最后，在“标记”窗格中，您可以修改点的形状、大小、颜色等。就我个人而言，我喜欢让它们看起来像不透明度为75%的小方块。这让我想起了小的拍立得照片，我们会把它们分类放在一张桌子上。<br/>您也可以将“图像文件名”拖放到“工具提示”中，使图像的名称出现，然后双击“工具提示”，您可以编辑工具提示的内容，修改为只保留“&lt; ATTR(图像文件名)&gt;”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/09a97ebb17e7d2cc259a2b37be383c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G68on14tYPiImT0o0vQ0Fw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">纸张修饰—图片由作者提供</p></figure><p id="1457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以切换到“Dashboard”选项卡，方法是单击工作表1底部的“New Dashboard”图标。<br/>让我们通过将“宽度”和“高度”分别更改为1600像素和900像素来增加“尺寸”窗格中的尺寸。<br/>然后，您可以将“工作表1”从“工作表”选项卡拖放到仪表板。右键点击标题使其消失。<br/>在“对象”窗格中，将“网页”拖放到仪表板上“工作表1”的右侧。然后单击“确定”,将URL留空。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/2196e7f2ce0192139c96a62c76fc6331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ld9TM87X0AUjd7uf7vh5tg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Tableau仪表板页面-按作者分类的图像</p></figure><p id="c1f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个网页是显示图像的一种方式。目的是通过将鼠标悬停在一个正方形上来显示网页中的图像。为此，我们将启动一个本地web服务器。在您的终端中，转到要服务的目录并键入<code class="fe np nq nr ns b">cd &lt;path where UIC_dataset folder is&gt;</code>，然后通过键入<code class="fe np nq nr ns b">python -m http.server --bind 127.0.0.1</code>启动一个Python web服务器。您的服务器现已启动。<br/>在顶部的“仪表板”标签中&gt;“操作……”&gt;“添加操作&gt;”&gt;“转到URL……”。在“运行操作于:”中，选择“悬停”。在“URL”中，输入URL<em class="oe">“http://127 . 0 . 0 . 1:8000/&lt;图像文件路径&gt;”</em>。在“URL目标”中，选择“网页对象”。最后，点击“确定”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/d87582557f948401afce916ba8d61723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*h71DMCo3jiFC_R47uRMW4Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">动作窗口—按作者分类的图像</p></figure><p id="e84f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果您在Windows中工作，您可能需要通过将“\”替换为“/”来更改“图像文件路径”。为此，在“工作表1”中，右键单击“数据”窗格底部，然后单击“创建计算字段…”。输入名称“路径”,并输入如下计算公式。然后在“Dashboard”&gt;“Actions”&gt;双击“Hyperlink1”，用“<em class="oe">http://127 . 0 . 0 . 1:8000/&lt;path&gt;</em>”更改网址。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/f28bac22ca713d88b05a0099219e0e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*o6xnzLhlTs1bpDKmd0IEnA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算字段窗口-按作者排序的图像</p></figure><p id="ec3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧！当你飞过它们时，你的图像就会出现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/102f4c7d4dac83f1f52007b6f6cc4a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*u76Md2Tl5gPrWMggZhXNaw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">结果—作者提供的图片</p></figure><p id="c77d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以看到相似的图像被分组在一起。可以看到一些星团，如右上角的“住宅”星团或底部明显分离的“海湖”星团。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="e20e" class="ls lt iq bd lu lv nh lx ly lz ni mb mc jw nj jx me jz nk ka mg kc nl kd mi mj bi translated">结论</h1><p id="b58b" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">因此，我们看到了一种简单有效的方法来获得一个图像数据集的好主意。这个想法对你进一步的分析工作会非常珍贵。<br/>我希望你喜欢这篇文章，它让你想了解更多关于数据分析的知识。请随意提问和评论。</p><p id="dd1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码<a class="ae kv" href="https://gitlab.com/jthieyre/unsupervized-image-clusterization" rel="noopener ugc nofollow" target="_blank">在我的gitlab上有一个Jupyter笔记本，如果你愿意，你可以贡献给它。</a></p><p id="0e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多的文章将会出现，包括一篇关于清理纯文本邮件的文章。敬请关注，稍后见😉</p></div></div>    
</body>
</html>