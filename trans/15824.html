<html>
<head>
<title>Object classification with small training datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有小训练数据集的对象分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-classification-with-small-training-datasets-c6bd1e90dfc8?source=collection_archive---------16-----------------------#2020-10-31">https://towardsdatascience.com/object-classification-with-small-training-datasets-c6bd1e90dfc8?source=collection_archive---------16-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="5484" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/58cdb24d8c0c4cad383a96c9a9000215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BIJu5mNPm1VWJXwo"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">由<a class="ae kl" href="https://unsplash.com/@borisdunand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Boris Dunand </a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="397d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在一次机器学习实习期间，我的任务是为“空货架综合症”创建一个解决方案。在某些情况下，空货架综合症是零售业中的一个常见问题，在这种情况下，零售商仅仅因为没有意识到货架已经空了而无法用他们库存的物品补充货架。这导致消费者认为该商品不可用，从而导致零售商失去销售机会。</p><p id="b773" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最初，对象检测模型似乎是解决当前问题的理想方案。然而，在最初的设计阶段，我遇到了相当多的警告，使得一个简单的对象检测方法不可行。</p><p id="cf1a" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我必须注意的一些关键业务警告是:</p><ul class=""><li id="8359" class="lk ll iq ko b kp kq kt ku kx lm lb ln lf lo lj lp lq lr ls bi translated">零售店中各种商品的数量</li><li id="b7c7" class="lk ll iq ko b kp lt kt lu kx lv lb lw lf lx lj lp lq lr ls bi translated">缺乏每个单项的综合数据集</li></ul></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="0f21" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">该解决方案是对象检测的流水线和图像分类模型，用于最初检测项目的宽泛分类，然后进一步识别准确的类别标签。</p><h1 id="8c85" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated"><strong class="ak">管道:</strong></h1><ol class=""><li id="e540" class="lk ll iq ko b kp nd kt ne kx nf lb ng lf nh lj ni lq lr ls bi translated">捕捉图像:使用OpenCV构建的简单模块用于以2分钟的间隔捕捉货架的图像。为POC选择2分钟的时间间隔主要是为了提供充足的提醒时间，同时考虑到所需物品的重新进货。</li><li id="4e55" class="lk ll iq ko b kp lt kt lu kx lv lb lw lf lx lj ni lq lr ls bi translated">对象检测:捕获的图像通过对象检测模型运行。该模型确定了图像中存在的项目的大致分类。在当前的用例中，广泛的分类包括瓶子、盒子、包、书等。</li><li id="b537" class="lk ll iq ko b kp lt kt lu kx lv lb lw lf lx lj ni lq lr ls bi translated">图像裁剪:一旦对象检测模型已经识别了对象的宽泛分类，每个对象被从左上到右下单独裁剪，并存储在对应于其宽泛分类标签的文件夹中。例如，图像中的所有瓶子将保存在名为“瓶子”的文件夹中。</li><li id="5e35" class="lk ll iq ko b kp lt kt lu kx lv lb lw lf lx lj ni lq lr ls bi translated">图像分类:文件夹中的所有图像被分组，然后通过相应的图像分类模型运行(为每个宽泛的分类标签开发了一个单独的模型)</li><li id="780b" class="lk ll iq ko b kp lt kt lu kx lv lb lw lf lx lj ni lq lr ls bi translated">对象计数:分类模型的结果用于计数，图像的顺序用于映射货架上的物品位置。</li><li id="8a9e" class="lk ll iq ko b kp lt kt lu kx lv lb lw lf lx lj ni lq lr ls bi translated">仪表板:项目的数量显示在仪表板上，并对任何位置不当的项目发出警告。</li></ol></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="c866" class="mf mg iq bd mh mi nj mk ml mm nk mo mp mq nl ms mt mu nm mw mx my nn na nb nc bi translated"><strong class="ak">物体检测</strong></h1><p id="7495" class="pw-post-body-paragraph km kn iq ko b kp nd kr ks kt ne kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">对于对象检测模型，我利用了Tensorflow对象检测API(<a class="ae kl" href="https://github.com/tensorflow/models/tree/master/research/object_detection" rel="noopener ugc nofollow" target="_blank">https://github . com/tensor flow/models/tree/master/research/Object _ Detection</a>)。来自COCO数据集的预训练权重被用于在基本分类标签上训练模型。</p><p id="468c" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">一旦模型检测到相关的对象，OpenCV就被用来裁剪图像中的边界框。这些图像随后被存储在相关的文件夹中。</p><p id="f928" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">该模型是使用Tensorflow对象检测API创建的。将更快的RCNN初始resnet权重用作初始权重，然后在COCO数据集上进一步训练该模型，该数据集具有广泛分类类所需的标签。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="d0b7" class="oa mg iq nw b gy ob oc l od oe">MODEL_NAME = 'object_detection/Models/faster_rcnn_inception_resnet_v2_atrous_oid_v4_2018_12_12'<br/>PATH_TO_FROZEN_GRAPH = MODEL_NAME + '/frozen_inference_graph.pb'</span></pre><p id="a836" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><em class="of"> MODEL_NAME </em>在这里指定要下载的模型，而<em class="of"> PATH_TO_FROZEN_GRAPH </em>是模型将实际用来执行对象检测的冻结图。</p><p id="2704" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">有关Tensorflow对象检测API使用的全面教程，请参考以下链接。</p><div class="og oh gp gr oi oj"><a href="https://tensorflow-object-detection-api-tutorial.readthedocs.io/en/latest/install.html" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ja gy z fp oo fr fs op fu fw iz bi translated">安装- TensorFlow 2对象检测API教程文档</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">虽然安装和使用TensorFlow并不一定要有Anaconda，但我建议这样做，因为它…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">tensor flow-object-detection-API-tutorial . readthedocs . io</p></div></div></div></a></div></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="ba52" class="mf mg iq bd mh mi nj mk ml mm nk mo mp mq nl ms mt mu nm mw mx my nn na nb nc bi translated">图像裁剪</h1><p id="ce90" class="pw-post-body-paragraph km kn iq ko b kp nd kr ks kt ne kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">基于边界框裁剪图像是下一个关键步骤。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="1fb8" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在上面的要点中，<em class="of">output _ dict[' detection _ Scores ']</em>包含了模型创建的每个包围盒的分数。出于POC的目的，并且为了考虑部分可见的项目，阈值被设置为50%(即，模型超过50%确信所创建的边界框已经检测到相关项目)。50%可能看起来是一个相当低的数字，但它允许在不适当的位置考虑更广泛的项目。</p><p id="30ec" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">然后存储每个边界框的4个端点，并用于确定图像的位置和要裁剪的原始图像的区域，并随后输入图像分类模型。</p><h1 id="fa25" class="mf mg iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">图像分类</h1><p id="1bcd" class="pw-post-body-paragraph km kn iq ko b kp nd kr ks kt ne kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">对于图像分类模型，只有稀疏训练集是可用的。用户拍摄物品的图像(大约5-10张图像),然后进行复制和转换。这些图像随后被用来以很高的精确度训练模型。在创建这个概念验证时(2019年5月)，我使用了ImageAI库(<a class="ae kl" href="https://github.com/OlafenwaMoses/ImageAI" rel="noopener ugc nofollow" target="_blank">https://github.com/OlafenwaMoses/ImageAI</a>)作为图像分类模型。</p><p id="76e9" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">一旦模型被分类到广泛的分类标签中，它们都被存储在“裁剪图像”目录下的单独文件夹中。然后，该模型将依次考虑目录中出现的文件夹，并为每个文件夹创建一个预测列表。</p><p id="bc17" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">例如，让我们考虑标签瓶。</p><figure class="nr ns nt nu gt ka"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="e177" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><em class="of"> duck </em>将包含瓶子文件夹中所有图像的列表，然后对图像进行排序。(图像正在排序，因为在裁剪过程中，图像的命名顺序与它们在原始图像中出现的顺序相同)。这些图像被分组，然后进行分类。每个分类的预测和概率随后被存储，并且列表<em class="of"> img </em>被所有预测的标签填充。</p><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/8788166337d5da336918acddd2aae3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*2Ib1APz4H7qeUAv3jZVZOw.png"/></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">输入图像(作者提供的图像)</p></figure><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/635a7cb9d1047d1c1dae25d157e61871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*jvt-FOK21rwkDeqiKuEJkA.png"/></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">带有边框的图像(作者提供的图像)</p></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="61b8" class="mf mg iq bd mh mi nj mk ml mm nk mo mp mq nl ms mt mu nm mw mx my nn na nb nc bi translated">结果</h1><figure class="nr ns nt nu gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ow"><img src="../Images/0fdd68eb856861535ad4135cf5becebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DI0twm0cBK8qnWu3xUWBIQ.png"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">带有项目计数和位置提醒的仪表板(图片由作者提供)</p></figure><p id="12cf" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">仪表板根据项目的广义分类标签显示项目的数量。如果发现任何放错地方的物品，就会发出警报。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="2f2e" class="mf mg iq bd mh mi nj mk ml mm nk mo mp mq nl ms mt mu nm mw mx my nn na nb nc bi translated">未来范围</h1><p id="b667" class="pw-post-body-paragraph km kn iq ko b kp nd kr ks kt ne kv kw kx no kz la lb np ld le lf nq lh li lj ij bi translated">这个项目是我在计算机视觉领域起步时创建的一个有趣的概念验证。将对该项目的进一步改进，以充实功能和优化管道。当处理小数据集时，一种简单而有效的方法来处理对象检测。</p><p id="181d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">Github链接:<a class="ae kl" href="https://github.com/abhinav2301/Object_Detection-Empty-Shelf-Issue" rel="noopener ugc nofollow" target="_blank">https://github . com/abhinav 2301/Object _ Detection-Empty-Shelf-Issue</a></p></div></div>    
</body>
</html>