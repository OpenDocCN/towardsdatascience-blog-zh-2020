<html>
<head>
<title>Archiving and Logging Your Use of Public Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">归档和记录您对公共数据的使用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/archiving-and-logging-your-use-of-public-data-5c19a7ac360?source=collection_archive---------64-----------------------#2020-10-26">https://towardsdatascience.com/archiving-and-logging-your-use-of-public-data-5c19a7ac360?source=collection_archive---------64-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="331a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理公共数据集的不确定性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3251c238b0ffeab1a1d2d2b240f47b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xR_HyzWYJH4bdZoN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">信用:<a class="ae kv" href="https://unsplash.com/@ula_kuzma" rel="noopener ugc nofollow" target="_blank">乌拉Kuźma </a></p></figure><p id="0e19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我从网上下载数据集时，我总是担心它们的不稳定性。链接死了，数据变了，灰归灰，尘归尘。</p><p id="a30e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我将<a class="ae kv" href="http://web.archive.org/" rel="noopener ugc nofollow" target="_blank">返程机</a>引入我的工作流程。但即使这样，也很难确定我是从一个存档网站还是从一个实时网站下载数据，也很难理解我过去做了什么。</p><p id="aaf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在<a class="ae kv" rel="noopener" target="_blank" href="/linear-regressions-for-the-survey-of-consumer-finances-ed2c10b2670c?sk=fa2330fb7d48fd5cea3134d74d8c1778">消费者金融调查</a> (SCF)的工作中所做的是实现一个同时归档和记录我使用的数据的系统。下面是我所做工作的总结，但是如果你只是想看代码，请滚动到这篇文章的底部，查看我在SCF方面实现的功能的要点。</p><h2 id="8b72" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">WaybackPy的建筑</h2><p id="f5b5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我想在这个项目中完成的最重要的事情是确保我在下载数据时尽可能多地使用最近的Wayback档案。另外，对于没有存档的任何数据，我希望确保它在Wayback上存档以供将来使用。</p><p id="a76e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我找到的最好的包是<a class="ae kv" href="https://pypi.org/project/waybackpy/" rel="noopener ugc nofollow" target="_blank"> WaybackPy </a>，尽管我需要做一些修改来让它为我的目的工作。</p><p id="5bf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我需要实现允许我查看最新归档的年龄的属性。通过这种方式，我可以查看给定的<code class="fe mq mr ms mt b">archive_age_limit</code>是否需要新的归档。</p><p id="1832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举例来说，如果你得到一个通过<code class="fe mq mr ms mt b"><a class="ae kv" href="http://www.google.com" rel="noopener ugc nofollow" target="_blank">www.google.com</a></code>的WaybackPy Url对象的<code class="fe mq mr ms mt b">len()</code>，你会得到0，或者是自上次存档以来的天数。</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="11e4" class="ls lt iq mt b gy my mz l na nb">import waybackpy</span><span id="2dfa" class="ls lt iq mt b gy nc mz l na nb">url = “https://www.google.com/"</span><span id="8759" class="ls lt iq mt b gy nc mz l na nb">waybackpy_url_obj = waybackpy.Url(url)</span><span id="eb6a" class="ls lt iq mt b gy nc mz l na nb">print(len(waybackpy_url_obj))</span></pre><p id="3c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到几乎每天都会生成一个新的归档，这是有意义的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/bf3e05edfa2ea5c38a8005c0b885f34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7lTqZ71L0qEEwrGzmpgtA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Google.com档案馆(作者截图)</p></figure><h2 id="ae1f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">归档和记录数据集</h2><p id="3509" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">有了WaybackPy，归档就变得简单了。只要确保为超过一定年龄的档案调用<code class="fe mq mr ms mt b">save()</code>方法，存储一些关键数据，就可以开始了。</p><p id="c3ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更难的部分是将关键数据添加到CSV中以供进一步检查。对于不能从Wayback机器上直接访问的新档案，尤其如此。</p><p id="6084" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个实现的函数，它将您想要的数据所在的URL和数据本地保存的目标目录作为参数。它返回的是一个字典，包含最新存档的URL和时间戳。为了检查它的行为，让我们看看它是如何与SCF一起使用的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="8922" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用SCF实现</h2><p id="9cfd" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这篇文章的底部是一个完整的要点，展示了如何存档，记录和下载SCF数据。这个过程相对简单:</p><ol class=""><li id="c37c" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">提供您想要的SCF数据的年份、您想要的变量以及您想要存储数据的目标目录。</li><li id="ce3b" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">使用最新的归档文件，或者如果最新的归档文件比您的限制旧，则创建新的归档文件。同时，记录正在使用的最新归档或新归档。</li><li id="410d" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">尝试使用存档URL来检索您的数据，否则使用实时URL。</li><li id="5c57" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">将您的数据转换为熊猫数据框。</li></ol><p id="1547" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">日志本身的行为方式如下:</p><ol class=""><li id="6b69" class="ng nh iq ky b kz la lc ld lf ni lj nj ln nk lr nl nm nn no bi translated">如果最新存档在您的年龄限制内，它将记录其详细信息，如果您在年龄限制内再次尝试重新下载该数据，日志将不会重复记录。</li><li id="e1df" class="ng nh iq ky b kz np lc nq lf nr lj ns ln nt lr nl nm nn no bi translated">如果最新的存档超过了年龄限制，它将记录您保存的详细信息，如果您重新下载它。因为Wayback可能不会立即显示您的记录，所以您可能会在日志中有多个保存和记录，这比在Wayback不起作用时丢失保存的数据要好。</li></ol><p id="890c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果您今天要下载2019年、2016年和2013年的SCF数据，最后一个被下载两次，您会期望日志显示4个带有<code class="fe mq mr ms mt b">archive_age_limit = 30</code>的记录，因为2019年的数据集是唯一一个在过去30天内存档的数据集。下面是一个例子，你会看到什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/7d805a32b0c1baec879766eabca774c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOW9rx4ugdVpNpMnL8OYdw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例日志(作者截图)</p></figure><h2 id="8df1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">最后的想法</h2><p id="d059" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我实现的日志对我的目的肯定是有用的，但是我还没有完全探索这段代码是如何被破坏的。很难找出如何最好地处理最近存档但没有立即更新的网站，但上面描述的“过度记录”行为总比没有好。</p><p id="e186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其他潜在的问题可能是不同的文件类型，但基本的归档行为应该保持不变。如果你想看的话，至少这段代码可以用于SCF的zip文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>