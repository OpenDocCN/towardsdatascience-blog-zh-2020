<html>
<head>
<title>Introduction to Python Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python类简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-python-classes-da526ff745df?source=collection_archive---------14-----------------------#2020-11-13">https://towardsdatascience.com/introduction-to-python-classes-da526ff745df?source=collection_archive---------14-----------------------#2020-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f895" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">面向对象编程的综合实践指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/084923a06907798fe7caeb08eee48c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whdOswlacQ_B_cpFkYssEw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Edvard Alexander lvaag在<a class="ae ky" href="https://unsplash.com/s/photos/hierarchy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="106c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类是Python最基础的部分。原因在于面向对象编程的概念。</p><p id="f782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的一切都是对象比如整数、列表、字典、函数等等。每个对象都有一个类型，对象类型是使用类创建的。</p><p id="5f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">课程有:</p><ul class=""><li id="28c2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">数据属性:定义创建一个类的实例需要什么</li><li id="5c22" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">方法(即过程属性):定义如何与类的实例交互</li></ul><p id="4743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法就像函数一样，但是它们属于一个特定的类。属性可以被认为是与类交互的接口。</p><p id="2348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类的一个优点是我们不需要知道它是如何被创建的。我们可以通过数据属性和方法来使用它。例如，为了使用scikit-learn中的线性回归模型，我们只需导入linear regression类。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e446" class="mo mp it mk b gy mq mr l ms mt">from sklearn.linear_model import LinearRegression</span></pre><p id="af06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要知道如何使用LinearRegression类或与之交互。我们对它是如何产生的不感兴趣。这是抽象的概念。行为已定义，但实现是隐藏的(如果您愿意，可以看到它)。</p><p id="000f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个帖子可以被认为是对类的全面介绍。我们将通过许多例子来解释它们的特点。在实现一个类时，还需要记住一些提示。</p><p id="29f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将做几个例子来解释继承，这是面向对象编程中一个非常重要的概念。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="313a" class="mo mp it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">创建一个类</h2><p id="53d8" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">让我们首先创建一个名为“Person”的简单类。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="8a13" class="mo mp it mk b gy mq mr l ms mt">class Person(object):<br/>    def __init__(self, age, name):<br/>        self.age = age<br/>        self.name = name</span></pre><p id="5f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">__init__是一个特殊的方法，在创建类的实例时自动运行。参数代表数据属性。自我就是实例本身。你可以用任何词来代替“自我”，但使用“自我”是一种非常普遍的做法。</p><p id="90ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">年龄和姓名是另外两个数据属性。因此，Person类的每个实例都有年龄和姓名数据属性。</p><p id="35a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了Person类的一个实例。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="48ab" class="mo mp it mk b gy mq mr l ms mt">p1 = Person(24, "John")</span><span id="61a4" class="mo mp it mk b gy nx mr l ms mt">print(type(p1))<br/>&lt;class '__main__.Person'&gt;<br/><br/>print(p1)<br/>&lt;__main__.Person object at 0x7f67faac9ba8&gt;</span></pre><p id="9e05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">type打印出一个对象的类型(即类)。因此，p1是Person类型的实例。</p><p id="ca32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们打印p1时，Python返回对象的类型和内存位置。但是，我们可以通过在我们的类中实现__str__方法来改变它。</p><p id="cf1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把这个人的名字和年龄打印出来。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="f111" class="mo mp it mk b gy mq mr l ms mt">class Person():<br/>    def __init__(self, age, name):<br/>        self.age = age<br/>        self.name = name</span><span id="8dfe" class="mo mp it mk b gy nx mr l ms mt">    def __str__(self):<br/>        return "&lt;" + self.name + "," + str(self.age) + "&gt;"</span></pre><p id="5a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在打印一个Person类型的对象，我们将得到名字和年龄。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="033b" class="mo mp it mk b gy mq mr l ms mt">print(p1)<br/>&lt;John,24&gt;</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="ad6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以访问对象的数据属性，如下所示:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="ed93" class="mo mp it mk b gy mq mr l ms mt">p1 = Person(24, "John")</span><span id="9d10" class="mo mp it mk b gy nx mr l ms mt">print(p1.name)<br/>John</span><span id="13da" class="mo mp it mk b gy nx mr l ms mt">print(p1.age)<br/>24</span></pre><p id="2e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以用同样的方式改变属性:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="4994" class="mo mp it mk b gy mq mr l ms mt">p1 = Person(24, "John")</span><span id="bb0f" class="mo mp it mk b gy nx mr l ms mt">print(p1.age)<br/>24</span><span id="09a5" class="mo mp it mk b gy nx mr l ms mt">p1.age = 28</span><span id="1563" class="mo mp it mk b gy nx mr l ms mt">print(p1.age)<br/>28</span></pre><p id="528d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，不建议使用这种方法。相反，我们可以实现获取和设置属性值的方法(也称为getters和setters)。</p><p id="d1ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为年龄属性做这件事:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="1491" class="mo mp it mk b gy mq mr l ms mt">def set_age(self, age):<br/>    self.age = age</span><span id="930e" class="mo mp it mk b gy nx mr l ms mt">def get_age(self):<br/>    return self.age</span></pre><p id="d8f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我每次只写新的部分，而不是写整个类的定义。</p><p id="ba2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">set_age方法用给定的值更新一个人的年龄。get_age方法只返回age属性的值。self参数表示实例本身。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="4080" class="mo mp it mk b gy mq mr l ms mt">p2 = Person(26, "Emily")</span><span id="be0d" class="mo mp it mk b gy nx mr l ms mt">print(p2.get_age())<br/>26</span><span id="99d4" class="mo mp it mk b gy nx mr l ms mt">p2.set_age(27)</span><span id="0265" class="mo mp it mk b gy nx mr l ms mt">print(p2.get_age())<br/>27</span></pre><p id="560b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调用了对象上的方法。另一种选择是在类上调用它。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="25be" class="mo mp it mk b gy mq mr l ms mt">p2 = Person(26, "Emily")</span><span id="1a4f" class="mo mp it mk b gy nx mr l ms mt">print(Person.get_age(p2))<br/>26</span><span id="1d31" class="mo mp it mk b gy nx mr l ms mt">Person.set_age(p2, 27)</span><span id="4371" class="mo mp it mk b gy nx mr l ms mt">print(Person.get_age(p2))<br/>27</span></pre><p id="6d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要使用此选项，请确保在方法内部传递对象的名称。</p><p id="f8ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让这些方法返回值，我们需要使用括号。否则，您将得到如下消息:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="9b29" class="mo mp it mk b gy mq mr l ms mt">p1 = Person(36, "Edward")</span><span id="1ca8" class="mo mp it mk b gy nx mr l ms mt">print(p1.get_age)<br/>&lt;bound method Person.get_age of &lt;__main__.Person object at 0x7fe33bf08eb8&gt;&gt;</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="d56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以为我们的类定义方法。记住方法就像函数一样，但是与特定的类相关联。</p><p id="7e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个计算两个人物年龄差的方法。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="6dd2" class="mo mp it mk b gy mq mr l ms mt">def age_diff(self, other):<br/>    diff = self.age - other.age<br/>    return abs(diff)</span></pre><p id="b366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它接受两个对象，并返回它们之间年龄差的绝对值:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="2c18" class="mo mp it mk b gy mq mr l ms mt">p1 = Person(22, "Ashley")<br/>p2 = Person(26, "Max")</span><span id="b941" class="mo mp it mk b gy nx mr l ms mt">print(p1.age_diff(p2))<br/>4</span><span id="80b8" class="mo mp it mk b gy nx mr l ms mt">print(Person.age_diff(p1, p2))<br/>4</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="a6f6" class="mo mp it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">创建子类(继承)</h2><p id="2702" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我们将创建另一个基于Person类的类。在面向对象编程中，有一个概念叫做<strong class="lb iu">继承</strong>。</p><p id="edb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于现实生活中的传承。我们的大部分基因组来自我们的父母。我们继承了他们。因此，我们和父母有相似之处。</p><p id="1859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承与类的工作方式相同。当我们创建一个子类时，它从父类继承属性(数据的和过程的)。但是，我们可以自由添加或覆盖这些属性。</p><p id="9552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为MarriedPerson的新类。它将是人的子类。除了年龄和姓名数据属性之外，它还具有配偶姓名和子女数量属性。</p><p id="94e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是包含__init__方法的类定义:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="71a1" class="mo mp it mk b gy mq mr l ms mt">class MarriedPerson(Person):<br/>   def __init__(self, age, name, spouse_name, number_of_children=0):<br/>      Person.__init__(self, age, name)<br/>      self.spouse_name = spouse_name<br/>      self.number_of_children = number_of_children</span></pre><p id="e636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两个要点:</p><ol class=""><li id="e3ed" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ny mb mc md bi translated">父类的名称写在括号中，这样python就知道MarriedPerson类继承了Person类的所有属性。</li><li id="94f0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ny mb mc md bi translated">因为已经在Person类中定义了age和name属性，所以我们可以复制Person类的__init__方法。我们只需要定义额外的属性。</li></ol><p id="4acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong>:我们可以自由手工为子类定义每个数据属性。使用parent的__init__是可选的。</p><p id="d0fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:我们也可以在__init__方法中继承父类的属性，如下所示:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0390" class="mo mp it mk b gy mq mr l ms mt">class MarriedPerson(Person):<br/>   def __init__(self, age, name, spouse_name, number_of_children=0):<br/>      super().__init__(age, name)<br/>      self.spouse_name = spouse_name<br/>      self.number_of_children = number_of_children</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="2c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以创建一个MarriedPerson对象(这个类的一个实例)。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="8958" class="mo mp it mk b gy mq mr l ms mt">mp1 = MarriedPerson(26, 'Max', 'Ashley', 2)</span><span id="e65b" class="mo mp it mk b gy nx mr l ms mt">print(mp1)<br/>&lt;Max,26&gt;</span></pre><p id="c304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，print函数只打印已婚者的姓名和年龄。原因是MarriedPerson类从Person类继承了__str__方法。</p><p id="68e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以覆盖它。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="bcd0" class="mo mp it mk b gy mq mr l ms mt">class MarriedPerson(Person):<br/>   def __init__(self, age, name, spouse_name, number_of_children):<br/>      Person.__init__(self, age, name)<br/>      self.spouse_name = spouse_name<br/>      self.number_of_children = number_of_children</span><span id="c919" class="mo mp it mk b gy nx mr l ms mt">   def __str__(self):<br/>      return "&lt;" + self.name + "," + "married to " +<br/>      self.spouse_name + "&gt;"</span></pre><p id="af67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在打印一个MarriedPerson对象，我们将看到姓名和配偶姓名。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="cb36" class="mo mp it mk b gy mq mr l ms mt">mp1 = MarriedPerson(26, 'Max', 'Ashley', 2)</span><span id="7f0c" class="mo mp it mk b gy nx mr l ms mt">print(mp1)<br/>&lt;Max,married to Ashley&gt;</span></pre><p id="0e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个方法来返回两个Person对象之间的年龄差(age_diff)。因为我们从Person对象继承，所以我们可以对MarriedPerson对象使用该方法。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="ed4b" class="mo mp it mk b gy mq mr l ms mt">mp1 = MarriedPerson(26, 'Max', 'Ashley', 2)<br/>mp2 = MarriedPerson(29, 'Emily', 'John', 1)</span><span id="18aa" class="mo mp it mk b gy nx mr l ms mt">print(mp1.age_diff(mp2))<br/>3</span></pre><p id="c7f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以为数据属性指定默认值。例如，一个已婚的人可能没有孩子。因此，我们可以将默认值设置为0。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="c670" class="mo mp it mk b gy mq mr l ms mt">class MarriedPerson(Person):<br/>   def __init__(self, age, name, spouse_name, number_of_children=0):<br/>      Person.__init__(self, age, name<br/>      self.spouse_name = spouse_name<br/>      self.number_of_children = number_of_children</span></pre><p id="3ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非另外指定，否则number_of_children属性将获得值0。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="a2fd" class="mo mp it mk b gy mq mr l ms mt">mp1 = MarriedPerson(26, 'Max', 'Ashley', 2)<br/>mp2 = MarriedPerson(29, 'Emily', 'John')</span><span id="6ccd" class="mo mp it mk b gy nx mr l ms mt">print(mp1.number_of_children)<br/>2</span><span id="a458" class="mo mp it mk b gy nx mr l ms mt">print(mp2.number_of_children)<br/>0</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="de8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是Person和MarriedPerson类的最终版本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/02cfb464fe430588009e01edae41f42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*UIXQSOyIsSjvLvjCCVuNww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">人物类(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9fd77ae78d596daf43987cbfdf039f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*LR0uz5M3mEjiPCyJgBfCew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">已婚人士类(图片由作者提供)</p></figure><h2 id="f7e6" class="mo mp it bd nb nc nd dn ne nf ng dp nh li ni nj nk lm nl nm nn lq no np nq nr bi translated">结论</h2><p id="973f" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">关于Python类还有很多内容要介绍。例如，类变量和实例变量之间的区别是一个重要的话题。</p><p id="f0d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们在这篇文章中讨论的内容将会让你对工作和创建类感到舒适。可以认为是全面的介绍。</p><p id="332c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着你不断练习，你会学到更多。</p><p id="c07c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>