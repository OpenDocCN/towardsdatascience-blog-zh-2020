<html>
<head>
<title>LSTM Networks | A Detailed Explanation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LSTM网络|详细解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lstm-networks-a-detailed-explanation-8fae6aefc7f9?source=collection_archive---------0-----------------------#2020-10-21">https://towardsdatascience.com/lstm-networks-a-detailed-explanation-8fae6aefc7f9?source=collection_archive---------0-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="334b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="4729" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">LSTMs的全面介绍</h2></div><p id="9a41" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这篇文章解释了长短期记忆(LSTM)网络。我发现学习一个主题的最好方法是阅读许多不同的解释，所以我会在本文的最后链接一些我认为特别有用的资源。我强烈建议你去看看他们对LSTMs的不同观点和解释！</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/92ad6e47093362ca54c1bfe13eb76ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*jikKbzFXCq-IYnFZankIMg.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">LSTM图——这张图和下面所有的图片都是作者创作的</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="a888" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">什么是LSTMs，为什么有用？</h2><p id="681f" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">LSTM网络是专门设计来克服递归神经网络RNNs所面临的长期依赖性问题(由于<a class="ae nd" href="https://en.wikipedia.org/wiki/Vanishing_gradient_problem" rel="noopener ugc nofollow" target="_blank">消失梯度问题</a>)。LSTMs具有反馈<em class="ne">连接</em>，这使得它们不同于更传统的前馈<em class="ne">神经网络。这一特性使得LSTMs能够处理整个数据序列(例如时间序列),而不用独立地处理序列中的每个点，而是保留关于序列中先前数据的有用信息，以帮助处理新数据点。因此，LSTMs特别擅长处理数据序列，如文本、语音和一般时间序列。</em></p><p id="dc41" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如，假设我们试图预测每月的冰淇淋销售额。正如人们所预料的，这种差异随着月份的不同而变化很大，12月最低，6月最高。</p><p id="2fd1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">LSTM网络可以学习这种每12个时间周期存在的模式。它不仅仅使用以前的预测，而是保留一个更长期的上下文，这有助于它克服其他模型面临的长期依赖问题。值得注意的是，这是一个非常简单的例子，但是当模式被更长的时间间隔分开时(例如，在很长的文本段落中)，LSTMs变得越来越有用。</p><h2 id="c30b" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">LSTM网络是如何工作的？</h2><p id="940a" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">首先，在基本层面上，LSTM在特定时间点的输出取决于三件事:<br/> ▹网络的当前长期记忆——被称为<em class="ne">单元状态</em> <br/> ▹前一时间点的输出——被称为前一<em class="ne">隐藏状态</em> <br/> ▹当前时间步的输入数据</p><p id="4e65" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">LSTMs使用一系列“门”来控制数据序列中的信息如何进入、存储和离开网络。典型的LSTM有三道门；忘记门，输入门和输出门。这些门可以被认为是过滤器，每一个都是它们自己的神经网络。我们将在这篇文章中详细探讨它们。</p><p id="29eb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在下面的解释中，我们考虑下图所示的LSTM池。当查看本文中的图表时，想象从左向右移动。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/92ad6e47093362ca54c1bfe13eb76ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*jikKbzFXCq-IYnFZankIMg.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">LSTM图</p></figure><h2 id="6695" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">第一步</h2><p id="4ec7" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">该过程的第一步是<strong class="kt jd">遗忘门</strong>。这里，我们将决定单元状态(网络的长期记忆)的哪些位是有用的，给定先前的隐藏状态和新的输入数据。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9de87e6d35a78d5f3e6dcdf71ad7f097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*irikskuron_qJ-kARUS0nQ.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">忘记大门</p></figure><p id="fd61" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为此，先前的隐藏状态和新的输入数据被输入到神经网络中。该网络生成一个向量，其中每个元素都在区间[0，1]中(通过使用sigmoid激活来确保)。这个网络(在遗忘门内)被训练成当输入的一个分量被认为不相关时输出接近0，而当相关时输出接近1。将这个向量的每个元素看作一种过滤器/筛子是有用的，当值接近1时，它允许更多的信息通过。</p><p id="143a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这些输出值然后被发送并逐点乘以先前的单元状态。这种逐点乘法意味着被遗忘门网络视为不相关的单元状态的分量将被乘以一个接近0的数，因此对后续步骤的影响较小。</p><p id="d1ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">总之，遗忘门决定了给定序列中先前的隐藏状态和新的数据点，哪些长期记忆片段现在应该被遗忘(具有较小的权重)。</p><h2 id="5919" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">第二步</h2><p id="6744" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">下一步涉及<strong class="kt jd">新存储网络</strong>和<strong class="kt jd">输入门</strong>。这一步的目标是在给定先前的隐藏状态和新的输入数据的情况下，确定什么新的信息应该被添加到网络的长期记忆(细胞状态)中。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/95e220f0fc3af4e4c6dcb1c2303c1117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*Mov9d_W9y24Ctlt-JhT0EA.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">输入门</p></figure><p id="45b4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">新的记忆网络和输入门本身都是神经网络，并且都接受相同的输入，即先前的隐藏状态和新的输入数据。值得注意的是<em class="ne">这里的输入实际上与遗忘门</em>的输入相同！</p><ol class=""><li id="6d7b" class="nh ni it kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated"><strong class="kt jd">新记忆网络</strong>是一个tanh激活的神经网络，它已经学会了如何将先前的隐藏状态和新的输入数据结合起来，以生成一个“新的记忆更新向量”。给定来自先前隐藏状态的上下文，该向量实质上包含来自新输入数据的信息。这个向量告诉我们，在给定新数据的情况下，网络的长期存储器(单元状态)的每个组件需要更新多少。<br/> <br/>注意，我们在这里使用一个双曲正切值，因为它的值位于[-1，1]中，所以可以是负数。如果我们希望减少单元状态中组件的影响，这里负值的可能性是必要的。</li><li id="ca3e" class="nh ni it kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">然而，在上面的第1部分中，我们生成了新的内存向量，这里有一个大问题，它实际上并没有检查新的输入数据是否值得记忆。这就是<strong class="kt jd">输入门</strong>出现的地方。输入门是一个sigmoid激活的网络，它作为一个过滤器，识别“新记忆向量”的哪些成分值得保留。该网络将输出[0，1]中的值的向量(由于sigmoid激活)，允许其通过逐点乘法充当过滤器。类似于我们在遗忘门中看到的，接近零的输出告诉我们，我们不想更新单元状态的该元素。</li><li id="3de3" class="nh ni it kt b ku nq kx nr la ns le nt li nu lm nm nn no np bi translated">部分1和部分2的输出逐点相乘。这导致我们在第2部分中决定的新信息的大小被调整，并且如果需要的话被设置为0。得到的组合向量然后被<em class="ne">加</em>到单元状态，导致网络的长期记忆被更新。</li></ol><h2 id="fc10" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">第三步</h2><p id="6664" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">既然我们对网络长期记忆的更新已经完成，我们可以进入最后一步，<strong class="kt jd">输出门</strong>，决定新的隐藏状态。为了决定这一点，我们将使用三样东西；新更新的单元状态、先前的隐藏状态和新的输入数据。</p><p id="2d07" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有人可能认为我们可以只输出更新的单元状态；然而，这相当于有人在只被问及他们认为明天股市会涨还是会跌时，就把他们所知道的关于股市的一切都卸下来了！</p><p id="e930" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了防止这种情况发生，我们创建了一个滤波器，<em class="ne">输出门</em>，就像我们在遗忘门网络中所做的一样。输入是相同的(先前的隐藏状态和新数据)，激活也是sigmoid(因为我们希望从[0，1]中的输出获得滤波器属性)。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ba2dd5d18e839d8d23fd1b811c3f58b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*Iz3_7-RlonZE9jrXSbgR0g.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">输出门</p></figure><p id="f8b3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如前所述，我们希望将这个过滤器应用于新更新的单元格状态。这确保了只输出必要的信息(保存到新的隐藏状态)。但是，在应用过滤器之前，我们通过一个tanh传递单元格状态，以强制值进入区间[-1，1]。<br/> <br/>这最后一步的逐步过程如下:<br/> ▹将双曲正切函数逐点应用于当前单元状态，以获得压扁的单元状态，其现在位于[-1，1]。<br/> ▹通过sigmoid激活的神经网络传递先前的隐藏状态和当前的输入数据以获得滤波器向量。<br/> ▹通过逐点乘法将该滤波器向量应用于压扁的单元状态。<br/> ▹输出新的隐藏状态！</p><h2 id="f38e" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">一些澄清</h2><p id="5ddc" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">虽然第3步是LSTM单元格中的最后一步，但是在我们的LSTM实际输出我们正在寻找的类型的预测之前，我们还需要考虑一些事情。</p><p id="65a7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，上述步骤重复多次。例如，如果您试图根据前30天的定价数据预测未来几天的股票价格，那么这些步骤将重复30次。换句话说，你的模型将迭代产生30个隐藏状态来预测明天的价格。</p><p id="7c0c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">但是输出还是隐藏状态。在上面的例子中，我们想要明天的价格，我们不能从明天的隐藏状态中赚钱！因此，要将隐藏状态转换为输出，我们实际上需要应用一个线性层，作为LSTM过程的最后一步。这种线性层步骤只在最末端发生一次，这就是为什么它通常不包括在LSTM单元图中的原因。</p><p id="62e7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在许多其他参考资料中，根本没有提到这个线性层步骤，这最初让我感到困惑，所以希望这能为你们中的一些读者提供澄清！</p><h2 id="5cbe" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">如何用Python实现LSTM？</h2><p id="9e8b" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">如果您想查看如何在Pytorch中实现所有这些的示例，请查看我的另一篇文章！👇</p><div class="nw nx gp gr ny nz"><a href="https://levelup.gitconnected.com/forecasting-walmart-quarterly-revenue-pytorch-lstm-example-b4e4b20862a7" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">预测沃尔玛季度收入——py torch LSTM示例</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">应用LSTM网络预测季节性时间序列数据</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on lt nz"/></div></div></a></div><h2 id="9163" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">结论</h2><p id="49ff" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">感谢那些坚持到现在的人，我希望这篇文章对你理解LSTM网络有所帮助！如有任何反馈或问题，请随时发表评论。</p><div class="nw nx gp gr ny nz"><a href="https://medium.com/@riandolphin/membership" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">加入我的推荐链接-海豚</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oo l ok ol om oi on lt nz"/></div></div></a></div><h2 id="068b" class="mg mh it bd mi mj mk dn ml mm mn dp mo la mp mq mr le ms mt mu li mv mw mx iz bi translated">其他资源</h2><p id="e2f5" class="pw-post-body-paragraph kr ks it kt b ku my kd kw kx mz kg kz la na lc ld le nb lg lh li nc lk ll lm im bi translated">其他一些观点可以在<a class="ae nd" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank"> Colah的Github帖子</a>、<a class="op oq ep" href="https://medium.com/u/1bdc81ea939d?source=post_page-----8fae6aefc7f9--------------------------------" rel="noopener" target="_blank"> Michael Phi </a>的<a class="ae nd" rel="noopener" target="_blank" href="/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21">帖子</a>中找到，其中包含精彩的动画，以及<a class="ae nd" href="https://cs224d.stanford.edu/lecture_notes/LectureNotes4.pdf" rel="noopener ugc nofollow" target="_blank"> Stanford的笔记</a>。</p></div></div>    
</body>
</html>