<html>
<head>
<title>Major Data Frame Operations with R &amp; Python code — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用R &amp; Python代码的主要数据框操作—第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/major-data-frame-operations-with-r-python-code-part-1-686f6d34ff5e?source=collection_archive---------14-----------------------#2020-10-25">https://towardsdatascience.com/major-data-frame-operations-with-r-python-code-part-1-686f6d34ff5e?source=collection_archive---------14-----------------------#2020-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6cae9db2219d5e80230e6e29c72bbd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6lNg9EiyHQSetGC_Vf8rQ.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@campaign_creators?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae kc" href="https://unsplash.com/s/photos/data-transformation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="07a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当谈到数据分析时，数据争论的知识或以正确的形式和格式放置可用数据集与数据分析的实际操作一样必要。</p><p id="6e4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，数据不会以我们想要的形式出现，因此知道如何做到这一点变得至关重要。尽管我们有很多软件工具来处理数据，但在本文中，我将向您展示如何使用R和Python来完成这项工作。</p><p id="2d6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将要讨论的主要操作有:</p><ol class=""><li id="d39a" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">数据帧子集化</li><li id="ed06" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">对行和列应用函数</li><li id="0c8a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">分组和应用聚合函数</li><li id="4043" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">数据框旋转</li><li id="0a11" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">数据帧熔化</li><li id="afbf" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">将多个数据框连接/合并在一起</li></ol><p id="7b6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所用数据:<strong class="kf ir">泰坦尼克号数据集</strong></p><p id="00dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用的Python包:<strong class="kf ir">熊猫</strong></p><p id="5b73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用的r库:<strong class="kf ir"> Dplyr，reshape2 </strong></p><p id="3a0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">设置环境和导入数据</strong></p><p id="b498" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分析任何数据的第一步是将数据导入到您想要用于分析的环境中。因为我将在整篇文章中讨论R &amp; Python的两种变体，所以让我们先导入数据和所需的库。您可以使用Python的R或Sci-kit learn包中内置的titanic数据集，但更方便的方法是通过使用下面代码中提到的URL来使用我在Github帐户上托管的数据。</p><p id="a4cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> R —版本:</strong></p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c12b" class="ly lz iq lu b gy ma mb l mc md">library(dplyr)</span><span id="b3dc" class="ly lz iq lu b gy me mb l mc md">library(reshape2)</span><span id="3054" class="ly lz iq lu b gy me mb l mc md">titanic &lt;- read.csv(‘https://raw.githubusercontent.com/hurratanvir/algo-trade/master/titanic.csv')</span></pre><p id="9815" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Python —版本:</strong></p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a9ca" class="ly lz iq lu b gy ma mb l mc md">import pandas as pd</span><span id="2c86" class="ly lz iq lu b gy me mb l mc md">titanic = pd.read_csv(‘https://raw.githubusercontent.com/hurratanvir/algo-trade/master/titanic.csv')</span></pre><p id="026a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，由于我们手里有titanic variable中的数据，让我们跳到分析部分，但在此之前，让我们尝试理解数据(至少我们将使用的几列)。直接在任意Python IDE中运行数据框变量的名称，在R Studio中运行<em class="mf"> View(titanic) </em>，就可以在Python中查看数据框。</p><p id="ed44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">泰坦尼克号的数据集包含了乘客的数据(姓名，票价等。以及他们是否幸存)谁在1912年登上了著名的泰坦尼克号。数据框中的各列如下:</p><p id="cae5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> PassengerId </strong>:认为是数据记录的序列号。在数据帧中，每个乘客都有一个唯一的id。</p><p id="6598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">生还:</strong> 0表示没有生还，1表示乘客生还</p><p id="7a70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Pclass </strong>:乘客等级(1-一等，2-二等，3-三等)</p><p id="0653" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">性别</strong>:乘客的性别</p><p id="7da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">年龄</strong>:乘客的年龄</p><p id="00f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">票价</strong>:乘客支付的票价</p><p id="d75c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1。</strong> <strong class="kf ir">数据帧子集化</strong></p><p id="2eba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在数据分析中经常需要数据帧子集化。举个例子，在泰坦尼克号的数据框中，假设你想只使用男性乘客的数据，或者那些幸存的乘客的数据，或者那些支付了高于某个特定金额的票价的乘客的数据。如果在所有数据集中，您只想使用姓名列或票价列等，该怎么办？上面提到的所有情况都要求您根据给定的条件对数据进行子集划分。所以让我们看看它是如何在R和Python中实现的</p><p id="3867" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> R —版本:</strong></p><p id="dbac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在R中，您可以使用已经导入的dplyr库来完成这项工作。这个库中有两个主要函数在这种情况下会很有用，<em class="mf"> select() </em>和<em class="mf"> filter() </em>。现在让我们看看它们是如何使用的:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="7f95" class="ly lz iq lu b gy ma mb l mc md">#Selecting only PassengerId and Name columns</span><span id="3de8" class="ly lz iq lu b gy me mb l mc md">select(titanic, c(PassengerId, Name))</span><span id="c1ba" class="ly lz iq lu b gy me mb l mc md">#Selecting only those records where sex is male</span><span id="ab18" class="ly lz iq lu b gy me mb l mc md">filter(titanic, Sex == ‘male’)</span><span id="0198" class="ly lz iq lu b gy me mb l mc md">#Selecting the record of only those males who survived</span><span id="e91c" class="ly lz iq lu b gy me mb l mc md">filter(titanic, Sex == ‘male’ &amp; Survived == 1)</span></pre><p id="8bc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Python —版本:</strong></p><p id="1e1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Python中，您可以使用已经作为<strong class="kf ir"> pd </strong>导入的Pandas包来为您完成任务。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="f300" class="ly lz iq lu b gy ma mb l mc md">#selecting only PassengerId and Name column</span><span id="e373" class="ly lz iq lu b gy me mb l mc md">#simply pass the list containing column names as data frame index</span><span id="1359" class="ly lz iq lu b gy me mb l mc md">titanic[[‘PassengerId’, ‘Name’]]</span></pre><p id="0654" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在python中，基于特定条件过滤行是通过布尔屏蔽完成的。首先生成一系列真、假值，然后将该系列作为原始数据框的索引进行传递。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="64de" class="ly lz iq lu b gy ma mb l mc md">#Selecting only those records where sex is male</span><span id="0197" class="ly lz iq lu b gy me mb l mc md">titanic[titanic[‘Sex’] == ‘male’]</span></pre><p id="68cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意在上面代码行titanic['Sex'] == 'male '首先生成一系列真-假值。当满足条件时，输出值为True，否则为False(尝试单独运行此命令)。然后，该序列作为索引传递给titanic数据帧以获得结果。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="ee17" class="ly lz iq lu b gy ma mb l mc md">#Selecting the record of only those males who survived</span><span id="d102" class="ly lz iq lu b gy me mb l mc md">titanic[(titanic[‘Sex’] == ‘male’) &amp; (titanic[‘Survived’]==1)]</span></pre><p id="edb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意每个条件周围的普通括号。</p><p id="1d02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2。</strong> <strong class="kf ir">对行和列应用函数</strong></p><p id="e752" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除非您学会通过某种数学或逻辑运算将值放入数据框中，否则您无法通过浏览数据框或仅取出数据框的一部分来从数据框中提取大量信息。数据框中的数据是按行和列排列的，当要对其执行某些操作或应用任何函数时，通常只在这两个维度上完成。简而言之，我们可以在行方向或列方向对数据帧应用函数。我们将尝试在泰坦尼克号数据框架的背景下回答几个问题，以使其更加清晰。假设我们有两列，年龄和费用<strong class="kf ir">来自我们的整个titanic数据集，我们希望首先按行检查值的总和，然后按列检查，如下所示:</strong></p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/386bc8d5ffa763498756532a42876ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*AajcZNeRpPcbfd5WeLCT9Q.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="1125" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然结果没有太多的实际用途，但可以很好地证明我们正在学习的任务。此外，为简化起见，仅显示了每个变量下的前10个值。现在让我们看看上面的过程是如何在R和Python中完成的</p><p id="09d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> R —版本</strong></p><p id="c20c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在R中，任何函数都可以通过使用<em class="mf"> apply() </em>函数应用于数据帧，该函数是R基础包的一部分。<em class="mf"> apply() </em>函数的语法是:<em class="mf"> apply(数据帧，边距，函数)</em>。第一个参数是我们希望对其应用函数的数据帧或数据帧子集。Margin控制函数是按行还是按列应用，Margin = 1表示按行操作，Margin = 2表示按列操作。让我们看看apply()函数的运行情况:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3517" class="ly lz iq lu b gy ma mb l mc md"># calculating sum of Age and Fare column (Column wise)</span><span id="67e9" class="ly lz iq lu b gy me mb l mc md">apply(select(titanic, Age, Fare), 2, sum, na.rm = TRUE)</span><span id="3f76" class="ly lz iq lu b gy me mb l mc md"># calculating sum of Age and Fare column (Row wise)</span><span id="e4f6" class="ly lz iq lu b gy me mb l mc md">apply(select(titanic, Age, Fare), 1, sum, na.rm = TRUE)</span></pre><p id="4468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先使用<em class="mf"> select() </em>函数从titanic数据集中取出Age和Fare列，然后使用<em class="mf"> apply() </em>函数，将sum函数作为数据的第三个参数，首先按列(Margin = 2)，然后按行(Margin = 1)。na.rm = TRUE的参数用于告诉<em class="mf"> apply() </em>函数忽略任何遇到的na值。</p><p id="8883" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Python —版本</strong></p><p id="3a85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在熊猫中，我们有一个类似的函数叫做<em class="mf"> apply() </em>来完成任务。我们将看到它的运行，但在此之前，让我们了解它的论点。我们必须将想要应用于数据框和轴信息的函数作为参数传递给<em class="mf"> apply() </em>函数。Axis = 0表示按行操作，axis = 1表示按列操作。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="2573" class="ly lz iq lu b gy ma mb l mc md"># calculating sum of Age and Fare column (Column wise)</span><span id="3dd8" class="ly lz iq lu b gy me mb l mc md">titanic[[‘Fare’, ‘Age’]].apply(‘sum’, axis = 1)</span><span id="4fb3" class="ly lz iq lu b gy me mb l mc md"># calculating sum of Age and Fare column (Row wise)</span><span id="0cf0" class="ly lz iq lu b gy me mb l mc md">titanic[[‘Fare’, ‘Age’]].apply(‘sum’, axis = 0)</span></pre><p id="cb9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">引号中的第一个参数“sum”告诉pandas执行sum操作。虽然，你可以使用任何你选择的功能，除了熊猫已经提供的功能。</p><p id="e2a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3。</strong> <strong class="kf ir">分组并应用聚合函数</strong></p><p id="8a98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在回答某些值/每个分类变量值等问题时，对数据框进行分组变得至关重要。在titanic数据集的情况下，如果我们被问及每种性别的平均票价是多少，那么我们需要首先根据性别对数据进行分组，然后执行Fare列中每个相应值的平均值计算操作。这个问题可以如下图所示:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/53315de40e2e90cbbe16d283b66c2503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XzWTjmeg8oYR6IV3I2vPLA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="e510" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简化，上述过程考虑了titanic数据集的性别和票价列的前10个值。我们首先根据某个分类变量的值(在当前情况下为性别)进行分组，然后计算总值(平均值、总和、最大值、最小值等。)的一些其他变量，票价在当前情况下。</p><p id="bc7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，上面显示了Fare列，因为我们计划以后使用它，但是您可以按照相同的分组过程用男性和女性值来可视化每个其他列。到目前为止，分组和在每个组上使用聚合函数的过程必须是清楚的。现在让我们看看这一切是如何在R和Python中完成的。</p><p id="ec9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> R —版本:</strong></p><p id="b8f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在R中，我们将首先使用<em class="mf"> group_by() </em>函数对数据进行分组，然后使用<em class="mf">summary()</em>函数对票价列应用平均值聚合函数，这两个函数都是dplyr包的一部分。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="6b24" class="ly lz iq lu b gy ma mb l mc md">titanic %&gt;% group_by(Sex) %&gt;% summarise(mean(Fare))</span></pre><p id="5f70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意使用管线操作器，<strong class="kf ir"> % &gt; % </strong>。这个操作符极大地简化了R代码。它被称为管道是有原因的，管道顶部的输出被输入到管道底部的函数。作为实例<em class="mf"> titanic % &gt; % group_by(..)</em>表示将titanic传递给group_by函数。</p><p id="91aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Python —版本:</strong></p><p id="a409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在python中，我们将使用<em class="mf"> groupby() </em>函数，该函数是pandas包的一部分，用于对性别列上的数据帧进行分组。在我们将数据分组后，我们将对其使用<em class="mf"> apply() </em>函数来计算Fare列的平均值。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="57ee" class="ly lz iq lu b gy ma mb l mc md">g = titanic.groupby(‘Sex’)</span><span id="3364" class="ly lz iq lu b gy me mb l mc md">g[[‘Fare’]].apply(‘mean’)</span></pre><p id="7d20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pandas的默认特征是将分组后的列作为分组数据框的索引。您应该运行以上两个命令，以了解这有多有用。</p><p id="2af2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 4。</strong> <strong class="kf ir">数据框旋转</strong></p><p id="537c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">旋转数据框对于从中提取信息非常有用。为了理解旋转，让我们尝试回答一个与泰坦尼克号数据框相关的问题。</p><p id="0832" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乘坐三等舱的男性乘客中有多少人幸存？ </p><p id="741a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决这个问题的一种方法是，首先按性别对数据进行分组，然后按Pclass进行另一轮分组，然后计算包含Pclass组3的男性组中1的数量。如下图所示:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/52c2f30b33fc791fd4ab2ea68a969af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BtU8BlJ6jEXhP6E4uYvCxQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="225c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你现在可以很容易地回答这个问题，通过找出对应于Pclass = 3的幸存列(= 0)下的1的数量，对应于性别=男性。为了简化，上面只考虑了20个记录。</p><p id="3cd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为在组内分组的过程可以回答我们的问题，但是有一个更简单的方法来解决这样的问题，通过旋转。相同的数据如果进行透视，看起来应该是这样的:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/66693bcae3a9ee985c8f50c0ebb39a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*MeAZEQFGYPzambyPvjLS8w.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="bd80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上表显示了在不同的性别和性别值下1的数量。旋转既方便又容易解释。所以让我们看看R &amp; Python中的旋转是如何完成的</p><p id="63e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> R —版本:</strong></p><p id="a94c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在R中，为了制作数据透视表，我们将使用reshape2库中的函数以及dplyr中的函数。在R中制作像excel一样的数据透视表有点棘手，让我们看看如何制作一个</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="dd66" class="ly lz iq lu b gy ma mb l mc md">x &lt;- select(titanic, Sex, Pclass, Survived)</span><span id="2ad4" class="ly lz iq lu b gy me mb l mc md">y &lt;- x %&gt;% group_by(Sex, Pclass) %&gt;% summarise(sum(Survived))</span><span id="a26e" class="ly lz iq lu b gy me mb l mc md">pt &lt;- dcast(y, Sex~Pclass)</span></pre><p id="336c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先在性别列上对数据进行分组&amp;再次在Pclass列上。在分组数据上，我们使用<em class="mf"> sum() </em>函数来计算幸存列的总和(因为0代表未幸存，1代表幸存，所以总和将给出幸存人员的总数)。一旦数据被分组，我们将使用reshape2库的<em class="mf"> dcast() </em>函数将数据框转换成典型的数据透视表的形状。</p><p id="1ce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Python版本:</strong></p><p id="a03b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Python (Pandas)中，从数据生成数据透视表比R相对容易。可以使用的函数是<em class="mf"> Pandas.pivot_table() </em>。调整该表需要一些参数，但我们将在titanic data frame上使用其中的4个参数来生成我们想要的数据透视表。这些论点是:</p><p id="654a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">数据</strong>:要使用的数据集，<strong class="kf ir">索引</strong>:将在数据透视表中用作索引的列名，<strong class="kf ir">列</strong>:其值将在数据透视表中用作列名的列名，<strong class="kf ir">值</strong>:将用于计算数据透视表的值的列名，<strong class="kf ir"> aggfunc </strong>:对值列的值使用的聚合函数</p><p id="c253" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们从Sex，Pclass &amp; Survived列创建一个数据透视表:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="cd3f" class="ly lz iq lu b gy ma mb l mc md">pt = pd.pivot_table(titanic, index = ‘Sex’, columns = ‘Pclass’, values = ‘Survived’, aggfunc = ‘sum’)</span></pre><p id="54bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我所说的，这比R版创建数据透视表相对容易。</p><p id="68fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 5。</strong> <strong class="kf ir">数据帧融化</strong></p><p id="3e63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据帧融合可以被视为旋转的相反过程。随着旋转向数据框添加更多列并减少行数，数据框的融合意味着在减少列数的同时添加更多行。作为一个例子，我们上面创建的数据透视表在融化时可以是这样的:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/b99f21c7b831f4227d968d974e4f4d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngs6y2em_6LIAXotNzzUoQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="7687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Melting只是选取了列名&amp;用它们制作了一个单独的列，保持了所有信息的完整性。现在让我们看看数据帧是如何在R和Python中融合的</p><p id="c6aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> R —版本:</strong></p><p id="c56b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在R中我们可以使用reshape2库的<em class="mf"> melt() </em>函数来一次性融化一个数据帧。假设我们上面创建的数据透视表被分配给变量pt，我们将使用这个pt来演示熔化</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="61d2" class="ly lz iq lu b gy ma mb l mc md">melt(pt, variable.name = ‘Pclass’)</span></pre><p id="250a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">variable.name参数将是新创建的列的名称，其中的值是从现有的列名中选取的。</p><p id="4c6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Python版本:</strong></p><p id="b9ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在python中，pandas包的melt()函数用于融合透视数据框，如下所示:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3df2" class="ly lz iq lu b gy ma mb l mc md">pd.melt(pt, ignore_index=False)</span></pre><p id="6466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ignore_index默认为True &amp;我们必须将其设置为False，因为在我们之前创建的数据透视表中，性别列被视为索引。</p><p id="fb21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6。 <strong class="kf ir">将多个数据帧合并在一起</strong></p><p id="b0c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当信息分布在不同的数据帧中时，我们需要将两个或更多的数据帧合并在一起，并且我们需要将它们组合在单个数据帧中以进行数据分析。为了更清楚地理解这一点，假设我们想在titanic数据框中添加另一列，该数据框包含有关旅行等级的信息，如下图数据框所示:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/e1a3a06808f4efd8f900a9a8bafe0b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*M8nOp_BpMdQinY3cE_j6-w.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="fa9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在下面贴了一部分泰坦尼克号的数据框，让问题更清晰。我们有PassengerId、Name和Pclass列，我们希望向其中添加另一列，其中Pclass被转换为基于上表的类名。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/ab03899ca351508077b0102acf1cd345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*qoZh362MPAL17yvoAcu_rQ.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="35a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，我们想要一个如下所示的新数据框:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/38e68d7766bfd9ef41352bec6ddcae43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDBRz35jkBz-4iYqxXbB0w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="af80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，合并的好处肯定是显而易见的，同时，您可能已经猜对了，为了合并两个数据框，它们必须至少有一个公共列。如下所述，可以更清楚地理解合并过程:</p><ul class=""><li id="899e" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la mo lh li lj bi translated">我们有两个数据框共享一个公共列(您可以称之为关键列)</li><li id="8f68" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mo lh li lj bi translated">左数据框中的关键字与右数据框中的关键字一一匹配</li><li id="ab89" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la mo lh li lj bi translated">在每次匹配时，根据正在执行的合并/连接过程的类型返回结果。</li></ul><p id="e932" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开始编码练习之前，让我们先了解不同类型的合并/连接过程:</p><ol class=""><li id="f134" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">左连接</strong>:在左连接中，即使没有找到匹配，也会返回左数据框的行。左列中所有与右列不匹配的值将在右数据框的列下获得Nan或Null值，如下所示:</li></ol><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/8a06b85c0eca1e342c9856a570da9375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fg6Nm8J-29U8Jujid3_g4A.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="5f09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<strong class="kf ir">右连接</strong>:在右连接中，即使右数据框中的行在左数据框中没有匹配项，也会返回右数据框中的行。右数据框中所有与左数据框不匹配的值将在左数据框的列下获得Nan/Null值，如下所示:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/678cad3b746b3ebb0df8d60f57a6b321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*specuaw24emATqQ4BPNWlg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="818a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<strong class="kf ir">内连接</strong>:内连接是最常用的连接技术。仅返回找到匹配项的行，如下所示:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/ca175fb6a80e539247980e2c9927cb0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wWr0ygxcA67PRQe88RAjg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="831f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.<strong class="kf ir">外部/完全连接</strong>:在外部连接中，无论是否找到匹配，都返回两个数据帧的所有行。特定数据框中与另一个数据框不匹配的所有行在另一个数据框的列下都为Nan或Null，如下所示:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/8b6f9bfb9d8d19ac9acd45a6e5ce8197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lxkg3f3NCCOyEzxy0ghK-Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来源:Self</p></figure><p id="e890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道了连接的含义和它的不同类型，让我们看看所有这些是如何在Python和R中完成的</p><p id="21f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> R —版本:</strong></p><p id="3383" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在R中，我们在基础包中提供了<em class="mf"> merge() </em>函数，其主要参数如下:</p><p id="f545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> x </strong>:左数据框，<strong class="kf ir"> y </strong>:右数据框，<strong class="kf ir"> by </strong>:要进行合并的列(必须为两个数据框所共有)，all.x:如果我们想要左数据框中的所有行(左连接)，则设置为TRUE，<strong class="kf ir"> all.y </strong>:如果我们想要右数据框中的所有行(右连接)，则设置为TRUE。</p><p id="2297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:默认情况下，<em class="mf"> merge() </em>将执行内部连接，如果我们想要外部连接，我们需要将all.x和all.y都设置为TRUE。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="1462" class="ly lz iq lu b gy ma mb l mc md">#We will first create the other data frame that we will merge with the titanic data frame</span><span id="04fc" class="ly lz iq lu b gy me mb l mc md">y = data.frame(Pclass = c(1,2,4), Class = c(‘1st Class’, ‘2nd Class’, ‘4th Class’))</span><span id="323d" class="ly lz iq lu b gy me mb l mc md">#Left Join:</span><span id="d982" class="ly lz iq lu b gy me mb l mc md">merge(titanic, y, by = ‘Pclass’, all.x = TRUE)</span><span id="5c46" class="ly lz iq lu b gy me mb l mc md">#Right Join:</span><span id="4875" class="ly lz iq lu b gy me mb l mc md">merge(titanic, y, by = ‘Pclass’, all.y = TRUE)</span><span id="240c" class="ly lz iq lu b gy me mb l mc md">#Inner Join:</span><span id="911b" class="ly lz iq lu b gy me mb l mc md">merge(titanic, y, by = ‘Pclass’)</span><span id="7b33" class="ly lz iq lu b gy me mb l mc md">#Outer/Full Join:</span><span id="b8ad" class="ly lz iq lu b gy me mb l mc md">merge(titanic, y, by = ‘Pclass’, all.x = TRUE, all.y = TRUE)</span></pre><p id="4c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Python —版本:</strong></p><p id="75fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Pandas中，我们有一个<em class="mf"> Pandas.merge() </em>函数来处理所有的合并需求。主要论点是:</p><p id="052f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> on </strong>:需要合并的列(必须为两个数据框所共有)，<strong class="kf ir"> how </strong>:合并类型，可以是“左”、“右”、“内”或“外”。</p><p id="aa16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看如何使用它</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="598b" class="ly lz iq lu b gy ma mb l mc md">#We will first create the other data frame that we will merge with the titanic data frame</span><span id="aa34" class="ly lz iq lu b gy me mb l mc md">y = pd.DataFrame({‘Pclass’:[1,2,4], ‘Class’:[‘1st Class’, ‘2nd Class’, ‘4th Class’]})</span><span id="0e8d" class="ly lz iq lu b gy me mb l mc md">#Left Join:</span><span id="e710" class="ly lz iq lu b gy me mb l mc md">pd.merge(titanic, y, on=’Pclass’, how = ‘left’)</span><span id="0e05" class="ly lz iq lu b gy me mb l mc md">#Right Join:</span><span id="04fe" class="ly lz iq lu b gy me mb l mc md">pd.merge(titanic, y, on=’Pclass’, how = ‘right’)</span><span id="a515" class="ly lz iq lu b gy me mb l mc md">#Inner Join:</span><span id="72d2" class="ly lz iq lu b gy me mb l mc md">pd.merge(titanic, y, on=’Pclass’, how = ‘inner’)</span><span id="bea8" class="ly lz iq lu b gy me mb l mc md">#Outer/Full Join:</span><span id="8f62" class="ly lz iq lu b gy me mb l mc md">pd.merge(titanic, y, on=’Pclass’, how = ‘outer’)</span></pre><p id="b03f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">结论:</strong></p><p id="a384" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管除了强调各种数据转换技术之外，这个主题并不需要一个结论，但是本文在数据转换方面对R和Python进行了比较。虽然我们只讨论了6种数据框架转换技术，对其做出判断是不公平的，但有一点我们可以肯定，Python和R都足够强大，可以非常轻松地处理任何复杂的数据转换任务。到目前为止，我的个人观点是，对于数据分析和可视化，R比Python容易得多，当谈到机器学习时，Python占了上风。但是，这也是我个人的观点，也是可以争论的。</p></div></div>    
</body>
</html>