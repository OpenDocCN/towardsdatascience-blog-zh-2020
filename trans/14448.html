<html>
<head>
<title>Lightweight yet scalable TensorFlow workflow on Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google Cloud上轻量级但可扩展的TensorFlow工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lightweight-yet-scalable-tensorflow-workflow-on-google-cloud-b32e0ba410c6?source=collection_archive---------27-----------------------#2020-10-05">https://towardsdatascience.com/lightweight-yet-scalable-tensorflow-workflow-on-google-cloud-b32e0ba410c6?source=collection_archive---------27-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9b4a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我的超能力工具包:TFRecorder、TensorFlow Cloud、人工智能平台预测和权重与偏差</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/571be4b6f312497f41b9532aa87c4270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Qzkf0gVtKIBDakB8DIhQg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者使用<a class="ae kv" href="https://www.figma.com/" rel="noopener ugc nofollow" target="_blank">figma.com</a></p></figure><p id="3458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我正要说出来。今天，机器学习(ML)的广度和深度越来越大，这让我完全不知所措。</p><ul class=""><li id="7924" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">需要建立一个高性能的数据管道？学习Apache Beam或Spark和协议缓冲区</li><li id="ed1b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">需要缩放你的模型训练？了解全还原和多节点分布式架构</li><li id="858e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">需要部署您的模型吗？学习Kubernetes、TFServing、量化和API管理</li><li id="d959" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">需要跟踪管道？建立一个元数据库，学习docker，成为一名DevOps工程师</li></ul><p id="7adb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这甚至还不包括算法和建模空间，这也让我觉得自己像一个没有研究背景的冒名顶替者。一定有更简单的方法！</p><p id="4616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过去几周，我一直在思考这个两难的问题，以及我会向一位与我有相似思维模式的数据科学家推荐什么。上面的许多主题都很重要，尤其是如果你想专注于MLOps这一新领域，但有没有工具和技术可以让你站在巨人的肩膀上？</p><p id="211f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是4个这样的工具，它们抽象出许多复杂性，可以让你更有效地开发、跟踪和扩展你的ML工作流程。</p><ul class=""><li id="085d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/google/tensorflow-recorder" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> TFRecorder </strong> </a> <strong class="ky ir">【通过数据流】</strong>:通过导入CSV文件，轻松将数据转化为TFRecords。对于图像，只需在CSV中提供JPEG URIs和标签。通过数据流扩展到分布式服务器，无需编写任何Apache Beam代码。</li><li id="f16c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/tensorflow/cloud" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">TensorFlow Cloud</strong></a><strong class="ky ir">(通过AI平台训练):</strong>通过一个简单的API调用，将您的tensor flow模型训练扩展到AI平台训练的单节点和多节点GPU集群。</li><li id="d660" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> AI平台预测:</strong>将您的模型作为API端点部署到Kubernetes支持的带有GPU的自动缩放服务，与<a class="ae kv" href="https://cloud.google.com/blog/products/ai-machine-learning/how-waze-predicts-carpools-using-google-cloud-ai-platform" rel="noopener ugc nofollow" target="_blank"> Waze </a>使用的相同！</li><li id="3f3b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">权重&amp;偏差:</strong>记录工件(数据集和模型)来跟踪整个开发过程中的版本和沿袭。自动生成你的实验和工件之间的关系树<a class="ae kv" href="https://www.wandb.com/articles/announcing-artifacts" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><h1 id="2be5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">工作流程概述</h1><p id="7279" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我将使用一个典型的猫和狗的计算机视觉问题来浏览这些工具。此工作流程包含以下步骤:</p><ul class=""><li id="0316" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将原始JPEG图像保存到对象存储中，每个图像位于指定其标签的子文件夹下</li><li id="3066" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">以所需格式生成带有图像URIs和标签的CSV文件</li><li id="e8dd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将图像和标签转换为TFRecords</li><li id="45fe" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">从TFRecords创建数据集，并使用Keras训练CNN模型</li><li id="d593" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将模型存储为SavedModel，并部署为API端点</li><li id="dfee" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">JPEG图像、TFRecords和SavedModels都将存储在对象存储中</li><li id="5ad8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">实验和人工制品的传承将通过权重和偏差进行跟踪</li></ul><p id="256d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用的笔记本和脚本都在这个<a class="ae kv" href="https://github.com/mchrestkha/machine_learning_examples/tree/master/catsdogs/tensorflow" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>里。</p><p id="358c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们深入了解每种工具。</p><h1 id="5ef3" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">TF记录器</h1><p id="b285" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">TFRecords还是让我很困惑。我理解它们提供的性能优势，但是一旦我开始处理一个新的数据集，我总是很难使用它们。显然我不是唯一的一个，谢天谢地，TFRecorder项目最近才发布。使用TFRecords从未如此简单，它只需要(1)以逻辑目录格式组织您的图像，以及(2)使用PANDAS数据帧和CSV。以下是我采取的步骤:</p><ul class=""><li id="d265" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建一个包含3列的CSV文件，包括指向每个图像目录位置的图像URI</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/54157ce08c0d67874a70f1b59fc9f8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MybwAqvOZI3PzdvQflRSxg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><ul class=""><li id="b1fe" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">将CSV读入PANDAS数据帧，并调用TFRecorder函数转换数据流上的文件，指定输出目录</li></ul><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="fa8c" class="nj mh iq nf b gy nk nl l nm nn">dfgcs = pd.read_csv(FILENAME)</span><span id="a6d4" class="nj mh iq nf b gy no nl l nm nn">dfgcs.tensorflow.to_tfr(<br/>    output_dir=TFRECORD_OUTPUT,<br/>    runner='DataFlowRunner',<br/>    project=PROJECT,<br/>    region=REGION,<br/>    tfrecorder_wheel=TFRECORDER_WHEEL)</span></pre><p id="6731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！不到10行代码就可以将数百万张图像转换成TFRecord格式。作为一名数据科学家，您刚刚为高性能培训渠道奠定了基础。如果你对后台发生的奇迹感兴趣，你也可以看看数据流控制台中的数据流作业图和指标。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/cce23a506bff1e5b3a73f3914ee854df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiRoS9ZdTHvq6lpVBA2zgw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0b33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通读了一点GitHub repo之后，tfrecord的模式如下:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="ef51" class="nj mh iq nf b gy nk nl l nm nn">tfr_format = {<br/>            "image": tf.io.FixedLenFeature([], tf.string),<br/>            "image_channels": tf.io.FixedLenFeature([], tf.int64),<br/>            "image_height": tf.io.FixedLenFeature([], tf.int64),<br/>            "image_name": tf.io.FixedLenFeature([], tf.string),<br/>            "image_width": tf.io.FixedLenFeature([], tf.int64),<br/>            "label": tf.io.FixedLenFeature([], tf.int64),<br/>            "split": tf.io.FixedLenFeature([], tf.string),<br/>        }</span></pre><p id="e27f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您可以使用下面的代码将TFRecords读入Keras模型定型管道的TFRecordDataset中:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4637" class="nj mh iq nf b gy nk nl l nm nn">IMAGE_SIZE=[150,150]<br/>BATCH_SIZE = 5</span><span id="d888" class="nj mh iq nf b gy no nl l nm nn">def read_tfrecord(example):<br/>    image_features= tf.io.parse_single_example(example, tfr_format)<br/>    image_channels=image_features['image_channels']<br/>    image_width=image_features['image_width']<br/>    image_height=image_features['image_height']<br/>    label=image_features['label']<br/>    image_b64_bytes=image_features['image']<br/>    <br/>    image_decoded=tf.io.decode_base64(image_b64_bytes)<br/>    image_raw = tf.io.decode_raw(image_decoded, out_type=tf.uint8)<br/>    image = tf.reshape(image_raw, tf.stack([image_height,    image_width, image_channels]))<br/>    image_resized = tf.cast(tf.image.resize(image, size=[*IMAGE_SIZE]),tf.uint8)<br/>    return image_resized, label</span><span id="3fdf" class="nj mh iq nf b gy no nl l nm nn">def get_dataset(filenames):<br/>    dataset = tf.data.TFRecordDataset(filenames=filenames, compression_type='GZIP') <br/>    dataset = dataset.map(read_tfrecord)<br/>    dataset = dataset.shuffle(2048)<br/>    dataset = dataset.batch(BATCH_SIZE)<br/>    return dataset</span><span id="f814" class="nj mh iq nf b gy no nl l nm nn">train_dataset = get_dataset(TRAINING_FILENAMES)<br/>valid_dataset = get_dataset(VALID_FILENAMES)</span></pre><h1 id="2dac" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">TensorFlow云(AI平台训练)</h1><p id="b987" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我们有了一个tf.data.Dataset，我们可以将它输入到我们的模型训练调用中。下面是一个使用Keras顺序API的CNN模型的简单例子。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="9f91" class="nj mh iq nf b gy nk nl l nm nn">model = tf.keras.models.Sequential([<br/>    tf.keras.layers.Conv2D(16, (3,3), activation='relu', input_shape=(150, 150, 3)),<br/>    tf.keras.layers.MaxPooling2D(2, 2),<br/>    tf.keras.layers.Conv2D(32, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),<br/>    tf.keras.layers.MaxPooling2D(2,2),<br/>    tf.keras.layers.Flatten(),<br/>    tf.keras.layers.Dense(256, activation='relu'),<br/>    tf.keras.layers.Dense(1, activation='sigmoid')<br/>])</span><span id="070b" class="nj mh iq nf b gy no nl l nm nn">model.summary()<br/>model.compile(loss='binary_crossentropy',<br/>              optimizer=RMSprop(lr=1e-4),<br/>              metrics=['accuracy'])<br/>model.fit(<br/>    train_dataset,<br/>    epochs=10,<br/>    validation_data=valid_dataset,<br/>    verbose=2<br/>)</span></pre><p id="1d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我首先在我的开发环境中对一部分图像(在我的例子中是一个Jupyter笔记本)运行这个，但是我想让它扩展到所有的图像并使它更快。TensorFlow Cloud允许我使用单个API命令来封装我的代码，并提交作为分布式GPU作业运行。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="a2e3" class="nj mh iq nf b gy nk nl l nm nn">import tensorflow_cloud as tfc</span><span id="1665" class="nj mh iq nf b gy no nl l nm nn">tfc.run(entry_point='model_training.ipynb',<br/>        chief_config=tfc.COMMON_MACHINE_CONFIGS['T4_4X'],<br/>        requirements_txt='requirements.txt')</span></pre><p id="3595" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是愚人节的玩笑。上面的代码(&lt; 5行代码)是完整的python脚本，您需要将它放在与Jupyter笔记本相同的目录中。最棘手的部分是遵循所有的设置说明，以确保您正确地通过了Google云平台项目的身份验证。这是一种巨大的超级力量！</p><p id="b55d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们更深入地了解一下这是怎么回事。</p><p id="8103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，将构建一个docker容器，其中包含您需要的所有库和笔记本，并保存在Google Cloud的容器注册服务中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/5f67ecfa834523355d3f2fa132fbfab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DHHthHcKBI0BfJbVg_ugQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="547c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该容器然后被提交给完全管理的无服务器培训服务，AI平台培训。无需设置任何基础设施和安装任何GPU库，我就可以在一台16 vCPU 60GB RAM、配有4个英伟达T4 GPU的机器上训练这个模型。我只在需要的时候使用这些资源(大约15分钟)，并且可以使用IDE或Jupyter笔记本在我的本地环境中继续开发。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/b0e94d6b26117fed59cf8271a5e64962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZS60P978u0dcLow0JX3LA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3242" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SavedModel最终存储在对象存储中，这是在我的训练脚本的最后指定的。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="f505" class="nj mh iq nf b gy nk nl l nm nn">MODEL_PATH=time.strftime("gs://mchrestkha-demo-env-ml-examples/catsdogs/models/model_%Y%m%d_%H%M%S")<br/>model.save(MODEL_PATH)</span></pre><h1 id="cc8f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">人工智能平台预测</h1><p id="00ac" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">通过对象存储中的SavedModel，我可以将它加载到我的开发环境中，并运行一些示例预测。但是，如果我想允许其他人使用它，而不需要他们设置Python环境和学习TensorFlow，该怎么办？这就是人工智能平台预测发挥作用的地方。它允许您将模型二进制文件部署为API端点，可以使用REST、简单的Google Cloud SDK (gcloud)或各种其他客户端库来调用这些端点。最终用户只需要知道所需的输入(在我们的例子中，JPEG图像文件被转换为[150，150，3] JSON数组)并可以将您的模型嵌入到他们的工作流中。当你做了一个改变(在一个新的数据集上重新训练，一个新的模型架构，甚至一个新的框架)，你可以发布一个新的版本。</p><p id="2bfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面简单的gcloud SDK是将您的模型部署到这个Kubernetes支持的自动缩放服务的超级力量。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="8bd1" class="nj mh iq nf b gy nk nl l nm nn">MODEL_VERSION="v1"<br/>MODEL_NAME="cats_dogs_classifier"<br/>REGION="us-central1"</span><span id="1af8" class="nj mh iq nf b gy no nl l nm nn">gcloud ai-platform models create $MODEL_NAME \<br/>    --regions $REGION</span><span id="6b99" class="nj mh iq nf b gy no nl l nm nn">gcloud ai-platform versions create $MODEL_VERSION \<br/>  --model $MODEL_NAME \<br/>  --runtime-version 2.2 \<br/>  --python-version 3.7 \<br/>  --framework tensorflow \<br/>  --origin $MODEL_PATH</span></pre><p id="9740" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://cloud.google.com/blog/products/ai-machine-learning/ai-platform-prediction-better-reliability-ml-workflows" rel="noopener ugc nofollow" target="_blank">人工智能平台预测</a>是一项让我特别兴奋的服务，因为它消除了让你的模型进入世界(内部和外部)并开始从中创造价值的许多复杂性。虽然这个博客的范围是一个实验性的工作流程<a class="ae kv" href="https://cloud.google.com/blog/products/ai-machine-learning/how-waze-predicts-carpools-using-google-cloud-ai-platform" rel="noopener ugc nofollow" target="_blank">像Waze </a>这样的公司正在使用人工智能平台预测来部署和服务他们的大规模生产模型。</p><h1 id="e747" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">权重和偏差</h1><p id="b91b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在我已经完成了一个实验，但是我未来的实验呢？我可能需要:</p><ul class=""><li id="0bbf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">本周晚些时候运行更多的实验，并跟踪我的工作</li><li id="a652" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一个月后再来，试着记住我每个实验的所有输入和输出</li><li id="76f9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">与有希望将我的工作流程拼凑起来的队友分享工作</li></ul><p id="9688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在ML管道领域有很多工作要做。这是一个令人兴奋但仍处于萌芽状态的领域，最佳实践和行业标准仍有待开发。一些很棒的项目包括MLFlow、Kubeflow Pipelines、TFX和Comet.ML。对于我的工作流的需求，MLOps和连续交付超出了范围，我想要简单的东西。我选择了Weights &amp; bias(WandB ),因为它易于使用，并且可以轻量级集成来跟踪实验和工件。</p><p id="e453" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先说实验。WandB提供了许多定制选项，但是如果你使用任何一个流行的框架，你不需要做太多。对于TensorFlow Keras API，我简单地(1)导入了<em class="ns"> wandb </em> python库(2)初始化了我的实验运行，以及(3)在模型拟合步骤中添加了一个回调函数。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="5c9b" class="nj mh iq nf b gy nk nl l nm nn">model.fit(<br/>    train_dataset,<br/>    epochs=10,<br/>    validation_data=valid_dataset,<br/>    verbose=2,<br/>   <strong class="nf ir"> callbacks=[WandbCallback()</strong>]<br/>)</span></pre><p id="47c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将自动将现成的指标流入集中的实验跟踪服务。看看人们使用<a class="ae kv" href="https://www.wandb.com/articles" rel="noopener ugc nofollow" target="_blank"> WandB的所有方式</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/2e5f022f648e25cebc217eaca6c819f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23CX5IM1NPwHt3z5KUZvrg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="445b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">WandB还提供了一个工件API，它比当今一些笨重的工具更适合我的需求。我在整个管道中添加了简短的代码片段，以定义4个关键项目:</p><ol class=""><li id="71d3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nu ly lz ma bi translated">初始化管道中的一个步骤</li><li id="392a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">使用现有的工件(如果有的话)作为这个步骤的一部分</li><li id="7d27" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">记录由该步骤生成的工件</li><li id="e934" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">说明一个步骤已经完成</li></ol><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="3cfe" class="nj mh iq nf b gy nk nl l nm nn">run = wandb.init(project='cats-dogs-keras', job_type='data', name='01_set_up_data')</span><span id="596a" class="nj mh iq nf b gy no nl l nm nn"><strong class="nf ir"><em class="ns">&lt;Code to set up initial JPEGs in the appropriate directory structure&gt;</em></strong></span><span id="0b7e" class="nj mh iq nf b gy no nl l nm nn">artifact = wandb.Artifact(name='training_images',job_type='data', type='dataset')<br/>artifact.add_reference('gs://mchrestkha-demo-env-ml-examples/catsdogs/train/')<br/>run.<strong class="nf ir">log_artifact</strong>(artifact)<br/>run.finish()</span><span id="cc7a" class="nj mh iq nf b gy no nl l nm nn">run = wandb.init(project='cats-dogs-keras',job_type='data', name='02_generate_tfrecords')</span><span id="2088" class="nj mh iq nf b gy no nl l nm nn">artifact = run.<strong class="nf ir">use_artifact</strong>('training_images:latest')</span><span id="4c18" class="nj mh iq nf b gy no nl l nm nn"><strong class="nf ir"><em class="ns">&lt;TFRecorder Code&gt;</em></strong></span><span id="897a" class="nj mh iq nf b gy no nl l nm nn">artifact = wandb.Artifact(name='tfrecords', type='dataset')<br/>artifact.add_reference('gs://mchrestkha-demo-env-ml-examples/catsdogs/tfrecords/')<br/>run.<strong class="nf ir">log_artifact</strong>(artifact)<br/>run.finish()</span><span id="12df" class="nj mh iq nf b gy no nl l nm nn">run = wandb.init(project='cats-dogs-keras',job_type='train', name='03_train')<br/>artifact = run.<strong class="nf ir">use_artifact</strong>('tfrecords:latest')</span><span id="9742" class="nj mh iq nf b gy no nl l nm nn"><strong class="nf ir"><em class="ns">&lt;TensorFlow Cloud Code&gt;</em></strong></span><span id="2005" class="nj mh iq nf b gy no nl l nm nn">artifact = wandb.Artifact(name='model', type='model')<br/>artifact.add_reference(MODEL_PATH)<br/>run.<strong class="nf ir">log_artifact</strong>(artifact)</span></pre><p id="4c15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个简单的工件API存储了每次运行和工件的元数据和沿袭，因此您可以完全清楚您的工作流。UI也有一个漂亮的树形图来图形化地查看它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/57ffa4819f40be14d0494d10aeebd1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_zPJKo7bjkiui-fITnGOQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="770c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">摘要</h1><p id="3e89" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如果你被无休止的机器学习主题、工具和技术吓倒，你并不孤单。我每天与同事、合作伙伴和客户谈论数据科学、MLOps、硬件加速器、数据管道、AutoML等的各个方面时，都会感到一种冒名顶替综合症。请记住，重要的是:</p><ol class=""><li id="e627" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nu ly lz ma bi translated"><strong class="ky ir">实际一点</strong>:让我们所有人都成为开发操作系统、数据和机器学习领域的全栈工程师是不现实的。选择一两个你感兴趣的领域，和其他人一起解决整个系统的问题。</li><li id="d5da" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">关注你的问题:我们都被新的框架、新的研究论文、新的工具冲昏了头脑。从您的业务问题、数据集和最终用户需求开始。不是每个人都需要每天对生产中的数百个ML模型进行重新训练，并提供给数百万用户(至少现在还不是)。</li><li id="e9fb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated"><strong class="ky ir">识别超级工具:</strong>找到一套核心工具，作为效率倍增器，提供可伸缩性并消除复杂性。我浏览了我的Tensorflow工具包(<strong class="ky ir">TF recorder+tensor flow Cloud+AI平台预测+权重&amp;偏差</strong>)，但是找到了映射到您的问题和工作流的正确工具包。</li></ol><p id="0b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有问题或者想聊天？在<a class="ae kv" href="https://twitter.com/mchrestkha" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上找到我</p><p id="6ff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个博客的笔记本例子可以在<a class="ae kv" href="https://github.com/mchrestkha/machine_learning_examples/tree/master/catsdogs/tensorflow" rel="noopener ugc nofollow" target="_blank">我的GitHub </a>上找到。</p><p id="edf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢<a class="ae kv" href="https://www.linkedin.com/in/mike-bernico/" rel="noopener ugc nofollow" target="_blank"> Mike Bernico </a>、<a class="ae kv" href="https://www.linkedin.com/in/rajeshthallam/" rel="noopener ugc nofollow" target="_blank">Rajesh thal am</a>和<a class="ae kv" href="https://www.linkedin.com/in/1vaibhavsingh/" rel="noopener ugc nofollow" target="_blank"> Vaibhav Singh </a>帮助我完成这个示例解决方案。</p></div></div>    
</body>
</html>