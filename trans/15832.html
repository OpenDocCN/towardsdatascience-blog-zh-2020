<html>
<head>
<title>Real-Time Simulation-based Analytics Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于实时模拟的分析服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/real-time-simulation-based-analytics-services-3b1f722ebd14?source=collection_archive---------24-----------------------#2020-10-31">https://towardsdatascience.com/real-time-simulation-based-analytics-services-3b1f722ebd14?source=collection_archive---------24-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="62a8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在AWS上使用SimPy进行概念验证，英尺。Terraform和本地堆栈</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/918e4adab7d79861da656925e8aa2f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Y8T56MWmpHOS8rBn8zyiHQ.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">沃尔夫冈·哈塞尔曼的照片</p></figure><p id="90a3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在他最近发表的非常有趣的<a class="ae kr" href="http://nbn-resolving.de/urn:nbn:de:bvb:29-opus4-145483" rel="noopener ugc nofollow" target="_blank">博士论文(德语)</a>中，来自埃尔兰根-纽伦堡大学的Toni Donhauser给出了一个很好的例子，说明了生产同步数字双胞胎如何用于砖石工厂的自动化、基于模拟的订单调度。作为一项核心功能，开发的模拟允许初始化制造系统的<em class="lo">在制品</em>，以精确反映当前状态并创建准确的短期预测，作为在意外中断情况下比较替代方案和优化生产计划的基础。<a class="ae kr" href="https://www.plm.automation.siemens.com/global/de/products/manufacturing-planning/plant-simulation-throughput-optimization.html" rel="noopener ugc nofollow" target="_blank"> Tecnomatix Plant Simulation(西门子)</a>用于仿真模型的实现。</p><p id="637c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">由于<em class="lo"> Plant Simulation </em>以广泛的功能和广泛的许可费用而闻名，这篇博客文章将介绍这种生产同步数字双胞胎的替代实现，基于开源框架并建立在易于操作、按使用付费的AWS基础设施上。可以使用<em class="lo"> Docker </em>、<em class="lo"> Terraform </em>和<em class="lo"> LocalStack </em>在本地部署和测试完整的设置(不需要AWS帐户)。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><blockquote class="lw lx ly"><p id="5ca7" class="ks kt lo ku b kv kw jr kx ky kz ju la lz lc ld le ma lg lh li mb lk ll lm ln ij bi translated"><em class="iq">从github获取回购:</em><a class="ae kr" href="https://github.com/fladdimir/csa-simulation-based-sc-forecast" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://github . com/fladdimir/CsA-simulation-based-sc-forecast</em></a></p></blockquote></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="9ac3" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">场景和范围</h1><p id="508b" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">下图显示了一个虚构的简化订单处理流程，并将作为一个最小的示例来说明如何实现系统的数字孪生。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3eaa970153036d1e08f8e2ad44605df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/0*aogJFpc2d2glaz5K.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">简单的订单处理流程</p></figure><p id="1f1c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">创建后，公司接收并接受订单(<em class="lo">摄取</em>-步骤)，订购订单特定的原材料(<em class="lo">订单_材料</em>)，让订单等待，直到相应的材料到达(<em class="lo">等待_材料</em>)。物料交付后，订单进入缓冲队列(<em class="lo"> wait_for_sop </em>)，等待在产能受限的<em class="lo">生产</em>步骤中处理，该步骤一次只能处理一个订单。最终，完成的订单被交付给客户并离开系统。</p><p id="e1a3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">每当请求订单的物料时，会分配一个初始预计到达时间(ETA)。然而，意外的供应商特定流程偏差或其他交付问题可能会在任何时间点引入延迟，因此在订单等待材料交付时，ETA更新是可能的。由于生产步骤使用受能力限制的资源，并代表系统的一个可能的瓶颈，这里任何计划外的利用不足都可能延迟每个即将到来的订单，并减少系统吞吐量(取决于时间表看起来有多紧)。因此，一旦订单的任何ETA更新发生，就希望能够量化任何时间偏移的影响。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="6555" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">同步数字孪生:概念和实现</h1><p id="b6c5" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">下图显示了一个简单的事件处理管道，能够接收定义的事件并保持系统状态(<em class="lo">事件跟踪</em>)，这反过来又能够基于模拟创建对预期订单完成时间和延迟的预测(<em class="lo">事件分析</em>)。一个简单的网络仪表板将用于可视化的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/1bb53469b2c5aa60ab2fcaca3121eebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQlQRFYU50df0d22uhyMdA.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">基于模拟的预测创建的处理流程(图标由<a class="ae kr" href="https://aws.amazon.com/de/architecture/icons/" rel="noopener ugc nofollow" target="_blank"> AWS </a>提供)</p></figure><h2 id="b04b" class="nf md iq bd me ng nh dn mi ni nj dp mm lb nk nl mo lf nm nn mq lj no np ms nq bi translated">1.数据生产者的发布事件</h2><p id="6141" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">在生产系统中处理订单的过程中，数据生产者发布进度信息，例如订单处理步骤的开始或结束。虽然这些事件实际上会在物理制造系统中发生，但在开发过程中可能会使用模拟模型来创建数字双胞胎的测试数据(参见<em class="lo">虚拟调试</em> 上的这篇<a class="ae kr" href="https://fladdimir.github.io/post/csa-vcom/" rel="noopener ugc nofollow" target="_blank">帖子，了解物流模拟用例的另一个示例)。</a></p><h2 id="7c95" class="nf md iq bd me ng nh dn mi ni nj dp mm lb nk nl mo lf nm nn mq lj no np ms nq bi translated">2.使用AWS Kinesis捕获事件</h2><p id="28d2" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated"><a class="ae kr" href="https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html" rel="noopener ugc nofollow" target="_blank"> Kinesis </a>是一个AWS服务，用于连续缓冲和实时处理流数据。Kinesis流分离了数据生产者和消费者，由可配置数量的<em class="lo">碎片</em>组成，每个碎片每秒能够摄取高达1 MB或1000条记录的数据。每个记录根据其指定的<em class="lo">分区键</em>值放入一个碎片中，这变得很重要，因为记录的有序处理<a class="ae kr" href="https://aws.amazon.com/blogs/compute/new-aws-lambda-scaling-controls-for-kinesis-and-dynamodb-event-sources/" rel="noopener ugc nofollow" target="_blank">只在分区键级别</a>上得到保证。<br/>在所描述的场景中，有序处理对于订单的ETA更新变得至关重要，因为预期延迟的消息不能在任何更早提交的更新之前处理。</p><h2 id="2619" class="nf md iq bd me ng nh dn mi ni nj dp mm lb nk nl mo lf nm nn mq lj no np ms nq bi translated">3.用AWS Lambda处理事件</h2><p id="4663" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated"><a class="ae kr" href="https://aws.amazon.com/lambda/?nc1=h_ls" rel="noopener ugc nofollow" target="_blank"> Lambda </a>是AWS提供的功能即服务，允许按需运行代码，为调用次数和执行时间付费。Lambda函数可以很容易地与其他服务耦合，比如SQS和DynamoDB。由于AWS按需提供函数运行时，NodeJS和Python的短冷启动时间使它们成为实现lambdas的流行选择。<br/>为处理订单更新而实现的lambda很简单，只需用调用中提供的事件数据更新指定DynamoDB表中受影响订单的相应项目。</p><h2 id="e4db" class="nf md iq bd me ng nh dn mi ni nj dp mm lb nk nl mo lf nm nn mq lj no np ms nq bi translated">4.用DynamoDB保持系统状态</h2><p id="b7f4" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated"><a class="ae kr" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>用作快速、灵活和可管理的NoSQL数据库。虽然这种类型的数据库在设计上缺乏关系数据库的一些便利性(例如在数据库级别上实施引用完整性的适当方法，或者复杂ORM和模式管理工具的可用性)，但它对于我们只涉及更新单个项目和基本查询的简单用例来说是很好的。DynamoDB需要一个分区键和一个可选的范围键，两者结合使用可以唯一地标识一个存储项。对于订单，字符串id可用作分区键。DynamoDB的一个很好的特性是启用<em class="lo">流</em>，自动提供表更新信息。这样，订单ETA更新可以触发新的预测。</p><h2 id="ceeb" class="nf md iq bd me ng nh dn mi ni nj dp mm lb nk nl mo lf nm nn mq lj no np ms nq bi translated">5.模拟未来</h2><p id="891b" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">AWS允许使用Lambda函数作为DynamoDB流事件消费者，因此模拟运行可以预测每个状态变化的未来订单完成时间。对于每次运行，从DynamoDB中获取当前系统状态(这实际上可能需要多次请求，因为单次扫描只能返回一页最多1 MB的数据)。<br/>基于注册的过程时间戳，可以识别每个订单的当前相关过程步骤。<br/>使用<a class="ae kr" href="https://fladdimir.github.io/post/casymda/" rel="noopener ugc nofollow" target="_blank"> Casymda </a>从上图所示的流程图生成仿真模型。为了概念证明的简单性，处理时间被假定为确定性的。实施模型块是为了说明<em class="lo">在制品</em>实体在模拟开始时已经经过的处理时间(初始化<em class="lo">在线模拟</em>模型的可能性之一，在<a class="ae kr" href="https://informs-sim.org/wsc05papers/222.pdf" rel="noopener ugc nofollow" target="_blank"> Hanisch和Tolujew，2005 </a>的经常引用的论文中讨论，并由<a class="ae kr" href="https://d-nb.info/987148664/34" rel="noopener ugc nofollow" target="_blank"> Hotz，2007 </a>进一步探讨)。在执行过程中，以预测流程步骤完成时间的形式收集预测指标。<br/>目前，AWS允许Lambda函数的执行时间长达15分钟，因此即使复杂的模型也可以这样运行。然而，频繁且长时间运行的计算可能会使创建专用服务更有吸引力。</p><h2 id="0a01" class="nf md iq bd me ng nh dn mi ni nj dp mm lb nk nl mo lf nm nn mq lj no np ms nq bi translated">6.+ 7.预测持久性和可视化</h2><p id="4796" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">在每次运行结束时，收集的结果被保存在第二个DynamoDB表中，仪表板应用程序可以从这个表中访问和可视化数据。<br/> <a class="ae kr" href="https://github.com/plotly/dash" rel="noopener ugc nofollow" target="_blank"> Plotly Dash </a>是一个流行的网络应用分析框架。只需编写Python代码，就可以快速创建动态仪表板。在引擎盖下，它使用<a class="ae kr" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">烧瓶</a>将<a class="ae kr" href="https://dash.plotly.com/react-for-python-developers" rel="noopener ugc nofollow" target="_blank">带有<a class="ae kr" href="https://github.com/plotly/plotly.js/" rel="noopener ugc nofollow" target="_blank">图表</a>的</a>网站反应给浏览器。使用Python在后端完成数据查询和分析。实现的仪表板只包含一个简单的甘特图。使用<em class="lo"> interval </em> -callback循环轮询数据库更新来实现自动仪表板刷新。dashboard的Docker容器可以在AWS上运行(例如ECS/Fargate，但是由于LocalStack的免费版本不包括这一点，所以它只是在本地运行以供演示)。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="1bdf" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结果</h1><p id="5a0b" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">要从克隆的存储库中本地运行设置，需要安装Docker和Terraform。<br/>尽管性能无法与实际的云服务相提并论，<a class="ae kr" href="https://github.com/localstack/localstack" rel="noopener ugc nofollow" target="_blank"> LocalStack </a>是在本地模拟众多AWS服务的绝佳选择，包括Kinesis、Lambda和DynamoDB。LocalStack可以在Docker容器中启动，根据需要生成更多的容器，例如用于执行Lambdas:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="e4b6" class="nf md iq ns b gy nw nx l ny nz">docker-compose up localstack</span></pre><p id="cc9c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在部署Lambda函数之前，需要打包函数代码及其依赖项:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="0dc0" class="nf md iq ns b gy nw nx l ny nz">docker-compose up package-ingest-lambda package-simulation-lambda</span></pre><p id="ef8f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>是一个伟大而广泛使用的工具，它可以自动提供配置文件中描述的基础设施资源(但是，请看一下<a class="ae kr" href="https://itnext.io/things-i-wish-i-knew-about-terraform-before-jumping-into-it-43ee92a9dd65" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中更细致的分析)。要创建所有需要的资源，需要在相应的目录中使用两个terraform命令:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="3c57" class="nf md iq ns b gy nw nx l ny nz">cd terraform<br/>terraform init # (only required once)<br/>terraform apply<br/># (enter 'yes' when prompted to confirm the changes,<br/># or use -auto-approve)<br/>cd ../ # return to project root</span></pre><p id="c5e5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">(为了防止在没有调用<code class="fe oa ob oc ns b">terraform destroy</code>的情况下重启LocalStack后调用<code class="fe oa ob oc ns b">apply</code>时出现404错误，首先删除<code class="fe oa ob oc ns b">main.tf</code>旁边的<code class="fe oa ob oc ns b">terraform.tfstate</code>文件。)</p><p id="3e58" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">成功创建后，可以启动另外两个容器，一个服务于仪表板，另一个运行模拟模型来模拟真实的事件生成器:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="4ec9" class="nf md iq ns b gy nw nx l ny nz">docker-compose up dashboard emulation</span></pre><p id="aeb3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在(重新)开始任何试运行之前，需要清除DynamoDB表:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="3ba3" class="nf md iq ns b gy nw nx l ny nz">docker-compose up truncate-tables</span></pre><p id="67f4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="http://localhost:8050/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8050 </a>现在应该显示空的仪表板，而<a class="ae kr" href="http://localhost:5001/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5001 </a>应该显示Casymda web canvas动画控件。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="9505" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">样品流</h1><p id="803b" class="pw-post-body-paragraph ks kt iq ku b kv mu jr kx ky mv ju la lb mw ld le lf mx lh li lj my ll lm ln ij bi translated">开始模拟时，订单将在源位置创建，并流经定义的流程。同时，仪表板应稍有延迟地更新，并显示系统(y轴)中当前所有订单的相关流程步骤的完成时间(x轴)。图表中的垂直线表示模拟运行开始和预测创建的时间点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi od"><img src="../Images/9b3a8cbcdfd5107863aa8ad8ad6c6f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-ROp7VXyPZ7dD5hoVqfaPA.gif"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">仿真模型和预测仪表板的截屏</p></figure><p id="8095" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当<em class="lo">订单-2 </em>的预期未来物料交付延迟发生时，会产生一个有趣的情况(橙色):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oe"><img src="../Images/874e21fd6660ad0fc2f0a0f79a3fc7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mzOIp-c4aLpc8tVs.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">订单2的预期物料交付延迟(橙色)对订单3的预测影响(红色)</p></figure><p id="2dc9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">由生产步骤的能力限制引起(最大。一个订单并发)<em class="lo">订单-2 </em>的延迟(橙色)预计也会延迟<em class="lo">订单-3 </em>的开始生产(红色)。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="9b59" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">虽然给出的例子很简单，但是可以想象出很多扩展。从商业角度来看，研究一个更复杂的过程是很有意思的，例如包括原材料库存和不同的补充策略。类似地，可以评估随机或计划的机器维护间隔的影响。这可能还要求自动确定最佳决策备选方案，例如考虑订单特定的到期日或吞吐量目标。有趣的技术扩展可能包括对摄取的事件数据进行初步分析，使用流处理解决方案，如<em class="lo"> AWS Kinesis数据分析</em>，以便识别相关模式并仅在关键流程偏差的情况下触发预测/优化运行。</p></div></div>    
</body>
</html>