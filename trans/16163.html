<html>
<head>
<title>Pipelines &amp; Custom Transformers in Scikit-learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scikit中的管道和定制变压器-了解</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pipelines-custom-transformers-in-scikit-learn-ef792bbb3260?source=collection_archive---------11-----------------------#2020-11-07">https://towardsdatascience.com/pipelines-custom-transformers-in-scikit-learn-ef792bbb3260?source=collection_archive---------11-----------------------#2020-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="12e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">带有代码片段的介绍性说明…</h2></div><p id="c06d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">机器学习学术课程往往几乎只关注模型。有人可能会说，模型是表演魔术的东西。这种说法可能有一定的道理，但这种魔力只有在数据形式正确的情况下才能发挥作用。此外，让事情变得更复杂的是，“正确的形式”取决于模型的类型。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/94e3a09623fe1f0e8b574e83b34b88e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*j1lYjAXlTK0ZpWcDboy_zQ.jpeg"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">演职员表:<a class="ae ln" href="https://www.freepik.com/free-vector/pipeline-brick-wall-background_3834959.htm" rel="noopener ugc nofollow" target="_blank">https://www . free pik . com/free-vector/pipeline-brick-wall-background _ 3834959 . htm</a>(*我更喜欢MarioBros。图片…但是你知道:版权)</p></figure><p id="f878" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以正确的形式获取数据被业界称为预处理。这花费了机器学习从业者大量的时间。对于工程师来说，预处理和拟合或者预处理和预测是两个不同的过程，但是在生产环境中，当我们为模型服务时，没有区别。它只是数据输入，预测输出。管道就是用来做这个的。它们将预处理步骤和拟合或预测集成到单个操作中。除了帮助模型生产就绪，他们还为实验阶段增加了大量的可重复性。</p><h1 id="c651" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">学习目标</h1><ul class=""><li id="dc15" class="mg mh iq kh b ki mi kl mj ko mk ks ml kw mm la mn mo mp mq bi translated">什么是管道</li><li id="75c6" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated">什么是变压器</li><li id="69c6" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated">什么是定制变压器</li></ul><h1 id="e79b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">资源</h1><ul class=""><li id="af5e" class="mg mh iq kh b ki mi kl mj ko mk ks ml kw mm la mn mo mp mq bi translated"><a class="ae ln" rel="noopener" target="_blank" href="/pipelines-custom-transformers-in-scikit-learn-the-step-by-step-guide-with-python-code-4a7d9b068156">管道&amp;sci kit中的自定义变压器-学习:分步指南(带Python代码)</a></li><li id="c0a6" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae ln" rel="noopener" target="_blank" href="/custom-transformers-and-ml-data-pipelines-with-python-20ea2a7adb65">使用Python定制转换器的ML数据管道</a></li><li id="4240" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae ln" href="https://machinelearningmastery.com/how-to-transform-target-variables-for-regression-with-scikit-learn/" rel="noopener ugc nofollow" target="_blank">如何在Python中转换回归的目标变量</a></li><li id="3fa7" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae ln" href="http://zacstewart.com/2014/08/05/pipelines-of-featureunions-of-pipelines.html" rel="noopener ugc nofollow" target="_blank">使用Scikit-learn管道和特征联合</a></li></ul><h1 id="0c59" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">参考</h1><p id="e332" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated"><a class="ae ln" href="https://scikit-learn.org/stable/data_transforms.html" rel="noopener ugc nofollow" target="_blank"> Scikit学习。数据集转换</a></p><p id="d6cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从Scikit学习文档中，我们可以获得:</p><blockquote class="mz na nb"><p id="6ad6" class="kf kg nc kh b ki kj jr kk kl km ju kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">数据集变换…与其他估计器一样，这些估计器由具有拟合方法和变换方法的类表示，拟合方法从训练集中学习模型参数(例如，归一化的均值和标准差)，变换方法将此变换模型应用于看不见的数据。fit_transform可以更方便和有效地同时对训练数据进行建模和转换。</p></blockquote><p id="37d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将重点介绍两种变压器类型，即:</p><ul class=""><li id="211e" class="mg mh iq kh b ki kj kl km ko ng ks nh kw ni la mn mo mp mq bi translated"><a class="ae ln" href="https://scikit-learn.org/stable/modules/preprocessing.html" rel="noopener ugc nofollow" target="_blank">预处理数据</a></li><li id="7346" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae ln" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">缺失值插补</a></li></ul><h1 id="40a0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">定制变压器</h1><p id="9fee" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">虽然Scikit learn附带了一套标准的变压器，但我们将从一个定制的变压器开始，以了解它们的功能和工作原理。首先要记住的是，自定义转换器既是估计器又是转换器，所以我们将创建一个从BaseEstimator和TransformerMixin继承的类。用super()初始化它是一个很好的做法。__init__()。通过继承，我们免费得到了get_params、set_params这样的标准方法。在init中，我们还想创建模型参数或我们想学习的参数。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="e5bd" class="no lp iq nk b gy np nq l nr ns"><strong class="nk ir">class</strong> <strong class="nk ir">CustomScaler</strong>(BaseEstimator, TransformerMixin):<br/>    <strong class="nk ir">def</strong> __init__(self):<br/>        super().__init__()<br/>        self.means_ = <strong class="nk ir">None</strong><br/>        self.std_ = <strong class="nk ir">None</strong><br/><br/>    <strong class="nk ir">def</strong> fit(self, X, y=<strong class="nk ir">None</strong>):<br/>        X = X.to_numpy()<br/>        self.means_ = X.mean(axis=0, keepdims=<strong class="nk ir">True</strong>)<br/>        self.std_ = X.std(axis=0, keepdims=<strong class="nk ir">True</strong>)<br/><br/>        <strong class="nk ir">return</strong> self<br/><br/>    <strong class="nk ir">def</strong> transform(self, X, y=<strong class="nk ir">None</strong>):<br/>        X[:] = (X.to_numpy() - self.means_) / self.std_<br/><br/>        <strong class="nk ir">return</strong> X</span></pre><p id="08f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">fit方法是“学习”发生的地方。这里，我们基于生成模型参数的训练数据来执行操作。</p><p id="7146" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在转换方法中，我们将在fit中学习到的参数应用于看不见的数据。请记住，预处理将成为整个模型的一部分，因此在训练期间，拟合和变换将应用于同一个数据集。但是之后，当您使用经过训练的模型时，您只能根据训练数据集而不是看不见的数据，应用带有通过fit学习的参数的变换方法。</p><p id="e89c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的是，无论要应用的数据是什么，学习到的参数以及变压器的操作都是相同的。</p><h1 id="18e8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">标准变压器</h1><p id="cb82" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">Scikit learn自带各种开箱即用的标准变压器。考虑到它们几乎不可避免的使用，你应该熟悉数字数据的<a class="ae ln" href="https://scikit-learn.org/stable/modules/preprocessing.html#standardization-or-mean-removal-and-variance-scaling" rel="noopener ugc nofollow" target="_blank">标准化，或均值去除和方差缩放</a>和<a class="ae ln" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank">简单估算器</a>，以及分类的<a class="ae ln" href="https://scikit-learn.org/stable/modules/preprocessing.html#encoding-categorical-features" rel="noopener ugc nofollow" target="_blank">编码分类特征</a>，特别是one-of-K，也称为one-hot编码。</p><h1 id="18dc" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">管道</h1><h2 id="f7eb" class="no lp iq bd lq nt nu dn lu nv nw dp ly ko nx ny ma ks nz oa mc kw ob oc me od bi translated">链接估计量</h2><p id="a27b" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">请记住，变压器是一个估计，但你的模型也是(逻辑回归，随机森林等)。).你可以把它想象成台阶垂直堆叠。这里秩序很重要。所以你要把预处理放在模型之前。关键是一步输出是下一步输入。</p><h2 id="3a6b" class="no lp iq bd lq nt nu dn lu nv nw dp ly ko nx ny ma ks nz oa mc kw ob oc me od bi translated">特征联合:复合特征空间</h2><p id="9779" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">通常，您希望对某些要素应用不同的变换。数字数据和分类数据所需的转换是不同的。这就好像你有两条平行的路，或者它们是水平堆叠的。</p><p id="d148" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并行路径的输入是相同的。因此，转换方法必须从选择与转换相关的特征开始(例如，数字特征或分类特征)。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="c9a1" class="lo lp iq bd lq lr ol lt lu lv om lx ly jw on jx ma jz oo ka mc kc op kd me mf bi translated">例子</h1><p id="0bf6" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们将为Kaggle的<a class="ae ln" href="https://www.kaggle.com/c/titanic/data" rel="noopener ugc nofollow" target="_blank">泰坦尼克号数据集</a>做预处理流水线。你可以在这里找到卡格勒斯的教程<a class="ae ln" href="https://www.kaggle.com/alexisbcook/titanic-tutorial" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi oq"><img src="../Images/aaf62dca234d207d0deae6ec2f5c5d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiixxCstvi4B9TyOmLQjEA.png"/></div></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">演职员表:<a class="ae ln" href="https://commons.wikimedia.org/wiki/RMS_Titanic#/media/File:Titanic_in_color.png" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/RMS _ Titanic #/media/File:Titanic _ in _ color . png</a></p></figure><p id="e6ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的工作，您可以遵循下面提供的要点中的步骤(在一个新的选项卡中打开它，然后跟着做)。它包含了所有的代码。为了更好地理解，我们将把它分开。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="b95d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们开始吧。解压文件并加载数据后，进行快速浏览。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="7296" class="no lp iq nk b gy np nq l nr ns"># loading and exploration</span><span id="7d78" class="no lp iq nk b gy ox nq l nr ns">filename = '/content/working_directory/train.csv'<br/>raw_train = pd.read_csv(filename)<br/>print('data set shape: ', raw_train.shape, '<strong class="nk ir">\n</strong>')<br/>print(raw_train.head())</span><span id="86b8" class="no lp iq nk b gy ox nq l nr ns">data set shape:  (891, 12) <br/><br/>   PassengerId  Survived  Pclass  ...     Fare Cabin  Embarked<br/>0            1         0       3  ...   7.2500   NaN         S<br/>1            2         1       1  ...  71.2833   C85         C<br/>2            3         1       3  ...   7.9250   NaN         S<br/>3            4         1       1  ...  53.1000  C123         S<br/>4            5         0       3  ...   8.0500   NaN         S<br/><br/>[5 rows x 12 columns]</span></pre><p id="5ebf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，在删除我们将不使用的功能(乘客Id、姓名、机票、客舱、已登机)并分离标签(幸存)后，六(6)个功能保留下来，即:Pclass、性别、年龄、SibSp、Parch和Fare。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="ab57" class="no lp iq nk b gy np nq l nr ns">dr = ['PassengerId','Name','Ticket','Cabin','Embarked']<br/>train = raw_train.drop(labels = dr, axis = 1)<br/><br/>X = train.drop('Survived', axis=1)<br/>y = train['Survived'].values<br/>print('data set shape: ', X.shape, '<strong class="nk ir">\n</strong>')<br/>print(X.head())<br/>print(X.describe())</span><span id="89a7" class="no lp iq nk b gy ox nq l nr ns">data set shape:  (891, 6) <br/><br/>   Pclass     Sex   Age  SibSp  Parch     Fare<br/>0       3    male  22.0      1      0   7.2500<br/>1       1  female  38.0      1      0  71.2833<br/>2       3  female  26.0      0      0   7.9250<br/>3       1  female  35.0      1      0  53.1000<br/>4       3    male  35.0      0      0   8.0500<br/>           Pclass         Age       SibSp       Parch        Fare<br/>count  891.000000  714.000000  891.000000  891.000000  891.000000<br/>mean     2.308642   29.699118    0.523008    0.381594   32.204208<br/>std      0.836071   14.526497    1.102743    0.806057   49.693429<br/>min      1.000000    0.420000    0.000000    0.000000    0.000000<br/>25%      2.000000   20.125000    0.000000    0.000000    7.910400<br/>50%      3.000000   28.000000    0.000000    0.000000   14.454200<br/>75%      3.000000   38.000000    1.000000    0.000000   31.000000<br/>max      3.000000   80.000000    8.000000    6.000000  512.329200</span></pre><p id="2bc1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，有数字(Pclass '，' Age '，' SibSp '，' Parch '，' Fare ')和分类(Sex ')特征，它们的预处理是不同的。还要注意，并非所有乘客年龄值都可用。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="c1d3" class="no lp iq nk b gy np nq l nr ns"><em class="nc"># count missing values</em><br/>X.isna().sum()</span><span id="276b" class="no lp iq nk b gy ox nq l nr ns">Pclass      0<br/>Sex         0<br/>Age       177<br/>SibSp       0<br/>Parch       0<br/>Fare        0<br/>dtype: int64</span></pre><h2 id="8cef" class="no lp iq bd lq nt nu dn lu nv nw dp ly ko nx ny ma ks nz oa mc kw ob oc me od bi translated">自定义估算器</h2><p id="da60" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">年龄大概是预测存活几率的一个关键因素。因此，为了让模型充分发挥作用，我们需要填充缺失的值。一种替代方法是使用数据集年龄平均值。但是性别、阶级和年龄之间是有关联的。男性比女性年长，而且上层阶级的乘客也比下层阶级的乘客年长。我们可以用它来得出一个比一般平均值更好的重置价值。我们将使用由性别和阶级给出的类别的平均值。请注意，我们使用了两个分类特征(Pclass和Sex)来对点进行分组，以填充数字特征(年龄)的缺失值。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="4f19" class="no lp iq nk b gy np nq l nr ns"><em class="nc"># Custom Transformer that fills missing ages</em><br/><strong class="nk ir">class</strong> <strong class="nk ir">CustomImputer</strong>(BaseEstimator, TransformerMixin):<br/>    <strong class="nk ir">def</strong> __init__(self):<br/>        super().__init__()<br/>        self.age_means_ = {}<br/><br/>    <strong class="nk ir">def</strong> fit(self, X, y=<strong class="nk ir">None</strong>):<br/>        self.age_means_ = X.groupby(['Pclass', 'Sex']).Age.mean()<br/><br/>        <strong class="nk ir">return</strong> self<br/><br/>    <strong class="nk ir">def</strong> transform(self, X, y=<strong class="nk ir">None</strong>):<br/>        <em class="nc"># fill Age</em><br/>        <strong class="nk ir">for</strong> key, value <strong class="nk ir">in</strong> self.age_means_.items():<br/>            X.loc[((np.isnan(X["Age"])) &amp; (X.Pclass == key[0]) &amp; (X.Sex == key[1])), 'Age'] = value<br/><br/>        <strong class="nk ir">return</strong> X</span></pre><h1 id="8685" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">数字特征流水线</h1><p id="594e" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">选择适当的特性后，我们将执行一个简单的估算器和一个标准缩放器。前面介绍的CustomScaler与预构建的Scikit-learn StandardScaler执行相同的操作。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="fc7a" class="no lp iq nk b gy np nq l nr ns"><strong class="nk ir">class</strong> <strong class="nk ir">NumericalTransformer</strong>(BaseEstimator, TransformerMixin):<br/>    <strong class="nk ir">def</strong> __init__(self):<br/>        super().__init__()<br/><br/>    <strong class="nk ir">def</strong> fit(self, X, y=<strong class="nk ir">None</strong>):<br/>        <strong class="nk ir">return</strong> self<br/><br/>    <strong class="nk ir">def</strong> transform(self, X, y=<strong class="nk ir">None</strong>):<br/>        <em class="nc"># Numerical features to pass down the numerical pipeline</em><br/>        X = X[['Pclass', 'Age', 'SibSp', 'Parch', 'Fare']]<br/>        X = X.replace([np.inf, -np.inf], np.nan)<br/>        <strong class="nk ir">return</strong> X.values</span><span id="e5ad" class="no lp iq nk b gy ox nq l nr ns"><em class="nc"># Defining the steps in the numerical pipeline</em><br/>numerical_pipeline = Pipeline(steps=[<br/>    ('num_transformer', NumericalTransformer()),<br/>    ('imputer', SimpleImputer(strategy='median')),<br/>    ('std_scaler', StandardScaler())])</span></pre><h1 id="0cfe" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">分类特征管道</h1><p id="bd25" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">在选择适当的特性(性别)后，我们将通过预构建的转换OneHotEncoder执行热编码。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="8201" class="no lp iq nk b gy np nq l nr ns"><strong class="nk ir">class</strong> <strong class="nk ir">CategoricalTransformer</strong>(BaseEstimator, TransformerMixin):<br/>    <strong class="nk ir">def</strong> __init__(self):<br/>        super().__init__()<br/><br/>    <em class="nc"># Return self nothing else to do here</em><br/>    <strong class="nk ir">def</strong> fit(self, X, y=<strong class="nk ir">None</strong>):<br/>        <strong class="nk ir">return</strong> self<br/><br/>    <em class="nc"># Helper function that converts values to Binary depending on input</em><br/>    <strong class="nk ir">def</strong> create_binary(self, obj):<br/>        <strong class="nk ir">if</strong> obj == 0:<br/>            <strong class="nk ir">return</strong> 'No'<br/>        <strong class="nk ir">else</strong>:<br/>            <strong class="nk ir">return</strong> 'Yes'<br/><br/>    <em class="nc"># Transformer method for this transformer</em><br/>    <strong class="nk ir">def</strong> transform(self, X, y=<strong class="nk ir">None</strong>):<br/>        <em class="nc"># Categorical features to pass down the categorical pipeline</em><br/>        <strong class="nk ir">return</strong> X[['Sex']].values</span><span id="5d37" class="no lp iq nk b gy ox nq l nr ns"><em class="nc"># Defining the steps in the categorical pipeline</em><br/>categorical_pipeline = Pipeline(steps=[<br/>    ('cat_transformer', CategoricalTransformer()),<br/>    ('one_hot_encoder', OneHotEncoder(sparse=<strong class="nk ir">False</strong>))])</span></pre><h1 id="9432" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">水平堆叠</h1><p id="2df5" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">分类管道和数字管道并行但独立运行。它们有相同的输入，但产生独立的输出，我们将重新连接这些输出。为了重新加入它们，我们使用FeatureUnion。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="b85d" class="no lp iq nk b gy np nq l nr ns"><em class="nc"># Combining numerical and categorical pipeline into one full big pipeline horizontally</em><br/><em class="nc"># using FeatureUnion</em><br/>union_pipeline = FeatureUnion(transformer_list=[<br/>    ('categorical_pipeline', categorical_pipeline),<br/>    ('numerical_pipeline', numerical_pipeline)])</span></pre><h1 id="51a0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">垂直堆叠</h1><p id="fd43" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">因为我们需要自定义估算器的分类和数字特征(我们在其中填充缺失的年龄值)，所以它出现在并行管道之前，现在一起作为预处理管道。为此，我们使用Scikit Learn的管道。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="7ab6" class="no lp iq nk b gy np nq l nr ns"><em class="nc"># Combining the custom imputer with the categorical and numerical pipeline</em><br/>preprocess_pipeline = Pipeline(steps=[('custom_imputer', CustomImputer()),<br/>                                      ('full_pipeline', union_pipeline)])</span></pre><h1 id="66c7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">模型</h1><p id="100b" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我们将使用Scikit Learn的决策树分类器。这里的重点不是模型，而是查看转换和管道运行的借口。DecisionTreeClassifier是我们在预处理管道之后堆叠的另一个估计器。</p><p id="5a7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了查看所有正在进行的操作，我们将在full_pipeline上调用fit，即预处理和建模，以及稍后的预测。</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="0de0" class="no lp iq nk b gy np nq l nr ns"><em class="nc"># MODEL</em><br/><strong class="nk ir">from</strong> <strong class="nk ir">sklearn</strong> <strong class="nk ir">import</strong> tree<br/><br/><em class="nc"># Decision Tree</em><br/>decision_tree = tree.DecisionTreeClassifier()</span><span id="db1b" class="no lp iq nk b gy ox nq l nr ns"><em class="nc"># define full pipeline --&gt; preprocessing + model</em><br/>full_pipeline = Pipeline(steps=[<br/>    ('preprocess_pipeline', preprocess_pipeline),<br/>    ('model', decision_tree)])<br/><br/><em class="nc"># fit on the complete pipeline</em><br/>training = full_pipeline.fit(X, y)<br/>print(full_pipeline.get_params())<br/><br/><em class="nc"># metrics</em><br/>score_test = \<br/>    round(training.score(X, y) * 100, 2)<br/>print(f"<strong class="nk ir">\n</strong>Training Accuracy: <strong class="nk ir">{</strong>score_test<strong class="nk ir">}</strong>")</span></pre><p id="a4fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后是预测部分:</p><pre class="lc ld le lf gt nj nk nl nm aw nn bi"><span id="004a" class="no lp iq nk b gy np nq l nr ns"><em class="nc"># Prediction</em><br/><br/>my_data = X.iloc[[77]]<br/>y = full_pipeline.predict(my_data)<br/>print(my_data, y)</span><span id="05f4" class="no lp iq nk b gy ox nq l nr ns">Pclass   Sex       Age  SibSp  Parch  Fare<br/>77       3  male -0.211777      0      0  8.05 [0]</span></pre><h1 id="0a77" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">关闭</h1><p id="1d68" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">这个非常简短的关于Scikit learn的转换和管道的叙述，应该已经为您提供了以生产就绪和可重复的方式集成机器学习模型中的预处理阶段的工具。希望你喜欢。编码快乐！</p></div></div>    
</body>
</html>