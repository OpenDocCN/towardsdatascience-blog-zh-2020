<html>
<head>
<title>Compression, search, interpolation, and clustering of images using machine learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习对图像进行压缩、搜索、插值和聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/compression-search-interpolation-and-clustering-of-images-using-machine-learning-eb65fcf0abbb?source=collection_archive---------21-----------------------#2020-10-24">https://towardsdatascience.com/compression-search-interpolation-and-clustering-of-images-using-machine-learning-eb65fcf0abbb?source=collection_archive---------21-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3f83" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用图像嵌入进行压缩、搜索、插值和聚类</h2></div><p id="e9ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">机器学习中的嵌入提供了一种创建复杂、非结构化数据的简明、低维表示的方法。自然语言处理中通常使用嵌入来将单词或句子表示为数字。</p><p id="d471" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在之前的一篇文章中，我展示了如何创建一个1059x1799 HRRR图像的简洁表示(50个数字)。在本文中，我将向您展示嵌入有一些很好的属性，您可以利用这些属性来实现用例，如压缩、图像搜索、插值和大型图像数据集的聚类。</p><h2 id="efff" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">压缩</h2><p id="4d60" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">首先，嵌入是否捕捉到了图像中的重要信息？我们能把嵌入的图像解码成原始图像吗？</p><p id="749a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，我们将无法恢复原始图像，因为我们获取了200万像素的值，并将它们放入一个长度=50的向量中。尽管如此，嵌入是否捕捉到了天气预报图像中的重要信息？</p><p id="f5d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是世界协调时2019年9月20日05:00 HRRR的原始预报:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/b138fb0fcd3c5b69a606108ddab2f338.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*QF2TLbKMGJvtWp7Z7A9zKQ.png"/></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">2019年9月20日天气</p></figure><p id="262d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以获得时间戳的嵌入并如下解码(<a class="ae lb" href="https://github.com/GoogleCloudPlatform/ml-design-patterns/blob/master/02_data_representation/weather_search/wx_embeddings.ipynb" rel="noopener ugc nofollow" target="_blank">完整代码在GitHub </a>上)。首先，我们通过加载SavedModel、找到嵌入层并重建所有后续层来创建解码器:</p><pre class="mb mc md me gt mm mn mo mp aw mq bi"><span id="d4af" class="lc ld iq mn b gy mr ms l mt mu">import tensorflow as tf<br/>def create_decoder(model_dir):<br/>    model = tf.keras.models.load_model(model_dir)<br/>    decoder_input = tf.keras.Input([50], name='embed_input')<br/>    embed_seen = False<br/>    x = decoder_input<br/>    for layer in model.layers:<br/>        if embed_seen:<br/>            x = layer(x)<br/>        elif layer.name == 'refc_embedding':<br/>            embed_seen = True<br/>    decoder = tf.keras.Model(decoder_input, x, name='decoder')<br/>    print(decoder.summary())<br/>    return decoder</span><span id="fc9b" class="lc ld iq mn b gy mv ms l mt mu">decoder = create_decoder('gs://ai-analytics-solutions-kfpdemo/wxsearch/trained/savedmodel')</span></pre><p id="d038" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了解码器，我们就可以从BigQuery中提取时间戳的嵌入:</p><pre class="mb mc md me gt mm mn mo mp aw mq bi"><span id="a479" class="lc ld iq mn b gy mr ms l mt mu">SELECT *<br/>FROM advdata.wxembed</span></pre><p id="2920" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这给了我们一个这样的表格:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/1ff69c5677b9def5a287dc153f62b119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Du8YRgk4bdTlPPcD8iyPUg.png"/></div></div></figure><p id="8901" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以将上表中的“ref”值传递给解码器:</p><pre class="mb mc md me gt mm mn mo mp aw mq bi"><span id="b1b2" class="lc ld iq mn b gy mr ms l mt mu">import tensorflow as tf<br/>import numpy as np<br/>embed = tf.reshape( tf.convert_to_tensor(df['ref'].values[0], <br/>                     dtype=tf.float32), [-1, 50])<br/>outimg = decoder.predict(embed).squeeze() * 60<br/>plt.imshow(outimg, origin='lower');</span></pre><p id="06ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，TensorFlow希望看到一批输入，因为我们只传入一个，所以我必须将其重新整形为[1，50]。类似地，TensorFlow返回一批图像。我在显示它之前挤压它(删除虚拟尺寸)。结果呢？</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nb"><img src="../Images/d0078cdb9c759d6f31e18974ab12d3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*m5bjhDt8z6lAdZRMmGDKpw.png"/></div></div></figure><p id="f784" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，解码图像是原始HRRR的模糊版本。嵌入确实保留了密钥信息。它起到压缩算法的作用。</p><h2 id="d5df" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">搜索</h2><p id="b0e2" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果嵌入是一个压缩的表示，嵌入空间的分离程度会转化为实际预测图像的分离程度吗？</p><p id="a22c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是这种情况，搜索过去与现在的一些情况“相似”的天气情况就变得容易了。在200万像素的图像上寻找相似物可能会很困难，因为风暴可能会略有不同，或者大小有所不同。</p><p id="0b21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们在BigQuery中有嵌入，所以让我们使用SQL来搜索类似于2019年9月20日05:00 UTC:</p><pre class="mb mc md me gt mm mn mo mp aw mq bi"><span id="f715" class="lc ld iq mn b gy mr ms l mt mu">WITH ref1 AS (<br/>SELECT time AS ref1_time, ref1_value, ref1_offset<br/>FROM `ai-analytics-solutions.advdata.wxembed`,<br/>     UNNEST(ref) AS ref1_value WITH OFFSET AS ref1_offset<br/>WHERE time = '2019-09-20 05:00:00 UTC'<br/>)</span><span id="46e3" class="lc ld iq mn b gy mv ms l mt mu">SELECT <br/>  time,<br/>  <strong class="mn ir">SUM( (ref1_value - ref[OFFSET(ref1_offset)]) * (ref1_value - ref[OFFSET(ref1_offset)]) ) AS sqdist </strong><br/>FROM ref1, `ai-analytics-solutions.advdata.wxembed`<br/>GROUP BY 1<br/>ORDER By sqdist ASC<br/>LIMIT 5</span></pre><p id="e46d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，我们计算在指定时间戳(refl1)的嵌入和每隔一个嵌入之间的欧几里德距离，并显示最接近的匹配。结果是:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/93bcbe2fc38ffb4d7c6614b8fd8d58d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*iqeXrlwPAGvJFv6m4JMz0A.png"/></div></figure><p id="409d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很有道理。前一小时/后一小时的图像最相似。然后，从+/- 2小时开始的图像等等。</p><p id="3306" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想找到不在+/- 1天内的最相似的图像呢？由于我们只有1年的数据，我们不打算进行大的类比，但让我们看看我们得到了什么:</p><pre class="mb mc md me gt mm mn mo mp aw mq bi"><span id="35d9" class="lc ld iq mn b gy mr ms l mt mu">WITH ref1 AS (<br/>SELECT time AS ref1_time, ref1_value, ref1_offset<br/>FROM `ai-analytics-solutions.advdata.wxembed`,<br/>     UNNEST(ref) AS ref1_value WITH OFFSET AS ref1_offset<br/>WHERE time = '2019-09-20 05:00:00 UTC'<br/>)</span><span id="1955" class="lc ld iq mn b gy mv ms l mt mu">SELECT <br/>  time,<br/>  SUM( (ref1_value - ref[OFFSET(ref1_offset)]) * (ref1_value - ref[OFFSET(ref1_offset)]) ) AS sqdist <br/>FROM ref1, `ai-analytics-solutions.advdata.wxembed`<br/><strong class="mn ir">WHERE time NOT BETWEEN '2019-09-19' AND '2019-09-21'</strong><br/>GROUP BY 1<br/>ORDER By sqdist ASC<br/>LIMIT 5</span></pre><p id="f2f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果有点出人意料:1月2日和7月1日是天气最相似的日子；</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3888061e6165bf13a9031fb69247eeb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*tFS24TO__Kfq_yzbIZAu4Q.png"/></div></figure><p id="49f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，让我们来看看这两个时间戳:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/4af9e135827bb53e0a1be1cdeb4a4e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*kq1XsZRBOh5HXTp2mLmpNA.png"/></div></figure><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/aba9af7c962ebf655ca7225eba0ee52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*mnfSOT7PUKlj9RaO_myzVA.png"/></div></figure><p id="30af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到9月20日的图像确实落在这两张图像之间。两张图片中都有墨西哥湾沿岸和中西部北部的天气情况。就像9月20日的照片一样。</p><p id="01f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有(a)不止一年的数据,( b)在多个时间步加载HRRR预报图像，而不仅仅是分析场，以及(c)使用更小的切片来捕捉中尺度现象，我们可能会得到更有意义的搜索。这是留给感兴趣的气象学学生的练习</p><h2 id="4632" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">插入文字</h2><p id="e74e" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">回想一下，当我们寻找与05:00的图像最相似的图像时，我们得到了06:00和04:00的图像，然后是07:00和03:00的图像。在嵌入空间中，到下一个小时的距离大约为sqrt(0.5)。</p><p id="050e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定搜索用例中的这种行为，一个自然的问题是我们是否可以使用嵌入在天气预报之间进行插值。我们能对t-1和t+1的嵌入进行平均以得到t=0的嵌入吗？有什么错误？</p><pre class="mb mc md me gt mm mn mo mp aw mq bi"><span id="63e9" class="lc ld iq mn b gy mr ms l mt mu">WITH refl1 AS (<br/>SELECT ref1_value, idx<br/>FROM `ai-analytics-solutions.advdata.wxembed`,<br/>     UNNEST(ref) AS ref1_value WITH OFFSET AS idx<br/>WHERE time = '2019-09-20 05:00:00 UTC'<br/>),</span><span id="5ff9" class="lc ld iq mn b gy mv ms l mt mu">...</span><span id="42b2" class="lc ld iq mn b gy mv ms l mt mu">SELECT SUM( (ref2_value - (ref1_value + ref3_value)/2) * (ref2_value - (ref1_value + ref3_value)/2) ) AS sqdist<br/>FROM refl1<br/>JOIN refl2 USING (idx)<br/>JOIN refl3 USING (idx)</span></pre><p id="9003" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果呢？sqrt(0.1)，比sqrt(0.5)少很多。换句话说，嵌入确实起到了方便的插值算法的作用。</p><p id="a37c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ne">为了将嵌入作为一种有用的插值算法，我们需要用远远超过50个像素的像素来表示图像。丢失的信息不可能这么高。同样，这是留给感兴趣的气象学家的练习。</em></p><h2 id="536d" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使聚集</h2><p id="48c6" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">鉴于嵌入在可交换性和可加性方面看起来工作得非常好，我们应该期望能够对嵌入进行聚类。</p><p id="948c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用K-Means算法，要求五个聚类:</p><pre class="mb mc md me gt mm mn mo mp aw mq bi"><span id="4d70" class="lc ld iq mn b gy mr ms l mt mu">CREATE OR REPLACE MODEL advdata.hrrr_clusters<br/>OPTIONS(model_type='kmeans', num_clusters=5, KMEANS_INIT_METHOD='KMEANS++')<br/>AS</span><span id="ef4a" class="lc ld iq mn b gy mv ms l mt mu">SELECT arr_to_input(ref) AS ref<br/>FROM `ai-analytics-solutions.advdata.wxembed`</span></pre><p id="bb1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成的质心形成一个50元素的数组:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/17882ca07c82d9368995177682854773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*yhd0X_EEnEWSMVGfelF1eg.png"/></div></figure><p id="2c05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以继续绘制五个质心的解码版本:</p><pre class="mb mc md me gt mm mn mo mp aw mq bi"><span id="4317" class="lc ld iq mn b gy mr ms l mt mu">for cid in range(1,6):<br/>    <strong class="mn ir">embed = df[df['centroid_id']==cid].sort_values(by='feature')['numerical_value'].values</strong><br/>    embed = tf.reshape( tf.convert_to_tensor(embed, dtype=tf.float32), [-1, 50])<br/>    outimg = decoder.predict(embed).squeeze() * 60<br/>    axarr[ (cid-1)//2, (cid-1)%2].imshow(outimg, origin='lower');<br/>12.15992</span></pre><p id="0166" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是5个群集的结果形心:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ng"><img src="../Images/009efe36c44ab6da5c5108f27af2eb28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8EwGLHfBbqgeCSHJoCbcQ.png"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated">当嵌入被聚类成5个簇时，这些是质心</p></figure><p id="1d46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个好像是你们班中西部风暴。第二个是芝加哥-克利夫兰走廊和东南部的大范围天气。第三个是第二个的强大变体。第四个是穿越阿巴拉契亚山脉的飑线。第五是内陆晴朗的天空，但是沿海的天气。</p><p id="6039" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ne">为了将聚类用作有用的预测辅助工具，您可能想要对更小的切片进行聚类，可能是500公里x 500km公里的切片，而不是整个美国。</em></p><p id="6903" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在所有五个集群中，西雅图下雨，加利福尼亚阳光明媚。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f434f4db4577c98faeb8e936c1faaecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*BC9gS16jDW98rMWRW4fQsQ.jpeg"/></div></figure><h2 id="4c37" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">后续步骤:</h2><ol class=""><li id="a015" class="ni nj iq kh b ki lv kl lw ko nk ks nl kw nm la nn no np nq bi translated">仔细阅读GitHub 上的<a class="ae lb" href="https://github.com/GoogleCloudPlatform/ml-design-patterns/blob/master/02_data_representation/weather_search/wx_embeddings.ipynb" rel="noopener ugc nofollow" target="_blank">完整代码</a></li><li id="dbe3" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">阅读前两篇文章。一个是关于如何<a class="ae lb" rel="noopener" target="_blank" href="/how-to-convert-binary-files-into-tensorflow-records-3150d7236341">将HRRR文件转换成张量流记录</a>，另一个是关于<a class="ae lb" rel="noopener" target="_blank" href="/how-to-create-a-concise-image-representation-using-machine-learning-20156c1e0c19">如何使用自动编码器</a>来创建HRRR分析图像的嵌入。</li><li id="2384" class="ni nj iq kh b ki nr kl ns ko nt ks nu kw nv la nn no np nq bi translated">我在华盛顿大学的科学研究所做了一个关于这个话题的演讲。看YouTube上的演讲:</li></ol><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div></div>    
</body>
</html>