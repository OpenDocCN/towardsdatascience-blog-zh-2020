<html>
<head>
<title>Clear Understanding of Depth-First Search Algorithm and Its Python Implementation: Graph Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清晰理解深度优先搜索算法及其Python实现:图算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clear-understanding-of-depth-first-search-algorithm-and-its-python-implementation-graph-algorithm-3e87d8f1a9ea?source=collection_archive---------33-----------------------#2020-11-02">https://towardsdatascience.com/clear-understanding-of-depth-first-search-algorithm-and-its-python-implementation-graph-algorithm-3e87d8f1a9ea?source=collection_archive---------33-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/06254a9712ae96cb660ceaf7bf9303d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1wcT82PuZv7PLyqD"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@brock222?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">李灿明</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><div class=""/><div class=""><h2 id="5062" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">借助清晰的视觉效果进行学习。还要学习人们在深度优先搜索算法中常犯的一个错误</h2></div><blockquote class="ky kz la"><p id="1332" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jk">什么是深度优先搜索？</strong></p></blockquote><p id="2a97" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这是广泛使用和非常流行的图搜索算法之一。为了理解这个算法，想象一个迷宫。当我们必须解决一个迷宫的时候我们做什么？我们走一条路，一直走，直到我们找到一个死胡同。在到达死胡同后，我们会原路返回，继续前进，直到我们看到一条我们以前没有尝试过的路。走那条新路线。再次继续前进，直到我们找到一个死胡同。再走一次原路…</p><p id="9100" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">深度优先搜索几乎以同样的方式工作。使用这种回溯过程。从起点开始，它一直走，直到再也找不到可以走的路。然后沿原路返回，回到有未探索路径的点。它一直这样做，直到遍历完所有的节点和边。</p><p id="31f3" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这是我介绍深度优先搜索的最简单的方法。稍后我会更详细地解释它。</p><blockquote class="ky kz la"><p id="f84f" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jk">为什么深度搜索很重要</strong></p></blockquote><p id="88fe" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">深度优先搜索有广泛的使用案例。</p><ol class=""><li id="bcb2" class="mb mc jj le b lf lg li lj ly md lz me ma mf lx mg mh mi mj bi translated">解决我上面描述的迷宫或难题</li><li id="9b63" class="mb mc jj le b lf mk li ml ly mm lz mn ma mo lx mg mh mi mj bi translated">安排问题</li><li id="9358" class="mb mc jj le b lf mk li ml ly mm lz mn ma mo lx mg mh mi mj bi translated">图中的循环检测</li><li id="b93a" class="mb mc jj le b lf mk li ml ly mm lz mn ma mo lx mg mh mi mj bi translated">网络分析</li><li id="1a92" class="mb mc jj le b lf mk li ml ly mm lz mn ma mo lx mg mh mi mj bi translated">映射路线</li><li id="40b2" class="mb mc jj le b lf mk li ml ly mm lz mn ma mo lx mg mh mi mj bi translated">拓扑排序</li></ol><p id="85e9" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">还有很多。深度优先搜索也是许多其他复杂算法的基础。</p><blockquote class="ky kz la"><p id="affc" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jk">深度优先搜索如何工作？</strong></p></blockquote><p id="e913" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在本节中，我们将直观地看到深度优先搜索的工作流程。这是一个图，源节点显示为节点u。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mp"><img src="../Images/42d9758419b7a8e3343cd4925085f6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/0*IB272sYawzRdBnLn.png"/></div></div></figure><p id="9af2" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我们可以从u到节点v或x，我们可以去任何方向。我选择去v，从图中可以清楚的看到，从v出来的路由只有一条，那就是y。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/5a59d762cb8cd98d0be1c2d19528f4c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/0*QrboGWRzFL4LxXD1.png"/></div></figure><p id="cd5f" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">从图中可以清楚地看到，只有一条从v发出的路由，即y。因此，我们现在位于y中。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/385e6b267b2bb6fb939cc151b802ec2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/0*f4Om4XrkMFhgfaYQ.png"/></div></figure><p id="46af" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">和以前一样，从y也有一个输出路径。那是到x，所以，我们必须到x，那是唯一的选择。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/73524b13cf35fdd93ec54ad15c06200d.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/0*PYuvgSmeZcndm9hc.png"/></div></figure><p id="0010" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">看，我们被困住了！如前所述，在这种情况下，我们采取回溯。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/8c3176090ee82164f3924f1d8d27960e.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/0*aQ4-V8eaN-trTkB9.png"/></div></figure><p id="3a14" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">通过回溯，我们回到了y。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/b6222baf942c1c0dd3427a998931c672.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/0*L0fy2R8k4YrBGO1Y.png"/></div></figure><p id="e91c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">从这里没有路可走。所以，我们再回溯一下。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/978ab93ac950d1b11c4b0001a9f250d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/0*XHtkEJW7YSWWt19u.png"/></div></figure><p id="db79" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">现在，我们在v. Explore v .中，但是没有从v .再次传出的路径。所以再退一步。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/edc97229fd8e2c3007c1d046dc92a57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/0*M8wLTVKi7MSL9-xD.png"/></div></figure><p id="eab2" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我们又回到了一步，那就是我们的源节点u。</p><p id="3c35" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这里我们可以看到有一条我们没有探索过的外出路径。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/f01a2d204d0c105a4b338022a51a75b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/0*_yX6LoiwAGwOu3HK.png"/></div></figure><p id="34e6" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我们从u到x，看到x已经被访问过了。这种类型的边缘被称为前沿。从x到v也有一条路径。节点v也被访问，v是x的祖先。因此<strong class="le jk">这条路径被称为后边缘。</strong></p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/2b870a1ff948a05a87efb64f4117dc6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/0*JA8S1ZeK-SrtGFiL.png"/></div></figure><p id="9891" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我们完成了“uvyx”圆中的所有节点和边。这里我们探索一个新的节点w。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/977242f706aa777869adcfe58e2f9a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/0*r6fxErCIYUzpfzCI.png"/></div></figure><p id="3cb1" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">从w出发，我们可以去z或者y，我现在选择去z。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8c579c02fc67182b78c78527c247d5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/0*JDqYfswW3hMMNAW_.png"/></div></figure><p id="7708" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">注意，z使用<strong class="le jk">后沿</strong>返回z。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/cea4f9fd851ad47ab37b2efe8e041e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*ivddi15FPFIL68ys.png"/></div></figure><p id="cb0e" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">从z处无处可去，所以我们再次回溯，回到w处，w有一条未探索的边通向y。</p><p id="adb0" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><strong class="le jk">这种类型的连接边称为交叉边。</strong></p><p id="3dd3" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">旅行结束了。我们走遍了所有的节点和边缘。</p><blockquote class="ky kz la"><p id="5010" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jk">开发深度第五搜索算法</strong></p></blockquote><p id="c4ee" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在开发算法之前，将上图表示为邻接表是很重要的。如果你以前没有见过邻接表，它就是一本字典。其中，每个节点都是一个键，并且在该键中用传出路径链接的节点都是列表中的值。</p><p id="7e98" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">看下面的邻接表。节点‘u’有两条到节点‘v’和节点‘x’的输出链路。因此，“u”是键，一个包含元素“v”和“x”的列表是值。同样，我们必须每隔一个节点做一个键值对。</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="e57a" class="ne nf jj na b gy ng nh l ni nj">g = {<br/>    'u': ['v', 'x'],<br/>    'v': ['y'],<br/>    'y': ['x'],<br/>    'x': ['v'],<br/>    'w': ['y', 'z'],<br/>    'z': ['z']<br/>    }</span></pre><p id="869c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">邻接表准备好了。</p><p id="5695" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我将使用递归方法来开发深度优先搜索算法。</p><p id="d997" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这个想法是遍历所有的节点和顶点，就像我们在上一节的图片中遍历的那样。为了跟踪被访问的节点，我们将从一个空列表开始。</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="42ea" class="ne nf jj na b gy ng nh l ni nj">class depth_first:<br/>    def __init__(self):<br/>        self.visited = []</span></pre><p id="8398" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">现在定义一个循环遍历所有节点的函数，如果有一个未被访问的节点，我们将进入那个节点，找出这个节点将我们带到哪里。</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="d028" class="ne nf jj na b gy ng nh l ni nj">def dfs(self, graph):        <br/>    for ver in graph:<br/>        if ver not in self.visited:<br/>            self.dfs_visit(graph, ver)<br/>    return self.visited</span></pre><p id="8d09" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">注意，在这个函数中，我们调用了一个函数“dfs_visit”。该函数应该遍历由未访问节点提供的整个未访问路线，并将这些未访问节点添加到“已访问”列表中。我们将递归地实现这个函数。</p><p id="448f" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">以下是“dfs_visit”函数:</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="1590" class="ne nf jj na b gy ng nh l ni nj">def dfs_visit(self, graph, vertex):<br/>    if vertex not in self.visited:<br/>        self.visited.append(vertex)<br/>        for nb in g[vertex]:<br/>            self.dfs_visit(g, nb)</span></pre><p id="3ffd" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">仔细看看！如果节点不在“已访问”列表中，此函数将添加一个节点。然后它会转到与其相邻的一个节点并调用自己。</p><p id="9050" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这样，它将遍历以前没有访问过的整个路线，一次一个。</p><p id="edcc" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">以下是完整的代码:</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="7e8f" class="ne nf jj na b gy ng nh l ni nj">class depth_first:<br/>    def __init__(self):<br/>        self.visited = []    def dfs(self, graph):<br/>        for ver in graph:<br/>            if ver not in self.visited:<br/>                self.dfs_visit(graph, ver)<br/>        return self.visited<br/>    <br/>    def dfs_visit(self, graph, vertex):<br/>        if vertex not in self.visited:<br/>            self.visited.append(vertex)<br/>            for nb in g[vertex]:<br/>                self.dfs_visit(g, nb)</span></pre><p id="1c81" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">现在让我们用之前描述的邻接表来测试一下。</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="ee74" class="ne nf jj na b gy ng nh l ni nj">d = depth_first()<br/>print(d.dfs(g))</span></pre><p id="5b60" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">输出:</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="0562" class="ne nf jj na b gy ng nh l ni nj">['u', 'v', 'y', 'x', 'w', 'z']</span></pre><p id="0c69" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">看，节点的顺序和我们预想的一样！</p><blockquote class="ky kz la"><p id="914e" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jk">人们在DFS算法中常犯的错误</strong></p></blockquote><p id="fb1d" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我看到许多其他网站和博客解释了深度优先搜索算法。但是他们使用的代码是这样的:</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="eefa" class="ne nf jj na b gy ng nh l ni nj">def dfs(graph, vertex, path=[]):<br/>    path += [vertex]    for n in graph[vertex]:<br/>        if n not in path:<br/>            path = dfs(graph, n, path)<br/>    return path</span></pre><p id="8748" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">如果你注意到，它没有通过顶点循环。它从源节点开始，并不断遍历相邻节点。它将在一个图上工作，其中每个节点都有一个连接回任何其他被访问节点的传出节点。</p><p id="f804" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">但是在我们正在处理的图中，节点“y”没有到“w”的输出链接，这种算法将不起作用。因为它永远不会到达w。</p><p id="9dc0" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">让我们检查一下</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="cc9f" class="ne nf jj na b gy ng nh l ni nj">print(dfs(g, 'u'))</span></pre><p id="c0eb" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">输出:</p><pre class="mq mr ms mt gt mz na nb nc aw nd bi"><span id="05fa" class="ne nf jj na b gy ng nh l ni nj">['u', 'v', 'y', 'x']</span></pre><p id="a6a4" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">看，它看不到节点“w”和“z”。</p><blockquote class="ky kz la"><p id="4f6f" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jk">结论</strong></p></blockquote><p id="630d" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我想尽可能清楚地介绍和解释深度优先搜索的工作过程以及如何开发该算法。希望现在对你来说很容易。</p><p id="7d2e" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">欢迎在<a class="ae jg" href="https://twitter.com/rashida048" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，并喜欢我的<a class="ae jg" href="https://www.facebook.com/rashida.smith.161" rel="noopener ugc nofollow" target="_blank">脸书</a>页面。</p><blockquote class="ky kz la"><p id="70f7" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le jk">更多阅读</strong></p></blockquote><div class="is it gp gr iu nk"><a rel="noopener follow" target="_blank" href="/a-complete-guide-to-hypothesis-testing-for-data-scientists-using-python-69f670e6779e"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd jk gy z fp np fr fs nq fu fw ji bi translated">数据科学家使用Python进行假设检验的完整指南</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">用样本研究问题、解决步骤和完整代码清楚地解释</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ja nk"/></div></div></a></div><div class="is it gp gr iu nk"><a rel="noopener follow" target="_blank" href="/a-complete-anomaly-detection-algorithm-from-scratch-in-python-step-by-step-guide-e1daf870336e"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd jk gy z fp np fr fs nq fu fw ji bi translated">Python中从头开始的完整异常检测算法:分步指南</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">基于概率的异常检测算法</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny ja nk"/></div></div></a></div><div class="is it gp gr iu nk"><a rel="noopener follow" target="_blank" href="/an-ultimate-cheat-sheet-for-data-visualization-in-pandas-4010e1b16b5c"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd jk gy z fp np fr fs nq fu fw ji bi translated">熊猫数据可视化的终极备忘单</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">熊猫所有的基本视觉类型和一些非常高级的视觉…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny ja nk"/></div></div></a></div><div class="is it gp gr iu nk"><a rel="noopener follow" target="_blank" href="/multiclass-classification-algorithm-from-scratch-with-a-project-in-python-step-by-step-guide-485a83c79992"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd jk gy z fp np fr fs nq fu fw ji bi translated">使用Python从零开始的多类分类算法:分步指南</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">本文介绍两种方法:梯度下降法和优化函数法</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="ob l nv nw nx nt ny ja nk"/></div></div></a></div><div class="is it gp gr iu nk"><a rel="noopener follow" target="_blank" href="/want-to-become-a-data-scientist-in-12-weeks-3926d8eacee2"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd jk gy z fp np fr fs nq fu fw ji bi translated">想在12周内成为数据科学家？</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">花钱前再想一想</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="oc l nv nw nx nt ny ja nk"/></div></div></a></div><div class="is it gp gr iu nk"><a rel="noopener follow" target="_blank" href="/great-quality-free-courses-to-learn-machine-learning-and-deep-learning-1029048fd0fc"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd jk gy z fp np fr fs nq fu fw ji bi translated">学习机器学习和深度学习的优质免费课程</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">顶级大学高质量免费课程的链接</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="od l nv nw nx nt ny ja nk"/></div></div></a></div></div></div>    
</body>
</html>