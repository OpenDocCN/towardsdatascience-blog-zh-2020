<html>
<head>
<title>Build a LIME explainer dashboard with the fewest lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用最少的代码行构建一个LIME explainer仪表板</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-lime-explainer-dashboard-with-the-fewest-lines-of-code-bfe12e4592d4?source=collection_archive---------13-----------------------#2020-10-24">https://towardsdatascience.com/build-a-lime-explainer-dashboard-with-the-fewest-lines-of-code-bfe12e4592d4?source=collection_archive---------13-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="5c10" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="597f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Flask、Plotly Dash和Streamlit的比较，以构建仪表板，为分类结果提供石灰解释</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/aecf60ed83170799ba406347b26147fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rPfZH7ku8Yrp4yUe.jpg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来源:<a class="ae le" href="https://pixabay.com/photos/doors-choices-choose-open-decision-1767563/" rel="noopener ugc nofollow" target="_blank">Pixabay上的奇摩诺</a></p></figure><p id="a4d4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在<a class="ae le" rel="noopener" target="_blank" href="/fine-grained-sentiment-analysis-in-python-part-2-2a92fdc0160d">早先的一篇文章</a>中，我描述了如何使用LIME(<strong class="lh ja">L</strong>ocal<strong class="lh ja">I</strong>interpretable<strong class="lh ja">M</strong>model-agnostic<strong class="lh ja">E</strong>explanations)来解释一个细粒度情感分类器的结果。概括地说，以下六个模型用于在斯坦福情感树库(SST-5)数据集上进行细粒度情感类别预测。</p><ul class=""><li id="9f4e" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">基于规则的模型:<strong class="lh ja">文本块</strong>和<strong class="lh ja"> VADER </strong></li><li id="09a9" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">基于特征的模型:<strong class="lh ja">逻辑回归</strong>和<strong class="lh ja">支持向量机</strong></li><li id="6666" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">基于嵌入的模型:<strong class="lh ja"> FastText </strong>和<strong class="lh ja"> Flair </strong></li></ul><p id="8845" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用线性工作流来分析和解释使用每种方法的情感分类结果。每个模型被训练成5类情绪(1到5)，1是“强烈负面”，3是“中性”，5是“强烈正面”。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mp"><img src="../Images/e35552e4ce5988e05a794e588ea5a1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A2ox9DtrIamY6DU9.png"/></div></div></figure><p id="a5c2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这篇文章的目标是展示如何构建一个解释器仪表板(使用三个框架中的任何一个),它接受一个经过训练的模型，并为模型做出的预测输出及时的解释。</p><h1 id="a487" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">示例石灰说明</h1><p id="490e" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">简而言之，LIME生成一个包含可视化效果(作为嵌入式JavaScript)的解释对象，该对象可以输出到一个HTML文件，然后可以在任何浏览器中打开。LIME的典型输出如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/29bf0ee05b8099a507b18fb5c00a636a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bZVB0yUN_d67NK_y.png"/></div></figure><h1 id="9fdb" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">为什么要构建交互式仪表板应用程序？</h1><p id="ff54" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">要使用LIME解释分类器的结果，每次需要解释时都必须写出单独的HTML文件，这可能很麻烦。接受用户输入的交互式仪表板是实时快速迭代多个测试样本的非常有效的手段，为用户提供即时反馈。此外，拥有一个仪表板允许非技术用户(他们可能知道也可能不知道如何执行Python脚本)能够按需做出自己的时间解释。</p><p id="0f53" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下部分展示了我们如何使用三种不同的框架构建LIME explainer仪表板:Flask、Dash和Streamlit。</p><h1 id="8602" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">解释器类</h1><p id="5094" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">为了方便地引用每个分类器的预测方法，下面的面向对象的模板被应用来支持代码重用，在项目的GitHub repo 中<a class="ae le" href="https://github.com/prrao87/fine-grained-sentiment/blob/master/explainer.py" rel="noopener ugc nofollow" target="_blank">可用。简而言之，定义了一个Python类，它接受由LIME生成的变量列表(标记空白的随机文本样本)，然后我们将每个样本的类概率输出为一个Numpy数组。</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ee7e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一旦每个变化的类概率被返回，这可以被馈送到<code class="fe nq nr ns nt b">LimeTextExplainer</code>类(如下所示)。启用词包(<code class="fe nq nr ns nt b">bow</code>)意味着LIME在生成变体时不考虑词序。然而，FastText和Flair模型分别考虑n元语法和上下文排序进行训练，因此为了模型之间的公平比较，SST-5上的所有解释都禁用了<code class="fe nq nr ns nt b">bow</code>标志选项。</p><p id="41ad" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">LIME解释器返回的<code class="fe nq nr ns nt b">exp</code>对象是通过LIME内部的<code class="fe nq nr ns nt b">explain_instance</code>方法，将本地线性模型的预测(以数字形式)转换成可视的、可解释的形式。这可以输出为HTML。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e8eb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下部分描述了如何将所有这些功能封装到一个交互式仪表板应用程序中。</p><h1 id="d256" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">选项1:烧瓶</h1><p id="b73f" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">LIME explainer仪表板的烧瓶版本如下所示。用户输入一段文本，选择要为LIME生成的随机样本的数量，然后使用下拉菜单从给定的分类器列表中进行选择。点击<code class="fe nq nr ns nt b">Explain results!</code>按钮，然后生成一个LIME解释HTML对象，它呈现在一个HTML Iframe中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/7a9575bf96766ddbdb1a8a1dc33a28ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AmFZg-VIVQLOjmPT.gif"/></div></div></figure><p id="ac89" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">虽然Flask不是一个数据仪表板工具(它是一个<a class="ae le" href="https://wsgi.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> WSGI </a> web框架，最初是围绕<a class="ae le" href="https://werkzeug.palletsprojects.com/" rel="noopener ugc nofollow" target="_blank"> Werkzeug </a>和<a class="ae le" href="https://palletsprojects.com/p/jinja/" rel="noopener ugc nofollow" target="_blank"> Jinja </a>的包装器)，但它提供了一个简单的基于插件的架构，开发人员可以从这个架构中为复杂的应用程序构建和扩展接口。Flask的关键优势在于它在生产环境中的健壮性，以及在Python生态系统中围绕它的大量扩展。</p><p id="9f26" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">要使用Flask构建LIME explainer仪表板，需要了解以下技术:</p><ul class=""><li id="f405" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">HTML/JavaScript :页面的整体结构和内容是用HTML定义的。任何需要基于字段值或用户输入触发的操作都需要使用JavaScript来定义，要么通过HTML文件本身，要么从外部源加载。</li><li id="cce6" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated"><strong class="lh ja"> CSS </strong>:使用CSS文件定义页面的样式和布局。</li><li id="e715" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated"><strong class="lh ja"> Jinja2 </strong>:这是一个模板引擎，从Python中动态生成页面的HTML。出于安全原因，这是必要的(不使用模板和传递未转义的静态HTML会导致跨站点脚本攻击)。模板引擎由Python控制，最终的HTML使用Flask方法呈现。</li></ul><h2 id="b870" class="nv mr iq bd ms nw nx dn mw ny nz dp na lo oa ob nc ls oc od ne lw oe of ng iw bi translated">Flask应用程序:目录结构</h2><p id="cc0f" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">Flask应用程序使用的目录结构如下所示。所需的样式在<code class="fe nq nr ns nt b">static/style.css</code>文件中用CSS配置，要渲染的HTML模板在<code class="fe nq nr ns nt b">templates/index.html</code>中定义。任何经过训练的情感分类器模型都会进入<code class="fe nq nr ns nt b">models</code>目录。解释器类在<code class="fe nq nr ns nt b">lime_explainer.py</code>中定义，烧瓶路径在<code class="fe nq nr ns nt b">app.py</code>中定义。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/9c5bbd51bf343b1c9cc4a4d23b04c46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*Gqep-YG-3My3sHPQCUOSHw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">烧瓶石灰解释器应用程序的目录结构</p></figure><p id="b8cf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于这个用例，Flask中的应用程序代码是用最简单的方式编写的。定义了两条路线(默认路线<code class="fe nq nr ns nt b">'/'</code>和时间结果路线<code class="fe nq nr ns nt b">'result'</code>)。请注意，结果路由使用了一个<code class="fe nq nr ns nt b">POST</code>请求，这意味着它只在用户向应用程序输入一些信息并与之交互时才生成HTML(通过Jinja)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b1ad" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Flask LIME explainer应用程序的代码可从GitHub获得:</p><div class="oh oi gp gr oj ok"><a href="https://github.com/prrao87/fine-grained-sentiment-app" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ja gy z fp op fr fs oq fu fw iz bi translated">prrao 87/细粒度情感应用程序</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">这个报告包含一个用Flask编写的交互式应用程序的初始原型，它解释了…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ky ok"/></div></div></a></div><h1 id="58df" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">选项2:破折号</h1><p id="2f72" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">设计LIME仪表板的另一种方法是使用Plotly的<a class="ae le" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank"> Dash </a>库。Dash是一个用Python构建分析性web应用程序的框架。使用Dash的好处是双重的:开发人员可以只使用Python(不需要JavaScript)设计应用程序，并且他们可以通过CSS完全控制应用程序的设计和结构。下面演示了一个使用Dash编写的LIME explainer应用程序。就像Flask应用程序的情况一样，单击<code class="fe nq nr ns nt b">Explain results</code>按钮生成一个LIME解释HTML对象，该对象通过Dash的HTML Iframes包装器呈现。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/ff3f0dfaff907e2f3e9f363d5ea82d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n8d-eAj-HRUx6fDK.gif"/></div></div></figure><h1 id="eddb" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">Dash应用程序:目录结构</h1><p id="f0c2" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">Dash应用程序使用的目录结构如下所示。使用CSS在<code class="fe nq nr ns nt b">assets/style.css</code>文件中配置所需的样式。与Flask示例不同，在<code class="fe nq nr ns nt b">app.py</code>中，应用程序的HTML布局和路线/交互是使用纯Python定义的。任何经过训练的情感分类器模型都会进入<code class="fe nq nr ns nt b">models</code>目录。解释器类在<code class="fe nq nr ns nt b">lime_explainer.py</code>中定义。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/d243d7e3be779acb3ac267974a3ba9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*pckrbaov8GK2MUK9U9-fNw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Dash LIME解释器应用程序的目录结构</p></figure><p id="616a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Dash应用程序代码的关键组件如下所述。首先是应用程序布局，它是使用Dash的HTML包装器用Python编写的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="87cb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">常见的HTML对象，如标题、标签、文本输入和Iframes，可以使用Python结构轻松添加，如图所示。</p><p id="b170" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下一个组件是<em class="pb">回调</em>，这是一段反应式的功能性代码，允许开发人员观察、修改和更新UI中任何组件的属性。在Dash中，回调是使用Python的装饰语法定义的。回调是编码应用程序交互性的非常强大的方法，因为它们跟踪按钮点击和数据更新的状态<em class="pb">。LIME解释器中使用的主要回调如下所示。</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a818" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">按照上面的构造，我们传递用户的按钮点击(或者是“提交”或者是“清除”按钮)，以及下拉菜单的<em class="pb">状态</em>，在文本输入中输入的样本数量，以及我们想要预测其情感的文本样本。这里跟踪每个文本字段的状态(而不仅仅是<em class="pb">值</em>)是很重要的——它允许我们将回调的执行与<em class="pb">按钮点击</em>联系起来，而不是每次文本输入中的值更新时都执行它。</p><p id="6bab" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Dash LIME explainer应用程序的代码也可以在GitHub上找到:</p><div class="oh oi gp gr oj ok"><a href="https://github.com/prrao87/fine-grained-sentiment-app-dash" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ja gy z fp op fr fs oq fu fw iz bi translated">pr Rao 87/细粒度-情感-应用-破折号</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">这个报告包含了一个现有的交互式应用程序的Plotly Dash等价物，它解释了…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="pc l ov ow ox ot oy ky ok"/></div></div></a></div><h1 id="03ab" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">选项3:简化</h1><p id="8df2" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">另一种选择是使用<a class="ae le" href="https://www.streamlit.io/" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>来构建解释器应用程序。这是目前最快的方法，需要非常基础的web开发知识和最少的代码行。与Flask和Dash方法不同，Streamlit应用程序使用自己的样式和布局(不可能通过CSS进行定制，至少不能使用传统方法)。Streamlit LIME explainer应用程序如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/53dd88f3a3ae58b531ad7c77d5aa7320.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*DBnUg3OjQAmwev5HiIX8Bw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Streamlit LIME解释器应用程序的目录结构</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/8b2690ab5ad8282df3e0c64fb47bbc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F1R6jGtk-O9vxaUd.gif"/></div></div></figure><p id="90c1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因为Streamlit是为帮助快速创建和共享web应用程序而从头设计的，所以LIME dashboard应用程序有一个非常简单的目录结构。web应用程序的所有代码都写在一个文件中，<code class="fe nq nr ns nt b">app.py</code> -这包括小部件、结构、交互和所有用户输入来进行时间预测。这种设计的显著之处在于，即使将所有这些功能都塞进了一个文件中，它仍然非常简洁(大约40行代码！).因此，我们只对特定于应用程序的实体使用单独的目录，比如模型和数据。</p><p id="a1a8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Streamlit仪表板的完整代码如下所示。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="eec4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">标题是用markdown语法编写的。请注意，因为Streamlit的API是为速度和易用性而设计的，所以它不像Flask和Dash那样允许轻松访问底层HTML。因此，在这种情况下，我们需要显式地使用原始HTML字符串的不安全呈现(使用<code class="fe nq nr ns nt b">unsafe_allow_html</code>关键字)来获得居中对齐的标题。然后使用一个<a class="ae le" href="https://docs.streamlit.io/en/stable/develop_streamlit_components.html" rel="noopener ugc nofollow" target="_blank"> Streamlit HTML组件</a>呈现LIME explainer的HTML输出，这是一个定制组件，在Iframe中显示HTML字符串。</p><p id="e9b7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">和往常一样，Streamlit LIME explainer应用程序的代码可以在GitHub上获得:</p><div class="oh oi gp gr oj ok"><a href="https://github.com/prrao87/fine-grained-sentiment-app-streamlit" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ja gy z fp op fr fs oq fu fw iz bi translated">prrao 87/细粒度-情感-应用程序-简化</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">此回购包含现有交互式应用程序的Streamlit等价物，它解释了…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="pf l ov ow ox ot oy ky ok"/></div></div></a></div><h1 id="c5cd" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">部署</h1><p id="a988" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">出于本文的目的，这三个应用都是使用<a class="ae le" href="https://www.heroku.com/what" rel="noopener ugc nofollow" target="_blank"> Heroku </a>部署的，这是一个PaaS系统，允许开发者在云上构建、运行和操作应用。用于构建应用程序的三个框架都有很好的Heroku部署指南，如下所示。</p><ul class=""><li id="25f6" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">Flask: <a class="ae le" href="https://stackabuse.com/deploying-a-flask-application-to-heroku/" rel="noopener ugc nofollow" target="_blank">将Flask应用程序部署到Heroku </a></li><li id="bc7a" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">Dash: <a class="ae le" href="https://dash.plotly.com/deployment" rel="noopener ugc nofollow" target="_blank">部署Dash应用</a></li><li id="263d" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">Streamlit: <a class="ae le" rel="noopener" target="_blank" href="/deploy-streamlit-on-heroku-9c87798d2088">如何在Heroku上部署Streamlit</a></li></ul><p id="2604" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然而，使用生产级WSGI web服务器，如<a class="ae le" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> gunicorn </a>和负载平衡器，如<a class="ae le" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a>，部署Flask或Dash应用程序也相对简单。在部署期间，Nginx <a class="ae le" href="https://www.digitalocean.com/community/tutorials/how-to-deploy-python-wsgi-apps-using-gunicorn-http-server-behind-nginx" rel="noopener ugc nofollow" target="_blank">充当位于web服务器</a>前面的反向代理，以高度的可靠性处理大量请求。类似地，Streamlit还提供了一种使用Docker和/或Nginx的组合来<a class="ae le" href="https://docs.streamlit.io/en/stable/streamlit_faq.html" rel="noopener ugc nofollow" target="_blank">手动部署应用</a>的方法。</p><h1 id="b525" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">关于Python web框架中可伸缩性的一个注释</h1><p id="2a4f" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">web服务器网关接口(WSGI)是作为Python web框架与Web服务器交互的标准而开发的一个<a class="ae le" href="https://www.python.org/dev/peps/pep-3333/" rel="noopener ugc nofollow" target="_blank"> Python规范</a>。有了这样的系统，开发人员可以轻松地将Nginx之类的服务放在Python web应用程序的前面(例如，用Flask或Dash编写),作为将所有请求转发给web应用程序的反向代理。<strong class="lh ja">兼容WSGI的服务器的一个关键特性是它们是同步的</strong>。这意味着每个请求<em class="pb">阻塞</em>服务器，直到它收到来自应用程序的响应，称为<em class="pb">阻塞操作</em>。WSGI服务器合并可伸缩性的典型方式是通过使用多线程，其中为每个请求创建一个新线程，以便能够同时处理多个请求。然后，这与运行web服务器的多个工作进程相结合，这确实具有很好的伸缩性，但是受到给定机器上可用的物理内核数量的限制。</p><p id="efa4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">像Flask和Dash这样的框架所使用的WSGI方法，如果有非常大量的请求进入，就可以在伸缩方面达到极限。在生产系统中解决这个问题的方法是水平扩展<em class="pb"/>，即添加越来越多的服务器，并使用类似Nginx的负载平衡服务，这些服务可以在高请求量期间在所有服务器之间平均分配负载。</p><p id="2392" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最近的Python web应用框架，如Streamlit，完全依赖于不同的并发系统。Streamlit在幕后使用了一个<a class="ae le" href="https://www.tornadoweb.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> Tornado </a> web服务器，它被从头设计为使用<a class="ae le" href="https://www.tornadoweb.org/en/stable/guide/async.html" rel="noopener ugc nofollow" target="_blank">异步事件循环</a>。在这个系统中，使用了一个单线程，它实现了按照到达顺序执行的<em class="pb">非阻塞</em>功能。这种方法可以很容易地在web应用程序中实现非常高的并发度，这在很大程度上依赖于I/O绑定操作的应用程序中，可以真正帮助扩展系统，以同时处理大量请求。</p><p id="4d5c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">和往常一样，没有单一的规则来决定哪种并发方法更好。根据确切的用例以及手边的应用程序，基于WSGI或异步事件循环驱动的服务可能是合适的选择。</p><blockquote class="pg"><p id="22ea" class="ph pi iq bd pj pk pl pm pn po pp ma dk translated"><em class="pq">延伸阅读:</em> <a class="ae le" href="https://www.475cumulus.com/single-post/2017/04/03/WSGI-Is-Not-Enough-Anymore" rel="noopener ugc nofollow" target="_blank"> <em class="pq"> WSGI已经不够用了</em> </a> <em class="pq"> —第一、二、三部</em></p></blockquote><h1 id="eb92" class="mq mr iq bd ms mt mu mv mw mx my mz na kf pr kg nc ki ps kj ne kl pt km ng nh bi translated">什么时候使用每个框架最有意义？</h1><p id="078c" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">本节讨论每个框架最适合当前任务的情况。</p><h2 id="9522" class="nv mr iq bd ms nw nx dn mw ny nz dp na lo oa ob nc ls oc od ne lw oe of ng iw bi translated">瓶</h2><p id="e126" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">Flask的强大之处在于它允许开发人员使用任何前端工具的组合来创建web应用程序。这包括表单输入扩展，如<a class="ae le" href="https://wtforms.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> WTForms </a>和<a class="ae le" href="https://flask-login.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Flask-Login </a>，以及JavaScript可视化库(<a class="ae le" href="https://www.highcharts.com/" rel="noopener ugc nofollow" target="_blank"> Highcharts </a>或<a class="ae le" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3 </a>)。此外，Flask通过HTML、CSS、jQuery和<a class="ae le" href="https://pythonhosted.org/Flask-Bootstrap/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>为开发人员提供了对底层页面结构和用户交互的完全访问，允许基于项目需求构建非常复杂的应用程序的巨大灵活性。</p><p id="96f2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">关于本文中显示的LIME explainer仪表盘，Flask是以下任何一种场景的绝佳选择:</p><ul class=""><li id="4154" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">该应用程序由一个在JavaScript、HTML和CSS以及不同的HTTP请求方法(GET、POST等)方面拥有专业知识的团队编写。)</li><li id="1cd4" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">该应用是一个更大的仪表板的一部分，由前端的JavaScript框架提供支持</li><li id="c5ca" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">处理和服务数据的多个RESTful端点已经存在(在这之后，LIME explainer可以作为另一个端点被写入前端)</li></ul><h2 id="b681" class="nv mr iq bd ms nw nx dn mw ny nz dp na lo oa ob nc ls oc od ne lw oe of ng iw bi translated">破折号</h2><p id="f327" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">对于主要在Python环境中工作的应用程序需要高度可定制性的开发人员来说，Dash是一个很好的选择。许多强大的前端可视化工具(来自<a class="ae le" href="https://plotly.com/javascript/" rel="noopener ugc nofollow" target="_blank"> Plotly.js </a> JavaScript库)都是现成的，允许开发人员主要关注应用程序的样式和添加用户交互。因为Dash构建在Flask之上，所以它遵循与Flask相似的部署策略，这使得已经有在生产中实现Flask应用的经验的团队可以非常容易地使用它。</p><p id="2948" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一般来说，在以下任何一种情况下，Dash都是构建LIME explainer仪表板的绝佳选择:</p><ul class=""><li id="bd4e" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">需要编写应用程序来与现有的Flask应用程序集成</li><li id="dc2d" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">开发和部署该应用程序的团队在Python方面经验丰富(但在JavaScript方面不太精通)</li><li id="3178" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">仪表板需要很好的定制程度(Dash允许开发者访问底层CSS)</li></ul><h2 id="9ffa" class="nv mr iq bd ms nw nx dn mw ny nz dp na lo oa ob nc ls oc od ne lw oe of ng iw bi translated">细流</h2><p id="43db" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">作为生态系统的相对新人，Streamlit在数据科学家需要通过交互式应用程序与更大的团队快速分享他们的工作的情况下大放异彩。对于数据科学家个人来说，它也非常有用，可以快速、交互式地探索数据集或模型对单个样本的性能。</p><p id="c3db" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对于LIME explainer仪表板，Streamlit是在以下任何场景中使用的一个很好的替代方案:</p><ul class=""><li id="5507" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">该应用程序是由一个团队(或个人)编写的，只有很少的web开发经验</li><li id="79e5" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">应用程序需要在最短的时间内快速构建，并尽可能使用最少的代码行</li><li id="59a1" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">开发人员希望花更多的时间构建交互式工具，尽可能少的时间定制应用程序的外观</li></ul><h1 id="d738" class="mq mr iq bd ms mt mu mv mw mx my mz na kf nb kg nc ki nd kj ne kl nf km ng nh bi translated">结论</h1><p id="9fb4" class="pw-post-body-paragraph lf lg iq lh b li ni ka lk ll nj kd ln lo nk lq lr ls nl lu lv lw nm ly lz ma ij bi translated">这篇文章强调了构建LIME explainer交互式仪表板应用程序的三种不同方法。Streamlit是所有选项中最简单、最容易学习的。Flask需要最大的前期时间投入，学习各种组合在一起的部分(HTML、CSS、jQuery/JavaScript、Jinja2和HTTP请求方法)。Plotly Dash很好地介于Flask和Streamlit之间，就复杂性和启动并运行仪表板的初始工作而言。根据承担此类项目的团队的组成和技能，这三个选项中的任何一个都可能是最合适的。</p><p id="413b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">构建如图所示的LIME仪表板的主要原因是允许非数据科学家的人检查NLP分类器的结果。至少在某种程度上，提供一种交互式方法来动态测试单个样本的结果可以帮助诊断NLP模型的问题，并提高模型的可解释性。为您自己的用例从每个回购(如下所示)中体验和定制代码的乐趣吧！</p><ul class=""><li id="ac6e" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated"><a class="ae le" href="https://github.com/prrao87/fine-grained-sentiment-app" rel="noopener ugc nofollow" target="_blank">石灰讲解器app:烧瓶</a></li><li id="1e78" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated"><a class="ae le" href="https://github.com/prrao87/fine-grained-sentiment-app-dash" rel="noopener ugc nofollow" target="_blank">石灰解说app: Dash </a></li><li id="5d99" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated"><a class="ae le" href="https://github.com/prrao87/fine-grained-sentiment-app-streamlit" rel="noopener ugc nofollow" target="_blank">石灰解说app: Streamlit </a></li></ul></div><div class="ab cl pu pv hu pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="ij ik il im in"><p id="adce" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="pb">原载于2020年10月24日</em><a class="ae le" href="https://prrao87.github.io/blog/lime-explainer-dashboards/" rel="noopener ugc nofollow" target="_blank"><em class="pb">https://prrao 87 . github . io</em></a><em class="pb">。</em></p></div></div>    
</body>
</html>