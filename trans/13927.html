<html>
<head>
<title>SQL Window Function — Demonstrated with Real Interview Questions from Leetcode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL窗口函数—用Leetcode中的真实面试问题演示</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-window-function-demonstrated-with-real-interview-questions-from-leetcode-e83e28edaabc?source=collection_archive---------6-----------------------#2020-09-25">https://towardsdatascience.com/sql-window-function-demonstrated-with-real-interview-questions-from-leetcode-e83e28edaabc?source=collection_archive---------6-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="deba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">作者Sherwin郑</em></p><p id="6803" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">窗口功能现在是SQL访谈中必不可少的内容，尽管它只是在2018年4月19日在<strong class="js iu">发布后才在MySQL 8.0上可用。</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/c454b30c250b20316fb4cb9024182fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnYxTRQVXh_xSuqlG3lcDQ.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">作者图片</p></figure><h1 id="c943" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一张便条</h1><p id="269f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">本文假定读者除了基本的SQL语法之外，还知道SQL窗口函数。如果不熟悉，想了解更多，可以参考我学习用的这个[ <a class="ae mi" href="https://www.sqlite.org/windowfunctions.html" rel="noopener ugc nofollow" target="_blank">链接</a>。请注意，在不同的SQL平台上，语法可能会有所不同。</p><p id="e143" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文将向您介绍几个常见的it应用程序，并在面试中使用Leetcode.com的例子进行测试</p><p id="d197" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近的Leetcode问题<a class="ae mi" href="https://leetcode.com/problems/the-most-frequently-ordered-products-for-each-customer/" rel="noopener ugc nofollow" target="_blank"> 1596。每个客户最常订购的产品</a>启发我写这个主题是因为它把一堆知识点链接在了一起，包括窗口函数及其从易到中的应用，自连接及其与窗口函数的关系，以及SQL语句的执行顺序。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mj"><img src="../Images/88319e4108d669b3356b2bef7b122171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJca3ARrSv25fW6GRXd0pg.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">我的Leetcode数据库从09242020开始更新</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="3b52" class="lf lg it bd lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">问题类型一—具有两级粒度的数据</h1><h2 id="652a" class="mw lg it bd lh mx my dn ll mz na dp lp kb nb nc lt kf nd ne lx kj nf ng mb nh bi translated">每个部门的最高工资</h2><p id="f3a7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，我们先从一个简单的问题开始:各部门工资最高是多少？我想答案很快就在你脑海里弹出来:<code class="fe ni nj nk nl b">SELECT MAX(salary)</code>跟<code class="fe ni nj nk nl b">GROUP BY department</code>。</p><h2 id="f023" class="mw lg it bd lh mx my dn ll mz na dp lp kb nb nc lt kf nd ne lx kj nf ng mb nh bi translated">每个部门及其相应员工的最高工资</h2><p id="98f7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">然而，如果面试官想夸大其词，说公司不仅想知道最高工资，还想知道与该工资相对应的员工姓名，该怎么办？如何编写查询？在这个意义上，它类似于Tableau中的细节层次(LOD)操作。这是leet code<a class="ae mi" href="https://leetcode.com/problems/department-highest-salary/" rel="noopener ugc nofollow" target="_blank">【184。部门最高工资] </a></p><p id="21e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两种方法可以解决这个问题:<strong class="js iu">窗口函数</strong>或<strong class="js iu">自连接/相关子查询</strong>，任何一种都可以。你会发现它们是等价的，而窗口函数更简洁，更容易编写。</p><p id="40db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用窗口函数，很简单，只需编写下面的代码</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c5d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而使用相关子查询时，代码需要花费更多时间来运行</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4934" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于外部表中的每一行，相关子查询将在<code class="fe ni nj nk nl b">WHERE</code>子句中查找内部表，并将外部表中的行与子查询中对应的行进行比较。如果使用自连接，它不限于顶部记录，还可以通过将<code class="fe ni nj nk nl b">COUNT()</code>与<code class="fe ni nj nk nl b">WHERE</code>语句一起使用来给出<code class="fe ni nj nk nl b">RANK()</code>。</p><p id="71de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于Leetcode的其他良好实践问题包括:</p><ul class=""><li id="5d60" class="no np it js b jt ju jx jy kb nq kf nr kj ns kn nt nu nv nw bi translated">178。等级分数 ](硬编码DESNE_RANK)</li><li id="0c4d" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated">177。第n高工资</li><li id="981a" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated">185。部门前三名薪资</li></ul><p id="1bb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我对178的解决方案在这里。这可能不是最佳实践，但它很好地说明了该机制是如何工作的。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e245" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简短说明:</p><ul class=""><li id="ba8b" class="no np it js b jt ju jx jy kb nq kf nr kj ns kn nt nu nv nw bi translated">Self-join + COUNT() = RANK()，平局时给出缺口</li><li id="51d0" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated">自连接+ COUNT(DISTINCT ) = DENSE_RANK()，这消除了平局时差距</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oc"><img src="../Images/7c1619aef4efffa81f1460e4df1db16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NULRz0mV680IHVnzB2XBVg.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">作者图片</p></figure><p id="505b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么它们的等价性值得一提？好吧，如果您非常幸运，您的SQL平台不支持窗口函数，您将不得不使用自连接设计一个等效的窗口函数来实现相同的效果。所以知道还是好的。</p><p id="abc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上两个例子的总结:</p><p id="9fd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们可以使用</strong> <code class="fe ni nj nk nl b"><strong class="js iu">GROUP BY</strong></code> <strong class="js iu"> + </strong> <code class="fe ni nj nk nl b"><strong class="js iu">MIN()</strong></code> <strong class="js iu">找到每组中的最小值，但是如果我们想知道它在其他字段下的对应值，就需要使用window函数给出一个排名，相当于旧版SQL中的一个过滤自连接或者Tableau中的LOD。</strong></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="01f5" class="lf lg it bd lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">问题类型二—具有三级粒度的数据</h1><h2 id="a92d" class="mw lg it bd lh mx my dn ll mz na dp lp kb nb nc lt kf nd ne lx kj nf ng mb nh bi translated">当排名字段是聚合值时</h2><p id="1491" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们再来一次。</p><p id="d624" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想知道“年薪”的级别，但在汇总他们的“月薪”之前，我们还不能在我们的窗口函数中使用<code class="fe ni nj nk nl b">ORDER BY</code>该怎么办？</p><p id="fa1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，编写一个SQL查询来查找每个客户最常订购的产品。</p><pre class="kq kr ks kt gt od nl oe of aw og bi"><span id="d224" class="mw lg it nl b gy oh oi l oj ok">orders table<br/>+----------+------------+-------------+------------+<br/>| order_id | order_date | customer_id | product_id |<br/>+----------+------------+-------------+------------+<br/>| 1        | 2020-07-31 | 1           | 1          |<br/>| 2        | 2020-07-30 | 2           | 2          |<br/>| 3        | 2020-08-29 | 3           | 3          |<br/>| 4        | 2020-07-29 | 4           | 1          |<br/>| 5        | 2020-06-10 | 1           | 2          |<br/>| 6        | 2020-08-01 | 2           | 1          |<br/>| 7        | 2020-08-01 | 3           | 3          |<br/>| 8        | 2020-08-03 | 1           | 2          |<br/>| 9        | 2020-08-07 | 2           | 3          |<br/>| 10       | 2020-07-15 | 1           | 2          |<br/>+----------+------------+-------------+------------+</span></pre><p id="a1d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上一节中的问题很简单，因为显示了排名字段<code class="fe ni nj nk nl b">salary</code>。但是在上表中，每一行都记录了一个客户购买的“产品”,并且是重复的。</p><p id="f4d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们<strong class="js iu">采用前面的推理</strong>，我们需要(1)写一个子查询:<code class="fe ni nj nk nl b">GROUP BY customer_id, product_id</code>和<code class="fe ni nj nk nl b">COUNT(product_id) AS cnt</code>，然后(2)使用<code class="fe ni nj nk nl b">cnt</code>作为窗口函数的排序字段，(3)在<code class="fe ni nj nk nl b">WHERE</code>子句中过滤结果，比如在第三个查询中使用<code class="fe ni nj nk nl b">rnk = 1</code>，因为我们不能在<code class="fe ni nj nk nl b">WHERE</code>语句中使用窗口函数。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="7865" class="mw lg it bd lh mx my dn ll mz na dp lp kb nb nc lt kf nd ne lx kj nf ng mb nh bi translated">通过了解SQL语句的执行顺序来简化查询</h2><p id="0ee4" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">然而，我们实际上可以将t1和t2合并到一个查询中，如下所示</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e815" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一开始，当把<code class="fe ni nj nk nl b">PARTITION BY</code>和<code class="fe ni nj nk nl b">GROUP BY</code>结合起来时，我并不是本能的:查询基于哪个分区/组？但是在我查看了查询的执行顺序之后，这个问题就迎刃而解了:</p><ol class=""><li id="cc8d" class="no np it js b jt ju jx jy kb nq kf nr kj ns kn ol nu nv nw bi translated">从并加入s。</li><li id="46ea" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn ol nu nv nw bi translated">哪里…</li><li id="47c6" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn ol nu nv nw bi translated">分组依据…</li><li id="9943" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn ol nu nv nw bi translated">拥有…</li><li id="9f34" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn ol nu nv nw bi translated">选择…</li><li id="f461" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn ol nu nv nw bi translated">独特的…</li><li id="707a" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn ol nu nv nw bi translated">排序依据…</li><li id="d013" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn ol nu nv nw bi translated">极限/偏移。</li></ol><p id="7c30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要知道窗口函数与<code class="fe ni nj nk nl b">SELECT</code>是在同一个阶段执行的，所有的东西也是如此，包括<code class="fe ni nj nk nl b">PARTITION BY</code>。因此，实际的执行步骤如下所示(注意:前面代码块中的代码不会在结果中显示<code class="fe ni nj nk nl b">CNT</code>，但是它会按照图示进行计算)。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi om"><img src="../Images/4320c7cf4062b481ba4582c95a75ae34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4fMQcEs-qk6c-aSfWGbh-Q.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">作者图片</p></figure><p id="a434" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是1596年的Leetcode。每位顾客最常订购的产品</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi on"><img src="../Images/30bee631101aef3070f7894e475eb581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*8NMMbLeWOTBPONvbrS6L6Q.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">作者图片</p></figure><h1 id="d5b2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">扩展到更多的细节层次</h1><h2 id="6663" class="mw lg it bd lh mx my dn ll mz na dp lp kb nb nc lt kf nd ne lx kj nf ng mb nh bi translated">如果我们想知道购买第二多的产品呢</h2><p id="5cfc" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我进一步的想法是，如果我们想知道第二多，甚至第n多购买的产品，因为我们比较这个问题[ <a class="ae mi" href="https://leetcode.com/problems/nth-highest-salary/" rel="noopener ugc nofollow" target="_blank"> 177。第n高工资</a>。你如何修改最后一部分的代码？</p><ul class=""><li id="a9b6" class="no np it js b jt ju jx jy kb nq kf nr kj ns kn nt nu nv nw bi translated">将<code class="fe ni nj nk nl b">rnk = 1</code>改为<code class="fe ni nj nk nl b">rnk = 2</code>，或者</li><li id="d806" class="no np it js b jt nx jx ny kb nz kf oa kj ob kn nt nu nv nw bi translated">将<code class="fe ni nj nk nl b">rnk = 1</code>改为<code class="fe ni nj nk nl b">rnk = 2</code>，同时将<code class="fe ni nj nk nl b">RANK()</code>改为<code class="fe ni nj nk nl b">DENSE_RANK()</code>？</li></ul><p id="de53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应该由你来思考。看完这篇文章，你应该熟悉其中的关系。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="1cb9" class="lf lg it bd lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly mv ma mb mc bi translated">结论</h1><p id="1836" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">掌握这类数据粒度问题在很多方面都有帮助。我们首先介绍了窗口函数的价值和用法，并将其与简单的<code class="fe ni nj nk nl b">GROUP BY</code>进行了比较。然后，我们对窗口函数和自连接/相关子查询有了更深入的了解。最后，我们学习了如何用更高粒度的数据对任何级别的细节进行排序。</p><p id="8ef5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">读完本文后，无论是在面试还是在生产中，您都应该能够处理这种类型的问题，并且通过使用窗口函数练习您的SQL专业知识，从任何级别的细节中挖掘见解。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="c87f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">关于我</em></p><p id="3771" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko"> Sherwin是维克森林大学的商业分析理学硕士，本科专业是中山大学的管理科学，辅修的是伊拉斯谟大学鹿特丹管理学院(RSM)的大数据。查看我的</em> <a class="ae mi" href="https://www.linkedin.com/in/sherwinzhengsysu/" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> LinkedIn </em> </a> <em class="ko">或</em><a class="ae mi" href="https://www.github.com/SherwinZ" rel="noopener ugc nofollow" target="_blank"><em class="ko">Github</em></a><em class="ko">了解更多。</em></p></div></div>    
</body>
</html>