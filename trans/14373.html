<html>
<head>
<title>Popular NumPy Function and Where to Find Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流行的NumPy函数以及在哪里可以找到它们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/popular-numpy-function-and-where-to-find-them-6d170b7e6ba1?source=collection_archive---------31-----------------------#2020-10-03">https://towardsdatascience.com/popular-numpy-function-and-where-to-find-them-6d170b7e6ba1?source=collection_archive---------31-----------------------#2020-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/420e13ab84f5d73263ac8147f482b8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98DAS9La4VhMN7MhLkC0Ug.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">最流行的NumPy函数(图片由作者提供)</p></figure><p id="8a85" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">探索，还是剥削？</p><p id="2208" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果有用，那就足够了。如果你能把事情做好，为什么要寻找其他方法来解决同样的问题呢？这是看待事物的一种方式。反对这种做法的理由是，这样你会错过更有效、更易读的选择。</p><p id="ba45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">即使在与NumPy、Pandas和其他相关库一起工作了近三年之后，我仍然经常找到解决问题的替代方法，至少可以说，这些方法大大减少了运行时间或者可读性更好。</p><p id="ee56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么，在开始工作之前，我们应该努力探索其他功能吗？绝对不行！浏览整个文档会花很多时间。</p><p id="a77d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那我们该怎么办？</p><p id="67ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我决定看看最常用的函数，看看我是否知道它们。假设是<strong class="ke ir">最有用的功能可能会被大多数人使用</strong>。</p><p id="fb83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们来了解一下这些功能是什么！我们将分三步走。</p><ol class=""><li id="73e9" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">使用Github搜索API来查找使用NumPy的存储库</li><li id="c87b" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">从这些存储库中，下载相关的文件</li><li id="8cce" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">浏览代码库，找到最常用的函数</li></ol><h2 id="ffac" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">使用Github搜索API来查找使用NumPy的存储库</h2><p id="6ab4" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">要使用Github API，首先需要创建一个<a class="ae mm" href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token" rel="noopener ugc nofollow" target="_blank"> API令牌</a>。我们将把这个令牌放入请求的头部。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="2a92" class="lo lp iq ms b gy mw mx l my mz"># I put the API token in a txt file, which I read in the next line<br/>with open('../../api_keys/github.txt', "r") as f:<br/>    API_KEY = f.read()<br/>    <br/>headers = {'Authorization': 'token %s' % API_KEY}</span></pre><p id="894a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们来声明一些变量。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="596d" class="lo lp iq ms b gy mw mx l my mz"># We will look for python codebases that use the NumPy library<br/>LIBRARY = ‘numpy’<br/>LANGUAGE = ‘python’</span><span id="0d35" class="lo lp iq ms b gy na mx l my mz"># This is how the basic search URL looks like. We need to append the page number with it in order to get the paginated search results<br/>URL = '<a class="ae mm" href="https://api.github.com/search/repositories?q=%s+language:%s&amp;sort=stars&amp;order=desc&amp;page='" rel="noopener ugc nofollow" target="_blank">https://api.github.com/search/repositories?q=%s+language:%s&amp;sort=stars&amp;order=desc&amp;page='</a> % (LIBRARY, LANGUAGE)</span></pre><p id="f587" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们将使用请求库发送一个GET请求，然后检查响应。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="26ba" class="lo lp iq ms b gy mw mx l my mz">r = requests.get(URL + '1', headers=headers)<br/>json_response = r.json()</span><span id="8790" class="lo lp iq ms b gy na mx l my mz">print(json_response.keys())<br/>print('Total Repositories:', json_response['total_count'])<br/>print('Total number of items in a page:', len(json_response['items']))</span><span id="4570" class="lo lp iq ms b gy na mx l my mz">print('Keys in a item:', json_response['items'][0].keys())</span></pre><p id="b1e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输出:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d1f5" class="lo lp iq ms b gy mw mx l my mz">dict_keys(['total_count', 'incomplete_results', 'items'])<br/>Total Repositories: 10853<br/>Total number of items in a page: 30<br/>Keys in a item: dict_keys(['id', 'node_id', 'name', 'full_name', 'private', 'owner', 'html_url', 'description', 'fork', 'url', 'forks_url', 'keys_url', 'collaborators_url', 'teams_url', 'hooks_url', 'issue_events_url', 'events_url', 'assignees_url', 'branches_url', 'tags_url', 'blobs_url', 'git_tags_url', 'git_refs_url', 'trees_url', 'statuses_url', 'languages_url', 'stargazers_url', 'contributors_url', 'subscribers_url', 'subscription_url', 'commits_url', 'git_commits_url', 'comments_url', 'issue_comment_url', 'contents_url', 'compare_url', 'merges_url', 'archive_url', 'downloads_url', 'issues_url', 'pulls_url', 'milestones_url', 'notifications_url', 'labels_url', 'releases_url', 'deployments_url', 'created_at', 'updated_at', 'pushed_at', 'git_url', 'ssh_url', '<strong class="ms ir">clone_url</strong>', 'svn_url', 'homepage', 'size', 'stargazers_count', 'watchers_count', 'language', 'has_issues', 'has_projects', 'has_downloads', 'has_wiki', 'has_pages', 'forks_count', 'mirror_url', 'archived', 'disabled', 'open_issues_count', 'license', 'forks', 'open_issues', 'watchers', 'default_branch', 'permissions', 'score'])</span></pre><p id="04b1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们看到响应是一个包含三个键的字典:total_count、incomplete_results和items。</p><p id="1615" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们观察到有10853个存储库匹配我们的查询。但是我们不会深入研究这么多的存储库！假设我们将只研究N个最流行的。怎样才能找到最受欢迎的？嗯，我们已经在我们的<strong class="ke ir"> URL </strong>中指定了根据<strong class="ke ir">星星</strong>对结果进行排序，按照<strong class="ke ir">降序</strong>的顺序。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="95a6" class="lo lp iq ms b gy mw mx l my mz">URL = '<a class="ae mm" href="https://api.github.com/search/repositories?q=%s+language:%s&amp;sort=stars&amp;order=desc&amp;page='" rel="noopener ugc nofollow" target="_blank">https://api.github.com/search/repositories?q=%s+language:%s&amp;<strong class="ms ir">sort=stars</strong>&amp;<strong class="ms ir">order=desc</strong>&amp;page='</a> % (LIBRARY, LANGUAGE)</span></pre><p id="a6eb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们只需要这些存储库的URL，这样我们就可以克隆它们了。你可以看到每一项都有一个“<strong class="ke ir"> clone_url </strong>”键，它服务于这个目的。我们将为每个存储库保留一些额外的密钥，以防我们以后需要它们。现在，我们将迭代前35页。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="740b" class="lo lp iq ms b gy mw mx l my mz">keys = ['name', 'full_name', 'html_url', 'clone_url', 'size', 'stargazers_count']<br/>NUMBER_OF_PAGES_TO_ITERATE = 35</span><span id="50ae" class="lo lp iq ms b gy na mx l my mz"># We will declare a dictionary to store the items<br/>repo_dict = dict([(key, []) for key in keys])</span></pre><p id="8a6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要发送每个页面的请求，并保存结果！不要忘记在每个请求之间等待几秒钟，以免API不堪重负。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3b08" class="lo lp iq ms b gy mw mx l my mz">for page_num in tqdm(range(0, 35)):<br/>    r = requests.get(URL + str(page_num))<br/>    contents = r.json()<br/>    <br/>    for item in contents['items']:<br/>        for key in keys:<br/>            repo_dict[key].append(item[key])<br/>            <br/>    if page_num % 5 == 0:<br/>        time.sleep(60)</span></pre><p id="e27f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们已经有了存储库信息，让我们把它保存在一个数据帧中，我们稍后会用到它。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="bfeb" class="lo lp iq ms b gy mw mx l my mz">repo_df = pd.DataFrame(repo_dict)<br/>repo_df.to_csv('../../data/package_popularity/numpy/repo_info.csv')</span><span id="82b9" class="lo lp iq ms b gy na mx l my mz">repo_df.head()</span></pre><p id="5850" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下面的要点中，您可以查看搜索查询返回的存储库。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="a2e8" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">从这些存储库中下载相关文件</h2><p id="a895" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">如果您运行下面的命令，您将会看到一些存储库不止一次出现在那里。我还没有发现为什么会发生这种情况。如果你知道任何关于这件事的情况，请让我知道。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d391" class="lo lp iq ms b gy mw mx l my mz">repo_df[‘full_name’].value_counts()</span></pre><p id="3590" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们将只考虑这些存储库中的一个，最先出现的那个。</p><p id="1d5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以编写一个bash脚本来克隆这些存储库，或者使用Github库。要使用Github库，您必须提供Github API。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d0a7" class="lo lp iq ms b gy mw mx l my mz">with open('../../api_keys/github.txt', "r") as f:<br/>    API_KEY = f.read()<br/>    <br/>g = Github(API_KEY)</span></pre><p id="f10d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这些文件中，我们将只下载那些带有。py或者。ipnyb扩展。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="a907" class="lo lp iq ms b gy mw mx l my mz">ext_set = set(['ipnyb', 'py'])<br/># The directory where we will store the repositories<br/>REPO_DIR_PARENT = ‘../../data/package_popularity/numpy/clones/’</span></pre><p id="01e2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们将只考虑至少有100颗星的存储库。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="f8bf" class="lo lp iq ms b gy mw mx l my mz">repo_df = repo_df[repo_df['stargazers_count'] &gt;= 100]</span></pre><p id="68e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要获得回购的文件，我们可以使用下面的代码片段。这将返回目录中的所有文件，作为int get_contents函数的参数。例如，下面的代码片段将返回根目录中的文件。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="19c8" class="lo lp iq ms b gy mw mx l my mz">repo = git_client.get_repo(full_name)<br/>contents = repo.get_contents("")</span></pre><p id="3a7e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要从目录结构中递归收集所有文件。让我们编写一个助手函数来处理这个问题。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="66b2" class="lo lp iq ms b gy mw mx l my mz">def get_relevant_files (full_name, git_client, ext_set):<br/>    repo = git_client.get_repo(full_name)<br/>    contents = repo.get_contents("")<br/>    files = []<br/>    <br/>    while contents:<br/>        file_content = contents.pop(0)<br/>        if file_content.type == "dir":<br/>            contents.extend(repo.get_contents(file_content.path))<br/>        elif file_content.name.split('.')[-1] in ext_set:<br/>            files.append((file_content.name, file_content.download_url))<br/>            <br/>    return files</span></pre><p id="2d23" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们调用存储库，看看会发生什么。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4d2e" class="lo lp iq ms b gy mw mx l my mz">files = get_relevant_files('ddbourgin/numpy-ml', git_client, ext_set)<br/>print(len(files))<br/>print(files[0])</span></pre><p id="92c8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输出:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3bfb" class="lo lp iq ms b gy mw mx l my mz">89<br/>('setup.py', '<a class="ae mm" href="https://raw.githubusercontent.com/ddbourgin/numpy-ml/master/setup.py'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/ddbourgin/numpy-ml/master/setup.py'</a>)</span></pre><p id="ea68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">存储库中有89个文件。py或者。ipnyb扩展。该列表包含文件的URL，我们可以使用请求库轻松下载这些文件。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3f81" class="lo lp iq ms b gy mw mx l my mz">for name, download_url in files:<br/>    r = requests.get(download_url, allow_redirects=True)</span></pre><p id="8ae1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们需要将文件的内容保存在本地目录中。我们将简单地使用存储库的全名来创建一个目录，然后将所有文件放在这个特定的目录中。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="7a2b" class="lo lp iq ms b gy mw mx l my mz">os.path.join(REPO_DIR_PARENT, '_'.join(full_name.split('/')))</span></pre><p id="985b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在下面的要点中找到完整的代码。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="4ed7" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">探索仓库</h2><p id="b3c2" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">现在我们将深入挖掘下载的文件。首先，让我们看看import语句，了解NumPy库通常是如何导入的。我们已经知道流行的“import numpy as np”语句。但是有没有人把它进口当pd，甚至熊猫？🤔</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9e0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">查看导入语句，我发现有三种最常用的类型。</p><ol class=""><li id="c3ac" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">import numpy <br/>处理这个问题非常简单。我们将只看形式为<strong class="ke ir"> numpy的语句。* </strong></li><li id="73aa" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">import numpy.abc <br/>这个也很直接。</li><li id="962e" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">从numpy导入abc <br/>我们将通过处理每个实例<strong class="ke ir"> abc来处理这个问题。* </strong>为<strong class="ke ir"> numpy.abc.* </strong></li><li id="36cc" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">从numpy.abc导入xyz <br/>我们将处理<strong class="ke ir"> xyz。* </strong>为<strong class="ke ir"> numpy.xyz.abc.* </strong></li></ol><p id="4ecf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所有这些语句都可以用“as”来修改，如“import numpy as np”或“from numpy import abc as def”我们也需要解决这个问题！</p><p id="147c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将保留一本字典，在那里我们将记录这些缩写以及它们代表什么。然后看到def，就用numpy.abc代替，以此类推。</p><p id="88d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">导入的模块实例可以有两种类型。</p><ol class=""><li id="1d84" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">它们可以是函数，我们可以通过寻找左括号来识别。</li><li id="c7b6" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">它们可以是类，我们可以通过检查它们的属性是否被访问来识别它们。</li></ol><p id="b822" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在非常接近最终解决方案。</p><p id="b189" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于每个文件，我们将首先构建一组导入的实例。</p><p id="b7b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们将遍历每一行，并检查“numpy.xyz.abc.*(”，这是一个简单的正则表达式，其中星号可以由任意数量的字符替换。</p><p id="0979" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们找到一行包含“numpy.xyz.abc.*(”，我们就知道这一行使用的是“numpy.xyz.abc.*()”函数。</p><p id="e68b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">限制</strong>:我们只看单行语句。如果一个函数调用或导入语句跨越多行，这段代码不会计算在内。我没处理过一些边缘案件。如果你想的话，可以随意修改代码！</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="714d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了20个最常用的函数！</p><ol class=""><li id="587c" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">numpy.array()</li><li id="2004" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.arange()</li><li id="f6f1" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.zeros()</li><li id="70a4" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.ones()</li><li id="834a" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy . testing . assert _ array _ equal()</li><li id="168f" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.dtype()</li><li id="c698" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.random.uniform()</li><li id="c27a" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.asarray()</li><li id="b724" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.empty()</li><li id="b811" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.testing.assert_equal()</li><li id="64ce" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.linspace()</li><li id="448d" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.all()</li><li id="6e4f" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.sum()</li><li id="e44e" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.random.randint()</li><li id="95fc" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.random.rand()</li><li id="a809" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.allclose()</li><li id="7254" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.random.random()</li><li id="a34d" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy . testing . assert _ almost _ equal()</li><li id="9ccd" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.dot()</li><li id="bbf0" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">numpy.testing.assert_allclose()</li></ol><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/aad6ad97e6d1600213425d5e827d42cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFlkVs-0EYT0WSrvk8Jtyg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图一。最常用的NumPy函数(图片由作者提供)</p></figure><p id="a119" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果，我用了18个。我不知道<a class="ae mm" href="https://numpy.org/doc/stable/reference/generated/numpy.allclose.html" rel="noopener ugc nofollow" target="_blank"> numpy.all_close() </a>函数和它的断言变量。看起来很有帮助！</p><p id="9582" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你知道多少？</p><p id="481d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>