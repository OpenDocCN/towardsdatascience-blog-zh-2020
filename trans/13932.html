<html>
<head>
<title>A Cheatsheet for Data Wrangling using Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用熊猫进行数据争论的备忘单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-wrangling-in-pandas-a-downloadable-cheatsheet-84326d255a7b?source=collection_archive---------11-----------------------#2020-09-25">https://towardsdatascience.com/data-wrangling-in-pandas-a-downloadable-cheatsheet-84326d255a7b?source=collection_archive---------11-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7158" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">重要的熊猫</h2><div class=""/><div class=""><h2 id="78d3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">将原始数据转换成函数形式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c5e33b3a722a5b20273bc17c9f198707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4hJ9-Sfz9qEPBMaU4dXYw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/photos/koy6FlCCy5s" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="960b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在获取原始数据之后，数据争论是将原始数据转换为更具功能性的形式以用于数据分析、模型构建和数据可视化的最重要步骤。它涉及预处理、重组和清理操作，最终产品是一个易于访问的格式的数据集，可以随时进行分析和可视化。</p><p id="037f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文的<strong class="lk jd">目的是展示在<a class="ae lh" href="https://pandas.pydata.org" rel="noopener ugc nofollow" target="_blank"> pandas </a>中执行这些任务的一些<strong class="lk jd">关键操作</strong>，pandas 是一个基于python的数据操作工具。这里的想法不是详尽地描述所有可用的pandas操作，而是给初级和中级用户一个基本功能的方便指南。</strong></p><p id="fdd6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章的<strong class="lk jd">内容被分成以下目录。</strong></p><p id="4d3b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">A.数据框架简介</p><ul class=""><li id="fcae" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">创建数据帧</li><li id="41c4" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">从数据帧中检索数据</li><li id="a305" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">汇总数据</li></ul><p id="b6d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">B.数据争论</p><ul class=""><li id="4aac" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">组合数据帧</li><li id="e35a" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">重塑数据帧</li><li id="4e4f" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">处理空值</li></ul><p id="5ddc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意</strong>:除了最上面的图片，所有图片都是作者的，包括最后面的可下载备忘单和代码/代码结果。</p><h1 id="41b0" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">数据框架简介</h1><p id="0b71" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">DataFrame是pandas中最常用的结构化API，用于在行(观察值)和列(变量)中存储数据，就像在表中一样。行标签被称为'<strong class="lk jd">索引</strong>，而列标签被称为'<strong class="lk jd">列</strong>。我们首先讨论定义数据帧的两种最常见的方法。虽然本文中的讨论仅限于二维数据集，但这里讨论的框架完全擅长处理高维数据。</p><h2 id="c558" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">创建数据框架</h2><p id="e33d" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">让我们从定义熊猫数据帧开始，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/c405dcf6692def8576d7cf5526e16d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWJvvhvYy4nVndotPPrxvg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="f0ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该数据帧由三列(<strong class="lk jd">包含三个标记为:col1、col2、col3 </strong>的变量)和三行(<strong class="lk jd">包含三个标记为:1、2和3 </strong>的观察值/索引)组成。定义数据帧最简单的方法是提供一个观察值列表<strong class="lk jd">然后在数据帧中按行排列。<em class="ob"> </em>或者，我们可以提供数据作为一个<strong class="lk jd">字典，每个条目作为数据帧中的一列</strong>。下面是这两种方法的代码。</strong></p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="fceb" class="np mt it od b gy oh oi l oj ok"># Defining DataFrame by specifing a list of observations<br/>df_1= DataFrame([['a', 'b', 'c'],<br/>                 ['d', 'e', 'f'],<br/>                 ['g', 'h', 'i']],<br/>                index = [1,2,3], columns = ['col1', 'col2', 'col3'])</span><span id="7223" class="np mt it od b gy ol oi l oj ok"># Defining DataFrame by specifing a dictionary of columns <br/>df_2= DataFrame({'col1': ['a', 'd', 'g'], <br/>                 'col2': ['b', 'e', 'h'],<br/>                 'col3': ['c', 'f', 'i']}, <br/>                 index = [1,2,3])</span></pre><p id="511c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面定义的<code class="fe om on oo od b">df_1</code>和<code class="fe om on oo od b">df_2</code>是相同的</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5cee7caa1be407a663c23e5dd1022f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*FNIi8l-oA4ehLGiTCQ_FfA.png"/></div></figure><h2 id="c932" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">从数据帧中检索数据</h2><p id="6e92" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">数据帧<code class="fe om on oo od b">df_1</code>中存储的索引标签<strong class="lk jd"> (1，2，3) </strong>、列标签<strong class="lk jd"> (col1，col2，col3) </strong>和数据值<strong class="lk jd"> (a到i) </strong>可以分别使用<code class="fe om on oo od b">df_1.index,</code> <code class="fe om on oo od b">df_1.columns,</code>和<code class="fe om on oo od b">df_1.values</code>进行检索。</p><p id="4f6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于本文的大部分内容，我们将使用Iris数据集，而不是上面定义的3X3数据帧。这个<a class="ae lh" href="https://scikit-learn.org/stable/auto_examples/datasets/plot_iris_dataset.html" rel="noopener ugc nofollow" target="_blank">公开可用的数据集</a>以四种不同参数/变量<strong class="lk jd"> ( <em class="ob">萼片长度、萼片宽度、花瓣长度和花瓣宽度</em> ) </strong>的形式包含关于三种不同品种的鸢尾花<strong class="lk jd"> <em class="ob"> (Setosa、Versicolour和Virginica) </em> </strong>的数据。我们可以使用iris = <code class="fe om on oo od b">pd.read_csv(‘<a class="ae lh" href="https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/mwaskom/seaborndata/master/iris.csv'</a>)</code>导入并保存为熊猫数据帧</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/7312817fa0775b773e233ebc1387951d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCb06bosit0dP1O4nnEtbw.png"/></div></div></figure><p id="3ee7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe om on oo od b">loc</code>是基于<strong class="lk jd">标签的</strong>函数，用于访问特定索引和/或列的数据，并返回为该特定索引/列存储的所有条目。<code class="fe om on oo od b">iris.loc[[0,1]]</code>将返回索引为0和1的行:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/b219056929ca858b14711c0c1f0c5cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5EtL8G8pgrCwWIouEc-TUw.png"/></div></div></figure><p id="ec7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，如果我们只想要标记为0 &amp; 1的行中的某些特定列，我们可以使用<code class="fe om on oo od b"> iris.loc[[0,1], [‘sepal_width’, ‘petal_length’]]</code>来指定列标签和行标签。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/d60696ef535f2e3753928693552ce334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plcnuaDrY24_kZV7qUin2g.png"/></div></div></figure><p id="3ee3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe om on oo od b">iloc</code>是切片数据帧的第二个选项。它基本上与<code class="fe om on oo od b">loc</code>做同样的事情，但是利用<strong class="lk jd">基于整数的位置</strong>来访问数据，而不是索引和列标签。如果我们使用<code class="fe om on oo od b">iris.iloc[1:4,0:3]</code> : <code class="fe om on oo od b">1:4</code>将返回索引为1，2的行&amp; 3在一个基于<strong class="lk jd"> 0的索引</strong>的数据帧<code class="fe om on oo od b">iris</code>中，<code class="fe om on oo od b">0:3</code>将返回索引为0，1 &amp; 2的列。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/64d78b61ef2cbca77c77c84e41e31949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyZW_Q0L27zfP06Um0Fs5w.png"/></div></div></figure><p id="246b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然<code class="fe om on oo od b">loc</code>和<code class="fe om on oo od b">iloc</code>在大多数情况下足以对数据帧进行切片，但是切片方法的完整列表可以在<a class="ae lh" href="https://pandas.pydata.org/docs/user_guide/indexing.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="6d27" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">汇总数据</h2><p id="555b" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">本节列出了一些常用于检查数据帧的操作，以便更好地理解其内容。</p><ul class=""><li id="9f88" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe om on oo od b">iris.head(n)</code>和<code class="fe om on oo od b">iris.tail(n)</code>分别返回数据帧的顶部和底部n行。</li><li id="b530" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><code class="fe om on oo od b">iris.describe()</code>返回数据集中所有数值变量(列)的汇总。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/fcd8e45da23973d6260f33a22aaebaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6tRO32KXdi0Cfet-8v2dg.png"/></div></div></figure><ul class=""><li id="f3c8" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe om on oo od b">iris[‘species’].value_counts() </code>将返回包含变量物种的每个唯一值的行数。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/0348e3bbff0206f00fa413b9e6c98a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6g8bENm4z4Xabtod_9-VaA.png"/></div></div></figure><ul class=""><li id="9f2d" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe om on oo od b">iris[‘sepal_length’].nunique()</code>将返回该列中唯一值的个数，正好是35</li><li id="c240" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">对列或行可以调用的数值运算有:<code class="fe om on oo od b">min()</code>(最小值)<code class="fe om on oo od b">max()</code>(最大值)<code class="fe om on oo od b">var()</code>(方差)<code class="fe om on oo od b">std()</code>(标准差)<code class="fe om on oo od b">sum()</code>(加法)等。</li></ul><h1 id="e0de" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">数据争论</h1><h2 id="c4bc" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">组合数据帧</h2><p id="b819" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">在本节中，我们将讨论两种非常重要的组合数据帧的方法</p><ul class=""><li id="5b38" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe om on oo od b">merge</code>使用一个<strong class="lk jd"> <em class="ob">公共变量作为参考</em> </strong>来组合来自<strong class="lk jd"> <em class="ob">不同数据帧</em> </strong>的观测值</li><li id="75f1" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><code class="fe om on oo od b">groupby</code>至<strong class="lk jd"> <em class="ob">根据参考变量的输入，将数据分组到单个数据帧</em> </strong>中。</li></ul><p id="6674" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们从定义两个数据帧开始，这两个数据帧是使用数据切片的<code class="fe om on oo od b">iloc</code>操作从前面讨论的Iris数据帧中提取的。首先，我们使用<code class="fe om on oo od b">df_1 = iris.iloc[[1,51],3:]</code>对第1行和第51行的最后两列进行切片。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/24cd07fc4d524ad6ae9a0d161127b3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feWBUW8iBDSWxKDRlc5BNw.png"/></div></div></figure><p id="182b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们使用<code class="fe om on oo od b">iris.iloc[[1,51,101],[0,2,4]]</code>定义<code class="fe om on oo od b">df_2</code>，这将为我们提供iris数据库中索引为1、51和101的行的第一、第三和第五列。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/4af0395685298dcc334d4d404a14093c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PE5QKdHr2CRHS5QlFuc64w.png"/></div></div></figure><p id="5993" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe om on oo od b">species</code>作为参考变量<code class="fe om on oo od b">pd.merge(df_1, df_2, how = ‘outer’, on= ‘species’)</code>，操作<code class="fe om on oo od b">merge</code>可以合并这两个数据帧。由于<code class="fe om on oo od b">df_2</code>中提到的物种并不都在<code class="fe om on oo od b">df_1</code>中出现，我们需要使用<code class="fe om on oo od b"> how</code>参数指定哪些物种应该包含在合并的数据帧中。<code class="fe om on oo od b">how = ‘outer’</code>表示两个数据集中任何一个的所有物种都必须包含在合并的数据集中。因为在<code class="fe om on oo od b">df_1</code>中没有物种<code class="fe om on oo od b">virginica</code>的条目，所以它的值是合并数据帧中变量<code class="fe om on oo od b">petal_width</code>的<code class="fe om on oo od b">NaN</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/2be2e57e9e167c609ce78921354d8091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dut16kW78dXr3NjPd4cNzQ.png"/></div></div></figure><p id="1184" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果我们设置了<code class="fe om on oo od b">how = ‘inner’</code>，那么只有那些同时出现在<code class="fe om on oo od b">df_1</code>和<code class="fe om on oo od b">df_2</code>中的物种才会被包含在合并的数据帧中。<code class="fe om on oo od b">pd.merge(df_1, df_2, how = ‘inner’, on= ‘species’) </code>会给:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/8fd1940a78e4879f1cb79a7d989b5107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L7-NiVXmgMlq2dPk0vAKrQ.png"/></div></div></figure><p id="6530" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的文氏图展示了<code class="fe om on oo od b">how</code>参数的使用。两个圆圈中的每一个都代表一个数据帧，阴影区域显示将使其成为合并的数据帧的观察结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/e64dffdcceb7b31a09465d601f269d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*DSQ_zJtXNm0Maj_WIxUS1w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="e494" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们从原始iris数据帧中检索另一个数据帧，这次由8行组成<code class="fe om on oo od b">df_3 = iris.iloc[[1,2,3,4,51,52,53,54],[0,2,4]]</code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/7034156d42ad65415c5b2e136ca168fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZiVutoEZhfhFeqGZL5wR3w.png"/></div></div></figure><p id="d2a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe om on oo od b">groupby</code>操作可用于使用<code class="fe om on oo od b">df_3.groupby(‘species’)</code>拆分和合并<code class="fe om on oo od b">df_3</code>中两个物种(<code class="fe om on oo od b">setosa</code> &amp; <code class="fe om on oo od b">versicolor</code>)的数据。然后，我们可以使用<code class="fe om on oo od b">get_group</code>分别访问两个<code class="fe om on oo od b">species</code>的数据。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="b53b" class="np mt it od b gy oh oi l oj ok">a.get_group('versicolor')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/62b0b97c0c6a531947d03956524c249c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJinNjE2hqoekWG02M3cjg.png"/></div></div></figure><h2 id="69ec" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">重塑数据帧</h2><p id="e51f" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">在本节中，我们将讨论重塑数据的关键操作。让我们从定义数据帧<code class="fe om on oo od b">df_4 = iris.iloc[1:5,0:3]</code>开始</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/8555048ab621b5bf4aac303c16866cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLIPguC1GCRn69hJdRliOQ.png"/></div></div></figure><p id="3379" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">向<code class="fe om on oo od b">df_4</code>添加新列需要指定变量名和相关数据</p><p id="8086" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe om on oo od b">df_4[‘Species’] = [‘versicolor’, ‘versicolor’, ‘setosa’, ‘setosa’] </code>。请注意，列表的维度必须与现有数据帧中的行数相匹配。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/25c39ab74526b16237ef4c3191b3f323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-F29lbw1MHnhMbWhdx1Ag.png"/></div></div></figure><p id="0108" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，为了给这个数据帧添加一行，我们使用前面讨论过的<code class="fe om on oo od b">loc</code>操作。<code class="fe om on oo od b"> df_4.loc[5] = [4.9, 1.4, 1.3, ‘setosa’]</code>将返回:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/6181b9ec7318914e153d178c234e0413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynAPXTW1Y3uDAM2b6jqg7Q.png"/></div></div></figure><p id="dee4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了删除行和列，我们使用了<code class="fe om on oo od b">drop</code>操作。<code class="fe om on oo od b">df_4.drop(‘Species’, axis=1)</code>将删除<code class="fe om on oo od b">Species</code>列，而<code class="fe om on oo od b">df_4.drop(2, axis = 0)</code>将删除索引为2的行。注意，我们在这里指定的是索引和列名，而不是相应的从0开始的索引值。<code class="fe om on oo od b">axis</code>自变量用于区分行和列。0，默认值用于行，1用于列。</p><p id="3133" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以通过指定索引和列标签来同时删除行和列，如<code class="fe om on oo od b">df_4.drop(index = 1, columns = [‘Species’]).</code></p><p id="efb2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要制作包含两个或多个原始数据帧副本的数据帧，我们可以使用<code class="fe om on oo od b">concatenate</code>功能。<code class="fe om on oo od b">pd.concat([df_4,df_4])</code>将加入<code class="fe om on oo od b">df_4</code>如下图所示</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/440783f97c0a7e0661430f30025a3245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIZ37SJ5F_RRn46XrS3eyw.png"/></div></div></figure><p id="6c7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意当两个<code class="fe om on oo od b">df_4</code>副本被连接时，原始数据帧的索引标签是如何被保留的。传递一个额外的参数<code class="fe om on oo od b">ignore_index=True</code>将导致索引标签的范围从0到9。</p><p id="a7a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在接下来的操作中，我们将使用我保存为excel文件并通过<code class="fe om on oo od b">df = pd.read_excel(“weather.xlsx”)</code>导入的数据帧</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/388657acc9905a4e440563c69033a047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POQvGrtQPff0IW48eRNaPA.png"/></div></div></figure><p id="3296" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意这个数据帧的结构。这里有一个单变量<code class="fe om on oo od b">temperature</code>。<code class="fe om on oo od b">Day</code>和<code class="fe om on oo od b">city</code>是两个不同的观察值，因为<code class="fe om on oo od b">temperature</code>是在两个不同的<code class="fe om on oo od b">city</code>(波士顿和纽约市)的五个<code class="fe om on oo od b">Days</code>(周一至周五)记录的。我们可以使用<code class="fe om on oo od b">pivot</code>操作<code class="fe om on oo od b">df.pivot(index = ‘city’, columns= ‘Day’)</code>重新构建该数据帧，给出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/15bdc58b2644110f787cc7a327ef0972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTGRAWWW2M98a-jAY-7OtA.png"/></div></div></figure><p id="dfa7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe om on oo od b">city</code>是这个重新构造的数据帧中的唯一索引，而<code class="fe om on oo od b">Day</code>变量已经被转换成列。这种格式的数据框架更易于阅读，避免了重复的<code class="fe om on oo od b">Day</code>变量，并且两个城市的<code class="fe om on oo od b">temperature</code>值易于比较，因为它们彼此相邻。</p><p id="5497" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了介绍下一个整形操作，让我们导入另一个excel文件作为数据帧。<code class="fe om on oo od b">df_1 = pd.read_excel(‘city_weather.xlsx’)</code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/b9972ee5c7ccd7bbe0864c6f486642c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfPnXESiVZ5RS5tqMSB3oA.png"/></div></div></figure><p id="9119" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该数据帧与我们之前讨论的<code class="fe om on oo od b">df</code>数据帧具有完全相同的数据，尽管格式非常不同。使用<code class="fe om on oo od b">melt</code>操作，我们可以将这个数据帧转换成类似于我们之前从excel文件导入的数据帧。</p><p id="9696" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe om on oo od b">pd.melt(df_1, id_vars = [“day”], var_name = [‘city’], value_name = ’temperature’)</code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/45f69eed55b2bcd399bb60b660ee3d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evvQsgkAH0HABo9NC2VkCw.png"/></div></div></figure><p id="7cdf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe om on oo od b">melt</code>因此，与<code class="fe om on oo od b">pivot</code>在数据帧重组方面的做法相反。</p><p id="b6ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于我们将讨论的最后一个数据重组操作，让我们定义一个自定义数据帧，如下所示:</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="b351" class="np mt it od b gy oh oi l oj ok">df_2 = DataFrame(np.arange(16).reshape(4,4), <br/>                 index = [['A', 'A', 'B', 'B'],['a','b','c','d']],         <br/>                 columns = [[1,1,2,2], [11,11,22,22]])<br/>df_2.index.names = ['Index1', 'Index2']<br/>df_2.columns.names = ['City', 'Town']</span></pre><p id="2096" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码是这样做的:它定义了一个由0到15的整数组成的数据帧，这些整数以<code class="fe om on oo od b">4X4</code>的格式排列。指定了两个不同的索引(<code class="fe om on oo od b">[‘A’, ‘A’, ‘B’, ‘B’]</code> &amp; <code class="fe om on oo od b">[‘a’,’b’,’c’,’d’]</code>)和列(<code class="fe om on oo od b">[1,1,2,2]</code> &amp; <code class="fe om on oo od b">[11,11,22,22]</code>)标签以及每个标签的名称。生成的数据帧如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/85527e371727d082439e999193105680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ySsaUdoufrc_orUc7-oDw.png"/></div></div></figure><p id="7264" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">分层索引和列标签在复杂的数据集中并不少见，尤其是在描述许多不同变量之间的关系时。我们现在可以使用<code class="fe om on oo od b">stack</code>操作来重构这个数据帧。<code class="fe om on oo od b">df_2.stack(level = 0)</code>将在<code class="fe om on oo od b">City</code>变量处重构数据帧，给出:-</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/f604fb7337b60ac21fbe0f6ba0283044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYadNr1uCR0A3YOo7qGzyA.png"/></div></div></figure><p id="5310" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，<code class="fe om on oo od b">df_2.stack(level = 1)</code>将如下转换<code class="fe om on oo od b">Town</code>变量</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/4a3700f23daf3cad993c1befdd348a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByhXwfjqTc_c2wBvPd6oVQ.png"/></div></div></figure><h2 id="7dfb" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">处理空值</h2><p id="f1b5" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">由于缺乏数据可用性，原始数据集通常包含一些空值(<code class="fe om on oo od b">NaN</code>:非数字)。在进行数据建模和可视化之前，需要考虑和替换这些空值。让我们从定义包含5个空值的<code class="fe om on oo od b">df_na_1</code>数据帧开始。</p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="d05e" class="np mt it od b gy oh oi l oj ok">npn = np.nan<br/>df_na_1 = DataFrame([[1, 2, 3, 4], <br/>                     [4, 5, 6, npn], <br/>                     [6, npn, 7, 8], <br/>                     [9, npn, npn, npn]])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/c7108150e140158aaed3c9271d23e547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GS33W7QSW56qXUUqSIMziw.png"/></div></div></figure><p id="4dbc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对该数据帧(<code class="fe om on oo od b">df_na_1.isnull()</code>)调用<code class="fe om on oo od b">isnull</code>操作将为所有空值返回true</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/908f259dbbfb94abc14c33e9566f7390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLlu3nrnG-4Y8gAENRjVlw.png"/></div></div></figure><p id="5eee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们可以使用<code class="fe om on oo od b">dropna </code>操作<code class="fe om on oo od b">df_na_1.dropna()</code>去掉所有具有单个空值的行/观察值，只剩下第一行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/cdb085bffa1e99cec322f368c278ed94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xi56tR-W4zyt5fDcs3Ysg.png"/></div></div></figure><p id="f039" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想删除只有一个空值的列，设置<code class="fe om on oo od b">axis = 1</code> <code class="fe om on oo od b">(df_na_1.dropna(axis=1))</code>，现在我们只剩下第一列。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/691cae663644da7ddef2b4bb9901053c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMKC9c0r5jHK3O0_4kleJQ.png"/></div></div></figure><p id="2d07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以用选择的值代替空值，而不是丢弃它们。使用<code class="fe om on oo od b">df_na_1.fillna({1:100, 2:200, 3:300})</code>,我们可以用不同列的不同值替换空值。标有<code class="fe om on oo od b">1</code>的列中的所有空值都由<code class="fe om on oo od b">100, </code>替换，标有<code class="fe om on oo od b">2 </code>的列由<code class="fe om on oo od b">200 </code>替换，依此类推。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/13c5a32f61d8fed7a8630a9ac7331de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQMjvWNYbpcXmWkrbGlEMg.png"/></div></div></figure><p id="053c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们定义另一个数据帧<code class="fe om on oo od b">df_na_2</code></p><pre class="ks kt ku kv gt oc od oe of aw og bi"><span id="fdb1" class="np mt it od b gy oh oi l oj ok">df_na_2 = DataFrame([[100, 100, 100, 100], <br/>                     [200, 200, 200, 200], <br/>                     [300, 300, 300, 300], <br/>                     [400, 400, 400, 400]])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/b861fec8b29285bd4c25c7f632a65e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgFaRPdRINX_yR8b68KgQg.png"/></div></div></figure><p id="a85a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe om on oo od b">df_na_1.combine_first(df_na_2)</code>,我们可以组合两个数据帧，使得<code class="fe om on oo od b">df_na_1</code>的值为空时，它将被<code class="fe om on oo od b">df_na_2</code>中的相应值替换。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/9be57a53002660d4d18890ca77de8e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1F-s1ZYCdXBKMo2sBHwJew.png"/></div></div></figure><h2 id="8a46" class="np mt it bd mu nq nr dn my ns nt dp nc lr nu nv ne lv nw nx ng lz ny nz ni iz bi translated">下载备忘单</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ps"><img src="../Images/150799f744915d38ab25964f1c3c3ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qc6U4Ww7MUACRm8shDVaIg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="0873" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面显示的备忘单包含了本文中讨论的大部分关键概念，可以从<a class="ae lh" href="https://github.com/Aseem139/pandas_cheatsheet/blob/master/Pandas_Cheatsheet_Medium.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>下载。为了简洁起见，在cheetsheet中不可能给出详细的解释，所以请参考本文的正文。感谢阅读。</p></div></div>    
</body>
</html>