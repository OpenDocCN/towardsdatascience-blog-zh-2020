<html>
<head>
<title>Bayesian Inference of Mock NBA Draft Order</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模拟NBA选秀顺序的贝叶斯推理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bayesian-inference-of-mock-nba-draft-order-f4fa4a26be17?source=collection_archive---------52-----------------------#2020-11-09">https://towardsdatascience.com/bayesian-inference-of-mock-nba-draft-order-f4fa4a26be17?source=collection_archive---------52-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="68b2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用优步概率编程库Pyro对NBA选秀顺序进行建模</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><p id="6946" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们许多密切关注NBA选秀的人都渴望知道选秀的准确顺序，例如每个球员将被带到哪里(“哪里”在这里有双重含义，球队和选秀位置)。为此，我们通常会从十几份甚至更多的“重要”模拟草稿中吸取信息。分析师和媒体试图以不同的方式将这些信息整合成我喜欢称之为“元模拟”的东西。一般来说，这只涉及非常简单的操作，如平均排名或查看最小和最大吃水位置。Chris Feller前几天分享了一个非常酷的生存分析方法。我还没有深入研究它，但是和我在这里做的事情相比会很有趣。</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="d00c" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我想做的是为模拟草稿创建一个生成元模型，这与使用生存分析略有不同，但可以产生类似的见解，我将在后面展示。理论上，这使得人们能够从等级排序中推断出一些“价值”的度量(我没有发现模拟选秀给玩家分配数字评级)，然后从后验分布中生成随机模拟选秀顺序。换句话说，就像Nate Silver运行模拟来预测谁将赢得选举一样，我们可以为模拟草案创建一个模拟，并在其中做各种各样的事情。让我告诉你怎么做！</p><p id="061e" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们首先需要的是对等级数据有意义的概率分布。向<a class="ae lp" href="https://cran.rstudio.com/web/packages/PlackettLuce/vignettes/Overview.html" rel="noopener ugc nofollow" target="_blank"> Plackett-Luce分布</a>问好。基本思想是，如果你有一些集合<em class="lq"> S </em>的项目，每个项目都有一些“价值”<em class="lq"> w_i </em>你可以在一些向量中的这些项目的任意排列的排名上生成一个概率分布。我不会向您展示这些方程(参见参考资料)，但我可以向您展示一个非常简单的模拟来快速理解这个想法。首先我们需要导入一些包并定义PL发行版，我发现有人已经在github <a class="ae lp" href="https://github.com/agadetsky/pytorch-pl-variance-reduction" rel="noopener ugc nofollow" target="_blank">这里</a>上实现了。这里的工作都是使用优步开源的<a class="ae lp" href="http://pyro.ai/" rel="noopener ugc nofollow" target="_blank"> Pyro概率编程语言</a>完成的，它是基于<a class="ae lp" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank">脸书的PyTorch </a>深度学习库构建的。</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="2cb1" class="lw lx iq ls b gy ly lz l ma mb"><strong class="ls ir">import</strong> <strong class="ls ir">random</strong><br/><br/><strong class="ls ir">import</strong> <strong class="ls ir">pandas</strong> <strong class="ls ir">as</strong> <strong class="ls ir">pd</strong><br/><strong class="ls ir">import</strong> <strong class="ls ir">numpy</strong> <strong class="ls ir">as</strong> <strong class="ls ir">np</strong><br/><br/><strong class="ls ir">import</strong> <strong class="ls ir">torch</strong><br/><strong class="ls ir">from</strong> <strong class="ls ir">pyro.infer.autoguide</strong> <strong class="ls ir">import</strong> AutoDiagonalNormal <br/><strong class="ls ir">from</strong> <strong class="ls ir">pyro.infer</strong> <strong class="ls ir">import</strong> SVI, Trace_ELBO, Predictive<br/><strong class="ls ir">from</strong> <strong class="ls ir">pyro.distributions.distribution</strong> <strong class="ls ir">import</strong> Distribution<br/><strong class="ls ir">from</strong> <strong class="ls ir">torch.distributions</strong> <strong class="ls ir">import</strong> constraints<br/><strong class="ls ir">from</strong> <strong class="ls ir">pyro.distributions.torch_distribution</strong> <strong class="ls ir">import</strong> TorchDistributionMixin, TorchDistribution<br/><strong class="ls ir">import</strong> <strong class="ls ir">pyro.distributions</strong> <strong class="ls ir">as</strong> <strong class="ls ir">dist</strong><br/><strong class="ls ir">import</strong> <strong class="ls ir">pyro</strong><br/><strong class="ls ir">import</strong> <strong class="ls ir">seaborn</strong> <strong class="ls ir">as</strong> <strong class="ls ir">sns</strong></span><span id="f9b6" class="lw lx iq ls b gy mc lz l ma mb"><em class="lq"># some utilities defined in https://github.com/agadetsky/pytorch-pl-variance-reduction/blob/master/utils.py</em><br/><br/><strong class="ls ir">def</strong> logcumsumexp(x, dim):<br/>    <em class="lq"># slow implementation, but ok for now</em><br/>    <strong class="ls ir">if</strong> (dim != -1) <strong class="ls ir">or</strong> (dim != x.ndimension() - 1):<br/>        x = x.transpose(dim, -1)<br/><br/>    out = []<br/>    <strong class="ls ir">for</strong> i <strong class="ls ir">in</strong> range(1, x.size(-1) + 1):<br/>        out.append(torch.logsumexp(x[..., :i], dim=-1, keepdim=<strong class="ls ir">True</strong>))<br/>    out = torch.cat(out, dim=-1)<br/><br/>    <strong class="ls ir">if</strong> (dim != -1) <strong class="ls ir">or</strong> (dim != x.ndimension() - 1):<br/>        out = out.transpose(-1, dim)<br/>    <strong class="ls ir">return</strong> out<br/><br/><br/><strong class="ls ir">def</strong> reverse_logcumsumexp(x, dim):<br/>    <strong class="ls ir">return</strong> torch.flip(logcumsumexp(torch.flip(x, dims=(dim, )), dim), dims=(dim, ))<br/><br/><strong class="ls ir">def</strong> smart_perm(x, permutation):<br/>    <strong class="ls ir">assert</strong> x.size() == permutation.size()<br/>    <strong class="ls ir">if</strong> x.ndimension() == 1:<br/>        ret = x[permutation]<br/>    <strong class="ls ir">elif</strong> x.ndimension() == 2:<br/>        d1, d2 = x.size()<br/>        ret = x[<br/>            torch.arange(d1).unsqueeze(1).repeat((1, d2)).flatten(),<br/>            permutation.flatten()<br/>        ].view(d1, d2)<br/>    <strong class="ls ir">elif</strong> x.ndimension() == 3:<br/>        d1, d2, d3 = x.size()<br/>        ret = x[<br/>            torch.arange(d1).unsqueeze(1).repeat((1, d2 * d3)).flatten(),<br/>            torch.arange(d2).unsqueeze(1).repeat((1, d3)).flatten().unsqueeze(0).repeat((1, d1)).flatten(),<br/>            permutation.flatten()<br/>        ].view(d1, d2, d3)<br/>    <strong class="ls ir">else</strong>:<br/>        <strong class="ls ir">ValueError</strong>("Only 3 dimensions maximum")<br/>    <strong class="ls ir">return</strong> ret</span><span id="cb08" class="lw lx iq ls b gy mc lz l ma mb"><strong class="ls ir">class</strong> <strong class="ls ir">PlackettLuce</strong>(Distribution):<br/>    <em class="lq">"""</em><br/><em class="lq">        Plackett-Luce distribution</em><br/><em class="lq">    """</em><br/>    arg_constraints = {"logits": constraints.real}<br/><br/>    <strong class="ls ir">def</strong> __init__(self, logits):<br/>        <em class="lq"># last dimension is for scores of plackett luce</em><br/>        super(PlackettLuce, self).__init__()<br/>        self.logits = logits<br/>        self.size = self.logits.size()<br/><br/>    <strong class="ls ir">def</strong> sample(self, sample_shape=torch.Size()):<br/>        <em class="lq"># sample permutations using Gumbel-max trick to avoid cycles</em><br/>        <strong class="ls ir">with</strong> torch.no_grad():<br/>            logits = self.logits.unsqueeze(0).expand(sample_shape, *self.size)<br/>            u = torch.distributions.utils.clamp_probs(torch.rand_like(logits))<br/>            z = self.logits - torch.log(-torch.log(u))<br/>            samples = torch.sort(z, descending=<strong class="ls ir">True</strong>, dim=-1)[1]<br/>        <strong class="ls ir">return</strong> samples<br/><br/>    <strong class="ls ir">def</strong> log_prob(self, samples):<br/>        <em class="lq"># samples shape is: num_samples x self.size</em><br/>        <em class="lq"># samples is permutations not permutation matrices</em><br/>        <strong class="ls ir">if</strong> samples.ndimension() == self.logits.ndimension():  <em class="lq"># then we already expanded logits</em><br/>            logits = smart_perm(self.logits, samples)<br/>        <strong class="ls ir">elif</strong> samples.ndimension() &gt; self.logits.ndimension():  <em class="lq"># then we need to expand it here</em><br/>            logits = self.logits.unsqueeze(0).expand(*samples.size())<br/>            logits = smart_perm(logits, samples)<br/>        <strong class="ls ir">else</strong>:<br/>            <strong class="ls ir">raise</strong> <strong class="ls ir">ValueError</strong>("Something wrong with dimensions")<br/>        logp = (logits - reverse_logcumsumexp(logits, dim=-1)).sum(-1)<br/>        <strong class="ls ir">return</strong> logp</span></pre><p id="af2d" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">好，让我们做一个小模拟。很简单。想象一下，我们有5名赛车手。我们将使用指数分布生成一些“价值”向量。我们看到，到目前为止，驾驶员3的评分最高，驾驶员0的评分最低。给定这些参数，然后我们使用PL分布生成“种族”的随机样本。我们这样做10次。</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="f9a6" class="lw lx iq ls b gy ly lz l ma mb">n_drivers = 5<br/>torch.manual_seed(39)<br/>theta = dist.Exponential(0.1).sample((n_drivers,))<br/>ranks = list(zip(range(n_drivers),theta.numpy()))<br/>[print(f'driver <strong class="ls ir">{</strong>i<strong class="ls ir">}</strong>: <strong class="ls ir">{</strong>j<strong class="ls ir">:</strong>0.3<strong class="ls ir">}</strong>') <strong class="ls ir">for</strong> i, j <strong class="ls ir">in</strong> sorted(ranks,key=<strong class="ls ir">lambda</strong> x: -x[1])]<br/>pl = PlackettLuce(theta)<br/>data = pl.sample(10)<br/>print(data.numpy())</span><span id="05eb" class="lw lx iq ls b gy mc lz l ma mb"># output<br/>driver 3: 31.7<br/>driver 4: 23.0<br/>driver 2: 2.02<br/>driver 1: 1.02<br/>driver 0: 0.294<br/>[[3 4 1 2 0]<br/> [3 4 1 2 0]<br/> [3 4 2 0 1]<br/> [3 4 2 1 0]<br/> [3 4 2 1 0]<br/> [3 4 1 0 2]<br/> [3 4 2 1 0]<br/> [3 4 1 2 0]<br/> [3 4 2 1 0]<br/> [3 4 0 2 1]]</span></pre><p id="0caf" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">你可以看到，在我们所有的10场模拟比赛中，3号和4号车手分别获得了1号和2号。</p><p id="8c86" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，让我们做同样的模拟，但增加指数率参数，使驱动器更“均匀”。</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="a797" class="lw lx iq ls b gy ly lz l ma mb">n_drivers = 5<br/>torch.manual_seed(39)<br/>theta = dist.Exponential(1.0).sample((n_drivers,))<br/>ranks = list(zip(range(n_drivers),theta.numpy()))<br/>[print(f'driver <strong class="ls ir">{</strong>i<strong class="ls ir">}</strong>: <strong class="ls ir">{</strong>j<strong class="ls ir">:</strong>0.3<strong class="ls ir">}</strong>') <strong class="ls ir">for</strong> i, j <strong class="ls ir">in</strong> sorted(ranks,key=<strong class="ls ir">lambda</strong> x: -x[1])]<br/>pl = PlackettLuce(theta)<br/>data = pl.sample(10)<br/>print(data.numpy())</span><span id="f507" class="lw lx iq ls b gy mc lz l ma mb">#output<br/>driver 3: 3.17<br/>driver 4: 2.3<br/>driver 2: 0.202<br/>driver 1: 0.102<br/>driver 0: 0.0294<br/>[[1 4 3 2 0]<br/> [3 1 4 2 0]<br/> [3 4 2 0 1]<br/> [4 3 2 0 1]<br/> [4 3 2 1 0]<br/> [3 4 0 1 2]<br/> [3 4 2 0 1]<br/> [3 4 1 2 0]<br/> [3 4 2 0 1]<br/> [4 0 3 2 1]]</span></pre><p id="6f09" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">你可以看到现在车手4赢得了一些比赛，甚至车手1也站在了领奖台上。太棒了。希望这开始对你有意义。我们基本上准备好了。我们只需要读入一些数据，创建模型，做一些推断。我们开始吧！</p><p id="06df" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我从17个公开的模拟草稿中收集了数据。然而，并非所有的草案都模拟了两轮投票。这是可以的，因为即使在一个回合中仍然有有用的信息。我将很快解释我是如何处理这个问题的，但是让我们先看看数据。</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="cb8d" class="lw lx iq ls b gy ly lz l ma mb">df = pd.read_csv('data/mock-drafts.csv')<br/>df.head()</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/058ccd2d26affd1c450579ad5272b031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23cdc02hcDab1SUvHWsxxg.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="e1e3" class="lw lx iq ls b gy ly lz l ma mb">cols = df.columns[1:]<br/>players_set = set()<br/><strong class="ls ir">for</strong> col <strong class="ls ir">in</strong> cols:<br/>    <strong class="ls ir">for</strong> player <strong class="ls ir">in</strong> df[col].values:<br/>        players_set.add(player)<br/>players = {player:idx <strong class="ls ir">for</strong> idx,player <strong class="ls ir">in</strong> enumerate(players_set) <strong class="ls ir">if</strong> type(player) <strong class="ls ir">is</strong> str}<br/>player_lut = {idx:player <strong class="ls ir">for</strong> player,idx <strong class="ls ir">in</strong> players.items() <strong class="ls ir">if</strong> type(player) <strong class="ls ir">is</strong> str}<br/>print(player_lut)</span><span id="8a5b" class="lw lx iq ls b gy mc lz l ma mb"># output<br/>{1: 'Kira Lewis', 2: 'Udoka Azubuike', 3: 'Tyrell Terry', 4: 'Saben Lee', 5: 'Aleksej Pokusevski', 6: 'Cassius Winston', 7: 'Austin Wiley', 8: 'Devon Dotson', 9: 'Naji Marshall', 10: 'Nick Richards', 11: 'Yam Madar', 12: 'Zeke Nnaji', 13: 'Kaleb Wesson', 14: 'Mason Jones', 15: 'Patrick Williams', 16: 'James Wiseman', 17: 'Tyrese Haliburton', 18: 'Theo Maledon', 19: 'LaMelo Ball', 20: 'Tyrique Jones', 21: 'Ty-Shon Alexander', 22: 'Vernon Carey', 23: 'Reggie Perry', 24: 'Xavier Tillman', 25: 'Filip Petrusev', 26: 'Leandro Bolmaro', 27: 'Josh Green', 28: 'Abdoulaye Ndoye', 29: 'Killian Hayes', 30: 'Tyler Bey', 31: 'Isaiah Stewart', 32: 'Lamine Diane', 33: 'Desmond Bane', 34: 'Lamar Stevens', 35: 'Aaron Nesmith', 36: 'Tyrese Maxey', 37: 'Anthony Edwards', 38: 'Yoeli Childs', 39: 'Omer Yurtseven', 40: 'Borisa Simanic', 41: 'Justinian Jessup', 42: 'Malachi Flynn', 43: 'Jahmius Ramsey', 44: 'Obi Toppin', 45: 'Markus Howard', 46: 'Tre Jones', 47: 'Robert Woodard', 48: 'Nate Hinton', 49: 'Isaac Okoro', 50: 'Cole Anthony', 51: 'Jaden McDaniels', 52: 'Jordan Nwora', 53: 'Deni Avdija', 54: 'Jalen Harris', 55: 'Rokas Jokubaitis', 56: 'Paul Reed', 57: 'Jay Scrubb', 58: 'Ashton Hagans', 59: 'Jalen Smith', 60: 'Kristian Doolittle', 61: 'Henri Drell', 62: 'CJ Elleby', 63: 'Isaiah Joe', 64: 'Paul Eboua', 65: 'Killian Tillie', 66: 'Kenyon Martin', 67: 'RJ Hampton', 68: 'Immanuel Quickley', 69: 'Sam Merrill', 70: 'Onyeka Okongwu', 71: 'Grant Riller', 72: 'Payton Pritchard', 73: 'Skylar Mays', 74: 'Karim Mane', 75: 'Giorgos Kalaitzakis', 76: 'Mamadi Diakite', 77: 'Nico Mannion', 78: 'Saddiq Bey', 79: 'Marko Simonovic', 80: 'Paul Ebouta', 81: 'Precious Achiuwa', 82: 'Cassius Stanley', 83: 'Daniel Oturu', 84: 'Elijah Hughes', 85: 'Josh Hall', 86: 'Devin Vassell'}</span></pre><p id="6c2d" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">正如你所看到的，在这些模拟选秀中共有86名选手。现在我们将把模拟放入Pyro可以理解的数据格式中，一个包含17行的Torch张量。每一排将有所有86名球员在一些排列。现在我可以解释我是如何填充每个模拟的，这样无论一个模拟有30个还是60个玩家，每个都将被填充以包含所有的86个玩家。我假设一些非常简单的事情:如果一个模拟没有一个玩家，那么每个其他玩家可以被随机洗牌以填充整个模拟到位置86。这是我能做的最简单的方法。更高级的方法是从这样的随机化开始，然后用基于模型推断评级的随机顺序来细化“反事实”填充。人们可以像这样不断迭代，直到达到某种平衡(基本上直到不再有改进)。</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="6992" class="lw lx iq ls b gy ly lz l ma mb"><strong class="ls ir">import</strong> <strong class="ls ir">random</strong><br/>n_players = len(player_lut)<br/>list_data = []<br/><strong class="ls ir">for</strong> col <strong class="ls ir">in</strong> cols:<br/>    mock = df[col]<br/>    ranks = []<br/>    players_cp = players.copy()<br/>    <strong class="ls ir">for</strong> i <strong class="ls ir">in</strong> range(1,n_players+1):<br/>        <strong class="ls ir">try</strong>:<br/>            player = mock[i-1]<br/>            players_cp.pop(player)<br/>            ranks.append(players[player])<br/>        <strong class="ls ir">except</strong> <strong class="ls ir">KeyError</strong>: <br/>            random_player = random.choice(list(players_cp.keys()))<br/>            <strong class="ls ir">if</strong> players_cp.pop(random_player):<br/>                ranks.append(players[random_player])<br/>    list_data.append(ranks)<br/>data = torch.tensor(list_data)-1<br/>print(data)</span><span id="d6d8" class="lw lx iq ls b gy mc lz l ma mb"># output<br/>tensor([[18, 15, 36,  ..., 44, 73,  6],<br/>        [36, 52, 15,  ...,  8, 53, 78],<br/>        [18, 16, 36,  ..., 75, 61, 63],<br/>        ...,<br/>        [18, 15, 36,  ..., 31,  3,  6],<br/>        [36, 18, 69,  ..., 72, 51, 63],<br/>        [36, 15, 18,  ..., 37, 44, 19]])</span></pre><p id="1bc4" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们看看其中的一行:</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="c999" class="lw lx iq ls b gy ly lz l ma mb">[player_lut[i+1] <strong class="ls ir">for</strong> i <strong class="ls ir">in</strong> data.numpy()[0]][0:10]</span><span id="de55" class="lw lx iq ls b gy mc lz l ma mb"># output<br/>['LaMelo Ball',<br/> 'James Wiseman',<br/> 'Anthony Edwards',<br/> 'Deni Avdija',<br/> 'Obi Toppin',<br/> 'Tyrese Haliburton',<br/> 'Isaac Okoro',<br/> 'Devin Vassell',<br/> 'Onyeka Okongwu',<br/> 'Killian Hayes']</span></pre><p id="3211" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">好了，现在是激动人心的部分。让我们定义模型:</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="bff3" class="lw lx iq ls b gy ly lz l ma mb">n_players = 86<br/><br/><strong class="ls ir">def</strong> model(data):<br/>    sigma = pyro.sample("sigma", dist.Uniform(0,1))<br/>    theta = pyro.sample("theta", dist.Cauchy(torch.zeros(n_players,),sigma*torch.ones(n_players,)))<br/>    <strong class="ls ir">with</strong> pyro.plate("data", data.shape[-2]):<br/>        pyro.sample("obs", PlackettLuce(theta), obs=data)</span></pre><p id="a2d1" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">真的就是这样。我使用柯西分布，因为如果你考虑NBA人才的分布，它似乎是“厚尾”的。换句话说，我们希望我们的模型能够处理有“超级明星”或一致同意的最佳人选的情况。如果我们让我们的分布过于平坦，这将更像一场赛马，任何一匹马都有机会第一个到达终点(或多或少)。现在我们进行推理步骤，根据Pyro的说法建立一个向导和优化器来进行随机变分推理(在未来，我计划研究更精确的MCMC采样方法，但是现在应该可以了)。</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="e8f3" class="lw lx iq ls b gy ly lz l ma mb">guide = AutoDiagonalNormal(model)<br/>adam = pyro.optim.Adam({"lr": 0.03})<br/>svi = SVI(model, guide, adam, loss=Trace_ELBO())<br/>pyro.clear_param_store()<br/><strong class="ls ir">for</strong> j <strong class="ls ir">in</strong> range(5000):<br/>    <em class="lq"># calculate the loss and take a gradient step</em><br/>    loss = svi.step(data)<br/>    <strong class="ls ir">if</strong> j % 100 == 0:<br/>        print("[iteration <strong class="ls ir">%04d</strong>] loss: <strong class="ls ir">%.4f</strong>" % (j + 1, loss / data.shape[-2]))</span></pre><p id="b53f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这是我们元模拟的结果！</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="4876" class="lw lx iq ls b gy ly lz l ma mb">1. Anthony Edwards (12.2)<br/>2. LaMelo Ball (12.0)<br/>3. Deni Avdija (10.3)<br/>4. James Wiseman (10.3)<br/>5. Obi Toppin (9.9)<br/>6. Onyeka Okongwu (8.0)<br/>7. Killian Hayes (7.9)<br/>8. Tyrese Haliburton (7.6)<br/>9. Isaac Okoro (7.6)<br/>10. Devin Vassell (6.7)<br/>11. Patrick Williams (6.0)<br/>12. Aaron Nesmith (5.2)<br/>13. Saddiq Bey (4.7)<br/>14. Kira Lewis (4.6)<br/>15. Precious Achiuwa (4.5)<br/>16. RJ Hampton (4.1)<br/>17. Jalen Smith (4.0)<br/>18. Cole Anthony (3.9)<br/>19. Tyrese Maxey (3.7)<br/>20. Josh Green (3.0)<br/>21. Aleksej Pokusevski (2.6)<br/>22. Leandro Bolmaro (2.4)<br/>23. Isaiah Stewart (2.3)<br/>24. Jaden McDaniels (2.2)<br/>25. Theo Maledon (2.0)<br/>26. Jahmius Ramsey (1.7)<br/>27. Tyrell Terry (1.6)<br/>28. Desmond Bane (1.3)<br/>29. Nico Mannion (1.2)<br/>30. Zeke Nnaji (1.1)<br/>31. Malachi Flynn (1.0)<br/>32. Tre Jones (0.9)<br/>33. Devon Dotson (0.8)<br/>34. Paul Reed (0.5)<br/>35. Vernon Carey (0.5)<br/>36. Isaiah Joe (0.5)<br/>37. Elijah Hughes (0.5)<br/>38. Cassius Stanley (0.5)<br/>39. Daniel Oturu (0.4)<br/>40. Killian Tillie (0.4)<br/>41. Cassius Winston (0.4)<br/>42. Grant Riller (0.3)<br/>43. Udoka Azubuike (0.3)<br/>44. Tyler Bey (0.3)<br/>45. Reggie Perry (0.2)<br/>46. Xavier Tillman (0.2)<br/>47. Payton Pritchard (0.1)<br/>48. Jay Scrubb (0.1)<br/>49. Abdoulaye Ndoye (0.1)<br/>50. Immanuel Quickley (-0.0)<br/>51. Ty-Shon Alexander (-0.0)<br/>52. Ashton Hagans (-0.0)<br/>53. Jordan Nwora (-0.1)<br/>54. Robert Woodard (-0.1)<br/>55. Nick Richards (-0.1)<br/>56. Yam Madar (-0.1)<br/>57. Skylar Mays (-0.2)<br/>58. Nate Hinton (-0.2)<br/>59. Paul Ebouta (-0.2)<br/>60. Filip Petrusev (-0.3)<br/>61. Justinian Jessup (-0.3)<br/>62. Lamar Stevens (-0.3)<br/>63. Marko Simonovic (-0.3)<br/>64. Sam Merrill (-0.3)<br/>65. Josh Hall (-0.4)<br/>66. Karim Mane (-0.4)<br/>67. Kaleb Wesson (-0.4)<br/>68. Kristian Doolittle (-0.5)<br/>69. Tyrique Jones (-0.5)<br/>70. Borisa Simanic (-0.5)<br/>71. Markus Howard (-0.5)<br/>72. Kenyon Martin (-0.5)<br/>73. CJ Elleby (-0.6)<br/>74. Rokas Jokubaitis (-0.6)<br/>75. Lamine Diane (-0.6)<br/>76. Yoeli Childs (-0.6)<br/>77. Jalen Harris (-0.6)<br/>78. Mason Jones (-0.7)<br/>79. Paul Eboua (-0.7)<br/>80. Saben Lee (-0.7)<br/>81. Mamadi Diakite (-0.7)<br/>82. Omer Yurtseven (-0.8)<br/>83. Henri Drell (-0.8)<br/>84. Austin Wiley (-0.8)<br/>85. Naji Marshall (-0.8)<br/>86. Giorgos Kalaitzakis (-0.9)</span></pre><p id="f617" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">好吧，还不错，但这还不是最酷的部分。最酷的部分是现在我们有了每个玩家的概率分布，所以我们可以去模拟成千上万的模拟选秀。我们开始吧！基本上，我们只是对后验分布进行采样(来自Pyro guide函数),并生成一个样本模拟汇票订单。然后我们做那10，000(！)次，并将它们全部放入熊猫数据框中。</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="a23e" class="lw lx iq ls b gy ly lz l ma mb">rank_hist = []<br/><strong class="ls ir">for</strong> m <strong class="ls ir">in</strong> range(10_000):<br/>    theta = guide.forward()['theta']<br/>    pl = PlackettLuce(theta)<br/>    sample = pl.sample(1).numpy()[0]<br/>    <strong class="ls ir">for</strong> i, j <strong class="ls ir">in</strong> enumerate(sample.squeeze()):<br/>        <strong class="ls ir">if</strong> i&lt;=59:<br/>            rank_hist.append((i+1,player_lut[j+1]))<br/>        <strong class="ls ir">else</strong>:<br/>            rank_hist.append((61,player_lut[j+1]))<br/>rank_df = pd.DataFrame.from_records(rank_hist,columns=['rank','player'])</span></pre><p id="70ad" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">所以现在我们有了每个球员的模拟选秀位置的分布(直方图)。例如，让我们看看安东尼·爱德华兹是在哪里被预言的:</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="9a47" class="lw lx iq ls b gy ly lz l ma mb">sns.set_style("ticks", {"xtick.minor.size": 1, "ytick.major.size": 8})<br/>players = ['Anthony Edwards']<br/>sns.displot(data=rank_df[rank_df.player.isin(players)],x='rank',kind='hist',hue='player')</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/59907990405a90116a7f01577c907757.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*sSIKBB__3sLRnJ8fKopzMg.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="f9d4" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">理解这种分布的一个更简单的方法是看累积概率。还记得我说过这个模型可以以类似生存分析的方式使用吗？这就是我所说的:</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="9453" class="lw lx iq ls b gy ly lz l ma mb">sns.set_style("ticks", {"xtick.minor.size": 1, "ytick.major.size": 8})<br/>players = ['Anthony Edwards']<br/>sns.displot(data=rank_df[rank_df.player.isin(players)],x='rank',kind='ecdf',hue='player')</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1477562b80772ab0138d541c8078ad04.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*ec8-QCk0impUOoJrFJqkkQ.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="6f65" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">从这里我们看到爱德华兹有大约45%的机会被选为第一名，大约80%的机会进入前两名，以此类推。相当整洁！现在让我们来看看一个预测范围更广的人，Saddiq Bey:</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="7320" class="lw lx iq ls b gy ly lz l ma mb">sns.set_style("ticks", {"xtick.minor.size": 1, "ytick.major.size": 8})<br/>players = ['Saddiq Bey']<br/>sns.displot(data=rank_df[rank_df.player.isin(players)],x='rank',kind='ecdf',hue='player')</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/2d1d21e61dad9fba154d3cf9b541980b.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*8zE6Y_CtiRYdsN8ID0VKbQ.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="ae09" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">哦，那不是很酷吗？确实范围很广。让我们来看看一个更加边缘的球员，尼克·理查兹:</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="846e" class="lw lx iq ls b gy ly lz l ma mb">sns.set_style("ticks", {"xtick.minor.size": 1, "ytick.major.size": 8})<br/>players = ['Nick Richards']<br/>sns.displot(data=rank_df[rank_df.player.isin(players)],x='rank',kind='ecdf',hue='player')</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/8f665a79d57edb8f1db0b77db660948a.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*F2XzCNs2IFyc1Y8h4vnblA.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="5081" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">好的，所以我应该解释一下，在模拟中，如果一个球员没有被选进前60，我就把他放在61，这样他基本上就是一个未被选中的自由球员(UDFA)。这些图有点乱，但在我完成之前，这里有一个图表中有前10名的人。</p><pre class="li lj lk ll gt lr ls lt lu aw lv bi"><span id="3d39" class="lw lx iq ls b gy ly lz l ma mb">sns.set_style("ticks", {"xtick.minor.size": 1, "ytick.major.size": 8})<br/>players = ['Anthony Edwards', 'LaMelo Ball', 'Deni Avdija', 'James Wiseman', 'Obi Toppin', 'Onyeka Okongwu',<br/>          'Killian Hayes', 'Tyrese Haliburton', 'Isaac Okoro', 'Devin Vassell']<br/>sns.displot(data=rank_df[rank_df.player.isin(players)],x='rank',kind='ecdf',hue='player')</span></pre><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/6db7cf1b3cbcb5296990adf406cfe315.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*KMHsZ0tkgDXoeCN64jiJZQ.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="ca5e" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">嗯，我现在就知道这么多了。随着选秀临近(11月18日)，请(通过我的推特)关注更多与此相关的事情。如果你有任何建议(或修正)让我知道！以下是该项目的github repo的链接:</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="ln lo l"/></div></figure></div></div>    
</body>
</html>