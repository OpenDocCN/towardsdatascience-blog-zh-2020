<html>
<head>
<title>New Features in Python 3.10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.10中的新功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/new-features-in-python-3-10-66ac05e62fc7?source=collection_archive---------3-----------------------#2020-11-11">https://towardsdatascience.com/new-features-in-python-3-10-66ac05e62fc7?source=collection_archive---------3-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6096" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看Python最新版本中包含的最佳特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b8eab34d92201fdf6e7b1341fbf99072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3WmfPeAMznHUgY70"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@benjaminsweet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本·斯威特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="327f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">Python 3.10的第二个alpha版本于11月初发布，通过它，我们可以一窥Python的未来。</p><p id="9d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些令人兴奋的举措正在实施，这些举措可能会将未来的Python生态系统改变为更明确、更可读的代码——同时保持我们都知道和喜爱的易用性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/caa9c6d1bf09c516c2934bb2d3ee7d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGuJF-KUoWSi_GEXrx0iyA.png"/></div></div></figure><p id="d538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于新的年度发布时间表[ <a class="ae ky" href="https://www.python.org/dev/peps/pep-0602/" rel="noopener ugc nofollow" target="_blank"> PEP 602 </a> ]，我们现在可以看到更短的开发窗口，这意味着我们可以在2021年10月预期的许多功能已经以某种形式出现，我们将涵盖迄今为止的所有新功能:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="424b" class="mk ml it mg b gy mm mn l mo mp"><strong class="mg iu">Further Extensions to Type Annotations</strong><br/>  - Postponed Evaluation of Annotations<br/>  - Type Union Operator<br/>  - TypeAlias Annotation</span><span id="0111" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg iu">Why Typing is Important</strong></span><span id="3908" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg iu">New Methods and Behaviors<br/> </strong> - Equal Length Flag for zip()<br/>  - Bit Count for Integers<br/>  - Mapping for Dictionary Views</span></pre><p id="585c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您更喜欢视频，我们在这里涵盖了本文中的所有内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f3cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mt">*所有文章图片均由作者制作，除非另有说明。</em></p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="b65a" class="nb ml it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">类型注释的进一步扩展</h1><p id="7eab" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">版本3.9引入了对Python中的类型提示和注释的大检修和清理。这看起来像是一个持续的趋势，在3.10中会进一步增加输入功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/a2bcfadb9cdd2eec3842eed72ea307e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xxv_IwtuIoYXL6WwXA53wA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从Python 3.0到现在类型注释的变化时间表。</p></figure><h2 id="0b77" class="mk ml it bd nc ny nz dn ng oa ob dp nk li oc od nm lm oe of no lq og oh nq oi bi translated">1.注释的延期评估</h2><p id="a970" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">类型注释的计算总是在函数定义时执行，这意味着类型注释是以自顶向下的方式逐行计算的。</p><p id="13ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这看起来合乎逻辑，但这样做有两个问题:</p><ul class=""><li id="63b9" class="oj ok it lb b lc ld lf lg li ol lm om lq on lu oo op oq or bi translated">引用尚未定义的类型的类型提示(前向引用)不起作用，必须表示为字符串。我们将需要编写<code class="fe os ot ou mg b">"int"</code>而不是<code class="fe os ot ou mg b">int</code>(尽管这只适用于<em class="mt">自定义</em>，而不是<em class="mt">内置/预定义</em>类型)。</li><li id="f41e" class="oj ok it lb b lc ov lf ow li ox lm oy lq oz lu oo op oq or bi translated">它降低了模块导入的速度，因为那时会执行类型提示。</li></ul><p id="36d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，相反，注释将存储在<code class="fe os ot ou mg b">__annotations__</code>中，对它们的评估可以一起执行——允许前向引用并首先执行模块导入(减少初始化时间)。</p><h2 id="1f84" class="mk ml it bd nc ny nz dn ng oa ob dp nk li oc od nm lm oe of no lq og oh nq oi bi translated">2.类型联合运算符</h2><p id="a923" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">3.10引入了带有|操作符的条件逻辑。在注释数据类型时，我们可以将|用作OR。例如，我们有一个预期为<code class="fe os ot ou mg b">int</code>或<code class="fe os ot ou mg b">float</code>的变量，我们把它写成<code class="fe os ot ou mg b">int | float</code>，就像这样:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="f341" class="mk ml it mg b gy mm mn l mo mp">def f(x: <strong class="mg iu">int | float</strong>) -&gt; float:<br/>    return x * 3.142</span><span id="42ef" class="mk ml it mg b gy mq mn l mo mp">f(1)  # pass<br/>f(1.5)  # pass<br/>f('str')  # linter will show annotation error</span></pre><p id="a038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在3.10之前，等效的操作将使用<code class="fe os ot ou mg b">typing.Union</code>方法编写，就像<code class="fe os ot ou mg b">Union[int, float]</code>一样。</p><h2 id="3538" class="mk ml it bd nc ny nz dn ng oa ob dp nk li oc od nm lm oe of no lq og oh nq oi bi translated">3.TypeAlias批注</h2><p id="dc38" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">回到前向引用问题，避免前向引用的一个常见解决方案是将它们写成字符串。</p><p id="6185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，将类型写成字符串会在将这些类型赋给变量时产生问题——因为Python会假设我们的字符串文字类型注释只是一个字符串。</p><p id="27a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们通常使用类型注释的地方使用该类型注释变量将会返回一个错误。例如:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="e656" class="mk ml it mg b gy mm mn l mo mp">MyType = "ClassName"  # ClassName is our type annotation<br/>def foo() -&gt; MyType:<br/>    ...</span></pre><p id="62cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们试图使用<code class="fe os ot ou mg b">MyType</code>作为类型的<em class="mt">别名</em>，但是，<code class="fe os ot ou mg b">MyType</code>将被读取为字符串值——而不是类型别名。</p><p id="7a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要在代码的后面定义了<code class="fe os ot ou mg b">ClassName</code>，这就是有效的。目前，这将抛出注释错误。</p><p id="b1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，增加了一个方法来显式地将<code class="fe os ot ou mg b">MyType</code>标识为类型别名:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="1fef" class="mk ml it mg b gy mm mn l mo mp"><strong class="mg iu">from typing_extensions import TypeAlias</strong></span><span id="c6bf" class="mk ml it mg b gy mq mn l mo mp">MyType: <strong class="mg iu">TypeAlias </strong>= "ClassName"<br/>def foo() -&gt; MyType:<br/>    ...</span><span id="48e0" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg iu">OR</strong></span><span id="3c2d" class="mk ml it mg b gy mq mn l mo mp">MyType: <strong class="mg iu">TypeAlias </strong>= ClassName <em class="mt"># if we have defined ClassName already</em><br/>def foo() -&gt; MyType:<br/>    ...</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="cafa" class="nb ml it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">为什么打字很重要</h1><p id="e872" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">虽然这肯定不是一个巨大的、改变游戏规则的举动，但是看到Python开发者加倍努力增强类型化特性是非常酷的。</p><p id="d65a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的优势来自于它的易用性和没有陡峭的学习曲线。其中一个原因是我们的代码中不需要显式定义类型。</p><p id="8de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来违反直觉，但是给开发人员<em class="mt">选项</em>来定义类型可以极大地增强代码库的可读性和可维护性。例如，从变形金刚库的<a class="ae ky" href="https://github.com/huggingface/transformers/blob/master/src/transformers/pipelines.py" rel="noopener ugc nofollow" target="_blank">源代码</a>中提取这些内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa ms l"/></div></figure><p id="950d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使没有上下文，我们也可以阅读这些代码，并立即掌握我们应该期望将哪些数据提供给这些函数、类和方法，以及我们应该期望返回哪些数据类型。</p><p id="e71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在复杂的代码库(甚至是简单的代码库)中，类型注释可以极大地提高可读性。同时，不是每个人都想(或需要)使用它们——所以一个可选的、无异常的功能达到了完美的平衡。</p><p id="2682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些变化表明了对Python的类型注释特性的承诺。我们最喜欢的库(和我们自己的代码)更加清晰，这可能会对Python生态系统产生有趣的长期影响。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="eec6" class="nb ml it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">新的方法和行为</h1><p id="b384" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">除了新的类型变化，我们还对其他核心Python功能进行了一些更新和新特性。</p><h2 id="4990" class="mk ml it bd nc ny nz dn ng oa ob dp nk li oc od nm lm oe of no lq og oh nq oi bi translated">邮政编码的等长标志</h2><p id="0a52" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">第一个是PEP 618，它为<code class="fe os ot ou mg b">zip()</code>函数添加了一个可选的<code class="fe os ot ou mg b">strict</code>标志。如果我们设置了<code class="fe os ot ou mg b">strict=True</code>，如果<code class="fe os ot ou mg b">zip</code>的两个输入长度不相等，就会出现错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/e3e42aa692125cc5972c5a74773a6dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0B7UQOuIXpm6AtYQ3robQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果没有<strong class="bd pc"> strict=True </strong>标志(左)，则不会产生错误，并且较长的列表会被截断以创建压缩生成器。当<strong class="bd pc"> strict=True </strong>时，产生一个错误。</p></figure><p id="9f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的<code class="fe os ot ou mg b">strict</code>参数允许我们控制<code class="fe os ot ou mg b">zip</code>的行为，而不是盲目地截断不匹配的数据——这将使许多开发人员在未来某个时候不再头疼。</p><h2 id="53db" class="mk ml it bd nc ny nz dn ng oa ob dp nk li oc od nm lm oe of no lq og oh nq oi bi translated">整数的位数</h2><p id="cd2d" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">也被称为<em class="mt">总体计数</em>，这种新方法允许我们计算一个整数的二进制表示<strong class="lb iu">中一的数量。我们写的都是<code class="fe os ot ou mg b">int.<strong class="lb iu">bit_count()</strong></code>。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/021177b20c3428f44974a88d40b7264e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgSqW3XAaztiS_9KfCZa6A.png"/></div></div></figure><p id="dade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是返回代表每个整数的二进制值中的正位数:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="5f84" class="mk ml it mg b gy mm mn l mo mp">0   = 00000000<br/>1   = 00000001<br/>2   = 00000010<br/>3   = 00000011<br/>10  = 00001010<br/>11  = 00001011<br/>12  = 00001100<br/>100 = 01100100<br/>101 = 01100101<br/>102 = 01100110</span></pre><h2 id="59bd" class="mk ml it bd nc ny nz dn ng oa ob dp nk li oc od nm lm oe of no lq og oh nq oi bi translated">字典视图的映射</h2><p id="6e85" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">三个字典方法<code class="fe os ot ou mg b">dict.keys()</code>、<code class="fe os ot ou mg b">dict.values()</code>和<code class="fe os ot ou mg b">dict.items()</code>都返回一个字典的不同<em class="mt">视图</em>。现在，每个视图对象都添加了一个<code class="fe os ot ou mg b">mapping</code>属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/80da4b9a56d2fd6f3b8b17b7f306f983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHSboj8vjVFmaaV8iiK6Vw.png"/></div></div></figure><p id="70d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新属性是一个包装原始字典的<code class="fe os ot ou mg b">types.MappingProxyType</code>对象——如果我们在视图上调用它，我们将返回原始字典。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="76af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是目前的全部内容——虽然我们进入3.10的开发时间表才几个月，但是已经有很多有趣的变化了！</p><p id="da0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python的发展还在继续，看起来随着时间的推移，会有更多有趣的特性加入到这种语言中。</p><p id="a4a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。如果你想要更多，我已经开始在<a class="ae ky" href="https://www.youtube.com/channel/UCv83tO5cePwHMt1952IVVHw" rel="noopener ugc nofollow" target="_blank"> YouTube这里</a>发布编程教程。或者如果你有任何问题、想法或建议——请通过推特或在下面的评论中告诉我。</p><p id="fa33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="5577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还在使用Python 3.9，我在这里介绍了完整版本中的所有内容:</p><div class="pf pg gp gr ph pi"><a rel="noopener follow" target="_blank" href="/python-3-9-9c2ce1332eb4"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">Python 3.9</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">有什么新的，下一步是什么？</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">towardsdatascience.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ks pi"/></div></div></a></div></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="f953" class="mk ml it bd nc ny nz dn ng oa ob dp nk li oc od nm lm oe of no lq og oh nq oi bi translated"><a class="ae ky" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">🤖《变形金刚》课程NLP的70%折扣</a></h2></div></div>    
</body>
</html>