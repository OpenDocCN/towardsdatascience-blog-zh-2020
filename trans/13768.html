<html>
<head>
<title>Bootstrap Estimates and Experimentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自助估计和实验</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bootstrap-estimates-and-experimentation-adf084d7c6e7?source=collection_archive---------58-----------------------#2020-09-21">https://towardsdatascience.com/bootstrap-estimates-and-experimentation-adf084d7c6e7?source=collection_archive---------58-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="51ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">蒙特卡罗估计第一部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d0b6ddab24f08cc6a80863bc96053354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ijQTvOejV2a-V8Sb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">莫里茨·金德勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d9e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些天进行的许多数字实验可以用频率统计方法愉快地分析，因为我们期望数据是正态分布的<em class="ls"/>。然而，有些指标并不那么容易。以一个旨在增加税收或支付发票的实验为例。如果所有发票要么全部支付，要么根本没有支付，这可以用<em class="ls">二项式比例检验</em>或<em class="ls">卡方检验</em>进行分析。然而，发票的某一部分将被部分支付，使得这些测试不合适。即使我们试图比较实际的账单分布，这些很可能是某种形式的指数分布，有许多小额账单和较少的大额账单，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/dc75bc7e80a46318f9f9f8227f07445b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4xHNPIkhAAmxoiHV_JVBQ.png"/></div></div></figure><p id="fffa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那怎么办呢？处理这个问题的一种方法是使用随机抽样统计工具，通常被称为<em class="ls">蒙特卡罗模拟</em>。与评估实验结果特别相关的两个是<strong class="ky ir"><em class="ls"/></strong><em class="ls">(</em>用于确定平均值等统计参数的分布)和<strong class="ky ir"> <em class="ls">排列测试</em> </strong> <em class="ls"> ( </em>用于确定两个分布之间的统计数据是否存在差异，以及这种差异与偶然情况相比有多大可能是真实的)。在这篇文章中，我们将讨论自举。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/c7e864cc12ed2fe261c2213225ce3d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z_S1AcYUOOzKr0TY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@christieckim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂·金</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自举使用<strong class="ky ir"> <em class="ls">替换采样</em> </strong>的概念来生成参数的分布。为了说明这一点，假设我们要估计二十朵花的平均高度。如果没有电脑，我们可以这样做:</p><ol class=""><li id="58cb" class="lv lw iq ky b kz la lc ld lf lx lj ly ln lz lr ma mb mc md bi translated">测量每朵花，并在一张纸上记录花的ID和高度</li><li id="53ed" class="lv lw iq ky b kz me lc mf lf mg lj mh ln mi lr ma mb mc md bi translated">计算样本中花朵的平均高度，并写下来。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/32632508518a18c51fb75c50fe87a7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvwtwtwpzrk_wII0EjW1mQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上面我们用Python生成了20朵花的正态分布高度</p></figure><p id="e874" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">现在是有趣和(稍微)神奇的部分……</em></strong></p><ol class=""><li id="ed10" class="lv lw iq ky b kz la lc ld lf lx lj ly ln lz lr ma mb mc md bi translated">把纸片放在帽子里，随机选择一张。</li><li id="7c15" class="lv lw iq ky b kz me lc mf lf mg lj mh ln mi lr ma mb mc md bi translated">写下你选择的花的高度，然后把纸放回帽子里。</li><li id="8a5e" class="lv lw iq ky b kz me lc mf lf mg lj mh ln mi lr ma mb mc md bi translated">随机再选一次——你可能会再选同一个！这就是所谓的<strong class="ky ir"> <em class="ls">抽样替换。</em>T3】</strong></li><li id="3d44" class="lv lw iq ky b kz me lc mf lf mg lj mh ln mi lr ma mb mc md bi translated">重复20次，以符合原始样本大小。这些应该是一样的。</li><li id="8d9e" class="lv lw iq ky b kz me lc mf lf mg lj mh ln mi lr ma mb mc md bi translated">再次计算平均值<strong class="ky ir"/>并记下来——这是平均值的第二个估计值。</li></ol><p id="318e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你重复上述1000次，你会得到1000个略有不同的平均值，这些平均值是:</p><ol class=""><li id="f5fd" class="lv lw iq ky b kz la lc ld lf lx lj ly ln lz lr ma mb mc md bi translated"><em class="ls">正态分布，</em></li><li id="ca35" class="lv lw iq ky b kz me lc mf lf mg lj mh ln mi lr ma mb mc md bi translated">提供您估计的花朵平均高度的平均值 的<strong class="ky ir"> <em class="ls">标准误差。</em></strong></li></ol><p id="941c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在(非常不优化，但也许更可读？！)Python我们可以这样做上面的内容:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="1ffc" class="mp mq iq ml b gy mr ms l mt mu">#generate a few normally distributed heights for demonstration<br/>N_flowers = 20<br/>flower_heights = np.random.normal(5,size = N_flowers)</span><span id="0119" class="mp mq iq ml b gy mv ms l mt mu">data_points = flower_heights<br/>number_of_bootstraps = 1000<br/>average_estimate = [np.mean(data_points)]</span><span id="2677" class="mp mq iq ml b gy mv ms l mt mu">for j in range(0,number_of_bootstraps):<br/>    random_sample = []<br/>    for i in range(0,len(data_points)):<br/>        random_sample.append(np.random.choice(data_points))<br/>    average_estimate.append(np.mean(random_sample))</span><span id="100d" class="mp mq iq ml b gy mv ms l mt mu">ax = sns.distplot(average_estimate, bins = 100).set_title('Average Flower Heights')<br/>plt.xlabel("Height [cm]")<br/>plt.ylabel("Count")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/441b43aac1f8d508654e398cc9453b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nH3a2Ccgv5S6SnHCY9dqA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">这里我们有我们在这个例子中使用的20朵花的平均高度分布的boostrapped估计。</p></figure><p id="904d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为健全性检查，有必要将自举标准误差与我们使用frequentist方法从正态分布中预期的标准误差进行比较。标准偏差为σ、样本大小为N的正态分布的平均值(SE)的标准误差如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d5d16feb003779db1c27d52747c22578.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/1*cVFnr0ZIVFvsZz1hR9ExAg.gif"/></div></figure><p id="49e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用以下公式将上述内容与我们的自举估计进行比较:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="e349" class="mp mq iq ml b gy mr ms l mt mu">#normal distribution estimate<br/>std_error_mean = np.std(flower_heights) / np.sqrt(N_flowers) -- 0.1983</span><span id="8a14" class="mp mq iq ml b gy mv ms l mt mu">#bootstrap estimate<br/>bootstrap_estimate = np.std(average_estimate) -- 0.1977</span></pre><p id="e67a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我听到你们有些人在后台嘀咕- <strong class="ky ir"> <em class="ls">有什么大不了的！如果没有这些乱七八糟的选择，我们本可以做到的。</em></strong></p><p id="1bc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">但是</strong> …如果(而不是花)我们有一些其他非正态分布的样本呢？那么通常具有某种指数分布的钞票呢？</p><p id="5243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面显示的账单的含义是什么？对于实验来说更重要的是<em class="ls">(我们试图确定两个均值或其他统计参数之间是否存在差异)</em>均值估计的<strong class="ky ir"> <em class="ls">标准误差</em> </strong>是多少？</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="2352" class="mp mq iq ml b gy mr ms l mt mu">bill_size = np.random.pareto(1,200)<br/>sns.distplot(pareto).set_title("Average Bill Size")<br/>plt.xlabel("Bill ($)")<br/>plt.ylabel("Count")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/dc75bc7e80a46318f9f9f8227f07445b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4xHNPIkhAAmxoiHV_JVBQ.png"/></div></div></figure><p id="4375" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就有点棘手了，不是吗…</p><p id="49f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试使用bootstrap技术对此进行估计，但这次让我们稍微整理一下，并使用一个函数…</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="c7dd" class="mp mq iq ml b gy mr ms l mt mu">def get_bootstrap_mean(data_values, n_bootstraps):<br/>    '''<br/>    data_values: Pandas Dataframe<br/>    n_bootstrapes: Number of bootstrap estimates to calculate<br/>    Return:<br/>    Pandas Dataframe of the mean estimates<br/>    '''</span><span id="65f3" class="mp mq iq ml b gy mv ms l mt mu">    bootstrap_means = []<br/>    for j in range(0, n_bootstraps):<br/>        sample = data_values.sample(frac=1, replace=True).copy()<br/>        bootstrap_means.append(sample.mean())<br/>    return(pd.DataFrame(bootstrap_means))</span><span id="f180" class="mp mq iq ml b gy mv ms l mt mu">bill_size_experiment_a = pd.DataFrame(np.random.exponential(3,10000) )<br/>average_estimate_a = get_bootstrap_mean(bill_size_experiment_a, 100)</span><span id="4a92" class="mp mq iq ml b gy mv ms l mt mu">ax = sns.distplot(average_estimate_a, bins = 100).set_title('Average Bill Size Experiment Arm A')<br/>plt.xlabel("Bill Amount ($)")<br/>plt.ylabel("Count")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/2d356872e62bd233205f02371bc85632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZATuge_psIMiy2Ir98l4A.png"/></div></div></figure><p id="29f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！但是这对实验来说意味着什么呢？对于实验来说，我们想让自己相信干预确实有效果。例如，假设我们做了一个旨在增加平均还款的实验？我们怎么知道它起作用了？我们可以比较如下的自举平均分布:</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="63ad" class="mp mq iq ml b gy mr ms l mt mu">bill_size_experiment_b = 1.1 +pd.DataFrame(np.random.exponential(3,10000) )<br/>average_estimate_b = get_bootstrap_mean(bill_size_experiment_b, 100)</span></pre><p id="7a75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后如下所述比较两个直方图(其中A和B分别是实验组A和B):</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="5690" class="mp mq iq ml b gy mr ms l mt mu">fig, ax = plt.subplots()<br/>for a in [average_estimate_a, average_estimate_b]:<br/>    sns.distplot(a, bins = 20, ax=ax, kde=False)<br/>plt.legend(["A","B"])<br/>plt.title("Comparison of the Bill Bootstrapped Means")<br/>plt.xlabel("Bill Amount ($)")<br/>plt.ylabel("Count")</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/eeb688328ca20024d249407e24811251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JE0QMk6b97pDcqYY81uCCA.png"/></div></div></figure><p id="1807" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一件很棒的事情是，我们现在可以用t检验来比较两个均值分布</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="ffb0" class="mp mq iq ml b gy mr ms l mt mu">t2, p2 = stats.ttest_ind(average_estimate_a,average_estimate_b)</span></pre><p id="58ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于上述情况，我们得到p~0，即两个样本的平均值相同的概率几乎为零。如果这是两个实验条件的代表，我们可以有把握地假设它们之间存在差异。</p><p id="f282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种<strong class="ky ir"> <em class="ls">非常</em> </strong>强大的技术——它可以用来估计任何统计参数的标准误差，不管底层数据是什么分布。此外，得到的估计值是正态分布的，这使得使用标准频率技术进行比较变得容易。</p><p id="b7e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一篇文章中，我将描述<strong class="ky ir"> <em class="ls">排列测试</em> </strong>。这些特别用于确定参数在两个分布之间不同的可能性。</p></div></div>    
</body>
</html>