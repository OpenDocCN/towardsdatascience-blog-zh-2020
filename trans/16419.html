<html>
<head>
<title>7 Easy Ways for Improving Your Data Science Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进数据科学工作流程的7种简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2?source=collection_archive---------24-----------------------#2020-11-12">https://towardsdatascience.com/7-easy-ways-for-improving-your-data-science-workflow-b2da81ea3b2?source=collection_archive---------24-----------------------#2020-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5eee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">作为一名数据科学家，我学到了一些技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12e30210447186d5c76b4dafd241ad11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tJ-jhgPbCaUj05E3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sctgrhm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="de88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赢得数据科学比赛并不容易，但我们肯定有办法改进我们实践数据科学的方式。在这篇博客中，我们将讨论7种可以快速改善数据科学工作流程的简单方法。这些是我离开大学后艰难地学到的技巧。希望这可以帮助您组织您的环境，更好地编码，并为您的数据科学项目找到更合适的堆栈！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6636" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">1.组织您的项目目录</h2><p id="08e0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">没有什么比拥有一个<code class="fe na nb nc nd b">Untitled.ipynb</code>到<code class="fe na nb nc nd b">Untitled9999.ipynb</code>的乱七八糟的文件夹，文件夹里到处散落的数据csv，还有一堆<code class="fe na nb nc nd b">.ipynb_checkpoints</code>一样的缓存更糟糕的了。建立项目文件夹的第一步会让你的日常工作流程更加顺畅。一些有助于建立有序文件夹的常用工具有:</p><ul class=""><li id="620a" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" href="https://cookiecutter.readthedocs.io/en/1.7.2/" rel="noopener ugc nofollow" target="_blank"> Cookiecutter </a>:帮助你建立标准文件夹目录的Python包。查看<a class="ae ky" rel="noopener" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72">这里</a>的一个受cookiecutter启发的插件，它可以直接从你的Jupyter开发环境中访问。</li><li id="971d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">迷你巨蟒:巨蟒的一个准系统版本。如果您不需要Anaconda启动程序附带的GUI或其他应用程序，Miniconda是一个不错的选择。</li><li id="472a" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">requirements.txt或environment.yml:这有助于立即重新创建开发环境</li><li id="766d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">。gitignore file:这有助于通过忽略不需要推送到repo的文件来保持git存储库的整洁。例如临时文件、笔记本检查点、venv文件夹等。</li></ul><p id="4280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个话题的更多信息，请点击这里:</p><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">为数据科学建立必要的Jupyter扩展</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">自定义Jupyter扩展，帮助组织您的项目文件夹</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><h2 id="683d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">2.清理您的Python环境</h2><p id="787f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">大多数data science medium博客帖子会告诉你，为你的项目创建一个虚拟环境，但很少告诉你保持环境整洁的重要性。通常，当您创建开发环境时，会安装一堆生产环境不需要的IPython相关包。要使您的工作流程更加顺畅，您可以:</p><ul class=""><li id="fbde" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">Multiple requirements.txt或enviornment.yml:对dev和prod进行单独的配置可能是有用的，但是当您添加新的包时，您需要更新这两者</li><li id="aa31" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/bndr/pipreqs" rel="noopener ugc nofollow" target="_blank"> pipreqs </a>:一个Python包，通过只保留您的代码通过运行<code class="fe na nb nc nd b">pipreqs /path/to/your/project/folder</code>导入的包来清理您的production requirements.txt。</li><li id="0a22" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://github.com/naiquevin/pipdeptree" rel="noopener ugc nofollow" target="_blank"> pipdeptree </a>:一个Python包，通过运行<code class="fe na nb nc nd b">pipdeptree</code>帮助您理解Python环境的依赖性。</li></ul><p id="e3ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个话题的更多信息，请点击这里:</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/python-pandemonium/better-python-dependency-and-package-management-b5d8ea29dff1" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">打包项目时更好的Python依赖性</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">这个博客话题想法我煮了很久了。我做了大量的搜索，阅读和尝试，同时致力于…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj ks nv"/></div></div></a></div><h2 id="de0a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">3.更好地利用Python的标准库</h2><p id="f311" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不要重新发明轮子！很多时候，当您觉得有一些笨拙的代码需要编写时，您会重新创建Python提供的一些内置函数。</p><p id="9529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例1: <code class="fe na nb nc nd b">collection.Counter</code>用于统计出现次数</p><pre class="kj kk kl km gt ol nd om on aw oo bi"><span id="4318" class="mc md it nd b gy op oq l or os"># instead of this<br/>counter = dict()<br/>for item in my_list:<br/>    counter[item] = counter.get(item, 0) + 1</span><span id="7f68" class="mc md it nd b gy ot oq l or os"># do this<br/>from collections import Counter<br/>counter = Counter(my_list)</span></pre><p id="96e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例2: <code class="fe na nb nc nd b">itertools.chain.from_iterable</code>用于连接列表列表</p><pre class="kj kk kl km gt ol nd om on aw oo bi"><span id="18b9" class="mc md it nd b gy op oq l or os"># instead of this<br/>joined_list = []<br/>for sub_list in my_list_of_list:<br/>    joined_list.extend(sub_list)</span><span id="85fc" class="mc md it nd b gy ot oq l or os"># do this<br/>from itertools import chain<br/>joined_list = list(chain.from_iterable(my_list_of_list))</span></pre><p id="218f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例3: <code class="fe na nb nc nd b">collections.namedtuple</code>作为一个不可变类的替换</p><pre class="kj kk kl km gt ol nd om on aw oo bi"><span id="f3d9" class="mc md it nd b gy op oq l or os"># instead of this<br/>class Color:<br/>    def __init__(self, r, g, b):<br/>        self.r, self.g, self.b = r, g, b</span><span id="f6e6" class="mc md it nd b gy ot oq l or os"># or this<br/>RED, GREEN, BLUE = 0, 1, 2<br/>c = (0, 255, 120) # lime green<br/>red_value = c[RED]</span><span id="0508" class="mc md it nd b gy ot oq l or os"># do this<br/>from collections import namedtuple<br/>Color = namedtuple('Color', ['r', 'g', 'b'])<br/>c = Color(0, g=255, b=120) # lime green<br/>red_value = c.r</span></pre><p id="5530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例4: <code class="fe na nb nc nd b">bisect.insort</code>用于维护排序列表</p><pre class="kj kk kl km gt ol nd om on aw oo bi"><span id="5d08" class="mc md it nd b gy op oq l or os"># just do this<br/>from bisect import insort<br/>my_sorted_list = []<br/>for i in (1, 324, 52, 568, 24, 12, 8):<br/>    insort(my_sorted_list, i)</span></pre><p id="7570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个常见的陷阱是使用过度的数据结构。例如，如果一旦定义了一个列表，你就不改变它的内容，那么一个元组会节省你很多内存；或者，如果您只使用列表的第一个或最后一个元素，那么请使用deque。</p><p id="705d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于此主题的更多信息:</p><div class="ns nt gp gr nu nv"><a href="https://docs.python.org/3/library/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Python标准库- Python 3.9.0文档</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">虽然Python语言参考描述了Python语言的确切语法和语义，但是这个库…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">docs.python.org</p></div></div></div></a></div><h2 id="fa2e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">4.包装笔记本电脑时简化您的代码</h2><p id="f09b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们自己都知道，就可读性、可伸缩性和可维护性而言，开发笔记本是世界上最糟糕的脚本之一。在将笔记本打包到Python包中时，通常有一些经验法则:</p><ul class=""><li id="025c" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">识别重复的代码片段，并将它们分组到一个函数中</strong>:例如，我不用每次都编写一个正则表达式来进行关键字匹配，而是使用下面的代码片段:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><ul class=""><li id="2e78" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">去掉多余的单元格、线和变量</strong>:对，我们说的是<code class="fe na nb nc nd b">df_temp = df.copy()</code>、<code class="fe na nb nc nd b">gc.collect()</code>、<code class="fe na nb nc nd b">temp = df.some_column.unique()</code></li><li id="1f2f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">将所有的函数和导入移到笔记本的开头:</strong>我在大学的时候，C给我上了一堂很好的课，那就是预先定义你需要的所有东西，你永远不需要担心去哪里找它们</li><li id="eaa4" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">按执行顺序解开并排序单元格:</strong>你最不想要的就是记住你是什么时候从笔记本的最后一个单元格跳到第一个单元格的</li></ul><h2 id="0215" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">5.尽可能继承现有的抽象类</h2><p id="1fc3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当涉及到组织代码时，面向对象编程和函数式编程将永远是一场争论。但是底线是，使用任何一个都比什么都不用要好。说到数据科学，有许多以OOP方式组织的包，例如sci-kit learn、nltk、spacy等等。如果你设法将你的脚本打包成扩展抽象类的类，这将有助于更好地组织你的代码，并允许与你的数据科学管道更好地集成。</p><p id="3f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，根据我以前的regex表达式构造片段，我想构造一个标记器，只返回函数捕获的标记。通过继承nltk的<code class="fe na nb nc nd b">TokenizerI</code>，我的<code class="fe na nb nc nd b">RegexpEntityTokenizer</code>现在与say nltk的<code class="fe na nb nc nd b">PunktSentenceTokenizer</code>具有相同的结构。这意味着我现在可以将我的自定义标记器传递给sklearn <code class="fe na nb nc nd b">Pipeline</code>来实现无缝工作流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="feed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个话题的更多信息，请点击这里:</p><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/object-oriented-programming-for-data-scientists-build-your-ml-estimator-7da416751f64"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">面向数据科学家的面向对象编程:构建您的ML估计器</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">通过构建自己的Scikit-learn-like，在机器学习环境中实现一些核心的OOP原则…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="ow l og oh oi oe oj ks nv"/></div></div></a></div><h2 id="ae33" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">6.停止腌制一切</h2><p id="5819" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">是的，我知道。腌制数据框等物品方便；你基本上可以将你的python脚本中的所有东西序列化到一个<code class="fe na nb nc nd b">.pkl</code>文件中。然而，pickle的便利性伴随着几个薄弱环节:</p><ul class=""><li id="9f0f" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">不是为速度而设计的</strong> : Pickle是为任何对象而设计的，这使得它比其他更专业的序列化要慢</li><li id="e4c0" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">不安全</strong>:解包一个pickle文件可以执行一些已经隐藏在pickle文件中的任意代码。想象一下，如果你的前任为你准备了一些生日恶作剧。</li><li id="fc61" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">不可移植</strong>:不同版本的Python之间并不是所有的pickled数据都兼容。</li></ul><p id="c87b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以记住，pickle不是保存数据和进度的唯一方法。以下是一些备选方案:</p><ol class=""><li id="6628" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu ox nk nl nm bi translated"><strong class="lb iu"> cPickle </strong>:底线，看看cPickle，这是用C实现的Pickle，比Pickle快1000多倍。</li><li id="103f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu ox nk nl nm bi translated"><strong class="lb iu"> JSON </strong> : JSON序列化你的数据比pickle快很多。最重要的是，JSON使得在Python之外的文本编辑器中存储和编辑字典(或者配置模型的kwargs)成为可能。</li><li id="0ebe" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu ox nk nl nm bi translated"><strong class="lb iu"> NumPy </strong>:如果你正在序列化一个定义明确的结构，你可以把它放进<code class="fe na nb nc nd b">numpy.ndarray</code>，NumPy的<code class="fe na nb nc nd b">np.save</code>和<code class="fe na nb nc nd b">np.memmap</code>是一些更快的选择</li><li id="5a99" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu ox nk nl nm bi translated"><strong class="lb iu"> Joblib </strong>:对于一直在开发机器学习模型的人来说，这应该并不陌生。如果你的对象包含大的<code class="fe na nb nc nd b">np.ndarray</code>，那么joblib可能适合你。它的界面与pickle基本相同，但更简单一些，所以你使用它应该没有问题。但是，请注意joblib与pickle有相同的安全问题。</li><li id="8bcb" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu ox nk nl nm bi translated"><strong class="lb iu"> h5py </strong>:对于之前玩过say tensorflow或者keras的人来说并不陌生。HDF5阵列可以存储大量压缩数字数据。的确，拥有一个包含压缩数据的层次数据结构意味着一点学习曲线，也意味着查询数据集有点困难；但另一方面，您将从中获得非常高效的数据I/O。</li></ol><h2 id="6159" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">7.考虑使用数据库</h2><p id="a721" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最后但同样重要的是，这将是一个巨大的飞跃，并有可能改变你的游戏计划。但是相信我，在自己经历了转换之后，是值得的。查看您是否经历过以下任何情况:</p><ul class=""><li id="2a2e" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">在你巨大的熊猫数据帧上不能再加速你的python脚本了</li><li id="3159" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">保存和加载数据集的时间越来越长</li><li id="b2bb" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">您的所有数据都位于同一位置，无论是原始数据、外部数据还是经过处理的数据</li><li id="bce6" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">新数据不断出现，并保存为CSV格式</li></ul><p id="2117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些都是数据库将使你的生活变得容易得多的迹象。一旦有了数据库，SQL会帮你做很多繁重的工作。很多时候，I/O是我的Python脚本的瓶颈。通过将处理向数据靠近一步，读写速度得到了不同数量级的提高。最棒的是，无论你的需求是什么，你总能找到合适的数据库:MySQL、PostgreSQL、MongoDB、CouchDB等。</p><p id="8722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个话题的更多信息，请点击这里:</p><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/databases-101-introduction-to-databases-for-data-scientists-ee18c9f0785d"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">数据库101:数据科学家数据库简介</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">如何开始接触数据库世界？</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="oy l og oh oi oe oj ks nv"/></div></div></a></div><h2 id="af7e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">出发前</strong></h2><p id="aa9b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这些是我的一些关于数据科学和python的中型博客，您可能想看看:</p><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">熊猫数据帧上的高效条件逻辑</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">是时候停止过于依赖。iterrows()和。应用()</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="oz l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">为数据科学建立必要的Jupyter扩展</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">自定义Jupyter扩展，帮助组织您的项目文件夹</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/mastering-root-searching-algorithms-in-python-7120c335a2a8"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Python中高效的根搜索算法</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在Python中实现高效的寻根和优化搜索算法</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="pa l og oh oi oe oj ks nv"/></div></div></a></div><h2 id="98a9" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">好了</h2><p id="d6a9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">希望您已经发现这些提示对完善您的数据科学工作很有用。让我知道如果评论你如何找到这些技巧。</p><p id="ab6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再见！</p><div class="ns nt gp gr nu nv"><a href="https://www.linkedin.com/in/louis-chan-b55b9287/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Louis Chan-FTI Consulting | LinkedIn数据科学总监</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.linkedin.com</p></div></div></div></a></div></div></div>    
</body>
</html>