<html>
<head>
<title>Multithreading vs. Multiprocessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多线程与多处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multithreading-vs-multiprocessing-in-python-3afeb73e105f?source=collection_archive---------0-----------------------#2020-09-27">https://towardsdatascience.com/multithreading-vs-multiprocessing-in-python-3afeb73e105f?source=collection_archive---------0-----------------------#2020-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9a598534df310c24e4c903bff7bde114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XbMhaKrrzEPmMZg8"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">劳尔·卡乔·奥斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="ad45" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="d7b9" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">两者之间的区别，以及如何和何时使用它们</h2></div><p id="c155" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Python通常被认为是一种近乎淫秽的编程语言。一个自由主义的地方，在这里一切都被允许，我们最狂野的梦想都得以实现。忘记标签和定义，尤其是括号。这是一种欢迎所有人的语言，从最有经验的程序员(那个因为某些你不想知道的原因仍然使用Fortran的古怪家伙)到自负的千禧一代新手。嗯，除非你和<code class="fe md me mf mg b">multiprocessing</code>或<code class="fe md me mf mg b">multithreading</code>一起工作。</p><p id="cdb4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在Python中处理并行性和并发性的挑战始于这样一个事实，即使是互联网也不太了解它是如何工作的。事实上，我在stackoverflow回复上发现了多个错误的陈述(有些有很高的向上票数)，甚至是看起来非常严肃的博客。因此，不同于其他情况，其中<em class="mh">编程</em>也可能被称为<em class="mh">堆栈溢出</em>，在开始使用Python中的<code class="fe md me mf mg b">multiprocessing</code>或<code class="fe md me mf mg b">multithreading</code>之前，你最好至少知道你正在做的事情的基础。</p><p id="718e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">否则，你可能会过得不好。</p><h1 id="1163" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">基础知识</h1><p id="f24f" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">当寻找python <code class="fe md me mf mg b">multiprocessing</code>和<code class="fe md me mf mg b">multithreading</code>之间的区别时，人们可能会有这样的印象:它们的工作方式非常相似。这真是大错特错。主要区别在于:</p><ul class=""><li id="f602" class="nf ng jj lj b lk ll ln lo lq nh lu ni ly nj mc nk nl nm nn bi translated">进程是在处理器内核中执行的独立实例。线程是进程的组件，并发运行(在该进程内部)。</li><li id="4162" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc nk nl nm nn bi translated">进程不共享同一个内存空间，而线程共享(它们妈妈的内存，诗意吧？).</li><li id="7900" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc nk nl nm nn bi translated">线程更轻，导致的开销更少。此外，因为它们在一个进程中共享相同的内存，所以共享数据更容易、更快、更安全。</li><li id="50e8" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc nk nl nm nn bi translated">只有使用<code class="fe md me mf mg b">multiprocessing</code>才能实现真正的平行。这是因为在一个进程时间空间内，一个给定的时间只能执行一个线程。这是由Python的全局解释器锁(GIL)保证的(见<a class="ae jg" href="https://realpython.com/python-gil/" rel="noopener ugc nofollow" target="_blank"> Python GIL在RealPython </a>)。</li><li id="bb13" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc nk nl nm nn bi translated">进程的执行由操作系统调度，而线程由GIL调度。</li></ul><p id="0d1e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们还应该理解并发和并行的区别。</p><ul class=""><li id="c4e9" class="nf ng jj lj b lk ll ln lo lq nh lu ni ly nj mc nk nl nm nn bi translated"><strong class="lj jt">并发</strong>执行是指两个或两个以上的任务同时进行。</li><li id="8938" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc nk nl nm nn bi translated">并行执行意味着两个或更多的任务同时被执行。</li></ul><p id="6051" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在记住:<code class="fe md me mf mg b">multithreading</code>实现并发，<code class="fe md me mf mg b">multiprocessing</code>实现并行。流程在独立的处理节点上运行。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/4dcf3512817993c3587f5572ff6f2f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*_nSpk2ZTATQpps0XOHJHGA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><em class="ny">流程并行运行。线程并发执行。</em>作者图片</p></figure><h1 id="a3b1" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">使用案例</h1><p id="9632" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">那么我们如何在<code class="fe md me mf mg b">multiprocessing</code>和<code class="fe md me mf mg b">multithreading</code>之间做出选择呢？简短的回答是:</p><ul class=""><li id="b7ab" class="nf ng jj lj b lk ll ln lo lq nh lu ni ly nj mc nk nl nm nn bi translated">用于I/O密集型任务的多线程技术；</li><li id="d1ae" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc nk nl nm nn bi translated">针对CPU密集型任务的多处理(如果您有多个内核可用)</li></ul><p id="85b1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是为什么呢？</p><h1 id="9f64" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">多线程:I/O绑定任务</h1><p id="b637" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">假设你有一个任务，它依赖于系统的另一部分或者用户的输入。</p><p id="2fce" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">没有理由为那项工作指定一个进程，因为它会花费大部分时间等待刺激开始工作。如果将一个计算节点专用于此，那将是一种资源浪费，而且不会带来任何加速，因为瓶颈不在执行上，而在第三方调用上。在这种情况下，<code class="fe md me mf mg b">multithreading</code>就是要走的路。</p><p id="762f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">的确，<code class="fe md me mf mg b">multithreading</code>通常被实现来处理GUI。例如，在文本编辑器程序中，一个线程将负责从键盘获取输入，而另一个线程将检查拼写，第三个线程可以处理格式配置。</p><p id="a02d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">I/O密集型程序也可以直接从<code class="fe md me mf mg b">multithreading</code>中受益，因为它们的瓶颈通常是读或写操作(例如，在web scrappers中是下载)。查看以下示例:</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="1668" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个函数将一些URL地址加载到内存中，并将它们写入一个本地文本文件(50次，总是覆盖同一个文件)。这是相当愚蠢的，但它的目的只是强调I/O绑定的执行。你可以在<a class="ae jg" href="https://github.com/gennsev/Python_MultiProc_Examples/blob/master/Example.ipynb" rel="noopener ugc nofollow" target="_blank">这个笔记本</a>里查看这段代码并自己执行。</p><p id="3bf4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们在16个地址的列表上运行该方法，并检查一些不同线程数的执行时间。这将为我们带来以下图表(在MacBook Air 2019上执行)。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/1813a89e1cd86d5f96cbdbc0c17f271e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*qn6Gg7AOsEJNZJa9.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="d981" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中一个线程的结果代表代码的串行执行。从图中我们可以看出,<code class="fe md me mf mg b">multithreading</code>能够大大减少算法的执行时间。我们可以继续增加线程的数量，但是一旦达到每个地址都由一个线程处理的程度，这种增加就会停止。</p><h1 id="4e06" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">多重处理:CPU限制的任务</h1><p id="d23f" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">现在想象一下，你在内存中加载了大量的数据，这些数据都需要处理。受计算限制的程序将从多重处理中受益，因为它们的瓶颈是时间和资源。图像和图形处理就是一个很好的例子。它们由大量的数学运算组成，因为它们的数据是独立的，所以通常可以分成单独的任务。在这方面，GPU是最先进的硬件，旨在并行处理大块数据。</p><p id="cec5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了模拟计算密集型算法，我们将使用以下代码:</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f5a6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同样，你可以在<a class="ae jg" href="https://github.com/gennsev/Python_MultiProc_Examples/blob/master/Example.ipynb" rel="noopener ugc nofollow" target="_blank">这个笔记本</a>中检查这个代码，然后自己执行它(我<strong class="lj jt"> <em class="mh">强烈</em> </strong>建议你看一下，因为我们必须做一些变通办法才能在windows上正确执行它)。</p><p id="b449" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我的MacBook采用了带超线程的双核处理器，因此没有必要强制在其上运行4个以上的进程。以下是该基准测试的性能测试结果:</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/4ee35525e6143a3650b2e194c9aefb8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*RMTFnj3ghxCuIa71.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="5793" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe md me mf mg b">multithreading</code>没有提供加速(执行时间实际上是相同的)。然而，当使用<code class="fe md me mf mg b">multiprocessing</code>时，我们有了显著的加速。由于流程管理花费的时间，将执行时间减少到原来的四分之一是不够的。请记住，进程比线程重得多。</p><h2 id="c8d7" class="oc mj jj bd mk od oe dn mo of og dp ms lq oh oi mu lu oj ok mw ly ol om my jp bi translated">I/O密集型任务的多重处理</h2><p id="3b68" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">即使这不是他们的最佳用例，也没有理由期望<code class="fe md me mf mg b">multiprocessing</code>在I/O密集型任务上表现不佳。这是一种资源浪费:想象一下，将一个处理器内核专用于一个函数，该函数在执行的很大一部分时间里，只是等待输入。一个处理器，即使是一个集群，也只有这么多的处理节点。我们最好将它们用于真正的应用并行化，只有通过这些方法才能加速。</p><p id="f686" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是为了科学起见，如果我们使用<code class="fe md me mf mg b">multiprocessing</code>执行第一个I/O绑定代码，会发生什么呢？下图显示了这一点。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/915e1c934b00818fbffb749711d5ebdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*Cy0tF2o1sqsYjVH_.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="19e3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如所料，<code class="fe md me mf mg b">multiprocessing</code>也能够加速I/O限制的计算。同样值得注意的是，我们保持了8个进程的加速。原因是在这种情况下，进程开始像线程一样执行。加速不是来自并行性，而是来自并发性。</p><h1 id="df4d" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">数据科学示例</h1><p id="4b57" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">现在，让我们更深入地了解如何在Python中实现多处理和多线程，以及数据科学家如何从中获益。有许多不同的方法可以做到这一点，我鼓励您从文档中获得一些想法(<a class="ae jg" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">这里</a>、<a class="ae jg" href="https://docs.python.org/3.8/library/threading.html" rel="noopener ugc nofollow" target="_blank">这里</a>、<a class="ae jg" href="https://docs.python.org/3.8/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">和这里</a>)，并在我在<a class="ae jg" href="https://github.com/gennsev/Python_MultiProc_Examples/blob/master/Example.ipynb" rel="noopener ugc nofollow" target="_blank">本笔记本</a>中作为练习提供的示例模型上尝试它们。</p><p id="5139" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从广义上讲，数据科学项目遵循四个步骤:</p><ol class=""><li id="e600" class="nf ng jj lj b lk ll ln lo lq nh lu ni ly nj mc on nl nm nn bi translated">获取数据；</li><li id="e127" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc on nl nm nn bi translated">处理数据；</li><li id="7a20" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc on nl nm nn bi translated">对数据做点什么；</li><li id="cc47" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc on nl nm nn bi translated">存储其他数据</li></ol><p id="8766" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，你可能会说:“不，我的项目完全不同”。嗯，恕我不敢苟同，但我相信你可以通过这篇博文获得一些关于如何加速你自己与众不同的项目的想法。</p><blockquote class="oo op oq"><p id="f30d" class="lh li mh lj b lk ll kt lm ln lo kw lp or lr ls lt os lv lw lx ot lz ma mb mc im bi translated">记住黄金法则:<code class="fe md me mf mg b">multithreading</code>用于I/O绑定任务，而<code class="fe md me mf mg b">multiprocessing</code>用于CPU绑定任务。</p></blockquote><p id="2477" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，不难理解“获取数据”和“存储其他数据”步骤可能是我们应该使用<code class="fe md me mf mg b">multithreading</code>的步骤。所有其他的(“处理数据”和“用数据做点什么”)使用<code class="fe md me mf mg b">multiprocessing</code>可能会更好。您可能认为处理大量数据可能会出现I/O瓶颈，在某些情况下，您可能是对的。如果是这种情况，您应该尝试将这种处理分成“获取数据”和“处理数据”两部分，以便可以将最佳策略应用于每一部分。</p><h1 id="73c6" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">文本分类</h1><p id="360d" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">让我们看看如何在一个经典的自然语言处理(NLP)问题中应用我们所学的知识:文本分类。这个想法是通过文本找出一篇新闻文章的类别(例如:它是否应该被分类为“体育”、“金融”、“经济”等)。</p><blockquote class="oo op oq"><p id="dadb" class="lh li mh lj b lk ll kt lm ln lo kw lp or lr ls lt os lv lw lx ot lz ma mb mc im bi translated">如果您只是想了解如何在实际项目中使用多重处理和多线程，就跟着做吧，您不需要了解NLP的任何知识就能理解这个例子。但是，如果你对主题感兴趣，你应该从研究什么是<a class="ae jg" href="https://en.wikipedia.org/wiki/Word_embedding" rel="noopener ugc nofollow" target="_blank">单词向量</a>开始。喜欢<a class="ae jg" href="https://medium.com/@jayeshbahire/introduction-to-word-vectors-ea1d4e4b84bf" rel="noopener">这篇文章</a>。你也可以关注这个GitHub库<a class="ae jg" href="https://github.com/gennsev/tclass" rel="noopener ugc nofollow" target="_blank">,我和我的一个同事正在那里开发一些文本分类模型(那里有一些很酷的笔记本)。</a></p></blockquote><p id="27de" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的项目非常简单，我们将:</p><ol class=""><li id="ae13" class="nf ng jj lj b lk ll ln lo lq nh lu ni ly nj mc on nl nm nn bi translated">从路透社获取一些包含新闻及其各自标签的数据(定义它们是什么类型的新闻)(<a class="ae jg" href="https://www.cs.umb.edu/~smimarog/textmining/datasets/" rel="noopener ugc nofollow" target="_blank">数据源</a>)；</li><li id="6e9a" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc on nl nm nn bi translated">使用<code class="fe md me mf mg b">GloVe</code>预训练的单词向量(从维基百科训练而来)对它们进行矢量化(<a class="ae jg" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank">GloVe project page</a>)；</li><li id="ed62" class="nf ng jj lj b lk no ln np lq nq lu nr ly ns mc on nl nm nn bi translated">使用带有<code class="fe md me mf mg b">scikit-learn</code>的随机森林训练一个模型，在给定的标签下对文本进行分类。</li></ol><p id="781e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">到目前为止，应该很容易看出在Python中使用<code class="fe md me mf mg b">multithreading</code>可以加速步骤1，而步骤3应该使用<code class="fe md me mf mg b">multiprocessing</code>。</p><h2 id="bc9b" class="oc mj jj bd mk od oe dn mo of og dp ms lq oh oi mu lu oj ok mw ly ol om my jp bi translated">加载数据</h2><p id="fc9f" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">让我们从预训练的手套单词向量加载开始。你可以在<a class="ae jg" href="https://github.com/gennsev/Python_MultiProc_Examples/blob/master/Example-2.ipynb" rel="noopener ugc nofollow" target="_blank">这个笔记本</a>里查看完整代码并自己执行。加载这个预先训练好的单词向量文件会花费很多时间。这个文件相当长，我们必须逐行处理。每行包含一个单词，然后是单词向量的每个维度的值列表。</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a881" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe md me mf mg b">GloveVectorizer()</code>在其<code class="fe md me mf mg b">__init__</code>函数中加载预训练向量，可以异步或串行完成。这是它执行基本的逐行文件读取的方式:</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="9623" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是<code class="fe md me mf mg b">multithread</code>的实现:</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0ca4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我再次强烈建议你检查一下它是如何在<a class="ae jg" href="https://github.com/gennsev/Python_MultiProc_Examples/blob/master/Example-2.ipynb" rel="noopener ugc nofollow" target="_blank">完整代码</a>中实现的。</p><p id="7bac" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe md me mf mg b">ThreadPoolExecutor</code>异步运行它的线程。最后一个<code class="fe md me mf mg b">for</code>循环用于保证只有在提交给执行器的所有线程完成后，执行才会继续。查看<a class="ae jg" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="noopener ugc nofollow" target="_blank"> Python文档</a>了解更多关于<code class="fe md me mf mg b">ThreadPoolExecutor</code>如何工作的细节。</p><p id="56ea" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是用<code class="fe md me mf mg b">multithreading</code>加载向量的速度有多快呢？在我的MacBook Air中，第一个串行版本在大约<code class="fe md me mf mg b">269.19898986816406s</code>处加载了40万个单词向量。异步方法在<code class="fe md me mf mg b">27.559515953063965s</code>中加载400000个字向量，使用10个工人(它可能用更少的工人达到相同的执行时间，因为瓶颈是读取行，而不是处理)。</p><h2 id="2c06" class="oc mj jj bd mk od oe dn mo of og dp ms lq oh oi mu lu oj ok mw ly ol om my jp bi translated">训练模型</h2><p id="3e02" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">现在酷的部分:培训和测试。</p><p id="805b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对我们来说幸运的是，<code class="fe md me mf mg b">scikit-learn</code>本身就提供了<code class="fe md me mf mg b">multiprocessing</code>，只需在模型的参数上进行设置。下面的两个代码示例用相同的数据串行地或使用一组<code class="fe md me mf mg b">jobs</code>(映射到<code class="fe md me mf mg b">scikit-learn</code>中的流程)训练一个相同的模型。</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2f98" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<code class="fe md me mf mg b">scikit-learn</code>中使用多重处理就像设置<code class="fe md me mf mg b">n_jobs</code>模型参数一样简单。在这里，我们将它设置为两个:</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="30d5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这太简单了，你可能会怀疑它是否有用。但确实如此。下面的条形图显示了同一型号在不同工作数量下的培训时间:</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/130c154e90c6c8614601592e35917186.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/0*ZvBRwxViokO3XQF8.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="e5fc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">哦，如果你好奇的话，这个模型的准确性(<code class="fe md me mf mg b">RandomForestClassifier.scoreTrain</code>)一点也不差:</p><pre class="nu nv nw nx gt ov mg ow ox aw oy bi"><span id="6128" class="oc mj jj mg b gy oz pa l pb pc">Train score: 0.9992707383773929<br/>Test score: 0.9346733668341709</span></pre><h2 id="2ae7" class="oc mj jj bd mk od oe dn mo of og dp ms lq oh oi mu lu oj ok mw ly ol om my jp bi translated">结论</h2><p id="2b48" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">我认为它涵盖了几乎所有的东西。最后一个例子展示了如何使用Python多处理和多线程特性来加速实际项目，有时只需很少甚至不需要修改代码。然而，并非所有闪光的东西都是金子。当期待python中更复杂的并行和异步执行时，您很快就会发现，事情会变得相当混乱。</p></div></div>    
</body>
</html>