<html>
<head>
<title>Fueling up your neural networks with the power of cyclical learning rates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用循环学习率的力量给你的神经网络加油</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fueling-up-neural-networks-with-the-power-of-cyclical-learning-rates-1b494eeaac42?source=collection_archive---------41-----------------------#2020-09-27">https://towardsdatascience.com/fueling-up-neural-networks-with-the-power-of-cyclical-learning-rates-1b494eeaac42?source=collection_archive---------41-----------------------#2020-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="600b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">永远不要限制你的神经网络的能力。让它探索自己的学习能力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b69fed810a295ae6888e735e4a79338a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JTC8VgeBr7YUnm9aWg-Ow.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:https://unsplash.com/photos/WE_Kv_ZB1l0</p></figure><h2 id="22f2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="7f20" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">为训练神经网络选择最佳学习速率是一项单调乏味的任务，通常是通过反复试验来完成的。</p><p id="e581" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">但是，如果你能为你的神经网络提供一系列的学习率值呢？最好的部分是，有一种方法可以在甚至不开始实际训练你的神经网络的情况下，获得最佳的学习速率范围。</p><p id="1d53" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">多酷啊。</p><p id="b726" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这些很酷的技术是由<strong class="lx iu"> Leslie N. Smith </strong>在他的论文<a class="ae ky" href="https://arxiv.org/abs/1506.01186" rel="noopener ugc nofollow" target="_blank"> <strong class="lx iu">中介绍的，用于训练神经网络</strong> </a>的循环学习率。</p><p id="1453" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">通过使用本文中讨论的技术，我们可以在更少的迭代中获得更好的结果。</p><p id="e715" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">论文的摘要清楚地说明了这一点:</p><blockquote class="mt mu mv"><p id="779e" class="lv lw mw lx b ly mo ju ma mb mp jx md mx mq mf mg my mr mi mj mz ms ml mm mn im bi translated">用循环学习率而不是固定值进行训练可以提高分类精度，而不需要调整，并且通常迭代次数更少</p></blockquote><p id="e04d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">摘要中的陈述得到了针对自适应学习率等其他技术进行的几个实验的支持。</p><p id="9e2e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在CIFAR-10数据集上使用循环学习率进行训练时，获得了以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/3aed08e114f315654c474eff26047f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIpD4_Ze_yw9E3kBiRu7ig.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://arxiv.org/abs/1506.01186" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1506.01186</a></p></figure><p id="f651" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">通过循环学习率方法在大约25，000次迭代时实现了通过其他方法在70，000次迭代时获得的相同精度。</p><p id="896b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，让我们直接进入论文的细节。</p><h2 id="bdb1" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">这个所谓的循环学习率是什么？</h2><p id="033a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">大多数情况下，在传递学习率时，我们只是给神经网络一个固定的值。</p><p id="c22e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">但是在使用循环学习率时，我们传递的是最小学习率和最大学习率。</p><p id="dc4d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">例如，考虑最小学习率为0.001，最大学习率为0.01。在训练过程中，学习率将从0.001(最小学习率)变化到值0.01(最大学习率)，然后再次从0.01(最大学习率)变化到0.001(最小学习率)，并且该过程继续，直到训练完成。</p><p id="b436" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">就像一个循环过程，从最小值开始到最大值，然后又回到最小值。就这么简单。</p><p id="85f0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">显然，你可能会有一个问题。</p><p id="2385" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">学习率从最小值到最大值需要多少次迭代或多少个时期，反之亦然？</p><p id="5690" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个问题的答案是步长。</p><p id="0d17" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果步长为100，那么学习率从最小值到最大值需要100次迭代，再需要100次迭代才能回到最小值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b8826cfe835b4fdc96d2d4022b8fad50.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*RmJSeMVs2E9ABQ_W1N0A2w.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f86d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如上图所示，学习率从最小值0.0001开始，在100次迭代后达到最大值0.001，并在接下来的100次迭代中再次返回到最小值。</p><p id="b249" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">一个完整的周期是返回最小值所需的时间。在上图中，等于200次迭代。</p><p id="b8ea" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">一个完整的周期= 2*(步长)</p><p id="7612" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Torch7代码中给出的实现循环学习的速率是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Torch7循环学习率代码</p></figure><p id="1bc6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><em class="mw"> epochCounter </em> —迭代次数</p><p id="6fab" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><em class="mw">被占领土。LR </em> —学习率的最小值</p><p id="e9f7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><em class="mw"> maxLR </em> —学习率的最大值</p><p id="fc78" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">但是让我们把上面的代码转换成numpy:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">循环学习率的数值实现</p></figure><p id="b288" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，让我们测试我们的numpy实现是否按预期工作。为此，让我们运行一个For循环，并检查学习率是否像前面讨论的那样从最小移动到最大。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试我们功能的代码</p></figure><p id="5ed8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">通过运行上面的代码，我们得到一个如下所示的图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6f0905ea0c2dd98425ef897ecf8d9696.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*D3X-jPZhUO3TgTYKriMX1Q.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="86f7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">正如预期的那样，我们的学习率从最小值开始，在指定的步长内上下线性移动。</p><p id="7bf8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">上述技术被称为三角策略。本文还介绍了另外两种技术:</p><ol class=""><li id="68b6" class="ne nf it lx b ly mo mb mp li ng lm nh lq ni mn nj nk nl nm bi translated">三角形2  —三角形策略和三角形策略之间的唯一区别在于，在每个完整周期结束时，基本学习率和最大学习率之间的差值减半。</li><li id="d85e" class="ne nf it lx b ly nn mb no li np lm nq lq nr mn nj nk nl nm bi translated"><em class="mw"> exp_range </em> —这里的学习率从最小值到最大值变化，但唯一的区别是每个边界值(最小值和最大值)以gamma^iteration(gamma的指数因子下降，直到迭代。</li></ol><h2 id="8837" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用循环学习率训练模型</h2><p id="c54f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">既然你对什么是循环学习率有一个确切的概念，让我们用循环学习率来训练一个模型，看看它是否比一个单一学习率的模型表现得更好。</p><p id="8713" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了使我们的实验更快，我们将使用来自MNIST(改进的国家标准和技术研究所)数据集的一个小子集。让我们从实验开始:</p><ol class=""><li id="d83d" class="ne nf it lx b ly mo mb mp li ng lm nh lq ni mn nj nk nl nm bi translated">导入必要的模块。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">导入必要的模块</p></figure><p id="9d58" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">2.下载MNIST数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">下载mnist数据集</p></figure><p id="107a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">正如我所说的，我们将只下载完整的MNIST数据集的一小部分。</p><p id="a1de" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">3.现在，我们将创建一个自定义数据集类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义数据集类</p></figure><p id="99d0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">4.使用PyTorch数据加载器构建所需的转换并加载数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加载数据</p></figure><p id="cb7e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">由于下载的MNIST数据集是张量形式的，PyTorch数据类只接受PIL(Python图像库)图像，我们需要将数据集转换成PIL图像，并将其转换成张量，然后输入数据加载器。</p><p id="f592" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">数据集以这样的方式分割，8000个数据点用于训练，其余的用于验证(大约2000个数据点)。</p><p id="5a3c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">5.现在让我们创建一个验证函数来计算我们的模型在验证数据上的损失和准确性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">验证功能</p></figure><p id="a5e6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">6.现在，让我们创建我们的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建模型</p></figure><p id="deab" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们将使用resnet18(没有预训练的权重)作为具有交叉熵损失和adam优化器的模型。</p><p id="0b56" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">7.现在我们都准备好训练我们的模型了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用循环学习率进行训练</p></figure><p id="5ea9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在数据加载器的每次迭代中，我们将使用循环学习率函数来更新优化器中的学习率值，这个函数是我们之前使用numpy实现的。</p><p id="002a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在上面的代码中，我们使用的步长等于训练数据加载器的两倍，学习率边界在1e-3和1e-2之间。</p><p id="dedc" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们还将在每次迭代后存储精度值，以便将结果与使用单一学习率训练的另一个模型进行比较。</p><p id="0f77" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">9.现在，我们将快速创建和训练另一个模型，但只有一个学习率值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="eb17" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们将使用之前使用的相同数据集来训练模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="86bf" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">8.现在，让我们比较我们的模型训练4个时期的结果和另一个模型训练8个时期的结果，但是具有单一学习率，即0.001(Adam优化器的默认值)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于比较结果的代码</p></figure><p id="1b58" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在上述代码中，术语“acc1”是用单一学习率训练的模型的精度值，术语“acc”是用循环学习率训练的模型的精度值。</p><p id="53f9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">上面的代码给出了如下图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/33beb79a34f7638fe84f7dc923b55d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcbIlN1NaDEKWxGIzZd68g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5394" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">从上面的图中可以清楚地看出，使用循环学习率(红线)训练的模型比使用固定学习率(蓝线)训练的模型获得了更高的精度，即使迭代次数更少。</p><h2 id="3961" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">寻找最佳学习率范围</h2><p id="4a2b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">正如我之前说过的，有一种技术可以使用一种技术找到最佳的学习速度范围。这种技术被称为论文中提到的“LR范围测试”。</p><blockquote class="mt mu mv"><p id="3711" class="lv lw mw lx b ly mo ju ma mb mp jx md mx mq mf mg my mr mi mj mz ms ml mm mn im bi translated">有一种简单的方法来估计合理的最小和最大边界值，只需在几个时期内对网络进行一次训练。这是一个“LR范围测试”。</p></blockquote><p id="6768" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这是通过将最小学习率设置为小值(如1e-07)并将最大学习率设置为高值来实现的。然后对模型进行一些迭代训练，然后对每个学习率获得的损失进行绘图。</p><p id="ddc6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这在fastai库中很好地实现了，但是也有同样的PyTorch实现。</p><p id="8aea" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">但是为此，我们需要使用pip安装一个名为torch-lr-finder的库，如下所示:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="cf3d" class="kz la it nu b gy ny nz l oa ob">pip install torch-lr-finder</span></pre><p id="1b66" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在我们可以测试学习率的最佳范围，并将其传递到我们的模型中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d34a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们将通过我们的模型、损失函数、优化器和设备(cuda或cpu)来初始化学习率查找器。</p><p id="a65e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们通过训练数据加载器、验证数据加载器、最小学习率(非常低的值)和最大学习率(非常高的值)来开始学习率范围测试。</p><p id="bf0e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">运行上面的代码后，我们得到一个带有学习率建议的图，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/5ad11ba3c1495624aa7b681e8b7ac0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*e-kYdzR2ealiSrJWN2ccvg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3bd7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">从图中，我们可以看到损失值从大约3e-4的值继续减小到1e-3的值，因此这些值可以用作我们的学习率的最小和最大值。学习率查找器建议的最佳学习率是5.21e-04，也在此范围内，如果您希望以单一学习率训练模型，可以使用该学习率。</p><h2 id="e4ac" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用PyTorch的学习率计划程序</h2><p id="4096" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">PyTorch提供了一个学习率调度器来改变学习率，如上所述。</p><p id="7e21" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">因此，让我们使用PyTorch的学习率调度程序来训练一个模型，该模型具有与我们之前使用的相同的架构、超参数、优化器和损失函数。</p><p id="8494" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们从PyTorch导入学习率调度器，快速构建模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">正在初始化CyclicLR计划程序</p></figure><p id="be6d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，我们将训练我们的模型，并使用学习率调度程序来更新学习率。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用调度器训练模型并更新学习率</p></figure><p id="e488" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">从上面的代码中可以看出，在数据加载器的每次迭代之后，学习率会使用调度器进行更新。</p><p id="ce5b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在4个时期之后，该模型给出了与使用我们构建的循环学习率函数训练的模型相同的准确度(98.2638)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/13bfbce2d6ec963ef9fc4f0178c51fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*zlCw0BYfF-V0PY3Lwg4MfA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e607" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">📎需要记住的一些要点是:</p><ol class=""><li id="adfa" class="ne nf it lx b ly mo mb mp li ng lm nh lq ni mn nj nk nl nm bi translated">将学习率从最小值(低值)增加到最大值(高值)可能会有短期的负面影响，但从长期来看，它会产生更好的结果。</li><li id="d516" class="ne nf it lx b ly nn mb no li np lm nq lq nr mn nj nk nl nm bi translated">循环学习率有助于在训练时摆脱鞍点。</li><li id="3ce3" class="ne nf it lx b ly nn mb no li np lm nq lq nr mn nj nk nl nm bi translated">最好将步长设置为数据加载器在单个历元内迭代次数(或训练数据加载器的长度)的2-10倍。</li><li id="3e27" class="ne nf it lx b ly nn mb no li np lm nq lq nr mn nj nk nl nm bi translated">最好在周期结束时停止训练，也就是说，当学习率最低时。</li><li id="161f" class="ne nf it lx b ly nn mb no li np lm nq lq nr mn nj nk nl nm bi translated">一个经验法则是将最小学习速率保持在最大学习速率的1/3或1/4。</li><li id="2a6d" class="ne nf it lx b ly nn mb no li np lm nq lq nr mn nj nk nl nm bi translated">无论何时开始一个新的数据集或架构，学习率范围测试都是获得最佳学习率值或最佳学习率范围的好方法。</li></ol><h2 id="146d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="e75d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这是一个非常棒的技术，可以用在你日常的神经网络训练中。</p><p id="fac4" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果你仍然怀疑循环学习率的能力，那么你一定要看看这篇论文的实验部分，你也应该尝试自己的循环学习率实验，以了解它的能力。</p><p id="4285" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">您可以将这种技术与其他方法(如自适应学习率技术)结合起来，以获得强大的模型。</p><p id="6e66" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">有许多技术在深度学习爱好者中并不流行，这些技术可能会提高您的模型的泛化能力，或者减少训练模型的时间，从而节省您的大量宝贵时间。</p><p id="1251" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果您希望获得本文中讨论的完整代码，您可以在这个<a class="ae ky" href="https://github.com/bipinKrishnan/fastai_course" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到它。</p></div></div>    
</body>
</html>