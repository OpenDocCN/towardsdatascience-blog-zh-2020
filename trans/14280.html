<html>
<head>
<title>How to Build a Movie Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何建立电影推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-movie-recommendation-system-67e321339109?source=collection_archive---------4-----------------------#2020-10-02">https://towardsdatascience.com/how-to-build-a-movie-recommendation-system-67e321339109?source=collection_archive---------4-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/32ae87302415c9a2d67b45b2b7b32faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jb306SqcT0f-5ZFe"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Noom Peerapong 在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="9b2b" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">动手教程</a>，机器学习</h2><div class=""/><div class=""><h2 id="28c3" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">构建简单推荐系统的逐步指南</h2></div><p id="a908" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">你有没有想过YouTube是怎么推荐内容的，或者脸书是怎么推荐你的，新朋友？也许你已经注意到了LinkedIn connections的类似推荐，或者当你在浏览时亚马逊将如何推荐类似的产品。所有这些推荐都是通过推荐系统的实现而成为可能的。</p><p id="7c0f" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">推荐系统包括一类可以向用户建议“相关”项目的技术和算法。他们通过包括矩阵分解在内的多种技术，根据过去的数据预测未来的行为。</p><p id="3884" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这篇文章中，我将看看为什么我们需要推荐系统和不同类型的在线用户。然后，我将向您展示如何使用开源数据集构建您自己的电影推荐系统。</p><h2 id="cc0c" class="ma mb jg bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr jm bi translated">内容</h2><ul class=""><li id="0d22" class="ms mt jg lg b lh mu lk mv ln mw lr mx lv my lz mz na nb nc bi translated">为什么我们需要推荐系统？</li><li id="3193" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">推荐系统的类型<br/> A)基于内容的电影推荐系统<br/> B)协同过滤电影推荐系统</li><li id="53ba" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">数据集</li><li id="e110" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">电影推荐系统的设计</li><li id="70a3" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">实现<br/>步骤1:基于矩阵分解的算法<br/>步骤2:创建手工制作的特征<br/>步骤3:为我们的电影推荐系统创建最终模型</li><li id="ecdd" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">性能指标</li><li id="910c" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">摘要</li></ul><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="1c17" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">为什么我们需要推荐系统？</h1><p id="cdb5" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">我们现在生活在一些人称之为“富足时代”的时代。对于任何给定的产品，有时有成千上万的选项可供选择。想想上面的例子:流媒体视频、社交网络、网上购物；这样的例子不胜枚举。推荐系统有助于个性化平台，帮助用户找到他们喜欢的东西。</p><p id="7a81" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最简单易行的方法就是推荐最受欢迎的单品。然而，要真正通过个性化推荐提升用户体验，我们需要专门的推荐系统。</p><p id="e884" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从商业角度来看，用户在平台上找到的相关产品越多，他们的参与度就越高。这通常会增加平台本身的收入。各种消息来源称，多达35-40%的科技巨头的收入仅来自推荐。</p><p id="0c85" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在我们已经了解了推荐系统的重要性，让我们来看看推荐系统的类型，然后用开源数据构建我们自己的推荐系统！</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="5c59" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">推荐系统的类型</h1><p id="8176" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">推荐系统中的机器学习算法通常分为两类:基于内容的系统和协同过滤系统。现代推荐系统结合了这两种方法。</p><p id="c954" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们看看他们是如何使用电影推荐系统作为基础的。</p><h1 id="02b1" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">a)基于内容的电影推荐系统</h1><p id="498e" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">基于内容的方法是基于电影属性的相似性。使用这种类型的推荐系统，如果用户观看一部电影，相似的电影被推荐。例如，如果用户观看亚当·桑德勒主演的喜剧电影，系统将向他们推荐相同类型或相同演员主演的电影，或者两者都推荐。考虑到这一点，构建基于内容的推荐系统的输入是电影属性。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ob"><img src="../Images/d7d7afb2898bc765fcdaf6c6ff4f5c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsuGJVJSqhhhNySFnt7EVw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图1:基于内容的推荐系统概述(图片由作者创建)</p></figure><h1 id="9857" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">b)协同过滤电影推荐系统</h1><p id="357c" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">通过协同过滤，该系统基于用户和电影之间过去的交互。考虑到这一点，协同过滤系统的输入由用户与他们观看的电影的交互的过去数据组成。</p><p id="a561" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">例如，如果用户A观看M1、M2和M3，而用户B观看M1、M3、M4，我们向相似的用户c推荐M1和M3。为了更清楚地参考，您可以在下图中看到这种情况。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/57af64f12d7a7be8b23e24c6ce0893bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*pv6CDVqPgITYi_Nr0RygUw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><em class="od">图2:协同过滤电影推荐系统的示例(由作者创建的图像)</em></p></figure><p id="cc4a" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些数据存储在一个名为用户-电影交互矩阵的矩阵中，其中行是用户，列是电影。</p><p id="5763" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，让我们使用上面讨论的概念来实现我们自己的电影推荐系统。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="4fcb" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">数据集</h1><p id="c88e" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">对于我们自己的系统，我们将使用来自GroupLens的开源<a class="ae jd" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"> MovieLens数据集</a>。这个数据集包含各种电影和用户的100K个数据点。</p><p id="2895" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将使用三列数据:</p><ul class=""><li id="af53" class="ms mt jg lg b lh li lk ll ln oe lr of lv og lz mz na nb nc bi translated">使用者辩证码</li><li id="0bc2" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">电影Id</li><li id="a986" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">等级</li></ul><p id="7a70" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您可以在下面的图3中看到数据的快照:</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/14832bbf3c7c1feeea2ccc5a2579ebda.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*Tmjknz0VUyDhXl5h.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图3:数据快照(图片由作者提供)</p></figure><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="88a2" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">设计我们的电影推荐系统</h1><p id="cb34" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">为了获得对用户的推荐，我们将预测他们对尚未观看的电影的评分。然后基于这些预测的评级，电影被编入索引并被推荐给用户。</p><p id="3076" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为此，我们将使用电影和用户评级的过去记录来预测他们未来的评级。在这一点上，值得一提的是，在现实世界中，我们很可能会遇到没有历史的新用户或电影。这种情况被称为冷启动问题。</p><p id="e2ad" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们简单看看如何解决冷启动问题。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="832a" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">冷启动问题</h1><p id="65a7" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">冷启动问题可以通过基于元信息的建议来处理，例如:</p><ul class=""><li id="833c" class="ms mt jg lg b lh li lk ll ln oe lr of lv og lz mz na nb nc bi translated">对于新用户，我们可以使用他们的位置、年龄、性别、浏览器和用户设备来预测推荐。</li><li id="f93b" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">对于新电影，我们可以用流派、演员、剧组来推荐给目标用户。</li></ul><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="adb1" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">履行</h1><p id="5989" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">对于我们的推荐系统，我们将使用上面提到的两种技术:基于内容的和协同过滤。对于我们的基于内容的方法，为了找到电影之间的相似性，我们将使用余弦相似性函数。对于我们的协作过滤方法，我们将使用矩阵分解技术。</p><p id="31f0" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">第一步是创建一个基于矩阵分解的模型。我们将使用这个模型的输出和一些手工制作的功能来为最终的模型提供输入。基本流程如下所示:</p><ul class=""><li id="a1d5" class="ms mt jg lg b lh li lk ll ln oe lr of lv og lz mz na nb nc bi translated">步骤1:构建基于矩阵分解的模型</li><li id="b166" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">步骤2:创建手工制作的特征</li><li id="c7ac" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">步骤3:实现最终模型</li></ul><p id="cce4" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将在下面详细讨论这些步骤。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="5460" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">步骤1:基于矩阵分解的算法</h1><p id="8c3c" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated"><a class="ae jd" href="https://datajobs.com/data-science-repo/Recommender-Systems-[Netflix].pdf" rel="noopener ugc nofollow" target="_blank">矩阵分解</a>是一类用于推荐系统的协同过滤算法。由于非常有效，这一系列方法在<a class="ae jd" href="https://netflixprize.com/index.html" rel="noopener ugc nofollow" target="_blank">网飞奖挑战赛</a>期间广为人知。</p><p id="48b1" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">矩阵分解算法通过将用户-电影交互矩阵分解成两个较低维度的矩形矩阵(比如U和m)的乘积来工作。分解以这样的方式完成，使得乘积产生与用户-电影交互矩阵几乎相似的值。这里U代表用户矩阵，M代表电影矩阵，n代表用户数，M代表电影数。</p><p id="44ad" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">用户矩阵的每一行代表一个用户，电影矩阵的每一列代表一部电影。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/034d3d1eea1185f934746b97aff3a1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXi0LB3kgjXI9meTYB1Raw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图4:矩阵分解(图片由作者创建)</p></figure><p id="0887" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一旦我们获得了U和M矩阵，基于用户-电影交互矩阵中的非空单元，我们执行U和M的乘积，并预测用户-电影交互矩阵中非空单元的值。</p><p id="3a7d" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了实现矩阵分解，我们使用了一个简单的名为Surprise的Python库，用于构建和测试推荐系统。数据帧被转换成训练集，一种被惊喜库接受的数据集格式。</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="b18f" class="ma mb jg ok b gy oo op l oq or">from surprise import SVD<br/>import numpy as np<br/>import surprise</span><span id="70cf" class="ma mb jg ok b gy os op l oq or">from surprise import Reader, Dataset<br/># It is to specify how to read the data frame.<br/>reader = Reader(rating_scale=(1,5))</span><span id="7a2b" class="ma mb jg ok b gy os op l oq or"># create the traindata from the data frame<br/>train_data_mf = Dataset.load_from_df(train_data[['userId', 'movieId', 'rating']], reader)</span><span id="d5a8" class="ma mb jg ok b gy os op l oq or"># build the train set from traindata. <br/>#It is of dataset format from surprise library<br/>trainset = train_data_mf.build_full_trainset()</span><span id="c02d" class="ma mb jg ok b gy os op l oq or">svd = SVD(n_factors=100, biased=True, random_state=15, verbose=True)<br/>svd.fit(trainset)</span></pre><p id="1b20" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在模型准备好了。我们将存储这些预测，并作为附加特征传递给最终模型。这将有助于我们将协同过滤整合到我们的系统中。</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="495c" class="ma mb jg ok b gy oo op l oq or">#getting predictions of train set<br/>train_preds = svd.test(trainset.build_testset())<br/>train_pred_mf = np.array([pred.est for pred in train_preds])</span></pre><p id="6b79" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">请注意，我们还必须对测试数据执行上述步骤。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="665f" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">步骤2:创建手工特征</h1><p id="4884" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">让我们将数据帧格式的数据转换成用户-电影交互矩阵。在这类问题中使用的矩阵通常是稀疏的，因为用户很可能只对几部电影进行评级。</p><p id="d009" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">数据的稀疏矩阵格式(也称为CSR格式)的优点如下:</p><ul class=""><li id="05ec" class="ms mt jg lg b lh li lk ll ln oe lr of lv og lz mz na nb nc bi translated">高效的算术运算:CSR + CSR，CSR * CSR等。</li><li id="d9eb" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">高效的行切片</li><li id="75f0" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">快速矩阵向量乘积</li></ul><p id="2266" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">scipy.sparse.csr_matrix是一个实用函数，可以有效地将数据帧转换为稀疏矩阵。</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="1fe3" class="ma mb jg ok b gy oo op l oq or"># Creating a sparse matrix<br/>train_sparse_matrix = sparse.csr_matrix((train_data.rating.values, (train_data.userId.values, train_data.movieId.values)))</span></pre><p id="4696" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">‘train _ sparse _ matrix’是train_data数据帧的稀疏矩阵表示。</p><p id="8930" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将使用此稀疏矩阵创建3组特征:</p><ol class=""><li id="db03" class="ms mt jg lg b lh li lk ll ln oe lr of lv og lz ot na nb nc bi translated">代表全球平均值的特征</li><li id="7aba" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz ot na nb nc bi translated">代表前五名相似用户的功能</li><li id="1f38" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz ot na nb nc bi translated">代表前五部类似电影的特写</li></ol><p id="c1fc" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们更详细地了解一下如何准备每一项。</p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><h2 id="021d" class="ma mb jg bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr jm bi translated">1.代表全球平均值的特征</h2><p id="2341" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">我们将采用的三个全球平均值是:</p><ol class=""><li id="c7d8" class="ms mt jg lg b lh li lk ll ln oe lr of lv og lz ot na nb nc bi translated">所有用户对所有电影的平均评分</li><li id="43b9" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz ot na nb nc bi translated">所有用户对特定电影的平均评级</li><li id="bf39" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz ot na nb nc bi translated">特定用户给出的所有电影的平均评级</li></ol><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="4cd6" class="ma mb jg ok b gy oo op l oq or">train_averages = dict()<br/># get the global average of ratings in our train set.<br/>train_global_average = train_sparse_matrix.sum()/train_sparse_matrix.count_nonzero()<br/>train_averages['global'] = train_global_average<br/>train_averages</span><span id="ba35" class="ma mb jg ok b gy os op l oq or">Output: {‘global’: 3.5199769425298757}</span><span id="e868" class="ma mb jg ok b gy os op l oq or">Next, let’s create a function which takes the sparse matrix as input and gives the average ratings of a movie given by all users, and the average rating of all movies given by a single user.</span><span id="ae85" class="ma mb jg ok b gy os op l oq or"># get the user averages in dictionary (key: user_id/movie_id, value: avg rating)<br/>def get_average_ratings(sparse_matrix, of_users):</span><span id="8a1d" class="ma mb jg ok b gy os op l oq or"># average ratings of user/axes<br/>ax = 1 if of_users else 0 # 1 - User axes,0 - Movie axes</span><span id="97d6" class="ma mb jg ok b gy os op l oq or"># ".A1" is for converting Column_Matrix to 1-D numpy array<br/>sum_of_ratings = sparse_matrix.sum(axis=ax).A1</span><span id="dc27" class="ma mb jg ok b gy os op l oq or"># Boolean matrix of ratings ( whether a user rated that movie or not)<br/>is_rated = sparse_matrix!=0</span><span id="f16f" class="ma mb jg ok b gy os op l oq or"># no of ratings that each user OR movie..<br/>no_of_ratings = is_rated.sum(axis=ax).A1</span><span id="f025" class="ma mb jg ok b gy os op l oq or"># max_user and max_movie ids in sparse matrix<br/>u,m = sparse_matrix.shape<br/># create a dictionary of users and their average ratings..<br/>average_ratings = { i : sum_of_ratings[i]/no_of_ratings[i]</span><span id="fa83" class="ma mb jg ok b gy os op l oq or">for i in range(u if of_users else m)<br/>if no_of_ratings[i] !=0}</span><span id="0c74" class="ma mb jg ok b gy os op l oq or">#return that dictionary of average ratings<br/>return average_ratings</span></pre><p id="72d9" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">平均评级由用户给出:</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="508e" class="ma mb jg ok b gy oo op l oq or">train_averages['user'] = get_average_ratings(train_sparse_matrix, of_users=True)</span></pre><p id="69f5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">电影的平均评级如下:</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="258d" class="ma mb jg ok b gy oo op l oq or">train_averages['movie'] = get_average_ratings(train_sparse_matrix, of_users=False)</span></pre></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><h2 id="f721" class="ma mb jg bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr jm bi translated">2.代表前5名相似用户的功能</h2><p id="0d8e" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">在这组功能中，我们将创建对特定电影进行评级的前5名相似用户。使用用户之间的余弦相似度来计算相似度。</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="107b" class="ma mb jg ok b gy oo op l oq or"># compute the similar Users of the "user"</span><span id="1a84" class="ma mb jg ok b gy os op l oq or">user_sim = cosine_similarity(train_sparse_matrix[user], train_sparse_matrix).ravel()<br/>top_sim_users = user_sim.argsort()[::-1][1:] # we are ignoring 'The User' from its similar users.</span><span id="1066" class="ma mb jg ok b gy os op l oq or"># get the ratings of most similar users for this movie<br/>top_ratings = train_sparse_matrix[top_sim_users, movie].toarray().ravel()</span><span id="335f" class="ma mb jg ok b gy os op l oq or"># we will make it's length "5" by adding movie averages to<br/>top_sim_users_ratings = list(top_ratings[top_ratings != 0][:5])<br/>top_sim_users_ratings.extend([train_averages['movie'][movie]]*(5 -len(top_sim_users_ratings)))</span></pre></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><h2 id="bbce" class="ma mb jg bd mc md me dn mf mg mh dp mi ln mj mk ml lr mm mn mo lv mp mq mr jm bi translated">3.代表前5部相似电影的特征</h2><p id="1958" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">在这组特征中，我们获得了由特定用户评价的前5部相似电影。使用电影之间的余弦相似度来计算该相似度。</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="6c1a" class="ma mb jg ok b gy oo op l oq or"># compute the similar movies of the "movie"<br/>movie_sim = cosine_similarity(train_sparse_matrix[:,movie].T,<br/>train_sparse_matrix.T).ravel()<br/>top_sim_movies = movie_sim.argsort()[::-1][1:]</span><span id="691b" class="ma mb jg ok b gy os op l oq or"># we are ignoring 'The User' from its similar users.<br/># get the ratings of most similar movie rated by this user<br/>top_ratings = train_sparse_matrix[user, top_sim_movies].toarray().ravel()</span><span id="eaf5" class="ma mb jg ok b gy os op l oq or"># we will make it's length "5" by adding user averages to<br/>top_sim_movies_ratings = list(top_ratings[top_ratings != 0][:5])<br/>top_sim_movies_ratings.extend([train_averages['user'][user]]*(5-len(top_sim_movies_ratings)))</span></pre><p id="370a" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们为每个电影用户对添加所有这些特征，并创建一个数据框。图5是我们的数据框的快照。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pb"><img src="../Images/9211cb31b90ba96974264ad86d08ed1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SIGOks9EEfRANi6T.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图5:包含13个特性的数据概述</p></figure><p id="58d2" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">以下是其内容的更详细的分类:</p><ul class=""><li id="8ae0" class="ms mt jg lg b lh li lk ll ln oe lr of lv og lz mz na nb nc bi translated">GAvg:所有评分的平均评分</li><li id="b451" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">这部电影的相似用户评分:sur1、sur2、sur3、sur4、sur5(对这部电影评分的前5名相似用户)</li><li id="e856" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">此用户评价的相似电影:smr1、smr2、smr3、smr4、smr5(用户评价的前5部相似电影)</li><li id="173d" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">用户平均评分</li><li id="8ba5" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">MAvg:这部电影的平均评分</li><li id="c389" class="ms mt jg lg b lh nd lk ne ln nf lr ng lv nh lz mz na nb nc bi translated">分级:此用户对此电影的分级。</li></ul><p id="90e0" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一旦我们准备好这13个特性，我们将添加矩阵分解输出作为第14个特性。在图6中，您可以看到添加步骤1的输出后的数据快照。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pc"><img src="../Images/082385593060acddfe0cf8665a89b74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zvcVS95LTqxFU8LX.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图6:具有13个特征和矩阵分解输出的数据概述(图片由作者提供)</p></figure><p id="be3e" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后一列名为mf_svd，是包含步骤1中执行的模型输出的附加列。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="6d03" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">步骤3:为我们的电影推荐系统创建一个最终模型</h1><p id="581a" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">为了创建我们的最终模型，让我们使用<a class="ae jd" href="https://xgboost.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>，一个优化的分布式梯度增强库。</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="f92d" class="ma mb jg ok b gy oo op l oq or"># prepare train data<br/>x_train = final_data.drop(['user', 'movie','rating'], axis=1)<br/>y_train = final_data['rating']<br/># initialize XGBoost model<br/>xgb_model = xgb.XGBRegressor(silent=False, n_jobs=13,random_state=15,n_estimators=100)<br/># fit the model<br/>xgb_model.fit(x_train, y_train, eval_metric = 'rmse')</span></pre><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="09aa" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">性能指标</h1><p id="58ba" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">评价推荐系统的性能主要有两种方法:均方根误差(RMSE)和平均绝对百分比误差(MAPE)。RMSE衡量的是平方损失，而MAPE衡量的是绝对损失。较低的值意味着较低的错误率，因此性能更好。</p><p id="f6c0" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">两者都很好，因为它们允许简单的解释。让我们来看看它们分别是什么:</p><h1 id="7613" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">均方根误差(RMSE)</h1><p id="8714" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">RMSE是误差平方平均值的平方根，由下式给出。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/8c32ab579da3e354df19074d2df9e4c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/0*NNoASArJ2PxFbzNg.png"/></div></figure><p id="936a" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">其中:<br/> r是实际收视率，<br/> r^是预测收视率，<br/> N是预测总数</p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><h1 id="8879" class="nn mb jg bd mc no pe nq mf nr pf nt mi kv pg kw ml ky ph kz mo lb pi lc mr nx bi translated">平均绝对百分比误差(MAPE)</h1><p id="ef54" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">MAPE用百分比来衡量误差。它由下面的公式给出:</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/ae8019ca1093cca129432f029febcb8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/0*YmbNzU_OsvdL2apL.png"/></div></figure><p id="5ef5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">其中:<br/> r是实际收视率，<br/> r^是预测收视率，<br/> N是预测总数</p><pre class="nj nk nl nm gt oj ok ol om aw on bi"><span id="807a" class="ma mb jg ok b gy oo op l oq or">#dictionaries for storing train and test results<br/>test_results = dict()<br/># from the trained model, get the predictions<br/>y_est_pred = xgb_model.predict(x_test)<br/># get the rmse and mape of train data<br/>rmse = np.sqrt(np.mean([ (y_test.values[i] - y_test_pred[i])**2 for i in<br/>range(len(y_test_pred)) ]))<br/>mape = np.mean(np.abs( (y_test.values- y_test_pred)/y_true.values )) * 100<br/># store the results in train_results dictionary<br/>test_results = {'rmse': rmse_test, 'mape' : mape_test, 'predictions' : y_test_pred}</span></pre><figure class="nj nk nl nm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pk"><img src="../Images/4b9b4ae85b61a151b326ad27f66a9aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*isRRGIjBwFdShyzd.png"/></div></div></figure><p id="c558" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们的模型在看不见的测试数据上得到0.67的RMSE和19.86的MAPE，这是一个很好的模型。小于2的RMSE值被认为是好的，小于25的MAPE是极好的。也就是说，这种模式可以通过添加功能来进一步增强，这些功能将根据位置或流派的最佳选择进行推荐。我们还可以通过A/B测试实时测试各种模型的功效。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><h1 id="58bf" class="nn mb jg bd mc no np nq mf nr ns nt mi kv nu kw ml ky nv kz mo lb nw lc mr nx bi translated">摘要</h1><p id="6b87" class="pw-post-body-paragraph le lf jg lg b lh mu kq lj lk mv kt lm ln ny lp lq lr nz lt lu lv oa lx ly lz ij bi translated">在本文中，我们学习了推荐系统的重要性，正在实现的推荐系统的类型，以及如何使用矩阵分解来增强系统。然后，我们构建了一个电影推荐系统，它考虑了用户-用户相似性、电影-电影相似性、全局平均值和矩阵分解。这些概念可以应用于任何其他用户-项目交互系统。</p><p id="dab1" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">感谢阅读！如果你想自己试验这个自定义数据集，你可以在<a class="ae jd" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"> GroupLens </a>下载带注释的数据，并在<a class="ae jd" href="https://github.com/RamyaVidiyala/MovieRecommenderSystem" rel="noopener ugc nofollow" target="_blank"> Github </a>查看我的代码。</p><figure class="nj nk nl nm gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/85ae43ab2bc681c76ea69fc1b64ac999.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*XNAW-HhJKgddajOM9ql7QQ.png"/></div></figure><p id="7a77" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">谢谢你的阅读。本文原载<a class="ae jd" href="https://lionbridge.ai/articles/step-by-step-guide-to-building-a-movie-recommendation-system/" rel="noopener ugc nofollow" target="_blank">此处</a>。我也将在未来写更多初学者友好的帖子。请在<a class="ae jd" href="https://medium.com/@ramyavidiyala" rel="noopener">媒体</a>上关注我，以便了解他们。我欢迎反馈，可以通过Twitter <a class="ae jd" href="https://twitter.com/ramya_vidiyala" rel="noopener ugc nofollow" target="_blank"> ramya_vidiyala </a>和LinkedIn <a class="ae jd" href="https://www.linkedin.com/in/ramya-vidiyala-308ba6139/" rel="noopener ugc nofollow" target="_blank"> RamyaVidiyala </a>联系我。快乐学习！</p></div></div>    
</body>
</html>