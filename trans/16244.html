<html>
<head>
<title>Pytorch model in Deep Java Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度Java库中的Pytorch模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pytorch-model-in-deep-java-library-a9ca18d8ce51?source=collection_archive---------20-----------------------#2020-11-09">https://towardsdatascience.com/pytorch-model-in-deep-java-library-a9ca18d8ce51?source=collection_archive---------20-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="44b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从PyTorch模型构建到DJL推理的简单端到端工作流程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/074877a572de9923cf75a50adc5a4070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4UsV0SeQ2F8EDJ2W"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>拍照</p></figure><p id="f8ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://ai.facebook.com/tools/pytorch/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>是一个快速发展且非常流行的开源机器学习框架。它的命令式设计与类似“numpy”的工作流程相结合，使它成为初学者和专业人士的首选。然而，在生产中服务这些模型并不简单，如果目标是在Java中本地服务它们，事情会特别困难。</p><p id="07f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">亚马逊的<a class="ae kv" href="https://docs.djl.ai/docs/quick_start.html" rel="noopener ugc nofollow" target="_blank"> Deep Java Library </a> (DJL)旨在通过提供高级API来解决这个特殊的痛点，这些API可以用很少的代码在PyTorch模型上运行推理。我最近与DJL的试驾告诉我，它可能是一个非常强大的工具，但现有的示例集和社区指南(也称为stackoverflow help:)可能会让新手感到有点害怕，特别是那些来自python背景并且不熟悉java风格的人。希望这个简单的演示能让他们的工作更轻松。所有的脚本也可以在我的git repo <a class="ae kv" href="https://github.com/bhattacharyya/DJL_Pytorch_Demo" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="1647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先用PyTorch创建一个简单的线性回归模型。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3695" class="lx ly iq lt b gy lz ma l mb mc">import torch<br/>import torch.nn as nn</span><span id="3e45" class="lx ly iq lt b gy md ma l mb mc">X = torch.tensor([[1],[2],[4],[7],[9]], dtype = torch.float32)<br/>Y = torch.tensor([[2],[4],[8],[14],[18]], dtype = torch.float32)</span><span id="fdb8" class="lx ly iq lt b gy md ma l mb mc">X_test = torch.tensor([[5]], dtype=torch.float32)</span><span id="6207" class="lx ly iq lt b gy md ma l mb mc">n_sample, n_features = X.shape</span><span id="8ea9" class="lx ly iq lt b gy md ma l mb mc">model = nn.Linear(n_features, n_features)</span><span id="14e6" class="lx ly iq lt b gy md ma l mb mc">learn_rate = 0.01<br/>n_epochs = 500</span><span id="16a9" class="lx ly iq lt b gy md ma l mb mc">loss = nn.MSELoss()<br/>optimizer = torch.optim.SGD(lr = learn_rate, params=model.parameters())</span><span id="1f0c" class="lx ly iq lt b gy md ma l mb mc">for i in range(0,n_epochs):<br/>    y_pred = model(X)<br/>    ls = loss(y_pred,Y)</span><span id="06eb" class="lx ly iq lt b gy md ma l mb mc">    ls.backward()<br/>    optimizer.step()<br/>    optimizer.zero_grad()</span><span id="440a" class="lx ly iq lt b gy md ma l mb mc">    [w,b] = model.parameters()</span><span id="087d" class="lx ly iq lt b gy md ma l mb mc">    traced_cell = torch.jit.trace(model, X_test)</span><span id="cebf" class="lx ly iq lt b gy md ma l mb mc">    #print(traced_cell(X_test).item())</span><span id="0c24" class="lx ly iq lt b gy md ma l mb mc">    print(f"{ls.item():0.3f}, {w[0][0].item():0.3f {model(X_test).item():0.3f}")</span><span id="687d" class="lx ly iq lt b gy md ma l mb mc">traced_cell.save('./model1.zip')</span></pre><p id="25cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模型(模型1)学习获取输入n并预测2 * n。</p><p id="6954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的脚本中有两行代码是PyTorch脚本中没有的。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="62d5" class="lx ly iq lt b gy lz ma l mb mc">1. traced_cell = torch.jit.trace(model, X_test) <br/>2. traced_cell.save('./model1.zip')</span></pre><p id="ea78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两行是创建一个<a class="ae kv" href="https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html" rel="noopener ugc nofollow" target="_blank"> TorchScript </a>模型(序列化pytorch模型)所必需的，该模型可以在高性能环境中以与语言无关的方式使用。我们现在将使用这个模型通过DJL来进行推论。我用了一个运行Java内核的Jupyter笔记本来做这个演示。</p><p id="b217" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1:获得所有需要的maven依赖项。DJL支持pytorch模型开箱即用。SLF4J用于伐木。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="bffc" class="lx ly iq lt b gy lz ma l mb mc">%maven ai.djl.pytorch:pytorch-engine:0.8.0<br/>%maven ai.djl.pytorch:pytorch-native-auto:1.6.0<br/>%maven org.slf4j:slf4j-simple:1.7.26</span></pre><p id="1590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果出现“未知解析器为空”的错误，现在可以忽略它们。</p><p id="aa4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2:导入所需的模块</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d856" class="lx ly iq lt b gy lz ma l mb mc">import ai.djl.*;<br/>import ai.djl.inference.*;<br/>import ai.djl.ndarray.*;<br/>import ai.djl.translate.*;<br/>import java.nio.file.*;</span></pre><p id="5009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里值得强调一下<a class="ae kv" rel="noopener" target="_blank" href="/ndarray-a-java-based-n-dim-array-toolkit-60b4035b10b8"> ndarray </a>的导入。n维数组是许多语言中流行的数据结构，numpy(python中的ndarray库)在深度学习领域或几乎任何涉及数值计算的应用程序中都非常普遍。</p><p id="2419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java没有类似的ndarray实现。DJL通过上述导入提供了ndarray功能。这是允许DJL使用PyTorch模型的关键因素之一。</p><p id="d5f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.声明模型路径和模型名称。这假设您正在使用一个本地生成的模型。DJL也提供了一些可以直接使用的标准模型。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="7206" class="lx ly iq lt b gy lz ma l mb mc">Path modelDir = Paths.get("Path_To_Your_Model_Folder/");<br/>Model model = Model.newInstance("model name");<br/>model.load(modelDir);<br/>model</span></pre><p id="d6a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当前的DJL文档说模型可以。zip，。tar，. tar.gz，.tgz或. tar.z</p><p id="6667" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果模型加载正确，您应该会看到类似ai . djl . py torch . engine . pt model @ 4c EFA 68 f的输出</p><p id="6c87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.翻译器处理预处理和后处理步骤。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="255d" class="lx ly iq lt b gy lz ma l mb mc">Translator&lt;Float, Float&gt; translator = new Translator&lt;Float, Float&gt;(){</span><span id="0bbc" class="lx ly iq lt b gy md ma l mb mc">    @Override<br/>    public NDList processInput(TranslatorContext ctx, Float input) {<br/>        NDManager manager = ctx.getNDManager();<br/>        NDArray array = manager.create(new float[] {input});<br/>        return new NDList (array);<br/>    }<br/>    <br/>    @Override<br/>    public Float processOutput(TranslatorContext ctx, NDList list) {<br/>        NDArray temp_arr = list.get(0);<br/>        return temp_arr.getFloat();<br/>    }<br/>    <br/>    <a class="ae kv" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@</a>Override<br/>    public Batchifier getBatchifier() {<br/>        // The Batchifier describes how to combine a batch together<br/>        // Stacking, the most common batchifier, takes N [X1, X2, ...] arrays to a single [N, X1, X2, ...] array<br/>        return Batchifier.STACK;<br/>    }<br/>};</span></pre><p id="247a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是最让大多数人困惑的一步。翻译器定义了输入和输出数据类型的签名<input type="" output=""/>。在我们的例子中，它们都是浮点数。确保使用float，而不是Float，因为显式需要引用。这个翻译步骤不是可选的。</p><p id="2a79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果您查看<a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/0.4.1/ai/djl/translate/PreProcessor.html" rel="noopener ugc nofollow" target="_blank">预处理器</a>的DJL文档，您会发现NDList是提供给模型的预处理输出的预期类型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f5f048d55c718b380e4c2f23d26cf262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*39Ur6iDT1DOeWE53cZYG7w.png"/></div></figure><p id="f132" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，即使假设您的输入已经是NDList类型，您仍然需要执行这一步。</p><p id="52c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/0.4.1/ai/djl/translate/PostProcessor.html" rel="noopener ugc nofollow" target="_blank">后处理</a>的情况类似。它使用NDList并输出您的翻译器描述的类型。</p><p id="778a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上三条也是强制性的。当然，DJL提供了预实现的翻译器，我推荐你去探索它们，尤其是图像处理的。</p><p id="3b31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.做出预测</p><p id="3a59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝贺您，您已经完成了艰苦的工作，离做出推论只有几行代码了。他们在这里</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9bc2" class="lx ly iq lt b gy lz ma l mb mc">Predictor&lt;Float, Float&gt; predictor = model.newPredictor(translator);<br/>predictor.predict(Your_Test_Float)</span></pre><p id="5c27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我的测试用例，我做了predictor.predict(2.9f)，它输出5.799781。啊，纯粹的快乐！</p><p id="da25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们看到了如何创建PyTorch模型，并在Java环境中使用该模型进行推理。尽管这是一个非常简单的用例。对于更高级的用例，让翻译人员正确地进行预处理和后处理可能需要一些迭代。此外，内置模块(如图像处理模块)的数量目前很少。</p><p id="dc08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，我相信DJL将会迅速发展，并可能成为在Java(或C++)环境中利用PyTorch模型的完美库，实现开发速度和高性能的完美结合。</p></div></div>    
</body>
</html>