<html>
<head>
<title>Collaborative Filtering in Pyspark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pyspark中的协同过滤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/collaborative-filtering-in-pyspark-52617dd91194?source=collection_archive---------27-----------------------#2020-10-09">https://towardsdatascience.com/collaborative-filtering-in-pyspark-52617dd91194?source=collection_archive---------27-----------------------#2020-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fa1d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="b4f3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">基于交替最小二乘(ALS)算法的协同过滤及其在Pyspark中的实现</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1c3305e17a2386504ac2a27146a0b922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ate1JDiPkPHIKDEM"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@buduczki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺贝特·布杜茨基</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="42a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你有没有想过Spotify是如何每周在“发现周刊”上发布一个歌曲列表，而你最终因为喜欢这些歌曲而将其中一些添加到你的播放列表中的？因为你昨天看了一个特别的节目，网飞推荐给你的那些节目怎么样？这些科技巨头怎么这么聪明？答案是推荐系统。</p><p id="cb2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">推荐系统基于用户的历史行为，如观看、搜索或购买历史，进行预测。推荐系统的两种常见方法是<strong class="lk jd">基于内容的</strong> <em class="me"> </em>和<strong class="lk jd">协同过滤</strong>，本文将深入探讨后者。</p><h1 id="0a19" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">什么是协同过滤？</h1><p id="9bea" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">协作过滤是一种数学方法，用于根据其他相似用户的评级来预测用户如何对特定项目进行评级。典型的协同过滤包括4个不同的阶段:</p><ol class=""><li id="3a0a" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">数据收集—收集用户行为和相关数据项</li><li id="3ed1" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">数据处理—处理收集的数据</li><li id="99af" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">建议计算—根据处理的数据计算推荐</li><li id="79cd" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">结果推导-提取相似性并返回前N个结果</li></ol><h1 id="a004" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">显性和隐性反馈</h1><p id="040a" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">那么，在协同过滤的第一阶段，收集的是什么类型的数据呢？有两种不同类别的数据(称为反馈)，可以是<strong class="lk jd">显性</strong>或<strong class="lk jd">隐性</strong>。</p><p id="b32b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显式反馈的一个例子是用户给出的评级，网飞收集这些评级是为了在客户对他们观看的电影进行评级后向他们提供建议。隐式反馈不那么直接，因为它基于用户与平台的互动，包括点击、观看、喜欢和购买。Spotify利用隐式反馈来实现它的推荐系统。</p><h1 id="3405" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">计算相似度</h1><p id="8613" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">一旦收集和处理了数据，就需要一些数学公式来进行相似性计算。两种最常见的方法是:</p><ol class=""><li id="819c" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nh ni nj nk bi translated">欧几里德距离——两个用户之间偏好的距离。如果距离小，则两个用户之间的相似性高</li><li id="1eba" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nh ni nj nk bi translated">皮尔逊相关-如果两个用户之间的余弦值(入射角)一致，则两个用户之间的相似性很高</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5df2e5994df283e714f50c86f1607e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*Ln-RCwWtInpd5f23w2R66w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片—余弦和欧几里德距离向量空间</p></figure><h1 id="3d0f" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">Pyspark中的实现</h1><p id="a038" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">库包<em class="me"> spark.ml </em>目前支持基于模型的协同过滤，其中用户和产品由一小组潜在因素描述，这些因素可用于进行预测。它使用<a class="ae lh" href="https://www.quora.com/What-is-the-Alternating-Least-Squares-method-in-recommendation-systems-And-why-does-this-algorithm-work-intuition-behind-this" rel="noopener ugc nofollow" target="_blank">交替最小二乘(ALS)算法</a>来学习这些潜在因素。</p><p id="6abd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将使用来自https://www.last.fm/api/<a class="ae lh" href="https://www.last.fm/api/" rel="noopener ugc nofollow" target="_blank">的数据集，其中包含3个文件:</a></p><ul class=""><li id="1fdd" class="nc nd it lk b ll lm lo lp lr ne lv nf lz ng md nr ni nj nk bi translated"><strong class="lk jd"> user_artist_data.txt </strong> 3列:userid artistid playcount</li><li id="4807" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nr ni nj nk bi translated">artistid artist_name</li><li id="69a3" class="nc nd it lk b ll nl lo nm lr nn lv no lz np md nr ni nj nk bi translated"><strong class="lk jd"> artist_alias.txt </strong> 2列:badid，goodid[已知拼写错误的艺术家和正确的艺术家id]</li></ul><p id="dbe3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们用下面的代码设置Spark。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="75c3" class="nx mg it nt b gy ny nz l oa ob"># import libraries</span><span id="e837" class="nx mg it nt b gy oc nz l oa ob">from pyspark import SparkContext<br/>from pyspark.ml.recommendation import ALS<br/>from pyspark.sql import SparkSession ,Row</span><span id="3b61" class="nx mg it nt b gy oc nz l oa ob">appName="Collaborative Filtering with PySpark"<br/># initialize the spark session<br/>spark = SparkSession.builder.appName(appName).getOrCreate()<br/># get sparkcontext from the sparksession<br/>sc = spark.sparkContext</span></pre><p id="8d19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们定义数据结构并将弹性分布式数据帧转换成数据帧。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="4e7b" class="nx mg it nt b gy ny nz l oa ob">from pyspark.sql.types import StructType,StructField,IntegerType,StringType,LongType<br/>from pyspark.sql.functions import col</span><span id="cac8" class="nx mg it nt b gy oc nz l oa ob">#Define the schema for the datasets<br/>schema_artist = StructType([StructField("artistId",StringType(),True),StructField("artistName",StringType(),True)])</span><span id="ace4" class="nx mg it nt b gy oc nz l oa ob">schema_user_artist = StructType([StructField("userId",StringType(),True),StructField("artistId",StringType(),True),StructField("playCount",StringType(),True)])</span><span id="2916" class="nx mg it nt b gy oc nz l oa ob">schema_alias = StructType([StructField("badId",StringType(),True),StructField("goodId",StringType(),True)])</span><span id="e7e2" class="nx mg it nt b gy oc nz l oa ob">#Convert RDDs into Dataframes<br/>artistRDD = rawArtistData.map(lambda k: k.split("\t"))artist_df = spark.createDataFrame(artistRDD,schema_artist,['artistId','artistName'])</span><span id="2ae9" class="nx mg it nt b gy oc nz l oa ob">userArtistRDD = rawUserArtistData.map(lambda k: k.split())user_artist_df = spark.createDataFrame(userArtistRDD,['userId','artistId','playCount'])</span><span id="2660" class="nx mg it nt b gy oc nz l oa ob">aliasRDD = rawArtistAlias.map(lambda k: k.split())alias_df = spark.createDataFrame(aliasRDD,['badId', 'goodId'])</span><span id="74fd" class="nx mg it nt b gy oc nz l oa ob">#First for convenience, we can create aliases for each dataframes<br/>ua = user_artist_df.alias('ua')<br/>ub = artist_df.alias('ub')</span></pre><p id="c46a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦数据集被处理，我们可以继续训练我们的ALS模型。在此之前，我们应该将数据集分成训练和测试数据，这样我们就可以知道我们的模型执行得有多好。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="5c26" class="nx mg it nt b gy ny nz l oa ob"># dataset split into training and testing set<br/>(training, test) = ua.randomSplit([0.8, 0.2])</span><span id="64c3" class="nx mg it nt b gy oc nz l oa ob"># training the model<br/>als = ALS(maxIter=5, implicitPrefs=True,userCol="userId", itemCol="artistId", ratingCol="playCount",coldStartStrategy="drop")<br/>model = als.fit(training)</span><span id="7a57" class="nx mg it nt b gy oc nz l oa ob"># predict using the testing datatset<br/>predictions = model.transform(test)<br/>predictions.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2ac36a676cd85ad219471bad9b916ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*ISdy0oPVbHq3DuBvzIZQTA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片—测试预测的Pyspark输出</p></figure><p id="bda1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以尝试使用该模型来找到为每个用户推荐的顶级艺术家。我们可以使用ALS模型中的<a class="ae lh" href="https://spark.apache.org/docs/2.2.0/api/python/pyspark.ml.html#pyspark.ml.recommendation.ALS" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd"><em class="me">recommended for allusers</em></strong></a>函数来获取每个用户的首选推荐列表。</p><p id="aaaa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的函数将<em class="me"> userId </em>和limit作为输入。对于给定的<em class="me">用户Id </em>，它获得当前最受欢迎艺术家的列表(基于<em class="me">播放计数</em>)。让我们尝试为用户(2062243)显示最喜欢的艺术家。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="1b0f" class="nx mg it nt b gy ny nz l oa ob">def currentLikes(ua,ub,userId,limit):<br/> df = ua.join(ub,ua.artistId==ub.artistId)\<br/> .filter(ua.userId==userId)\<br/> .sort(ua.playCount.desc())\<br/> .select(ua.userId,ua.playCount,ub.artistName)\<br/> .limit(limit)<br/> return df</span><span id="93ed" class="nx mg it nt b gy oc nz l oa ob"># display top 10 liked artists for user 2062243<br/>currentLikes(ua,ub,2062243,10).show(truncate=False)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8ab6735b3a805d650b795f5b1e813d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*mZ8vrQeB-f0Zd9nI8808XA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">按作者分类的图片Pyspark为用户2062243输出的最受欢迎的艺术家</p></figure><p id="6502" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，下面的函数使用该模型为每个用户给出艺术家的最佳推荐。我们试着为同一个用户(2062243)显示推荐的艺术家。</p><pre class="ks kt ku kv gt ns nt nu nv aw nw bi"><span id="fb9d" class="nx mg it nt b gy ny nz l oa ob">def recommendedArtists(userId,limit):<br/> test =  model.recommendForAllUsers(limit).filter(col('userId')==userId).select("recommendations").collect()<br/> topArtists = []<br/> for item in test[0][0]:<br/>  topArtists.append(item.artistId)<br/> <br/>schema = StructType([StructField("artistId",IntegerType(),True)])<br/>artists = spark.createDataFrame(topArtists,IntegerType())<br/>final=artists.join(ub,artists.value==ub.artistId).select(ub.artistId,ub.artistName)<br/>return final</span><span id="cc29" class="nx mg it nt b gy oc nz l oa ob"># display top 10 recommended artists for user 2062243<br/>recommendedArtists(2062243,10).show(truncate=False)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6c9b18c9f69cc3357ba781ad98dfd499.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*_c3nMAM8zP203MolVhTf2w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">按作者分类的图片-为用户2062243推荐的艺术家的Pyspark输出</p></figure><h1 id="b77c" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">摘要</h1><p id="e12d" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在这篇文章中，我们介绍了什么是协同过滤，以及它的4个不同阶段。协同过滤收集的两类数据，主要是<strong class="lk jd">隐式</strong>和<strong class="lk jd">显式反馈</strong>，使用<strong class="lk jd">欧氏距离</strong>或<strong class="lk jd">皮尔逊系数</strong>计算相似度。最后，简要介绍了使用spark中内置的<strong class="lk jd">交替最小二乘(ALS)算法</strong>在Pyspark中实现协同过滤的过程。希望你们对推荐系统的工作原理有一个简单的了解，下次在网上冲浪和使用Spotify/Amazon时，看到好的推荐，不要感到惊讶，干杯！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://www.buymeacoffee.com/tankahwang"><div class="gh gi og"><img src="../Images/4bc5de35955c00939383a18fb66b41d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*9vg3-OY14aZN1UpKwIxxZg.png"/></div></a></figure></div></div>    
</body>
</html>