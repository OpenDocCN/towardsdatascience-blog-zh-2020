<html>
<head>
<title>An Overview of The PEP 8 Style Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PEP 8风格指南概述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-overview-of-the-pep-8-style-guide-5672459c7682?source=collection_archive---------18-----------------------#2020-10-15">https://towardsdatascience.com/an-overview-of-the-pep-8-style-guide-5672459c7682?source=collection_archive---------18-----------------------#2020-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9baf1081a97c2e81a6fbd65b682aef82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MGwhgis8-7h-M0M0"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class=""/><div class=""><h2 id="e8f1" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">让您的Python代码具有风格。</h2></div><p id="7a37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">ython Enhancement Proposal 8或PEP 8是一个全面的Python代码样式指南。PEP 8的目标是将所有Python集合在一个样式指南下。这增加了Python代码的可读性和整体理解。PEP 8并不意味着在任何情况下都要遵循。你会遇到不适用的代码，如果是这样，你可能需要暂时脱离风格指南。关键是尽可能使用风格指南。它将帮助你和其他所有看到你的代码的人阅读和处理它。我会涵盖我认为最重要的领域。我不会讨论一些领域和其他领域，我可能只是略读一下。我真的推荐完整阅读PEP 8，因为这个指南更像是一个快速概览。为了真正理解并获得更深入的解释，以及我选择不包含在本文中的部分。PEP 8中我将复习的部分如下:</p><ul class=""><li id="84cb" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">代码布局</li><li id="88e2" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">用线串</li><li id="cecb" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">空白</li><li id="b135" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">尾随逗号</li><li id="1ec7" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">评论</li><li id="3fc8" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">命名规格</li><li id="236b" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">推荐</li></ul><p id="31e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">PEP 8可在此处找到:</p><div class="is it gp gr iu mr"><a href="https://www.python.org/dev/peps/pep-0008/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">PEP 8风格的Python代码指南</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Python编程语言的官方主页</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.python.org</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ja mr"/></div></div></a></div></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="0804" class="nn no jj bd np nq nr ns nt nu nv nw nx kp ny kq nz ks oa kt ob kv oc kw od oe bi translated">代码布局</h1><h2 id="b28e" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">缩进:</h2><ul class=""><li id="abc1" class="md me jj la b lb or le os lh ot ll ou lp ov lt mi mj mk ml bi translated">4个空格，虽然这取决于你的延续行，只要有某种形式的缩进。</li><li id="bc5a" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">您可以垂直排列括号中的换行元素，或者使用悬挂缩进。</li></ul><pre class="ow ox oy oz gt pa pb pc pd aw pe bi"><span id="3862" class="of no jj pb b gy pf pg l ph pi"># 4 space indent<br/>def hello(var):<br/>    print(var)</span><span id="8780" class="of no jj pb b gy pj pg l ph pi"># vertical alignment</span><span id="965c" class="of no jj pb b gy pj pg l ph pi">example2 = function(first_var, second_var,<br/>                    third_Var, fourth_var)</span><span id="8e21" class="of no jj pb b gy pj pg l ph pi"># hanging indent</span><span id="5cba" class="of no jj pb b gy pj pg l ph pi">example3 = function(<br/>    first_var, second_var,<br/>    third_var, fourth_var)</span></pre><ol class=""><li id="6a73" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt pk mj mk ml bi translated">您可以对太长或希望成为延续行的条件使用类似的工作流。您可以在两个字符的关键字后使用括号，这将允许在转到新行时自动缩进。这对于长条件语句很有用，比如一个<code class="fe pl pm pn pb b">if</code>语句。对于嵌套语句，您可以选择没有额外的缩进，注释您的缩进细节，或者添加额外的缩进。</li><li id="a2b9" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">您可以将结束标点(大括号、中括号或圆括号)与最后一行的第一个字符或非空白的多行表达式的第一个字符对齐。</li></ol><pre class="ow ox oy oz gt pa pb pc pd aw pe bi"><span id="3a11" class="of no jj pb b gy pf pg l ph pi"># last line, first character<br/>new_list = [<br/>    'one', 'two', 'three',<br/>    'four', 'five', 'six'<br/>    ]</span><span id="55dd" class="of no jj pb b gy pj pg l ph pi"># first line, first character<br/>new_list = [<br/>    'one', 'two', 'three',<br/>    'four', 'five', 'six'<br/>]</span></pre><h2 id="183f" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">制表符和空格</h2><ol class=""><li id="e590" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">建议缩进时使用空格，而使用制表符是为了与使用制表符缩进的代码保持一致。</li><li id="e38f" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">Python不允许在同一个代码中同时使用这两者。如果您正在转换混合了两者的Python 2，请使用空格重做。</li></ol><h2 id="72fa" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">最大线路长度</h2><ol class=""><li id="925c" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">最大的行长度应该是79个字符，虽然我发现这有时是限制性的，在那些情况下必须更长。在这种情况下，最多可以输入99个字符。</li><li id="8566" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">对于注释和文档字符串，应该使用72个字符，不能增加。</li><li id="dd84" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">这有助于阅读Python代码并将其保存在编辑器、检查和调试工具中。</li><li id="98a2" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">为了帮助你坚持下去，Python有一个助手。您可以用括号将行括起来，从第一个关键字之后的所有内容开始，到下一个关键字之前结束。这是PEP 8建议的，它会根据正确的Python行样式格式自动换行。</li><li id="1625" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">也可以使用反斜杠，仅当圆括号换行不适用时，例如<code class="fe pl pm pn pb b">assert</code>语句。</li></ol><h2 id="0fff" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">使用二元运算符换行</h2><ol class=""><li id="7b12" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">为了更好的可读性，你应该在二进制操作符之前换行，尽管在过去这是相反的，如果它们是一致的，这两者都是可以接受的。</li></ol><h2 id="3895" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">空白行</h2><ol class=""><li id="a46b" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">在类定义之前和之后应该有两个空行。</li><li id="d637" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">方法定义前后都应该有一个空行。</li><li id="013b" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">您应该在代码中保守地使用空行来分隔函数组。</li><li id="144f" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">如果不同行之间只有一行代码相互独立，则不必包含空行。</li><li id="8a30" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">Python使用control-L (^L)换行符来表示空白。</li></ol><h2 id="21ba" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">源文件编码</h2><ol class=""><li id="c8c6" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">代码应该使用核心Python 3发行版的UTF-8(Python 2的ASCII ),并且不应该有声明。</li><li id="7719" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">除此之外的编码只应用于测试目的。</li><li id="50b5" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">跳转到<a class="ae jg" href="https://www.python.org/dev/peps/pep-3131/" rel="noopener ugc nofollow" target="_blank"> PEP 3131 </a>了解更多关于这项政策的信息。</li><li id="4c75" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">标识符应该只使用ASCII，如果可能的话，应该使用英文单词。</li></ol><h2 id="273e" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">进口</h2><ol class=""><li id="da8f" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">导入通常没有空行分隔。</li><li id="2b89" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">导入通常应该在不同的行上分开，除非使用<code class="fe pl pm pn pb b">from</code>关键字。</li><li id="51b8" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">导入属于代码的顶部，在注释和文档字符串之后，在全局变量和常量之前。</li><li id="2c56" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">进口应该是这个顺序。</li></ol><ul class=""><li id="1271" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">标准程序库</li><li id="881a" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">第三方</li><li id="63c7" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">特定于本地/库。</li></ul><p id="bf66" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.推荐绝对导入，但是显式相对导入也很好。以不太冗长的为准。</p><p id="882a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.从单独的类模块导入类。</p><p id="188c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">7.除非必要，否则不应使用通配符(<code class="fe pl pm pn pb b">*</code>)。</p><p id="d095" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">8.模块级“dunders”是带有两个尾随下划线的名称。这些名称应该放在注释和文档字符串之后，但在导入之前。</p><p id="dca0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">9.<code class="fe pl pm pn pb b">from __future__</code>导入必须在除注释和文档字符串之外的任何代码之前。</p><h1 id="a0c6" class="nn no jj bd np nq po ns nt nu pp nw nx kp pq kq nz ks pr kt ob kv ps kw od oe bi translated">用线串</h1><ol class=""><li id="734d" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">字符串两边的单引号或双引号意思相同。你可以选择你更喜欢哪一个，但是要坚持，这样你就可以用你没有选择的替代来代替反斜杠。</li><li id="3a5a" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">三重引号应该使用双引号字符。检查一下<a class="ae jg" href="https://www.python.org/dev/peps/pep-0257/" rel="noopener ugc nofollow" target="_blank"> PEP 257 </a>。</li></ol><h1 id="1a53" class="nn no jj bd np nq po ns nt nu pp nw nx kp pq kq nz ks pr kt ob kv ps kw od oe bi translated">空白</h1><p id="18b2" class="pw-post-body-paragraph ky kz jj la b lb or kk ld le os kn lg lh pt lj lk ll pu ln lo lp pv lr ls lt im bi translated">避免尾随空白。</p><ol class=""><li id="0593" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt pk mj mk ml bi translated">不要在你的表达式和语句中使用过多的空格。如果逗号、冒号和分号不在中括号、大括号或圆括号后面，则应该在逗号、冒号和分号后面有空格。</li><li id="19f5" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">对于任何运算符，您都应该在运算符的两边使用空格。用于切片的冒号被视为二元运算符，它们之间不应该有任何空格。</li><li id="b078" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">当调用函数<code class="fe pl pm pn pb b">function()</code>时，函数旁边应该有不带空格的括号。</li><li id="62a6" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">索引或切片时，括号应直接紧挨着集合，没有空格<code class="fe pl pm pn pb b">collection[‘index’]</code>。</li><li id="12fd" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">不建议使用空格来排列变量值。</li><li id="93f2" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">当可选选项可用时，请确保与您选择的格式一致。</li></ol><h1 id="ad30" class="nn no jj bd np nq po ns nt nu pp nw nx kp pq kq nz ks pr kt ob kv ps kw od oe bi translated">尾随逗号</h1><ol class=""><li id="2d8c" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">唯一需要尾随逗号的时候是在创建单个元素元组的时候。</li><li id="4f8c" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">如果您使用尾随逗号，请用括号将它们括起来。</li><li id="db39" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">尾部逗号经常在版本控制中使用，用来详细说明以后将要扩展的区域。</li></ol><h1 id="9ed9" class="nn no jj bd np nq po ns nt nu pp nw nx kp pq kq nz ks pr kt ob kv ps kw od oe bi translated">评论</h1><ol class=""><li id="5fcd" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">确保您的注释有意义，并且对阅读代码有用。适得其反的注释可能会损害代码的可读性。</li><li id="4009" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">更新代码时，请确保更新您的注释。</li><li id="b8fa" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">确保你的评论对其他Python程序员来说容易理解。</li><li id="4f00" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">块注释是一段或多段单行注释，以每行的结束标点结束。他们应该以<code class="fe pl pm pn pb b">#</code>开头，然后是空格。同样，块注释的缩进量应该与它们将要进入的代码的缩进量相同。用一行没有任何内容的注释来分隔段落。</li><li id="7f20" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">在多行注释中，在句尾使用两个空格，除了在最后一句后只使用一个空格。</li><li id="ccf0" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">行内注释是跟在同一行代码后面的注释。保守地使用行内注释。在您的代码后面，它们应该至少由两个空格分隔。只有在必要时才使用它们。</li><li id="f6e2" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">文档字符串或文档字符串确实如其所述。它们为模块、函数、类和方法提供文档。对于以下所有内容，您都应该有Docstrings。通过在文档串的开头和结尾使用三个<code class="fe pl pm pn pb b">“””</code>引号来创建文档串。要了解更多关于文档字符串的信息，请看<a class="ae jg" href="https://www.python.org/dev/peps/pep-0257/" rel="noopener ugc nofollow" target="_blank"> PEP 257 </a>。</li></ol><h1 id="2271" class="nn no jj bd np nq po ns nt nu pp nw nx kp pq kq nz ks pr kt ob kv ps kw od oe bi translated">命名规格</h1><p id="ccf8" class="pw-post-body-paragraph ky kz jj la b lb or kk ld le os kn lg lh pt lj lk ll pu ln lo lp pv lr ls lt im bi translated"><strong class="la jk">尽管Python库中的命名约定与Python有些不一致，但仍然建议使用当前的命名约定，除非您正在使用的已经有了不同的约定，然后使用该格式。</strong></p><p id="7d7a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的原则是你应该为你的API的公共方面反映用法而不是实现。</p><p id="32c4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">有多种命名方式可供选择。记得要有描述性。您也可以使用前缀将名称组合在一起。</strong></p><pre class="ow ox oy oz gt pa pb pc pd aw pe bi"><span id="e728" class="of no jj pb b gy pf pg l ph pi">b  <br/>B  <br/>lowercase  <br/>lower_case_underscore<br/>UPPERCASE<br/>UPPER_CASE_UNDERSCORE<br/>CamelCase<br/>mixedCase<br/>Cap_words_Underscore # not recommended </span></pre><h2 id="75c8" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">4.规范的命名约定</h2><ul class=""><li id="710d" class="md me jj la b lb or le os lh ot ll ou lp ov lt mi mj mk ml bi translated">单前导下划线:弱，除非内部使用，否则不推荐使用。</li><li id="e3b9" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">单结尾下划线:用于避免Python关键字的问题。</li><li id="3357" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">双前导下划线:用于命名类属性。</li><li id="e237" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">双前导和尾随下划线是用户名称空间中的“神奇”对象或属性。</li></ul><p id="09c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">要避免的名字:</strong></p><pre class="ow ox oy oz gt pa pb pc pd aw pe bi"><span id="5903" class="of no jj pb b gy pf pg l ph pi"># try not to use.<br/>l  # lowercase L<br/>O  # uppercase o<br/>I  # uppercase i</span></pre><p id="c2ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> ASCII兼容性:</strong></p><ul class=""><li id="c9ff" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">标准库要求标识符与ASCII兼容。</li></ul><p id="f2f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">包和模块名称:</strong></p><ul class=""><li id="377a" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">如果可能的话，包和模块应该有小写和简短的名字。</li><li id="3b07" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">模块可以有下划线。</li><li id="6178" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">包不应有下划线。</li><li id="2464" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">如果一个模块在C或C++中，并且与一个Python模块相关联，那么它会创建一个更高的接口，并且可以用一个前导下划线来命名。</li></ul><p id="f466" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">类名:</strong></p><ul class=""><li id="4d4a" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">使用大写单词的惯例<code class="fe pl pm pn pb b">WordExample</code>。</li><li id="595a" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">如果函数有很好的文档记录，并且主要用于可调用，那么您可以使用函数命名约定。</li><li id="bd59" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">内置名称通常是一个单词或两个单词长。他们也只对异常和内置常量使用大写单词约定。</li></ul><p id="8930" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">类型变量名称:</strong></p><ul class=""><li id="1b47" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">类型变量应该使用大写字母约定和简称。</li><li id="a686" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">后缀<code class="fe pl pm pn pb b">_co</code>用于具有协变行为的变量。</li><li id="6dbe" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">后缀<code class="fe pl pm pn pb b">_contra</code>用于具有逆变行为的变量。</li></ul><p id="9229" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">异常名称:</strong></p><ul class=""><li id="7963" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">使用类命名约定。</li><li id="2a0d" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">后缀<code class="fe pl pm pn pb b">Error</code>用于出错的异常名。</li></ul><p id="a4bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">全局变量名称:</strong></p><ul class=""><li id="c957" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">遵循函数命名约定。</li><li id="56e6" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated"><code class="fe pl pm pn pb b">__all__</code>机制应该用来防止由<code class="fe pl pm pn pb b">from M import *</code>引起的全局变量或者像前缀<code class="fe pl pm pn pb b">globals</code>一样使用。</li></ul><p id="0468" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">功能&amp;变量名:</strong></p><ul class=""><li id="0e87" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">函数和变量应该是带下划线的小写字母。</li><li id="452f" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">如果已经在使用混合案例风格，您可以使用它。</li></ul><p id="92e9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">函数&amp;方法参数:</strong></p><ul class=""><li id="8f67" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">包含<code class="fe pl pm pn pb b">self</code>作为即时方法的第一个参数。</li><li id="2596" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">包含<code class="fe pl pm pn pb b">cls</code>或类方法的第一个参数。</li><li id="3d05" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">如果需要，最好使用尾随下划线，而不是缩写。</li></ul><p id="9159" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">方法名&amp;实例变量:</strong></p><ul class=""><li id="083a" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">使用函数命名约定。</li><li id="6828" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">对非公共方法和实例变量使用前导下划线。</li><li id="1cf1" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">如有必要，您可以使用两个前导下划线，以使用Python的名称mangling。</li></ul><p id="7942" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">常量:</strong></p><ul class=""><li id="b2a9" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">带下划线的大写命名约定。</li></ul><p id="947e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">继承:</strong></p><ul class=""><li id="2f19" class="md me jj la b lb lc le lf lh mf ll mg lp mh lt mi mj mk ml bi translated">确保您的类的属性是公共的或非公共的。</li><li id="fa8e" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">非公共属性不是为第三方设计的。</li><li id="d7d9" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">“私有”是Python中使用的一个术语。</li><li id="67f3" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">“子类API”(又名。“受保护”)。旨在继承。基类。</li><li id="cbeb" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">公共属性=没有前导下划线，除非关键字冲突。</li><li id="6a14" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">只公开公共数据属性的属性名。</li><li id="de0f" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">子类化的类可以用双前导下划线来命名，使用Python的名称转换器。</li></ul><h2 id="b437" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">5.公共和内部接口</h2><ul class=""><li id="0325" class="md me jj la b lb or le os lh ot ll ou lp ov lt mi mj mk ml bi translated">用户应该能够区分公共接口和内部接口。</li><li id="aa1f" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">如果一个接口被文档化，它就被认为是公共的，除非文档中另有说明。</li><li id="dca8" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">未记录的接口是内部接口。</li><li id="dca4" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">模块应该使用<code class="fe pl pm pn pb b">__all__</code>来声明公共API。如果<code class="fe pl pm pn pb b">__all__</code>设置为空列表，表示没有公共API。</li><li id="9560" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">内部接口的单前导下划线。</li><li id="3e54" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">如果任何名称空间是内部的，那么接口也是内部的。</li><li id="e36a" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt mi mj mk ml bi translated">导入是一个实现细节。</li></ul><h1 id="def9" class="nn no jj bd np nq po ns nt nu pp nw nx kp pq kq nz ks pr kt ob kv ps kw od oe bi translated">推荐</h1><ol class=""><li id="e9b2" class="md me jj la b lb or le os lh ot ll ou lp ov lt pk mj mk ml bi translated">编写代码，以免对Python的其他实现产生负面影响。</li><li id="4090" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated"><code class="fe pl pm pn pb b">is</code>或<code class="fe pl pm pn pb b">is not</code>来比较单件。</li><li id="16d1" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated"><code class="fe pl pm pn pb b">is not</code>而不是<code class="fe pl pm pn pb b">not is</code>。</li><li id="7810" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">将lambda表达式绑定到标识符时，使用<code class="fe pl pm pn pb b">def</code>而不是赋值。</li><li id="aa3c" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">对于例外情况，使用<code class="fe pl pm pn pb b">Exception</code>代替<code class="fe pl pm pn pb b">BaseException</code>。</li><li id="47b9" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">确保您的异常链接被正确使用。</li><li id="09af" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">尽可能具体说明例外情况。</li><li id="2ae4" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">使用显式名称绑定语法。</li><li id="1655" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">对操作系统错误使用显式异常层次结构。</li><li id="439d" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">当使用<code class="fe pl pm pn pb b">try</code>和<code class="fe pl pm pn pb b">except</code>时，在需要包装在<code class="fe pl pm pn pb b">try</code>块中的区域周围保持代码紧凑。</li><li id="a809" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">在本地资源上使用<code class="fe pl pm pn pb b">with</code>语句。</li><li id="14ed" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">确保正确使用<code class="fe pl pm pn pb b">return</code>语句。要么有<code class="fe pl pm pn pb b">return</code>表情，要么没有。</li><li id="ee30" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">与字符串模块相对的字符串方法。</li><li id="21d0" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">使用方法<code class="fe pl pm pn pb b">.startswith()</code>和<code class="fe pl pm pn pb b">.endswith()</code>进行字符串前缀和后缀切片。</li><li id="3762" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">使用<code class="fe pl pm pn pb b">isinstance(&lt;item&gt;, &lt;item&gt;)</code>而不是<code class="fe pl pm pn pb b">if type(&lt;item&gt;) is type(&lt;item&gt;)</code>。</li><li id="ce75" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">空序列被视为<code class="fe pl pm pn pb b">False</code>。</li><li id="9521" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">不要用<code class="fe pl pm pn pb b">==</code>来做<code class="fe pl pm pn pb b">True</code> <code class="fe pl pm pn pb b">False</code>的比较。</li><li id="f713" class="md me jj la b lb mm le mn lh mo ll mp lp mq lt pk mj mk ml bi translated">流控制语句应该在<code class="fe pl pm pn pb b">finally</code>代码块中。</li></ol><h2 id="b938" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">函数注释</h2><ul class=""><li id="98d7" class="md me jj la b lb or le os lh ot ll ou lp ov lt mi mj mk ml bi translated">功能注释见<a class="ae jg" href="https://www.python.org/dev/peps/pep-0484/" rel="noopener ugc nofollow" target="_blank"> PEP 484 </a>。</li></ul><h2 id="4239" class="of no jj bd np og oh dn nt oi oj dp nx lh ok ol nz ll om on ob lp oo op od oq bi translated">可变注释</h2><ul class=""><li id="3aaa" class="md me jj la b lb or le os lh ot ll ou lp ov lt mi mj mk ml bi translated">变量注释见<a class="ae jg" href="https://www.python.org/dev/peps/pep-0526/" rel="noopener ugc nofollow" target="_blank"> PEP 526 </a>。</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="b7f2" class="nn no jj bd np nq nr ns nt nu nv nw nx kp ny kq nz ks oa kt ob kv oc kw od oe bi translated">结论</h1><p id="e8cb" class="pw-post-body-paragraph ky kz jj la b lb or kk ld le os kn lg lh pt lj lk ll pu ln lo lp pv lr ls lt im bi translated">对于任何Python程序员来说，PEP 8都是一个不可思议的资源。如果使用正确，它将保持你的代码可读性和PEP 8的风格参数。同样，这只是对PEP 8的一个简要概述，如果你想真正了解这个令人惊叹的样式指南，我鼓励你在Python网站或GitHub上阅读整个内容。我希望你喜欢阅读和快乐编码！</p><div class="is it gp gr iu mr"><a href="https://www.python.org/dev/peps/pep-0008/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">PEP 8风格的Python代码指南</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Python编程语言的官方主页</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.python.org</p></div></div><div class="na l"><div class="pw l nc nd ne na nf ja mr"/></div></div></a></div><div class="is it gp gr iu mr"><a href="https://github.com/python/peps/blob/master/pep-0008.txt" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">python/peps</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">标题:Python代码版本风格指南:$Revision$ Last-Modified: $Date$作者:吉多·范·罗苏姆，巴里华沙…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="px l nc nd ne na nf ja mr"/></div></div></a></div></div></div>    
</body>
</html>