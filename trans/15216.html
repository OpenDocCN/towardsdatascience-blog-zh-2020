<html>
<head>
<title>Top 3 programming mistakes every data scientist makes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个数据科学家都会犯的3大编程错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-3-programming-mistakes-every-data-scientist-makes-c0a0476de3b9?source=collection_archive---------46-----------------------#2020-10-19">https://towardsdatascience.com/top-3-programming-mistakes-every-data-scientist-makes-c0a0476de3b9?source=collection_archive---------46-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8738" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><div class=""><h2 id="ac8d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何使用熊猫、Sklearn和函数</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d5f1a464e496c8cd03205b4a1cf5d6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1p71f7yFTzCatzzftF3yA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@emilep?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃米尔·佩龙</a>在<a class="ae lh" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="6149" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文指出了前景数据科学家最常犯的错误，并讨论了如何避免这些错误。事不宜迟，让我们直入主题吧。</p><h1 id="88fd" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">熊猫的低效利用</h1><p id="078a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Pandas是数据科学家经常用来处理结构化数据的库。最常见的错误是使用“for循环”遍历数据帧中的行。Pandas具有内置函数，例如<code class="fe nb nc nd ne b">apply</code>或<code class="fe nb nc nd ne b">applymap</code>，使您能够对数据帧的所有行的选择或所有列应用函数，或者在满足条件时应用函数。然而，最理想的情况是，您可以使用效率最高的Numpy数组。</p><p id="0693" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">效率低下:</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="3859" class="nj mf it ne b gy nk nl l nm nn">my_list=[] <br/>for i in range(0, len(df)):        <br/>   l = myfunction(df.iloc[i]['A'], df.iloc[i]['B'])<br/>   my_list.append(l)<br/>df['newColumn'] = my_list</span><span id="c41e" class="nj mf it ne b gy no nl l nm nn">Time:640ms</span></pre><p id="7c74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">高效:</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="9a2b" class="nj mf it ne b gy nk nl l nm nn">df['newColumn'] = myfunction( df['A'].values, df['B'].values)</span><span id="0d28" class="nj mf it ne b gy no nl l nm nn">Time: 400 µs</span></pre><p id="e2bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者给定如下数据帧:</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="1a80" class="nj mf it ne b gy nk nl l nm nn">df = pd.DataFrame([[4, 9]] * 3, columns=['A', 'B'])<br/><strong class="ne jd">&gt;&gt;&gt; </strong>df<br/>   A  B<br/>0  4  9<br/>1  4  9<br/>2  4  9</span></pre><p id="d31f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">计算每个元素的平方根</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="53c4" class="nj mf it ne b gy nk nl l nm nn">df.apply(np.sqrt)<br/><strong class="ne jd">&gt;&gt;&gt; </strong>df<br/>     A    B<br/>0  2.0  3.0<br/>1  2.0  3.0<br/>2  2.0  3.0</span></pre><p id="0400" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">来源:<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/pandas-docs/stable/reference/API/pandas。DataFrame.apply.html</a></p><h1 id="1673" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">2.Sklearn的低效使用</h1><p id="f7ae" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Sklearn (scikit-learn)是数据科学家用来训练机器学习模型的Python库。通常在训练一个模型之前需要转换数据，但是如何建立一个转换数据然后训练的管道呢？您可能希望自动化这一点，尤其是当您希望在交叉验证中每个文件夹都应用转换时。遗憾的是，库中最常用的函数是<code class="fe nb nc nd ne b">train_test_split</code>。许多数据科学家只是转换数据，使用<code class="fe nb nc nd ne b">train_test_split</code>，在一组上训练，在另一组上测试。</p><p id="e7af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这听起来没那么糟糕，但是当你没有一个大的数据集时可能会特别糟糕。交叉验证对于评估模型如何对看不见的数据进行归纳非常重要。因此，一些数据科学家可能热衷于在每次验证迭代之前实现一个函数来进行转换。</p><p id="5d03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Sklearn有一个Pipeline对象，可以用来在交叉验证过程中转换数据和训练机器学习模型。</p><p id="7c78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的例子中，PCA在逻辑回归之前应用于交叉验证的每个折叠，同时，进行网格搜索以找到模型的参数以及PCA的参数。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="c08c" class="nj mf it ne b gy nk nl l nm nn">import numpy as np import matplotlib.pyplot as plt<br/>import pandas as pd  <br/>from sklearn import datasets <br/>from sklearn.decomposition import PCA <br/>from sklearn.linear_model import LogisticRegression <br/>from sklearn.pipeline import Pipeline <br/>from sklearn.model_selection import GridSearchCV   </span><span id="8e2a" class="nj mf it ne b gy no nl l nm nn"># Define a pipeline to search for the best combination of PCA truncation <br/># and classifier regularization. <br/>pca = PCA() </span><span id="6066" class="nj mf it ne b gy no nl l nm nn"># set the tolerance to a large value to make the example faster <br/>logistic = LogisticRegression(max_iter=10000, tol=0.1) </span><span id="2c86" class="nj mf it ne b gy no nl l nm nn"><strong class="ne jd">pipe = Pipeline(steps=[('pca', pca), ('logistic', logistic)])</strong><br/>  <br/>X_digits, y_digits = datasets.load_digits(return_X_y=True)<br/>  <br/># Parameters of pipelines can be set using ‘__’ separated parameter<br/>names: <br/>param_grid = {     <br/>'pca__n_components': [5, 15, 30, 45, 64],     <br/>'logistic__C': np.logspace(-4, 4, 4), <br/>} </span><span id="4bf3" class="nj mf it ne b gy no nl l nm nn">search = GridSearchCV(pipe, param_grid, n_jobs=-1) search.fit(X_digits, y_digits) </span><span id="622d" class="nj mf it ne b gy no nl l nm nn">print("Best parameter (CV score=%0.3f):" % search.best_score_) print(search.best_params_)</span></pre><p id="1b87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">来源:<a class="ae lh" href="https://scikit-learn.org/stable/tutorial/statistical_inference/putting_together.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/tutorial/statistical _ inference/putting _ together . html</a></p><h1 id="dfd1" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">3.不使用函数</h1><p id="f095" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">一些数据科学家不太关心他们的代码表示和格式，但是他们应该关心。与只在单个文件或笔记本中编写脚本相比，编写函数有几个好处。这不仅更容易调试，而且代码可以重用，更容易理解。这篇<a class="ae lh" rel="noopener" target="_blank" href="/5-reasons-why-you-should-switch-from-jupyter-notebook-to-scripts-cb3535ba9c95">帖子</a>更详细地展示了函数在数据科学中的应用，尽管我不同意作者的观点，即你不能在Jupyter笔记本中复制这种方法。此外，作为一名数据科学家，你应该致力于保持代码干燥。那就是<a class="ae lh" href="https://github.com/davified/clean-code-ml" rel="noopener ugc nofollow" target="_blank">不要重复自己</a>！消除重复使代码可以被你和其他可能接触到你的代码的人重用。此外，它还有助于维护和识别错误。</p><p id="0795" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，您可能有这样几行数据帧操作:</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="3468" class="nj mf it ne b gy nk nl l nm nn">df.drop(columns=['A','B'],inplace=True) df['datetime']=pd.to_datetime(df['dt']) <br/>df.dropna(inplace=True)</span></pre><p id="6bb6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是效率不高，因为每次要预处理数据帧时，都必须复制粘贴所有代码行，并根据需要编辑列名。</p><p id="f836" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，如果有一个处理所有操作的函数，那就更好了。</p><pre class="ks kt ku kv gt nf ne ng nh aw ni bi"><span id="8548" class="nj mf it ne b gy nk nl l nm nn">processor = Preprocess(columns_to_drop, datetime_column, dropna_columns)</span></pre><p id="1c08" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在这里找到预处理<a class="ae lh" rel="noopener" target="_blank" href="/5-reasons-why-you-should-switch-from-jupyter-notebook-to-scripts-cb3535ba9c95">的实现。</a></p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="4bae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您是数据科学新手或正在准备数据科学面试，您可能也会对<a class="ae lh" rel="noopener" target="_blank" href="/3-most-asked-python-interview-questions-for-data-scientists-1a2ad63ebe56"> 3个数据科学家最常问的Python面试问题</a>感兴趣</p></div></div>    
</body>
</html>