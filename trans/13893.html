<html>
<head>
<title>Python Best Practices for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学的Python最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-coding-mistakes-and-best-practices-part-1-f7511cf573f7?source=collection_archive---------15-----------------------#2020-09-24">https://towardsdatascience.com/data-science-coding-mistakes-and-best-practices-part-1-f7511cf573f7?source=collection_archive---------15-----------------------#2020-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0e9c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="c9d6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过以下几个技巧，避免常见错误并提高您的数据科学编码技能</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ac16c2d264e338b195eefd81220aff3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzBp99wOaJAW0OIvsWRApw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@nesabymakers" rel="noopener ugc nofollow" target="_blank"> nesabymakers </a>在<a class="ae lh" href="https://unsplash.com/photos/kwzWjTnDPLk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ac00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们中的许多人在没有强大的软件工程背景的情况下开始了他们的数据科学职业生涯。虽然一开始这可能不是问题，但是随着代码变得越来越复杂，您会发现您的笔记本会变得越来越慢，并且您会努力维护它。这篇文章的目标是帮助你写出干净、易读、高性能的代码。这篇文章并不是关于如何成为一名更好的程序员的详尽指南，但是我希望你能从中找到一些有用的东西来提高你的编码技能。</p><h1 id="c526" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">1.在DataFrame行上循环(简单回答:不要！)</h1><p id="c692" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我认为这是第一次做分析编程的人最常犯的错误之一。StackOverflow的回答很好地解释了这一点。</p><blockquote class="nb nc nd"><p id="40a5" class="li lj ne lk b ll lm kd ln lo lp kg lq nf ls lt lu ng lw lx ly nh ma mb mc md im bi translated">pandas中的迭代是一种反模式，只有当你用尽了所有其他选择时，才应该这么做。你不应该使用名字中带有“iter”的函数超过几千行，否则你将不得不习惯等待。</p></blockquote><p id="5656" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了加快你的数据处理，你需要使用内置的pandas或numpy函数，因为它更快更容易。例如，看看这个For循环，</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a483" class="nn mf it nj b gy no np l nq nr">for index, row in df.iterrows():<br/>   if row['room_size'] &lt;= 36<br/>       row['category'] = 'small'<br/>   else:<br/>       row['category'] = 'large'</span></pre><p id="5a52" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可以使用numpy轻松完成，</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="0d05" class="nn mf it nj b gy no np l nq nr">df['category'] = np.where(df['room_size'] &lt;= 36, 'small', 'large')</span></pre><p id="9a64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用numpy/pandas函数的最大好处可能是它们比for循环快很多。看看下面的图表，比较熊猫函数和迭代的运行时间。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ns"><img src="../Images/3791c754ff92ad2a91d2373aa569a972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3kLYFgP2mDWffO_Aoxw0hQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">各种数据处理方法的速度比较。</p></figure><p id="65a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您使用pandas或numpy函数，您的代码将被矢量化，这意味着这些库不是一次处理一个值，而是一次对所有行执行一次操作，这使得您的数据处理速度非常快。以下是您可以使用pandas进行数据帧操作的一些其他示例:</p><h2 id="db4f" class="nn mf it bd mg nt nu dn mk nv nw dp mo lr nx ny mq lv nz oa ms lz ob oc mu iz bi translated">基于其他列的操作创建新列:</h2><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="5181" class="nn mf it nj b gy no np l nq nr">df['c4'] = (df['c1'] — df['c2']) * df['c3']/100</span></pre><h2 id="265f" class="nn mf it bd mg nt nu dn mk nv nw dp mo lr nx ny mq lv nz oa ms lz ob oc mu iz bi translated">向上或向下移动列:</h2><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="1c77" class="nn mf it nj b gy no np l nq nr">df['c1'] = df['c1'].shift(periods=1) # Shifting up one column<br/>df['c1'] = df['c1'].shift(periods=-1) # Shifting down one column</span></pre><h2 id="a217" class="nn mf it bd mg nt nu dn mk nv nw dp mo lr nx ny mq lv nz oa ms lz ob oc mu iz bi translated"><strong class="ak">切片一个</strong>列<strong class="ak"> : </strong></h2><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="241d" class="nn mf it nj b gy no np l nq nr">df = df[start_index:end_index].copy()</span></pre><h2 id="2a20" class="nn mf it bd mg nt nu dn mk nv nw dp mo lr nx ny mq lv nz oa ms lz ob oc mu iz bi translated">填充不适用值:</h2><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a8b3" class="nn mf it nj b gy no np l nq nr">df.fillna('bfill',inplace=True)</span></pre><p id="5805" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最棒的是，您可以使用<a class="ae lh" href="https://pandas.pydata.org/docs/user_guide/index.html" rel="noopener ugc nofollow" target="_blank"> pandas </a>或<a class="ae lh" href="https://numpy.org/doc/stable/reference/index.html#reference" rel="noopener ugc nofollow" target="_blank"> numpy </a>内置函数进行大多数数据操作。我只能想到一些用例，这些用例只能通过迭代来完成，比如训练你的ML模型或者使用正则表达式。因此，如果您想知道如何使用这些库之一进行数据操作，请查阅numpy或pandas文档(或StackOverflow)。</p><h1 id="db63" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">2.SettingWithCopyWarning()，了解视图与副本</h1><p id="2e14" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果你曾经使用过熊猫，你可能以前遇到过这个警告。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="9ebe" class="nn mf it nj b gy no np l nq nr">SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span></pre><p id="5ade" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个警告可能是由很多原因造成的，但是我认为最常见的原因是对视图和副本的不清楚的理解。顾名思义，<strong class="lk jd">视图</strong>是原始数据的视图，因此修改视图可能会修改原始对象。举个例子，</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="103a" class="nn mf it nj b gy no np l nq nr"># df2 will return a <strong class="nj jd">view</strong><br/>df2 = df[['A']]<br/>df2['A'] /= 2</span></pre><p id="8c7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的操作返回一个视图，并将产生<code class="fe od oe of nj b">SettingWithCopyWarning</code>。如果您更改列<code class="fe od oe of nj b">df2</code>的值，它也会更改列<code class="fe od oe of nj b">df</code>上<code class="fe od oe of nj b">A</code>的值，这就是警告试图告诉我们的。要修复它，你必须使用<code class="fe od oe of nj b">.copy()</code>为<code class="fe od oe of nj b">df2</code>创建一个全新的对象</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="fb69" class="nn mf it nj b gy no np l nq nr"># df2 will return a <strong class="nj jd">copy</strong><br/>df2 = df[['A']].copy()<br/>df2['A'] /= 2</span></pre><p id="e7f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码将返回一个<strong class="lk jd">副本</strong>，这是一个全新的对象。在上面的代码中，改变<code class="fe od oe of nj b">df2</code>不会改变<code class="fe od oe of nj b">df</code>。事实上，<strong class="lk jd">你应该在每次创建一个新的非空数据框架</strong>时使用 <code class="fe od oe of nj b"><strong class="lk jd">.copy()</strong></code> <strong class="lk jd">来避免声名狼藉的<code class="fe od oe of nj b">SettingWithCopyWarning</code>。</strong></p><h1 id="e4e6" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">3.编写干净的代码。</h1><p id="8fc6" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">众所周知，数据科学家写的代码很糟糕。这并不奇怪，因为数据科学家编写的许多代码都是用于EDA、快速原型制作和一次性分析的。你的代码可能有一天会被其他人修改或阅读，这个事实你可能不会想到。引用一个比我更好的程序员的话，“代码被阅读的次数比它被编写的次数多得多，所以要相应地计划”。以下是我给你的一些关于如何写出更好代码的建议。</p><h2 id="6cd9" class="nn mf it bd mg nt nu dn mk nv nw dp mo lr nx ny mq lv nz oa ms lz ob oc mu iz bi translated"><strong class="ak">避免非描述性的变量名</strong></h2><p id="fbe9" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">不要在你的代码中写简短的非描述性的变量名，比如<code class="fe od oe of nj b">i</code>、<code class="fe od oe of nj b">j</code>、<code class="fe od oe of nj b">X</code>、<code class="fe od oe of nj b">Y</code>。而是写一个描述性的变量名，比如<code class="fe od oe of nj b">row_index</code>、<code class="fe od oe of nj b">column_index</code>、<code class="fe od oe of nj b">train_data</code>、<code class="fe od oe of nj b">test_data</code>。是的，这会让你多花两秒钟输入变量，但是相信我，当将来有人试图修改/调试你的代码时，这会节省很多工时。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="f5c4" class="nn mf it nj b gy no np l nq nr"># Avoid (❌) - Non-descriptive variable names<br/>n, x, y = data.shape</span><span id="ba72" class="nn mf it nj b gy og np l nq nr"># Prefer (✅) - Clear, descriptive variable names<br/>no_of_images, image_width, image_height = data.shape</span></pre><h2 id="8488" class="nn mf it bd mg nt nu dn mk nv nw dp mo lr nx ny mq lv nz oa ms lz ob oc mu iz bi translated">命名和格式约定</h2><p id="2ca3" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">拥有一致的命名准则将有利于您和您的团队。它将使任何阅读你的代码的人更快地理解它，并使你的代码更好看。由于大多数数据科学代码都是用python编写的，所以我将分享一些PEP8命名约定:</p><ul class=""><li id="c707" class="oh oi it lk b ll lm lo lp lr oj lv ok lz ol md om on oo op bi translated"><strong class="lk jd">变量/函数</strong>名称为小写，用下划线分隔</li><li id="7f2a" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><strong class="lk jd">常量名称</strong>都是大写字母</li><li id="eefc" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated"><strong class="lk jd">类</strong>名称通常应使用茶色</li></ul><p id="c67e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">至于格式，因为python不允许混合使用制表符和空格来缩进，所以最好坚持一种格式。有许多不同的<a class="ae lh" href="https://www.python.org/dev/peps/pep-0008/#code-lay-out" rel="noopener ugc nofollow" target="_blank"> python </a> <a class="ae lh" href="https://google.github.io/styleguide/pyguide.html" rel="noopener ugc nofollow" target="_blank">风格</a> <a class="ae lh" href="https://docs.python-guide.org/writing/style/" rel="noopener ugc nofollow" target="_blank">指南</a>可供您遵循，但我发现其中有几个是必不可少的:</p><ul class=""><li id="b13d" class="oh oi it lk b ll lm lo lp lr oj lv ok lz ol md om on oo op bi translated">使用4个空格代替制表符(如果你使用VS代码，你可以<a class="ae lh" href="https://stackoverflow.com/questions/36814642/visual-studio-code-convert-spaces-to-tabs" rel="noopener ugc nofollow" target="_blank">自动将制表符转换成空格</a>)</li><li id="95e0" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated">用两行空行将顶级函数和类定义括起来。</li><li id="1797" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated">通过在圆括号、方括号和大括号内使用Python的隐含行继续符来换行</li></ul><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a8d5" class="nn mf it nj b gy no np l nq nr"># Long function<br/>foo = long_function_name(var_one, var_two,<br/>                         var_three, var_four)</span></pre><h2 id="0d6b" class="nn mf it bd mg nt nu dn mk nv nw dp mo lr nx ny mq lv nz oa ms lz ob oc mu iz bi translated">保持你的代码干燥(不要重复)</h2><p id="ad23" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">考虑将您在整个代码中使用的相同值重构到代码的单独部分中的单个变量中，或者更好的是，重构到单独的JSON文件中。这将在将来为您节省大量时间，因为如果您想在整个代码中更改相同的值，您可以通过更改一个变量来实现。这种做法还将避免一种常见的编码反模式，称为<a class="ae lh" href="https://en.wikipedia.org/wiki/Magic_number_(programming)" rel="noopener ugc nofollow" target="_blank">幻数</a>，其中具有未解释含义的唯一值被直接硬编码在源代码中。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="09d5" class="nn mf it nj b gy no np l nq nr"># Avoid (❌) - Unexplained 'magic' number<br/>model = models.Sequential()<br/>model.add(layers.LSTM(60, activation='relu', input_shape=(10, 3)))</span><span id="a4d4" class="nn mf it nj b gy og np l nq nr"># Prefer (✅) - Clear value names and meaning<br/>neurons = 60<br/>no_of_timesteps = 10<br/>no_of_feature = len(df.columns)<br/>activation = 'relu'<br/><br/>model = models.Sequential()<br/>model.add(layers.LSTM(neurons, <br/>activation= activation, input_shape=(no_of_timesteps, dimensions)))</span></pre><p id="84a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这也适用于您的过程，与其在笔记本中编写冗长的数据处理过程，不如将相似的过程分组并重构为单个函数。然后，您可以使用pandas <code class="fe od oe of nj b">.pipe()</code>函数在单个链式执行中调用所有重构的函数。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="6eb2" class="nn mf it nj b gy no np l nq nr"># Avoid (❌) - Long, sequential procedures<br/>df = pd.read_csv(‘data/train.csv’)<br/>df[‘price_per_sqft’] = df[‘price’] / df[‘sqft’]<br/>df[‘c1’].fillna(0, inplace=True)<br/>df[‘c2’].fillna(method=‘bfill’, inplace=True)<br/>df[‘c3’].fillna(df.groupby([‘c1,c2’])[‘c3’].transform(‘mean’))</span><span id="8fd8" class="nn mf it nj b gy og np l nq nr"># Prefer (✅) - Separation of functions and chained executions<br/>PATH = ‘data/train.csv’</span><span id="87f6" class="nn mf it nj b gy og np l nq nr">def load_data(path):<br/> return pd.read_csv(path)</span><span id="5683" class="nn mf it nj b gy og np l nq nr">def calculate_price_per_sqft(df):<br/> df[‘price_per_sqft’] = df[‘price’] / df[‘sqft’]</span><span id="c118" class="nn mf it nj b gy og np l nq nr">def imputate_missing_values(df):<br/> df[‘c1’].fillna(0, inplace=True)<br/> df[‘c2’].fillna(method=‘bfill’, inplace=True)<br/> df[‘c3’].fillna(df.groupby([‘c1,c2’])[‘c3’].transform(‘mean’))<br/> return df</span><span id="c469" class="nn mf it nj b gy og np l nq nr">df = load_data(PATH)<br/>result = (<br/>  df.pipe(calculate_price_per_sqft)<br/>    .pipe(imputate_missing_values)<br/>)</span></pre><h1 id="e96d" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">4.在. parquet文件中保存和加载数据</h1><p id="9b54" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">常见的做法是使用<code class="fe od oe of nj b">.to_csv()</code>功能将数据保存到CSV，就像你在许多kaggle笔记本中看到的那样。但是CSV实际上<a class="ae lh" rel="noopener" target="_blank" href="/the-best-format-to-save-pandas-data-414dca023e0d"> <strong class="lk jd">不是存储大数据的好格式</strong> </a>，因为它是<em class="ne">无模式的</em>，所以你必须在加载数据时解析日期和数字，并且<em class="ne">是未压缩的</em>，这意味着大数据集将占用大量内存，并且保存和加载将非常慢。Pandas库实际上支持许多更适合保存大型数据集的格式。看看下面的图表，比较数据帧保存/加载时间。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/7e62b98e396a7e5a960f051b74d31dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*RhGeGRoIyXGnhgpE4nn1-Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来自<a class="ae lh" rel="noopener" target="_blank" href="/the-best-format-to-save-pandas-data-414dca023e0d">伊利亚扎依采夫</a>，2019。经允许重新发布</p></figure><p id="55cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到羽毛和拼花比CSV快几个数量级，两者都由<code class="fe od oe of nj b">pandas</code>支持。这是由于这些文件类型的列压缩，它们将数据存储在磁盘中，类似于DataFrame对象在内存中的存储方式。接下来，我们来看看这些文件类型的文件大小对比。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/d4560914bd56d4ba66f7ef17c0de59f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*VuaMQKmXRuUOLcbMiTM5gw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来自<a class="ae lh" rel="noopener" target="_blank" href="/the-best-format-to-save-pandas-data-414dca023e0d">伊利亚扎依采夫</a>，2019。经允许重新发布</p></figure><p id="f9f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一次拼花地板脱颖而出。基于这种比较，我推荐以parquet格式保存数据，因为这样速度更快，占用的内存更少，并且受<code class="fe od oe of nj b">pandas</code>支持。您可以使用<code class="fe od oe of nj b">.to_parquet()</code>将数据保存在<code class="fe od oe of nj b">parquet</code>文件中。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="42f2" class="nn mf it nj b gy no np l nq nr"># Avoid (❌) - Saving and loading data to CSV<br/>df = pd.read_csv('raw_dataset.csv')<br/>df.to_csv('results.csv')</span><span id="3a45" class="nn mf it nj b gy og np l nq nr"># Prefer (✅) - Saving and loading data to parquet<br/>df = pd.read_parquet('raw_dataset.parquet')<br/>df.to_parquet('results.parquet')</span></pre><h1 id="b43e" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">5.构建您的项目</h1><p id="ed3f" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">一开始，在一个jupyter笔记本上进行分析、可视化、特征工程和构建ML模型似乎是个不错的主意。当然，打开笔记本开始处理数据集是非常容易的，但是如果你在开始时没有仔细地组织代码，事情会很快变得非常混乱。结构化您的项目将降低代码的复杂性，并使其更易于维护。对于starter，你可以将自己创建的有用的函数放在一个名为<code class="fe od oe of nj b">data_processor.py</code>的独立模块中，然后导入到你的jupyter笔记本中。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="2ce2" class="nn mf it nj b gy no np l nq nr">// data_processor.py</span><span id="fd4c" class="nn mf it nj b gy og np l nq nr">import pandas as pd</span><span id="bbd1" class="nn mf it nj b gy og np l nq nr">def imputate_missing_values(df):<br/> df['c1'].fillna(0, inplace=True)<br/> df['c2'].fillna(method='bfill', inplace=True)<br/> df['c3'].fillna(df.groupby(['c1','c2'])['c3'].transform('mean'))<br/> return df</span><span id="7cb6" class="nn mf it nj b gy og np l nq nr">def calculate_moving_averages(df):<br/> df['moving_average'].fillna(0, inplace=True)<br/> return df</span></pre><p id="65ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在你的jupyter笔记本中，你可以导入你已经创建的模块，并使用<code class="fe od oe of nj b">.pipe()</code>函数来使用它(我是<code class="fe od oe of nj b">.pipe</code>函数的粉丝)。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="cf57" class="nn mf it nj b gy no np l nq nr">// your_notebook.ipynb</span><span id="b0d6" class="nn mf it nj b gy og np l nq nr">import data_processor.py as dp</span><span id="5351" class="nn mf it nj b gy og np l nq nr">result = (<br/>  df.pipe(calculate_price_per_sqft)<br/>    .pipe(imputate_missing_values)<br/>)</span></pre><p id="c2c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，您可以将它们进一步分成名为<code class="fe od oe of nj b">visualization.py</code>、<code class="fe od oe of nj b">data_processing.py</code>、<code class="fe od oe of nj b">build_model.py</code>等模块。</p><p id="cf78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">事实上，只要项目中的每个模块都符合<strong class="lk jd">单一责任原则</strong>，你就可以随心所欲地构建你的项目。引用维基百科，</p><blockquote class="nb nc nd"><p id="3d88" class="li lj ne lk b ll lm kd ln lo lp kg lq nf ls lt lu ng lw lx ly nh ma mb mc md im bi translated"><em class="it">单一责任原则(SRP)是一种计算机编程原则，它规定每个模块或类都应该对软件提供的功能的单一部分负责，并且这种责任应该完全由类来封装。它的所有服务都应严格符合这一职责。</em></p></blockquote><p id="93ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者，如果你想要一个现成的模板，请查看为你做上述所有事情的<a class="ae lh" href="https://drivendata.github.io/cookiecutter-data-science/#nothing-here-is-binding" rel="noopener ugc nofollow" target="_blank">cookiecutter</a>data science。</p><h1 id="c87c" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="741a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这篇文章包含了我在作为一名数据科学家的旅程中所犯的错误和学到的有用技术。我并不声称这些方法是完美的，但我希望这篇文章对开始职业生涯的数据科学家初学者有所帮助。</p></div><div class="ab cl ox oy hx oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="im in io ip iq"><p id="d38d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ne">我是一名初学数据的科学家，热衷于从数据中创造价值。可以在Twitter</em><a class="ae lh" href="https://twitter.com/faisalrasbihan" rel="noopener ugc nofollow" target="_blank"><em class="ne">@ faisalrasbihan</em></a><em class="ne">联系我。我欢迎建设性的反馈和批评。</em></p><p id="2ccf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">参考文献:<br/>【1】<a class="ae lh" href="https://medium.com/r?url=https%3A%2F%2Ftowardsdatascience.com%2Ftop-10-coding-mistakes-made-by-data-scientists-bb5bc82faaee" rel="noopener">https://medium.com/r?URL = https % 3A % 2F % 2 ftowardsdatascience . com % 2 ftop-10-coding-errors-made-by-data-scientists-bb 5 BC 82 faaee</a><br/>【2】<a class="ae lh" rel="noopener" target="_blank" href="/data-scientists-your-variable-names-are-awful-heres-how-to-fix-them-89053d2855be">https://towards data science . com/data-scientists-your-variable-names-are-words-heres-how-to-fix-them-89053d 2855 be</a><br/>【3】<a class="ae lh" rel="noopener" target="_blank" href="/the-best-format-to-save-pandas-data-414dca023e0d">https://towards</a></p><p id="0b13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[4]<a class="ae lh" href="https://www.practicaldatascience.org/html/views_and_copies_in_pandas.html" rel="noopener ugc nofollow" target="_blank">https://www . practical data science . org/html/views _ and _ copies _ in _ pandas . html</a></p></div></div>    
</body>
</html>