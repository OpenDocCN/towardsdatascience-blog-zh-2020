<html>
<head>
<title>Binary Tree and Lowest Common Ancestor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树和最低共同祖先</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/binary-tree-and-lowest-common-ancestor-58eddd433ac?source=collection_archive---------21-----------------------#2020-11-12">https://towardsdatascience.com/binary-tree-and-lowest-common-ancestor-58eddd433ac?source=collection_archive---------21-----------------------#2020-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1123" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">二叉树中两个节点的最低公共祖先以及寻找它的算法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc6773857606515a0661d63859802761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqQTPisJ0b3KYO4Kp9vsFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="4620" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是“最低共同祖先(LCA)”。</h2><p id="8a36" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">它是树中两个节点共享的最低级别的父节点。</p><p id="9dfc" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">让我们来看一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/9c9270823dd26d3e86cfa1239b4db85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*atYX2NkzJ6EU9463as85JQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c2d7" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">在上面的二叉树中，节点8和10被突出显示。他们共有的父母是什么？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/556c680dcf79afa1b1bdc5004024774a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*QTHcAG8MkLf98IQE1mXdxg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="11fc" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">共享的父母是5，7，9是相当明显的。</p><p id="30d3" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">但最底层的共享父代是9，称为<strong class="lw iu">最低共同祖先(LCA) </strong>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="c16f" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">二叉查找树中最低的共同祖先</h2><p id="1980" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">让我们用二叉查找树热身。</p><p id="5f0b" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">二叉查找树是二叉树的一个特例，左子树只包含较小的节点，而右子树只包含较大的节点。</p><p id="41b5" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们上面的例子是一个二叉查找树。如您所见，在节点3，左子树(0，1，2)中的所有节点都小于3，而右子树中的所有节点都大于4。</p><p id="eb73" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">那么，我们如何着手寻找二叉查找树中的LCA，例如节点8和10？</p><p id="c7b7" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">实际上，二叉查找树让搜索变得非常简单。仔细看看节点9，它和节点7有什么不同？我能想到一件事:</p><p id="8f3e" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><em class="na">节点9介于8和10之间，而对于节点7，节点8和10都更大。</em></p><p id="84aa" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">这实际上是足够信息来确定节点9是二叉查找树中节点8和10的LCA，这要归功于它的巨大属性。</p><p id="a594" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">下面是它的一个实现:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="20d4" class="ky kz it nc b gy ng nh l ni nj">from collections import deque<br/><br/><br/>class Node:<br/>    def __init__(self, value, left=None, right=None):<br/>        self.value = value<br/>        self.left = left<br/>        self.right = right<br/><br/><br/>def create_bt(value_queue):<br/>    <em class="na">"""create binary tree"""<br/><br/>    </em>if len(value_queue) &lt;= 0:<br/>        return None, None<br/><br/>    root = Node(value_queue.popleft())<br/><br/>    current_queue = deque()<br/>    current_queue.append(root)<br/><br/>    while len(current_queue) &gt; 0 and len(value_queue) &gt; 0:<br/><br/>        current_node = current_queue.popleft()<br/><br/>        left = value_queue.popleft()<br/>        if left is not None:<br/>            current_node.left = Node(left)<br/>            current_queue.append(current_node.left)<br/><br/>        right = value_queue.popleft()<br/>        if right is not None:<br/>            current_node.right = Node(right)<br/>            current_queue.append(current_node.right)<br/><br/>    return root<br/><br/><br/>def create_bt_fls(value_list):<br/>    <em class="na">"""create binary create from list"""<br/><br/>    </em>return create_bt(deque(value_list))<br/><br/><br/>def lca_bst(bst, v1, v2):<br/>    <em class="na">"""lowest common ancestor of two nodes<br/>       in a binary search tree"""<br/><br/>    </em>if v1 &lt;= bst.value &lt;= v2 or v1 &gt;= bst.value &gt;= v2:<br/>        return bst<br/>    elif bst.value &gt; v1 and bst.value &gt; v2:<br/>        return lca_bst(bst.left, v1, v2)<br/>    else:<br/>        return lca_bst(bst.right, v1, v2)<br/><br/><br/>bt1 = create_bt_fls([5, 3, 7, 1, 4, 6, 9, 0, 2, None, None, None, None, 8, 10])<br/><br/>lca = lca_bst(bt1, 8, 10)<br/>print(lca.value)<br/>'''<br/>output:<br/>9<br/>'''</span></pre><p id="079e" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">在这个实现中，我们首先从一个值列表中创建一个二叉树数据结构，然后调用LCA算法来查找节点8和10的LCA，它返回正确的值9。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="b6ff" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">让我们暂停一下，稍微思考一下这个算法的复杂性。该算法从根节点开始，在每个节点将节点的值与两个输入节点进行比较，如果值在两个节点之间，则返回该节点作为答案，否则，如果值大于两个输入节点，则向左移动，如果值小于两个输入节点，则向右移动。</p><p id="5c31" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">所以在每次递归迭代过程中，搜索空间被切成两半(树的一半)，这意味着如果树中的节点总数为n，则需要的迭代次数为log(n)(以2为底)，所以复杂度为O(log(n))。不算太坏。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="f3ba" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">二叉树中的LCA(非BST)</h2><p id="aef0" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">这是一个很好的热身，现在让我们把事情变得稍微复杂一些。</p><p id="9fb6" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">现在假设这棵树不是二叉查找树，而是一棵没有特定结构的随机节点值的树。我们如何找到树中两个节点的LCA？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/022d5c293a7863020fdc06a87cde9152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PCwTxonbP0rBNp0R8fSZ1Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二叉树，作者图片</p></figure><p id="0bf3" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">如果你试图在上面的树上运行二叉查找树LCA算法，它将悲惨地失败:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f538" class="ky kz it nc b gy ng nh l ni nj">ls1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, None, None, None, None, 9, 10]<br/>bt1, node_dict = create_bt_fls(ls1)<br/><br/>lca = lca_bst(bt1, 9, 10)<br/>print(lca.value)<br/>'''<br/>output:<br/>10 WRONG!!<br/>'''</span></pre><p id="0973" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们得想别的办法。</p><p id="e728" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">一种直观的方法是从下面的观察中得来的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c3fc857fa27b4fa78e1310ae3d781435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Frshll-RL3yhBpe174XE6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">9的路径:[0，2，6，9]，10的路径:[0，2，6，10]，按作者排序的图像</p></figure><p id="8417" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">从上图中可以看出，到节点9的路径是0，2，6，9，到节点10的路径是0，2，6，10。一旦我们有了到每个节点的路径，我们需要做的就是在两条路径中找到最后一个匹配的节点，这也是我们的LCA！</p><p id="c6c2" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">下面是一个实现:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="338e" class="ky kz it nc b gy ng nh l ni nj">def find_path(tree, value):<br/>    <em class="na">"""find path from root to value"""<br/><br/>    </em>if tree is None:<br/>        return None<br/>    elif tree.value == value:<br/>        return [tree]<br/><br/>    res = find_path(tree.left, value)<br/>    if res is not None:<br/>        return [tree] + res<br/><br/>    res = find_path(tree.right, value)<br/>    if res is not None:<br/>        return [tree] + res<br/><br/>    return None<br/><br/><br/>def lca_fp(tree, v1, v2):<br/>    <em class="na">"""find lca of two nodes using find_path"""<br/><br/>    </em>path1 = find_path(tree, v1)<br/>    path2 = find_path(tree, v2)<br/><br/>    cur_idx = 0<br/>    while len(path1) &gt; cur_idx and \<br/>          len(path2) &gt; cur_idx and \<br/>          path1[cur_idx].value == path2[cur_idx].value:<br/>        cur_idx = cur_idx + 1<br/><br/>    return path1[cur_idx - 1]</span><span id="2651" class="ky kz it nc b gy nk nh l ni nj"><br/>lca = lca_fp(bt1, 9, 10)<br/>print(lca.value)<br/>'''<br/>output:<br/>6<br/>'''</span></pre><p id="d0a9" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">作品。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="5124" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">上面的算法足够简单，只需要注意一点，Find Path算法搜索整个树寻找到目标节点的路径，所以它的复杂度是O(n)，因此使用find_path的LCA算法也是O(n)。因为没有将树构造为二叉查找树而牺牲了性能。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="ba59" class="nl kz it bd la nm nn no ld np nq nr lg jz ns ka lk kc nt kd lo kf nu kg ls nv bi translated">寻路算法的优化</h1><p id="78d9" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">查找路径算法的复杂性并不令人担心，但是如果您需要重复执行搜索该怎么办呢？请记住，在一个大小为n的树中，有n选择2个唯一的节点对，即:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/89e6e7cf8dfd61f991b3879252f4eb96.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*5Xuq4_JPY0eOJ_XE-fdVmQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e4dd" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">节点对的数量，如果我们使用查找路径算法得到所有节点对的LCA，那么将是O(n n)或O(n)。也许我们应该试着加快一点。</p><p id="7d05" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">加快查找路径计算速度的一种方法是在节点中存储一个父指针，这样当我们试图查找到一个节点的路径时，我们需要做的就是沿着父指针一直到根，而不是在整个树中搜索路径。</p><p id="de95" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">下面是对树的这种增强的实现:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="9d8d" class="ky kz it nc b gy ng nh l ni nj">class Node:<br/>    def __init__(self, value, <strong class="nc iu">parent=None</strong>, left=None, right=None):<br/>        self.value = value<br/>        <strong class="nc iu">self.parent = parent</strong><br/>        self.left = left<br/>        self.right = right<br/><br/>    <strong class="nc iu">def add_to_dict(self, node_dict):<br/><br/>        node_dict[self.value] = self</strong><br/><br/><br/>def create_bt(value_queue):<br/>    <em class="na">"""create binary tree"""<br/><br/>    </em>if len(value_queue) &lt;= 0:<br/>        return None, None<br/><br/>    <strong class="nc iu">node_dict = {}</strong><br/><br/>    root = Node(value_queue.popleft())<br/><br/>    <strong class="nc iu">root.add_to_dict(node_dict)</strong><br/><br/>    current_queue = deque()<br/><br/>    current_queue.append(root)<br/><br/>    while len(current_queue) &gt; 0 and len(value_queue) &gt; 0:<br/><br/>        current_node = current_queue.popleft()<br/><br/>        left = value_queue.popleft()<br/>        if left is not None:<br/>            current_node.left = Node(left, <strong class="nc iu">parent=current_node</strong>)<br/>            <strong class="nc iu">current_node.left.add_to_dict(node_dict)</strong><br/>            current_queue.append(current_node.left)<br/><br/>        right = value_queue.popleft()<br/>        if right is not None:<br/>            current_node.right = Node(right, <strong class="nc iu">parent=current_node</strong>)<br/>            <strong class="nc iu">current_node.right.add_to_dict(node_dict)</strong><br/>            current_queue.append(current_node.right)<br/><br/>    return root, <strong class="nc iu">node_dict</strong><br/><br/><br/>def create_bt_fls(value_list):<br/>    <em class="na">"""create binary create from list"""<br/><br/>    </em>return create_bt(deque(value_list))</span></pre><p id="7acd" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">在树的这个新实现中，我们在节点中存储了一个额外的字段parent来存储父节点。</p><p id="88bc" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们还为节点创建了一个值字典，这样我们就可以很容易地找到对应于某个值的节点。</p><p id="9e1b" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">有了这两个增强，我们可以实现一个新LCA算法:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2eea" class="ky kz it nc b gy ng nh l ni nj">def lca(node1, node2):<br/><br/>    parents = set()<br/><br/>    cur_parent = node1<br/>    while cur_parent is not None:<br/>        parents.add(cur_parent)<br/>        cur_parent = cur_parent.parent<br/><br/>    cur_parent = node2<br/>    while cur_parent is not None:<br/>        if cur_parent in parents:<br/>            return cur_parent<br/>        cur_parent = cur_parent.parent<br/><br/>    return None</span><span id="0b26" class="ky kz it nc b gy nk nh l ni nj"><br/>ls1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, None, None, None, None, 9, 10]<br/>bt1, node_dict = create_bt_fls(ls1)<br/>lca1 = lca(node_dict[9], node_dict[10])<br/>print(lca1.value)<br/>'''<br/>output:<br/>6<br/>'''</span></pre><p id="8e1b" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">又管用了。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="3732" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">通过这种增强，我们牺牲了多一点的内存空间O(n)来存储父指针，但是由于从节点到根父节点的跟踪是O(log(n))，所以算法的复杂度降低到O(log(n))。在所有节点对上运行现在需要O(n log(n))内存来提高速度。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="1eb7" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><strong class="lw iu">未完待续……</strong></p><p id="b857" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">这是我们能做的最好的吗？绝对不是，有很多方法可以优化算法。特别是Tarjan的离线最低共同祖先算法，可以将性能复杂度降低到常数！但是因为它涉及一个全新的数据结构(不相交集)，我们将在另一个故事中讨论它。</p></div></div>    
</body>
</html>