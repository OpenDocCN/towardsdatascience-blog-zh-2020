<html>
<head>
<title>Understanding Full-Stack Data Science: How the NLP model in your Jupyter Notebooks Could Actually Help Stop Disasters, Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解全栈数据科学:Jupyter笔记本中的NLP模型如何帮助阻止灾难，第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-full-stack-data-science-how-the-nlp-model-in-your-jupyter-notebooks-could-actually-d813adf62321?source=collection_archive---------45-----------------------#2020-11-15">https://towardsdatascience.com/understanding-full-stack-data-science-how-the-nlp-model-in-your-jupyter-notebooks-could-actually-d813adf62321?source=collection_archive---------45-----------------------#2020-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b988" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">自然语言处理</h2><div class=""/><div class=""><h2 id="71a5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从研究到生产的灾害信息分类模型——模型的自动训练、测试和打包</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b8fa586c0dba8a81561ad57b953ae546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrqDOxpcDAjAARocIwaZdg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@zhenhu2424?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">甄虎</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="e634" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">S</span>o . S</p><p id="834e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">紧急情况随时随地都可能发生。当我们穿越这个毁灭性的全球疫情时，我们现在见证了所有一线急救人员的绝对才华。事实上，派遣救援队只是他们已经很辛苦的工作的一部分。当灾难发生时，援助请求信息会从所有不同的渠道快速而猛烈地传来。来自不同渠道的所有请求救援的信息会很快淹没人类的劳动。</p><p id="4319" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，需要一种自动且可靠的方式将救援请求消息快速分类到正确的对应信道中。一个自然的选择是用一些机器学习模型构建一个消息分类器。所以我们通常会拿起我们的jupyter笔记本开始开发，对吗？事实上，这只是这里所做工作的一部分。借助Jupyter笔记本电脑，我们可以创建引人入胜的数据视觉效果和易于阅读的模型表示，但这些模型只能被观看，不会产生任何实际影响。因此，能够将模型转换成生产就绪的代码库对于团队直接创建功能是至关重要的。在这篇博文中，我们将通过在PaaS平台Heroku上构建一个完全容器化的、持续集成的灾难消息应用程序来说明全栈数据科学实践。<strong class="lk jd">由于我们使用的数据集(图8灾难消息)在数据科学社区中相当有名，我们将主要关注用于生产模型的高级工具，</strong>如Sklearn Pipeline、Pytest、Docker和CircleCI。为了避免这篇文章太长而无法阅读，我们将重点讨论这个模型的构建和打包过程</p><h2 id="4897" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated">项目总体结构</h2><p id="99af" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">由于会涉及到各种不同的文件，因此对项目结构有一个清晰的理解对项目的成功至关重要。在项目的根目录下，我们会有一个标准的<code class="fe nk nl nm nn b">.gitignore</code>文件和一个<code class="fe nk nl nm nn b">ReadMe.md</code>文件。还存在4个子目录，</p><ul class=""><li id="f5c9" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md nt nu nv nw bi translated"><strong class="lk jd">。circle ci</strong>—circle ci持续集成工具所需，包含<code class="fe nk nl nm nn b">circleci.config</code>文件，用于自动化模型培训和部署工作流</li><li id="cc53" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">disaster _ messaging _ class ification _ model</strong>—包含机器学习模型包，该包将传入的消息预测到其适当的类别中</li><li id="a726" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd"> disaster_messaging_app </strong> —包含API和docker文件，可用于训练好的机器学习模型，将由circleci部署</li><li id="79d1" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">笔记本</strong> —包含探索性分析笔记本</li></ul><p id="4bc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">。circleci </strong>和<strong class="lk jd">笔记本</strong>文件夹的用途非常明显。当我们构建这些模块时，我们将看看<strong class="lk jd">disaster _ messaging _ class ification _ model</strong>和<strong class="lk jd"> disaster_messaging_app </strong>中有什么。</p><h2 id="f548" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated">获取数据</h2><p id="d8d7" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">我们将使用Kaggle的多类别灾难响应消息数据集，其中包含英语消息、原始消息、消息发送通道以及所有37种二进制编码的消息类别。一封邮件可以属于多个类别。前5行如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/6937f769480343b62485e93e3efc05f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2MHqBqxsyMQkzyMromHbA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">disaster_response_messages.csv前5行</p></figure><p id="adf4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以手动下载数据并将文件保存到数据文件夹中。然而，在一般实践中，为了确保我们总是从数据源获得最新的数据，我们将使用shell脚本来自动化数据提取过程。对于我们的项目，数据来自Kaggle的<a class="ae lh" href="https://www.kaggle.com/landlord/multilingual-disaster-response-messages" rel="noopener ugc nofollow" target="_blank">多语言灾难响应消息</a>。该数据集包含从多个渠道提取的30，000条消息。一般过程如下，</p><ul class=""><li id="6ac7" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md nt nu nv nw bi translated">从Kaggle的多重灾难响应消息中下载数据</li><li id="40c5" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated">解压缩下载的zip存档文件，并将CSV文件保存到同一目录</li><li id="bcfc" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated">删除zip存档文件</li><li id="08c0" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated">通过将验证CSV和测试CSV中的内容复制到培训CSV中，将所有消息文件合并成一个文件(我们将在后面设置培训测试验证)</li><li id="d583" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated">将培训文件重命名为<code class="fe nk nl nm nn b">disaster_response_messages.csv</code></li><li id="6ea8" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated">删除两个额外的CSV文件-验证CSV和测试CSV</li></ul><p id="e18d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有这些步骤都可以在终端外壳命令中完成，</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6963" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这个shell脚本，上面的整个过程可以在下面一行中执行</p><pre class="ks kt ku kv gt of nn og oh aw oi bi"><span id="a185" class="mn mo it nn b gy oj ok l ol om">sh fetch_data.sh</span></pre><p id="094a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">执行后，您将能够看到<code class="fe nk nl nm nn b">disaster_response_messages.csv</code>文件存在于<strong class="lk jd">disaster _ messaging _ class ification _ model</strong>目录的data文件夹中。现在我们已经有了数据，我们可以继续为这个机器学习模型构建、训练和设置预测管道。</p><h2 id="26e9" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated">构建模型</h2><p id="5ca5" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">对于我们大多数人来说，构建模型应该是一个相对熟悉的过程。我们获取数据，将相关的机器学习框架导入到我们的jupyter笔记本中，训练模型，然后评估模型。在sklearn pipelines的帮助下，我们可以构建一个自包含的、稳定的、可复制的模型管道。由于这个<strong class="lk jd">disaster _ messaging _ classification _ model</strong>目录包含多个相关文件，我们将从查看该文件夹的结构开始。</p><p id="a2d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<strong class="lk jd">灾难_消息_分类_模型</strong>子目录中，包含以下文件/子目录</p><ul class=""><li id="7fb1" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md nt nu nv nw bi translated"><strong class="lk jd">配置</strong> —包含模型和日志记录的配置文件</li><li id="7d4a" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">数据</strong> —下载数据的保存目录</li><li id="9e71" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">特征</strong>-包含创建模型管线中使用的特征的模块</li><li id="a676" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">模型</strong> —包含机器学习模型的训练和预测脚本</li><li id="6e3a" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">脚本</strong> —包含<code class="fe nk nl nm nn b">fetch_kaggle_dataset.sh</code> shell脚本的目录</li><li id="2c5a" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">测试</strong> —包含确保机器学习模型稳定行为的python单元测试</li><li id="be0a" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd"> trained_model </strong> —用于保存训练好的机器学习模型pickle文件和性能报告的目录，该文件夹不提交，将由数据实用函数自动创建(托管在<strong class="lk jd"> utils </strong>目录中)</li><li id="fa9b" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd"> utils </strong> —包含用于数据预处理、模型构建和可视化创建的实用函数</li><li id="08ed" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">可视化</strong>——包含构建显示在前端的单词云的<code class="fe nk nl nm nn b">generate_visuals.py</code>。</li><li id="2522" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">Makefile</strong>—circle ci正在使用的重要自动化脚本。关于这个文件的更多细节稍后</li><li id="be26" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">py project . toml</strong>—<strong class="lk jd"/>依赖定义文件，用于生成依赖锁文件(更多信息<a class="ae lh" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">此处</a>)</li><li id="79df" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd">poem . lock</strong>—调用<code class="fe nk nl nm nn b">poetry lock</code>从<code class="fe nk nl nm nn b">pyproject.toml</code> <strong class="lk jd"> </strong>文件生成的锁文件</li><li id="ca7a" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md nt nu nv nw bi translated"><strong class="lk jd"> setup.py </strong> —项目打包定义文件，包含所有安装需求和安装包</li></ul><p id="fd9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">数据预处理</strong></p><p id="c722" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了将数据提取为模型可用的格式，我们将按照以下步骤提取CSV并将转换后的数据保存到SQLite数据库中。</p><ol class=""><li id="95b8" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated">从保存在<strong class="lk jd">数据</strong>目录的CSV文件中加载数据作为熊猫数据帧(用<code class="fe nk nl nm nn b">load_data(<em class="oo">messages_filepath</em>)</code>函数定义)</li><li id="1818" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">在加载的数据帧中添加一列指示数据串测试分割(用<code class="fe nk nl nm nn b">train_test_split_label(<em class="oo">df</em>)</code>功能定义)</li><li id="4278" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">将数据帧保存到SQLite数据库中(用<code class="fe nk nl nm nn b">save_data(<em class="oo">df</em>, <em class="oo">database_filename</em>)</code>函数定义)</li></ol><p id="1a99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">4.定义一个调用上述3个步骤的函数(用<code class="fe nk nl nm nn b">process_data()</code>定义)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="29d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于原始数据相对干净，大多数数据转换操作将在我们创建标记化句子特征时执行(接下来)。</p><p id="3d44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">特征—标记器</strong></p><p id="6727" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要将原始文本转换为机器可读的单词标记，我们需要构建一个标记化器，删除停用词(如this、that、I、am……)，将单词按字母排序为原始格式，删除URL并去掉多余的空白。该模块在名为<code class="fe nk nl nm nn b">message_tokenizer.py</code>的文件中被构建为一个转换器。由于这个tokenizer转换器被用作一个特性创建器，我们将把它放在<strong class="lk jd">特性</strong>目录中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3b91" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">模型管道—培训</strong></p><p id="fa70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该模型的流水线仅由4个步骤组成，</p><ol class=""><li id="c2f9" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated">记号化——由我们上面定义的记号化器完成</li><li id="2322" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">计数矢量化—对所有句子进行字数统计，这由sklearn的计数矢量化工具完成</li><li id="63a7" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">TF-IDF-使用计数矢量化文本，可以使用sklearn的TF-IDF转换器计算TF-IDF特征</li><li id="ebbd" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">Adaboost模型——一旦创建了特性，我们就可以将模型作为管道的最后一步</li></ol><p id="ebd1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上述4个步骤可以很容易地构建成如下所示的管道函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="bf5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为下一步，我们可以继续构造训练函数，它包括如下步骤</p><ol class=""><li id="0f7e" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated">从数据库加载训练数据(在<code class="fe nk nl nm nn b">model_utils.py</code>的<code class="fe nk nl nm nn b">load_data_from_db</code>功能中定义)</li><li id="e83f" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">构建模型管道(在上述函数<code class="fe nk nl nm nn b">build_model_pipeline()</code>中定义)</li><li id="4efa" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">符合模型</li><li id="00db" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">保存模型管线(在<code class="fe nk nl nm nn b">model_utils.py</code>的<code class="fe nk nl nm nn b">save_pipeline</code>功能中定义)</li><li id="7130" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">从数据库加载测试数据(在<code class="fe nk nl nm nn b">model_utils.py</code>中定义)</li><li id="813c" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">评估模型(在<code class="fe nk nl nm nn b">model_utils.py</code>中定义)</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2b9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nk nl nm nn b">load_data_from_db</code>函数可以选择加载训练数据还是测试数据(默认为“train”)，具体定义如下</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7072" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nk nl nm nn b">save_pipeline()</code>功能将以<code class="fe nk nl nm nn b">config.py</code>中定义的特定命名约定(<em class="oo"> model_name_version.pkl </em>)将新训练的模型保存到特定位置(<strong class="lk jd"> trained_models目录</strong>),同时删除旧版本的模型管道以避免引用冲突。具体定义如下所示</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0563" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nk nl nm nn b">evaluate_model()</code>函数将使用内置的sklearn评估API并生成性能报告，该报告将保存在<strong class="lk jd">trained _ models/performance _ report</strong>目录中。具体定义如下所示</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="78d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">模型管道—预测</strong></p><p id="eefb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在对模型进行训练、保存和评估之后，我们现在就可以使用该模型在新数据到来时生成一些预测。预测脚本只包含3个步骤，可以在一个函数中实现</p><ol class=""><li id="3ccc" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated">收集输入数据并将其转换为与训练数据相同的形式</li></ol><p id="7b81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.加载管道并使用输入数据进行预测</p><p id="a681" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.组装包含预测结果和模型版本的有效负载</p><p id="08ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">具体定义如下所示</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f122" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">可视化——文字云</strong></p><p id="ae3e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将建立将在前端使用的单词云可视化。由于我们的前端只使用javascript来显示单词云视觉效果，我们将依靠Plotly的特殊布局结构和<code class="fe nk nl nm nn b">plotly_wordcloud</code>函数来生成我们的消息来自的3个不同渠道中最常用的单词的3个视觉效果——新闻、社交媒体和直接消息。</p><p id="020a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总体步骤如下，</p><ol class=""><li id="f2b7" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated">使用<code class="fe nk nl nm nn b">visual_utils.py</code>中定义的<code class="fe nk nl nm nn b">load_data_from_db_visual</code>将保存的数据库中的信息数据作为数据帧加载</li><li id="a319" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">通过数据帧的<code class="fe nk nl nm nn b">channel</code>列分割数据帧，并获得具有特定通道的子数据帧</li><li id="2fb8" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">使用<code class="fe nk nl nm nn b">plotly_wordcloud</code>函数生成一个可以被前端解释的JSON格式的字符串</li></ol><p id="5b9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nk nl nm nn b">VisualsGeneration</code>类定义如下。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f259" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nk nl nm nn b">plotly_wordcloud</code>功能(配方由Prashant <a class="ae lh" href="https://github.com/PrashantSaikia/Wordcloud-in-Plotly/blob/master/plotly_wordcloud.py" rel="noopener ugc nofollow" target="_blank">提供，此处为</a>)遵循以下一般步骤。</p><ol class=""><li id="4259" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated">创建单词云对象</li><li id="6bef" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">创建5个列表，收集列表中每个单词的单词、频率、字体大小、位置、方向和颜色列表，从单词云对象的<code class="fe nk nl nm nn b">.layout_</code>属性中提取</li><li id="96af" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">创建布局和数据跟踪，然后使用Plotly内置包构建图形</li></ol><p id="67e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该函数定义如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="79e1" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated"><strong class="ak">自动训练/打包</strong></h2><p id="8132" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">随着模型管道、训练和预测脚本的构建，我们可以在终端中使用一系列shell命令来执行与该模型相关的工作流。例如，我们可以在终端中调用以下两个命令来打包保存的训练模型，并将模型上传到PyPI服务器。</p><pre class="ks kt ku kv gt of nn og oh aw oi bi"><span id="5dd8" class="mn mo it nn b gy oj ok l ol om">python setup.py sdist</span><span id="86a9" class="mn mo it nn b gy op ok l ol om">twine upload --skip-existing dist/*</span></pre><p id="5465" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">执行模型打包将需要存在训练数据、所有安装在当前执行环境中的依赖包，并且模型已经被训练和保存。换句话说，在我们最终上传训练好的模型之前，我们需要完成一系列的步骤。</p><p id="1b1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">构建依赖关系定义</strong></p><p id="201e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将从为我们的模型包创建适当的环境定义开始，这可以通过构建由python依赖管理工具<a class="ae lh" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">poem</a>使用的<code class="fe nk nl nm nn b">pyproject.toml</code>文件来完成。pyproject。toml文件如下所示，</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b03e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们可以在终端中调用<code class="fe nk nl nm nn b">poetry lock</code>，这将生成一个<code class="fe nk nl nm nn b">poetry.lock</code>文件，其中包含该项目所需的所有锁定版本的包依赖项。锁定版本将允许我们在安装包依赖关系时有必要的一致性，以防部分依赖包收到更新，这会给我们的项目带来意想不到的问题。</p><p id="43ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">建立包装定义</strong></p><p id="1a59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于我们上传到PyPI服务器的每个python包，我们需要创建一个<code class="fe nk nl nm nn b">setup.py</code>文件。幸运的是，我们可以使用名为<a class="ae lh" href="https://github.com/dephell/dephell" rel="noopener ugc nofollow" target="_blank"> depshell </a>的工具为我们创建文件。我们只需要调用下面的命令来创建<code class="fe nk nl nm nn b">setup.py</code>文件。</p><pre class="ks kt ku kv gt of nn og oh aw oi bi"><span id="f6d1" class="mn mo it nn b gy oj ok l ol om">pip install dephell</span><span id="f879" class="mn mo it nn b gy op ok l ol om">dephell deps convert</span></pre><p id="229b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">创建的<code class="fe nk nl nm nn b">setup.py</code>文件如下所示</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9cf2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">创建自动化生成文件</strong></p><p id="7299" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于要执行这么多shell命令，简单地创建一个包含所有步骤的文件对于可读性和透明性来说并不理想。幸运的是，我们可以创建一个<code class="fe nk nl nm nn b">Makefile</code>,有效地将步骤聚集成组，这些组只包含完成单个任务的命令。例如，要安装和构建包依赖关系定义，我们可以将以下一系列命令写入Makefile，</p><pre class="ks kt ku kv gt of nn og oh aw oi bi"><span id="d6ef" class="mn mo it nn b gy oj ok l ol om"><strong class="nn jd">poetry-install</strong>:</span><span id="ec06" class="mn mo it nn b gy op ok l ol om">poetry lock</span><span id="6c0e" class="mn mo it nn b gy op ok l ol om">poetry config virtualenvs.create false \</span><span id="84ea" class="mn mo it nn b gy op ok l ol om">&amp;&amp; poetry export --without-hashes -f requirements.txt --dev\</span><span id="16bd" class="mn mo it nn b gy op ok l ol om">|  pip install -r /dev/stdin \</span><span id="22d2" class="mn mo it nn b gy op ok l ol om">&amp;&amp; poetry debug</span></pre><p id="bd9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后要执行这一系列的命令，我们只需要在终端中调用<code class="fe nk nl nm nn b">make poetry-install</code>，上面所有的命令集都会被执行。下面概述了将放入Makefile的步骤</p><ol class=""><li id="2779" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated">从诗锁文件安装依赖项</li><li id="20ed" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">从Kaggle获取数据集</li><li id="47b3" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">从dephells构建setup.py文件</li><li id="cc94" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">安装nltk资源(用于删除句子的停用词和词条)</li><li id="06cd" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">通过调用<code class="fe nk nl nm nn b">data_utils.py</code>预处理数据</li><li id="8bb2" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">通过调用<code class="fe nk nl nm nn b">train.py</code>训练模型</li><li id="4ac8" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">通过调用<code class="fe nk nl nm nn b">test.py</code>来测试模型</li><li id="d081" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">将模型包上传到PyPI</li></ol><p id="3b1f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完整的Makefile如下所示，</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="6aef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这很好，因为许多步骤可以总结成一个简短的make语句。为了进一步使整个过程自动化，我们将使用一个配置文件来指示circleci一个接一个地执行这些步骤。</p><p id="a86b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">配置CircleCI持续集成工具</strong></p><p id="1407" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">CicleCI是一个强大的持续集成工具，它允许我们的模型被自动训练、测试和打包，以供发布。它还使用自己的托管docker映像，模拟其他人有效使用您的项目的过程，因为它遵循本地安装项目时相同的设置步骤。我们只需要在名为<code class="fe nk nl nm nn b">.circleci</code>的指定文件夹中定义一个<code class="fe nk nl nm nn b">config.yaml</code>文件。更多关于circleci的资源和文档可以在<a class="ae lh" href="https://circleci.com/docs/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="806c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，现在的问题变成了我们需要遵循什么步骤来使这个项目从零开始工作？我们已经有了Makefile中的大部分步骤，我们只需要连接它们。</p><ol class=""><li id="19cd" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated">安装pip工具/将pip工具升级到最新版本</li><li id="a2b1" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">安装诗歌工具(通过pip安装)</li><li id="0a39" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">使用上面定义的make命令安装诗歌锁文件中的依赖项</li><li id="b3a3" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">使用上面定义的make命令从Kaggle获取数据集</li><li id="2a2d" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">使用上面定义的make命令预处理原始数据</li><li id="7ea4" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">使用上面定义的make命令训练模型</li><li id="346a" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">使用上面定义的make命令运行模型测试</li><li id="34c9" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">初始化PyPI的凭证文件——这将允许我们将包上传到PyPI服务器</li><li id="c020" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated">使用上面定义的make命令创建并上传模型包</li></ol><p id="8c57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">circle配置文件将以3行常规头开始，指示circleci的python docker映像版本，在我们的例子中是0.2.1。</p><p id="2cc6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后在下一行，<code class="fe nk nl nm nn b">jobs</code>将指示完成我们项目中定义的任务(我们上面定义的9个步骤)所要完成的自动化工作流步骤的开始。<code class="fe nk nl nm nn b">config.yaml</code>文件将如下所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="645d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">设置CircleCI </strong></p><p id="e6bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在用yaml文件配置CI工作流之后，我们将继续到CircileCI的网站并设置它与github存储库之间的连接。</p><p id="96d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将从使用包含我们的项目资源库的github帐户登录CircleCI开始。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/889c3576d3d6337edabcbd4a890ebecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdToOqEqgZkAfXZEnddOyw.png"/></div></div></figure><p id="1ba6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们将导航到左侧菜单栏上的第二个图标(<strong class="lk jd">项目</strong>)并找到我们对应的项目存储库。对我来说，它叫做<code class="fe nk nl nm nn b">Disaster_Response_Messaging_Classifier</code>。然后，我们将单击蓝色的“设置项目”按钮。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/2d6040467fef8b456038e4e41e3affcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rj_XuvQwfoizwqSVBEWNQ.png"/></div></div></figure><p id="2063" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在语言下拉菜单中，我们将选择“Python”，然后将我们的<code class="fe nk nl nm nn b">config.yaml</code>文件复制到下拉菜单正下方的编辑器中。然后点击“添加配置”按钮。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/28b0bdd11862595ecf6dbbef73c15fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hB2vori5k5yzSkAquntzBg.png"/></div></div></figure><p id="c7c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将登陆<strong class="lk jd">仪表板</strong>页面。由于我的项目已经构建了多次，工作流完成的状态将在仪表板上显示为行项目。要设置完成项目所需的环境变量，我们将单击左上角的“项目设置”按钮。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/b2eb1250ba83401eee2a99fffed41678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*we3JaiXxXB1-Pz7MCVFwIQ.png"/></div></div></figure><p id="0a17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下一页中，导航到左侧面板并单击“环境变量”。我们将需要添加以下4个环境变量，以使工作流完全发挥作用。</p><ol class=""><li id="b5dc" class="no np it lk b ll lm lo lp lr nq lv nr lz ns md on nu nv nw bi translated"><code class="fe nk nl nm nn b"><strong class="lk jd">KAGGLE_KEY</strong></code> <strong class="lk jd"> </strong> —设置Kaggle的API时获得。关于如何设置的更多资源可以在<a class="ae lh" href="https://github.com/Kaggle/kaggle-api" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li><li id="9f05" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated"><code class="fe nk nl nm nn b"><strong class="lk jd">KAGGLE_USERNAME</strong></code> <strong class="lk jd"> </strong> —设置Kaggle的API时获得</li><li id="6ad5" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated"><code class="fe nk nl nm nn b"><strong class="lk jd">PYPI_USERNAME</strong></code> <strong class="lk jd"> </strong> —在PyPI服务器上注册账户时获得</li><li id="eee6" class="no np it lk b ll nx lo ny lr nz lv oa lz ob md on nu nv nw bi translated"><code class="fe nk nl nm nn b"><strong class="lk jd">PYPI_PASSWORD</strong></code> <strong class="lk jd"> </strong> — <strong class="lk jd"> </strong>在PyPI服务器上注册账户时获得</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/f7618052f7ba343b2f466060b3cc4f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1cIFpmqIeVPoY8E5y6Vrg.png"/></div></div></figure><p id="049e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其他3个环境变量用于部署，这将在<a class="ae lh" rel="noopener" target="_blank" href="/understanding-full-stack-data-science-how-the-nlp-model-in-your-jupyter-notebooks-could-actually-460f17baf30b">第2部分</a>中讨论。</p><p id="aecd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在已经为我们的项目设置好了持续集成工具，现在是时候看看它是如何工作的了。</p><p id="ecfe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">提交、推送、观察和验证</strong></p><p id="4ccf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如题所示。我们将提交并推动回购，并观察工作流程自行进行。如果一切正常，我们将看到以下屏幕，指示工作流已成功完成。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/370c97a510f4c6cce59ad13a19aeebe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXmMONnGHXgLFlLzIl14XA.png"/></div></div></figure><p id="054c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们可以登录到我们的PyPI服务器，验证包是否被正确地推送到主机中。它确实在我们的项目列表中，耶！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/fe71243aae49c5bc6dce7917d49fcae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCf2u6VPex3bHqHfUCiTlQ.png"/></div></div></figure><h2 id="c80a" class="mn mo it bd mp mq mr dn ms mt mu dp mv lr mw mx my lv mz na nb lz nc nd ne iz bi translated">结论/结尾</h2><p id="8e47" class="pw-post-body-paragraph li lj it lk b ll nf kd ln lo ng kg lq lr nh lt lu lv ni lx ly lz nj mb mc md im bi translated">我们现在已经成功地完成了机器学习模型的构建，该模型将帮助我们将消息分类到它们正确的通道中。更重要的是，我们已经完全自动化了该模型的模型构建、训练和打包过程。每次，当我们想要更改模型定义，或者甚至想要在有新数据进入时重新训练模型时，我们所要做的只是提交和推送。</p><p id="0630" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">谢谢你坚持到最后。这只是故事的一部分，因为我们将在<a class="ae lh" rel="noopener" target="_blank" href="/understanding-full-stack-data-science-how-the-nlp-model-in-your-jupyter-notebooks-could-actually-460f17baf30b">第二部分</a>中谈论一些更令人兴奋的部署过程，这些过程将使这个项目真正端到端。</p></div></div>    
</body>
</html>