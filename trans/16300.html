<html>
<head>
<title>SKORCH: PyTorch Models Trained with a Scikit-Learn Wrapper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SKORCH:用Scikit-Learn包装器训练的PyTorch模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/skorch-pytorch-models-trained-with-a-scikit-learn-wrapper-62b9a154623e?source=collection_archive---------18-----------------------#2020-11-10">https://towardsdatascience.com/skorch-pytorch-models-trained-with-a-scikit-learn-wrapper-62b9a154623e?source=collection_archive---------18-----------------------#2020-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c46b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解使用SKORCH训练PyTorch模型是多么容易和简单的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f5fde3a460b7458912041b6eef54b887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_xhCo9_8YLvTAk9H"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">肯尼斯·贝里奥斯·阿尔瓦雷斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有想过有没有一种工具可以简单方便地训练和评估<strong class="lb iu"> PyTorch </strong>车型？这个工具确实存在，它就是<strong class="lb iu"> SKORCH </strong>，一个用于训练<strong class="lb iu"> PyTorch </strong>模型的<strong class="lb iu"> scikit-learn </strong>包装器。</p><p id="02ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博客中，我们将讨论什么是<strong class="lb iu"> SKORCH </strong>，它的组成部分，以及包装一个<strong class="lb iu"> PyTorch </strong>模型来训练和评估它是多么容易。博客将分为以下几个部分:</p><ul class=""><li id="252c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">什么是SKORCH？</strong></li><li id="e058" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> PyTorch型号</strong></li><li id="56e9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">与斯科奇一起训练</li></ul><p id="cb8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><h1 id="7c2b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">什么是斯科奇？</h1><p id="ed99" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><strong class="lb iu"> SKORCH </strong>是<strong class="lb iu"> scikit-learn </strong>和<strong class="lb iu"> PyTorch </strong>的并集，换句话说，<strong class="lb iu"> SKORCH </strong>是一个用于训练、调整和优化<strong class="lb iu"> PyTorch </strong>模型的包装器。<strong class="lb iu"> SKORCH </strong>是2017年推出的开源库【1】，<strong class="lb iu"> SKORCH </strong>的出现是为了将<strong class="lb iu"> PyTorch </strong>和<strong class="lb iu"> SciKit-learn </strong>框架的伟大优点结合在一起并加以增强。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/b98ac0b2c138ce7807da7080628ff76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E4GZb4qpcppgTM6BYN_X_Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。PyTorch + SciKit-Learn = SKORCH |作者图片|取自原始来源的徽标</p></figure><p id="733c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyTorch 是开发神经网络模型最常用的框架之一，然而，有些阶段需要开发时间，有时它会成为有些不切实际的部分。<strong class="lb iu">斯科奇</strong>试图简化<strong class="lb iu"> PyTorch </strong>车型培训阶段的各种流程。在一个或多个功能中开发<strong class="lb iu"> PyTorch </strong>模型的训练模块是很常见的，然而，当需要评估模型或优化以找到最佳参数时，需要开发额外的功能。所有这些过程都被<strong class="lb iu"> SKORCH </strong>简化了，因为它是基于<strong class="lb iu"> scikit-learn </strong>的包装，因此扩展了已经执行这些过程的函数。</p><blockquote class="nh ni nj"><p id="0196" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">斯科奇宣称他的哲学是:“做一个科学的人——学习API，学会黑客，不要隐藏PyTorch，不要重新发明轮子”</p></blockquote><p id="2b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图2中，我们可以看到复合了<strong class="lb iu">斯科奇</strong>的<strong class="lb iu"> PyTorch </strong>和<strong class="lb iu"> scikit-learn </strong>的能力。正如我们所见，从<strong class="lb iu"> PyTorch </strong>方面来看，原型化模型和处理数据集的能力被使用了。另一方面，我们观察到<strong class="lb iu"> scikit-learn </strong>已知的函数被扩展到能够训练、评估、调整和优化机器学习模型，这种组合使<strong class="lb iu"> SKORCH </strong>成为一个强大的工具。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/9adbde05912eea1512ed35cdca146295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDY94d2J83UzXgvdJXWCoA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。PyTorch和scikit的优势-了解SKORCH |作者图片|来自原始来源的徽标</p></figure><p id="7503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，我们可以将<strong class="lb iu"> SKORCH </strong>视为<strong class="lb iu"> Keras API </strong>的<em class="nk">等价物</em>，它从<strong class="lb iu"> Tensorflow </strong>扩展而来，以加速、简化和加快神经网络模型的原型化。在这种情况下，<strong class="lb iu"> SKORCH </strong>将作为<strong class="lb iu"> PyTorch </strong>模型的训练、调整和优化阶段的原型工具。</p><p id="2044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，到目前为止我们已经知道了<strong class="lb iu"> SKORCH </strong>是什么，它的组件是什么，使用它的优势是什么，是时候看看一个例子来更好地了解它的工作原理了，让我们开始吧！</p><h1 id="7ac5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">PyTorch模型</h1><p id="b51c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了了解<strong class="lb iu"> SKORCH </strong>在训练<strong class="lb iu"> PyTorch </strong>模型时是如何工作的，我们将创建一个神经网络来预测众所周知的<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/wine" rel="noopener ugc nofollow" target="_blank">葡萄酒数据集</a>。因此，首先我们将根据上述数据集创建一个简单的葡萄酒分类模型，然后我们有:</p><blockquote class="nh ni nj"><p id="861e" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">如果你想访问完整的实现，看看:<a class="ae ky" href="https://github.com/FernandoLpz/SKORCH-PyTorch-Wrapper" rel="noopener ugc nofollow" target="_blank">https://github.com/FernandoLpz/SKORCH-PyTorch-Wrapper</a></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段1。PyTorch模型</p></figure><p id="6ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，有些值是固定的。实际上，我只想强调第9行和第12行。在第9行中，我们定义了13个输入特征，这是因为葡萄酒数据集包含13个特征。另一方面，在第12行中，我们定义了大小为3的输出，这是因为我们要分类的类是3(即3种类型的葡萄酒)。</p><p id="923f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完美，<strong class="lb iu"> PyTorch </strong>模型做好了，是时候看看我们如何用<strong class="lb iu"> SKORCH </strong>训练这个模型了，让我们进入下一节！</p><h1 id="e0f2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">与SKORCH一起训练</strong></h1><h2 id="6a0e" class="nr mk it bd ml ns nt dn mp nu nv dp mt li nw nx mv lm ny nz mx lq oa ob mz oc bi translated">1.基础训练</h2><p id="cec0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通过<strong class="lb iu"> SKORCH </strong>进行的培训可以根据我们的需要简单或复杂，对于实际例子，我们将逐步进行。因此，训练上一节中定义的模型的一个基本而简单的方法就像下面几行代码一样简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段2。简单训练</p></figure><p id="d8b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将逐行分析。在第2行中，我们导入了<strong class="lb iu"> PyTorch </strong>模型(在前面的部分中已经定义)。在第4行中，我们导入了一个类，它将作为我们的<strong class="lb iu"> PyTorch </strong>模型的<em class="nk">包装器</em>。该类接收一系列重要参数(第7行),它们是:PyTorch模型，历元数，学习率，批量，优化器。显然，它们不是我们在这个类中可以定义的唯一参数，然而为了实用，我们将只显示在这个例子中已经提到的那些参数。最后，在第9行，我们执行“<em class="nk"> fit </em>”方法，它将负责执行整个训练阶段。</p><p id="fa15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道，“<em class="nk">那么分解成训练和验证呢？</em>”，那么<em class="nk"> NeuralNetClassifier </em>类也会处理这个问题。默认情况下，该类实现数据的<em class="nk"> StratifiedKFold </em>分割，80%用于训练，20%用于验证。好了，一旦上面提到，这将是输出:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="36ef" class="nr mk it oe b gy oi oj l ok ol">epoch    train_loss    valid_acc    valid_loss     dur<br/>-------  ------------  -----------  ------------  ------<br/>      1        9.6552       0.4167        9.2997  0.0124<br/>      2        9.6552       0.4167        9.2997  0.0109<br/>      3        9.6552       0.4167        9.2997  0.0107<br/>      4        9.6552       0.4167        9.2997  0.0109<br/>      5        9.6552       0.4167        9.2997  0.0116<br/>      6        9.6552       0.4167        9.2997  0.0119<br/>      7        9.6552       0.4167        9.2997  0.0114<br/>      8        9.6552       0.4167        9.2997  0.0113<br/>      9        9.6552       0.4167        9.2997  0.0115<br/>     10        9.6552       0.4167        9.2997  0.0115</span></pre><p id="a4aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出的结构如前面的代码片段所示。正如我们所看到的，默认情况下它显示了关于<em class="nk">训练</em>和<em class="nk">验证</em>集合中<em class="nk">损失</em>的信息，以及<em class="nk">验证</em>中<em class="nk">精度</em>和执行时间的信息。由于我们没有调整模型，结果非常差，但是，我们将在接下来的例子中解决这个问题。</p><h2 id="d909" class="nr mk it bd ml ns nt dn mp nu nv dp mt li nw nx mv lm ny nz mx lq oa ob mz oc bi translated">2.管道:定标员+培训</h2><p id="5efc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在上一点中，我们看到了如何用<strong class="lb iu"> SKORCH </strong>以一种基本的方式训练模型。然而，数据处理是一个非常重要的阶段，总是在训练阶段之前进行。在这种情况下，我们将执行一个非常简单的预处理，我们将只对数据进行<em class="nk">缩放，然后我们将执行<em class="nk">训练</em>，为此，我们将利用<em class="nk"> scikit-learn Pipeline </em>模块，因此我们将拥有以下内容:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段3。涉及扩展和培训的管道</p></figure><p id="9c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第5行和第6行，我们从<strong class="lb iu"> scikit-learn </strong>导入了流水线和<em class="nk"> StandardScaler </em>模块。在第12行中，我们可以看到，我们初始化包装器的方式与上一点完全相同(使用固定值)，有趣的事情出现在第14行和第15行，在那里管道被初始化，它包含<em class="nk"> StandarScaler() </em>模块以及<strong class="lb iu"> PyTorch </strong>模型的包装。运行这个程序，我们得到:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="bfdd" class="nr mk it oe b gy oi oj l ok ol">epoch    train_loss    valid_acc    valid_loss     dur<br/>-------  ------------  -----------  ------------  ------<br/>      1        0.4663       0.8889        0.3528  0.0124<br/>      2        0.0729       0.8889        0.6507  0.0111<br/>      3        0.0420       0.9167        0.4564  0.0118<br/>      4        0.0101       0.9167        0.3142  0.0116<br/>      5        0.0041       0.9167        0.3321  0.0119<br/>      6        0.0028       0.9167        0.3374  0.0129<br/>      7        0.0022       0.9167        0.3376  0.0111<br/>      8        0.0017       0.9167        0.3384  0.0122<br/>      9        0.0014       0.9167        0.3373  0.0135<br/>     10        0.0012       0.9167        0.3378  0.0118</span></pre><p id="8595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要强调的是，结果显著改善，这是由于在训练阶段之前对数据进行了缩放。</p><p id="8b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经看到了如何在执行管道中将<strong class="lb iu"> PyTorch </strong>模型(具有固定参数)训练为<strong class="lb iu"> scikit-learn </strong>模块，然而，我们如何将其他评估指标(如<em class="nk">准确性</em>或<em class="nk">平衡准确性</em>添加到<strong class="lb iu"> SKORCH </strong>模块，这就是我们利用回调的地方。</p><h2 id="c02a" class="nr mk it bd ml ns nt dn mp nu nv dp mt li nw nx mv lm ny nz mx lq oa ob mz oc bi translated">3.管道:定标员+培训+回访</h2><p id="7196" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><strong class="lb iu">回调</strong>是SKORCH的扩展，它允许我们向<em class="nk"> NeuralNetClassifier </em>包装器添加其他函数，例如，如果我们希望优化指标是<em class="nk"> balanced_accuracy </em>或<em class="nk"> ROC </em>或任何其他分类指标，这可以通过<strong class="lb iu">回调</strong>来完成。因此，引入一个<strong class="lb iu">回调</strong>来计算流水线内模型的<em class="nk">精度</em>和<em class="nk">平衡精度</em>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段4。涉及扩展、培训和回访的渠道</p></figure><p id="7560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，正如我们在第9行看到的，我们导入了<em class="nk">划时代</em> <em class="nk">回调</em>。为了使用<em class="nk">回调</em>，我们只需通过传递我们想要用作参数的度量的名称来初始化它，在这种情况下，我们为度量初始化“<em class="nk"> balanced_accuracy </em>和“<em class="nk"> accuracy </em>”。此外，我们必须将参数“<em class="nk"> lower_is_better </em>”设置为“<em class="nk"> False </em>”，因为我们的问题寻求度量的最大化，而不是最小化。</p><p id="2e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，执行前面的代码片段的结果将类似于:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="2028" class="nr mk it oe b gy oi oj l ok ol">epoch    accuracy    balanced_accuracy    train_loss    valid_acc    <br/>-------  ----------  -------------------  ------------  -----------  <br/>      1      0.9722               0.9762        0.4780       0.9722        <br/>      2      1.0000               1.0000        0.0597       1.0000        <br/>      3      1.0000               1.0000        0.0430       1.0000        <br/>      4      1.0000               1.0000        0.0144       1.0000        <br/>      5      1.0000               1.0000        0.0110       1.0000        <br/>      6      1.0000               1.0000        0.0083       1.0000        <br/>      7      1.0000               1.0000        0.0067       1.0000        <br/>      8      1.0000               1.0000        0.0058       1.0000        <br/>      9      1.0000               1.0000        0.0047       1.0000        <br/>     10      1.0000               1.0000        0.0039       1.0000        </span></pre><p id="c1c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将看到如何使用scikit-learn模块执行网格搜索，让我们开始吧！</p><h2 id="1ee3" class="nr mk it bd ml ns nt dn mp nu nv dp mt li nw nx mv lm ny nz mx lq oa ob mz oc bi translated">4.GridSearch:管道+定标器+培训+回调</h2><p id="9c80" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">要执行<em class="nk">网格搜索</em>，我们只需导入scikit-learn模块。执行<em class="nk">网格搜索</em>与从<strong class="lb iu"> scikit-learn </strong>中学习机器的经典模型完全相同，唯一的不同点在于网格参数的定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段5。网格搜索定义</p></figure><p id="f00e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，参数有一个特殊的方面。我们正在添加前缀“<em class="nk"> nn__ </em>”和“<em class="nk"> nn__module__ </em>”。这些前缀将帮助包装器知道参数是属于PyTorch模型的定义还是属于训练阶段。正如我们所看到的，当我们提到训练阶段的参数时，我们只使用前缀“<em class="nk"> nn__ </em>”，当我们提到PyTorch模型的参数时，我们只使用前缀“<em class="nk">nn __【模块_ _】”。重要的是名称“<em class="nk"> nn </em>”指的是包装器的实例化(第19行)。</em></p><p id="2b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们想知道最佳参数是什么，我们可以很容易地做到:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="21b3" class="nr mk it oe b gy oi oj l ok ol">[1] print(gs.best_params_)<br/>{'nn__lr': 0.1, 'nn__max_epochs': 10, 'nn__module__dropout': 0.1, 'nn__module__num_units': 10, 'nn__optimizer': &lt;class 'torch.optim.adam.Adam'&gt;}</span></pre><blockquote class="nh ni nj"><p id="6e6f" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated">如果你想访问完整的实现，看一看:<a class="ae ky" href="https://github.com/FernandoLpz/SKORCH-PyTorch-Wrapper" rel="noopener ugc nofollow" target="_blank">https://github.com/FernandoLpz/SKORCH-PyTorch-Wrapper</a></p></blockquote><h1 id="62a0" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="31bb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这篇博客中，我们已经看到了什么是SKORCH及其组成部分。我们还看到了如何实现NeuralNetClassifier包装器，以非常简单的方式训练PyTorch模型。</p><p id="c6da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，斯科奇会留下来。有时需要快速灵活地构建PyTorch模型的原型，SKORCH在这方面做得非常好。</p><h1 id="f997" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考</h1><p id="d4bf" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">[1]<a class="ae ky" href="https://skorch.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">https://skorch.readthedocs.io/en/latest/index.html</a></p><p id="aa30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=Qbu_DCBjVEk" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Qbu_DCBjVEk</a></p></div></div>    
</body>
</html>