<html>
<head>
<title>7 Fundamental SQL Concepts To Master Before Your Next Coding Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一次编码面试前要掌握的7个基本SQL概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-fundamental-sql-concepts-you-will-be-challenged-with-in-faang-interviews-d26097a8d867?source=collection_archive---------8-----------------------#2020-10-21">https://towardsdatascience.com/7-fundamental-sql-concepts-you-will-be-challenged-with-in-faang-interviews-d26097a8d867?source=collection_archive---------8-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8991" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/programming" rel="noopener" target="_blank">编程</a> | <a class="ae ep" href="https://towardsdatascience.com/tagged/interviewing" rel="noopener" target="_blank">面试</a> | <a class="ae ep" href="https://towardsdatascience.com/tagged/office-hours" rel="noopener" target="_blank">办公时间</a></h2><div class=""/><div class=""><h2 id="b8e6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过解决取自真实编码面试的SQL习题来练习，最终得到你应得的工作。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/da0651e09ec0bb296b9652faf22d96fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZJ0392R-eTD9iKr4"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@azhar93?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿兹哈鲁尔·伊斯拉姆</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="0170" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated"><em class="md">我的读者请注意</em></h2><p id="5c82" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated"><em class="mx">你们中的许多人联系我，要求我提供宝贵的资源来</em> <strong class="mg jd"> <em class="mx">练习更高级的SQL概念，以编写面试代码，包括真实的面试问题。</em> </strong> <em class="mx">下面我分享4个我个人推荐的平台/课程:</em></p><ul class=""><li id="f4c7" class="my mz it mg b mh na mk nb lr nc lv nd lz ne mw nf ng nh ni bi translated"><a class="ae lh" href="https://platform.stratascratch.com/coding?via=antonello" rel="noopener ugc nofollow" target="_blank"> <strong class="mg jd"> <em class="mx"> SQL高级编码问题(StrataScratch)</em></strong></a><strong class="mg jd"><em class="mx">→</em></strong><em class="mx">目前为止我找到的准备SQL编码面试的最好平台！比LeetCode更好更便宜。</em></li><li id="2fb2" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><a class="ae lh" href="https://imp.i115008.net/e41vB1" rel="noopener ugc nofollow" target="_blank"> <strong class="mg jd">学习SQL进行大数据分析(纳米程度)</strong> </a> <strong class="mg jd"> → </strong> <em class="mx">优质课程进行更长期的承诺。</em></li><li id="07fc" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><a class="ae lh" href="https://datacamp.pxf.io/a1ezzR" rel="noopener ugc nofollow" target="_blank"> <strong class="mg jd"> <em class="mx"> SQL汇总统计&amp;窗口函数(DataCamp) </em> </strong> </a></li><li id="8190" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><a class="ae lh" href="https://datacamp.pxf.io/7mMVVg" rel="noopener ugc nofollow" target="_blank"><strong class="mg jd"><em class="mx">SQL(Data camp)中操作数据的函数</em> </strong> </a></li></ul><p id="01ad" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated"><strong class="mg jd"><em class="mx">&gt;&gt;&gt;</em></strong><em class="mx">还不是中等成员？考虑与我的</em> <a class="ae lh" href="https://anbento4.medium.com/membership" rel="noopener"> <strong class="mg jd"> <em class="mx">推荐链接</em> </strong> </a> <em class="mx">签约，以获得Medium提供的一切服务，费用低至</em><strong class="mg jd"><em class="mx">【5美元一个月</em> </strong> <em class="mx">！</em></p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="74fe" class="ny lj it bd lk nz oa ob ln oc od oe lq ki of kj lu kl og km ly ko oh kp mc oi bi translated"><strong class="ak">停止低估SQL面试</strong></h1><p id="c23f" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">当面试顶级科技公司的数据科学、数据工程或软件工程职位时，很可能技术环节会包括一个或多个现场代码会话，以测试你对SQL和你选择的编程语言的了解。</p><p id="742c" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">尽管练习用Python或JAVA来解决算法通常是很费力的，而且可能会占用你大量的时间(<em class="mx">,因为几乎有无限多的问题存在！</em>)、<strong class="mg jd">FAANG面试中你要尽量不要低估SQL问题的难度</strong>。</p><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/10-algorithms-to-solve-before-your-python-coding-interview-feb74fb9bc27"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">Python编码面试前要解决的10个算法</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">在这篇文章中，我介绍并分享了FAANG中经常出现的一些基本算法的解决方案</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa lb om"/></div></div></a></div><p id="53fb" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">科技公司的数据库中存储了大量数据，他们希望应聘者能够使用复杂的SQL查询以高效的方式提取和处理数据，然后再进行更高级的分析。由于对这些角色来说，良好的SQL知识几乎是理所当然的，所以面试官通常希望你能出色地解决这些挑战“<em class="mx">”并且不太会提示你或忽略明显的错误。</em></p><p id="2e1c" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">举一个突出的例子，几年前，一名招聘人员联系我，希望在伦敦一家新兴的电子商务公司谋得一个职位，就在编码屏幕前，他打电话问我对解决定时SQL问题有多大信心。我告诉他，作为一名BI开发人员，我每天都使用SQL来编写复杂的查询，因此我对通过测试充满信心。我至今记得他的回答:</p><blockquote class="pb"><p id="db1b" class="pc pd it bd pe pf pg ph pi pj pk mw dk translated"><em class="md">“SQL编码面试可能会变得棘手。你不知道有多少有经验的候选人声称准备好了，然后在这个阶段失败了。”</em></p></blockquote><p id="0736" class="pw-post-body-paragraph me mf it mg b mh pl kd mj mk pm kg mm lr pn mo mp lv po mr ms lz pp mu mv mw im bi translated">就像预言一样，这正是发生在我身上的事情:我通过了Python编码筛选，却没有通过SQL测试。起初，我感到非常羞愧，我一直对自己说:<em class="mx">“我是一名BI开发人员，却没有通过SQL面试……你能相信吗？”</em>。</p><p id="71e0" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">然而，不久之后，我意识到，在解决<em class="mx">边缘案例</em>的技术面试中，很多SQL问题并不罕见，这些问题在日常工作中并不常见，因此需要特别的准备。</p><p id="57e1" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">为了帮助您在下一轮现场编码或带回家的定时SQL测试中评估自己的准备情况，在下一节课中，我将讨论一些<strong class="mg jd">面试练习问题</strong> ( <em class="mx">和解决方案</em>)，涵盖以下7个基本概念:</p><ul class=""><li id="11ea" class="my mz it mg b mh na mk nb lr nc lv nd lz ne mw nf ng nh ni bi translated"><strong class="mg jd"> <em class="mx"> SQL概念#1 : </em> </strong> <em class="mx">使用子查询的高级过滤</em></li><li id="a922" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><strong class="mg jd"> <em class="mx"> SQL概念# 2:</em></strong><em class="mx">HAVING子句的正确使用</em></li><li id="db66" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><strong class="mg jd"> <em class="mx"> SQL概念#3 : </em> </strong> <em class="mx">聚合With CASE WHEN子句</em></li><li id="be1e" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><strong class="mg jd"> <em class="mx"> SQL概念#4 : </em> </strong> <em class="mx">排名函数的正确使用</em></li><li id="f434" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><strong class="mg jd"> <em class="mx"> SQL概念#5 : </em> </strong> <em class="mx">正确使用UNION vs UNION ALL </em></li><li id="dcc6" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><strong class="mg jd"> <em class="mx"> SQL概念#6 : </em> </strong> <em class="mx">处理空值</em></li><li id="4be4" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated"><strong class="mg jd"> <em class="mx"> SQL概念#7 : </em> </strong> <em class="mx">计算累计总和</em></li></ul><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/6-sql-window-functions-coding-problems-on-ranking-interview-countdown-p1-9be0ccf66453"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">排名上的6个SQL窗口函数编码问题——采访倒计时P1</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">SQL面试即将来临，您正在寻找一些具有挑战性的练习来测试您的准备情况？你是…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="pq l ox oy oz ov pa lb om"/></div></div></a></div><h1 id="3843" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated"><strong class="ak"> <em class="md"> SQL概念# 1:高级过滤</em>T43】</strong></h1><p id="e0dc" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated"><em class="mx">编写一个SQL查询来报告购买了产品“A”、“B”但没有购买产品“C”的客户的</em> <code class="fe pw px py pz b"><em class="mx">customer_id</em></code> <em class="mx">和</em> <code class="fe pw px py pz b"><em class="mx">customer_name</em></code> <em class="mx">，因为我们想推荐他们购买该产品。返回结果表按</em> <code class="fe pw px py pz b"><em class="mx">customer_id</em></code> <em class="mx">排序。</em></p><pre class="ks kt ku kv gt qa pz qb qc aw qd bi"><span id="0fbd" class="li lj it pz b gy qe qf l qg qh">CUSTOMERS table:<br/>+-------------+---------------+<br/>| customer_id | customer_name |<br/>+-------------+---------------+<br/>| 1           | Daniel        |<br/>| 2           | Diana         |<br/>| 3           | Elizabeth     |<br/>| 4           | Jhon          |<br/>+-------------+---------------+</span><span id="9642" class="li lj it pz b gy qi qf l qg qh">ORDERS TABLE table:<br/>+----------+-------------+--------------+<br/>| order_id | customer_id | product_name |<br/>+----------+-------------+--------------+<br/>| 10       |     1       |     A        |<br/>| 20       |     1       |     B        |<br/>| 30       |     1       |     D        |<br/>| 40       |     1       |     C        |<br/>| 50       |     2       |     A        |<br/>| 60       |     3       |     A        |<br/>| 70       |     3       |     B        |<br/>| 80       |     3       |     D        |<br/>| 90       |     4       |     C        |<br/>+----------+-------------+--------------+</span><span id="84aa" class="li lj it pz b gy qi qf l qg qh">Expected OUTPUT Structure:<br/>|Customer_id | Customer_Name</span></pre><h1 id="d09b" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">解决方案:</h1><p id="519f" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">注意这个查询有多紧凑:它通过利用<code class="fe pw px py pz b">WHERE()</code>子句中的子查询只选择购买了产品A和B而没有购买c的客户，避免了使用多个cte(<em class="mx">节省了现场编码会话</em>中的大量输入工作。在过滤时，请记住，如果子查询返回多个值，您可以使用<code class="fe pw px py pz b">IN()</code>或<code class="fe pw px py pz b">NOT IN()</code>运算符来检查成员资格。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qk l"/></div></figure><h1 id="9335" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">SQL概念# 2:HAVING子句的正确使用</h1><p id="889e" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">编写一个SQL查询，报告拥有最多员工的所有项目。</p><pre class="ks kt ku kv gt qa pz qb qc aw qd bi"><span id="964e" class="li lj it pz b gy qe qf l qg qh">PROJECT table:<br/>+-------------+-------------+<br/>| project_id  | employee_id |<br/>+-------------+-------------+<br/>| 1           | 1           |<br/>| 1           | 2           |<br/>| 1           | 3           |<br/>| 2           | 1           |<br/>| 2           | 4           |<br/>+-------------+-------------+</span><span id="b5e7" class="li lj it pz b gy qi qf l qg qh">EMPLOYEE table:<br/>+-------------+--------+------------------+<br/>| employee_id | name   | experience_years |<br/>+-------------+--------+------------------+<br/>| 1           | Khaled | 3                |<br/>| 2           | Ali    | 2                |<br/>| 3           | John   | 1                |<br/>| 4           | Doe    | 2                |<br/>+-------------+--------+------------------+</span><span id="dba1" class="li lj it pz b gy qi qf l qg qh">Expected OUTPUT Structure:<br/>|project_id|</span></pre><h1 id="fcc4" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">解决方案:</h1><p id="e109" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">问题基本上是要求返回涉及<em class="mx">最多</em>名员工的项目。为了实现这一目标:</p><ul class=""><li id="02ac" class="my mz it mg b mh na mk nb lr nc lv nd lz ne mw nf ng nh ni bi translated">首先创建一个子查询，以便在按<code class="fe pw px py pz b">project_id</code>分组时只检索最大数量的雇员(<code class="fe pw px py pz b">LIMIT 1</code>)，</li><li id="68fe" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated">然后结合使用<code class="fe pw px py pz b">HAVING()</code>子句和<code class="fe pw px py pz b">COUNT(DISTINCT)</code>函数来过滤主查询，以便只选择在子查询中找到的雇员数量最多的项目。</li></ul><p id="548a" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">如您所见，当涉及某种聚合时，<code class="fe pw px py pz b">HAVING()</code>应该用于过滤数据集(<em class="mx">准备好解释</em> <code class="fe pw px py pz b">HAVING()</code>和<code class="fe pw px py pz b">WHERE()</code> <em class="mx">之间的区别，因为这是一个非常受欢迎的问题，特别是对于入口角色</em>)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qk l"/></div></figure><h1 id="8dc6" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">SQL概念# 3:聚合时的情况</h1><p id="efda" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated"><em class="mx">编写一个SQL查询来重新格式化表格，这样每个月都有一个</em> <code class="fe pw px py pz b"><em class="mx">department_id </em></code> <em class="mx">列和一个</em> <code class="fe pw px py pz b"><em class="mx">revenue</em></code> <em class="mx">列。结果表应该有13列(1列表示部门id + 12列表示月份)。</em></p><pre class="ks kt ku kv gt qa pz qb qc aw qd bi"><span id="e1b9" class="li lj it pz b gy qe qf l qg qh">DEPARTMENT table:<br/>+------+---------+-------+<br/>| id   | revenue | month |<br/>+------+---------+-------+<br/>| 1    | 8000    | Jan   |<br/>| 2    | 9000    | Jan   |<br/>| 3    | 10000   | Feb   |<br/>| 1    | 7000    | Feb   |<br/>| 1    | 6000    | Mar   |<br/>+------+---------+-------+</span><span id="4df2" class="li lj it pz b gy qi qf l qg qh">Expected OUTPUT Structure:<br/>|id | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... |</span></pre><h2 id="5e77" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">解决方案:</h2><p id="11d2" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">在某些情况下，面试官希望测试你处理数据的能力，例如，会要求你通过水平扩展来取消旋转表格。对于这个问题，我们的目标是去掉<code class="fe pw px py pz b">month</code>维度，创建与月数一样多的事实列。这可以很容易地通过使用一个<code class="fe pw px py pz b">CASE WHEN()</code>子句来识别特定的月份并生成新的聚合列来实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qk l"/></div></figure><h1 id="25cb" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">SQL概念# 4:排名函数的使用</h1><p id="6290" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated"><em class="mx">编写一个SQL查询，为每个客户返回第二早的</em> <code class="fe pw px py pz b"><em class="mx">order_id</em></code> <em class="mx">，每个日期他们至少下了两个订单。</em></p><pre class="ks kt ku kv gt qa pz qb qc aw qd bi"><span id="8ecd" class="li lj it pz b gy qe qf l qg qh">Extract from ORDERS table<br/>+------------+--------------+----------------------+------------ +<br/>| order_id   | customer_id  |    order_datetime    |   item_id   |<br/>+------------+--------------+----------------------+-------------+<br/>| C-001      |    62456     | 2018-12-15 09:15:22  |    A000     | <br/>| C-005      |    21376     | 2019-01-14 09:28:35  |    A001     | <br/>| C-005      |    88956     | 2019-01-14 09:28:35  |    A005     |<br/>| C-006      |    42491     | 2019-01-14 03:53:08  |    A008     |<br/>+------------+--------------+----------------------+-------------+</span><span id="79a5" class="li lj it pz b gy qi qf l qg qh">Expected Output Structure:<br/>Customer_id | Order_date | Second_order_id</span></pre><h2 id="4e30" class="li lj it bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc iz bi translated">解决方案:</h2><p id="96b1" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">涉及使用排名函数(<em class="mx">和一般窗口函数</em>)的问题在SQL技术回合中极为常见。例如，在这种情况下，<code class="fe pw px py pz b">RANK() OVER()</code>函数用于通过<code class="fe pw px py pz b">customer_id</code>和<code class="fe pw px py pz b">order_date</code>对分区中的每个订单进行排序。注意分区是如何使用<code class="fe pw px py pz b">order_date</code>的，而等级是通过<code class="fe pw px py pz b">order_datetime</code>以升序排列的。这样，第一个订单将得到<code class="fe pw px py pz b">order_rank = 1</code>，第二个最早的订单将得到<code class="fe pw px py pz b">order_rank = 2</code>。然后使用<code class="fe pw px py pz b">WHERE order_rank = 2</code>子句只保留第二早的订单。上面的过滤器会自动排除客户下少于两个订单的日期，因此无需添加任何其他内容。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qk l"/></div></figure><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/8-popular-sql-window-functions-replicated-in-python-e17e6b34d5d7"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jd gy z fp or fr fs os fu fw jc bi translated">Python中复制的8个流行的SQL窗口函数</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">关于如何利用业务分析中的Pandas高效复制最常用的SQL窗口的教程…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="ql l ox oy oz ov pa lb om"/></div></div></a></div><h1 id="e50d" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">SQL概念5:UNION与UNION ALL的使用</h1><p id="7321" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated"><em class="mx">写一条SQL，求出2019–08–16所有产品的价格，假设修改前所有产品价格都是10。</em></p><pre class="ks kt ku kv gt qa pz qb qc aw qd bi"><span id="0fff" class="li lj it pz b gy qe qf l qg qh"># PRODUCTS table:<br/>+------------+-----------+-------------+<br/>| product_id | new_price | change_date |<br/>+------------+-----------+-------------+<br/>| 1          | 20        | 2019-08-14  |<br/>| 2          | 50        | 2019-08-14  |<br/>| 1          | 30        | 2019-08-15  |<br/>| 1          | 35        | 2019-08-16  |<br/>| 2          | 65        | 2019-08-17  |<br/>| 3          | 20        | 2019-08-18  |<br/>+------------+-----------+-------------+</span><span id="d5e2" class="li lj it pz b gy qi qf l qg qh">Expected Output Structure:<br/>product_id | price</span></pre><h1 id="5c46" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">解决方案:</h1><p id="501f" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">这个问题有点挑战性:它要求您识别每个<code class="fe pw px py pz b">product_id</code>在<em class="mx">2019–08–16</em>的最近价格变化。如果某个产品的价格仅在该日期后发生变化，您应该假设<em class="mx">2019–08–16</em>的价格为10。为此，您可以应用上述问题中介绍的两个概念:</p><ul class=""><li id="f701" class="my mz it mg b mh na mk nb lr nc lv nd lz ne mw nf ng nh ni bi translated">首先，您可以使用<code class="fe pw px py pz b">DENSE RANK()</code>函数来查找每种产品在<em class="mx">2019–08–16的最新价格变化。</em> <code class="fe pw px py pz b">DENSE_RANK()</code>函数在分区中分配连续的等级，因此没有出现平局然后重复的风险。<em class="mx">该数据集不包括在阈值日期后发生价格变化的产品。</em></li><li id="b93e" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated">然后，您可以创建第二个数据集，包括2019年8月16日之后发生最早价格变化的所有产品，并将它们的价格设置为10。为了实现这一点，请注意带有<code class="fe pw px py pz b">MIN()</code>函数的<code class="fe pw px py pz b">HAVING()</code>子句的使用。</li><li id="281a" class="my mz it mg b mh nj mk nk lr nl lv nm lz nn mw nf ng nh ni bi translated">最后一步是用<code class="fe pw px py pz b">UNION ALL</code>连接两个数据集，这样所有的<code class="fe pw px py pz b">product_id</code>都会出现在解决方案中。</li></ul><p id="3609" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">如果被问到，请记住<code class="fe pw px py pz b">UNION ALL</code>比<code class="fe pw px py pz b">UNION</code>更有效、更快，原因是第一个操作符不会检查重复值。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qk l"/></div></figure><h1 id="9404" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">SQL概念# 6:处理空值</h1><p id="f6eb" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated"><em class="mx">编写一个SQL查询，查找在过去7天内每个类别订购了多少台。考虑总共七个日历日期，包括今天。还要考虑所有品类，甚至是零订单的品类。</em></p><pre class="ks kt ku kv gt qa pz qb qc aw qd bi"><span id="bcb6" class="li lj it pz b gy qe qf l qg qh">Extract from ORDERS table:<br/>+------------+----------------------+------------------------------+<br/>| order_id   | order_datetime       |   item_id   | order_quantity |<br/>+------------+----------------------+------------------------------+<br/>| C-001      | 2018-12-15 09:15:22  |    A000     |       5        |<br/>| C-005      | 2019-01-14 09:28:35  |    A001     |       1        |<br/>| C-005      | 2019-01-14 09:28:35  |    A005     |       1        |<br/>| C-006      | 2019-01-14 03:53:08  |    A008     |       3        |<br/>+------------+--------------+---------------------+----------------+</span><span id="ded4" class="li lj it pz b gy qi qf l qg qh">Extract from ITEMS table:<br/>+-------------+---------------+<br/>| item_id     | item_category |<br/>+-------------+---------------+<br/>| A000        | Outdoors      |<br/>| A001        | Outdoors      |<br/>| A002        | Outdoors      |<br/>| A003        | Kitchen       |<br/>| A004        | Kitchen       |<br/>+-------------+---------------+</span><span id="9f64" class="li lj it pz b gy qi qf l qg qh">Expected Output Structure:<br/>Category | Units</span></pre><h1 id="fafd" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">解决方案:</h1><p id="8027" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">这个问题需要找到每个类别的<em class="mx">和每个</em>类别的<em class="mx">的总单位数，这意味着在这种情况下<code class="fe pw px py pz b">items</code>表应该被用作前导表，并与<code class="fe pw px py pz b">orders</code>保持连接，以保留所有的<code class="fe pw px py pz b">item_category</code>值，甚至是那些与从未订购的项目相关联的值。一般来说，当你在真实的面试问题中读到单词<em class="mx"> "each" </em>和<em class="mx"> "every" </em>时，你可能需要对连接和一些空值采取一些行动，这些需要在过滤器中处理(<code class="fe pw px py pz b">OR o.item_id IS NULL</code>)</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qk l"/></div></figure><h1 id="deff" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">SQL概念# 7:计算累积和</h1><p id="8bc9" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated"><em class="mx">编写一个SQL语句来获得一个雇员三个月的工资总额，但不包括最近一个月。结果应该按“Id”升序显示，然后按“Month”降序显示。</em></p><pre class="ks kt ku kv gt qa pz qb qc aw qd bi"><span id="8822" class="li lj it pz b gy qe qf l qg qh">EMPLOYEE table:</span><span id="b1c3" class="li lj it pz b gy qi qf l qg qh">| Id | Month | Salary |<br/>|----|-------|--------|<br/>| 1  | 1     | 20     |<br/>| 2  | 1     | 20     |<br/>| 1  | 2     | 30     |<br/>| 2  | 2     | 30     |<br/>| 3  | 2     | 40     |<br/>| 1  | 3     | 40     |<br/>| 3  | 3     | 60     |<br/>| 1  | 4     | 60     |<br/>| 3  | 4     | 70     |<br/>+---------------------+</span><span id="474f" class="li lj it pz b gy qi qf l qg qh">Expected Output Structure:<br/>id | month | salary</span></pre><p id="7d7a" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">在SQL技术访谈中，被要求计算累计总和是一个非常经典的问题，因此对于这个问题，我提供了两个潜在的解决方案。</p><h1 id="d770" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">解决方案1:</h1><p id="658e" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">在这种情况下，<code class="fe pw px py pz b">ROW_NUMBER()</code>函数用于识别和排除支付给每个雇员的最后一笔工资。一旦排除了最后一笔工资，就会对前三行进行累计求和(<code class="fe pw px py pz b">SUM() OVER()</code>)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qk l"/></div></figure><h1 id="d69a" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated">解决方案2:</h1><p id="cf9f" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">在这个备选解决方案中，不是使用窗口函数来对月工资进行排序，而是通过编写一个查找并排除每个雇员最近一个月(<code class="fe pw px py pz b">MAX(month)</code>)工资支付(<code class="fe pw px py pz b">WHERE e1.id = e2.id</code>)的子查询来过滤掉最后一笔工资。然后，与解决方案1完全一样地计算累积和。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qj qk l"/></div></figure><h1 id="ea37" class="ny lj it bd lk nz pr ob ln oc ps oe lq ki pt kj lu kl pu km ly ko pv kp mc oi bi translated"><strong class="ak">结论</strong></h1><p id="63bd" class="pw-post-body-paragraph me mf it mg b mh mi kd mj mk ml kg mm lr mn mo mp lv mq mr ms lz mt mu mv mw im bi translated">在这篇文章中，我提出了7个基本的SQL概念，您应该在下一次FAANGs技术面试之前掌握它们。我希望你在下一个SQL编码屏幕或定时测试中使用上面的问题进行练习。</p><p id="b219" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">涉及日期转换的解决方案使用PostgreSQL作为语法(<em class="mx">以节省一点打字……</em>)，但可以很容易地转换成MySQL。我的解决方案也只是每个问题的潜在解决方案之一，所以请在评论中分享你的解决方案。请注意，本文中出现的所有SQL问题都摘自<a class="ae lh" href="https://leetcode.com/problemset/all/" rel="noopener ugc nofollow" target="_blank"><em class="mx">leet code</em></a><em class="mx">，其中混合了官方问题和订户在讨论区</em>中直接报告的问题。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="ebb4" class="pw-post-body-paragraph me mf it mg b mh na kd mj mk nb kg mm lr no mo mp lv np mr ms lz nq mu mv mw im bi translated">给我的读者一个提示:这篇文章包含了附属链接，如果你购买的话，我可以免费给你一点佣金。</p></div></div>    
</body>
</html>