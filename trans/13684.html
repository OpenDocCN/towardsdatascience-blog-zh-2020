<html>
<head>
<title>Dog breed classification using Deep Learning concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习概念的狗品种分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dog-breed-classification-using-deep-learning-concepts-23213d67936c?source=collection_archive---------11-----------------------#2020-09-20">https://towardsdatascience.com/dog-breed-classification-using-deep-learning-concepts-23213d67936c?source=collection_archive---------11-----------------------#2020-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="953d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开发狗识别应用程序的想法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/cb1787ffcd1c67705fc0629a2e6b66d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*3oMd9wRxALzUI_b0cE8j5w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">衍生作品:<a class="ae ku" href="https://commons.wikimedia.org/wiki/User:Djmirko" rel="noopener ugc nofollow" target="_blank"> Djmirko </a> ( <a class="ae ku" href="https://lizenzhinweisgenerator.de/wiki/User_talk:Djmirko" rel="noopener ugc nofollow" target="_blank"> talk </a>)，<a class="ae ku" href="https://commons.wikimedia.org/wiki/File:YellowLabradorLooking_new.jpg" rel="noopener ugc nofollow" target="_blank">黄拉拉新</a>，神经迁移学习，<a class="ae ku" href="https://creativecommons.org/licenses/by-sa/3.0/legalcode" rel="noopener ugc nofollow" target="_blank"> CC BY-SA 3.0 </a></p></figure><p id="6389" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">这篇博文是</em> <a class="ae ku" href="https://www.udacity.com/course/data-scientist-nanodegree--nd025" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Udacity数据科学家纳米学位计划</em> </a> <em class="lr">的一部分。</em></p><h2 id="6ff6" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">简介</strong></h2><p id="ceba" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">世界犬类组织(<a class="ae ku" href="http://www.fci.be/en/" rel="noopener ugc nofollow" target="_blank"> FCI </a>)目前列出了300多种官方认可的犬种。几千年来，人类已经成功创造了令人印象深刻的犬类表型多样性，以及它们忠实的四条腿朋友的一系列几乎不可思议的身体和行为特征。然而，除了犬学学者、养狗者和一些久经考验的爱狗人士之外，当被要求说出一只随机出现的狗的品种时，至少当它不是最受欢迎和最知名的品种如腊肠狗、德国牧羊犬或哈巴狗的代表时，大多数人都只是耸耸肩，表示无能为力。如果你是为数不多的觉得不能像犬类学家一样识别狗有点尴尬的人之一，你可能很高兴知道可能有一个技术解决方案。因为谢天谢地，深度学习和人工神经网络这一令人惊叹的领域为解决这种分类任务提供了强大的概念和方法。</p><p id="7b39" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这个项目中，我们将使用深度学习概念开发狗识别应用程序的想法。该软件旨在接受任何用户提供的图像作为输入。如果在图像中检测到狗，它将提供狗的品种的估计。如果检测到人类，它将提供一个最相似的狗品种的估计。</p><p id="6e97" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们的项目包括以下步骤，这些步骤将在这篇博文的后续部分详细介绍。</p><ul class=""><li id="e5e2" class="mq mr it kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated"><strong class="kx iu">第0步:导入数据集</strong></li><li id="8d29" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><strong class="kx iu">第一步:探测人类</strong></li><li id="9304" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><strong class="kx iu">第二步:检测狗</strong></li><li id="41f1" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><strong class="kx iu">第三步:创建一个CNN对狗的品种进行分类(从头开始)</strong></li><li id="4846" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><strong class="kx iu">第四步:使用CNN对狗的品种进行分类(使用迁移学习)</strong></li><li id="cb60" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><strong class="kx iu">第五步:创建一个CNN对狗的品种进行分类(使用迁移学习)</strong></li><li id="5412" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><strong class="kx iu">第六步:编写你的算法</strong></li><li id="b909" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated"><strong class="kx iu">第七步:测试你的算法</strong></li></ul><h2 id="8df7" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">第0步:导入数据集</strong></h2><p id="6bee" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">显然，为了能够建立一个旨在识别狗的算法，我们需要一些“狗数据”。很多。值得庆幸的是，为了这个项目，Udacity提供了相当数量的狗图片，包括相应的品种标签。具体地，图像数据包括8351幅狗图像和133个单独的狗品种名称。</p><p id="2f64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由于该应用程序有一个额外的任务，将最相似的狗品种分配给给定的人脸，我们还需要一个人脸数据集。Udacity提供的数据集包括来自野生数据集中<a class="ae ku" href="http://vis-www.cs.umass.edu/lfw/" rel="noopener ugc nofollow" target="_blank">标记的人脸的13233张图像。</a></p><h2 id="9d41" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">第一步:检测人类</strong></h2><p id="597c" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">这似乎是狗识别应用程序开发中有点令人惊讶的一步，但它的额外工作是将最相似的狗品种分配给给定的人脸。</p><p id="74d3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了检测图像中的人脸，我们将使用OpenCV实现的<a class="ae ku" href="http://docs.opencv.org/trunk/d7/d8b/tutorial_py_face_detection.html" rel="noopener ugc nofollow" target="_blank">基于Haar特征的级联分类器</a>。该分类器的方法基于<a class="ae ku" href="https://en.wikipedia.org/wiki/Haar-like_feature" rel="noopener ugc nofollow" target="_blank"> Haar-like features </a>的概念，由于其令人信服的计算速度而广泛应用于对象识别领域。</p><p id="28e8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在实例化新的预训练分类器之后，图像被加载并转换成灰度。将分类器应用到图像中，我们得到了检测到的人脸的边界框。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">使用OpenCV的级联分类器检测人脸的代码</p></figure><p id="f041" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下是本项目中使用的野生数据集中的<a class="ae ku" href="http://vis-www.cs.umass.edu/lfw/" rel="noopener ugc nofollow" target="_blank">标记人脸在通过我们的级联分类器后的几个例子:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/e9c1b6b5d458bf444a2c7ffd3903fa9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*id7FAsrDPio4GBOcnViQ6w.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:野生标签脸，<a class="ae ku" href="http://vis-www.cs.umass.edu/lfw/" rel="noopener ugc nofollow" target="_blank">http://vis-www.cs.umass.edu/lfw/</a></p></figure><p id="81ab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">评估人类探测器</p><p id="a933" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们来看看分类器如何处理来自我们数据集的图片。我们将该算法应用于我们的100幅狗图像，并好奇探索其中分类器有趣地识别了人类内容的12幅图片。我们有点失望，因为在所描绘的狗的脸上几乎找不到任何奇怪和不可思议的人类特征，这些特征可能骗过了我们的算法</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/26cfa745b34b7aa12eeea18fb1b23acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZynmWl73Ha2BGWOevISZA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:Udacity提供的狗狗图片数据集</p></figure><p id="37ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">相反，在我们的评估中使用的100个人类图片样本中，分类器在以下两个样本中遗漏了人脸:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3df9b0a8088bae14d5d656a1743ee1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*2UGQ6QdDn8RIrsdcKt15qQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:野外贴标签的脸，<a class="ae ku" href="http://vis-www.cs.umass.edu/lfw/" rel="noopener ugc nofollow" target="_blank">http://vis-www.cs.umass.edu/lfw/</a></p></figure><p id="ef77" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">尽管如此，我们的分类器似乎足够可靠，可以在我们的项目中尝试一下。</p><h2 id="51f8" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">第二步:探测狗</h2><p id="6dc2" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">现在我们有了一个相当不错的算法来检测图像中的人脸，我们当然希望为狗的检测建立一个类似的功能。不幸的是，目前OpenCV的级联分类器没有类似的“狗检测器”。因此，我们选择了另一种方法，采用一种在<a class="ae ku" href="http://www.image-net.org/" rel="noopener ugc nofollow" target="_blank"> ImageNet </a>的庞大图像数据库上预先训练好的图像分类模型。更具体地说，我们将使用高级深度学习API <a class="ae ku" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>来加载ResNet-50卷积神经网络，并通过该模型运行图像。对于一个特定的图像，网络预测总共1000个图像类别中每一个的概率。如果模型将最大概率分配给118个与狗相关的类别中的一个，我们将肯定的狗检测归因于图像。</p><p id="9637" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面的源代码列出了用于预处理图像数据并通过ResNet-50模型运行它们的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ef75" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">评估狗检测器</strong></p><p id="a96d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">ResNet-50狗检测器在我们的图像数据集上表现如何？我们将用下面的源代码对此进行测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="dfa9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们用我们的狗图像获得了令人信服的100%准确性，但Frank Solich可能会担心唯一的狗，在人类图像数据集中发现的最具开创性的深度学习网络模型之一，在他的肖像中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/55aaef0a269c572858d2ead101b67969.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*2jpnLhJeO3wnE-GCgxu2aA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">弗兰克·索利希，图片来源:野生的标签脸，<a class="ae ku" href="http://vis-www.cs.umass.edu/lfw/" rel="noopener ugc nofollow" target="_blank">http://vis-www.cs.umass.edu/lfw/</a></p></figure><h2 id="5374" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">第三步:创建一个CNN来分类狗的品种(从头开始)</h2><p id="ff1a" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">现在，我们将进入真正有趣的部分，解决应用程序的主要任务的实现，从狗的图像中辨别正确的狗品种标签。我们可以使事情变得简单，只需使用第二步中预先训练好的模型，并预测ImageNet数据集类别中定义的狗品种标签。当然，构建我们自己的解决方案更令人兴奋、有趣，也更有教育意义，所以让我们开始吧！在我们开始构建自己的分类器之前，先简单介绍一下卷积神经网络。</p><p id="5cfd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">卷积神经网络(CNN)是一类主要用于图像分析的深度神经网络。在一定程度上，卷积网络的设计受到了哺乳动物大脑处理视觉印象的方式的启发。平移不变性和共享权重最常被引用来解释CNN在图像分析中相对于使用其他类型的神经网络的优势。卷积网络的体系结构涉及使用多个隐藏层，这些隐藏层对其输入执行数学卷积运算。</p><p id="585a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第一次尝试</strong></p><p id="672b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Udacity提供了一个CNN结构的典型示例，它建议在本步骤中使用以下模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nn"><img src="../Images/2629f8843c950e703f82906662627cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXNn5PpNlIAuL-AOAgSUQw.png"/></div></div></figure><p id="1806" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，我们有一个输入层，图像数据馈入其中，在完全连接的“密集”层产生输出之前，共有三对卷积层和池层。卷积层由一组具有一定高度和宽度的滤波器组成，而汇集层的任务是降低输入的维数。通常，每个卷积层中的滤波器数量增加，而处理数据的维数减少。因为模型的性能通常随着深度的增加而增加，所以我们在Udacity提出的模型中增加了两个额外的阶段。</p><p id="c840" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用Keras库创建模型的源代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="21a9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在产生一个输出之前，我们插入一个额外的脱落层，它随机地去激活一些神经元。丢弃层的使用是防止训练数据过度拟合的常用正则化方法。</p><p id="1b61" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，我们的第一个模型如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi no"><img src="../Images/a2883360935414952b3ec89526d90b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*tmvCKagaBT3GfXeW6pLCOQ.jpeg"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">CNN从零开始(与<a class="ae ku" href="https://github.com/lutzroeder/netron" rel="noopener ugc nofollow" target="_blank"> Netron </a>一起策划)</p></figure><p id="7e42" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，让我们通过网络运行我们的训练集30次来训练我们的模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="376c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们来看看我们的训练在每个时期取得的进步:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/bded981b71efbfa47c59abf5b233961c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_IXJkBF4ALuKK0TAOBt9A.png"/></div></div></figure><p id="c7ca" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以看到准确性几乎呈线性增长，在训练结束时，我们的训练集获得了大约23 %的过度拟合效果，这意味着我们的验证集的准确性明显落后，但不是那么多。我们用测试数据进行的额外测试给出了16.5 %的准确度。</p><p id="962f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">还不错，但是对于一个严肃的应用程序来说肯定不够准确，所以让我们看看我们是否能做得更好。</p><p id="e670" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第二次尝试使用AlexNet </strong></p><p id="de4f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在我们要用CNN模特界的一个真正经典来再试一次。<a class="ae ku" href="https://en.wikipedia.org/wiki/AlexNet" rel="noopener ugc nofollow" target="_blank"> AlexNet </a>是一个CNN模型，它在2012年ImageNet大规模视觉识别挑战赛中远远超过了竞争对手，并引入了一些开创性的新概念，如ReLU激活功能和使用脱落层来防止过度拟合。该模型的一般结构如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/94227acdf729c183d2cabd0011995be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*vFkR3gS8O1rMYLhVrDjE9A.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">AlexNet(用<a class="ae ku" href="https://github.com/lutzroeder/netron" rel="noopener ugc nofollow" target="_blank"> Netron </a>绘制)</p></figure><p id="707f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们用Keras库实现一个AlexNet模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cad3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">与第一次尝试一样，我们通过网络运行我们的训练数据30次，并取得了以下进展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/b3c7b121a9e613c73d1c9e80e224a25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8naGoIuVt6jBc82GkPQzTw.png"/></div></div></figure><p id="1dd1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">所以，哇，训练集的准确性确实在接近尾声时超过了我们第一次尝试的结果，但是，天哪，验证曲线发生了什么？？？我们显然是在处理一个过度拟合的问题。</p><p id="05e3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">第三次尝试。通过数据扩充解决过度拟合问题</strong></p><p id="fd58" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">除了使用dropout层，我们可以使用另一种流行的方法来控制我们的问题。数据扩充是一种通过应用随机变换(如图像旋转、图像移动、改变图像亮度和图像翻转)来增加训练集多样性的技术。所以让我们在下一次尝试中试试这个方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f63f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">好了，现在让我们检查一下进度历史:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/5d54796fbd66f27ccd19f262f1592cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zhzPx30CKbr6vHL7Nq5Xg.png"/></div></div></figure><p id="b28d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">是的，现在看起来好多了，即使避免过拟合问题显然是以牺牲精度水平为代价的，所以我们的测试数据集只达到了10.9 %。但是如果我们比较我们第一次和第三次尝试的两个图的轨迹，AlexNet似乎有一个更陡峭的曲线，并且可能很快在其他时期超过我们第一次尝试的模型。</p><p id="d5e5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但总的来说，使用CNN模型的方法，即我们从头开始构建的方法，似乎非常复杂、乏味且耗时，这需要很大的耐心和大量的计算能力。所以，下一步我们来看看更好的方法。</p><h2 id="14e8" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">第四步:使用CNN对狗的品种进行分类(使用迁移学习)</strong></h2><p id="63c6" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">迁移学习背后的一般思想是这样一个事实，即向一个已经掌握特定领域基础知识的学科教授专业技能要容易得多。有很多神经网络模型已经专门研究图像识别，并在大量数据的基础上进行训练。我们现在的策略是利用这种预先训练好的网络，我们的计划可以概括如下:</p><ul class=""><li id="0765" class="mq mr it kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">找到为一般图像分类任务预先训练的网络模型</li><li id="b0db" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">用预训练的权重加载模型</li><li id="1949" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">删除“模型的顶部”，即具有完全连接的层的部分，因为模型的特定任务通常由网络的这一部分来定义</li><li id="2bb1" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">通过预训练模型的卷积部分运行新数据。(这也被称为<em class="lr">特征提取</em>并且该步骤的输出也被称为<em class="lr">瓶颈特征</em>。)</li><li id="4585" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">创建一个新的网络来定义手头的特定任务，并用上一步的输出(瓶颈特性<em class="lr">)来训练它。</em></li></ul><p id="0fc2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如我们马上会看到的，我们用来填充瓶颈特性的模型结构通常非常简单，因为大部分训练工作已经由预训练模型完成了。在这个项目的第4步中，Udacity为这一策略提供了某种蓝图，它已经将我们的图像数据集输入到预训练的VGG16模型(另一个用于图像分类的CNN模型领域的经典模型)中，并使输出作为瓶颈特征可用，我们现在可以将其输入到一个非常简单的训练网络中，该网络基本上只包含一个全局平均池层和一个最终的密集输出层。</p><p id="d5b3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面的源代码加载瓶颈特性，为我们的特定分类任务定义顶层，并用瓶颈特性训练这些新层:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cf97" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同样，让我们来看看进度历史:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nr"><img src="../Images/dc2085bc3f0cccb1ad7dd1d2f981dec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*56GMU9ZDSEmNTP2UfmOejQ.png"/></div></div></figure><p id="ce17" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">除了快速的训练速度之外，我们还观察到在准确性方面的显著表现，并在我们的测试数据中实现了大约75 %的准确性，尽管这是以明显的过拟合问题为代价的。</p><h2 id="7aed" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">第五步:创建一个CNN对狗的品种进行分类(使用迁移学习)</strong></h2><p id="b416" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">我们现在将步骤4作为模板，使用迁移学习定义我们自己的CNN。我们选择<a class="ae ku" href="https://keras.io/api/applications/inceptionv3/" rel="noopener ugc nofollow" target="_blank"> InceptionV3 </a>作为应该为我们的训练层提供特性的网络。Inception是ImageNet数据集上的另一个高性能模型，它的强大之处在于，通过引入称为<em class="lr"> inception模块</em>的子网，该网络可以设计得比其他模型更深入。</p><p id="f03a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">源代码看起来与步骤4中的代码非常相似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a5b2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了防止我们在步骤4中观察到的过拟合问题，我们插入了一个额外的丢弃层，并在输出层之前添加了批量归一化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nr"><img src="../Images/462462950bad059059e1f1394cd2b54c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bO4NvokN1dVpdLRbikh4vw.png"/></div></div></figure><p id="0c35" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如我们从进度历史中看到的，我们仍然有一些过度拟合的问题，但是我们也注意到精度的另一个提高。我们的测试数据达到了83 %的准确率。</p><p id="7b8f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了使我们的模型更好，我们可以考虑以下选项:</p><ul class=""><li id="03d1" class="mq mr it kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">使用数据扩充来防止过度拟合</li><li id="1e4b" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">向我们的简单训练模型添加层</li><li id="1834" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">获取更多培训数据</li></ul><p id="3739" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是现在，我们对最近一次尝试的结果非常满意，并在接下来的步骤中将它们用于我们将要编写和测试的算法中。</p><h2 id="93ad" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">第六步:编写你的算法</h2><p id="58fc" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">因此，现在让我们收集前面步骤中的成果和发现，并编写一个算法，该算法获取一张狗或人的图像，并吐出一个狗品种以及该特定品种的4个样本图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="b2de" class="ls lt it bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated"><strong class="ak">第七步:测试你的算法</strong></h2><p id="bf15" class="pw-post-body-paragraph kv kw it kx b ky ml ju la lb mm jx ld le mn lg lh li mo lk ll lm mp lo lp lq im bi translated">最后，让我们用一些测试图像来测试我们的算法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ns"><img src="../Images/a90ce30c827486c5b09e9fb6a5108443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5eni7aHe_fbtDsKf9qliwA.jpeg"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">杜宾犬图片来源:由Udacity提供的狗图片数据集</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/fd51212b4f3a65e6dfa506f60a51afea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnVsmFBQyjJnxthjUJErZQ.jpeg"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">牧羊犬，图片来源:由Udacity提供的狗狗图片数据集</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nu"><img src="../Images/6144b3932dacfcf4cbc70b8d23b6e016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zG3odK8-UISSage8aUfdkg.jpeg"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:Udacity提供的狗狗图片数据集</p></figure><p id="6404" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">结论</strong></p><p id="197b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这个项目中，我们开发了几种方法来开发识别狗品种的应用程序，并且我们通过应用迁移学习模型取得了最好的结果。我们在测试中获得了83%的准确率。我们还学习了如何从零开始构建卷积网络，这是一项非常有教育意义的任务，尽管我们很快意识到还有更有前途的方法，特别是应用迁移学习。</p><p id="229f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然而，我们仍然看到未来进一步改进我们算法的几种选择:</p><ul class=""><li id="3e65" class="mq mr it kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">我们可以收集更多的训练数据。</li><li id="8787" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">我们可以使用数据扩充来防止过度拟合。</li><li id="cfe6" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">我们可以添加更多的层，使我们的模型更复杂，希望更强大。</li><li id="d067" class="mq mr it kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">我们可以延长我们的训练时间，给训练增加更多的纪元。</li></ul><p id="ce0a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但总而言之，我们测试的准确性水平，以及对特定样本图像的测试，表明我们已经有了一个可以在真实应用程序中使用的严肃模型。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="3c2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个项目的源代码是在一个Jupyter笔记本上用Python编写的，并利用了流行的深度学习库<a class="ae ku" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>和<a class="ae ku" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>。可以在对应的<a class="ae ku" href="https://github.com/normannexo/dog-project" rel="noopener ugc nofollow" target="_blank"> github库</a>中找到。</p><p id="71a5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Udacity在这个<a class="ae ku" href="https://github.com/udacity/dog-project" rel="noopener ugc nofollow" target="_blank">库</a>中提供了一些源代码。</p></div></div>    
</body>
</html>