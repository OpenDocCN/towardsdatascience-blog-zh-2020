<html>
<head>
<title>Riot API: a machine learning and data analysis application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Riot API:一个机器学习和数据分析应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/riot-api-a-machine-learning-and-data-analysis-application-c8524b4160b4?source=collection_archive---------15-----------------------#2020-10-17">https://towardsdatascience.com/riot-api-a-machine-learning-and-data-analysis-application-c8524b4160b4?source=collection_archive---------15-----------------------#2020-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f742" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="8eb1" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一个简单的基于python的教程，通过Riot API进行数据分析和机器学习，以提高个人水平</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/853ce5004f77d069013379f1dc297bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gWExr1tx8qniswFA"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lh" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure><h1 id="1788" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">为什么要看这篇文章？</h1><p id="56c3" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">一个简单的基于python的教程，通过Riot API进行数据分析和机器学习，以提高个人水平。</p><p id="0068" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果你正在阅读这篇文章，你可能是《英雄联盟》的粉丝，这是一款流行的MOBA类型的在线游戏(多人在线竞技场)。或者你可能对机器学习和数据分析在网络游戏世界中的可能应用感兴趣。这款游戏由Riot Games开发发布。</p><p id="6696" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">全世界有数百万玩家，这款游戏拥有广泛的业余玩家和职业玩家。它利用了游戏的不断进化和统计复杂性。这个游戏的基本原理(非常)简单。由于有成千上万的变量和可能的场景，每场比赛都是不同的。</p><p id="87b3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">给定大量的数据，提取重要的数据可以让你获得关于你的比赛风格的有趣信息。你可以提取有用的信息来改善你的游戏风格或预测你未来的表现。</p><p id="ca06" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">许多网站如op.gg提供了大量的数据、分析和图表。这很好，但是如果您想要开发定制的或者更复杂的模型，您将需要一些手工工作。</p><p id="d6c7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><a class="ae lh" href="https://developer.riotgames.com/" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd">Riot</strong>Games<strong class="mc jd">API</strong></a>是一个REST <strong class="mc jd"> API </strong>为开发者构建自己的应用或网站提供有用的数据。</p><p id="2bfb" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我建议您在开始编程之前阅读文档，以避免违反服务的法律条款。您还可以避免数据请求速率的问题。</p><p id="b2b1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在接下来的部分中，我们将了解如何:</p><ul class=""><li id="4837" class="nb nc it mc b md mw mg mx mj nd mn ne mr nf mv ng nh ni nj bi translated">从Riot API中提取有用的数据</li><li id="6f50" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">处理数据以获得有用的信息</li><li id="6df5" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">创建简单的预测模型</li></ul><h1 id="5557" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">从Riot API中提取有用的数据</h1><p id="6498" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">让我们从安装和导入一些基本库开始。如果您使用的是Google协作笔记本，您将不会遇到任何问题，否则，您将需要根据您的操作系统安装单独的库。</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="17b9" class="nu lj it nq b gy nv nw l nx ny">!pip3 install riotwatcher</span><span id="77bd" class="nu lj it nq b gy nz nw l nx ny">!pip install -q seaborn</span><span id="734e" class="nu lj it nq b gy nz nw l nx ny">!pip install -q git+https://github.com/tensorflow/docs</span><span id="88c1" class="nu lj it nq b gy nz nw l nx ny">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pathlib<br/>import pandas as pd<br/>import seaborn as sns<br/>import tensorflow as tf<br/>import time<br/>from tensorflow import keras<br/>from tensorflow.keras import layers<br/>import tensorflow_docs as tfdocs<br/>import tensorflow_docs.plots<br/>import tensorflow_docs.modeling<br/>from riotwatcher import LolWatcher, ApiError</span></pre><p id="04e2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了提取数据，我们使用了<a class="ae lh" href="https://github.com/pseudonym117/Riot-Watcher" rel="noopener ugc nofollow" target="_blank"> RiotWatcher </a>，它是一个薄薄的包装器，位于英雄联盟的<a class="ae lh" href="https://developer.riotgames.com/" rel="noopener ugc nofollow" target="_blank"> Riot Games API之上。必须使用Riot API密钥，每24小时生成一次。请记住，此密钥是个人的，不应共享。让我们从提取一个玩家(或者召唤师)的一些信息开始:让我们得到想要的玩家的等级</a></p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="f10d" class="nu lj it nq b gy nv nw l nx ny">lol_watcher = LolWatcher('%YOUR RIOT API KEY%')<br/>my_region = 'euw1'<br/>me = lol_watcher.summoner.by_name(my_region, '%YOUR SUMMONER NAME%')<br/>my_ranked_stats = lol_watcher.league.by_summoner(my_region, me['id'])</span><span id="c934" class="nu lj it nq b gy nz nw l nx ny">print(my_ranked_stats)</span></pre><p id="92c7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">让我们提取一个更新版本的冠军，物品，召唤师法术和任何其他所需的属性，因此我们的比赛历史:</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="a6e4" class="nu lj it nq b gy nv nw l nx ny">versions = lol_watcher.data_dragon.versions_for_region(my_region)<br/>champions_version = versions['n']['champion']<br/>summoner_spells_version=versions['n']['summoner']<br/>items_version=versions['n']['item']<br/>( ... )<br/>current_champ_list = lol_watcher.data_dragon.champions(champions_version)<br/>( ... )<br/>my_matches = lol_watcher.match.matchlist_by_account(my_region, me['accountId'])</span></pre><p id="545d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们拥有大量的数据，这些数据的重要性是高度主观的。更多的功能将导致更复杂，但更准确的模型。为了获得真正准确的分析，有必要获得尽可能多的游戏信息，以更好地适应我们的模型，并使结果更可信。让我们从过去的100场比赛中提取数据，并定义一系列包含所有主要信息的熊猫数据帧。</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="dec0" class="nu lj it nq b gy nv nw l nx ny">n_games = 100</span><span id="f144" class="nu lj it nq b gy nz nw l nx ny">Games = {}<br/>Game_duration=np.zeros(n_games)<br/>Damage = np.zeros(n_games)<br/>(...)<br/>j=0<br/>cont=0<br/>while cont&lt;n_games:<br/> try:<br/>  last_match = my_matches['matches'][cont]<br/>  match_detail = lol_watcher.match.by_id(my_region,      last_match['gameId'])<br/>  participants = []<br/>  for row in match_detail['participants']:<br/>   participants_row = {}<br/>   participants_row['champion'] = row['championId']<br/>   participants_row['win'] = row['stats']['win']<br/>   participants_row['assists'] = row['stats']['assists']<br/>   ( ... )<br/>   participants.append(participants_row)<br/>  Games[j] = pd.DataFrame(participants)</span><span id="f964" class="nu lj it nq b gy nz nw l nx ny">  champ_dict = {}<br/>  for key in static_champ_list['data']: <br/>  row = static_champ_list['data'][key] <br/>  champ_dict[row['key']] = row['id']</span><span id="6339" class="nu lj it nq b gy nz nw l nx ny">  summoners_dict = {}<br/>  for key in static_summoners_list['data']:<br/>   row = static_summoners_list['data'][key]<br/>   summoners_dict[row['key']] = row['id']</span><span id="9223" class="nu lj it nq b gy nz nw l nx ny">  Summoner_name = []<br/>  for row in match_detail['participantIdentities']:<br/>   Summoner_name_row = {}<br/>   Summoner_name_row=row['player']['summonerName']<br/>   Summoner_name.append(Summoner_name_row)</span><span id="5da0" class="nu lj it nq b gy nz nw l nx ny">  i=0</span><span id="97b2" class="nu lj it nq b gy nz nw l nx ny">for row in participants:<br/>   row['championName'] = champ_dict[str(row['champion'])]<br/>   row['Summoner_name']=Summoner_name[i]<br/>   row['Summoner Spell 1']=summoners_dict[str(row['spell1'])]<br/>   row['Summoner Spell 2']=summoners_dict[str(row['spell2'])]<br/>   i+=1<br/>  <br/>  Games[j]= pd.DataFrame(participants)<br/>  for index, row in Games[j].iterrows():<br/>    if row['Summoner_name']=='%YOUR SUMMONER NAME%':<br/>      Damage[j]=row['totalDamageDealt']<br/>      Gold[j]=row['goldEarned']<br/>      ( ... ) </span><span id="e868" class="nu lj it nq b gy nz nw l nx ny">  time.sleep(10)<br/>  j+=1<br/>  cont+=1<br/> except:<br/>  cont+=1</span></pre><p id="485f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">至此，我们已经提取了所有感兴趣的数据:让我们继续进行数据分析。警告:在每个循环中插入了10秒钟的暂停，以不超过Riot API允许的每小时请求的最大数量。</p><h2 id="8ff9" class="nu lj it bd lk oa ob dn lo oc od dp ls mj oe of lu mn og oh lw mr oi oj ly iz bi translated">数据处理</h2><p id="1638" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在这一点上，我们拥有大量的数据，显然并不重要:要获得有用的信息，你需要将你在“游戏属性”方面的兴趣与数据分析和机器学习的现代算法结合起来，能够给出有效的答案。数据可以给出很多关于游戏中表现的答案，有可能发现优势/劣势，甚至根据你的现场游戏统计数据预测获胜的概率！为了便于理解，在下面的段落中给出了对一组简化的参数进行的一些简单分析作为例子，但是您可以很容易地生成更复杂和有趣的模型。我们可以从准备一个可以有效用于数据分析的数据库开始:让我们看看我们游戏的一些简单特性:</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="8a1b" class="nu lj it nq b gy nv nw l nx ny">dataset={}<br/>dataset['Total Damage']=Damage<br/>dataset['Gold']=Gold<br/>( ... )<br/>dataset['Victory']=Victory #Boolean</span></pre><p id="190e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">无论我们的目标是解决回归问题(连续输出系统)还是分类问题(离散输出系统)，都有必要将起始数据集分成两个独立的数据集:</p><ul class=""><li id="9b66" class="nb nc it mc b md mw mg mx mj nd mn ne mr nf mv ng nh ni nj bi translated">训练集:该数据集用于模型(即神经网络)的训练。在训练集上具有良好的预测性能是重要的，但同时，避免过拟合现象也是必要的。</li><li id="af5f" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">测试集:在训练迭代过程中用于模型验证的集</li></ul><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="59dd" class="nu lj it nq b gy nv nw l nx ny">train_dataset_raw = dataset.sample(frac=0.8,random_state=0)<br/>test_dataset_raw = dataset.drop(train_dataset_raw.index)<br/>train_dataset=train_dataset_raw.iloc[:,range(0,4)]<br/>test_dataset=test_dataset_raw.iloc[:,range(0,4)]<br/>train_labels=train_dataset_raw.iloc[:,4]<br/>test_labels=test_dataset_raw.iloc[:,4]</span></pre><p id="ca58" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">配对图</strong></p><p id="a68c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><a class="ae lh" href="https://pythonbasics.org/seaborn-pairplot/#:~:text=A%20pairplot%20plot%20a%20pairwise,Matplotlib%20Examples%20and%20Video%20Course" rel="noopener ugc nofollow" target="_blank">pair plot绘制数据集中的成对关系。Pairplot函数创建一个轴网格，这样数据中的每个变量将在y轴的一行中共享，在x轴的一列中共享。</a></p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="7486" class="nu lj it nq b gy nv nw l nx ny">sns.pairplot(train_dataset_raw, diag_kind="kde")</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/2b89ca5500f72c7d7b8eadfcabf408dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtJsclJkwgF9ayQ5e3hzvQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="53e4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为什么要分析这样一个图？因为它允许您快速获得有关所选数据之间各自关系的定性信息。例如，我们可能会注意到，所拥有的黄金总量的增加会导致更大的总伤害，这是获胜次数和游戏参数之间的关系，也是各自领域中个体数量的概率分布。</p><p id="73f4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">互相关矩阵</strong></p><p id="c477" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对于数据间相关性的更定性分析，可以参考相关矩阵。<a class="ae lh" href="https://www.vertica.com/blog/in-database-machine-learning-2-calculate-a-correlation-matrix-a-data-exploration-post/" rel="noopener ugc nofollow" target="_blank">计算相关值</a>有几种方法。最流行的是<a class="ae lh" href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient" rel="noopener ugc nofollow" target="_blank"> <em class="ol">皮尔逊相关系数</em> </a>。然而，应该注意的是，它只测量两个变量之间的线性关系。换句话说，它可能无法揭示非线性关系。皮尔逊相关值的范围从-1到+1，其中+/-1表示完全正/负相关，0表示不相关。相关矩阵是对称矩阵，所有对角元素等于+1”</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="a660" class="nu lj it nq b gy nv nw l nx ny">corr = dataset.corr()<br/>mask = np.triu(np.ones_like(corr, dtype=bool))<br/>f, ax = plt.subplots(figsize=(11, 9))<br/>cmap = sns.diverging_palette(230, 20, as_cmap=True)<br/>sb.heatmap(corr, mask=mask, cmap=cmap, vmax=0.9, center=0, vmin=-0.2,<br/>square=True, linewidths=.5, cbar_kws={"shrink": .5}, annot = True)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/955dca97527700360050c3a12e77c579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*81MpQRabUrMpfC9boSSuIw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="ad8d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">知道这个问题的人可能会意识到，比如说，附身黄金的伤害增加或者死亡和胜利之间的反向趋势是正确的，即使看起来微不足道。然而，用简单的语句对这些模型进行验证，可以更准确地应用于更复杂的数据集。</p><p id="b9d9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">胜利概率的估计:一个简单的分类问题</strong></p><p id="b7ab" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">首先，让我们将数据标准化:</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="7322" class="nu lj it nq b gy nv nw l nx ny">def norm(x):<br/>return (x - train_stats['mean']) / train_stats['std']<br/>normed_train_data = norm(train_dataset)<br/>normed_test_data = norm(test_dataset)</span></pre><p id="8ab5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Keras和TensorFlow库提供的强大工具有助于模型生成。让我们为我们的分类定义一个简单的序列模型，它具有以下属性:</p><ul class=""><li id="f4bb" class="nb nc it mc b md mw mg mx mj nd mn ne mr nf mv ng nh ni nj bi translated">型号:顺序</li><li id="f786" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">输入层:4节点层</li><li id="10aa" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">2隐藏层:activation = ' relu节点数= 16/32</li><li id="a2df" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">2个下降层:0.2</li><li id="cf26" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">输出层:activation = ' sigmoid节点数= 1；</li><li id="6566" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">模型属性:loss='binary_crossentropy '，optimizer='adam '，metrics=['accuracy']</li></ul><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="6add" class="nu lj it nq b gy nv nw l nx ny">dumbo=(normed_test_data,test_labels)<br/>model = Sequential()<br/>epochs=700<br/>model.add(Dense(16, input_dim=4, activation='relu'))<br/>layers.Dropout(0.2)<br/>model.add(Dense(32, activation='relu'))<br/>layers.Dropout(0.2)<br/>model.add(Dense(1, activation='sigmoid'))<br/>model.compile(loss='binary_crossentropy', optimizer='adam',metrics ['accuracy'])<br/>history = model.fit(normed_train_data, train_labels, epochs=epochs,validation_data=dumbo)</span></pre><p id="8c06" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，我们在整个测试数据集上评估模型预测的质量:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/72e1fa0336841be3cbef77b447e6b92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*s4BnOHLyBpriR-68wxJjyQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="3801" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">定性地说，我们可以注意到在训练集和验证集上都有非常好的表现(与所研究案例的简单性相关)。从数量上我们得到:</p><ul class=""><li id="426a" class="nb nc it mc b md mw mg mx mj nd mn ne mr nf mv ng nh ni nj bi translated">测试损失:0.4501 —测试精度:0.9583</li><li id="bfc7" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">列车损失:0.0891-列车精度:0.9688</li></ul><p id="8d9f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">从图形上看，我们得到:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2c5030c5f78e739dd26f30d27acd2185.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*lRPyNxnTJf_F5ssuXkpW8Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="366d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd"> <em class="ol">我们根据选择的游戏参数，有97%的准确率正确预测游戏结果！</em> </strong>显然，预测的质量将取决于所选择的特征、模型的质量等等。</p><p id="861a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">结论</strong></p><p id="9fd1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们已经看到了riot API的一个简单应用，我们开发了一系列工具来分析我们在游戏中的技能。我们还预测了我们未来的表现！这是开发代码、应用程序等的起点。利用英雄联盟游戏中产生的大量数据。</p><p id="a7ab" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="ol">感谢阅读</em></p></div></div>    
</body>
</html>