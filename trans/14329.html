<html>
<head>
<title>MNIST in the browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览器中的MNIST</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mnist-in-the-browser-f03cc4f055a1?source=collection_archive---------53-----------------------#2020-10-02">https://towardsdatascience.com/mnist-in-the-browser-f03cc4f055a1?source=collection_archive---------53-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/347c54b52f8ef2c4a991bf012cbb1f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*6j5c79W1KU5DK3wPHN1bRQ.png"/></div></figure><div class=""/><div class=""><h2 id="02f2" class="pw-subtitle-paragraph ju iw ix bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">将复杂的人工智能模型部署到浏览器(以及更远的地方)非常容易。</h2></div><p id="43ca" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">多年来，在实践中使用人工智能模型一直是一个挑战。是的，确实存在许多很好的例子，但根据我们的经验，大多数公司首先面临的挑战是整合数据，然后是构建和验证有用的模型，最后是将这些模型部署到最需要的地方(无论是内部、云中还是边缘)。</p><p id="50d5" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">然而，在过去几年中，这些挑战变得越来越容易。它们中没有一个是微不足道的，但是这个过程的每一步都有大量的工具。甚至在浏览器中部署相对复杂的<a class="ae li" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a>也变得相当简单:让我来分享一下如何实现。</p><h1 id="be50" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">1.训练模型:手写数字识别</h1><p id="6f02" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">为了演示CNN在浏览器中的部署，我们选择了一个CNN经常擅长的简单任务:图像识别。为了便于演示，我们将重点放在众所周知的<a class="ae li" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST </a>数据集上。<a class="ae li" href="https://github.com/Microsoft/CNTK/blob/master/Tutorials/CNTK_103D_MNIST_ConvolutionalNeuralNetwork.ipynb" rel="noopener ugc nofollow" target="_blank">本教程</a>展示了如何使用<a class="ae li" href="https://docs.microsoft.com/en-us/cognitive-toolkit/" rel="noopener ugc nofollow" target="_blank">微软的认知工具包</a>来训练一个具有相当令人印象深刻的性能的模型。然而，你并不真的需要自己训练模型；在<a class="ae li" href="https://github.com/onnx/models" rel="noopener ugc nofollow" target="_blank"> ONNX模型动物园</a>可以直接下载<a class="ae li" href="https://github.com/onnx/models/tree/master/vision/classification/mnist" rel="noopener ugc nofollow" target="_blank">ONNX格式的</a>。</p><blockquote class="mg"><p id="2696" class="mh mi ix bd mj mk ml mm mn mo mp lh dk translated">ONNX是一种开放格式，用于表示机器学习模型。这是存储使用不同工具(pyTorch、tensorflow、sklearn等)创建的训练模型(包括预处理和后处理)的一种非常统一的方式。).</p></blockquote><h1 id="098c" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd mq ke lv kg mr kh lx kj ms kk lz ma bi translated">2.模型转换:易于部署的WebAssembly。</h1><p id="847f" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">既然我们已经有了一个经过训练的数字识别模型，我们想在浏览器中直接使用它。这样做的一个选择是使用<a class="ae li" href="https://github.com/microsoft/onnxjs" rel="noopener ugc nofollow" target="_blank"> javascript ONNX运行时(ONNX.js) </a>。然而，我们更喜欢首先将ONNX转换成一个<a class="ae li" href="https://webassembly.org" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>可执行文件(。WASM)部署前。</p><p id="91fa" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">虽然ONNX.js(以及其他边缘设备可用的ONNX运行时)可能看起来更容易，但由于跳过了向WebAssembly的传输步骤，ONNX运行时通常比WASM运行时大得多，执行起来也更慢(参见<a class="ae li" href="https://wasmer.io" rel="noopener ugc nofollow" target="_blank"> Wasmer </a>收集)。我们建议感兴趣的读者<a class="ae li" href="https://medium.com/@maurits.kaptein/object-recognition-on-the-edge-fc8aaaeb2c53" rel="noopener">参考这篇文章</a>，了解ONNX.js和WebAssembly运行时比较的更多细节。在任何情况下，根据我们的经验，目前可用的(各种)ONNX运行时在实际(边缘)生产环境中比简单、独立的WebAssembly二进制文件更难维护和管理。</p><p id="45be" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><a class="ae li" href="https://www.scailable.net" rel="noopener ugc nofollow" target="_blank">scascalable</a>提供了(大部分)ONNX到。不到一美元的WASM(前100次转换是免费的)。描述转换过程的详细教程可以在<a class="ae li" href="https://github.com/scailable/sclbl-tutorials/tree/master/sclbl-pytorch-onnx" rel="noopener ugc nofollow" target="_blank">这里找到</a>。实际上，它就像上传。ONNX文件到web窗体。</p><blockquote class="mt mu mv"><p id="e354" class="km kn mw ko b kp kq jy kr ks kt kb ku mx kw kx ky my la lb lc mz le lf lg lh ij bi translated">Scailable目前支持ONNX 1.3到。WASM；对ONNX 1.7(包括IR 5和OPS 13)的支持即将到来。</p></blockquote><p id="2db7" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">转换之后，我们得到了一个非常小的(472 Kb) <a class="ae li" href="https://cdn.sclbl.net:8000/task/be269568-dbf7-11ea-b0d0-9600004e79cc.wasm" rel="noopener ugc nofollow" target="_blank">。WASM可执行的</a>可以用来进行数字识别。</p><h1 id="879a" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">3.浏览器中的模型部署(带后备)。</h1><p id="d14e" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">在转换到WebAssembly之后，CNN的实际部署是小菜一碟。大多数浏览器支持运行现成的WebAssembly <em class="mw">和由。这里描述了由Scailable创建的WASM<a class="ae li" href="https://github.com/scailable/sclbl-tutorials/blob/master/sclbl-create-your-own-wasm/README.md" rel="noopener ugc nofollow" target="_blank">。因此，如果您熟悉javascript，自己编写<code class="fe na nb nc nd b">I/O </code>相对容易。然而，使用</a><a class="ae li" href="https://github.com/scailable/sclbl-webnode" rel="noopener ugc nofollow" target="_blank"> Scailable-Webnode </a>可能更容易；最低限度。将运行的WASM运行时。WASMs由Scailable尽可能在浏览器中创建，如果浏览器不支持WebAssembly，则在云中创建。</em></p><p id="f26a" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">将所有这些放在一起，我们得到了以下实现:</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ne"><img src="../Images/b43836f9bd97a46d356b7059c6b23ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRQG3Gt_6YXdwWZCd49eKA.png"/></div></div></figure><p id="f1a0" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">实现出人意料地精简和快速，并且模型的性能不相上下。<a class="ae li" href="https://www.scailable.net/demo/mnist/" rel="noopener ugc nofollow" target="_blank">你可以在这里尝试一下</a>(显然，查看该页面的源代码，看看UX是如何完成的)。</p><h1 id="3109" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">包裹</h1><p id="a047" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated">像ONNX这样的中间表示，以及像WebAssembly这样有效、快速和可移植的编译目标，正在缓慢但肯定地改变我们在各种目标上部署AI的方式。这太棒了。对我们来说，上述过程很有吸引力，原因有很多:</p><ul class=""><li id="6e37" class="nn no ix ko b kp kq ks kt kv np kz nq ld nr lh ns nt nu nv bi translated"><strong class="ko iy">性能:</strong> WebAssembly速度超快，运行在一个微小的容器中。在计算预测和最小内存占用时，它提供了接近本机的性能。</li><li id="030b" class="nn no ix ko b kp nw ks nx kv ny kz nz ld oa lh ns nt nu nv bi translated"><strong class="ko iy">可移植性:</strong> ONNX允许从几乎任何现代数据分析工具中存储<em class="mw">任何</em>模型(包括预处理和后处理管道)，并且随后WebAssembly二进制文件可以在任何地方有效地运行。</li><li id="52d5" class="nn no ix ko b kp nw ks nx kv ny kz nz ld oa lh ns nt nu nv bi translated"><strong class="ko iy">隐私:</strong>我们经常在隐私敏感的情况下部署模型；在这些情况下，我们希望模型的输入数据保留在本地(例如，在医院)。我们不是四处发送敏感数据，而是四处发送模型。</li><li id="a74f" class="nn no ix ko b kp nw ks nx kv ny kz nz ld oa lh ns nt nu nv bi translated"><strong class="ko iy">治理:</strong>与ONNX运行时(或用于创建模型推理的docker容器)相比，它的巨大优势在于它是独立的。WASM二进制文件很容易进行版本控制和检查。我们可以保证模型预测的有效性，而不必担心它的周围环境(python版本、库等)。).</li></ul><p id="5dd2" class="pw-post-body-paragraph km kn ix ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">希望这个小教程(以及其中的参考资料)对其他人入门有用！</p><h1 id="bc4c" class="lj lk ix bd ll lm ln lo lp lq lr ls lt kd lu ke lv kg lw kh lx kj ly kk lz ma bi translated">放弃</h1><p id="3a18" class="pw-post-body-paragraph km kn ix ko b kp mb jy kr ks mc kb ku kv md kx ky kz me lb lc ld mf lf lg lh ij bi translated"><em class="mw">值得一提的是我自己的参与:我是Jheronimus数据科学院的数据科学教授，也是Scailable的联合创始人之一。因此，毫无疑问，我对Scailable有既得利益；我有兴趣让它成长，这样我们就可以最终将人工智能投入生产并兑现它的承诺。这里表达的观点是我自己的。</em></p></div></div>    
</body>
</html>