<html>
<head>
<title>How to create a list of files, folders, and subfolders and then export as Excel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建文件、文件夹和子文件夹的列表，然后导出为Excel</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-a-list-of-files-folders-and-subfolders-and-then-export-as-excel-6ce9eaa3867a?source=collection_archive---------26-----------------------#2020-10-26">https://towardsdatascience.com/how-to-create-a-list-of-files-folders-and-subfolders-and-then-export-as-excel-6ce9eaa3867a?source=collection_archive---------26-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7cf0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个生产力工具玛丽近藤你的文件夹</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e057c34cb98366715005448295550e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOJT00vdM2g4EWaXI2lYqw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@pranavmadhu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pranav Madhu </a>在<a class="ae kv" href="https://unsplash.com/s/photos/file-list?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kw kx ky"><p id="e6b5" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你能为我们的项目文件夹创建一个文件、文件夹和子文件夹的列表吗？</p></blockquote><p id="160c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这个请求看起来似乎很简单，但是你已经可以想象一旦这个列表的第一个版本完成，可能会出现的其他修改。</p><blockquote class="kw kx ky"><p id="2a4f" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你还能列出文件类型并给文件添加超链接吗？或许还可以增加文件的大小？</p></blockquote><p id="cbb8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">根据文件夹的大小、文件数量及其嵌套程度，您可以选择手动完成此任务，因为添加新字段可能很简单。现在，让我们考虑另一个请求:</p><blockquote class="kw kx ky"><p id="f29c" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我重新整理了一些文件夹，重命名了一些文件，你能更新一下列表吗？</p></blockquote><p id="15ab" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">别担心，蟒蛇来救你了！</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="fc20" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mg mh mi mj b">os.walk()</code>是主函数，我们将使用它来创建一个脚本来遍历主文件夹并列出所有子文件夹和文件。python文档的链接是<a class="ae kv" href="https://docs.python.org/3.8/library/os.html#os.walk" rel="noopener ugc nofollow" target="_blank">这里是</a>。下面是代码的主要部分:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="10ad" class="mo mp iq mj b gy mq mr l ms mt">df = pd.DataFrame(columns=['File','File Type',<br/>                           'Folder Location','Link', 'Path'])</span><span id="a243" class="mo mp iq mj b gy mu mr l ms mt">for root, dir, files in os.walk(path):<br/>    files = [f for f in files if not f.startswith('~') and f!='Thumbs.db']<br/>    paths = [os.path.join(root, f) for f in files]<br/>    exts = [os.path.splitext(f)[1][1:] for f in files]<br/>    filetypes = [ext_desc(ext) for ext in exts]<br/>    file_links = ['=HYPERLINK("{}","link")'.format(p) if len(p) &lt; 256 else '' for p in paths]<br/>    folders = [os.path.dirname(p) for p in paths]<br/>    df1 = pd.DataFrame({'File': files,<br/>                        'File Type': filetypes,<br/>                        'Folder Location': folders,<br/>                        'Link': file_links,<br/>                        'Path': paths})<br/>    df = df.append(df1)</span></pre><p id="1496" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">完整的代码可在故事的结尾。</p><h1 id="94d9" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">代码解释:</h1><h2 id="1de0" class="mo mp iq bd mw nm nn dn na no np dp ne lw nq nr ng lx ns nt ni ly nu nv nk nw bi translated">1.创建一个空的数据框架，其中所需的列按所需的顺序排列:</h2><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="b0ca" class="mo mp iq mj b gy mq mr l ms mt">df = pd.DataFrame(columns=['File','File Type',<br/>                           'Folder Location','Link', 'Path'])</span></pre><h2 id="6707" class="mo mp iq bd mw nm nn dn na no np dp ne lw nq nr ng lx ns nt ni ly nu nv nk nw bi translated">2.启动<code class="fe mg mh mi mj b">for</code>循环:</h2><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="ff01" class="mo mp iq mj b gy mq mr l ms mt">for root, dir, files in os.walk(path):</span></pre><p id="5918" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mg mh mi mj b">path</code>是指我们感兴趣的主文件夹路径。<code class="fe mg mh mi mj b">os.walk</code>返回一个元组<code class="fe mg mh mi mj b">root</code>、<code class="fe mg mh mi mj b">dir</code>和<code class="fe mg mh mi mj b">files</code>。为此我们只需要<code class="fe mg mh mi mj b">root</code>和<code class="fe mg mh mi mj b">files</code>。</p><h2 id="20bb" class="mo mp iq bd mw nm nn dn na no np dp ne lw nq nr ng lx ns nt ni ly nu nv nk nw bi translated">3.用列表理解来构建每个专栏</h2><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="1a71" class="mo mp iq mj b gy mq mr l ms mt"># 'Files' columns<br/>files = [f for f in files if not f.startswith('~') and f!='Thumbs.db']</span></pre><p id="3ffa" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">临时文件以波浪号<code class="fe mg mh mi mj b">~</code>开始，包含这些可能没有意义，因此list comprehension有一个<code class="fe mg mh mi mj b">if</code>条件来排除这样的文件。类似地，<code class="fe mg mh mi mj b">Thumbs.db</code>只是一个缩略图文件，并被明确排除。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="1f5f" class="mo mp iq mj b gy mq mr l ms mt"># 'Path' column<br/>paths = [os.path.join(root, f) for f in files]</span></pre><p id="817c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mg mh mi mj b">paths</code>是指向每个子文件夹中特定文件的路径列表。</p><p id="a097" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">文档推荐使用<code class="fe mg mh mi mj b">os.path.join</code>而不是字符串连接，这里有一个stackoverflow <a class="ae kv" href="https://stackoverflow.com/questions/13944387/why-use-os-path-join-over-string-concatenation" rel="noopener ugc nofollow" target="_blank">回答</a>为什么推荐这样做。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="c984" class="mo mp iq mj b gy mq mr l ms mt"># 'File Type' column<br/>exts = [os.path.splitext(f)[1][1:].lower() for f in files]<br/>filetypes = [ext_desc(ext) for ext in exts]</span></pre><p id="aff0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mg mh mi mj b">exts</code>是通过使用<code class="fe mg mh mi mj b">os.path.splitext()</code>形成的扩展名列表，它返回一个没有扩展名和扩展名<em class="lb">的<em class="lb">文件名元组。</em></em></p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="2187" class="mo mp iq mj b gy mq mr l ms mt">&gt;&gt;&gt; os.path.split('some_filename.pdf')<br/>('some_filename', '.pdf')</span></pre><p id="8e3a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">[编辑]以前，我通过右分裂<code class="fe mg mh mi mj b">rsplit</code>文件名得到扩展名。<code class="fe mg mh mi mj b">exts = [f.rsplit('.',1)[-1].lower() for f in files]</code>这不是一个好的做法。</p><p id="8c72" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mg mh mi mj b">filetypes</code>是文件类型列表，<code class="fe mg mh mi mj b">ext_desc</code>是将每个扩展名映射到适当名称的函数。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="c2fc" class="mo mp iq mj b gy mq mr l ms mt">def ext_desc(ext):<br/>    <br/>    d_ext_desc = {'xlsx':'Microsoft Excel File',<br/>                  'docx':'Microsoft Word Doc'}<br/>    # additional extensions and descriptions can be added to d_ext_desc</span><span id="2b8a" class="mo mp iq mj b gy mu mr l ms mt">    try:<br/>        desc = d_ext_desc[ext]<br/>    except KeyError:<br/>        desc = ''     # Any file extensions not mapped will be empty.<br/>    else:<br/>        pass<br/>    return desc</span></pre><p id="84d8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">添加文件链接的方式略有不同。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="9f6e" class="mo mp iq mj b gy mq mr l ms mt">file_links = ['=HYPERLINK("{}","link")'.format(p) if len(p) &lt; 256 else '' for p in paths]</span></pre><p id="4509" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mg mh mi mj b">=HYPERLINK()</code>是一个Excel公式，在给定链接位置(可以是网页或文件位置)时创建超链接。第二个参数<code class="fe mg mh mi mj b">link</code>是可选的，用于缩短显示的文本。<code class="fe mg mh mi mj b">if</code>条件<code class="fe mg mh mi mj b">len(p)&lt;256</code>是Excel中的一个限制，超过255个字符的链接无效。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="1f46" class="mo mp iq mj b gy mq mr l ms mt"># Folder column<br/>folders = [os.path.dirname(p) for p in paths]</span></pre><p id="4b56" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe mg mh mi mj b">folders</code>是一个文件夹列表，告诉我们每个文件的位置。这是通过使用<code class="fe mg mh mi mj b">os.path.dirname()</code>方法获取路径的目录名获得的。</p><p id="9975" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">[已编辑]之前，我使用<code class="fe mg mh mi mj b">folders = [p.rsplit('\\',1)[0] for path in paths]</code>来获取文件夹。同样，这不是一个好的做法。</p><h2 id="d480" class="mo mp iq bd mw nm nn dn na no np dp ne lw nq nr ng lx ns nt ni ly nu nv nk nw bi translated">4.附加到原始数据帧</h2><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="2c3b" class="mo mp iq mj b gy mq mr l ms mt">df1 = pd.DataFrame({'File': files,<br/>                    'File Type': filetypes,<br/>                    'Folder Location': folders,<br/>                    'Link': file_links,<br/>                    'Path': paths})<br/>df = df.append(df1)</span></pre><p id="e40b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">由于每个列表理解都是一列，剩下的工作就是构建一个数据帧并附加到原始数据帧上。使用<code class="fe mg mh mi mj b">df.to_excel('some_filename.xlsx')</code>可以将最终的数据帧写入Excel</p><h2 id="c3b8" class="mo mp iq bd mw nm nn dn na no np dp ne lw nq nr ng lx ns nt ni ly nu nv nk nw bi translated">5.将其推广以备将来使用</h2><ul class=""><li id="b5ac" class="nx ny iq lc b ld nz lg oa lw ob lx oc ly od lv oe of og oh bi translated">如果文件夹包含大量文件，生成完整的文件索引需要时间，因此当记录数量超过500时，我在<code class="fe mg mh mi mj b">for</code>循环中添加了一个关键字参数。这在添加新列或修改最终输出的外观时特别有用，因为您不会希望遍历成千上万个文件才意识到最后几行代码中存在输入错误。</li><li id="9554" class="nx ny iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">在脚本中修改路径可能会很麻烦，因此我添加了一个<code class="fe mg mh mi mj b">tkinter.filedialog</code>方法，如果没有提供路径，它会提示用户选择文件夹。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure></div></div>    
</body>
</html>