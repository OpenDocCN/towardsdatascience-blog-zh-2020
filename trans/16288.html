<html>
<head>
<title>Bootstrapping vs. Permutation Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自举与置换测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bootstrapping-vs-permutation-testing-a30237795970?source=collection_archive---------6-----------------------#2020-11-10">https://towardsdatascience.com/bootstrapping-vs-permutation-testing-a30237795970?source=collection_archive---------6-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c102" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="13c0" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用Python进行理论和实验比较</h2></div><p id="0cf5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">本文的主要目标是从理论上和实验上比较这两种重采样方法，然后在技术上有余地使用其中一种方法的情况下，就何时应该使用每种方法得出一些结论。促使我写这篇文章的原因是，我认为初学者在这个问题上缺乏免费的清晰指南。在一些学习材料中，我甚至遇到了这样的说法，我们可以使用其中任何一个，而没有任何进一步的解释。</p><p id="475b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">文章的主要章节:<br/> 1。作为对bootstrap】的<strong class="kq ja">介绍，我们将计算置信区间并分析测试一些假设，然后使用bootstrap方法非参数地解决相同的问题。<br/> 2。作为排列测试</strong>(也称为显著性测试)的<strong class="kq ja">介绍，我们将在与第1节相同的数据上使用排列测试来测试假设。<br/> 3。我们将开发一个稍微复杂一点的例子，设计几个假设检验，并且<strong class="kq ja">并排比较每个检验的重复统计的bootstrap分布和permutation分布</strong>。</strong></p><p id="1c55" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们邀请了一些最好的朋友过来:NumPy，SciPy和Matplotlib…熊猫将休息一天，因为我们将使用的数据集相当简单。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ffd9" class="lt lu iq lp b gy lv lw l lx ly">import numpy as np<br/>from scipy import stats<br/>from matplotlib import pyplot as plt</span></pre><h1 id="734f" class="lz lu iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">1.CI计算和HT——通过参数和自举</h1><p id="0b68" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">第一部分，我们将使用2008年美国总统选举的结果，来自宾夕法尼亚州和俄亥俄州的“摇摆州”，具体来说，是给定州每个县投票给民主党的选民的百分比(来源:<a class="ae mv" href="https://www.data.gov/" rel="noopener ugc nofollow" target="_blank">https://www.data.gov/</a>)。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="b795" class="lt lu iq lp b gy lv lw l lx ly">dem_share_PA = [60.08, 40.64, 36.07, 41.21, 31.04, 43.78, 44.08, 46.85, 44.71, 46.15, 63.10, 52.20, 43.18, 40.24, 39.92, 47.87, 37.77, 40.11, 49.85, 48.61, 38.62, 54.25, 34.84, 47.75, 43.82, 55.97, 58.23, 42.97, 42.38, 36.11, 37.53, 42.65, 50.96, 47.43, 56.24, 45.60, 46.39, 35.22, 48.56, 32.97, 57.88, 36.05, 37.72, 50.36, 32.12, 41.55, 54.66, 57.81, 54.58, 32.88, 54.37, 40.45, 47.61, 60.49, 43.11, 27.32, 44.03, 33.56, 37.26, 54.64, 43.12, 25.34, 49.79, 83.56, 40.09, 60.81, 49.81]<br/>dem_share_OH = [56.94, 50.46, 65.99, 45.88, 42.23, 45.26, 57.01, 53.61, 59.10, 61.48, 43.43, 44.69, 54.59, 48.36, 45.89, 48.62, 43.92, 38.23, 28.79, 63.57, 38.07, 40.18, 43.05, 41.56, 42.49, 36.06, 52.76, 46.07, 39.43, 39.26, 47.47, 27.92, 38.01, 45.45, 29.07, 28.94, 51.28, 50.10, 39.84, 36.43, 35.71, 31.47, 47.01, 40.10, 48.76, 31.56, 39.86, 45.31, 35.47, 51.38, 46.33, 48.73, 41.77, 41.32, 48.46, 53.14, 34.01, 54.74, 40.67, 38.96, 46.29, 38.25, 6.80, 31.75, 46.33, 44.90, 33.57, 38.10, 39.67, 40.47, 49.44, 37.62, 36.71, 46.73, 42.20, 53.16, 52.40, 58.36, 68.02, 38.53, 34.58, 69.64, 60.50, 53.53, 36.54, 49.58, 41.97, 38.11]</span></pre><p id="d777" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">对于本节和本说明的下一节，我们将使用相同的数据和相同的统计数据来保持示例的一致性，即PA和OH平均投票百分比之间的差异。</p><h2 id="40fb" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.1样品的EDA</h2><p id="e058" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">让我们看看每个州的平均值、中值、标准差和样本大小，以及直方图:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="92cf" class="lt lu iq lp b gy lv lw l lx ly">print("Mean:\t\t", round(np.mean(dem_share_PA),2))<br/>print("Median:\t\t", round(np.median(dem_share_PA),2))<br/>print("SD:\t\t", round(np.std(dem_share_PA),2))<br/>print("Sample Size:\t", len(dem_share_PA))<br/>plt.hist(dem_share_PA, bins=30, alpha=0.25)<br/>plt.grid()<br/>plt.show()</span></pre><blockquote class="ng nh ni"><p id="17dd" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">平均值:45.48 <br/>中位数:44.03 <br/>标准差:9.73 <br/>样本量:67</p></blockquote><figure class="lk ll lm ln gt no gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/3bd72e74589febd3ee63f0dc05a64d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*XZnB67mUANhOsJQVRh_ulA.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><strong class="bd nv">各县的PA Dem投票百分比</strong>(图片由Gene Mishchenko提供)</p></figure><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="bd35" class="lt lu iq lp b gy lv lw l lx ly">print("Mean:\t\t", round(np.mean(dem_share_OH),2))<br/>print("Median:\t\t", round(np.median(dem_share_OH),2))<br/>print("SD:\t\t", round(np.std(dem_share_OH),2))<br/>print("Sample Size:\t", len(dem_share_OH))<br/>plt.hist(dem_share_OH, bins=30, alpha=0.25)<br/>plt.grid()<br/>plt.show()</span></pre><blockquote class="ng nh ni"><p id="97db" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">平均值:44.32 <br/>中位数:43.68 <br/>标准差:9.84 <br/>样本量:88</p></blockquote><figure class="lk ll lm ln gt no gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/86d29e09ffd1632c32d6dcae80ae9029.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*ENIYCxW12bru5pmjyzCc0A.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><strong class="bd nv">各县的选民投票率(T22)</strong></p></figure><p id="57a1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:</strong>分布看起来并不完全正态，但它们可能足够接近于测试参数(分析)解，并且它们稍微<em class="nj">正偏</em>(平均值大于中间值，尾部在右侧/正侧更长)。</p><h2 id="7e38" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.2置信区间计算</h2><p id="d34f" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">置信度= 90%</p><h2 id="60d8" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated"><strong class="ak"> 1.2.1 CI </strong>通过参数方法计算</h2><p id="5f6a" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">(假设总体呈正态分布)</p><p id="936b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，让我们使用正态样本分布(相应地，α/2在左边，α/2在右边的z分数)来找到下临界值和上临界值(LCV和UCV)。在Python中，这可以通过使用<code class="fe nx ny nz lp b">scipy.stats.norm.ppf()</code>方法来完成，该方法将左侧的<em class="nj"> AUC(即百分位等级)作为输入，并返回与所提供的百分位等级相对应的Z分数。<br/> <strong class="kq ja">注1 </strong>:这是<code class="fe nx ny nz lp b">scipy.stats.norm.cdf()</code>方法的逆方法，采用Z分数并返回相应的百分位等级。这是用于这种分析的两种最常用的Python方法，但是这里的<a class="ae mv" href="https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html" rel="noopener ugc nofollow" target="_blank">是SciPy教程以获得更多信息。<br/> <strong class="kq ja">注2 </strong>:如果我们想使用学生的<em class="nj"> t </em>分布而不是正态分布，我们将使用<code class="fe nx ny nz lp b">scipy.stats.t</code>类及其方法，它将自由度作为一个附加参数。</a></em></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1706" class="lt lu iq lp b gy lv lw l lx ly"># Lower Critical Value<br/>lcv = stats.norm.ppf(0.05)<br/>print("Lower CV:", round(lcv,3))<br/># Upper Critical Value<br/>ucv = stats.norm.ppf(1 - 0.05)<br/>print("Upper CV: ", round(ucv,3))</span></pre><blockquote class="ng nh ni"><p id="e458" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">下CV: -1.645 <br/>上CV: 1.645</p></blockquote><p id="44b4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">太好了！现在我们不需要携带这些愚蠢的查找表… <br/>接下来，我们需要均值差异的标准误差(se)。<br/>公式为:<code class="fe nx ny nz lp b">sqrt(std(sample_1)^2 / len(sample_1) + std(sample_2)^2 / len(sample_2))</code></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9dac" class="lt lu iq lp b gy lv lw l lx ly">se = np.sqrt( np.std(dem_share_PA)**2 / len(dem_share_PA) + np.std(dem_share_OH)**2 / len(dem_share_OH) )<br/>print(round(se,3))</span></pre><blockquote class="ng nh ni"><p id="cc2d" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi">1.585</p></blockquote><p id="f4f3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">最后，我们需要均值的经验差异:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9fb7" class="lt lu iq lp b gy lv lw l lx ly">emp_diff_means = np.mean(dem_share_PA) - np.mean(dem_share_OH)<br/>print(round(emp_diff_means,3))</span></pre><blockquote class="ng nh ni"><p id="04de" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi">1.158</p></blockquote><p id="2441" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在我们准备好分析计算置信区间:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="5b82" class="lt lu iq lp b gy lv lw l lx ly">lower_lim_an = emp_diff_means + lcv * se<br/>upper_lim_an = emp_diff_means + ucv * se<br/>print(round(lower_lim_an,3), 'to', round(upper_lim_an,3))</span></pre><blockquote class="ng nh ni"><p id="2b2c" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">-1.449至3.766</p></blockquote><p id="28c5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:</strong> <br/>我们以90%的信心估计，PA和OH的平均票数之间的真正差异在<code class="fe nx ny nz lp b">-1.449</code>和<code class="fe nx ny nz lp b">3.766</code> <br/>(假设样本近似正态分布)<br/>这一结果通过使用在线CI计算器进行验证，该计算器使用学生的<em class="nj"> t </em>分布，结果与我们的非常接近，但比预期的要宽一些:<code class="fe nx ny nz lp b">(-1.4676, 3.7876)</code></p><h2 id="6875" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.2.2通过Bootstrap方法计算CI</h2><p id="02a5" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">一般来说，Bootstrapping和重采样方法非常强大，因为它们对总体分布做了更少的假设(例如，没有正态约束)，通常不涉及公式，并且计算相对简单。</p><p id="4fa5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">关于自举的一些理论:</strong></p><ul class=""><li id="d357" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">首先，Bootstrapping是一种从一个样本中找到抽样分布(至少是近似分布)的实用方法，而不是从总体中抽取多个随机样本。</li><li id="d4d2" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">它<em class="nj">模拟</em>从一个群体中仅用<em class="nj">一个</em>样本抽取多个随机样本，所以它非常依赖这个单一样本尽可能的随机。</li><li id="2854" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">与传统的t检验不同，Bootstrap检验不对实际样本所来自的总体分布施加正态性限制。</li></ul><p id="90bf" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">首先，我们需要计算测试统计的大量bootstrap复制。</p><p id="39c0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们定义一个可重用的函数，我们可以利用它来产生测试统计的引导复制，调用一些对每个样本进行操作的基本统计函数(预定义的或用户定义的)。<br/> <strong class="kq ja">注意</strong>在重新采样和计算每个重复之前，我们不会混合来自不同样本的数据。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="c62f" class="lt lu iq lp b gy lv lw l lx ly">def boot_diff(sample_1, sample_2, base_stat_func, num_iter):<br/>    <br/>    # initialize the list for holding the bootstrap replicates<br/>    bs_replicates = []<br/>    # iterate for the specified number of bootstrapping iterations<br/>    for i in range(num_iter):<br/>        # create the resampled sets of data of the original lengths (WITH REPLACEMENT)<br/>        sample_1_bs = np.random.choice(sample_1, len(sample_1))<br/>        sample_2_bs = np.random.choice(sample_2, len(sample_2))<br/>        # compute the BS replicate using the specified base statistical function and append it to the list of BS replicates<br/>        bs_replicates += [base_stat_func(sample_1_bs) - base_stat_func(sample_2_bs)]<br/>        <br/>    return bs_replicate</span></pre><p id="657c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">为我们的任务生成BS复制:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="eed6" class="lt lu iq lp b gy lv lw l lx ly">bs_replicates = boot_diff(dem_share_PA, dem_share_OH, np.mean, 100000)</span></pre><p id="632a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">直观地检查测试统计副本的分布总是一个好主意:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="50c7" class="lt lu iq lp b gy lv lw l lx ly">plt.hist(bs_replicates, bins=50, alpha = 0.25)<br/>plt.grid()<br/>plt.show()<br/>print("Mean:  ", round(np.mean(bs_replicates),3))<br/>print("Median:", round(np.median(bs_replicates),3))</span></pre><figure class="lk ll lm ln gt no gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4317a9cd6f2cddc4b62b85deefbf84d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*X-oBhlzQ7RAj4uzeslV_sQ.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><strong class="bd nv">平均值差异的Bootstrap复制</strong>(图片由Gene Mishchenko提供)</p></figure><p id="00b5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，我们可以将<code class="fe nx ny nz lp b">np.percentile()</code>函数应用于这个生成的BS副本的大集合，以便在一个步骤中获得置信区间的上限和下限。对于下限计算，我们提供<em class="nj"> alpha/2 </em>作为该函数的第二个参数，对于上限计算，我们提供alpha/2 的<em class="nj">补码，因为该函数期望将累积百分位数作为第二个参数。<br/>使用百分位数计算得出的置信区间称为<strong class="kq ja"> <em class="nj"> Bootstrap百分位数置信区间</em> </strong>:</em></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="5060" class="lt lu iq lp b gy lv lw l lx ly"># the lower limit will be the 5th percentile<br/>lower_lim_bs = np.percentile(bs_replicates,5)<br/># the upper limit will be the 95th percentile (5's complement to 100)<br/>upper_lim_bs = np.percentile(bs_replicates,95)<br/>print(round(lower_lim_bs,3), 'to', round(upper_lim_bs,3))</span></pre><blockquote class="ng nh ni"><p id="9be9" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">-1.433至3.792</p></blockquote><p id="e6df" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">注</strong>:如果(且仅当)BS重复分布呈正态且以真实参数值为中心(偏差较小)，我们可以用下面的公式计算<strong class="kq ja"> <em class="nj"> Bootstrap t置信区间</em> </strong> : <br/> <code class="fe nx ny nz lp b">BS_stat_mean +/- t * SE</code></p><p id="7e87" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:</strong> <br/>结果与分析结果<code class="fe nx ny nz lp b">(-1.449, 3.766)</code>相当接近，但这里我们没有对样本的分布做任何假设。</p><h2 id="008d" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.3双尾假设检验</h2><p id="8c56" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">首先，我们将检验总体均值之间的真实差异为0的假设。测试条件为:</p><p id="8537" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> <em class="nj"> Ho </em> </strong>:(平均PA投票%)——(平均OH投票%) = 0 <br/> <strong class="kq ja"> <em class="nj"> Ha </em> </strong>:(平均PA投票%)——(平均OH投票%)！= 0<br/><strong class="kq ja"><em class="nj">CL</em></strong>:90%<br/><strong class="kq ja"><em class="nj">方向</em> </strong>:双尾</p><h2 id="48ab" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.3.1通过参数方法的双尾HT</h2><p id="27e4" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">让我们使用Z值方法。<br/>我们需要计算平均值的假设差异的Z值。公式为:<br/> <code class="fe nx ny nz lp b">Zc = [(sample_mean_1 - sample_mean_2) - (hyp_difference)] / SE</code> <br/>临界Z值与上面计算置信区间中的相同:<code class="fe nx ny nz lp b">-1.645</code>和<code class="fe nx ny nz lp b">1.645</code>。<br/> SE(标准误差)也可以在计算CI时重复使用:<code class="fe nx ny nz lp b">1.585</code>。<br/>均值之间的假设差异为<code class="fe nx ny nz lp b">0</code>。</p><p id="45a5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，对于计算的Z分数(Zc ),我们得到以下结果:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="a8b6" class="lt lu iq lp b gy lv lw l lx ly">Zc = (emp_diff_means - 0) / 1.585<br/>print(round(Zc,3))</span></pre><blockquote class="ng nh ni"><p id="32f9" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi">0.731</p></blockquote><p id="f097" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:无法在90%的置信水平下拒绝</strong> (FTR)零假设，因为<code class="fe nx ny nz lp b">0.731</code>的计算Z值正好在<code class="fe nx ny nz lp b">-1.645</code>和<code class="fe nx ny nz lp b">1.645</code>的临界值之间。<br/>直觉上，这是有意义的，因为两个样本的标准偏差相对于平均值而言相当大(分别为21%和22%)，并且比平均值的经验差异大几倍。</p><p id="7603" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">注</strong>:正态分布的这个Z值关联的右尾p值(AUC到右边)是<code class="fe nx ny nz lp b">0.23239</code>。<br/>双尾p值是那个的两倍:<code class="fe nx ny nz lp b">0.465</code>。<br/>因此，如果我们想要使用<strong class="kq ja"> p值方法</strong>进行分析，它也会导致FTR决定，因为这个p值比我们在尾部的拒绝区域之和(每个区域<code class="fe nx ny nz lp b">0.05</code>大得多，由我们的总显著性水平<code class="fe nx ny nz lp b">10%</code>定义。</p><h2 id="0b35" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.3.2通过自举方法的双尾HT</h2><p id="7f04" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">在比较两组时，使用bootstrap方法比使用analytical方法的主要优点是，在BS方法下，对总体没有正态性限制。此外，我们在这里不仅限于手段的比较。</p><p id="8e6c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">生成bootstrapped test statistic副本的基本过程与上一节CI中的过程相同(也没有混合样本总体，以及替换抽样)，因此我们将使用相同的函数:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="464c" class="lt lu iq lp b gy lv lw l lx ly">bs_replicates = boot_diff(dem_share_PA, dem_share_OH, np.mean, 100000)</span></pre><p id="91a1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> <em class="nj">额外的重要步骤</em> </strong>(与查找CI相比)是围绕假设平均值确定重复的分布中心:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1643" class="lt lu iq lp b gy lv lw l lx ly">bs_replicates_shifted = bs_replicates - np.mean(bs_replicates) - 0</span></pre><p id="4928" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们确保我们的最终BS重复组是有序的(以假设平均值为中心，并且标准误差的BS版本接近分析版本):</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="7a46" class="lt lu iq lp b gy lv lw l lx ly">print("Replicate 25th percentile, mean, 75th percentile:",<br/>      round(np.percentile(bs_replicates_shifted, 25),3), <br/>      round(np.mean(bs_replicates_shifted)+1e-4, 2), <br/>      round(np.percentile(bs_replicates_shifted, 75),3))<br/>print("Replicate Std Dev:", round(np.std(bs_replicates_shifted),3)) # the analytical version is 1.585</span></pre><blockquote class="ng nh ni"><p id="b1a4" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">重复第25百分位，平均第75百分位:-1.085 ~ 0.0 ~ 1.07 <br/>重复标准差:1.595</p></blockquote><p id="b95d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">看起来不错…现在我们可以得到这组BS重复数据中平均值的经验差异的百分位数等级:<br/> ( <code class="fe nx ny nz lp b">scipy.stats.percentileofscore()</code>是<code class="fe nx ny nz lp b">np.percentile()</code>的倒数)</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2a43" class="lt lu iq lp b gy lv lw l lx ly">emp_diff_pctile_rnk = stats.percentileofscore(bs_replicates_shifted, emp_diff_means)<br/>print("Empirical difference of the sample means:", round(emp_diff_means, 3))<br/>print("Its percentile rank among the replicates:", round(emp_diff_pctile_rnk, 2), "% (AUC to the left)")<br/>auc_left = round(emp_diff_pctile_rnk / 100, 4)<br/>auc_rght = round(1 - emp_diff_pctile_rnk / 100, 4)<br/>print("AUC to the left:  ", auc_left)<br/>print("AUC to the right: ", auc_rght)</span></pre><blockquote class="ng nh ni"><p id="2516" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">样本的经验差异均值:1.158 <br/>其在重复中的百分位数排序:76.69 % (AUC向左)<br/> AUC向左:0.7669 <br/> AUC向右:0.2331</p></blockquote><p id="dc49" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们现在需要非常仔细地解释这个结果，这取决于我们正在进行的测试类型，以便获得<strong class="kq ja"> p值</strong>:</p><ul class=""><li id="b08c" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">如果我们正在进行左尾测试，我们需要将AUC带到左边</li><li id="ff81" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">如果我们正在进行右尾检验，我们需要将AUC向右移动</li><li id="f63c" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">如果我们正在进行一个双尾检验，我们需要取较小的AUC值(因为它总是代表一个尾区域)并乘以T2</li></ul><p id="6605" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，我们正在进行的双尾检验的p值为:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="92a4" class="lt lu iq lp b gy lv lw l lx ly">auc_tail = auc_left if auc_left &lt; auc_rght else auc_rght<br/>p_val = round(auc_tail * 2, 4)<br/>print("P-value:", p_val)</span></pre><blockquote class="ng nh ni"><p id="d9fc" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">p值:0.4662</p></blockquote><p id="ccd7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:未能在90%置信水平下拒绝(FTR) </strong>原假设，因为p值远大于<code class="fe nx ny nz lp b">0.10</code>的显著性。</p><h2 id="f5b7" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.4单尾假设检验</h2><p id="71be" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">这里，我们将测试PA和OH平均值之间的真实差值小于或等于-2.0的假设(换句话说，预计OH的平均投票百分比至少比PA大<em class="nj">2.0)。</em></p><p id="f080" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">注意</strong>:在陈述这个单尾假设时，为了便于说明，我们保持了与上述例子中相同的均值顺序，尽管陈述这个不等式更自然的方式是“OH mean — PA mean &gt; = 2”。</p><p id="bf24" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> <em class="nj"> Ho </em> </strong>:(平均PA投票%)——(平均OH投票%)&lt;=-2<br/><strong class="kq ja"><em class="nj">Ha</em></strong>:(平均OH投票%)——(平均OH投票%)&gt;-2<br/><strong class="kq ja"><em class="nj">CL</em></strong>:90%<br/><strong class="kq ja"><em class="nj">方向</em> </strong>:右尾(自<em class="nj"> Ho </em>拒绝</p><h2 id="a4a4" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.4.1通过参数方法的单尾HT</h2><p id="c2ef" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">我们需要计算平均值的假设差异的Z值。公式为:<br/> <code class="fe nx ny nz lp b">Zc = [(sample_mean_1 - sample_mean_2) - (hyp_difference)] / SE</code> <br/> SE(标准差)可以从计算CI中重复使用，也就是<code class="fe nx ny nz lp b">1.585</code>。<br/>假设平均值之差为<code class="fe nx ny nz lp b">-2</code>。我们假设人口的正态分布。<br/>因此，对于计算的Z得分(Zc ),我们得到以下结果:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="941a" class="lt lu iq lp b gy lv lw l lx ly">Zc = (emp_diff_means - (-2)) / 1.585<br/>print(round(Zc,4))</span></pre><blockquote class="ng nh ni"><p id="c572" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi">1.9926</p></blockquote><p id="b2af" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果使用<strong class="kq ja"> Z值方法</strong>，我们需要计算<code class="fe nx ny nz lp b">0.10</code>的右尾<em class="nj"> alpha </em>的上临界Z值，该值可以直接与计算的Z值进行比较:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="083f" class="lt lu iq lp b gy lv lw l lx ly">round(stats.norm.ppf(0.9),4)</span></pre><blockquote class="ng nh ni"><p id="62bc" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi">1.2816</p></blockquote><p id="63c2" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果使用<strong class="kq ja"> P值方法</strong>，我们需要找到与计算的Z值相关的右尾P值。<br/>首先，我们计算左边的AUC:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1c96" class="lt lu iq lp b gy lv lw l lx ly"># use scipy.stats.norm.cdf(), which is the inverse of stats.norm.ppf()<br/>auc_left = round(stats.norm.cdf(1.9926), 4)<br/>print("AUC to the left:", auc_left)</span></pre><blockquote class="ng nh ni"><p id="a485" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">左边的AUC:0.9768</p></blockquote><p id="32e7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因为我们正在寻找<em class="nj">右尾</em>下的p值，所以我们需要从<code class="fe nx ny nz lp b">1</code> : <br/>中减去这个值(如果我们正在进行左尾测试，我们将按原样取这个AUC值)</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="b7b8" class="lt lu iq lp b gy lv lw l lx ly">p_val = 1 - auc_left<br/>print("P-value:", p_val)</span></pre><blockquote class="ng nh ni"><p id="578a" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">p值:0.0232</p></blockquote><p id="3645" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:拒绝零假设</strong>因为:</p><ul class=""><li id="75db" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">计算出的<code class="fe nx ny nz lp b">1.9926</code>的Z值大于<code class="fe nx ny nz lp b">1.2816</code>的临界值上限</li><li id="3682" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">计算出的<code class="fe nx ny nz lp b">0.0232</code>的右尾p值小于<code class="fe nx ny nz lp b">0.10</code>的右尾显著性</li></ul><h2 id="14f8" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">1.4.2通过自举方法的单尾HT</h2><p id="e66d" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">生成引导复制的基本过程与之前相同:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="6897" class="lt lu iq lp b gy lv lw l lx ly">bs_replicates = boot_diff(dem_share_PA, dem_share_OH, np.mean, 100000)</span></pre><p id="7e70" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> <em class="nj">额外的重要步骤</em> </strong>(与查找CI相比)是围绕假设平均值确定重复的分布中心:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="344a" class="lt lu iq lp b gy lv lw l lx ly">bs_replicates_shifted = bs_replicates - np.mean(bs_replicates) - 2</span></pre><p id="885f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们确保我们的BS重复样本总体以假设平均值为中心，并且标准误差的BS版本接近分析结果:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="5651" class="lt lu iq lp b gy lv lw l lx ly">print(“Replicate 25th percentile, mean, 75th percentile:”,<br/> round(np.percentile(bs_replicates_shifted, 25),3), “~”,<br/> round(np.mean(bs_replicates_shifted)+1e-4, 2), “~”,<br/> round(np.percentile(bs_replicates_shifted, 75),3))<br/>print(“Replicate Std Dev:”, round(np.std(bs_replicates_shifted),3)) <br/># the analytical version is 1.585</span></pre><blockquote class="ng nh ni"><p id="d691" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">重复第25百分位，平均第75百分位:-3.077 ~ -2.0 ~ -0.94 <br/>重复标准差:1.584</p></blockquote><p id="000a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">看起来不错…现在我们可以得到这组BS重复数据中平均值的经验差异的百分位数等级:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4112" class="lt lu iq lp b gy lv lw l lx ly">emp_diff_pctile_rnk = stats.percentileofscore(bs_replicates_shifted, emp_diff_means)<br/>print("Empirical difference of the sample means:", round(emp_diff_means, 3))<br/>print("Its percentile rank among the replicates:", round(emp_diff_pctile_rnk, 2), "% (AUC to the left)")<br/>auc_left = round(emp_diff_pctile_rnk / 100, 4)<br/>auc_rght = round(1 - emp_diff_pctile_rnk / 100, 4)<br/>print("AUC to the left:  ", auc_left)<br/>print("AUC to the right: ", auc_rght)</span></pre><blockquote class="ng nh ni"><p id="080e" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">样本的经验差异平均值:1.158 <br/>其在重复中的百分位数等级:97.55 % (AUC向左)<br/> AUC向左:0.9755 <br/> AUC向右:0.0245</p></blockquote><p id="b129" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">解读:<br/>由于这是右尾检验，<strong class="kq ja"> p值就是右边</strong>的AUC(非常接近<code class="fe nx ny nz lp b">0.0232</code>的分析结果)。<br/>由于我们正在进行单尾检验，我们可以直接将该值与显著性水平进行比较。</p><p id="1b11" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:拒绝零假设</strong>，因为p值小于<code class="fe nx ny nz lp b">0.10</code>的显著性。</p><h1 id="467e" class="lz lu iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">2.使用排列测试的显著性测试</h1><p id="1d92" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">置换检验用于确定观察到的效应是否可以合理地归因于选择样本时引入的随机性。如果不是，我们有证据表明在样本中观察到的效应反映了在人群中存在的效应。置换测试在临床研究等受控环境中非常流行，在这些环境中，需要将接受某种治疗的组与未接受任何治疗的对照组进行比较。</p><h2 id="0aa3" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">2.1 PT理论</h2><p id="c2f8" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated"><strong class="kq ja">排列测试时<em class="nj">可以用</em>:</strong></p><ul class=""><li id="8384" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">当零假设表明两个总体相同时的两样本情形。我们可能希望比较总体的任何基本统计数据。就我们可以选择的统计数据而言，传统测试非常有限。</li><li id="3d68" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">当零假设表明配对中只有随机差异时的配对情景。这里也可以进行广泛的比较选择。</li><li id="646c" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">当零假设表明变量不相关时的两个定量变量情景。通常相关性是最常见的度量，但不是唯一的。</li></ul><p id="7d20" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">基本上，当有两组数据并且零假设表明它们之间的一些观察到的效应是偶然观察到的时，我们可以执行PT。</p><p id="508a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">排列测试的一般流程:</strong></p><ol class=""><li id="4373" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj op og oh oi bi translated">选择一个测试统计量来衡量我们在两组数据之间寻找的效果(这一步在bootstrap测试中很常见)。通常这是每个数据集的“基础”统计之间的差异。</li><li id="5bb3" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj op og oh oi bi translated">构建如果不存在该效应时该检验统计量将具有的抽样分布(这是排列检验的独特核心)。</li><li id="b23e" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj op og oh oi bi translated">在这个假设分布中找到观察到的(经验的)检验统计值。分布主体中的值很容易偶然出现。尾部中的值很少是偶然出现的，这可能是除了偶然之外的东西在起作用的证据(这在自举中很常见)。</li></ol><p id="78e3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">当排列测试<em class="nj">时，是否应该使用</em>来代替自举测试:</strong></p><p id="9ae7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在双样本检验设置中，我们可以在bootstrap检验和permutation检验之间进行选择。即使双样本排列测试的测试统计量<em class="nj">可能被选择为与双样本bootstrap测试相同的</em>(例如，样本均值之间的差异)，测试的潜在性质却大不相同:排列测试实际上使用某个狭窄的统计量查看两个样本<em class="nj">是否可能假设来自同一个总体</em>，而bootstrap测试则专门查看统计量本身，因此排列测试是比bootstrap测试更“深入”更普遍的比较，但是(注意！)测试统计可能不会显示出来，这取决于您如何设计它，以及它如何捕捉样本之间的实际差异。</p><p id="fbbb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">总之，<strong class="kq ja">排列测试</strong>应用于:</p><ul class=""><li id="e251" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">对影响的<em class="nj">存在</em>(或不存在)的假设检验(例如，某种影响是否存在，或者是否存在某种积极影响，或者是否存在某种消极影响)。</li></ul><p id="e3f7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">自举</strong>应该用于:</p><ul class=""><li id="ea8d" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">针对特定已知/预期效果的定量假设测试(例如，汽车电池的平均寿命实际上提高了一年或一年以上吗？).</li><li id="62e0" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">非参数化确定置信区间。</li></ul><h2 id="b426" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">2.2介绍性PT示例</h2><p id="a394" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">为了介绍这个过程本身，让我们使用同样的<strong class="kq ja">双样本场景</strong>，我们使用bootstrap测试(BT)来测试总体均值之间的差异:</p><p id="2d10" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> <em class="nj"> Ho </em> </strong>:底层分布相同(均值等特征)<br/> <strong class="kq ja"> <em class="nj"> Ha </em> </strong>:均值(PA投票%) —均值(OH投票%)！= 0 <br/></p><p id="3c66" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">注意</strong> <em class="nj"> : </em>这里的检验统计量和替代假设与我们进行的bootstrap检验相同，但是<em class="nj">零假设必须保持非常通用</em>，这仅仅是由于检验统计量通过排列复制的过程的性质(我们将很快看到为什么)。这里的逻辑是，一旦有足够的证据接受一个相当具体的替代假设，我们就可以拒绝一个非常笼统的零假设，这个零假设是很多东西的合取，包括替代假设的对立面。使用法律类比，在一个刑事案件中，可能只需要从所有可用证据中拿出一条非常具体的证据就可以打破非常普遍的无罪推定。然而，与法律环境不同的是，在排列测试<em class="nj">中，我们通常对零假设本身不感兴趣</em>(除非实际的测试目标是知道总体是否相同)。所以焦点转移到了另一个假设上。</p><p id="705f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们定义一个可重用的函数，我们可以利用它来产生一个测试统计的排列副本，调用一些对每个样本进行操作的基本统计函数(预定义的或用户定义的)。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1afd" class="lt lu iq lp b gy lv lw l lx ly">def perm_diff(sample_1, sample_2, base_stat_func, num_iter):<br/>    <br/>    # initialize the list for the test statistic replicate<br/>    perm_replicates = []<br/>    # iterate for the specified number of iterations<br/>    for i in range(num_iter):<br/>        # concatenate the two samples into one<br/>        samples_app = sample_1 + sample_2<br/>        # permute the entire appended set (making this complete combined resampling WITHOUT REPLACEMENT)<br/>        samples_perm = np.random.permutation(samples_app)<br/>        # create the hypothesized samples by:<br/>        #  pretending that the first len(sample_1) elements is the first sample<br/>        sample_1_hyp = samples_perm[:len(sample_1)]<br/>        #  and the rest is the second sample<br/>        sample_2_hyp = samples_perm[ len(sample_1):]<br/>        # compute the test statistic replicate and append it to the list of permutation replicates<br/>        perm_replicates += [base_stat_func(sample_1_hyp) - base_stat_func(sample_2_hyp)]</span><span id="b48b" class="lt lu iq lp b gy oq lw l lx ly">return perm_replicates</span></pre><p id="b1e7" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，让我们生成置换复制集:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="7312" class="lt lu iq lp b gy lv lw l lx ly">perm_replicates = perm_diff(dem_share_PA, dem_share_OH, np.mean, int(1e5))</span></pre><p id="7d56" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们简单看一下均值差的假设分布。它应该以零为中心，并且应该近似正常。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4400" class="lt lu iq lp b gy lv lw l lx ly">plt.hist(perm_replicates, bins=50, alpha=0.25)<br/>plt.grid()<br/>plt.show()</span></pre><figure class="lk ll lm ln gt no gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d301c3bd71a4a3ec928b079e1c201d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*yAzmUTdl8Eye8AXHJnqDpg.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><strong class="bd nv">均值差异的排列复制</strong>(图片由吉恩·米先科提供)</p></figure><p id="3237" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在我们需要从两个尾部得到<strong class="kq ja"> p值，该值与使用该分布的均值的经验差异相关。<br/> <strong class="kq ja">注意</strong>由于中心极限定理，置换分布在大多数情况下应该是相对对称的，作为一个好的实践，最好直接得到两个尾部下的AUC。有几种技术方法可以做到这一点:</strong></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="81e7" class="lt lu iq lp b gy lv lw l lx ly"># looking at the absolute values on both tails and comparing them to the absolute empirical value simultaneously<br/>p_val_2t_a = sum(np.abs(perm_replicates) &gt;= abs(emp_diff_means)) / len(perm_replicates)<br/>print(round(p_val_2t_a, 4))</span><span id="7129" class="lt lu iq lp b gy oq lw l lx ly"># Get the percentile rank of the NEGATIVE ABSOLUTE empirical value and take it as-is (looking at the left tail)<br/>lt_p_val = stats.percentileofscore(perm_replicates, -abs(emp_diff_means) ) / 100<br/># Get the percentile rank of the ABSOLUTE empirical value and take the complement of it (looking at the right tail)<br/>rt_p_val = 1 - stats.percentileofscore(perm_replicates, abs(emp_diff_means) ) / 100<br/># Add the two half-values together<br/>p_val_2t_b = lt_p_val + rt_p_val<br/>print(round(p_val_2t_b, 4))</span></pre><blockquote class="ng nh ni"><p id="9ab0" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">0.4709 <br/> 0.4709</p></blockquote><p id="12c6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:FTR </strong>(保留)原假设，即县对民主党人有利的投票百分比对PA和OH的分布是相同的，因为所得的p值大于<code class="fe nx ny nz lp b">0.10</code>的显著性。</p><p id="397d" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">可能值得注意的是，这里的p值比使用分析法和自举法(<code class="fe nx ny nz lp b">0.465</code>)比较平均值时略大...样本是相似的，所以很难判断结果的这种差异是否真的有意义，但一般来说，较大的p值是保持零假设的更强基础。</p><h1 id="db18" class="lz lu iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">3.比较Bootstrap和置换分布</h1><h2 id="3cf9" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">3.1工作流程概述</h2><p id="95dc" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">因为在可以使用自举的情况和可以使用置换的情况之间有一些重叠，所以让我们实验性地比较复制的测试统计的相应总体，以便我们更好地理解使用它们的含义。<br/>每次比较将包括以下假设检验工作流程，部分进行:</p><p id="8627" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> (1) </strong>陈述高级业务目标，以及我们正在进行的研究与这些目标的关系。在陈述业务目标和当前研究目标时，要尽可能具体。<br/><strong class="kq ja">【2】</strong>定义可以帮助我们达到研究目标的统计数据(这里我们假设这些样本是我们得到的唯一数据集，但通常这个阶段包括数据发现、EDA和/或新数据收集设置的迭代过程，视需要和可行而定)。<br/> <strong class="kq ja"> (3) </strong>设计使用上述统计量来满足上述研究目标的统计推断任务。根据需要创建尽可能多的任务。对于每个<em class="nj">假设检验</em>，需要说明以下项目:</p><ul class=""><li id="39dc" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">要使用的测试统计</li><li id="cd23" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">根据选定的统计数据陈述的无效假设和替代假设</li><li id="6d36" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">测试的方向(单尾/双尾)</li><li id="7922" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">置信度/显著性水平</li><li id="8ea0" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">要使用的方法(例如参数/引导/排列)</li></ul><p id="6358" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> (4) </strong>执行任务。</p><p id="33d9" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">步骤(1)可能经常看起来琐碎和不必要，但它是选择统计数据和正确设计测试所必需的。在我们的比较中，步骤(1)和(2)将在bootstrap和置换测试中共享。<br/>我们不会执行步骤(4)——实际进行测试——所以我们不需要定义置信区间。</p><p id="4a35" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">我们将重点比较检验统计重复的两种分布和相应的p值:</strong></p><ul class=""><li id="a920" class="oa ob iq kq b kr ks ku kv kx oc lb od lf oe lj of og oh oi bi translated">引导复制分布</li><li id="b20c" class="oa ob iq kq b kr oj ku ok kx ol lb om lf on lj of og oh oi bi translated">置换复制分布</li></ul><h2 id="54a2" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">3.2示例设置</h2><p id="fc84" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated"><strong class="kq ja">研究目标</strong>:这是一项关于一种新的教学方法对大学生成绩影响的假想对照研究。它被直接整合到新教学方法的开发和测试过程中。我们的任务是特别关注新方法的<em class="nj">效果，通过学生的考试成绩来衡量。这项研究的结论将与其他考虑因素一起，用于决定是否为该科目改用新的教学方法。<br/> <strong class="kq ja">研究设置</strong>:一个随机组成的“治疗”组在一个学期内接受新的教学方法，另一个随机组成的“控制”组接受同一科目的传统教学方法。每组由100名学生组成。教授这门课程的教师必须同时教授两组学生，以便尽可能地消除教学中的人为因素。两组学生的期中和期末考试是一样的。<br/> <strong class="kq ja">为每个小组收集的数据</strong>是每个学生的期中和期末考试成绩的平均值，满分为100分。</em></p><p id="6fbe" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们生成示例数据:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1b1e" class="lt lu iq lp b gy lv lw l lx ly"># draw the raw random data for the control sample from a normal distribution<br/>np.random.seed(5)<br/>cs_raw = np.random.normal(loc=75.0, scale=9.0, size=100)<br/># "pivot" the right tail around 100 with a multiplier <br/># (there should not be many cases)<br/>cs = [score - (score - 100)*1.5 if score &gt; 100 else score for score in cs_raw]</span><span id="faa9" class="lt lu iq lp b gy oq lw l lx ly"># draw the raw random data for the treatment sample from a normal distribution <br/># with a slightly larger mean and a significantly larger standard deviation than for the control sample<br/># (it is expected that there will be quite a few instances here that go over 100)<br/>ts_raw = np.random.normal(loc=78.0, scale=13, size=100)<br/># "pivot" the right tail around 100 with a multiplier, which caps the score at the max,<br/># making the right tail much thicker and shorter<br/>ts = [score - (score - 100)*2.0 if score &gt; 100 else score for score in ts_raw]</span></pre><h2 id="7aa5" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">3.3样品的EDA</h2><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="55ab" class="lt lu iq lp b gy lv lw l lx ly">fig = plt.gcf()<br/>fig.set_size_inches(16,8)<br/>plt.hist(cs, bins=20, alpha=0.15, label = 'control group')<br/>plt.hist(ts, bins=20, alpha=0.15, color='r', label = 'treatment group')<br/>plt.legend()<br/>plt.grid()<br/>plt.show()</span></pre><figure class="lk ll lm ln gt no gh gi paragraph-image"><div role="button" tabindex="0" class="os ot di ou bf ov"><div class="gh gi or"><img src="../Images/7e6de867a20c3947dc00de6932f0cb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ee1dEIxd3CVICiiBWzvfMg.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><strong class="bd nv">对照和治疗样品</strong>(由Gene Mishchenko成像)</p></figure><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="f072" class="lt lu iq lp b gy lv lw l lx ly">print("Control   mean, 10th, 25th, 50th, 75th, 90th pctiles:", <br/>      round(np.mean(cs),2), "~", <br/>      round(np.percentile(cs,10),2), "~",<br/>      round(np.percentile(cs,25),2), "~",<br/>      round(np.percentile(cs,50),2), "~",<br/>      round(np.percentile(cs,75),2), "~",<br/>      round(np.percentile(cs,90),2))<br/>print("Treatment mean, 10th, 25th, 50th, 75th, 90th pctiles:", <br/>      round(np.mean(ts),2), "~", <br/>      round(np.percentile(ts,10),2), "~",<br/>      round(np.percentile(ts,25),2), "~",<br/>      round(np.percentile(ts,50),2), "~",<br/>      round(np.percentile(ts,75),2), "~",<br/>      round(np.percentile(ts,90),2))</span></pre><blockquote class="ng nh ni"><p id="a99c" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">对照组均值，第10、25、50、75、90百分位数:75.82 ~ 67.12 ~ 70.62 ~ 74.43 ~ 81.78 ~ 86.67</p></blockquote><p id="f7b3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:</strong>看起来平均分数提高了大约2分，并且相对于对照组，治疗组中的A和B学生要多得多，但是在低端也发生了一些事情——更多的学生不及格(分数&lt; 70)并且差距更大。<br/>因此，在本例中，我们可以看到潜在的正面影响和负面影响。</p><h2 id="9e3a" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">3.4研究用例1(平均学习进步)</h2><p id="4bd3" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">让我们假设我们唯一关心的<strong class="kq ja">商业目标</strong>是所有学生平均学习成绩的<em class="nj">提高。<br/> <strong class="kq ja">测试统计</strong>:我们认为治疗组和对照组学生之间的平均测试分数</em>的任何<em class="nj">统计显著正差异都是达到商业目标的证明。</em></p><h2 id="7f98" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">自举测试</h2><p id="f87c" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated"><strong class="kq ja"> <em class="nj"> Ho </em> </strong>:均值(治疗组得分)—均值(对照组得分)= 0<br/><strong class="kq ja"><em class="nj">【Ha】</em></strong>:均值(治疗组得分)—均值(对照组得分)&gt; 0 <br/> <strong class="kq ja"> <em class="nj">方向</em> </strong>:右尾</p><h2 id="ed55" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">排列测试</h2><p id="09ce" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated"><strong class="kq ja"> <em class="nj"> Ho </em> </strong>:学生分数分布相同(含均值)<br/> <strong class="kq ja"> <em class="nj"> Ha </em> </strong>:均值(治疗组分数)—均值(对照组分数)&gt; 0 <br/> <strong class="kq ja"> <em class="nj">方向</em> </strong>:右尾</p><h2 id="3696" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">生成和比较复制分布</h2><p id="d7ca" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">首先，让我们生成并绘制两个复制分布:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="8a33" class="lt lu iq lp b gy lv lw l lx ly">boot_diff_mean_scores = boot_diff(ts, cs, np.mean, int(1e5))<br/># DON'T FORGET TO SHIFT TO THE HYPOTHESIZED MEAN (0 in this case)<br/>boot_diff_mean_scores = boot_diff_mean_scores - np.mean(boot_diff_mean_scores) + 0</span><span id="830f" class="lt lu iq lp b gy oq lw l lx ly">perm_diff_mean_scores = perm_diff(ts, cs, np.mean, int(1e5))</span><span id="9ffa" class="lt lu iq lp b gy oq lw l lx ly">fig = plt.gcf()<br/>fig.set_size_inches(10,5)<br/>plt.hist(boot_diff_mean_scores, bins=50, alpha=0.15, label = 'boot repl')<br/>plt.hist(perm_diff_mean_scores, bins=50, alpha=0.15, color='r', label = 'perm repl')<br/>plt.legend()<br/>plt.grid()<br/>plt.show()</span></pre><figure class="lk ll lm ln gt no gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/576a914aa27a25d1e2269462163bcecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*-TJ1U2FFhAFnUsRZMXuvvQ.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><strong class="bd nv">自助复制和排列复制—均值差异</strong>(图片由Gene Mishchenko提供)</p></figure><p id="50b5" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">分布之间没有很大的差异，排列重复分布略宽(对于较大的样本量，分布之间的差异较小，对于较小的样本量，差异更大)。</p><p id="ea97" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们看看<strong class="kq ja"> p值</strong>。由于我们正在进行右尾检验，p值是观察值的百分位秩的<em class="nj">补数:</em></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="90ec" class="lt lu iq lp b gy lv lw l lx ly">emp_val = np.mean(ts) - np.mean(cs)<br/>boot_p_val = 1 - stats.percentileofscore(boot_diff_mean_scores, emp_val)/100<br/>print("p-value by bootstrapping:\t", round(boot_p_val,5))<br/>perm_p_val = 1 - stats.percentileofscore(perm_diff_mean_scores, emp_val)/100<br/>print("p-value by permutation:\t\t", round(perm_p_val,5))</span></pre><blockquote class="ng nh ni"><p id="c795" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">自举p值:0.09773 <br/>置换p值:0.10201</p></blockquote><p id="de1f" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论:</strong>排列法比自举法给测试过程增加了更多的随机性(这种差异在样本越小的情况下越明显)，所以我们得到了一个更保守的答案。这就是为什么<strong class="kq ja">排列测试是分类假设测试的更好选择</strong>。<br/>在这个具体的例子中，如果我们的显著性水平设置为10%，方法的选择将产生关键的差异，因为p值落在它的不同边上(这也是为什么我们应该<em class="nj">总是</em>在实施测试之前确定显著性水平，这样我们就不会试图回解)。</p><h2 id="e62f" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">3.5研究用例2(留守学生)</h2><p id="accd" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">现在，让我们说，就<strong class="kq ja">商业目标</strong>而言，大学管理层不仅关心平均学习成果，还关心学生的<em class="nj">辍学率和不合格率</em>(当然，尽可能保持这些比率较低)。<br/>假设<strong class="kq ja">研究目标、研究设置和收集的数据</strong>自始至终都与这一新信息保持一致，我们能做些什么来实现研究目标？</p><p id="6f98" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">好吧，鉴于这种人工数据集，我们无法测量辍学率(或课程完成率)，但在现实生活中，完成课程的学生的考试成绩会得到这种信息的补充…所以让我们专注于分析低端的考试成绩。</p><p id="c5ea" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们可能要考虑的每个数据集的<strong class="kq ja">【基础】统计</strong> <em class="nj">是低于下四分位数的平均分数。因此<strong class="kq ja">检验统计量</strong>将是治疗组的基础统计量和对照组的基础统计量之间的差异。就像平均测试分数的差异一样，这是一个<em class="nj">正</em>度量，意味着如果它有一个正的符号，它对业务有好处，反之亦然。<br/>让我们定义一个用于计算基本统计数据的函数，我们可以将它传递给<code class="fe nx ny nz lp b">boot_diff</code>和<code class="fe nx ny nz lp b">perm_diff</code>函数:</em></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="3e74" class="lt lu iq lp b gy lv lw l lx ly">def low_quart_mean(arr):<br/>    first_percentile = np.percentile(arr, 25)<br/>    filt_arr = [x for x in arr if x &lt;= first_percentile]<br/>    return np.mean(filt_arr)</span></pre><p id="25e3" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们在处理样品和对照样品上测试它…</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="0c21" class="lt lu iq lp b gy lv lw l lx ly">low_quart_mean(ts)</span></pre><blockquote class="ng nh ni"><p id="d840" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi">60.97728174389116</p></blockquote><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e183" class="lt lu iq lp b gy lv lw l lx ly">low_quart_mean(cs)</span></pre><blockquote class="ng nh ni"><p id="4765" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi">65.93498145550805</p></blockquote><p id="1cc0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">从控制样本到处理样本的平均下降5个点…这应该很有趣…让我们来设置我们的测试。</p><h2 id="6b32" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">自举测试</h2><p id="f4ee" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated"><strong class="kq ja"> <em class="nj"> Ho </em> </strong>:均值(治疗组最低分之一)—均值(对照组最低分之一)&gt;= 0<br/><strong class="kq ja"><em class="nj">Ha</em></strong>:均值(治疗组最低分之一)—均值(对照组最低分之一)&lt; 0 <br/> <strong class="kq ja"> <em class="nj">方向</em> </strong>:左尾</p><h2 id="41bc" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">排列测试</h2><p id="0379" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated"><strong class="kq ja"> <em class="nj"> Ho </em> </strong>:学生分数分布相同(包括分数最低的四分之一的均值)<br/> <strong class="kq ja"> <em class="nj"> Ha </em> </strong>:均值(治疗组分数最低的四分之一)—均值(对照组分数最低的四分之一)&lt; 0 <br/> <strong class="kq ja"> <em class="nj">方向</em> </strong>:左尾</p><p id="e6a1" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">注意</strong>:我们有意将替代假设的方向设定为我们在EDA过程中所做的初步发现的方向……否则，置换测试在FTR结果(未能拒绝零假设)的情况下将不会非常有用，因为零假设非常普遍(在PT中也必须如此)。在研究过程中，必须在第一次测试后保留零假设，然后尝试构建一个不同的测试来“打破它”，这是完全正常的，但如果我们有一个基于EDA的“直觉”，并且我们认为我们可以在一个测试中做到这一点，为什么不这样做呢？<br/>在bootstrap测试中，我们没有这种限制——零假设可以被定义在与替代假设相同的水平上，并且是相反的镜像，因此测试的方向变得任意。<br/>此外，作为一个提醒，除了排列测试中对零假设的限制，排列测试中的<em class="nj">替代</em>假设也有一个限制——测量假设数据集之间差异的重复统计必须以0为中心，因为方向性在这个过程中丢失了。<br/> Bootstrap测试对<em class="nj"> Ho </em>和<em class="nj"> Ha </em>没有这些限制，这就是为什么<strong class="kq ja">对于已确认/预期效果的定量测试来说Bootstrap是一个自然的选择</strong>。</p><h2 id="63a4" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">生成和比较复制分布</h2><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="7d30" class="lt lu iq lp b gy lv lw l lx ly">boot_diff_lqms = boot_diff(ts, cs, low_quart_mean, int(1e5))<br/># DON'T FORGET TO SHIFT TO THE HYPOTHESIZED MEAN (0 in this case)<br/>boot_diff_lqms = boot_diff_lqms - np.mean(boot_diff_lqms) + 0</span><span id="4dc2" class="lt lu iq lp b gy oq lw l lx ly">perm_diff_lqms = perm_diff(ts, cs, low_quart_mean, int(1e5))</span><span id="6117" class="lt lu iq lp b gy oq lw l lx ly">fig = plt.gcf()<br/>fig.set_size_inches(10,5)<br/>plt.hist(boot_diff_lqms, bins=50, alpha=0.15, label = 'boot repl')<br/>plt.hist(perm_diff_lqms, bins=50, alpha=0.15, color='r', label = 'perm repl')<br/>plt.legend()<br/>plt.grid()<br/>plt.show()</span></pre><figure class="lk ll lm ln gt no gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/15124e8d82a4e132f2f001febae0d04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*7iwq_3rHfxquerskpLgi5Q.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><strong class="bd nv"> BS复制和烫发。重复——下四分之一差异表示</strong>(图片由Gene Mishchenko提供)</p></figure><p id="a076" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">同样，排列复制似乎分布得稍宽。</p><p id="64da" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在让我们看看<strong class="kq ja"> p值</strong>。因为我们正在进行左尾检验，所以每种情况下的p值都是观察值的<em class="nj">百分位:</em></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4d1f" class="lt lu iq lp b gy lv lw l lx ly">emp_val = low_quart_mean(ts) - low_quart_mean(cs)<br/>boot_p_val = stats.percentileofscore(boot_diff_lqms, emp_val)/100<br/>print("p-value by bootstrapping:\t", round(boot_p_val,5))<br/>perm_p_val = stats.percentileofscore(perm_diff_lqms, emp_val)/100<br/>print("p-value by permutation:\t\t", round(perm_p_val,5))</span></pre><blockquote class="ng nh ni"><p id="8003" class="ko kp nj kq b kr ks ka kt ku kv kd kw nk ky kz la nl lc ld le nm lg lh li lj ij bi translated">自举p值:0.01304 <br/>置换p值:0.01651</p></blockquote><p id="6bfc" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">结论</strong>:在这个用例中，重复分布之间的差异甚至比平均值之间的差异更明显，置换法产生了更宽的测试统计分布，并产生了更大的p值，这是一个更保守的零假设拒绝标准。</p><h2 id="6290" class="lt lu iq bd ma mw mx dn me my mz dp mi kx na nb mk lb nc nd mm lf ne nf mo iw bi translated">3.6 BT与PT —总结</h2><p id="8af9" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">Bootstrapping是一种更通用的方法，它不局限于具有两组数据的情况，不局限于假设检验，并且在无效假设和备选假设方面限制较少。它应该用于估计置信区间和已知效应的定量假设检验。</p><p id="da99" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">置换检验可用于两个数据集(两个样本、配对或一个样本中的两个变量)的设置中，当我们想要确认两个数据集之间存在(或不存在)某种可观察到的效应时，应使用置换检验。</p></div></div>    
</body>
</html>