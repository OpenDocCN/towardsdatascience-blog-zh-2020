<html>
<head>
<title>Overview of the main Google BigQuery features — practice writing requests for marketing analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google BigQuery主要特性概述——练习撰写营销分析请求</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/overview-of-the-main-google-bigquery-features-28f3ef3af6f?source=collection_archive---------39-----------------------#2020-10-28">https://towardsdatascience.com/overview-of-the-main-google-bigquery-features-28f3ef3af6f?source=collection_archive---------39-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/404ca54658be7b1e52f741a75eb90b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEaZTUtjzJsX3bhHBjiheg.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来源:<a class="ae jd" href="https://unsplash.com/photos/5fNmWej4tAA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><div class=""/><div class=""><h2 id="1688" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">在本文中，我们将研究BigQuery的主要功能，并通过具体的例子展示它们的可能性。您将学习如何编写基本的查询并在演示数据上测试它们。</h2></div><p id="02f2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">企业积累的信息越多，在哪里存储信息的问题就越尖锐。如果你没有能力或者没有意愿维护自己的服务器，<a class="ae jd" href="https://cloud.google.com/bigquery/" rel="noopener ugc nofollow" target="_blank"> Google BigQuery </a> (GBQ)可以帮忙。BigQuery为处理大数据提供了快速、经济高效且可扩展的存储，它允许您使用类似SQL的语法以及标准和<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions" rel="noopener ugc nofollow" target="_blank">用户定义函数</a>编写查询。</p><h1 id="21e1" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">什么是SQL，BigQuery支持哪些方言</h1><p id="a7d2" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">结构化查询语言(SQL)允许您在大型数组中检索数据、添加数据和修改数据。Google BigQuery支持两种SQL方言:标准SQL和过时的遗留SQL。</p><p id="ba43" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">选择哪种方言取决于您的偏好，但是Google建议使用标准SQL，因为它有以下好处:</p><ul class=""><li id="5d00" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">嵌套和重复字段的灵活性和功能性</li><li id="8853" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">支持<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-manipulation-language" rel="noopener ugc nofollow" target="_blank"> DML </a>和<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language" rel="noopener ugc nofollow" target="_blank"> DDL </a>语言，允许您更改表中的数据以及管理GBQ中的表和视图</li><li id="478c" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">与传统SQL相比，处理大量数据的速度更快</li><li id="5dc8" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">支持所有未来的BigQuery更新</li></ul><p id="bdb5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/migrating-from-legacy-sql" rel="noopener ugc nofollow" target="_blank"> BigQuery文档</a>中了解更多关于方言差异的信息。</p><p id="80cb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">默认情况下，Google BigQuery查询在遗留SQL上运行。</p><p id="2160" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以通过几种方式切换到标准SQL:</p><ol class=""><li id="53c9" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">在BigQuery界面的查询编辑窗口中，选择<strong class="kx jh">显示选项</strong>并取消勾选<strong class="kx jh">使用遗留SQL </strong>旁边的复选标记:</li></ol><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi gj"><img src="../Images/89e0059085594ca67f710e286c0fabe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4yJeFSf6PpclCW3i.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><ol class=""><li id="0813" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">在查询之前，添加#standardSQL行，并从新行开始查询:</li></ol><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d99c14fe96989b81252797ab6e1e5446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/0*lfii8SxAtBGW-zfy.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><h1 id="869e" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">从哪里开始</h1><p id="1ed2" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">首先，下载您的演示数据表，并将其上传到您的Google BigQuery项目。最简单的方法是使用OWOX BI BigQuery Reports 插件。</p><ol class=""><li id="49b6" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">打开Google Sheets并<a class="ae jd" href="https://gsuite.google.com/marketplace/app/owox_bi_bigquery_reports/263000453832?pann=cwsdp&amp;hl=en" rel="noopener ugc nofollow" target="_blank">安装OWOX BI BigQuery Reports插件</a>。</li><li id="7995" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">打开下载的包含演示数据的表格，选择<strong class="kx jh">OWOX BI big query Reports</strong>–&gt;<strong class="kx jh">上传数据到BigQuery </strong>:</li></ol><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/b680bb586dbc039525c2dec1f4f8e8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pqREiNBjUP25d141.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><ol class=""><li id="220e" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq nc mu mv mw bi translated">在打开的窗口中，选择您的Google BigQuery项目，一个数据集，并为将要存储加载数据的表想一个名称。</li><li id="2434" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq nc mu mv mw bi translated">指定加载数据的格式(如屏幕截图所示):</li></ol><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a170639d2584a56a657e2cd0920b8b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/0*QLPirR8PO4TEIse3.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="260c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您在Google BigQuery中没有项目，<a class="ae jd" href="https://cloud.google.com/bigquery/docs/quickstarts/quickstart-web-ui#before-you-begin" rel="noopener ugc nofollow" target="_blank">创建一个</a>。要做到这一点，你需要在谷歌云平台中有一个<a class="ae jd" href="https://cloud.google.com/billing/docs/how-to/manage-billing-account?visit_id=636776330112298770-3578127081&amp;rd=1" rel="noopener ugc nofollow" target="_blank">活跃的付费账户。不要让你需要链接银行卡吓到你:在你不知情的情况下，你不会被收取任何费用。此外，当你注册时，你会收到12个月的300美元，你可以用它来存储和处理数据。</a></p><p id="dbfb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在讨论Google BigQuery特性之前，让我们记住传统SQL和标准SQL方言中的基本查询是什么样的:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/a193c66e103cdfa6a3d5c84ee3d83955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EeN1LCzziLJO4MADPLJgw.png"/></div></div></figure><h1 id="4f8d" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">Google BigQuery特性</h1><p id="2aa4" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在构建查询时，您将最常使用聚合、日期、字符串和窗口函数。让我们仔细看看每一组函数。</p><h1 id="3600" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">聚合函数</h1><p id="f91e" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">聚合函数为整个表提供汇总值。例如，您可以使用它们来计算平均支票金额或每月总收入，或者您可以使用它们来选择购买次数最多的用户群。</p><p id="5a1b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些是最常用的聚合函数:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/cbc2b788e8f50d1329912e3076b07373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyXo4C7MZ4_6uTya8nRXBA.png"/></div></div></figure><p id="b3ff" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看演示数据，看看这些函数是如何工作的。我们可以计算交易的平均收入、最高和最低金额的购买、总收入、总交易和唯一交易的数量(以检查购买是否重复)。为此，我们将编写一个查询，在其中指定Google BigQuery项目的名称、数据集和表。</p><p id="9874" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#传统SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="40a0" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  <strong class="nn jh">AVG</strong>(revenue) <strong class="nn jh">as</strong> average_revenue,   <br/>  <strong class="nn jh">MAX</strong>(revenue) <strong class="nn jh">as</strong> max_revenue,   <br/>  <strong class="nn jh">MIN</strong>(revenue) <strong class="nn jh">as</strong> min_revenue,   <br/>  <strong class="nn jh">SUM</strong>(revenue) <strong class="nn jh">as</strong> whole_revenue,   <br/>  <strong class="nn jh">COUNT</strong>(transactionId) <strong class="nn jh">as</strong> transactions,      EXACT_COUNT_DISTINCT(transactionId) <strong class="nn jh">as</strong> unique_transactions <br/><strong class="nn jh">FROM</strong>   <br/>  [owox-analytics:t_kravchenko.Demo_data]</span></pre><p id="5a0a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#标准SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="e7f1" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  <strong class="nn jh">AVG</strong>(revenue) <strong class="nn jh">as</strong> average_revenue,   <br/>  <strong class="nn jh">MAX</strong>(revenue) <strong class="nn jh">as</strong> max_revenue,   <br/>  <strong class="nn jh">MIN</strong>(revenue) <strong class="nn jh">as</strong> min_revenue,   <br/>  <strong class="nn jh">SUM</strong>(revenue) <strong class="nn jh">as</strong> whole_revenue,   <br/>  <strong class="nn jh">COUNT</strong>(transactionId) <strong class="nn jh">as</strong> transactions,      <strong class="nn jh">COUNT</strong>(<strong class="nn jh">DISTINCT</strong>(transactionId)) <strong class="nn jh">as</strong> unique_transactions <br/><strong class="nn jh">FROM</strong>   <br/>  `owox-analytics.t_kravchenko.Demo_data`</span></pre><p id="3917" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果，我们将得到以下结果:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/21fc9b5b5559294dc58e041b36360ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ijX7VE2naeHg1LE2.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="5fdd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以使用标准的Google Sheets函数(SUM、AVG和其他函数)或使用数据透视表，在带有演示数据的原始表格中检查这些计算的结果。</p><p id="1a60" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的截图可以看出，交易数和唯一交易数是不一样的。这表明我们的表中有两个事务具有相同的transactionId:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/54c616e815756f9605f9418374cac7ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KtRsho1ddFoAXydp.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="baf2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您对唯一的事务感兴趣，请使用计算唯一字符串的函数。或者，您可以使用GROUP BY函数对数据进行分组，以便在应用聚合函数之前消除重复项。</p><h1 id="0bae" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">日期函数</h1><p id="89f0" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">这些函数允许您处理日期:更改它们的格式，选择必要的字段(日、月或年)，或者将日期移动一定的间隔。</p><p id="960f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下列情况下，它们可能有用:</p><ul class=""><li id="d3db" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">将不同来源的日期和时间转换为单一格式，以设置高级分析</li><li id="cc96" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">创建自动更新的报告或触发邮件(例如，当您需要过去两个小时、一周或一个月的数据时)</li><li id="1a44" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">创建<a class="ae jd" href="https://www.owox.com/blog/articles/what-is-cohort-analysis/" rel="noopener ugc nofollow" target="_blank">群组报告</a>，其中需要获取几天、几周或几个月的数据</li></ul><p id="fd54" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些是最常用的日期函数:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5afd7f73e859866379ca08874070a59a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*EPty1qcbUM61Qg9yFz4xMg.png"/></div></figure><p id="c9e0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有关所有日期函数的列表，请参见<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/legacy-sql#datetimefunctions" rel="noopener ugc nofollow" target="_blank">遗留SQL </a>和<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/date_functions" rel="noopener ugc nofollow" target="_blank">标准SQL </a>文档。</p><p id="ddaa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看我们的演示数据，看看这些函数是如何工作的。例如，我们将获取当前日期，将原始表中的日期转换为格式% YYYY -% MM-% DD，将其删除，并添加一天。然后，我们将计算当前日期和源表中的日期之间的差值，并将当前日期分成单独的年、月和日字段。为此，您可以复制下面的示例查询，并用您自己的查询替换项目名称、数据集和数据表。</p><p id="3ee0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#传统SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="6960" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>     </span><span id="0f57" class="nr ls jg nn b gy nz nt l nu nv"><strong class="nn jh">CURRENT_DATE</strong>() <strong class="nn jh">AS</strong> today,     <br/>DATE( date_UTC ) <strong class="nn jh">AS</strong> date_UTC_in_YYYYMMDD,    <br/><strong class="nn jh">DATE_ADD</strong>( date_UTC,1, 'DAY') <strong class="nn jh">AS</strong> date_UTC_plus_one_day,              <strong class="nn jh">DATE_ADD</strong>( date_UTC,-1, 'DAY') <strong class="nn jh">AS</strong> date_UTC_minus_one_day,     <strong class="nn jh">DATEDIFF</strong>(<strong class="nn jh">CURRENT_DATE</strong>(), date_UTC ) <strong class="nn jh">AS</strong> difference_between_date,     <strong class="nn jh">DAY</strong>( <strong class="nn jh">CURRENT_DATE</strong>() ) <strong class="nn jh">AS</strong> the_day,     <br/><strong class="nn jh">MONTH</strong>( <strong class="nn jh">CURRENT_DATE</strong>()) <strong class="nn jh">AS</strong> the_month,     <br/><strong class="nn jh">YEAR</strong>( <strong class="nn jh">CURRENT_DATE</strong>()) <strong class="nn jh">AS</strong> the_year   <br/><strong class="nn jh">FROM</strong>     <br/>  [owox-analytics:t_kravchenko.Demo_data]</span></pre><p id="6359" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#标准SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="7595" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong> <br/>  <br/>today,   <br/>date_UTC_in_YYYYMMDD,   <br/> <strong class="nn jh">DATE_ADD</strong>( date_UTC_in_YYYYMMDD, INTERVAL 1 <strong class="nn jh">DAY</strong>) <strong class="nn jh">AS</strong>                            date_UTC_plus_one_day,   <br/> <strong class="nn jh">DATE_SUB</strong>( date_UTC_in_YYYYMMDD,INTERVAL 1 <strong class="nn jh">DAY</strong>) <strong class="nn jh">AS</strong> date_UTC_minus_one_day,   <br/> DATE_DIFF(today, date_UTC_in_YYYYMMDD, <strong class="nn jh">DAY</strong>) <strong class="nn jh">AS</strong> difference_between_date,   <br/> <strong class="nn jh">EXTRACT</strong>(<strong class="nn jh">DAY</strong> <strong class="nn jh">FROM</strong> today ) <strong class="nn jh">AS</strong> the_day,   <br/> <strong class="nn jh">EXTRACT</strong>(<strong class="nn jh">MONTH</strong> <strong class="nn jh">FROM</strong> today ) <strong class="nn jh">AS</strong> the_month,   <br/> <strong class="nn jh">EXTRACT</strong>(<strong class="nn jh">YEAR</strong> <strong class="nn jh">FROM</strong> today ) <strong class="nn jh">AS</strong> the_year <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    <strong class="nn jh">CURRENT_DATE</strong>() <strong class="nn jh">AS</strong> today,     <br/>    DATE( date_UTC ) <strong class="nn jh">AS</strong> date_UTC_in_YYYYMMDD   <br/><strong class="nn jh">FROM</strong>     <br/>  `owox-analytics.t_kravchenko.Demo_data`)</span></pre><p id="cdbd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行查询后，您将收到以下报告:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/e113544b9c282b1f8471e40135037f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wu8653uKRVZ1Fk1P.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><h1 id="118d" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">字符串函数</h1><p id="8040" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">字符串函数允许您生成一个字符串，选择和替换子字符串，计算字符串的长度以及子字符串在原始字符串中的索引序列。例如，使用字符串函数，您可以:</p><ul class=""><li id="13cf" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">使用传递到页面URL的UTM标签过滤报表</li><li id="7fe8" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">如果源和活动名称写在不同的寄存器中，将数据转换为单一格式</li><li id="895f" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">替换报告中不正确的数据(例如，如果活动名称打印错误)</li></ul><p id="f715" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是处理字符串最常用的函数:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ob"><img src="../Images/61bf48b251620ba7b9cb2c12c1bef26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXP_Bx-KLwXfqEvrp5ZOng.png"/></div></div></figure><p id="4016" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/legacy-sql#stringfunctions" rel="noopener ugc nofollow" target="_blank">遗留SQL </a>和<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions" rel="noopener ugc nofollow" target="_blank">标准SQL </a>文档中了解更多关于所有字符串函数的信息。</p><p id="b431" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看演示数据，看看如何使用所描述的功能。假设我们有三个分别包含日、月和年值的列:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3ae393ad5c71c641a49558ac255ed4c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/0*wxYesfKr-aky8Pii.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="61b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这种格式的日期不太方便，所以我们可以将这些值合并到一列中。为此，请使用下面的SQL查询，并记住在Google BigQuery中替换您的项目、数据集和表的名称。</p><p id="89d3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#遗留SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="21eb" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  <strong class="nn jh">CONCAT</strong>(the_day,'-',the_month,'-',the_year) <strong class="nn jh">AS</strong> mix_string1 <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    31 <strong class="nn jh">AS</strong> the_day,     <br/>    12 <strong class="nn jh">AS</strong> the_month,     <br/>    2018 <strong class="nn jh">AS</strong> the_year   <br/>  <strong class="nn jh">FROM</strong>     <br/>    [owox-analytics:t_kravchenko.Demo_data]) <br/><strong class="nn jh">GROUP</strong> <strong class="nn jh">BY</strong>   <br/>  mix_string1</span></pre><p id="03a7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#标准SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="0ef9" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  <strong class="nn jh">CONCAT</strong>(the_day,'-',the_month,'-',the_year) <strong class="nn jh">AS</strong> mix_string1 <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    31 <strong class="nn jh">AS</strong> the_day,     <br/>    12 <strong class="nn jh">AS</strong> the_month,     <br/>    2018 <strong class="nn jh">AS</strong> the_year   <br/>  <strong class="nn jh">FROM</strong>     <br/>    owox-analytics.t_kravchenko.Demo_data) <br/><strong class="nn jh">GROUP</strong> <strong class="nn jh">BY</strong>   <br/>  mix_string1</span></pre><p id="a8fa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行查询后，我们在一列中收到日期:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e3b592440ff15d891396211de4c31fb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/0*ps84PySRbi_g22RD.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="c2ee" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常，当您在网站上下载页面时，URL会记录用户选择的变量的值。这可以是支付或交付方法、交易号、购买者想要提取物品的实体店的索引等。使用SQL查询，您可以从页面地址中选择这些参数。考虑两个例子来说明如何以及为什么要这样做。</p><p id="c053" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">例1 </strong>。假设我们想知道用户从实体店提货的购买次数。为此，我们需要计算从URL中包含子字符串shop_id(实体店的索引)的页面发送的交易数量。我们可以通过以下查询来实现这一点:</p><p id="21a6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#遗留SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="b0b6" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  <strong class="nn jh">COUNT</strong>(transactionId) <strong class="nn jh">AS</strong> transactions,   <br/>  <strong class="nn jh">check</strong> <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    transactionId,     <br/>    page CONTAINS 'shop_id' <strong class="nn jh">AS</strong> <strong class="nn jh">check</strong>   <br/><strong class="nn jh">FROM</strong>     <br/>  [owox-analytics:t_kravchenko.Demo_data]) <br/><strong class="nn jh">GROUP</strong> <strong class="nn jh">BY</strong>   <br/>  <strong class="nn jh">check</strong></span></pre><p id="c404" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#标准SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="8e77" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  <strong class="nn jh">COUNT</strong>(transactionId) <strong class="nn jh">AS</strong> transactions,   <br/>  check1,   <br/>  check2 <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    transactionId,     <br/>    REGEXP_CONTAINS( page, 'shop_id') <strong class="nn jh">AS</strong> check1,     <br/>    page <strong class="nn jh">LIKE</strong> '%shop_id%' <strong class="nn jh">AS</strong> check2   <br/><strong class="nn jh">FROM</strong>     <br/>  `owox-analytics.t_kravchenko.Demo_data`) <br/><strong class="nn jh">GROUP</strong> <strong class="nn jh">BY</strong>    <br/>  check1,   <br/>  check2</span></pre><p id="046a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从结果表中，我们看到5502个交易(check = true)是从包含shop_id的页面发送的:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/6f0c2eee7b40e3752a321ec7098bd371.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*r5aZH0FwHafWIWcm.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="6952" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">例二</strong>。您已经为每种交付方法分配了一个delivery_id，并在页面URL中指定了该参数的值。要找出用户选择了哪种交付方法，您需要在单独的列中选择delivery_id。</p><p id="9475" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们可以使用以下查询:</p><p id="2648" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#传统SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="ae69" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  page_lower_case,    <br/>  page_length,   <br/>  index_of_delivery_id,   <br/>  selected_delivery_id,   <br/>  <strong class="nn jh">REPLACE</strong>(selected_delivery_id, 'selected_delivery_id=', '') <strong class="nn jh">as</strong> delivery_id <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    page_lower_case,     <br/>    page_length,     <br/>    index_of_delivery_id,     <br/>    <strong class="nn jh">SUBSTR</strong>(page_lower_case, index_of_delivery_id) <strong class="nn jh">AS</strong> selected_delivery_id   <br/><strong class="nn jh">FROM</strong> (     <br/>  <strong class="nn jh">SELECT</strong>       <br/>    page_lower_case,       <br/>    <strong class="nn jh">LENGTH</strong>(page_lower_case) <strong class="nn jh">AS</strong> page_length,                 <strong class="nn jh">INSTR</strong>(page_lower_case, 'selected_delivery_id') <strong class="nn jh">AS</strong> index_of_delivery_id     <br/><strong class="nn jh">FROM</strong> (       <br/>  <strong class="nn jh">SELECT</strong>         <br/>    <strong class="nn jh">LOWER</strong>( page) <strong class="nn jh">AS</strong> page_lower_case,         <br/>    <strong class="nn jh">UPPER</strong>( page) <strong class="nn jh">AS</strong> page_upper_case       <br/><strong class="nn jh">FROM</strong>         <br/>  [owox-analytics:t_kravchenko.Demo_data]))) <br/><strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong>   <br/>  page_lower_case <strong class="nn jh">ASC</strong></span></pre><p id="69b4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#标准SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="5ce6" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  page_lower_case,   <br/>  page_length,   <br/>  index_of_delivery_id,   <br/>  selected_delivery_id,   <br/>  <strong class="nn jh">REPLACE</strong>(selected_delivery_id, 'selected_delivery_id=', '') <strong class="nn jh">AS</strong> delivery_id <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    page_lower_case,     <br/>    page_length,     <br/>    index_of_delivery_id,     <br/>    <strong class="nn jh">SUBSTR</strong>(page_lower_case, index_of_delivery_id) <strong class="nn jh">AS</strong> selected_delivery_id   <br/><strong class="nn jh">FROM</strong> (     <br/>  <strong class="nn jh">SELECT</strong>       <br/>    page_lower_case,       <br/>    <strong class="nn jh">CHAR_LENGTH</strong>(page_lower_case) <strong class="nn jh">AS</strong> page_length,         STRPOS(page_lower_case, 'selected_delivery_id') <strong class="nn jh">AS</strong> index_of_delivery_id     <br/><strong class="nn jh">FROM</strong> (       <br/>  <strong class="nn jh">SELECT</strong>         <br/>    <strong class="nn jh">LOWER</strong>( page) <strong class="nn jh">AS</strong> page_lower_case,         <br/>    <strong class="nn jh">UPPER</strong>( page) <strong class="nn jh">AS</strong> page_upper_case       <br/><strong class="nn jh">FROM</strong>         <br/>  `owox-analytics.t_kravchenko.Demo_data`))) <br/><strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong>   <br/>  page_lower_case <strong class="nn jh">ASC</strong></span></pre><p id="6550" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果，我们在Google BigQuery中得到这样一个表:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi of"><img src="../Images/91a77694b6638122cf0203eb03c184ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EgmcMg6j6UX_hf6T.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><h1 id="0bbc" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">窗口功能</h1><p id="67ce" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">这些函数类似于我们上面讨论的聚合函数。主要区别在于，窗口函数不在使用查询选择的整个数据集上执行计算，而只在部分数据上执行计算——子集或<em class="og">窗口</em>。</p><p id="1f52" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用窗口函数，您可以在组节中聚合数据，而无需使用JOIN函数来组合多个查询。例如，您可以计算每个广告活动的平均收入或每台设备的交易数量。通过向报表中添加另一个字段，您可以很容易地找到，例如，黑色星期五广告活动的收入份额或移动应用程序的交易份额。</p><p id="3cbc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了查询中的每个函数，您还必须详细说明定义窗口边界的OVER表达式。OVER包含您可以使用的三个组件:</p><ul class=""><li id="7c22" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">分区依据—定义将原始数据划分为子集的特征，如clientId或DayTime</li><li id="f329" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">排序依据-定义子集中行的顺序，例如小时DESC</li><li id="7bde" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">窗口框架-允许您处理特定要素子集内的行(例如，仅当前行之前的五行)</li></ul><p id="8233" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在此表中，我们收集了最常用的窗口函数:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/199308c26fc72dae549738cd1fe73b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*9eKJ_t2xzyPSsuI4xzyXvw.png"/></div></figure><p id="8ae5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/legacy-sql#syntax-window-functions" rel="noopener ugc nofollow" target="_blank">遗留SQL </a>和标准SQL的文档中看到所有<a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_analytic_functions" rel="noopener ugc nofollow" target="_blank">聚合分析函数和</a> <a class="ae jd" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions" rel="noopener ugc nofollow" target="_blank">导航函数</a>的列表。</p><p id="5360" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">例1 </strong>。假设我们想要分析客户在工作时间和非工作时间的活动。为此，我们需要将事务分为两组，并计算感兴趣的指标:</p><ul class=""><li id="a200" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">第1组—在9:00至18:00的工作时间内购买</li><li id="4f51" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">第2组—00:00至9:00和18:00至23:59的下班后购买</li></ul><p id="449b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了工作和非工作时间，形成窗口的另一个变量是clientId。也就是说，对于每个用户，我们将有两个窗口:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/2a2c7dd60318c337f057e8337e2b3958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mom5-4bvv67xdTfBzYh8gw.png"/></div></div></figure><p id="cadc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们使用演示数据来计算平均、最大、最小和总收入、交易总数，以及每个用户在工作时间和非工作时间的唯一交易数。下面的请求将帮助我们做到这一点。</p><p id="2ffa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#传统SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="d8a2" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  avg_revenue,   <br/>  max_revenue,   <br/>  min_revenue,   <br/>  sum_revenue,   <br/>  transactions,   <br/>  unique_transactions <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    date,     <br/>    clientId,     <br/>    DayTime,     <br/>    <strong class="nn jh">AVG</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> avg_revenue,     <br/>    <strong class="nn jh">MAX</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> max_revenue,     <br/>    <strong class="nn jh">MIN</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> min_revenue,     <br/>    <strong class="nn jh">SUM</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> sum_revenue,     <br/>    <strong class="nn jh">COUNT</strong>(transactionId) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> transactions,     <br/>    <strong class="nn jh">COUNT</strong>(<strong class="nn jh">DISTINCT</strong>(transactionId)) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> unique_transactions   <br/><strong class="nn jh">FROM</strong> (     <br/>  <strong class="nn jh">SELECT</strong>       <br/>    date,       <br/>    date_UTC,       <br/>    clientId,       <br/>    transactionId,       <br/>    revenue,       <br/>    page,       <br/>    <strong class="nn jh">hour</strong>,       <br/>    <strong class="nn jh">CASE</strong>         <br/>      <strong class="nn jh">WHEN</strong> <strong class="nn jh">hour</strong>&gt;=9 <strong class="nn jh">AND</strong> <strong class="nn jh">hour</strong>&lt;=18 <strong class="nn jh">THEN</strong> 'working hours'         <br/>      <strong class="nn jh">ELSE</strong> 'non-working hours'       <br/><strong class="nn jh">END</strong> <strong class="nn jh">AS</strong> DayTime     <br/><strong class="nn jh">FROM</strong>       <br/>  [owox-analytics:t_kravchenko.Demo_data])) <br/><strong class="nn jh">GROUP</strong> <strong class="nn jh">BY</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  avg_revenue,   <br/>  max_revenue,   <br/>  min_revenue,   <br/>  sum_revenue,   <br/>  transactions,   <br/>  unique_transactions <br/><strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong>   <br/>  transactions <strong class="nn jh">DESC</strong></span></pre><p id="4c5b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#标准SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="63ae" class="nr ls jg nn b gy ns nt l nu nv">#standardSQL <br/><strong class="nn jh">SELECT</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  avg_revenue,   <br/>  max_revenue,   <br/>  min_revenue,   <br/>  sum_revenue,   <br/>  transactions,   <br/>  unique_transactions <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    date,     <br/>    clientId,     <br/>    DayTime,     <br/>    <strong class="nn jh">AVG</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> avg_revenue,     <br/>    <strong class="nn jh">MAX</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> max_revenue,     <br/>    <strong class="nn jh">MIN</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> min_revenue,     <br/>    <strong class="nn jh">SUM</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> sum_revenue,     <br/>    <strong class="nn jh">COUNT</strong>(transactionId) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> transactions,     <br/>    <strong class="nn jh">COUNT</strong>(<strong class="nn jh">DISTINCT</strong>(transactionId)) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime) <strong class="nn jh">AS</strong> unique_transactions   <br/><strong class="nn jh">FROM</strong> (     <br/>  <strong class="nn jh">SELECT</strong>       <br/>    date,       <br/>    date_UTC,       <br/>    clientId,       <br/>    transactionId,       <br/>    revenue,       <br/>    page,       <br/>    <strong class="nn jh">hour</strong>,       <br/>    <strong class="nn jh">CASE</strong>         <br/>      <strong class="nn jh">WHEN</strong> <strong class="nn jh">hour</strong>&gt;=9 <strong class="nn jh">AND</strong> <strong class="nn jh">hour</strong>&lt;=18 <strong class="nn jh">THEN</strong> 'working hours'         <br/>      <strong class="nn jh">ELSE</strong> 'non-working hours'       <br/>    <strong class="nn jh">END</strong> <strong class="nn jh">AS</strong> DayTime     <br/><strong class="nn jh">FROM</strong>       <br/>  `owox-analytics.t_kravchenko.Demo_data`)) <br/><strong class="nn jh">GROUP</strong> <strong class="nn jh">BY</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  avg_revenue,   <br/>  max_revenue,   <br/>  min_revenue,   <br/>  sum_revenue,   <br/>  transactions,   <br/>  unique_transactions <br/><strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong>   <br/>  transactions <strong class="nn jh">DESC</strong></span></pre><p id="92af" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们以clientId为1020的用户为例，看看结果会怎样。56660.68668686661在该用户的原始表中，我们有以下数据:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5ae8f686873b811d6180d18e0840e8a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*rwfbEeCemIBSDqY2.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="205e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过运行该查询，我们将收到一份报告，其中包含来自该用户的平均、最小、最大和总收入，以及该用户的交易总数。正如您在下面的截图中看到的，这两笔交易都是用户在工作时间进行的:</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/9e58ab4a034b798a3fbb69d1ba04d8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ooie-wKikSVJSR1G.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="ee19" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">例二</strong>。现在是一个更复杂的任务:</p><ul class=""><li id="3e00" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">根据事务的执行时间，将所有事务的序列号放在窗口中。回想一下，我们通过用户和工作/非工作时隙来定义窗口。</li><li id="e454" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">报告窗口内下一个/上一个交易(相对于当前交易)的收入。</li><li id="9ab8" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">在窗口中显示第一笔和最后一笔交易的收入。</li></ul><p id="1984" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们将使用以下查询:</p><p id="71f7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#遗留SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="ac18" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  <strong class="nn jh">hour</strong>,   <br/>  <strong class="nn jh">rank</strong>,   <br/>  revenue,   <br/>  lead_revenue,   <br/>  lag_revenue,   <br/>  first_revenue_by_hour,   <br/>  last_revenue_by_hour <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    date,     <br/>    clientId,     <br/>    DayTime,     <br/>    <strong class="nn jh">hour</strong>,     <br/>    <strong class="nn jh">DENSE_RANK</strong>() <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> <strong class="nn jh">rank</strong>,     revenue,     <br/>    <strong class="nn jh">LEAD</strong>( revenue, 1) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> lead_revenue,     <br/>    LAG( revenue, 1) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> lag_revenue,     <br/>    <strong class="nn jh">FIRST_VALUE</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> first_revenue_by_hour,     <br/>    <strong class="nn jh">LAST_VALUE</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> last_revenue_by_hour   <br/><strong class="nn jh">FROM</strong> (     <br/>  <strong class="nn jh">SELECT</strong>       <br/>    date,       <br/>    date_UTC,       <br/>    clientId,       <br/>    transactionId,       <br/>    revenue,       <br/>    page,       <br/>    <strong class="nn jh">hour</strong>,       <br/>    <strong class="nn jh">CASE</strong>         <br/>      <strong class="nn jh">WHEN</strong> <strong class="nn jh">hour</strong>&gt;=9 <strong class="nn jh">AND</strong> <strong class="nn jh">hour</strong>&lt;=18 <strong class="nn jh">THEN</strong> 'working hours'         <br/>      <strong class="nn jh">ELSE</strong> 'non-working hours'       <br/>    <strong class="nn jh">END</strong> <strong class="nn jh">AS</strong> DayTime     <br/><strong class="nn jh">FROM</strong>       <br/>  [owox-analytics:t_kravchenko.Demo_data])) <br/><strong class="nn jh">GROUP</strong> <strong class="nn jh">BY</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  <strong class="nn jh">hour</strong>,   <br/>  <strong class="nn jh">rank</strong>,   <br/>  revenue,   <br/>  lead_revenue,   <br/>  lag_revenue,   <br/>  first_revenue_by_hour,   <br/>  last_revenue_by_hour <br/><strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  <strong class="nn jh">hour</strong>,   <br/>  <strong class="nn jh">rank</strong>,   <br/>  revenue,   <br/>  lead_revenue,   <br/>  lag_revenue,   <br/>  first_revenue_by_hour,   <br/>  last_revenue_by_hour</span></pre><p id="ee7e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">#标准SQL </strong></p><pre class="nd ne nf ng gt nm nn no np aw nq bi"><span id="ac9d" class="nr ls jg nn b gy ns nt l nu nv"><strong class="nn jh">SELECT</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  <strong class="nn jh">hour</strong>,   <br/>  <strong class="nn jh">rank</strong>,   <br/>  revenue,   <br/>  lead_revenue,   <br/>  lag_revenue,   <br/>  first_revenue_by_hour,   <br/>  last_revenue_by_hour <br/><strong class="nn jh">FROM</strong> (   <br/>  <strong class="nn jh">SELECT</strong>     <br/>    date,     <br/>    clientId,     <br/>    DayTime,     <br/>    <strong class="nn jh">hour</strong>,     <br/>    <strong class="nn jh">DENSE_RANK</strong>() <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> <strong class="nn jh">rank</strong>,     revenue,     <br/>    <strong class="nn jh">LEAD</strong>( revenue, 1) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> lead_revenue,     <br/>    LAG( revenue, 1) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> lag_revenue,     <br/>    <strong class="nn jh">FIRST_VALUE</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> first_revenue_by_hour,     <br/>    <strong class="nn jh">LAST_VALUE</strong>(revenue) <strong class="nn jh">OVER</strong> (<strong class="nn jh">PARTITION</strong> <strong class="nn jh">BY</strong> date, clientId, DayTime <strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong> <strong class="nn jh">hour</strong>) <strong class="nn jh">AS</strong> last_revenue_by_hour   <br/><strong class="nn jh">FROM</strong> (     <br/>  <strong class="nn jh">SELECT</strong>       <br/>    date,       <br/>    date_UTC,       <br/>    clientId,       <br/>    transactionId,       <br/>    revenue,       <br/>    page,       <br/>    <strong class="nn jh">hour</strong>,       <br/>    <strong class="nn jh">CASE</strong>         <br/>      <strong class="nn jh">WHEN</strong> <strong class="nn jh">hour</strong>&gt;=9 <strong class="nn jh">AND</strong> <strong class="nn jh">hour</strong>&lt;=18 <strong class="nn jh">THEN</strong> 'working hours'         <br/>      <strong class="nn jh">ELSE</strong> 'non-working hours'       <br/>   <strong class="nn jh">END</strong> <strong class="nn jh">AS</strong> DayTime     <br/><strong class="nn jh">FROM</strong>       <br/>  `owox-analytics.t_kravchenko.Demo_data`)) <br/><strong class="nn jh">GROUP</strong> <strong class="nn jh">BY</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  <strong class="nn jh">hour</strong>,   <br/>  <strong class="nn jh">rank</strong>,   <br/>  revenue,   <br/>  lead_revenue,   <br/>  lag_revenue,   <br/>  first_revenue_by_hour,   <br/>  last_revenue_by_hour <br/><strong class="nn jh">ORDER</strong> <strong class="nn jh">BY</strong>   <br/>  date,   <br/>  clientId,   <br/>  DayTime,   <br/>  <strong class="nn jh">hour</strong>,   <br/>  <strong class="nn jh">rank</strong>,   <br/>  revenue,   <br/>  lead_revenue,   <br/>  lag_revenue,   <br/>  first_revenue_by_hour,   <br/>  last_revenue_by_hour</span></pre><p id="5809" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用一个已知用户的例子来检查计算结果:clientId 10 204 2036767636767</p><figure class="nd ne nf ng gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/1be60a398ce731af11740d263a860eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MTGo8VG5Y1a0WJ_x.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者提供</p></figure><p id="26c9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的截图中，我们可以看到:</p><ul class=""><li id="1831" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">第一笔交易在15:00，第二笔交易在16:00</li><li id="c79e" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">15:00交易后，16:00有一笔交易，收入25066(列lead_revenue)</li><li id="024c" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">在16:00交易之前，15:00有一笔交易，收入3699(列lag_revenue)</li><li id="235e" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">窗口内的第一笔交易发生在15:00，此交易的收入为3699(first _ revenue _ by _ hour列)</li><li id="ca37" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">该查询逐行处理数据，因此对于所讨论的事务，窗口中的最后一个事务将是它本身，并且last_revenue_by_hour和revenue列中的值将是相同的</li></ul><h1 id="cab8" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">结论</h1><p id="4cdd" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在本文中，我们研究了最流行的函数组:聚合、日期、字符串和窗口。然而，Google BigQuery有许多更有用的功能，包括:</p><ul class=""><li id="d3fa" class="mo mp jg kx b ky kz lb lc le mq li mr lm ms lq mt mu mv mw bi translated">允许您将数据转换为特定格式的转换函数</li><li id="a37f" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">允许您访问数据集中多个表的表通配符函数</li><li id="8839" class="mo mp jg kx b ky mx lb my le mz li na lm nb lq mt mu mv mw bi translated">正则表达式函数，允许您描述搜索查询的模型，而不是它的确切值</li></ul></div></div>    
</body>
</html>