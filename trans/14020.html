<html>
<head>
<title>3 Ways to Build Neural Networks in TensorFlow with the Keras API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keras API在TensorFlow中构建神经网络的3种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-ways-to-build-neural-networks-in-tensorflow-with-the-keras-api-80e92d3b5b7e?source=collection_archive---------10-----------------------#2020-09-27">https://towardsdatascience.com/3-ways-to-build-neural-networks-in-tensorflow-with-the-keras-api-80e92d3b5b7e?source=collection_archive---------10-----------------------#2020-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在TensorFlow 2.x中使用Keras构建深度学习模型，可以使用<strong class="ak">顺序API </strong>、<strong class="ak">功能API </strong>和模型<strong class="ak">子类</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/13acf59edfb1a85e06e9f04ac958614f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzwKtnA0LEhiCGdWTTpLaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。顺序API、函数API、并行的子类化方法模型</p></figure><p id="1a1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你四处逛逛，查看不同的教程，进行谷歌搜索，花大量时间研究TensorFlow的堆栈溢出，你可能已经意识到有大量不同的方法来建立神经网络模型。长期以来，这一直是TensorFlow的一个问题。这几乎就像TensorFlow试图找到通往光明的深度学习环境的道路。如果你仔细想想，这正是正在发生的事情，对于2.x版本的库来说，这很正常。由于TensorFlow是迄今为止市场上最成熟的深度学习库，这基本上是你能得到的最好的库。</p><h1 id="66f0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">克拉斯-张量流关系</h1><h2 id="e5f3" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">一点背景</h2><p id="1333" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">TensorFlow向深度学习平台的进化不是一蹴而就的。最初，TensorFlow将自己推销为一个符号数学库，用于跨一系列任务的数据流编程。所以TensorFlow最初提供的价值主张并不是一个纯粹的机器学习库。目标是创建一个高效的数学库，以便在这个高效结构之上构建的定制机器学习算法可以在短时间内以高精度进行训练。</p><p id="fb25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，用低级API重复地从零开始构建模型并不是很理想。所以，谷歌工程师Franç ois Chollet开发了Keras，作为一个独立的高级深度学习库。虽然Keras已经能够在不同的库上运行，如TensorFlow、Microsoft Cognitive Toolkit、Theano或PlaidML，但TensorFlow过去是，现在仍然是人们使用Keras的最常见的库。</p><h2 id="efc6" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">现状</h2><p id="be95" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在看到模型构建过程的混乱之后，TensorFlow团队<a class="ae nd" href="https://blog.tensorflow.org/2019/01/whats-coming-in-tensorflow-2-0.html" rel="noopener ugc nofollow" target="_blank">宣布【Keras将成为用于在TensorFlow 2.0中构建和训练模型的核心高级API。另一个高级API</a><a class="ae nd" href="https://www.tensorflow.org/guide/estimator" rel="noopener ugc nofollow" target="_blank">Estimator API</a>，在这个声明之后，已经开始失去它已经逐渐减少的受欢迎程度。</p><h2 id="b800" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">Estimator API和Keras API</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/256a740c0c8f6af96531804c4ee6a515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_nEWx2lJTFXtq1pK8JAOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。Keras API和估算器API在张量流图中的位置</p></figure><p id="77fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们回到问题上:人们使用TensorFlow建立模型的方法有很多种。造成这个问题的主要原因是TensorFlow没有采用单一模型API。</p><p id="67c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在1.x版本中，对于生产级项目，最常用的模型构建API是Estimator API。但是，随着最近的变化，Keras API几乎赶上了Estimator API。最初，Estimator API更具可伸缩性，允许多种分布，并且具有方便的跨平台功能。然而，<a class="ae nd" href="https://www.reddit.com/r/tensorflow/comments/czr0ms/tf2_keras_vs_estimators/" rel="noopener ugc nofollow" target="_blank">Estimator API</a>的大部分优势现在都消失了，因此，很快Keras API可能会成为构建TensorFlow模型的单一标准API。</p><p id="ba1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在本文中，我们将只关注在TensorFlow中构建模型的Keras API方法，其中有三种方法:</p><ul class=""><li id="0d32" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">使用顺序API</li><li id="1f3e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">使用函数式API</li><li id="7150" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">模型子类化</li></ul><p id="1285" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将直接将它们与相应的模型构建代码进行比较，这样您就可以亲自测试它们了。让我们深入编码。</p><h1 id="c795" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">进行比较的初始代码</h1><p id="23c3" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">为了测试这三种Keras方法，我们需要选择一个深度学习问题。用MNIST进行图像分类是一项非常简单的任务。我们试图实现的是训练一个模型来识别手写数字，使用著名的MNIST数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/189ad591a961602ea3a569cf7064ab86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCtJmR_fzvMh98k9p2dp6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。基准分析的虚拟任务:MNIST图像分类</p></figure><p id="6d91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">MNIST数据集，代表修改的国家标准和技术研究所数据库，是一个手写数字的大型数据库，通常用于训练各种图像处理系统。MNIST数据库包含来自美国人口普查局员工和美国高中生的60，000幅训练图像和10，000幅测试图像。如果你想看完整的教程，你可以找到我关于<a class="ae nd" rel="noopener" target="_blank" href="/image-classification-in-10-minutes-with-mnist-dataset-54c35b77a38d">图像分类</a>的单独教程。</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/image-classification-in-10-minutes-with-mnist-dataset-54c35b77a38d"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">使用MNIST数据集在10分钟内完成图像分类</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">利用TensorFlow和Keras |监督深度学习使用卷积神经网络来分类手写数字</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><p id="f3ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用下面的代码，我们将导入所有的层和模型，这样在接下来的部分就不会打扰我们了。我们还下载了MNIST数据集并对其进行预处理，以便它可以用于我们将使用这三种不同方法构建的所有模型中。只需运行下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要点1。必要的进口，MNIST装载，预处理</p></figure><p id="d888" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，这部分就不碍事了，让我们把重点放在建立张量流模型的三种方法上。</p><h1 id="c271" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">构建Keras模型的3种方法</h1><p id="f5f3" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在TensorFlow中构建Keras模型有三种方法:</p><ul class=""><li id="d73f" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><strong class="la iu">顺序API: </strong>当你试图构建一个只有一个输入、输出和层分支的简单模型时，顺序API是最好的方法。对于想快速学习的新人来说，这是一个很好的选择。</li><li id="50aa" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="la iu">函数式API: </strong>函数式API是构建Keras模型最流行的方法。它能做顺序API能做的一切。此外，它允许多输入、多输出、分支和层共享。这是一种简洁易用的方法，并且仍然允许很好的定制灵活性。</li><li id="0dd3" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="la iu">模型子类化:</strong>模型子类化适用于需要完全控制他们的模型、层和训练过程的高级开发人员。您需要创建一个定义模型的定制类，并且您可能在日常任务中不需要它。但是，如果你是一个有实验需求的研究者，那么模型子类化可能是你最好的选择，因为它会给你所有你需要的灵活性。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/245fd4efc5c88aa5df032c95801fa93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoJOvO02YSNIydeYRSK68w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4。使用展平图层将二维图像阵列转换为一维阵列</p></figure><p id="a09e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看这些方法是如何实现的。我们将建立一个基本前馈神经网络，它具有一个平坦层，将二维图像阵列转换为一维阵列和两个密集层。</p><h2 id="8f07" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">顺序API</h2><p id="ede8" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在顺序API中，我们需要从tf.keras.Models模块创建一个顺序对象。我们可以简单地将所有层作为列表格式的单个参数传递，如下所示。如你所见，这很简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要点2。用Keras顺序API构建的前馈神经网络</p></figure><h2 id="0c42" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">功能API</h2><p id="c17e" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">对于函数式API，我们需要单独定义我们的输入。然后，我们需要创建一个输出对象，方法是创建所有相互关联并与输出关联的层。最后，我们创建一个模型对象，它接受输入和输出作为参数。代码仍然非常干净，但是我们在函数式API中有了更多的灵活性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要点三。用Keras Functional API构建的前馈神经网络</p></figure><h2 id="5599" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">模型子类化</h2><p id="f1bc" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">让我们继续讨论模型子类化。在模型子类化中，我们从创建一个扩展tf.keras.Model类的类开始。模型子类化有两个关键功能:</p><ul class=""><li id="7f93" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><strong class="la iu"> <em class="op"> __init__ </em> </strong> <em class="op"> </em>函数充当构造函数。多亏了<em class="op"> __init__ </em>，我们可以初始化模型的属性(<em class="op">例如层</em>)。<strong class="la iu"><em class="op"/></strong>用于调用父构造函数(构造函数在<em class="op"> tf.keras.Model </em>)和<strong class="la iu"> <em class="op"> self </em> </strong>用于引用实例属性(<em class="op">如图层</em>)。</li><li id="1de4" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><strong class="la iu"> <em class="op">调用</em> </strong>函数是在<em class="op"> __init__ </em>函数中定义图层后定义操作的地方。</li></ul><p id="dd61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了用模型子类化构建相同的模型，我们需要编写更多的代码，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要点4。基于Keras模型子类化的前馈神经网络</p></figure><h1 id="f2c2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结束代码</h1><p id="7571" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">既然您可以用三种不同的方法创建同一个模型，那么您可以选择其中的任何一种，构建模型，并运行下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要点5。模型配置、培训和评估</p></figure><p id="cdaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面几行负责模型配置、训练和评估。当我们比较这三种方法的性能时，我们看到它们非常接近，但略有不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表1。不同Keras方法的性能:顺序API、函数API和模型子类化</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/e8fe97271e130316842405a1d3887739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E27a0kkrw_ZKZlMb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jonathan Chng 在<a class="ae nd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2de6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们更复杂的模型子类化方法优于顺序API和函数API。这表明这些方法在低端的设计上也有细微的差别。然而，这些差异可以忽略不计。</p><h2 id="c74b" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">最终评估</h2><p id="dcba" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">到目前为止，您已经了解了这三种Keras方法之间的异同。但是，让我们用一个表格来总结一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表二。TensorFlow中构建Keras模型的不同方法比较:顺序API、函数API和模型子类化</p></figure><p id="6bf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，如果您刚刚开始，请坚持使用顺序API。当您深入到更复杂的模型时，尝试一下函数式API。如果你正在读博士或者只是喜欢进行独立的研究，试试模型子类化。如果你是专业人士，坚持使用功能API。它可能会满足你的需要。</p><p id="775d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="op">在评论中让我知道你最喜欢的建立Keras模型的方法。</em> </strong></p><h1 id="7cba" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">订阅邮件列表获取完整代码</h1><p id="20a4" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">如果你想在Google Colab上获得完整的代码，并获得我的最新内容，请订阅邮件列表:✉️</p><blockquote class="or"><p id="85c4" class="os ot it bd ou ov ow ox oy oz pa lt dk translated"><a class="ae nd" href="http://eepurl.com/hd6Xfv" rel="noopener ugc nofollow" target="_blank"> <em class="pb">现在就订阅</em> </a></p></blockquote><h1 id="45c4" class="lu lv it bd lw lx ly lz ma mb mc md me jz pc ka mg kc pd kd mi kf pe kg mk ml bi translated">喜欢这篇文章吗？</h1><p id="75cc" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">如果你喜欢这篇文章，可以考虑看看我的其他类似文章:</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/4-pre-trained-cnn-models-to-use-for-computer-vision-with-transfer-learning-885cb1b2dfc"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">4个预训练的CNN模型，用于具有迁移学习的计算机视觉</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用最先进的预训练神经网络模型，通过迁移学习解决计算机视觉问题</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="pf l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/fast-neural-style-transfer-in-5-minutes-with-tensorflow-hub-magenta-110b60431dcc"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">TensorFlow Hub &amp; Magenta在5分钟内实现快速神经风格转换</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">利用Magenta的任意图像风格化网络和深度学习，将梵高的独特风格转移到照片中</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="pg l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/image-classification-in-10-minutes-with-mnist-dataset-54c35b77a38d"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">使用MNIST数据集在10分钟内完成图像分类</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">利用TensorFlow和Keras |监督深度学习使用卷积神经网络来分类手写数字</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>