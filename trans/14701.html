<html>
<head>
<title>Adding Security to Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的代码添加安全性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/adding-security-to-your-code-1378ff123240?source=collection_archive---------21-----------------------#2020-10-10">https://towardsdatascience.com/adding-security-to-your-code-1378ff123240?source=collection_archive---------21-----------------------#2020-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1624" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这比你想象的要简单</h2></div><p id="9206" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我经常听到的一句话是“安全是每个人的责任”，但我注意到数据科学家经常过于关注他们需要知道的大量技能，以至于忽略了安全。除了有许多职责之外，我认为安全性似乎令人生畏，并且似乎需要大量的软件工程技能。实际上，在你的软件中实现最低级别的安全性是相当容易的。我建议遵循Charles Nwatu(网飞公司的安全主管，以前是StitchFix)的原则“做得更少更好”对我来说，这意味着成功地实现低级别的安全性比未能实现高级别的安全性要好。本文面向数据科学家(或python用户)，并且只假设您对命令行有一些基本的了解。</p><h1 id="7e37" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">安全工具的类型</h1><p id="f148" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">有两大类安全工具，静态和动态。动态安全工具针对运行中的软件运行以发现威胁，而静态工具针对源代码文件运行以发现问题。在本文中，我们将添加两个静态安全工具。第一个工具将检查以确保您没有向存储库添加密钥、秘密或密码，从而防止您暴露这些私人信息。第二个工具将帮助您检查软件依赖项是否存在安全威胁。</p><h1 id="4f59" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">Git秘密</h1><p id="e80a" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">Git Secrets是我们用来监控我们不想公开的信息的工具。在这里查阅它的报告<a class="ae mb" href="https://github.com/awslabs/git-secrets" rel="noopener ugc nofollow" target="_blank">，可以很容易地为你的操作系统安装它。一旦你安装了它，你可以用下面的命令添加我们想要寻找的东西:<code class="fe mc md me mf b">git secrets --add 'your-regular-expression'</code>阻止模式或者<code class="fe mc md me mf b">git secrets --add --literal 'your-literal-string'</code>阻止特定的字符串。作为一个例子，我将运行<code class="fe mc md me mf b">git secrets --add 'password ?=+ ?[A-Za-z0-9]+</code>,它将阻止如下内容:</a></p><ul class=""><li id="079c" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld ml mm mn mo bi translated">password = anyLengthPassword</li><li id="6f9f" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">password = passwordWithNoSpacesNextToEqualSign</li><li id="155d" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">password = = doubleEqualsBlockedToo</li></ul><p id="12a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但不会阻止这些:</p><ul class=""><li id="fd30" class="mg mh it kk b kl km ko kp kr mi kv mj kz mk ld ml mm mn mo bi translated">密码= " "</li><li id="399b" class="mg mh it kk b kl mp ko mq kr mr kv ms kz mt ld ml mm mn mo bi translated">密码=</li></ul><p id="2299" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好，因为它不会警告我们不要推送已经正确删除密码的代码。现在我运行<code class="fe mc md me mf b">git secrets --scan -r</code>来扫描所有文档中我添加的模式。它找到了我放在自述文件第一行的一个密码。以下是Git Secrets向我报告的内容:</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="8ac6" class="nc lf it mf b gy nd ne l nf ng">README.md:1:password = password12345<br/><br/>[ERROR] Matched one or more prohibited patterns<br/><br/>Possible mitigations:<br/>- Mark false positives as allowed using: git config --add secrets.allowed ...<br/>- Mark false positives as allowed by adding regular expressions to .gitallowed at repository's root directory<br/>- List your configured patterns: git config --get-all secrets.patterns<br/>- List your configured allowed patterns: git config --get-all secrets.allowed<br/>- List your configured allowed patterns in .gitallowed at repository's root directory<br/>- Use --no-verify if this is a one-time false positive</span></pre><p id="db0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我为这个特定的存储库设置了这些Git秘密配置，但是您可以设置一些全局配置来防止您在任何repo中推送任何秘密。用<code class="fe mc md me mf b">git secrets --add --global 'pattern or string here'</code>做这个。</p><h1 id="cc98" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">虚拟环境</h1><p id="6316" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">在之前的一篇文章中，我认为创建一个虚拟环境应该是你做任何项目的第一步。虚拟环境允许你为不同的项目隔离软件，所以如果你在一个项目上需要pandas版本0.25.3，而在另一个项目上需要pandas版本1.1.2，这不会有问题。</p><p id="a48b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你确实在使用python，你很可能会使用conda或virtualenv。用conda run <code class="fe mc md me mf b">conda create --name 'env-name' python='python-version'</code>创建虚拟环境，用virtualenv创建虚拟环境，使用<code class="fe mc md me mf b">virtualenv 'env-name'</code>。您可以将您的所有python包存储到一个通常称为requirements.txt的文件中，如果您希望在相同的环境中协作处理相同的代码，那么这个文件对于与他人共享非常有用。这是我所有的requirements.txt文件:</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="dfbc" class="nc lf it mf b gy nd ne l nf ng">numpy==1.16.0</span></pre><p id="7b57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要安装requirements.txt文件中的所有包，运行<code class="fe mc md me mf b">pip install -r requirements.txt</code>并生成requirements.txt文件，运行<code class="fe mc md me mf b">pip freeze &gt; requirements.txt</code>。</p><h1 id="4f4d" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">月初（beginning of month的缩写）</h1><p id="7362" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">根据2020年DevSecOps社区调查，28%的受访者表示他们至少有一次与开源工具相关的安全漏洞。那么，如何在这些安全威胁变成问题之前发现它们呢？通过使用物料清单(BOM ),它将描述您的项目使用的所有软件依赖项和库。然后，可以将该BOM与已发现的安全威胁的公共记录进行比较，这将引起您的注意。如果您已经在使用虚拟环境，那么requirements.txt文件可以作为python项目的BOM。现在让我们安装<a class="ae mb" href="https://pyup.io/safety/" rel="noopener ugc nofollow" target="_blank">安全</a>，它将扫描您的活动虚拟环境或requirements.txt文件，并将其与已知漏洞数据库的数据库进行比较。为此跑<code class="fe mc md me mf b">pip install safety</code>。作为一个警告，这个数据库每月只更新一次，要获得最新的安全威胁，你必须支付PyUp，安全背后的公司。但是请记住，“做得更少，更好。”</p><p id="d0e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您已经安装了它，您可以在活动环境中运行<code class="fe mc md me mf b">safety check</code>或者运行<code class="fe mc md me mf b">safety check -r requirements.txt</code>来检查requirements.txt文件。我这样做是针对我的需求文件，其中只有numpy版本1.16.0。以下是输出结果:</p><figure class="mu mv mw mx gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nh"><img src="../Images/e1700a2989c1e30815b86c9542d87ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzvVTmW9ichRvX3YcqcccA.png"/></div></div><p class="np nq gj gh gi nr ns bd b be z dk translated">安全检测器</p></figure><p id="8e7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我现在被警告numpy版本1.16.0中有安全威胁，我现在知道要升级到不同的版本。</p><h1 id="b366" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">在一个脚本中运行这些工具</h1><p id="50ac" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">我们可以将这两个命令放在一个shell脚本中，您可以随时执行该脚本。我用<code class="fe mc md me mf b">nano security.sh</code>打开了一个新的文本文档来放入这些内容。在这个文件中，我写道:</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="63ea" class="nc lf it mf b gy nd ne l nf ng">#!/bin/bash<br/># This script runs a security check<br/>git secrets --scan -r<br/>safety check -r requirements.txt</span></pre><p id="7555" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一行告诉我们bash的位置(您的可能不同)。有很多解释器，我希望bash(这是比较常见的一种)来执行这个脚本。第二行是一个常规的注释，告诉我们脚本做了什么。随着您对新工具的了解，您可以将它们添加到这个脚本中，这将使执行安全检查更加简单。</p><h1 id="696e" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">连续累计</h1><p id="05a1" class="pw-post-body-paragraph ki kj it kk b kl lw ju kn ko lx jx kq kr ly kt ku kv lz kx ky kz ma lb lc ld im bi translated">比偶尔运行这个脚本更好的是开始采用持续集成管道。持续集成是一次处理一小批代码，并频繁地将您的代码与一个主要分支集成的过程。当您整合您的代码时，您可以自动运行代码质量测试以及这些安全性检查。如果你这样做了，你会更快地了解问题，从而更快地减轻它们。</p><p id="bb3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了利用持续集成，您可能希望从为您的团队选择一个工具开始，比如CircleCI、TravisCI或Jenkins。这些工具可以在GitHub、Bitbucket或GitLab中连接到您的repo中，并在那里发生变化时开始执行。下面是一个Jenkinsfile的示例，您可以使用它来自动执行上述操作以及您可能在tests.py文件中编写的任何python测试。这将在你或你的任何队友推你的仓库时执行。</p><pre class="mu mv mw mx gt my mf mz na aw nb bi"><span id="c89e" class="nc lf it mf b gy nd ne l nf ng">pipeline {<br/>    agent any<br/>    stages {<br/>        stage('SecTest') {<br/>            steps {<br/>                sh '<!-- -->git secrets --scan -r<!-- -->'<br/>                sh '<!-- -->safety check -r requirements.txt<!-- -->'<br/>            }<br/>        }<br/>        stage('AppTest') {<br/>            steps {<br/>                sh 'python.exe tests.py'<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="e79d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您甚至可以添加额外的步骤，将您创建的任何机器学习模型或函数部署到该管道中。在我看来，一旦你采用了CI管道，高安全性和高质量的代码就更容易开发。希望这能让你开始提高代码的安全性！</p></div></div>    
</body>
</html>