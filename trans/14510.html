<html>
<head>
<title>Kickstarter with MLOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有MLOps的Kickstarter</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kickstarter-with-mlops-cc672d65731f?source=collection_archive---------43-----------------------#2020-10-06">https://towardsdatascience.com/kickstarter-with-mlops-cc672d65731f?source=collection_archive---------43-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="baa4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用PySpark和TensorFlow对kickstarter项目的成功进行分类。</h2></div><h1 id="8f9f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="0681" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对我来说，在99 %的情况下，在Kickstarter上支持发明者会导致多年等待一个永远不会出现在我家门口的产品。因此，让我们用一个惊人的kickstarter成功分类器来彻底解决这个问题。我们将使用<a class="ae lt" href="https://mlops.cloud" rel="noopener ugc nofollow" target="_blank"> MLOps平台</a>来获取我们的数据源(您可以在<a class="ae lt" href="https://www.kaggle.com/kemical/kickstarter-projects" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到它)，然后使用SDK在本地开发我们的预处理和建模脚本，最后将整个包提交到我们的AWS帐户，以对其进行版本控制并为生产做好准备。毕竟，这可能是一个真正的赚钱机器。</p><h1 id="b061" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">使用PySpark进行预处理</h1><p id="8ac6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有些人可能会认为对50 MB的数据集使用Spark可能有点大材小用。但我喜欢一致性和改进。毕竟，它对MB和TB一样有效。</p><p id="c5d4" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">让我们从定义我们的主要功能开始:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="f6c4" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">像往常一样，我使用MLOps平台生成脚本模板，从S3读取数据源。MLOps SDK为我们不想考虑的所有事情提供了一个很好的包装——比如读、写和版本控制转换，这样我就可以专注于<code class="fe mg mh mi mj b">my_transformations</code>中发生的事情。</p><p id="1dca" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">接下来，让我们定义我将使用的PySpark类:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="6067" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">这里没有什么特别的，普通的Spark预处理类以及导入的<a class="ae lt" href="https://docs.mlops.cloud/sdk/preprocessing/" rel="noopener ugc nofollow" target="_blank"> MLOps SDK </a>。</p><p id="353f" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们还需要我最喜欢的PySpark辅助函数，它将PySpark向量转换成列:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1f6e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">一旦我们完成了这些，我们就可以转到main函数了，它获取原始输入数据帧，执行所有转换，然后将其返回给main函数进行磁盘写入。我们从稍微清理一下数据帧开始，断言所有值都有正确的类型:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="74f9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们还通过减去项目的开始和结束时间来计算活动的总“在线”时间，并过滤掉一些小的子类，如非美元的货币(约10 %的数据)和非成功或失败的州(约6 %的数据)。</p><p id="bfaf" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">完成后，我们可以继续将所有分类字符串列转换为整数:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="00ec" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">完成后，我们可以继续缩放所有列。这是深度学习的重要一步，因为我们不想让我们的权重失控。我将使用<code class="fe mg mh mi mj b">StandardScaler</code>，一旦完成，我还将使用<code class="fe mg mh mi mj b">OneHotEncoder</code>将我的项目状态列(成功/失败)转换成一个hot编码表示，因为这是TensorFlow需要的格式:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="cdaa" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">需要注意的一件重要事情是<code class="fe mg mh mi mj b">OneHotEncoder</code>的<code class="fe mg mh mi mj b">dropLast=False</code>论点，你只能通过痛苦的经历来了解这一点。我知道他们有理由默认这个给<code class="fe mg mh mi mj b">True</code>，但是我真的认为有人在喝醉的时候决定的。</p><p id="1418" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">最后，我们可以将一个热编码向量分解成列，然后返回main:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="cf04" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">当我开发这个脚本时，我通过做<code class="fe mg mh mi mj b">pip install mlops-local</code>来使用平台内部可用的MLOps <a class="ae lt" href="https://docs.mlops.cloud/getting_started/local_mode/" rel="noopener ugc nofollow" target="_blank">本地测试环境</a>，这样我可以快速迭代数据的子集，直到我对我的转换满意为止:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/60cc625d67d2c2eeae1da082a9b6dae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxxvVNMU00yxb97OxR9rvQ.png"/></div></div></figure><p id="881b" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">然后，我可以在数据集视图中查看计算出的指标的最终结果:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mr"><img src="../Images/9af722db95f2ce9766b178ce5b04cc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQypQw2mq8VtJtERCPKAXA.png"/></div></div></figure><h1 id="58cb" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">使用TensorFlow训练</h1><p id="166c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">和往常一样，训练和预处理的设置是一样的。与预处理一样，我在main函数中有一点模板生成的代码，用于处理数据的读取、写入和发送回控制台。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="795b" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">除此之外，我有一个<code class="fe mg mh mi mj b">my_network</code>函数，在那里我定义了我的架构。在控制台中，我为脚本提供我的超参数，在这种情况下是<code class="fe mg mh mi mj b">batch_size</code>、<code class="fe mg mh mi mj b">learning_rate</code>和<code class="fe mg mh mi mj b">epochs</code>，然后在<code class="fe mg mh mi mj b">mlops.hyperparameters</code>下连同数据矩阵一起用于训练、验证和测试。我将运行20个时期，这可能会超出数据量:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ms"><img src="../Images/73989a031aa54f9646ed0892552bfb4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yNDfhKWVaQ6-ENcaZGQlw.png"/></div></div></figure><p id="a664" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">正如所料，我们看到一个快速上升到几乎96 %的准确性，然后停滞不前，损失变得疯狂。严重过度训练。但话说回来，它在测试集上获得了稳定的96 %的分数，这只是我玩玩而已。</p><h1 id="141d" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">投入生产</h1><p id="abd1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">既然我们对我们的模型如此满意，是时候利用它赚钱了，把它公之于众(其实不是，它藏在一个VPC里，可以从你的云服务中访问)。我将创建一个活动端点，这意味着一个24/7全天候运行的托管API，根据推理机的CPU利用率水平扩展实例。</p><p id="c485" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我还将设置10 %的数据采样百分比，这意味着对于每10个请求，MLOps平台将保存来自推理的输入和输出，并对数据漂移、模式正确性等进行分析。在这一点上，我可以稍后设置一个警报，通知我的DevOps团队，如果大便击中风扇:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mt"><img src="../Images/71f8ddf5fe2df6ef22285d4ce15ad855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rW0GUjXxBt3ytVIljAqCTg.png"/></div></div></figure><p id="77c8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">所以，对你来说这是一个端到端的魔术。希望很快在<a class="ae lt" href="https://join.slack.com/t/mlops-communitygroup/shared_invite/zt-f27d828w-XuVpXs0NIA9jJTOIYHdk1g" rel="noopener ugc nofollow" target="_blank"> Slack社区</a>与您见面，在这里我们将从数据工程、数据科学和DevOps的角度讨论机器学习和操作，以及它们如何融合在一起！</p></div></div>    
</body>
</html>