<html>
<head>
<title>Predicate vs Projection Pushdown in Spark 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark 3中的谓词与投影下推</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicate-vs-projection-pushdown-in-spark-3-ac24c4d11855?source=collection_archive---------7-----------------------#2020-11-05">https://towardsdatascience.com/predicate-vs-projection-pushdown-in-spark-3-ac24c4d11855?source=collection_archive---------7-----------------------#2020-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3796" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">谓词和投影下推及其在PySpark 3中实现的比较</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9fd66b41f4ef2eff9d45b6935cb7160e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SABnYfT-DtAuwGOgkqs79g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(<a class="ae kv" href="https://unsplash.com/photos/LqKhnDzSF-8" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><p id="e35f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理大数据伴随着大量处理成本和花费大量时间扩展这些成本的挑战。It需要了解适当的大数据过滤技术，以便从中受益。对于希望在过滤子领域(尤其是在嵌套结构化数据上)使用<a class="ae kv" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>的最新增强功能的数据科学家和数据工程师来说，这篇文章是必不可少的。</p><h1 id="ca3b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Spark 2.x和Spark 3.0在嵌套过滤方面的差异</h1><p id="e1a5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">用<strong class="ky ir"> Spark 2.x </strong>，用<strong class="ky ir">最大2级嵌套结构的文件。json </strong>和<strong class="ky ir">。拼花地板</strong>扩展可以被读取。</p><blockquote class="mp mq mr"><p id="206c" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir">示例:</strong></p><p id="c032" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">过滤器(col(' <strong class="ky ir"> library.books </strong>')。isNotNull())</p></blockquote><p id="fff0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<a class="ae kv" href="https://spark.apache.org/releases/spark-release-3-0-0.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Spark 3 </strong> </a>，现在可以同时使用<strong class="ky ir"><em class="ms"/></strong>和<strong class="ky ir"> <em class="ms">读取文件。2+级嵌套结构中的snappy parquet </em> </strong>扩展，无需任何模式展平操作。</p><blockquote class="mp mq mr"><p id="6471" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated"><strong class="ky ir">例如:</strong></p><p id="43cd" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">过滤器(col('<strong class="ky ir">library . books . title</strong>')。isNotNull())</p></blockquote><h2 id="4c7a" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated">用于下推过滤的火花会话配置</h2><p id="cd8f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">创建spark会话时，应启用以下配置，以使用Spark 3的下推功能。默认情况下，链接到<em class="ms">下推过滤</em>活动的设置值被激活。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="8e7a" class="mw lt iq nj b gy nn no l np nq">"spark.sql.parquet.filterPushdown", "true"<br/>"spark.hadoop.parquet.filter.stats.enabled", "true"<br/>"spark.sql.optimizer.nestedSchemaPruning.enabled","true"<br/>"spark.sql.optimizer.dynamicPartitionPruning.enabled", "true"</span></pre><p id="b989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spark中有<strong class="ky ir">和</strong>两种下推过滤技术，分别是<strong class="ky ir">谓词下推</strong>和<strong class="ky ir">投影下推</strong>，它们具有以下不同的特性，如本文以下部分所述。</p><h1 id="82a3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.谓词下推</h1><p id="4dbd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">谓词下推</strong>指向影响返回行数的<strong class="ky ir"> where </strong>或<strong class="ky ir">过滤器</strong>子句。基本上关系到<strong class="ky ir">哪些行</strong> <strong class="ky ir">会被过滤，而不是哪些列</strong>。由于这个原因，在嵌套列上应用过滤器作为<strong class="ky ir"><em class="ms">【library . books】</em></strong>仅仅返回值不为空的记录时，谓词下推函数将使parquet读取指定列中不包含空值的块。</p><h2 id="108f" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated">1.1.带有分区修剪的谓词下推</h2><p id="82cc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">分区消除技术允许在从相应的文件系统读取文件夹时优化性能，以便可以读取指定分区中的所需文件。它将致力于将数据过滤转移到尽可能靠近源的位置，以防止将不必要的数据保存在内存中，从而减少磁盘I/O。</p><p id="e2f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面，可以观察到filter of partition的下推动作，也就是<em class="ms">' library . books . title ' = ' HOST '</em>filter被下推进入<em class="ms"> parquet </em>文件扫描。该操作能够最小化文件和扫描数据。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="c9f1" class="mw lt iq nj b gy nn no l np nq">data.filter(col('library.books.title') == 'THE HOST').explain()</span></pre><p id="dab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于更详细的输出，包括<em class="ms">解析的逻辑计划、分析的逻辑计划、优化的逻辑计划、物理计划、</em><strong class="ky ir"/><em class="ms">‘扩展’</em><strong class="ky ir"/>参数可以添加到explain()函数中，如下所示。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="513a" class="mw lt iq nj b gy nn no l np nq">data.filter(col('library.books.title') == 'THE HOST').explain(<strong class="nj ir">'extended'</strong>)</span></pre><p id="8435" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它还可以减少传递回Spark引擎的数据量，以便在'<em class="ms"> price' </em>列的聚合函数中进行平均运算。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="da32" class="mw lt iq nj b gy nn no l np nq">data.filter(col('library.books.title') == 'THE HOST').groupBy('publisher').agg(avg('price')).explain()</span></pre><p id="55f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Parquet格式的文件为每一列保留了一些不同的统计指标，包括它们的最小值和最大值。谓词下推有助于跳过不相关的数据，处理所需的数据。</p><h1 id="6ff5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.投影下推</h1><p id="e2b2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir"> Projection Pushdown </strong>代表带有<strong class="ky ir"> select </strong>子句的选定列，该子句影响返回的列数。它将数据存储在<strong class="ky ir">列</strong>中，因此当您的投影将查询限制到指定的列时，将会返回这些列。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="621c" class="mw lt iq nj b gy nn no l np nq">data.select('library.books.title','library.books.author').explain()</span></pre><p id="f15a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着对<em class="ms">‘library . books . title’，‘library . books . author’</em><br/>列的扫描意味着在将数据发送回Spark引擎之前，将在文件系统/数据库中进行扫描。</p><h2 id="29fc" class="mw lt iq bd lu mx my dn ly mz na dp mc lf nb nc me lj nd ne mg ln nf ng mi nh bi translated"><strong class="ak">结论</strong></h2><p id="0e49" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于<strong class="ky ir">投影</strong>和<strong class="ky ir">谓词下推</strong>，有一些关键点需要强调。<strong class="ky ir">下推过滤</strong>作用于分区的列，这些列是根据拼花格式文件的性质计算的。为了能够从中获得最大的好处，分区列应该携带具有足够匹配数据的较小值，以便将正确的文件分散到目录中。</p><p id="5141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">防止过多的小文件会导致扫描效率因过度并行而降低。此外，阻止接受太少的大文件可能会损害并行性。</p><p id="c8e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">投影下推</strong>功能通过消除表格扫描过程中不必要的字段，使文件系统/数据库和Spark引擎之间的数据传输最小化。它主要在数据集包含太多列时有用。</p><p id="a57c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，<strong class="ky ir">谓词下推</strong>通过在过滤数据时减少文件系统/数据库和Spark引擎之间传递的数据量来提高性能。</p><p id="8d6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">投影下推</strong>通过<strong class="ky ir">基于列的</strong>和<strong class="ky ir">谓词下推</strong>通过<strong class="ky ir">基于行的过滤</strong>来区分。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="3554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢您的提问和评论！</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="e3be" class="ls lt iq bd lu lv ny lx ly lz nz mb mc jw oa jx me jz ob ka mg kc oc kd mi mj bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="4243" class="od oe iq ky b kz mk lc ml lf of lj og ln oh lr oi oj ok ol bi translated"><a class="ae kv" href="https://spark.apache.org/releases/spark-release-3-0-0.html" rel="noopener ugc nofollow" target="_blank">火花释放3.0.0 </a></li><li id="4d4b" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr oi oj ok ol bi translated"><a class="ae kv" href="https://issues.apache.org/jira/browse/SPARK-27699" rel="noopener ugc nofollow" target="_blank">下推析取谓词</a></li><li id="46d4" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr oi oj ok ol bi translated"><a class="ae kv" href="https://issues.apache.org/jira/browse/SPARK-25603" rel="noopener ugc nofollow" target="_blank">一般化嵌套列修剪</a></li><li id="d2c1" class="od oe iq ky b kz om lc on lf oo lj op ln oq lr oi oj ok ol bi translated"><a class="ae kv" href="https://issues.apache.org/jira/browse/SPARK-17636" rel="noopener ugc nofollow" target="_blank">嵌套字段的Parquet谓词下推</a></li></ol></div></div>    
</body>
</html>