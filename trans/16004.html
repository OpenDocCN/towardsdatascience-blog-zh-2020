<html>
<head>
<title>30 Examples to Master Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握熊猫的30个例子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/30-examples-to-master-pandas-f8a2da751fa4?source=collection_archive---------2-----------------------#2020-11-04">https://towardsdatascience.com/30-examples-to-master-pandas-f8a2da751fa4?source=collection_archive---------2-----------------------#2020-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e59f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习熊猫的综合实践指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae1c0fc825ef8eb2db5765c251167519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fG5RLd48iOZezB_y.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hengfilms?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">恒电影</a>在<a class="ae ky" href="https://unsplash.com/@hengfilms?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4b45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas是一个广泛使用的Python数据分析和操作库。它提供了许多加快数据分析和预处理步骤的功能和方法。</p><p id="1b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它的流行，有许多关于熊猫的文章和教程。这一个将会是其中之一，但是非常注重实际的一面。我将在Kaggle上的<a class="ae ky" href="https://www.kaggle.com/shubh0799/churn-modelling" rel="noopener ugc nofollow" target="_blank">客户流失数据集</a>上做例子。</p><p id="93ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些示例将涵盖您可能在典型的数据分析过程中使用的几乎所有函数和方法。</p><p id="64cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从将csv文件读入熊猫数据帧开始。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="07b2" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd</span><span id="f6ce" class="ma mb it lw b gy mg md l me mf">df = pd.read_csv("/content/churn.csv")</span><span id="ecd0" class="ma mb it lw b gy mg md l me mf">df.shape<br/>(10000,14)</span><span id="fc5f" class="ma mb it lw b gy mg md l me mf">df.columns<br/>Index(['RowNumber', 'CustomerId', 'Surname', 'CreditScore', 'Geography', 'Gender', 'Age', 'Tenure', 'Balance', 'NumOfProducts', 'HasCrCard','IsActiveMember','EstimatedSalary', 'Exited'], dtype='object')</span></pre><h2 id="16ca" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated"><strong class="ak"> 1。删除列</strong></h2><p id="fdfe" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">drop函数用于删除列和行。我们传递要删除的行或列的标签。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="82cb" class="ma mb it lw b gy mc md l me mf">df.drop(['RowNumber', 'CustomerId', 'Surname', 'CreditScore'], axis=1, inplace=True)</span><span id="0e3d" class="ma mb it lw b gy mg md l me mf">df.shape<br/>(10000,10)</span></pre><p id="f316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">axis参数设置为1表示删除列，设置为0表示删除行。将inplace参数设置为True以保存更改。我们删除了4列，所以列数从14列减少到了10列。</p><h2 id="bb5a" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">2.阅读时选择特定的列</h2><p id="1da4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们只能从csv文件中读取一些列。读取时，列的列表被传递给usecols参数。如果您事先知道列名，这比以后再删除要好。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f5e4" class="ma mb it lw b gy mc md l me mf">df_spec = pd.read_csv("/content/churn.csv", usecols=['Gender', 'Age', 'Tenure', 'Balance'])</span><span id="4080" class="ma mb it lw b gy mg md l me mf">df_spec.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9d39cd96fc206c31316baa7f17ccc3cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*LTLrkdzOo6pKtc49UYvemg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="5b76" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">3.读取数据帧的一部分</h2><p id="079e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">read_csv函数允许按照行读取数据帧的一部分。有两个选择。第一个是读取前n行。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0d2a" class="ma mb it lw b gy mc md l me mf">df_partial = pd.read_csv("/content/churn.csv", nrows=5000)</span><span id="51ea" class="ma mb it lw b gy mg md l me mf">df_partial.shape<br/>(5000,14)</span></pre><p id="4f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用nrows参数，我们创建了一个包含csv文件前5000行的数据帧。</p><p id="a407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用skiprows参数从文件的末尾选择行。Skiprows=5000意味着我们在读取csv文件时将跳过前5000行。</p><h2 id="b2e8" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">4.样品</h2><p id="6c24" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">创建数据帧后，我们可能想要绘制一个小样本来工作。我们可以使用n参数或frac参数来确定样本大小。</p><ul class=""><li id="a992" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">n:样本中的行数</li><li id="070c" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">frac:样本大小与整个数据框架大小的比率</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5e5a" class="ma mb it lw b gy mc md l me mf">df_sample = df.sample(n=1000)<br/>df_sample.shape<br/>(1000,10)</span><span id="1c36" class="ma mb it lw b gy mg md l me mf">df_sample2 = df.sample(frac=0.1)<br/>df_sample2.shape<br/>(1000,10)</span></pre><h2 id="ce9d" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">5.检查缺少的值</h2><p id="5825" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">isna函数确定数据帧中缺失的值。通过将isna与sum函数结合使用，我们可以看到每一列中缺失值的数量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6d6a" class="ma mb it lw b gy mc md l me mf">df.isna().sum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/13a6a51b91e0296ef20a81cd77073fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*nUjcX2lBUiIMV2fBKSsR7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有丢失的值。</p><h2 id="4c5e" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">6.使用loc和iloc添加缺失值</h2><p id="8503" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我做这个例子是为了练习“loc”和“iloc”。这些方法基于索引或标签选择行和列。</p><ul class=""><li id="d1cc" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">loc:使用标签选择</li><li id="3e6c" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">iloc:带索引选择</li></ul><p id="db3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先创建20个随机指数来选择。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="23c9" class="ma mb it lw b gy mc md l me mf">missing_index = np.random.randint(10000, size=20)</span></pre><p id="d3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用这些索引将一些值更改为np.nan(缺失值)。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8caf" class="ma mb it lw b gy mc md l me mf">df.loc[missing_index, ['Balance','Geography']] = np.nan</span></pre><p id="7106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“余额”和“地理位置”列中缺少20个值。让我们用索引代替标签来做另一个例子。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3344" class="ma mb it lw b gy mc md l me mf">df.iloc[missing_index, -1] = np.nan</span></pre><p id="9e72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“-1”是“已退出”的最后一列的索引。</p><p id="c671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们对loc和iloc使用了不同的列表示，但是行值没有改变。原因是我们正在使用数字索引标签。因此，行的标签和索引是相同的。</p><p id="a55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">丢失值的数量已更改:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e4273ca99ffab6599a1bc0fefd46fb12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*kkHER9aVhiFQOCPN1C2Fjw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="62b1" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">7.填充缺失值</h2><p id="f696" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">fillna函数用于填充缺失的值。它提供了许多选项。我们可以使用特定的值、聚合函数(例如平均值)，或者前一个或下一个值。</p><p id="360d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于geography列，我将使用最常见的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/7f065f4c93e2165a177a62a4ce32e1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*WtLnPxW5674JYxCPX68T3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="81fc" class="ma mb it lw b gy mc md l me mf">mode = df['Geography'].value_counts().index[0]<br/>df['Geography'].fillna(value=mode, inplace=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/958efbd342b7e805e4398bc1f9e2944e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*YePo3xpvmIPVIWOpV_C1qg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="bd8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对于balance列，我将使用该列的平均值来替换缺失的值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f71d" class="ma mb it lw b gy mc md l me mf">avg = df['Balance'].mean()<br/>df['Balance'].fillna(value=avg, inplace=True)</span></pre><p id="6c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fillna函数的method参数可用于根据列中的上一个或下一个值填充缺失值(例如method='ffill ')。这对于序列数据(例如时间序列)非常有用。</p><h2 id="3952" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">8.删除丢失的值</h2><p id="858a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">处理缺失值的另一种方法是删除它们。“已退出”列中仍有缺失值。下面的代码将删除任何缺少值的行。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8925" class="ma mb it lw b gy mc md l me mf">df.dropna(axis=0, how='any', inplace=True)</span></pre><p id="3bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">轴=1用于删除缺少值的列。我们还可以为一列或一行所需的非缺失值的数量设置一个阈值。例如，thresh=5意味着一行必须至少有5个非缺失值才不会被删除。缺少4个或更少值的行将被删除。</p><p id="3f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dataframe现在没有任何缺失值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="eabf" class="ma mb it lw b gy mc md l me mf">df.isna().sum().sum()<br/>0</span></pre><h2 id="f664" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">9.基于条件选择行</h2><p id="8559" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在某些情况下，我们需要符合某些条件的观察值(即行)。例如，下面的代码将选择居住在法国的客户。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0700" class="ma mb it lw b gy mc md l me mf">france_churn = df[(df.Geography == 'France') &amp; (df.Exited == 1)]</span><span id="6190" class="ma mb it lw b gy mg md l me mf">france_churn.Geography.value_counts()<br/>France    808</span></pre><h2 id="1ea8" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">10.用查询描述条件</h2><p id="d87a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">查询函数提供了一种更灵活的传递条件的方式。我们可以用字符串来描述它们。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e35a" class="ma mb it lw b gy mc md l me mf">df2 = df.query('80000 &lt; Balance &lt; 100000')</span></pre><p id="5d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过绘制余额柱的直方图来确认结果。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0f37" class="ma mb it lw b gy mc md l me mf">df2['Balance'].plot(kind='hist', figsize=(8,5))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/dfa818321510efaf71aacb8f6d53bcae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*q5AaDVKAz055w4zqtLyG9Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="8843" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">11.用isin描述条件</h2><p id="f692" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">条件可能有几个值。在这种情况下，最好使用isin方法，而不是单独写入值。</p><p id="1735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是传递一个所需值的列表。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ad48" class="ma mb it lw b gy mc md l me mf">df[df['Tenure'].isin([4,6,9,10])][:3]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/fc3f50063eff3b172680fdbe012ae9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*cwR5qSLANCM8v7dzbWJ3Hw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="9963" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">12.groupby函数</h2><p id="1b25" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Pandas <strong class="lb iu"> Groupby </strong>函数是一个多功能且易于使用的函数，有助于获得数据的概览。这使得探索数据集和揭示变量之间的潜在关系变得更加容易。</p><p id="5557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将做几个groupby函数的例子。先说一个简单的。下面的代码将根据地理-性别组合对行进行分组，然后给出每组的平均流失率。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3f7c" class="ma mb it lw b gy mc md l me mf">df[['Geography','Gender','Exited']].groupby(['Geography','Gender']).mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/fd6114b477ac0536ed357a680ec9ce82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*S24451H5V916H5_dA0c02g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="42cc" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">13.通过groupby应用多个聚合函数</h2><p id="46ea" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">agg函数允许对组应用多个聚合函数。函数列表作为参数传递。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0b46" class="ma mb it lw b gy mc md l me mf">df[['Geography','Gender','Exited']].groupby(['Geography','Gender']).agg(['mean','count'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/67c6c65c6bc27e5c98088d638bde60fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*rJTu_8Unr21vNsqnpKN4IA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到每个组中的观察计数(行)和平均流失率。</p><h2 id="0b94" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">14.对不同的组应用不同的聚合函数</h2><p id="6189" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们不必对所有列应用相同的函数。例如，我们可能希望看到每个国家的平均余额和客户总数。</p><p id="bd01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将传递一个字典，指示哪些函数将应用于哪些列。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b2d8" class="ma mb it lw b gy mc md l me mf">df_summary = df[['Geography','Exited','Balance']].groupby('Geography')\<br/>.agg({'Exited':'sum', 'Balance':'mean'})</span><span id="03f4" class="ma mb it lw b gy mg md l me mf">df_summary.rename(columns={'Exited':'# of churned customers', 'Balance':'Average Balance of Customers'},inplace=True)</span><span id="41ce" class="ma mb it lw b gy mg md l me mf">df_summary</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0b29bf8067867c79c542a47fea240869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*lcmbXz5fTdZ5JXvNU2UMBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="81fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还重命名了这些列。</p><p id="ef0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="oa">编辑</em> </strong>:感谢罗恩在评论区的提醒。NamedAgg函数允许重命名聚合中的列。语法如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1d00" class="ma mb it lw b gy mc md l me mf">df_summary = df[['Geography','Exited','Balance']].groupby('Geography')\<br/>.agg(<br/> Number_of_churned_customers = pd.NamedAgg('Exited', 'Sum'),<br/> Average_balance_of_customers = pd.NamedAgg('Balance', 'Mean')<br/>)</span></pre><h2 id="68c2" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">15.重置索引</h2><p id="2307" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可能已经注意到，groupby返回的数据帧的索引由组名组成。我们可以通过重置索引来改变它。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ba8b" class="ma mb it lw b gy mc md l me mf">df_new = df[['Geography','Exited','Balance']]\<br/>.groupby(['Geography','Exited']).mean().reset_index()</span><span id="4427" class="ma mb it lw b gy mg md l me mf">df_new</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/65b0f785c06cd8ce65b4ef71ee421af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*WAowSGpsglm7o_zTmPvM-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="54cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="oa">编辑</em> </strong>:感谢罗恩在评论区的提醒。如果我们将groupby函数的as_index参数设置为False，那么组名将不会用作索引。</p><h2 id="bd6a" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">16.用drop重置索引</h2><p id="e1d7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在某些情况下，我们需要重置索引，同时删除原始索引。考虑从数据帧中抽取样本的情况。该示例将保留原始数据帧的索引，因此我们希望重置它。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e941" class="ma mb it lw b gy mc md l me mf">df[['Geography','Exited','Balance']].sample(n=6).reset_index()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ed46107402d4aa4c5443db5ae49bc34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*EpuVQGeWXspiM187vD4vWQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引被重置，但原始索引作为新列保留。我们可以在重置索引时删除它。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ee1d" class="ma mb it lw b gy mc md l me mf">df[['Geography','Exited','Balance']]\<br/>.sample(n=6).reset_index(drop=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/ba09e828541224b63399ae47fb297b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*H9yVyQM9GndnGQeFoLFQaQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="e09b" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">17.将特定列设置为索引</h2><p id="8fca" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以将数据帧中的任何一列设置为索引。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5ae4" class="ma mb it lw b gy mc md l me mf">df_new.set_index('Geography')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/90a5b56023c2f8479ba7cc4c0c8088ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*n9SeTw5tOxz7TCGfFQoiow.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="00b0" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">18.插入新列</h2><p id="865b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以向数据帧添加一个新列，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3c15" class="ma mb it lw b gy mc md l me mf">group = np.random.randint(10, size=6)<br/>df_new['Group'] = group</span><span id="1fc6" class="ma mb it lw b gy mg md l me mf">df_new</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/9ffa77a377826e9847fffa9ebce8313a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*xRurn94JWFpx7hbGmO2BsA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="61ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是新列被添加在末尾。如果想把新列放在特定的位置，可以使用insert函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="114d" class="ma mb it lw b gy mc md l me mf">df_new.insert(0, 'Group', group)</span><span id="9421" class="ma mb it lw b gy mg md l me mf">df_new</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/edf64319b4d7f68948acd29a54eb82b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*rYQ-c2Mxz2dVojVmFpcK-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="920b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是位置的索引，第二个是列的名称，第三个是值。</p><h2 id="5c69" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">19.where函数</h2><p id="9b1b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">它用于根据条件替换行或列中的值。默认的替换值是NaN，但是我们也可以指定替换值。</p><p id="94a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑上一步中的数据帧(df_new)。对于属于小于6的组的客户，我们希望将余额设置为0。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="81d4" class="ma mb it lw b gy mc md l me mf">df_new['Balance'] = df_new['Balance'].where(df_new['Group'] &gt;= 6, 0)</span><span id="80ee" class="ma mb it lw b gy mg md l me mf">df_new</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/56b2ebb8d95fe73d460d5cd172368829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*5vQc_wh9lfThojEUEpOq4A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="07d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">符合指定条件的值保持不变，其他值被指定的值替换。</p><p id="af63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 20。排名函数</strong></p><p id="1028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它给这些值分配一个等级。让我们创建一个根据客户余额对客户进行排名的列。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2ef2" class="ma mb it lw b gy mc md l me mf">df_new['rank'] = df_new['Balance'].rank(method='first', ascending=False).astype('int')</span><span id="3499" class="ma mb it lw b gy mg md l me mf">df_new</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/6b67f87e45db4232d9d51868bdc55b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*DfMKoWtayO4fnxNxMNck4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="ec51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">method参数指定如何处理具有相同值的行。“第一个”意味着根据它们在数组(即列)中的顺序对它们进行排序。</p><h2 id="d8d0" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">21.列中唯一值的数量</h2><p id="da8a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在处理分类变量时，这很方便。我们可能需要检查唯一类别的数量。</p><p id="2b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以检查由value counts函数返回的序列的大小，或者使用nunique函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/b4c348c5378c9674937b8268e4295094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*6L4bNfluaWBvl05M65nZWg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="f858" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">22.内存使用</h2><p id="3cf0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是由memory_usage函数简单完成的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e5a64052c2c36563069f5b6795bc1261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*OK6dq4Ayrx3VT8_SdDqSyQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="ed18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些值以字节为单位显示使用了多少内存。</p><h2 id="6893" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">23.类别数据类型</h2><p id="01a4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">默认情况下，分类数据与对象数据类型一起存储。但是，这可能会导致不必要的内存使用，尤其是当分类变量的基数较低时。</p><p id="1cf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">低基数意味着与行数相比，一列只有很少的唯一值。例如，geography列有3个唯一值和10000行。</p><p id="b1d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将它的数据类型改为“类别”来节省内存。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8ccf" class="ma mb it lw b gy mc md l me mf">df['Geography'] = df['Geography'].astype('category')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/62ff82edfe1824e352a58974e436fe54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*2NbdxR5dEI-41jtSyl14Dg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="d79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">地理列的内存消耗减少了近8倍。</p><h2 id="e507" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">24.替换值</h2><p id="1ea2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">replace函数可用于替换数据帧中的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/4bfb9c1a2b6fcd43910606b80d2db7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*b27WaGX05rhaYV2Vp0HFcQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="7d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是要替换的值，第二个参数是新值。</p><p id="69b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用字典做多次替换。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/0a76496462246f2847b56a2e41186fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*9Sj4yQj4NqFghm6NaGonVw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="da47" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">25.绘制直方图</h2><p id="58f1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Pandas不是一个数据可视化库，但它使创建基本绘图变得非常简单。</p><p id="4cbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现用熊猫创建基本图比使用额外的数据可视化库更容易。</p><p id="be5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个余额柱状图。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9c48" class="ma mb it lw b gy mc md l me mf">df['Balance'].plot(kind='hist', figsize=(10,6), <br/>title='Customer Balance')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/17c80558044f0451bd1046b27a460bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*bxFX78iHpnZEsgWl3HaKZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="e470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于pandas不是一个数据可视化库，所以我不想详细介绍绘图。然而，<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.plot.html" rel="noopener ugc nofollow" target="_blank">图</a>函数能够创建许多不同的图，如折线图、条形图、kde图、面积图、散点图等。</p><h2 id="9030" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">26.减少浮点数的小数点</h2><p id="6d16" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">熊猫可能会为浮动显示过多的小数点。我们可以使用round函数轻松调整它。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="26b2" class="ma mb it lw b gy mc md l me mf">df_new.round(1) #number of desired decimal points</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0f723ea5908430a04937cccc634abaf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*TfXB1wSyDdwVoYVIgnm45w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="3b45" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">27.更改显示选项</h2><p id="a0b3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以更改各种参数的默认显示选项，而不是每次都手动调整显示选项。</p><ul class=""><li id="0886" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">get_option:返回当前选项</li><li id="3522" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">set_option:更改选项</li></ul><p id="96c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将小数点的显示选项改为2。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8eee" class="ma mb it lw b gy mc md l me mf">pd.set_option("display.precision", 2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7d56e75be3c35f049059905d01fb2694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*fXwsUkSh0YDkDUh5g9TY1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="1ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望更改的其他一些选项有:</p><ul class=""><li id="2875" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">max_colwidth:列中显示的最大字符数</li><li id="cddd" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">max_columns:要显示的最大列数</li><li id="f564" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">max_rows:要显示的最大行数</li></ul><h2 id="c8e3" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">28.通过列计算百分比变化</h2><p id="b2c6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">pct_change用于通过系列中的值计算百分比变化。它在计算时间序列或连续元素数组中的变化百分比时非常有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/56ac1ffcfb394149f2ec45b69b2d8d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*UfBRleFPFbASy6hvyFV4bQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第一个元素(4)到第二个元素(5)的变化是%25，因此第二个值是0.25。</p><h2 id="1355" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">29.基于字符串的过滤</h2><p id="3bae" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可能需要根据文本数据(如客户姓名)过滤观察结果(行)。我已经向df_new数据帧添加了虚构的名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/aa43ea2c5202711294c9b5d3f970787e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*qFy8z8V4NdAmAYwuNDIn9A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="c1e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们选择客户名称以“Mi”开头的行。</p><p id="a5f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用str访问器的startswith方法。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0d4d" class="ma mb it lw b gy mc md l me mf">df_new[df_new.Names.str.startswith('Mi')]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/10870ebe9f70a1b9d88339d857b98c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*UzGY0FiaLLYu5UmEqCiB3A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">endswith函数根据字符串末尾的字符进行同样的过滤。</p><p id="96b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫可以用绳子做很多操作。如果你想进一步阅读，我有一篇关于这个主题的单独文章。</p><div class="os ot gp gr ou ov"><a rel="noopener follow" target="_blank" href="/5-must-know-pandas-operations-on-strings-4f88ca6b8e25"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">熊猫5个必知的串线操作</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">熊猫让字符串操作变得简单</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div><h2 id="80f8" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">30.设计数据框架的样式</h2><p id="82f9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以通过使用返回一个<strong class="lb iu"> styler </strong>对象的<strong class="lb iu"> Style </strong>属性来实现这一点，它为格式化和显示数据帧提供了许多选项。例如，我们可以突出显示最小值或最大值。</p><p id="034a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还允许应用自定义样式功能。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5e92" class="ma mb it lw b gy mc md l me mf">df_new.style.highlight_max(axis=0, color='darkgreen')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/314e484d623750c0584ccb686672c197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*-14m0Nk60fWn5P7X6770SQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="85a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想进一步阅读的话，我有一篇关于设计熊猫数据框架的详细文章。</p><div class="os ot gp gr ou ov"><a rel="noopener follow" target="_blank" href="/style-your-pandas-dataframes-814e6a078c6d"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">设计你的熊猫数据框</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">让我们创造出比简单数字更多的东西。</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pl l pg ph pi pe pj ks ov"/></div></div></a></div></div><div class="ab cl pm pn hx po" role="separator"><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr"/></div><div class="im in io ip iq"><h2 id="446e" class="ma mb it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">结论</h2><p id="a718" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们已经介绍了大量的数据分析功能和方法。当然，熊猫提供的还有很多，但不可能在一篇文章中涵盖所有内容。</p><p id="a82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着您继续使用pandas进行数据分析任务，您可能会发现新的功能和方法。如同任何其他科目一样，熟能生巧。</p><p id="5504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想分享另外两个帖子，它们涵盖了与这篇帖子不同的操作。</p><ul class=""><li id="009b" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/20-points-to-master-pandas-time-series-analysis-f90155ee0e8a"> 20分掌握熊猫时间序列分析</a></li><li id="7786" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/pandas-dtype-specific-operations-accessors-c749bafb30a4"> Pandas特定于类型的操作:访问器</a></li></ul><p id="a419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>