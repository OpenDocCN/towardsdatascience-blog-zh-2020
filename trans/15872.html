<html>
<head>
<title>All about Pythonic Class: The Life Cycle®</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Pythonic类的所有内容:生命周期</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-about-pythonic-class-the-life-cycle-5d2deae1ad8d?source=collection_archive---------30-----------------------#2020-11-01">https://towardsdatascience.com/all-about-pythonic-class-the-life-cycle-5d2deae1ad8d?source=collection_archive---------30-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ea9f" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Python数据模型</h2><div class=""/><div class=""><h2 id="ec51" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Python数据模型—第2部分[b]</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d49863ec01a8fba63b9ca64b4b1bce50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQmLrSSPLoKp8uAKVW-HkQ.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片:<a class="ae le" href="https://www.pxfuel.com/en/free-photo-ernyb" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="8924" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是“关于Pythonic类的一切”的第二部分。现在，我们的“Python数据模型”系列—</p><ol class=""><li id="96b7" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated"><a class="ae le" rel="noopener" target="_blank" href="/python-data-model-part-1-objects-types-and-values-cb9316f57e8">对象、类型和值；Python数据模型—第1部分</a></li><li id="be9f" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated"><a class="ae le" href="https://farhadnaeem.medium.com/all-about-pythonic-class-the-birth-and-style-36002e28d035" rel="noopener">关于Pythonic类的一切:诞生和风格；Python数据模型—第2部分[a] </a></li><li id="45dd" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">关于Pythonic类的所有内容:生命周期；Python数据模型—第2部分[b]</li></ol><p id="44e8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在前一章中，我们已经展示了如何编写一个基本类，类和对象之间的关系，以及新式类和旧式类之间的区别。我们将从上一章离开的地方开始这一章</p><h1 id="7941" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">4.当我们定义一个类时，实际上会发生什么</h1><p id="56a4" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">那么当我们声明一个类时会发生什么呢？Python解释器是怎么解释的？</p><p id="d900" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们调用一个类来形成一个对象时，有两个特殊的方法被调用。</p><ul class=""><li id="a8b8" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma nm mh mi mj bi translated">首先，解释器调用__ <strong class="lh ja"> new__ </strong>方法，这是一个类的“真正”构造函数。然后，这个特殊的方法在内存中未命名的位置创建一个具有正确类型的对象。</li><li id="9061" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma nm mh mi mj bi translated">然后调用__ <strong class="lh ja"> init__ </strong>用__ <strong class="lh ja"> new__ </strong>创建的前一个对象初始化类对象。大多数时候，如果没有明显的原因，我们不需要声明一个__ <strong class="lh ja"> new__ </strong>的特殊方法。它主要发生在后台。用__ <strong class="lh ja"> init__ </strong>实例化一个对象是最常见和标准的做法，足以满足我们的大多数目的。</li></ul><p id="cda8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是一个复杂的过程，在幕后创建一个类。它还需要深入了解Python解释器的设计以及该语言的核心实现。为了简单起见，我们将从高层次的角度描述该过程，并编写后端过程的假设或伪代码。</p><p id="2b5a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们调用一个类来形成一个对象时，解释器调用<code class="fe nn no np nq b">type</code>。它需要三个参数- <br/> <code class="fe nn no np nq b">type(classname, superclass, attribs)</code>或<br/> <code class="fe nn no np nq b">type("", (), {})</code></p><p id="cde5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">其中类名是声明类的字符串表示，超类是类的元组表示，我们的类将从该元组表示中继承属性，属性是<code class="fe nn no np nq b">class.__dict__</code>的字典表示。让我们正常地声明一个类</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="09e8" class="nv mq iq nq b gy nw nx l ny nz">class Footballer():<br/>    game = "Football"<br/> <br/>    def __init__(self, name, club):<br/>        self.name = name<br/>        self.club = club<br/> <br/>    def a_method(self):<br/>        return None<br/> <br/>print(Footballer.__dict__)    <br/> <br/># Output<br/>'''<br/>{'__module__': '__main__', 'game': 'Football', '__init__': &lt;function Footballer.__init__ at 0x7f10c4563f28&gt;, 'a_method': &lt;function Footballer.a_method at 0x7f10c45777b8&gt;, '__dict__': &lt;attribute '__dict__' of 'Footballer' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Footballer' objects&gt;, '__doc__': None}<br/>'''</span></pre><p id="5aa6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们将使用<code class="fe nn no np nq b">type</code>元类编写相同类型的类</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="85e1" class="nv mq iq nq b gy nw nx l ny nz">def outer_init(self, name, club):<br/>    self.name = name<br/>    self.club = club<br/> <br/>Footballer1 = type("Footballer1", (), {"game":"Soccer",  "__init__": outer_init, "b_method": lambda self: None})</span><span id="8a34" class="nv mq iq nq b gy oa nx l ny nz">print(Footballer1.__dict__)  <br/>print(Footballer1.game)<br/> <br/># Output<br/>'''<br/>{'game': 'Soccer', '__init__': &lt;function outer_init at 0x7f10c4510488&gt;, 'b_method': &lt;function &lt;lambda&gt; at 0x7f10c4510f28&gt;, '__module__': '__main__', '__dict__': &lt;attribute '__dict__' of 'Footballer1' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Footballer1' objects&gt;, '__doc__': None}</span><span id="8b39" class="nv mq iq nq b gy oa nx l ny nz">Soccer<br/>'''</span></pre><p id="2fa1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">啊哈！我们刚刚使用类型元类创建了一个常规的用户定义类！！这到底是怎么回事？<br/>当类型被调用时，它的<code class="fe nn no np nq b">__call__</code>方法被执行，运行另外两个特殊的方法-</p><ol class=""><li id="90cc" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated"><code class="fe nn no np nq b">type.__new__(typeclass, classname, superclasses, attributedict)</code>建造师</li><li id="d99a" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated"><code class="fe nn no np nq b">type.__init__(cls, classname, superclasses, attributedict)</code>发起者/初始者</li></ol><p id="fe9c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe nn no np nq b">__new__(cls, [...)</code>特殊方法<code class="fe nn no np nq b">__new__</code>是创建对象时调用的第一个方法。它的第一个参数是类本身，后面是构成它所需的其他参数。这个函数很少使用，默认情况下在对象创建期间由解释器调用。<br/> <code class="fe nn no np nq b">__init__(self, [...)</code>初始化器特殊方法初始化一个类，并给出对象的默认属性。此方法将一个对象作为第一个参数，后面跟它的其他参数。这是Python世界中最常用的特殊方法。</p><p id="6511" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面的<code class="fe nn no np nq b">pseudo-code</code>展示了Python解释器如何从一个类创建一个对象。请记住，为了有一个基本的理解，我们已经省略了解释器所做的底层工作。看一看不言自明的代码说明</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="1777" class="nv mq iq nq b gy nw nx l ny nz">class Bar():<br/>    def __init__(self, obVar):<br/>        self.obVar = obVar<br/> <br/>&gt;&gt;&gt; obj = Bar("a string") ----------------[1]</span><span id="af0e" class="nv mq iq nq b gy oa nx l ny nz"># putting  object parameter into a temporary variable<br/>&gt;&gt;&gt; tmpVar = Bar.__new__(Bar, "another string")<!-- --> <br/>&gt;&gt;&gt; type(tmpVar)<br/>&gt;&gt;&gt; __main__.Bar</span><span id="1924" class="nv mq iq nq b gy oa nx l ny nz">&gt;&gt;&gt; tmpVar.obVar -------------------------[2]</span><span id="e849" class="nv mq iq nq b gy oa nx l ny nz"># the class is not initialised yet<!-- --> <br/># It will throw errors</span><span id="4a3d" class="nv mq iq nq b gy oa nx l ny nz">&gt;&gt;&gt; AttributeError Traceback (most recent call last)<br/>....<br/>AttributeError: 'Bar' object has no attribute 'obVar'<br/>------------------------------------------------------</span><span id="6b4f" class="nv mq iq nq b gy oa nx l ny nz"># initialise a temporary variable<!-- --> <br/>&gt;&gt;&gt; tmpVar.__init__("a string") ---------------[3]<br/>&gt;&gt;&gt; tmpVar.obVar<br/>&gt;&gt;&gt; 'another string'</span><span id="b329" class="nv mq iq nq b gy oa nx l ny nz">&gt;&gt;&gt; obVar = tmpVar <br/>&gt;&gt;&gt; obVar.obVar<br/>&gt;&gt;&gt; 'another string'<!-- --> </span></pre><p id="dec2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe nn no np nq b">Obj</code>的表现和我们预期的一样<code class="fe nn no np nq b">[1]</code>。但是，当我们通过调用<code class="fe nn no np nq b">Bar.__new__</code>并试图访问<code class="fe nn no np nq b">obVar,</code>来创建<code class="fe nn no np nq b">tmpVar</code>时，它抛出了一个错误<code class="fe nn no np nq b">[2]</code>。因此，我们需要用<code class="fe nn no np nq b">__init__</code>初始化，之后，它会像前面的变量<code class="fe nn no np nq b">[3]</code>一样很好地工作。</p><p id="3df1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">附:名字两边加双下划线的方法被称为特殊方法或魔法方法。特殊方法是CPython的“实现细节”或低级细节。为什么我们称之为魔法方法？因为这些方法给我们的课增加了“魔力”。对于魔法方法，我们将有两个单独的章节。</p><h1 id="3e4e" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">5.类的生命周期</h1><p id="8d49" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">到目前为止，我们已经讨论了Python类的几乎所有基本概念。我们在这一节将要讨论的内容可以算作是上一节的重复，我们将讨论一个类的更微妙的细节。</p><p id="bea3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们运行Python程序时，它会在运行时从内置或用户定义的类中生成对象。每个对象在创建后都需要内存。Python在完成分配给它的任务时不需要对象。它变成了一条不需要的信息或垃圾。</p><p id="082e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一方面，Python解释器需要定期释放内存用于进一步的计算、新对象的空间、程序效率和内存安全性。当一块“垃圾对象”被处置时，它就不再存在于内存中。问题是Python类存在多久，什么时候不再存在？最简单的答案是一个对象或类存在，只要它</p><ol class=""><li id="75e1" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">保存对其属性或派生的引用，并且</li><li id="d981" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">它被另一个对象引用。</li></ol><p id="a8fa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当两个标准都不满足时，一个对象或类就不存在了。答案是最简单的，但是很多事情都是在幕后进行的。我们将揭示其中的一些。</p><p id="465f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下面的类是设计来连接到一个web服务器并打印状态代码，服务器信息，然后我们将关闭连接。我们将属性从另一个名称空间“打包”到<code class="fe nn no np nq b">Response</code>类中，该名称空间将是类型的元类；不出所料。</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="7188" class="nv mq iq nq b gy nw nx l ny nz">import requests<br/> <br/># Another name space<br/>var = "a class variable."<br/> <br/>def __init__(self, url):<br/>    self.__response = requests.get(url)<br/>    self.code = self.__response.status_code<br/> <br/>def server_info(self):<br/>    for key, val in self.__response.headers.items():<br/>        print(key, val)<br/> <br/>def __del__(self): ---------------------- [1]<br/>    self.__response.close()<br/>    print("[!] closing connection done...")</span><span id="2583" class="nv mq iq nq b gy oa nx l ny nz"># Injecting meta from another namespace<br/>Response = type('Response', (), {"classVar":var,"__init__": __init__, "server":server_info, "__del__":__del__})<!-- -->  <br/>    <br/># Let's connect to our home server on my father's desk <br/>resp = Response("http://192.168.0.19")</span><span id="083b" class="nv mq iq nq b gy oa nx l ny nz">print(type(Response))<br/>print(resp.code)<br/>resp.server()</span><span id="9072" class="nv mq iq nq b gy oa nx l ny nz">del resp  # It will call the DE-CONSTRUCTOR</span><span id="6008" class="nv mq iq nq b gy oa nx l ny nz"># Output<br/>'''<br/>&lt;class 'type'&gt;<br/>401<br/>Date Fri, 25 Sep 2020 06:13:50 GMT<br/>Server Apache/2.4.38 (Raspbian)<br/>WWW-Authenticate Basic realm="Restricted Content"<br/>Content-Length 461Keep-Alive timeout=5, max=100<br/>Connection Keep-Alive<br/>Content-Type text/html; charset=iso-8859-1<br/>[!] closing connection done... # resp object destroyed<br/>'''</span></pre><p id="ed1a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe nn no np nq b">__del__(self)</code>特殊方法<code class="fe nn no np nq b">__del__</code>可以称为终结器或析构器，负责终止一个对象或类。<code class="fe nn no np nq b">__del__</code>是在对象的垃圾收集过程中调用的终结器。当对一个对象的所有引用都被删除时，这个过程就会发生。</p><p id="5ca1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上面这段代码中，为了有一个基本的理解，我们省略了解释器所做的底层事情。当我们删除响应对象<code class="fe nn no np nq b">del resp</code>时，会执行<code class="fe nn no np nq b">__del__</code>特殊方法或反构造函数来清除RAM中的对象。</p><p id="cb44" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">该方法在删除时需要额外清理的特殊情况下很有用，例如套接字和文件对象。然而，请记住这样一个事实，即使解释器退出时目标对象仍然存在，也不能保证<code class="fe nn no np nq b">__del__</code>是否会被执行。因此，手动或使用包装器关闭任何文件或连接是一个很好的做法。</p><h1 id="4d23" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">6.碎片帐集</h1><p id="64ce" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">一个类产生一个对象。当一个对象不再存在于一个名称空间中时，假设一个类也不需要存在于该空间中。类也可以像普通对象一样被删除，因为类本身就是一个对象。为了内存安全和高效的代码，垃圾收集过程会处理不必要的对象。</p><p id="663e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Python在CPython*中采用了两种垃圾收集机制</p><ol class=""><li id="ef42" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">引用计数</li><li id="265a" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">分代垃圾收集</li></ol><p id="126b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这两者之间，第一个是最常用的，因为在用户空间中销毁对象的自由如果不小心实现可能会带来灾难，例如，任何对被销毁对象的强引用都可能成为孤儿/悬空对象并泄漏内存。引用计数很容易实现，但是它不能处理引用周期，这使得它更容易发生内存泄漏。</p><p id="fc76" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">默认情况下，一个类在创建时会得到一个<em class="ob">类型和引用</em>计数。每当我们通过调用一个对象来创建它时，解释器就增加它的引用计数。对象或类的引用计数在</p><ol class=""><li id="2e32" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">作为函数参数传递</li><li id="68bd" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">赋给另一个对象或变量</li><li id="fbcf" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">附在名单上</li><li id="c48f" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">作为一个类的属性添加等等。</li></ol><p id="e67b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当该计数达到<em class="ob">零</em>时，该类不再存在于存储器中，这可以被视为“类的死亡”。换句话说，当一个对象在任何地方被引用时，它的引用计数增加，而当它被取消引用时，它的引用计数减少。我们编写的高级代码不会影响这种低级实现，尽管可以使用分代垃圾收集或<code class="fe nn no np nq b">gc</code>模块手工处理垃圾收集。请遵守以下代码</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="88f9" class="nv mq iq nq b gy nw nx l ny nz">import sys<br/> <br/>class Bar():<br/>    pass<br/> <br/>print(sys.getrefcount(Bar)) # default reference count is 5<br/> <br/>a = Bar()<br/>b = Bar()<br/>c = Bar()<br/> <br/>print(sys.getrefcount(Bar)) # reference count increased by 3 <br/> <br/> <br/>del a , b , c  <br/> <br/>print(sys.getrefcount(Bar)) # reference count decreased by 3 <br/> <br/># Output<br/>'''<br/>5<br/>8<br/>5<br/> <br/>'''</span></pre><p id="9bdb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当一个或多个Python对象相互引用时，就会出现引用循环。因此，在这些情况下，仅仅使用<code class="fe nn no np nq b">del</code>删除一个对象只会减少它的引用计数，并使它不可被程序访问。它实际上保留在记忆中。<br/>例如</p><pre class="kp kq kr ks gt nr nq ns nt aw nu bi"><span id="9e84" class="nv mq iq nq b gy nw nx l ny nz">class Foo():<br/>    pass<br/> <br/>obj.var = obj</span></pre><p id="881c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上面的例子中，我们通过将对象<code class="fe nn no np nq b">obj</code>本身赋予其属性<code class="fe nn no np nq b">obj.var</code>来创建一个引用循环。仅仅减少<code class="fe nn no np nq b">obj</code>的引用计数不会从内存中破坏它，而是需要分代垃圾收集来永久清除。这种实现可以由高级编码空间中的<code class="fe nn no np nq b">gc</code>模块来处理。<br/>这是‘杀班’的另一种方式。</p><h1 id="a395" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">最终想法:</h1><p id="8280" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">从这两部分，我们试图展示关于Pythonic类的6个重要事实。预计现在我们至少对Python类如何工作以及如何从后台内存中清理有了一些基本的概念。</p><p id="550a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了掩盖python数据模型，我们将有单独的更详细的文章，讨论魔术方法、装饰器、元编程、python继承等。对该过程的良好理解使开发人员能够充分利用Python的潜在能力，并在事情变得更加复杂时调试复杂的问题。</p><h1 id="b08c" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">参考资料:</h1><ol class=""><li id="8579" class="mb mc iq lh b li nh ll ni lo oc ls od lw oe ma mg mh mi mj bi translated"><a class="ae le" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/reference/datamodel.html</a></li><li id="c118" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">卢西亚诺·拉马尔霍的流畅Python。这是每一个python爱好者都应该读的书，以提高他们的python技能。</li><li id="75c3" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated"><a class="ae le" href="https://stackify.com/python-garbage-collection/" rel="noopener ugc nofollow" target="_blank">https://stackify.com/python-garbage-collection/</a></li></ol></div></div>    
</body>
</html>