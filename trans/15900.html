<html>
<head>
<title>How to get started with the Graph Data Science Library of Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何入门Neo4j的图形数据科学库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-get-started-with-the-new-graph-data-science-library-of-neo4j-3c8fff6107b?source=collection_archive---------13-----------------------#2020-11-02">https://towardsdatascience.com/how-to-get-started-with-the-new-graph-data-science-library-of-neo4j-3c8fff6107b?source=collection_archive---------13-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4348" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="bcbe" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Neo4j中图形数据科学管理方式的巨大变化带来了巨大的机遇</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3db3080919ed9cc399b0b9e8c02b6172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pRS0_W3JbJYCmDNWaWI5Q.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自Ecpp，CC BY-SA 4.0【https://creativecommons.org/licenses/by-sa/4.0&gt;】T2，转自维基共享。我没有改变这个形象。</p></figure><p id="ddf0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">图形分析领域已经存在很长时间了。总的想法是创建一个<em class="mb">事物连接到其他事物</em>的数据库。这些事情可能是人们在社交媒体上与其他人联系，或者可能是城市之间的航班或任何其他数量的例子。图形通常用于增强搜索能力，向电子商务网站上的购物者推荐产品，检测欺诈，或者绘制从A点到b点的最短路线。</p><p id="55b3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">长久以来，Neo4j一直是图形数据库领域的重要参与者。历史上，它使用<a class="ae le" href="https://en.wikipedia.org/wiki/Cypher_(query_language)" rel="noopener ugc nofollow" target="_blank">密码查询语言</a>与数据库进行交互。有很多关于如何分析图表或使用密码的初级读本。相反，这篇文章旨在介绍如何使用新的<a class="ae le" href="https://neo4j.com/docs/graph-data-science/current/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形数据科学库</a> (GDS)来完成数据科学中的任务，这是对原始<a class="ae le" href="https://neo4j.com/developer/graph-data-science/graph-algorithms/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形算法库</a>(现已废弃)的重大增强。从图算法到GDS有一些根本性的转变，但对于那些使用前者的人来说，一旦你掌握了新的使用方式，它将成为第二天性。出于本文的目的，没有必要使用任何一种来开始用数据科学方法解决图形问题。</p><p id="4d05" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将从你有一个正在运行的Neo4j服务器的前提开始。如果你还没有这个，你可以在这里下载开源社区版<a class="ae le" href="https://neo4j.com/download-center/?ref=web-product-database/#community" rel="noopener ugc nofollow" target="_blank">。</a>需要注意的是，为了访问GDS图书馆，您需要下载Neo4j的v4版本。当前版本永远是最好的，并提供了GDS的最新功能(他们总是添加伟大的新功能！).</p><h1 id="9c1a" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">使用。图形数据的csv文件</h1><p id="c78c" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">一旦Neo4j服务器启动并运行，您将需要一些图形数据来填充它。虽然Neo4j中内置了一些示例图，但是介绍一下如何导入您自己的数据可能会有所帮助。</p><p id="195b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">图形数据通常以边列表和节点列表的形式出现，它们通常是独立的文件。Neo4j使导入这些文件变得容易。csv格式，我们将讨论一种最容易导入的格式。让我们分别讨论一下这些文件。</p><p id="22b0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">节点列表:</strong>在此。csv文件我们提供关于节点的信息——它们的标签。可以有许多类型的标签，或者您可以只提供一个通用的节点ID。这些标签将用作上述<code class="fe mz na nb nc b">node1</code>和<code class="fe mz na nb nc b">node2</code>中的标识符。可以有任意数量的标签与节点相关联。好的选择是像唯一标识符、已知的名称(如果已知的话)和节点的一般类型(想想像“这个节点是一个人”或“这个节点是一个地方”，这可以用来给出像“人”或“地方”这样的节点类型)。格式看起来像这样</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="40e9" class="nh md iq nc b gy ni nj l nk nl">node1, label1, label2, …</span></pre><p id="498f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">边缘列表:</strong>在此。csv文件中，您有关于哪些节点连接到哪些其他节点的信息。它还可以指定关系的类型。所以格式遵循典型的</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="ee9a" class="nh md iq nc b gy ni nj l nk nl">node1, node2, relationship_type, weight</span></pre><p id="45a7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">其中，<code class="fe mz na nb nc b">node1</code>是起始节点，<code class="fe mz na nb nc b">node2</code>是终止节点，<code class="fe mz na nb nc b">relationship_type</code>指定边标签(可选)，而<code class="fe mz na nb nc b">weight</code>表示该关系的强度(可选)。</p><p id="7d65" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，为每个文件设置一个标题行通常是一个好习惯(尽管不是必需的),这样您就可以跟踪哪些列是什么。一旦你有了这些文件，我们就可以把它们载入Neo4j。出于本教程的考虑，我们将使用《权力的游戏》(GoT)中的角色图。GoT out上的图形数据有几个来源，但我特别喜欢Andrew Beveridge在<a class="ae le" href="https://github.com/mathbeveridge/gameofthrones" rel="noopener ugc nofollow" target="_blank"> this repo </a>中维护的那个，因为它简单、有条理且易于使用。</p><p id="dea5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数据被方便地分解成。节点和边的csv文件，每个季节一个文件。在本教程中，我将repo克隆到我的本地机器上以读取文件，但是您也可以选择从web上读取它们。</p><p id="907a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="mb">警告！！！图形分析是一个强大的工具，当我们进入GoT时，它将揭示一些严重的破坏者！所以如果你不想让系列剧透，现在就回头吧！</em>T15】</strong></p><h1 id="0dd9" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">将数据加载到Neo4j</h1><p id="0561" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">使用内置的<code class="fe mz na nb nc b">LOAD CSV</code>命令将数据加载到数据库非常简单。因为我们在装货。csv文件，您将希望确保进入neo4j.conf文件并注释掉行<code class="fe mz na nb nc b">dbms.directories.import=import</code>,以便允许我们从您本地机器上的任何地方加载文件。加载方式有很多种。csv数据到数据库中，我挑了下面我觉得最简单的。</p><p id="1afd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将从使用以下命令加载节点列表开始:</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="e2fb" class="nh md iq nc b gy ni nj l nk nl">WITH "file:///Users/cj2001/gameofthrones/data/got-s1-nodes.csv" AS uri<br/>LOAD CSV WITH HEADERS FROM uri AS row<br/>MERGE (c:Character {id:row.Id})<br/>SET c.name = row.Label</span></pre><p id="1551" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(这是加载到第一季文件中的命令，您可以重复这个命令来加载任何您想要的季节。我已经对从<code class="fe mz na nb nc b">s1</code>到<code class="fe mz na nb nc b">s8</code>的每个文件执行了这个命令。<em class="mb">注意:</em>第五季的文件名有轻微的错别字。)</p><p id="d019" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用上面的命令，我现在有了一系列类型为<code class="fe mz na nb nc b">Character</code>的节点，这些节点具有名为<code class="fe mz na nb nc b">id</code>和<code class="fe mz na nb nc b">name</code>的属性。注意，我们已经用标题行中可用的列名对应的<code class="fe mz na nb nc b">Id</code>和<code class="fe mz na nb nc b">Label</code>逐行加载了这个文件。</p><p id="6d86" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">接下来，我们将使用以下命令加载边列表:</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="2962" class="nh md iq nc b gy ni nj l nk nl">WITH "file:///Users/cj2001/gameofthrones/data/got-s1-edges.csv" AS uri<br/>LOAD CSV WITH HEADERS FROM uri AS row<br/>MATCH (source:Character {id: row.Source})<br/>MATCH (target:Character {id: row.Target})<br/>MERGE (source)-[:SEASON1 {weight: toInteger(row.Weight)}]-(target)</span></pre><p id="5cfd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(同样，我们将对每个想要合并的边缘文件重复上述步骤。)</p><p id="4663" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上面的命令创建了边缘类型为<code class="fe mz na nb nc b">:SEASON1</code>的字符之间的关系。我发现给每个季节赋予它自己的边类型是很方便的，这样可以探索不同季节之间图形的变化。边缘本身由源角色和目标角色交互的次数加权。注意，在导入时，Neo4j认为所有的列都是字符串，但是对于我们将来的计算，我们希望Neo4j知道<code class="fe mz na nb nc b">Weight</code>实际上是一个整数，所以我们必须将其重新转换。还要注意我们使用了格式<code class="fe mz na nb nc b">(source)-[edge_type]-(target)</code>。因为在这个关系中没有指示方向的箭头，所以我们创建了一个无向图。如果我们想做其他的事情，这种关系应该看起来像<code class="fe mz na nb nc b">(source)-[edge_type]-&gt;(target)</code>。</p><h1 id="d205" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">内存中的图形:转移到GDS图书馆的大问题和简单的PageRank计算</h1><p id="c025" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">内存图形的创建代表了Neo4j的革命性进步。基本上，它允许我们做的是创建不同的图或子图进行分析。我们可以在部分数据库上运行命令，而不是整个数据库。例如，在得到的数据中，我们可能关心对整个图表进行的计算，或者我们可能只想对单个季节进行计算。这种新的哲学方法为数据科学和图形上的机器学习打开了许多大门，我怎么强调都不为过！</p><p id="330a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将从创建整个8个赛季的内存图开始。在GDS有两种主要的方法可以做到这一点:使用Cypher投影或“本地”投影。我将在这里使用前者，因为这是一组非常直接的命令，很容易理解发生了什么。虽然原生投影非常快速和强大，但是超出了本教程的范围。为了用Cypher投影创建内存中的图形，我们使用命令</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="9101" class="nh md iq nc b gy ni nj l nk nl">CALL gds.graph.create.cypher(<br/>    'full_graph',<br/>    'MATCH (n) RETURN id(n) AS id',<br/>    'MATCH (n)-[e]-(m) RETURN id(n) AS source, e.weight AS weight, id(m) AS target'<br/>)</span></pre><p id="5d4f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">图形创建需要三样东西:</p><ol class=""><li id="23bf" class="nm nn iq lh b li lj ll lm lo no ls np lw nq ma nr ns nt nu bi translated">一个图形名称(<code class="fe mz na nb nc b">full_graph</code>)</li><li id="f203" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">一个节点查询(<code class="fe mz na nb nc b">MATCH (n) RETURN id(n) AS id</code></li><li id="1527" class="nm nn iq lh b li nv ll nw lo nx ls ny lw nz ma nr ns nt nu bi translated">一个边缘查询(<code class="fe mz na nb nc b">MATCH (n)-[e]-(m) RETURN id(n) AS source, e.weight AS weight, id(m) AS target</code></li></ol><p id="a183" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">图形名称非常清楚。但是节点和边查询需要一点解释。出于速度原因，Neo4j处理节点id，而不是实际的节点信息。通常，这些id除了与我们拥有的任何节点或边标签无关的一组整数之外，不会映射到任何东西。但是当你看到<code class="fe mz na nb nc b">id(n)</code>时，这就是GDS与这些数据的实际关联。我们在节点查询中获得这些id，然后在边查询中返回它们。</p><p id="4632" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们有了一个图表，我们可以在上面做一些数学运算。我们可以做的最基本的事情之一是计算图表中每个字符的PageRank。我们可以用两种不同的方式来查看和使用这些结果。为了理解其中的区别，我们认为大部分GDS函数可以调用<code class="fe mz na nb nc b">stream</code>或<code class="fe mz na nb nc b">write</code>方法。前者将计算结果输出到屏幕上。例如，为了计算这个图表上的PageRank并将其输出到屏幕上，我们应该这样做</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="d762" class="nh md iq nc b gy ni nj l nk nl">CALL gds.pageRank.stream('full_graph', {<br/>  maxIterations: 20,<br/>  dampingFactor: 0.85,<br/>  relationshipWeightProperty: 'weight'<br/>})<br/>YIELD nodeId, score<br/>RETURN gds.util.asNode(nodeId).id AS id,      gds.util.asNode(nodeId).name as name, score as full_pagerank<br/>ORDER BY full_pagerank DESC</span></pre><p id="9272" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(我只是使用了<code class="fe mz na nb nc b">maxIterations</code>和<code class="fe mz na nb nc b">dampingFactor</code>的默认值。)注意，我们使用的是之前的节点id，我们通过<code class="fe mz na nb nc b">gds.util.asNode(nodeId)</code>命令将它们从各自的id转换成我们识别的属性，比如<code class="fe mz na nb nc b">id</code>和<code class="fe mz na nb nc b">name</code>。</p><p id="2535" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们在所有8个季节的图表上这样做，我们会发现一些不令人惊讶的结果。各季排名最高的五个角色依次是提利昂、琼恩、丹妮莉丝、瑟曦和珊莎。(别担心……艾莉亚是6号。)</p><p id="d0b5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个结果并不令人惊讶，也许我们真的想把它作为一个节点属性，用于内存图之外的未来分析。为此，我们想使用<code class="fe mz na nb nc b">write</code>方法，该方法将计算结果作为属性写入节点。为了做到这一点，我们做到了</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="4e09" class="nh md iq nc b gy ni nj l nk nl">CALL gds.pageRank.write('full_graph', {<br/>    maxIterations: 20,<br/>    dampingFactor: 0.85,<br/>    relationshipWeightProperty: 'weight',<br/>    writeProperty: 'full_pagerank'})</span></pre><p id="e30b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在可以做一个简单的<code class="fe mz na nb nc b">MATCH (c:Character RETURN c.name ORDER BY c.full_pagerank DESC</code>来看看上面的结果。然而，我们可以看到，在这种情况下，PageRank被添加为一个名为<code class="fe mz na nb nc b">full_pagerank</code>的节点属性。</p><p id="d0d1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这很有趣，但是如果我们了解《GoT》的话，我们会认为PageRank会随着每一季角色的增加和减少或者死亡而改变。为了探索这一理论，我将创建两个额外的内存中图表—一个用于第1季，一个用于第8季。对于第一季，这看起来会像</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="e833" class="nh md iq nc b gy ni nj l nk nl">CALL gds.graph.create.cypher(<br/>    's1_graph',<br/>    'MATCH (n) RETURN id(n) AS id',<br/>    'MATCH (n)-[e:SEASON1]-(m) RETURN id(n) AS source, e.weight AS weight, id(m) AS target'<br/>)</span></pre><p id="fdba" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第八季也差不多。您可以使用<code class="fe mz na nb nc b">CALL gds.graph.list()</code>来检查图表。</p><p id="f121" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，如果我对第一季进行同样的PageRank计算，我会得到奈德、提利昂、凯特琳、琼恩和丹妮莉丝是最具影响力的前五个角色。第八季再重复一遍，我得到前五名分别是提利昂、琼恩、丹妮莉丝、詹姆和珊莎。再说一次，如果你了解这部剧，这些都不会让人感到惊讶。</p><h1 id="8b47" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">通过Louvain方法的社区检测</h1><p id="1c69" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">GDS库中包含的一个强大工具是在内存图形上运行<a class="ae le" href="https://en.wikipedia.org/wiki/Louvain_method" rel="noopener ugc nofollow" target="_blank"> Louvain聚类</a>的能力。要在所有8个季节的完整图表上这样做，并将计算的社区作为属性写入每个节点，我们将运行</p><pre class="kp kq kr ks gt nd nc ne nf aw ng bi"><span id="dc66" class="nh md iq nc b gy ni nj l nk nl">CALL gds.louvain.write('full_graph', <br/>    {relationshipWeightProperty: 'weight', <br/>     writeProperty: 'full_community_id'<br/>})</span></pre><p id="3520" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(注意，这样做不会得到很好的模块化，但是为Louvain调优参数超出了本教程的范围。)如果我想获得提利昂所有8个赛季的检测到的社区，我们将首先获得ID值(<code class="fe mz na nb nc b">MATCH (c:Character {name: ‘Tyrion’}) RETURN c.name, c.full_community_id </code>，它给了我社区143，但你的可能会不同)，然后在同一个社区中找到排名最高的人物。就我而言，我会做<code class="fe mz na nb nc b">MATCH (c:Character {full_community_id: 143}) RETURN c.name, c.full_community_id ORDER BY c.full_pagerank DESC</code>，我会得到8季中对提利昂生活影响最大的5个角色是瑟曦、詹姆、瓦里斯、乔佛里和泰温。不奇怪。我把它作为一个练习留给读者，让他们探索其他角色，或者看看探测到的社区是如何随季节变化的。</p><h1 id="3ca1" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">最后的想法</h1><p id="8196" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">Neo4j从基本的查询转向形式化的图表处理，使数据科学和机器学习成为可能，这给我留下了深刻的印象。这里有很多功能，我在本教程中只触及了皮毛。我希望在未来撰写其他文章，讨论诸如本机投影和node2vec和GraphSAGE的矢量嵌入所提供的全部可能性之类的事情，在GDS库的最新版本中，它们已经从alpha版本中移除。</p><p id="cc15" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">[1] M. Needham和A. Hodler，<a class="ae le" href="https://neo4j.com/lp/book-graph-algorithms/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=na-search-graph-algorithms&amp;utm_adgroup=graph-algorithms&amp;gclid=Cj0KCQjwufn8BRCwARIsAKzP697HaYt3oOY7a3XV-y1NeqJdjIFSRrKUhd7J95k0KANvkdi2Shv2dz4aAkEREALw_wcB" rel="noopener ugc nofollow" target="_blank">图算法:Apache Spark和Neo4j中的实际例子</a> (2020)，奥赖利媒体。</p></div></div>    
</body>
</html>