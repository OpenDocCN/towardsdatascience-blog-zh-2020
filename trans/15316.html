<html>
<head>
<title>Real-time Model Interpretability API using SHAP, Streamlit and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SHAP、Streamlit和Docker的实时模型可解释性API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/real-time-model-interpretability-api-using-shap-streamlit-and-docker-e664d9797a9a?source=collection_archive---------24-----------------------#2020-10-21">https://towardsdatascience.com/real-time-model-interpretability-api-using-shap-streamlit-and-docker-e664d9797a9a?source=collection_archive---------24-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="25c4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak"><em class="ki"/></strong>自助式API实时解释模型分数</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/6392c8e78b180c70a5621200f2aa2c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_h-o3lAb6nlBRkRp0Y72A.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">礼貌:<a class="ae kz" href="https://pixabay.com/photos/house-painter-balloon-why-question-3062248/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="0ab1" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">背景</h1><p id="a395" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">作为一名数据科学家，您将一个业务问题转化为一个数据科学问题。接下来，您构建解决问题的解决方案/模型。您用测试和超时数据验证模型，以确保它没有偏差。最后，您在生产中部署模型，监控模型的性能，进行实验等等。除了这些任务之外，您还需要向业务涉众展示您的发现，有时还需要与他们一起工作来教育和有效地使用您的模型。你的工作完成了吗？还没有。</p><p id="c5db" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">您的模型的最终用户可能会思考并提出类似这样的问题——“为什么您的模型预测这个客户是某某人？”或者“你能解释一下为什么我们会从你的模型中得到这个结果吗？”。即使你有一个合适的文档(假设你做了)，它也不能解释你的模型预测。考虑一个场景，您构建了一个模型来对猫/狗进行分类。您的文档看起来像这样。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/8c054fdd1dd0d1d7569d46281a53c746.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*yHoBB2AG_unBWkiDxpZjKQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">混淆矩阵</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mv"><img src="../Images/d1abc29adb784f3e27800960074e6b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTMa0cEqJPMIVlBFv6EzWw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">交叉熵</p></figure><blockquote class="mw"><p id="ad81" class="mx my it bd mz na nb nc nd ne nf mn dk translated"><strong class="ak">当最终用户问你“为什么你的模型预测这张图片是一只猫？”</strong></p></blockquote><figure class="nh ni nj nk nl ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ng"><img src="../Images/3e17bda163f035237e6a3db2525e9be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mt0OTXU8t8c73sY8hrr4iQ.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">礼貌:<a class="ae kz" href="https://pixabay.com/photos/tree-cat-silhouette-moon-full-moon-736877/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="c063" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">上面提供的文档不能回答这些类型的问题。当您有一个线性模型时，您可以使用参数估计来解释结果。然而，随着模型开始变得复杂(像神经网络这样的黑盒模型)，解释结果变得更加困难。在这种情况下，你需要一个黑盒模型来获得更好的结果，但解释这些结果变得更加困难，这是一个讽刺。此外，当你被要求解释一个你过去开发的模型时，你需要一定的时间才能得到答案。SHAP解决了这个根本的缺点。</p><h2 id="0ccd" class="nm lb it bd lc nn no dn lg np nq dp lk mb nr ns lm mf nt nu lo mj nv nw lq nx bi translated">你将从这篇文章中学到什么？</h2><ol class=""><li id="b6d5" class="ny nz it lu b lv lw ly lz mb oa mf ob mj oc mn od oe of og bi translated">对模型进行分类以执行实时评分</li><li id="6c9c" class="ny nz it lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated">使用Streamlit创建一个前端API来与您的模型通信并获得预测</li><li id="cf2c" class="ny nz it lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated">使用SHAP解释模型预测</li></ol><p id="fe23" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">GitHub资源库中提供了完整的代码。</p><div class="om on gp gr oo op"><a href="https://github.com/Sundar0989/model-interpretability" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">sundar 0989/模型-可解释性</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd kt op"/></div></div></a></div><p id="bd73" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">在这个练习中，我使用了<a class="ae kz" href="https://github.com/Sundar0989/model-interpretability/blob/main/bank-full.csv" rel="noopener ugc nofollow" target="_blank">银行数据集</a>来构建一个二元分类模型。<a class="ae kz" href="https://github.com/Sundar0989/model-interpretability/blob/main/Trial_API.ipynb" rel="noopener ugc nofollow" target="_blank"> jupyter笔记本</a>将带你完成为pickle文件创建对象的步骤。在本练习中，我们在pickle文件中存储4个对象。</p><ol class=""><li id="33cf" class="ny nz it lu b lv mp ly mq mb pe mf pf mj pg mn od oe of og bi translated"><strong class="lu iu"> d </strong> —标签编码器对象，用于将分类数据转换为数字数据</li><li id="8ae1" class="ny nz it lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated"><strong class="lu iu"> features_selected </strong> —分类模型中使用的特征</li><li id="888e" class="ny nz it lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated"><strong class="lu iu"> clf </strong> —随机森林分类模型</li><li id="db2c" class="ny nz it lu b lv oh ly oi mb oj mf ok mj ol mn od oe of og bi translated"><strong class="lu iu">讲解人</strong> — SHAP讲解对象</li></ol><p id="8ee9" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">一旦准备好pickle文件，就可以继续创建API了。</p><blockquote class="ph pi pj"><p id="8c16" class="ls lt mo lu b lv mp ju lx ly mq jx ma pk mr md me pl ms mh mi pm mt ml mm mn im bi translated"><strong class="lu iu">第一步:对你的模型进行分类，进行实时评分</strong></p></blockquote><h2 id="e604" class="nm lb it bd lc nn no dn lg np nq dp lk mb nr ns lm mf nt nu lo mj nv nw lq nx bi translated">helper.py</h2><p id="f6e2" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">这个文件包含执行评分的帮助函数。当您获得原始数据时，需要对其进行处理，并为评分做好准备。这是通过<strong class="lu iu"><em class="mo">transform _ categorial</em></strong>函数实现的。一旦数据被处理，我们可以使用<strong class="lu iu"> <em class="mo"> score_record </em> </strong>函数对数据进行评分。该函数返回概率和预测，稍后将在前端API中显示。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><h2 id="aa3c" class="nm lb it bd lc nn no dn lg np nq dp lk mb nr ns lm mf nt nu lo mj nv nw lq nx bi translated">app.py</h2><p id="b973" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">这个flask应用程序用于读取你的模型对象并产生分数。首先我们读取之前创建的pickle文件(<strong class="lu iu"><em class="mo">score _ objects . pkl</em></strong>)并加载模型对象。第二，我们从Streamlit前端API以<em class="mo"> json </em>格式获取数据。第三，我们使用助手函数来执行预处理并生成分数。最后，我们将分数发回Streamlit前端API。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><h2 id="1148" class="nm lb it bd lc nn no dn lg np nq dp lk mb nr ns lm mf nt nu lo mj nv nw lq nx bi translated">requirements.txt</h2><p id="7ce8" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">该文件包含执行上述操作所需的包的列表。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><h2 id="f4bc" class="nm lb it bd lc nn no dn lg np nq dp lk mb nr ns lm mf nt nu lo mj nv nw lq nx bi translated">Dockerfile文件</h2><p id="be46" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">这个文件用于为您的模型创建一个docker，并将整个应用程序容器化。正如您所看到的，它获取了一个基础映像(<strong class="lu iu"><em class="mo">python:3.7-stretch</em></strong>)，并在映像内部创建了一个工作目录(<strong class="lu iu"> <em class="mo"> /deploy/ </em> </strong>)。我们把前面提到的文件(<strong class="lu iu"> <em class="mo"> app.py，requirements.txt，helper.py和score_objects.pkl </em> </strong>)复制到工作目录下。它在映像内部的requirements.txt文件中安装包(第7行),并将端口5000暴露给外部的wold。当flask被执行时(第9行),它将使用这个端口与外部应用程序通信。如果需要使用不同的端口，那么在<strong class="lu iu"> <em class="mo"> app.py </em> </strong>文件中配置端口。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="44c0" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">所有这些文件都驻留在一个名为<strong class="lu iu"> <em class="mo">的目录中。</em></strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/467872c40acd81595bcfaac29799662a.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*IC--nQ0pYHXOiR81yQ4kDA.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><strong class="bd pq"> pythonapi </strong>目录结构</p></figure><blockquote class="mw"><p id="99b8" class="mx my it bd mz na nb nc nd ne nf mn dk translated">注意:在创建docker容器之前，您可以通过单独运行app.py文件来测试您的应用程序。这将避免不必要的错误，并有助于代码调试。我推荐使用<a class="ae kz" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Postman API </a>来完成这个任务。</p></blockquote><h2 id="4410" class="nm lb it bd lc nn pr dn lg np ps dp lk mb pt ns lm mf pu nu lo mj pv nw lq nx bi translated">使用Postman API调试应用程序</h2><p id="51b6" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">您需要确保按照步骤来设置Postman API。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pw"><img src="../Images/cbcc556d598f80bec26c231172feefa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsZFmmrCEO_XRihbt7jjYw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Postman API应用步骤</p></figure><p id="19d8" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">启动终端/命令提示符，使用下面显示的命令执行app.py文件。</p><p id="5ee3" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><strong class="lu iu"> python app.py </strong></p><p id="ce98" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">应用程序启动后，使用下面的示例验证应用程序是否正确运行，没有任何错误。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="b404" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">您应该会得到如下所示的输出。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="7144" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">完成调试后，您可以进入下一步，创建前端Streamlit API。</p><blockquote class="ph pi pj"><p id="97c8" class="ls lt mo lu b lv mp ju lx ly mq jx ma pk mr md me pl ms mh mi pm mt ml mm mn im bi translated">步骤2:使用Streamlit创建一个前端API</p></blockquote><p id="b8b9" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">Streamlit前端API位于自己的docker容器中。这样，前端应用程序就独立于模型docker，并且可以随时更改。这是一个很好的行业惯例。streamlit的目录结构如下所示。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi px"><img src="../Images/1bc86cc397bbb06222c043d7bd13d94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*CUN9xgUhbqLhSMrM91ku1A.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><strong class="bd pq"> streamlitapi </strong>目录结构</p></figure><h2 id="8d30" class="nm lb it bd lc nn no dn lg np nq dp lk mb nr ns lm mf nt nu lo mj nv nw lq nx bi translated">webapp.py</h2><p id="ef25" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">该文件包含创建Streamlit应用程序的代码。使用Streamlit的最大好处是您可以在工作时交互式地构建前端，并且只需要最少的代码。您需要确保Python API端点指向之前创建的<strong class="lu iu"> <em class="mo"> pythonapi </em> </strong>目录。如果您使用了不同的目录名，您需要更改它才能工作。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="e363" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">要调试这个应用程序，您可以使用下面的代码。</p><p id="8e1e" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><strong class="lu iu"> streamlit run webapp.py </strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi py"><img src="../Images/de69931ca1240db0aee20e0c35b49521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaZj_u-wD-IAjIsPvFA6rA.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">简化应用编程接口</p></figure><p id="b808" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">最终的前端API看起来如上。在这个API中，您可以在左侧栏中提供输入数据，然后在主页面中获得实时预测和解释。</p><h2 id="c1c3" class="nm lb it bd lc nn no dn lg np nq dp lk mb nr ns lm mf nt nu lo mj nv nw lq nx bi translated">需求. py</h2><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><h2 id="13c6" class="nm lb it bd lc nn no dn lg np nq dp lk mb nr ns lm mf nt nu lo mj nv nw lq nx bi translated">Dockerfile文件</h2><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="6f78" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">我们在这个目录中还有<strong class="lu iu"><em class="mo">score _ objects . pkl</em></strong>文件，也可以访问SHAP解释器对象。</p><p id="8cdc" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">现在，我们准备将shapley解释值合并到API中。</p><blockquote class="ph pi pj"><p id="6ab5" class="ls lt mo lu b lv mp ju lx ly mq jx ma pk mr md me pl ms mh mi pm mt ml mm mn im bi translated">第三步:使用SHAP解释模型预测</p></blockquote><p id="7080" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">SHAP的代码已经包含在<strong class="lu iu"> <em class="mo"> webapp.py </em> </strong>中。下面的代码是摘自<strong class="lu iu"> <em class="mo"> webapp.py </em> </strong>的片段。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="0ceb" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><strong class="lu iu"> <em class="mo">解释_模型_预测</em> </strong>函数产生解释结果所需的shap值。<strong class="lu iu"> <em class="mo"> st_shap </em> </strong>函数获取force_plot对象(p)生成的图形，并使其与Streamlit API兼容。最后，我们为每个预测添加了汇总图。</p><p id="ee30" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">现在，我们已经准备好了各个组件，让我们将它们组合在一起，使我们的应用程序工作。我们将使用docker-compose来执行这项任务。代码如下。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="03f5" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">这是使这个东西工作的整个目录的结构。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/4e6d7bf621fb9ee3a613342f723d956f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*JvOZmZtZ_8lot27k9UbQyQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">整个目录结构</p></figure><p id="2262" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">导航到终端/命令提示符并执行以下命令。</p><p id="9ab2" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><strong class="lu iu"> docker-compose构建</strong></p><p id="a7e7" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">它将构建完整的图像，并在模型和streamlit docker之间建立必要的连接。一旦该步骤完成，您就可以执行下面的代码来运行应用程序。</p><p id="93f5" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><strong class="lu iu"> docker-compose up </strong></p><p id="1a48" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">您将在URL中看到应用程序—<a class="ae kz" href="http://localhost:8501/" rel="noopener ugc nofollow" target="_blank">http://localhost:8501/</a>。要运行应用程序，为每个特性提供一些输入，并点击<strong class="lu iu">“获取预测”</strong>按钮。您应该得到如下所示的输出。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi qa"><img src="../Images/b3b6fce9bc411721f9977a788abbfbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrlvQZifZOOwH2BJ3yvnbA.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Streamlit API输出1</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi qb"><img src="../Images/788ffa3621510ce2275f664609161733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiZ9OpAgmyA4dhDyIPi3MA.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Streamlit API输出2</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi qb"><img src="../Images/9d00c4da1ad0ae5dce837a7d4b8e930c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*caTRE0-uagAYDj_Iuzf0aQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Streamlit API输出3</p></figure><p id="8830" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">除了预测和概率，你还会得到一个很好的可解释的图表，解释为什么模型会做出这样的预测。一旦您使用完API，您可以使用下面的代码关闭。</p><p id="f26e" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><strong class="lu iu"> docker-compose down </strong></p><p id="8bd3" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">就是这样。现在，您拥有了一个具有良好前端的实时模型评分和解释应用程序。您可以根据自己的目的/应用添加/修改/删除图。</p><p id="2f0c" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">玩得开心！</p></div></div>    
</body>
</html>