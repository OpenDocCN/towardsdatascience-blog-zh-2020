<html>
<head>
<title>Joining Datasets with Python’s Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的熊猫连接数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/joining-datasets-with-pythons-pandas-ed832f01450c?source=collection_archive---------36-----------------------#2020-10-26">https://towardsdatascience.com/joining-datasets-with-pythons-pandas-ed832f01450c?source=collection_archive---------36-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="42ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Pandas连接、追加和合并数据集</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f4a491a9aeaa1c58a97f15ad075c165e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C7PCggK9wNhdcXSq.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自PixBay — <a class="ae ky" href="https://pixabay.com/photos/panda-family-pandas-cute-bamboo-3811734/" rel="noopener ugc nofollow" target="_blank"> Nick115 </a></p></figure><p id="3057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在执行分析时，使用多个数据集的情况并不少见。因此，有大量的方法将这些数据整合在一起。</p><p id="515c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL将这些操作称为“联接”或“联合”；在其他语言和工具中，您可能会找到类似Merge或LookUp的功能来完成这项工作。</p><p id="9e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍一些我们可以用来将数据集与<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/getting_started/install.html" rel="noopener ugc nofollow" target="_blank">熊猫</a>连接起来的函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="77b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在一个<a class="ae ky" href="https://jupyterlab.readthedocs.io/en/stable/getting_started/installation.html" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中运行我的代码，我们在示例中唯一需要的是<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/getting_started/install.html" rel="noopener ugc nofollow" target="_blank">熊猫</a>。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="9c6f" class="mh mi it md b gy mj mk l ml mm">import pandas as pd</span></pre><p id="f95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从为示例定义一些虚拟数据开始，为了简化，我将使用列表，但是绝对鼓励您<a class="ae ky" href="https://medium.com/python-in-plain-english/reading-data-with-pythons-pandas-2715ff925b1d" rel="noopener">加载数据集</a>。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="5e66" class="mh mi it md b gy mj mk l ml mm"># create 5 lists with the same size<br/>names = ['bob', 'bella', 'blue', 'suzy', 'gunter', 'joe', 'holly', 'coco', 'elliot']</span><span id="b23b" class="mh mi it md b gy mn mk l ml mm">species = ['dog', 'cat', 'velociraptor', 'dog', 'penguin', 'squid', 'cat', 'cat', 'horse']</span><span id="2537" class="mh mi it md b gy mn mk l ml mm">age = [1, 6, 70, 8, 3, 1, 2, 13, 3]<br/>weight = [10, 5, 15, 7, 4, 1, 3, 2, 380]</span><span id="74ef" class="mh mi it md b gy mn mk l ml mm">color = ['brown', 'black', 'blue', 'black', 'black', 'gray', 'white', 'orange', 'white']</span></pre><p id="e924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义列表后，我们可以创建数据框。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="a964" class="mh mi it md b gy mj mk l ml mm"># create 3 data frames with the values from the lists</span><span id="57c7" class="mh mi it md b gy mn mk l ml mm">df1 = pd.DataFrame( {'name': names[:3],<br/>                     'species': species[:3],<br/>                     'age': age[:3]})</span><span id="a362" class="mh mi it md b gy mn mk l ml mm">df2 = pd.DataFrame( {'name': names[3:6],<br/>                     'species': species[3:6],<br/>                     'age': age[3:6]})</span><span id="b6c1" class="mh mi it md b gy mn mk l ml mm">df3 = pd.DataFrame( {'name': names[6:],<br/>                     'species': species[6:],<br/>                     'age': age[6:]})</span><span id="f235" class="mh mi it md b gy mn mk l ml mm">print(df1, '\n')<br/>print(df2, '\n')<br/>print(df3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/9b23c66899c977f933cebd60cf167da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*6YQuRVScSO-1v0XJCoikiw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三个数据帧</p></figure><p id="cdd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好，我们有三个列和大小相同的数据集。假设我们希望将这些数据分组到一个数据框中。</p><h1 id="c6af" class="mp mi it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">。串联</h1><p id="ac77" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">为此，我们可以使用。concat，这是一个接受数据帧列表并将它们连接成一个数据帧的函数。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="e453" class="mh mi it md b gy mj mk l ml mm"># .concat to join the dataframes, like a 'union all'<br/>df_list = [df1, df2, df3]<br/>df = pd.concat(df_list)</span><span id="0233" class="mh mi it md b gy mn mk l ml mm">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b7d077efa07a2a8d3e996c23930f87e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*eP8QRMJaeziE6a789_c2HQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">级联数据帧</p></figure><p id="a632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很酷，Pandas匹配了这些列，并毫不费力地返回了一个几乎完美的数据框。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="e2ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果列名不匹配呢？或者如果我们遗漏了一列呢？</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="9636" class="mh mi it md b gy mj mk l ml mm"># test with mismatching and missing columns</span><span id="dfdc" class="mh mi it md b gy mn mk l ml mm">df1 = pd.DataFrame( {'name': names[:3],<br/>                     'specie': species[:3],<br/>                     'age': age[:3]})</span><span id="6d78" class="mh mi it md b gy mn mk l ml mm">df2 = pd.DataFrame( {'name': names[3:6],<br/>                     'species': species[3:6],<br/>                     'age': age[3:6]})</span><span id="b0ae" class="mh mi it md b gy mn mk l ml mm">df3 = pd.DataFrame( {'name': names[6:],<br/>                     'age - years': age[6:]})</span><span id="b91c" class="mh mi it md b gy mn mk l ml mm">print(df1, '\n')<br/>print(df2, '\n')<br/>print(df3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d285f91d249b7387df94e62f1ac19f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*ftm6k_1bS4NH59tnQJdv-g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据帧不匹配</p></figure><p id="151b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于“物种”一栏，我在第一个df中更改了它的名称，并从最后一个中删除了它；我还把“年龄”重新命名为“年龄——年”。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="f7ad" class="mh mi it md b gy mj mk l ml mm"># concat with mismatching and missing columns<br/>df_list = [df1, df2, df3]<br/>df = pd.concat(df_list)</span><span id="7a8a" class="mh mi it md b gy mn mk l ml mm">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f40075abb42a3cc1af50691ff7fed3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*T05P4ZZuLRo4d-8MHe3N-A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">串联不匹配的数据帧</p></figure><p id="cca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，熊猫。concat要求列名完全匹配。如果一个列对于数据集来说是唯一的，就像完全连接一样，它会用空值填充空隙。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/585bf8e987da9f39ee3ccf9d503d95a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*fGZbDjYH86B8GSoC6vkBVA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我用Sketch.io制作——知识共享</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="8ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一件事我们需要注意，索引。</p><p id="8fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们在创建数据框时没有定义唯一索引，Pandas为我们设置了一些从零开始的默认值，但当我们使用. concat时，它不会重置它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e7c4f5fa17b13db9888777cb9f91f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jG5pJnsSKumxhHfB.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自PixBay — <a class="ae ky" href="https://pixabay.com/photos/panda-cub-wildlife-zoo-cute-china-649938/" rel="noopener ugc nofollow" target="_blank"> Skeeze </a></p></figure><p id="6c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的索引总是一个好主意。在这种情况下，我们可以使用。reset_index创建一个具有适当值的新列，或者使用。set_index将其中一列定义为索引。</p><p id="c604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是让我们尝试一个更简单的适合我们情况的解决方案。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="726b" class="mh mi it md b gy mj mk l ml mm">df1 = pd.DataFrame( {'name': names[:3],<br/>                     'species': species[:3],<br/>                     'age': age[:3]})</span><span id="c603" class="mh mi it md b gy mn mk l ml mm">df2 = pd.DataFrame( {'name': names[3:6],<br/>                     'species': species[3:6],<br/>                     'age': age[3:6]})</span><span id="ec49" class="mh mi it md b gy mn mk l ml mm">df3 = pd.DataFrame( {'name': names[6:],<br/>                     'species': species[6:],<br/>                     'age': age[6:]})</span><span id="f3e9" class="mh mi it md b gy mn mk l ml mm"># since we didn't define the indexes when creating the dataframes we can ignore them when concatenating</span><span id="c810" class="mh mi it md b gy mn mk l ml mm">df_list = [df1, df2, df3]<br/>df = pd.concat(df_list, ignore_index=True)</span><span id="b23e" class="mh mi it md b gy mn mk l ml mm">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b4dc51610bae797f462d53662e8243ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*dc7nq3Bp3wF4Dp-_X2O5Bw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">级联数据帧重新索引</p></figure><p id="763c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于单个参数，我们忽略了索引，并在连接的结果中获得了新的索引。</p><p id="5d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个方便的参数是“keys ”,它允许我们用一个新的索引级别来标识数据源。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="633e" class="mh mi it md b gy mj mk l ml mm">df1 = pd.DataFrame( {'name': names[:3],<br/>                     'species': species[:3],<br/>                     'age': age[:3]},<br/>                     index = [1,2,3])</span><span id="6d00" class="mh mi it md b gy mn mk l ml mm">df2 = pd.DataFrame( {'name': names[3:6],<br/>                     'species': species[3:6],<br/>                     'age': age[3:6]},<br/>                     index = [10,11,12])</span><span id="c3d2" class="mh mi it md b gy mn mk l ml mm">df3 = pd.DataFrame( {'name': names[6:],<br/>                     'species': species[6:],<br/>                     'age': age[6:]},<br/>                     index = [100,200,300])</span><span id="fcf4" class="mh mi it md b gy mn mk l ml mm"># we can pass 'keys' which creates another index level to identify the concatenated data frames<br/>df_list = [df1, df2, df3, df1]<br/>df = pd.concat(df_list, keys=['df1', 'df2', 'df3', 'df4'])</span><span id="6f34" class="mh mi it md b gy mn mk l ml mm">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c04846aad815da9a3f205c3be67d3c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*pVQZX9D49E99sjkanT42Mg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加了索引级别的级联数据帧</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，。concat使用列作为键，并将值追加为行。但是如果我们想要将列连接到数据框呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4287e601590c3e7340fba59d5e22d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7dP-l3bCpXu5Ua9D.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自PixBay — <a class="ae ky" href="https://pixabay.com/photos/columns-hallway-architecture-greek-801715/" rel="noopener ugc nofollow" target="_blank">免费照片</a></p></figure><p id="bb31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们定义一些要连接的新列。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="e77f" class="mh mi it md b gy mj mk l ml mm">df4 = pd.DataFrame( {'weight': weight,<br/>                     'color': color<br/>                     })<br/>df4</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/29d440b435a4e7e0eb67c6117ec5c785.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*aOFF0S32lEBkCDHwncxM6w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有额外列的数据框</p></figure><p id="d7f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们可以将列表直接添加到数据框中，方法是将它们分配给一个列，如下所示:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="6027" class="mh mi it md b gy mj mk l ml mm">df['color'] = color</span></pre><p id="3fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是一个数据框可能有很多字段，逐个传递它们并不是最好的选择。</p><p id="eb2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">concatenate函数接受“轴”的参数，这允许我们这样做—连接列。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="8590" class="mh mi it md b gy mj mk l ml mm">df = pd.concat([df, df4], axis=1)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/aea94734a6cbb4972ad278262818ae6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*PhZcd9BohgR58c6tjdvDqQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">级联数据帧</p></figure><p id="85a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以改变连接的行为。</p><p id="4cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试将“name”列作为我们的索引，并使用额外的一列创建另一个数据集进行实验。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="affe" class="mh mi it md b gy mj mk l ml mm">df_list = [df1, df2]<br/>df = pd.concat(df_list)<br/>df.set_index('name', inplace=True)</span><span id="82a7" class="mh mi it md b gy mn mk l ml mm">df5 = pd.DataFrame( {'species': species,<br/>                     'age': age,<br/>                     'score': [9,10,10,8,6,9,3,4,10]},<br/>                     index = names)</span><span id="d73a" class="mh mi it md b gy mn mk l ml mm">print(df, '\n')<br/>print(df5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/e5d10073e873c7a9234710f54c73be06.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*SwpvpIbu-ZNMZXe12mq2dw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更多数据帧</p></figure><p id="60ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们的第一个数据框比第二个数据框的值少。当我们执行内部连接时，它应该只带来索引匹配的行。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="30a8" class="mh mi it md b gy mj mk l ml mm"># by default concat behaves like an outer join, or a union all<br/># we can change that with the 'join' parameter<br/>df_list = [df, df5]<br/>df = pd.concat(df_list, axis=1, join='inner')<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/068ff461d4223b12fec08d5afe63075d.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*FgWd7vGuMg86uWhTEH2-ug.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用内部连接连接的数据帧</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ab400650b40bbbeab08afbfd4480a3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*vj4M43f-7_y1xE13c5czWA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我用Sketch.io制作——知识共享</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d700" class="mp mi it bd mq mr nw mt mu mv nx mx my jz ny ka na kc nz kd nc kf oa kg ne nf bi translated">。附加</h1><p id="3ea9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">现在让我们看看另一个名为. append的函数。</p><p id="6d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此函数的行为与. concat类似。前面的函数获取多个数据帧，并将它们连接成一个新的数据帧。追加方法将使用现有数据框添加数据。</p><p id="30b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者都将返回数据框，但是调用它们的方式不同。您将使用Pandas.concat()和DataFrame.append()。</p><p id="00f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一些例子。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="7da0" class="mh mi it md b gy mj mk l ml mm">df1.append(df2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/23e946777e7ed70932f7036f22d50bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*JwDe7KgrPoy482E7LLt-sQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">附加到数据帧1的数据帧2</p></figure><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="afb3" class="mh mi it md b gy mj mk l ml mm">df = df1.append(df2)<br/>df = df.append(df3)<br/>print(df, '\n')</span><span id="220a" class="mh mi it md b gy mn mk l ml mm">df = df1.append([df2, df3])<br/>print(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/cf8e6b4537e93011f06311021a3868de.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*O4C_oqsaEeTJrkTkcvxE7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个接一个附加的数据帧和附加有列表的数据帧</p></figure><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="2140" class="mh mi it md b gy mj mk l ml mm"># append a row<br/>df.append(pd.Series(['oliver', 'monkey', 13], index=['name', 'species', 'age']), ignore_index=True) </span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/7aca215c1c84dd2a6d6a3f1bb639e28a.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*roo-BLDkJyFewjipZtaG1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有附加行的数据框</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3e34" class="mp mi it bd mq mr nw mt mu mv nx mx my jz ny ka na kc nz kd nc kf oa kg ne nf bi translated">。合并</h1><p id="5418" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">太棒了。串联和。追加，我们可以执行我们可能需要的大多数连接。现在让我们检查一个更健壮的名为. merge的解决方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/8a0af97dcd18def9c792bb7f6574d0b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38c9-V7aDXk3nzYVRLZ3Bw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自Dreamstime</p></figure><p id="cae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从简单的事情开始，让我们看看如何。merge执行联接。</p><p id="5152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将定义另一个数据框，类似于我们已经在使用的数据框，但是多了一列，少了一条记录。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="0e2e" class="mh mi it md b gy mj mk l ml mm">print(df, '\n')</span><span id="29b1" class="mh mi it md b gy mn mk l ml mm">df6 = pd.DataFrame( {'name': names[1:],<br/>                     'age': age[1:],<br/>                     'score': [10,10,8,6,9,3,4,10]})<br/>print(df6)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/510859b127413384e966b3cb4fe09803.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*gTtaFrBOlMjzCiDLWpBi2A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更多用于实验的数据帧</p></figure><p id="302b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Merge允许我们选择哪个列将成为键；在这种情况下，让我们使用“名称”。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="f9d5" class="mh mi it md b gy mj mk l ml mm">merged_df = pd.merge(df, df6, on='name')<br/>merged_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d64e0590649613270bd73082ba321e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*0GoimfBCCQE7lBP-gBQ00g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由“名称”列合并的数据框。</p></figure><p id="d410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们之前看到的不同，默认情况下，合并是一个内部连接——这意味着除非另有说明，否则它将只返回两个数据集中匹配的行。</p><p id="012e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以注意到，两个数据集中的列是分开的，即使它们包含相同的值。</p><p id="da81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，当我们执行如上所示的内部连接时，两个数据框必须具有相同名称的键列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/487c58939d0e650042d0e038c1ca8d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rCttfix7TL-b0MIs.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自PixBay — <a class="ae ky" href="https://pixabay.com/photos/key-close-up-open-door-key-3497145/" rel="noopener ugc nofollow" target="_blank"> cocoparisienne </a></p></figure><p id="df0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以选择多个列作为键，就像组合键一样，还可以选择使用哪种连接。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="79e2" class="mh mi it md b gy mj mk l ml mm">merged_df = pd.merge(df, df6, how='left', on=['name', 'age'])<br/>merged_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/9f0986ae9d00c98c48a6e46014756cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*7dGgy5Jf_jh9Z28y35iNqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">姓名和年龄字段左侧的数据框已合并。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f8d78e91aee7c1676262851410828aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*oVsjIfj2vBlHvUDGD6ewNQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我用Sketch.io制作——知识共享</p></figure><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="bad7" class="mh mi it md b gy mj mk l ml mm">merged_df = pd.merge(df6, df, how='right', on=['name', 'age'])<br/>merged_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/314e6971098fec05079c1e5a9defb64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*cphzIw0Q6bdVHM7jUFIrPw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">姓名和年龄字段右侧的数据框已合并。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/357dfc1696f495c7573075694f339bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*Ir1E0bmZVNwxAV1g4bEmBA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我用Sketch.io制作——知识共享</p></figure><p id="c56c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！除此之外，合并功能还有助于我们验证和理解正在合并的数据。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="be94" class="mh mi it md b gy mj mk l ml mm"># 'one_to_one' or ‘1:1’<br/>merged_df = pd.merge(df6, df.append(df1), how='right', on=['name', 'age'], validate='one_to_one')</span><span id="7e66" class="mh mi it md b gy mn mk l ml mm">merged_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/f3121d312667d4ef70c328af39f4c8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWy9BVz6AFr7jKlktxM9vg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">出错信息</p></figure><p id="2d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果数据框不符合您选择的标准，验证参数将引发错误。</p><p id="dec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他有用的选项有:</p><p id="ba16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">‘一对多’</strong>或<strong class="lb iu">‘1:m’</strong>—检查左键是否唯一；</p><p id="ba59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">'多对一'</strong>或'<strong class="lb iu"> m:1' </strong> —检查右键是否唯一；</p><p id="581a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“指示器”参数向数据框中添加一列，解释键的关系。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="9385" class="mh mi it md b gy mj mk l ml mm">merged_df = pd.merge(df6, df.append(df1), how='outer', on=['name', 'age'], indicator=True)</span><span id="3904" class="mh mi it md b gy mn mk l ml mm">merged_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/cde4cc79473d71e07677dca714e3eced.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*-XvjwVqf6NS36YTLr5ja7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有指示器列的合并数据框</p></figure><p id="2364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="on">*如果您将一个字符串传递给指示器参数，它将被用作创建的列的名称。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="01dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不需要指定哪一列包含键，因为默认情况下，Pandas会假设索引是键。</p><p id="93c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试将名称设置为我们的索引，并再次合并这些数据框。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="7bfc" class="mh mi it md b gy mj mk l ml mm">df.set_index('name', inplace=True)<br/>df6.set_index('name', inplace=True)</span><span id="7581" class="mh mi it md b gy mn mk l ml mm">print(df)<br/>print(df6)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/aeca4919142a325425ae9274b86ff827.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*nYa926HgPSzeIxe_iqzyNw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按名称索引的数据框</p></figure><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="f203" class="mh mi it md b gy mj mk l ml mm">pd.merge(df6, df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/18707c05b708b84b837e6c78a46d7359.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*hznIWvm0eC3MpRjTU9BxDg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按索引合并的数据框</p></figure><p id="017c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不希望熊猫重置索引，我们必须使用right_index和left_index参数。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="cb0e" class="mh mi it md b gy mj mk l ml mm">pd.merge(df6, df, how='outer', left_index=True, right_index=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4763e262782b189464e29cf07d9043ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*USf3pD3d_GMfhR7bMHGwfw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按索引合并的数据框。</p></figure><p id="aa4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想一边合并一个索引，另一边合并一个键，我们可以指定right_on和left_on参数。</p><p id="e87b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们接受包含键的列名，就像我们之前看到的一样，但是将只应用于特定的一侧，使用另一侧的索引列。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="8443" class="mh mi it md b gy mj mk l ml mm">pd.merge(df, df6, how='right', right_on='name', left_index=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/0b3575efbea8d4ed0949c85086119457.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*aOfuuUjU-Z8Hb82akd-M8g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由索引和键列合并的数据框。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们看到了。串联和。append，连接两个数据框的两个方便的函数。然后我们探索了。合并，一个更好的选择，具有很大的灵活性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/5cf7df0748b97805bfc038c75316b418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HaKroF3msHm86WoW.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自PixBay — <a class="ae ky" href="https://pixabay.com/photos/panda-cub-wildlife-zoo-cute-china-1203101/" rel="noopener ugc nofollow" target="_blank"> PredragKezic </a></p></figure><p id="d58e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫有更多的方法来帮助你处理多个数据集；花时间构建解决问题的逻辑，然后在库中找到已经实现的解决方案，这种情况并不少见。</p><p id="b0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我鼓励大家看看其他一些功能，例如。比较，。combine_first，and。merge_asof。</p><p id="8485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读我的文章。我希望你喜欢它！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">参考文献:<br/> </strong> <a class="ae ky" href="https://www.oreilly.com/library/view/python-for-data/9781449323592/" rel="noopener ugc nofollow" target="_blank">用于数据分析的Python韦斯·麦金尼</a>；<br/> <a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html" rel="noopener ugc nofollow" target="_blank">熊猫—Concat</a>；<br/> <a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html" rel="noopener ugc nofollow" target="_blank">熊猫——合并</a>；<br/> <a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.append.html" rel="noopener ugc nofollow" target="_blank">熊猫—追加</a>；<br/> <a class="ae ky" href="https://pandas.pydata.org/docs/user_guide/merging.html" rel="noopener ugc nofollow" target="_blank">熊猫——合并、联结、连接、比较</a>；</p></div></div>    
</body>
</html>