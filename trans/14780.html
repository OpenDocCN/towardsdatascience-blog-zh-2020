<html>
<head>
<title>How to add Fourier terms to your regression &amp; seasonality analysis (using Python &amp; SciPy)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将傅立叶项添加到回归和季节性分析中(使用Python和SciPy)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-add-fourier-terms-to-your-regression-seasonality-analysis-using-python-scipy-99a94d3ae51?source=collection_archive---------12-----------------------#2020-10-12">https://towardsdatascience.com/how-to-add-fourier-terms-to-your-regression-seasonality-analysis-using-python-scipy-99a94d3ae51?source=collection_archive---------12-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="71ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用傅立叶项将季节性包括在回归中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89ce019a124952f3b94c10f86a17cdcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gL7OG-fudlk7Vowr1yLfHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">希望到此结束时，你也能够将你的回归提高410，000倍！</p></figure><h2 id="867c" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">重温我们的911电话记录</h2><p id="c924" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">在上一篇文章中，我们研究了如何使用傅立叶变换来分析宾夕法尼亚州蒙哥马利县911电话呼叫数据的季节性。如果你还没看过，看看下面吧(虽然你也一定能看完这篇文章)。</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/analyzing-seasonality-with-fourier-transforms-using-python-scipy-bb46945a23d3"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">使用Python和SciPy通过傅立叶变换分析季节性</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">通过寻找911电话数据中的季节性趋势，学会从噪音中分离信号</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><p id="648e" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">我们在数据中发现了一些有趣的周期性。通话量有3个主要的季节性趋势:每天，每天3次，每周一次。但是季节性并不能解释一切。历史不会完全重演。例如，潮汐整天都在退潮和流动(这是季节性的)，改变了水位，但每年，全球变暖都会增加整体海平面(除非我们采取措施)。如果你仅仅通过观察潮汐来预测未来许多年的水位，你会低估水位，因为你没有考虑海平面是如何随着时间的推移而上升的。</p><p id="3acd" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">同样，蒙哥马利县的人口从2010年到2019年增长了约3.9%，因此可以合理地假设，由于人口的增长，我们的数据中的911呼叫量也略有增加(我们将查明情况是否如此)。</p><p id="420b" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">为了解决这个问题，我们将对上次分析季节性的方法做一个大的改变。我们将首先运行线性回归，然后对残差(第一次回归的误差)执行傅立叶变换。</p><p id="4332" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">我们正在做的是尽最大努力不使用季节性来解释数据，然后我们将使用季节性来解释我们无法解释的东西。所以让我们开始吧。</p><h2 id="307a" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">计算残差</h2><p id="16c0" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">第一步是做回归。我的偏好是使用Sckit-Learn的线性回归模型，你可以使用任何你觉得舒服的模型。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="aa67" class="ky kz it nl b gy np nq l nr ns"># time_sec is the hourly timestamp converted to seconds<br/>X = pd.DataFrame(data['time_sec']) <br/># signal is how many calls were made in that hour<br/>y = pd.DataFrame(data['signal'])</span><span id="c31a" class="ky kz it nl b gy nt nq l nr ns">model = LinearRegression()<br/>model.fit(X, y) <br/>data['pred_signal_linreg'] = model.predict(X)<br/>data['residuals'] = data['signal'] - data['pred_signal_linreg']</span></pre><p id="53c2" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">查看模型系数和截距，我们发现斜率约为3E 10，截距为16.40。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b688" class="ky kz it nl b gy np nq l nr ns">&gt;&gt; print('Slope: {:.2e}, Intercept: {:.2f}'.format(model.coef_[0,0], model.intercept_[0]))<br/><strong class="nl iu">Slope: -2.59e-10, Intercept: 16.40</strong></span></pre><p id="83a3" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">因此，通话量从每小时约16.4次通话开始，每年通话量下降约10×60×60×24×365 3E每小时约0.009次通话。</p><p id="f056" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">我们最初的假设是，我们会看到911电话的增加与人口增长成比例，但这似乎并不正确。此外，很明显，这种回归不是很有帮助。其余真的少得可怜。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ac67" class="ky kz it nl b gy np nq l nr ns">&gt;&gt; print('R-squared: {:.2e}'.format(model.score(X,y)))<br/><strong class="nl iu">R-squared: 1.00e-06</strong></span></pre><p id="59b8" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">但是这种云也有一线希望。仅时间上的不良拟合就表明，我们可以通过引入傅立叶项来显著改善情况。</p><h2 id="843e" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">傅立叶变换和傅立叶逆变换</h2><p id="06d6" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated"><a class="ae nu" rel="noopener" target="_blank" href="/analyzing-seasonality-with-fourier-transforms-using-python-scipy-bb46945a23d3">第1部分</a>详细介绍了这一过程。简而言之，我们将使用傅立叶变换来找到最主要的频率，然后使用傅立叶逆变换来给出对应于这些频率的函数。</p><p id="d65e" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">这是傅立叶变换后我们找到的主频。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b337" class="ky kz it nl b gy np nq l nr ns">time = data['time']<br/>residuals = data['residuals']</span><span id="0123" class="ky kz it nl b gy nt nq l nr ns">fft_output = fft.fft(residuals)<br/>power = np.abs(fft_output)<br/>freq = fft.fftfreq(len(residuals))</span><span id="2109" class="ky kz it nl b gy nt nq l nr ns">peaks = scipy.sig.find_peaks(power[freq &gt;=0], prominence=10**4)[0]<br/>peak_freq =  freq[peaks]<br/>peak_power = power[peaks]<br/>plt.plot(peak_freq, peak_power, 'ro')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/e6da91c5ec5f8c7eebc683c1c60aa14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_dzKqUfofpQY-4_RvgjKg.png"/></div></div></figure><p id="4dd4" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">以下是这些峰值对应的值(与我们在第1部分中看到的没有太大不同)。为了便于参考，我将它们标为<code class="fe nw nx ny nl b">FT_1 ... FT_12</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/cdbd8ee0dbcab459b8df82edbc6f4893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qeVtBwnVicXijItTRCfn-Q.png"/></div></div></figure><p id="723d" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">如果您对如何获得这些值感兴趣，<code class="fe nw nx ny nl b">FFT </code>列是运行<code class="fe nw nx ny nl b">scipy.fft.fft(residuals)</code>的输出。您可以通过运行<code class="fe nw nx ny nl b">fft.fftfreq(len(residuals))</code>获得频率。这些频率的单位是<code class="fe nw nx ny nl b">1 / timestep</code>，其中时间步长是残差之间的间隔(在我们的例子中，这是一个小时)，振幅是<code class="fe nw nx ny nl b">abs(fft)</code>，相位是<code class="fe nw nx ny nl b">cmath.phase(fft)</code>。</p><p id="d9a2" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">这些行中的每一行都对应于一个正弦曲线。我们可以使用傅里叶逆变换来计算这些正弦曲线，并绘制它们的和与原始残差的关系。它们非常合适。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="8803" class="ky kz it nl b gy np nq l nr ns">filtered_residuals = fft.ifft(filtered_fft_output)</span><span id="9a86" class="ky kz it nl b gy nt nq l nr ns">N = 24 * 5<br/>plt.plot(time[:N], residuals[:N], linewidth=1, label='Original residuals')<br/>plt.plot(time[:N], filtered_residuals[:N].real, linewidth=1, label='Filtered residuals')<br/>plt.legend(loc='upper right')<br/>ax2.set_title('First 5 Days')<br/>plt.grid()<br/>plt.ylim((-25, 25))<br/>plt.xticks(rotation=90)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/69df09b23496bdef55674c236979335a.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*fM-NeQ3XeJTeLa9QZdB6VA.png"/></div></figure><h2 id="6905" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">融入我们的回归</h2><p id="37d0" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">现在让我们将正弦曲线纳入初始回归。这些正弦曲线的问题在于振幅不在范围内。你可以在上面的图表中看到，它显得太低了。这是因为我们对残差进行了傅里叶变换，并将输出过滤为12项。所以我们的过滤</p><p id="6161" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">我们最初的回归只是使用时间作为唯一的变量，但现在我们可以添加傅立叶项。相位、幅度和频率让我们用这个公式画出FFT项对应的波形。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0095c79cd83e99356d8184466eceb60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*uU_f7hmGjfuEfLbgz9vcxg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">A =振幅，ω=角频率= 2 *π*频率，φ=相移</p></figure><p id="8304" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">我们现在要做的是，如果我们增加几个与FFT波形相关的新变量，我们会得出什么样的新回归。</p><p id="5406" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">所以我们回到我们的原始数据，以秒为单位的时间和当时的呼叫次数，我们添加了几列，对应于傅立叶变换的每个波。然后我们可以将这些加在一起成为一个新的列，<code class="fe nw nx ny nl b">FT_All</code>。这看起来像:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="aaef" class="ky kz it nl b gy np nq l nr ns">for key in fourier_terms_dict.keys():<br/>    a = fourier_terms_dict[key]['amplitude']<br/>    w = 2 * math.pi * (fourier_terms_dict[key]['freq (1 / hour)'] / 3600)<br/>    p = fourier_terms_dict[key]['phase']<br/>    data[key] = data['time_sec'].apply(lambda t: math.cos(w*t + p))</span><span id="31e3" class="ky kz it nl b gy nt nq l nr ns">data['FT_All'] = 0<br/>for column in list(fourier_terms.index):<br/>    data['FT_All'] = data['FT_All'] + data[column]</span></pre><p id="4e6b" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">这为我们提供了一个新变量<code class="fe nw nx ny nl b">FT_All</code>，它与我们之前绘制的“过滤残差”相同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/1c0c8e2358662c30990dcbfa924f4be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EXhuc-qP8J_gNdy7xojywQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">之前我们只是对signal = f(time)进行回归，但现在我们可以对signal = f(time，FT_All)进行回归</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/310105f69729a7f4d3581952bb4ed7fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_oImUnHPBomNrJnbs7DbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">之前我们只是对signal = f(time)进行回归，但现在我们可以对signal = f(time，FT_All)进行回归</p></figure><p id="316c" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">这些傅立叶项可能看起来令人生畏，但基本上，它们只是我们认为在傅立叶变换中很重要的正弦曲线(即波)。它们很重要，因为它们在频域达到峰值。如果我们绘制<code class="fe nw nx ny nl b">FT_1</code>图，我们会看到这是一个具有一天周期和特定相移的波，这与我们在数据中看到的每日季节性相匹配。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="c8de" class="ky kz it nl b gy np nq l nr ns">&gt;&gt; plt.plot(data['time'][:24*5], data['FT_1'][:24*5])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/745aab2ec45d12c7f04bda0e4e3d996d.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*sw388552tGC6DiLgdoLknw.png"/></div></figure><p id="b807" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">现在我们可以使用新变量进行回归。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="60b7" class="ky kz it nl b gy np nq l nr ns"># time_sec is the hourly timestamp converted to seconds<br/># list(fourier_terms.index) are the names of our Fourier terms<br/>X = pd.DataFrame(data[['time_sec', 'FT_All']]) <br/># signal is how many calls were made in that hour<br/>y = pd.DataFrame(data['signal'])</span><span id="e988" class="ky kz it nl b gy nt nq l nr ns">model = LinearRegression()<br/>model.fit(X, y)</span></pre><p id="4464" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">这是前5天的回归结果。它看起来很有希望。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d7f7e6391dec7a77229c784163690a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*4ky1VQpTTi3WzC54bHSybg.png"/></div></figure><p id="6689" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">最后，如果我们检查模型得分，我们可以看到我们比以前做得好得多。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="350f" class="ky kz it nl b gy np nq l nr ns">&gt;&gt; model.score(X,y)<br/>0.4089566840099922</span></pre><p id="489b" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">通过增加一个新变量，R从0.000001提高到0.41。一点都不差！</p><h2 id="01d5" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么傅立叶变换对回归有帮助？</h2><p id="1046" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">傅立叶变换并不是回归中分析季节性的唯一方法。我肯定会考虑探索其他更简单的选择。就像为一天中的一个小时或一周中的一天添加一个虚拟变量，特别是如果你已经对将要发生的事情有了强烈的直觉。</p><p id="a6d6" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">例如，假设您知道911呼叫量在下午6点到9点之间达到峰值，那么您可以创建一个新变量，当时间在下午6点到9点之间时，该变量为<code class="fe nw nx ny nl b">1</code>，否则为<code class="fe nw nx ny nl b">0</code>。这个系数会非常清楚地告诉你，在晚上的时间里会有多少更多的呼叫量。</p><p id="14d4" class="pw-post-body-paragraph lu lv it lw b lx nf ju lz ma ng jx mc lh nh me mf ll ni mh mi lp nj mk ml mm im bi translated">挑战在于知道如何开始。是晚上6点到9点，还是晚上7点到10点？还是周末比晚上更能影响通话量？傅立叶变换是回答这些问题的好方法。它为您提供了一种可量化的方法来测量数据中的季节性。然后，如果您想在回归中利用它，有一个简单的选择，通过合并傅里叶变换输出的正弦曲线来实现。或者，您可以从傅立叶分析中获得见解，并在您的回归中测试更简单的变量。</p><h2 id="103c" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><a class="ae nu" href="https://github.com/Kommandat/seasonality-fourier-analysis/blob/master/notebooks/Part%202%20-%20Regression%20%20Analysis%20with%20scipy-fft.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Github上的项目代码</strong> </a></h2><h2 id="2be9" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><a class="ae nu" href="https://www.kaggle.com/mchirico/montcoalert" rel="noopener ugc nofollow" target="_blank">ka ggle上的数据集</a></h2><h2 id="80cf" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在此阅读第1部分<a class="ae nu" rel="noopener" target="_blank" href="/analyzing-seasonality-with-fourier-transforms-using-python-scipy-bb46945a23d3">的</a></h2><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/analyzing-seasonality-with-fourier-transforms-using-python-scipy-bb46945a23d3"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">使用Python和SciPy通过傅立叶变换分析季节性</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">通过寻找911电话数据中的季节性趋势，学会从噪音中分离信号</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div></div></div>    
</body>
</html>