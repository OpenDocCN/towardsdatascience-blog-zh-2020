<html>
<head>
<title>How to Handle Missing Values in Cross Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理交叉验证中的缺失值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-handle-missing-values-in-cross-validation-96fd569821d0?source=collection_archive---------33-----------------------#2020-11-11">https://towardsdatascience.com/how-to-handle-missing-values-in-cross-validation-96fd569821d0?source=collection_archive---------33-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3d0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么我们不应该用熊猫</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/997f48aa6a44e47c6d64a2bc8543e46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwV8cgwAYS0HttDy-Iph1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sofiameli?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊琳娜</a>在<a class="ae ky" href="https://unsplash.com/s/photos/missing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="96c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理缺失值是机器学习流水线中一个重要的数据预处理步骤。</p><p id="e0f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas在检测和处理缺失值方面是通用的。然而，当涉及到交叉验证的模型训练和评估时，有一种更好的方法。</p><p id="0bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">scikit-learn的估算器以及管道提供了一种更实用的方法来处理交叉验证过程中的缺失值..</p><p id="9adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将首先做几个例子，展示处理熊猫缺失值的不同方法。之后，我将解释为什么我们需要不同的方法来处理交叉验证中的缺失值。</p><p id="ae59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将使用scikit-learn的缺失值估算器和管道来做一个示例。</p><p id="cd1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说熊猫吧。这是一个简单的数据框架，有几个缺失值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7717" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd</span><span id="f0fb" class="ma mb it lw b gy mg md l me mf">df = pd.DataFrame(np.random.randint(10, size=(8,5)), columns=list('ABCDE'))</span><span id="065d" class="ma mb it lw b gy mg md l me mf">df.iloc[[1,4],[0,3]] = np.nan<br/>df.iloc[[3,7],[1,2,4]] = np.nan</span><span id="b845" class="ma mb it lw b gy mg md l me mf">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c73d0541e1dba21383cab7e7ee0ee814.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*ElpRxQhbtlQ_hikFnHLDvA.png"/></div></figure><p id="fb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">isna函数返回布尔值，指示缺少值的单元格。isna()。sum()给出了每一列中缺失值的数量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6e6d" class="ma mb it lw b gy mc md l me mf">df.isna().sum()<br/>A    2<br/>B    2<br/>C    2<br/>D    2<br/>E    2<br/>dtype: int64</span></pre><p id="e1c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fillna函数用于处理缺失值。它提供了许多选项来填写。让我们对每一列使用不同的方法。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="98fe" class="ma mb it lw b gy mc md l me mf">df['A'].fillna(df['A'].mean(), inplace=True)</span><span id="9a44" class="ma mb it lw b gy mg md l me mf">df['B'].fillna(df['B'].median(), inplace=True)</span><span id="413e" class="ma mb it lw b gy mg md l me mf">df['C'].fillna(df['C'].mode()[0], inplace=True)</span><span id="2b4f" class="ma mb it lw b gy mg md l me mf">df['D'].fillna(method='ffill', inplace=True)</span><span id="152f" class="ma mb it lw b gy mg md l me mf">df['E'].fillna(method='bfill', inplace=True)</span></pre><p id="6a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列A、B和C中缺少的值分别用该列的平均值、中值和众数填充。对于D列，我们使用“ffill”方法，该方法使用该列中的前一个值来填充缺失的值。“bfill”的作用正好相反。</p><p id="abc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是数据框架的更新版本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/b22c7c44256709e28d6c5e2f8d5ccaf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*1aJwOjrTLmcO6BWcPKE20Q.png"/></div></figure><p id="0133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在D列中仍然缺少一个值，因为我们对该列使用了“bfill”方法。使用这种方法，丢失的值应该用后面的值来填充。由于最后一个值是一个缺失值，因此未对其进行更改。</p><p id="a243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fillna函数也接受常数值。让我们用一个常量替换最后一个缺失的值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0a87" class="ma mb it lw b gy mc md l me mf">df['E'].fillna(4, inplace=True)</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="7d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，fillna函数非常灵活。然而，当涉及到训练机器学习模型时，我们需要小心处理丢失的值。</p><p id="4f3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非我们使用常量值，否则需要在拆分训练集和测试集后处理缺失值。否则，模型将被给予关于导致数据泄漏的测试集的信息。</p><p id="aa02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据泄露是机器学习中的一个严重问题。不应该给机器学习模型任何关于测试集的信息。测试集中的数据点需要是以前看不见的。</p><p id="e6f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用整个数据集的平均值来填充缺失值，我们会将关于测试集的信息泄露给模型。</p><p id="f554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种解决方案是在训练测试分割后处理缺失值。这绝对是一种可以接受的方式。如果我们想做交叉验证呢？</p><p id="f276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交叉验证意味着将数据集划分为子集(即折叠)。然后，使用不同的组合运行许多迭代，以便每个示例都将在训练和测试中使用。</p><p id="eb37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑5重交叉验证的情况。数据集被分成5个子集(即折叠)。在每次迭代中，4个折叠用于训练，1个折叠用于测试。经过5次迭代后，每个折叠都将用于训练和测试。</p><p id="a074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一种实用的方法来处理交叉验证过程中的缺失值，以防止数据泄漏。</p><p id="2c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是用scikit-learn创建一个管道。管道接受数据预处理功能，并可用于交叉验证过程。</p><p id="ef48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个适合简单线性回归任务的新数据框架。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8e09" class="ma mb it lw b gy mc md l me mf">df = pd.DataFrame(np.random.randint(10, size=(800,5)), columns=list('ABCDE'))</span><span id="3f8b" class="ma mb it lw b gy mg md l me mf">df['F'] = 2*df.A + 3*df.B - 1.8*df.C + 1.12*df.D - 0.5</span><span id="9cf8" class="ma mb it lw b gy mg md l me mf">df.iloc[np.random.randint(800, size=10),[0,3]] = np.nan</span><span id="e58b" class="ma mb it lw b gy mg md l me mf">df.iloc[np.random.randint(800, size=10),[1,2,4]] = np.nan</span><span id="7bb5" class="ma mb it lw b gy mg md l me mf">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/a8b125fd99bbdb45ed85cfd3b3538206.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*Z0K-HD_mEejCIJS7w02_-Q.png"/></div></figure><p id="8935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从A列到E列有10个缺失值。F列是具有附加偏差的其他列的线性组合。</p><p id="7ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们导入任务所需的库。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e2b4" class="ma mb it lw b gy mc md l me mf">from sklearn.linear_model import LinearRegression</span><span id="a4eb" class="ma mb it lw b gy mg md l me mf">from sklearn.pipeline import Pipeline</span><span id="8c3b" class="ma mb it lw b gy mg md l me mf">from sklearn.impute import SimpleImputer</span></pre><p id="06d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单估算器根据给定的策略填充缺失值。我们可以创建一个包含简单估算对象和线性回归模型的管道。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5793" class="ma mb it lw b gy mc md l me mf">imputer = SimpleImputer(strategy='mean')</span><span id="bef2" class="ma mb it lw b gy mg md l me mf">regressor = Pipeline(<br/>steps=[('imputer', imputer), ('regressor', LinearRegression())]<br/>)</span></pre><p id="1f35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“回归”管道包含一个简单的估算器，用平均值填充缺失值。线性回归模型完成预测任务。</p><p id="3d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以使用这个管道作为交叉验证的估计量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6d6a" class="ma mb it lw b gy mc md l me mf">X = df.drop('F', axis=1)<br/>y = df['F']</span><span id="f4b7" class="ma mb it lw b gy mg md l me mf">scores = cross_val_score(regressor, X, y, cv=4, scoring='r2')</span><span id="4dd9" class="ma mb it lw b gy mg md l me mf">scores.mean()<br/>0.9873438657209939</span></pre><p id="c279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">R平方得分相当高，因为这是一个预先设计的数据集。</p><p id="1c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里重要的一点是在分割训练集和测试集之后处理缺失值。如果我们做一个常规的训练测试分割，这在熊猫身上很容易做到。</p><p id="68e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果要做交叉验证，用熊猫会很繁琐。scikit-learn库的管道提供了一种更实用、更简单的方法。</p><p id="34b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道的范围相当广泛。您还可以在管道中添加其他预处理技术，例如用于数值的缩放器。使用管道可以实现某些任务的自动化，从而优化流程。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="6e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>