<html>
<head>
<title>Managing software dependencies for Data Science projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理数据科学项目的软件依赖性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/managing-software-dependencies-for-data-science-projects-523e70af82d4?source=collection_archive---------47-----------------------#2020-10-07">https://towardsdatascience.com/managing-software-dependencies-for-data-science-projects-523e70af82d4?source=collection_archive---------47-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2db7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保持项目依赖关系清晰和可重复的分步指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5f1804fac48b7fc2dcb20353283ec025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KBJ23MZxBrvIfrUO"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Emile Perron 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="086c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发软件项目时，虚拟环境是<em class="ls">的必备条件。它们允许您创建独立的Python安装，防止您的项目相互冲突，并让其他人复制您的设置。</em></p><p id="69b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，使用虚拟环境只是开发可重复数据项目的第一步。这篇文章讨论了另一个重要的主题:依赖性管理，它涉及到正确地记录虚拟环境，以简化可再现性，并使它们在部署到生产环境时变得可靠。</p><p id="ebf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于Python环境的更深入的描述，<a class="ae kv" href="https://ploomber.io/posts/python-envs/" rel="noopener ugc nofollow" target="_blank">参见另一篇文章</a>。</p><h1 id="5943" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">依赖性管理器如何工作</strong></h1><p id="3e10" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">TL；dr；软件包管理器使用试探法来安装相互兼容的软件包版本。大量的依赖项和版本约束可能会导致解析环境时失败。</em></p><p id="100b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您安装一个软件包时，您的软件包管理器(pip，conda)必须安装所请求的软件包的依赖项以及这些依赖项的依赖项，直到所有要求都得到满足。</p><p id="d971" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包通常有版本约束。例如，在编写<a class="ae kv" href="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/_build_utils/min_dependencies.py" rel="noopener ugc nofollow" target="_blank">时，scikit-learn </a>需要numpy 1.13.3或更高版本。当包共享依赖关系时，包管理器必须找到满足所有约束的版本(这个过程被称为依赖关系解析)，这样做在计算上是很昂贵的<a class="ae kv" href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" rel="noopener ugc nofollow" target="_blank"/>，当前的包管理器使用试探法在合理的时间内找到解决方案。</p><p id="3e80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于大量的依赖项，规划求解可能无法找到解决方案。一些包管理器会抛出一个错误，但是其他的可能只是打印一个警告消息。为了避免这些问题，了解项目的依赖性是很重要的。</p><h1 id="9334" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">开发和生产依赖关系</strong></h1><p id="102f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">TL；dr；对开发(即训练模型所需的包)和生产(即进行预测所需的包)中的依赖项进行分组。</em></p><p id="6e70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在从事数据科学项目时，可能会有一些只在开发时需要的包，但在生产环境中并不需要。例如，如果您正在开发一个模型，您可能会使用matplotlib在jupyter笔记本中生成一些评估图表，但是对于通过API提供预测，您不需要这些。</p><p id="2110" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使您有机会简化生产环境中的依赖关系。下一节将讨论如何做到这一点。</p><h1 id="f0f2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">维护依赖文件</strong></h1><p id="0195" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">TL；dr；为开发/生产依赖项保留单独的文件。手动添加/删除包，并尽可能保持它们的灵活性(通过不固定特定版本)，以简化依赖关系解析，并根据可用的最新兼容版本测试您的项目。</em></p><p id="ae38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mq mr ms mt b">pip</code>和<code class="fe mq mr ms mt b">conda</code>是Python使用最广泛的包管理器；两者都可以从文本文件中设置依赖关系。我推荐使用<code class="fe mq mr ms mt b">conda</code>(通过<a class="ae kv" href="https://docs.conda.io/en/latest/miniconda.html" rel="noopener ugc nofollow" target="_blank"> miniconda </a>)，因为它可以处理比<code class="fe mq mr ms mt b">pip</code>更多的依赖。你甚至可以安装非Python包，比如<a class="ae kv" href="https://ploomber.readthedocs.io/en/stable/user-guide/r-support.html#configuring-r-environment" rel="noopener ugc nofollow" target="_blank"> R </a>。如果有你不能使用<code class="fe mq mr ms mt b">conda install</code>安装的包，你仍然可以在conda环境中使用<code class="fe mq mr ms mt b">pip install</code>。</p><p id="d3a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mq mr ms mt b">conda</code>中，您可以在YAML文件中记录您的依赖关系，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="05e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然您可以自动生成这些文件，但最好手动维护它们。一个很好的做法就是加上一个简短的评论，让其他人知道(甚至是你未来的自己！)为什么需要套餐。在开发过程中，我们可能会试验一些包，但很快就将其丢弃，最好的方法是将其从环境文件中删除，但如果您忘记这样做，注释将有助于您将来决定丢弃哪些依赖项。</p><p id="401c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保持依赖关系的灵活性，并在必要时只固定特定的版本，添加到环境中的版本约束越多，遇到求解程序无法满足所有约束的可能性就越大。</p><h1 id="7a1d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">安装依赖关系</strong></h1><p id="4c94" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">TL；dr；在设置环境时总是寻找错误，有时您可能需要固定版本来解决问题。</em></p><p id="cad5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦指定创建环境文件，就可以使用以下命令创建conda虚拟环境:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4e84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有一组合理的依赖项，您的环境应该安装得很好，但是有一些因素可能会给出错误/警告。始终检查命令输出是否有问题。根据求解程序的配置，该命令可能会拒绝创建环境或打印警告消息。</p><p id="38b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我提到解决者试图找到满足所有包需求的解决方案，但这是在假设包维护者拥有最新需求的情况下。假设包X依赖于包Y，但X没有为Y设置任何版本约束。新版本的Y发布后会破坏X。下一次安装X时，如果求解器安装了不兼容版本的Y，则会导致安装失败(从求解器的角度来看，这不是问题，因为X没有为Y设置任何约束)。这些情况很难调试，因为您必须通过反复试验找到一个工作版本，然后将正确的版本固定在依赖文件中。</p><p id="2a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不从头测试环境设置的时间越长，破坏环境设置的风险就越大。因此，持续测试依赖文件是很重要的。</p><h1 id="856b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">测试您的开发环境</strong></h1><p id="fc09" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">TL；dr；在最近创建的环境中连续运行您的项目测试，以检测由于包更新引起的中断。</em></p><p id="83b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为你的开发包没有固定到一个特定的版本，包管理器将尝试安装最新的兼容版本，这从开发的角度来看是好的，因为包得到了改进:新的特性，错误修复和/或安全补丁，保持你的依赖关系更新是一个好主意；但它们也可能带来突破性的变化。要检测它们，请确保您在一个新的、最近安装的环境中运行项目的测试。流程如下:</p><ol class=""><li id="2cec" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">从干净的虚拟环境开始</li><li id="f5d5" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">安装依赖关系文件的依赖关系</li><li id="241e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">配置您的项目</li><li id="77a8" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">运行测试</li></ol><p id="adba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最好是，在每次修改源代码时自动运行这个过程(这被称为持续集成)。如果这不是一个选项，定期手动运行上述步骤。</p><h1 id="6f0b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">自动化项目设置和测试</strong></h1><p id="974c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">TL；dr；使用nox和pytest在一个全新的环境中运行您的测试，打包您的项目，这样您就可以轻松地在您的测试中导入项目的模块</em></p><p id="a0ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现的自动化环境设置和测试执行的最佳工具是<a class="ae kv" href="https://nox.thea.codes" rel="noopener ugc nofollow" target="_blank"> nox </a>和<a class="ae kv" href="https://pytest.org" rel="noopener ugc nofollow" target="_blank"> pytest </a>。</p><p id="a3fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Nox是一个Python包，可以自动创建conda环境，然后在该环境中运行您的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1e06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:在撰写本文时，nox(版本2020.8.22)并不正式支持从environment.yml文件安装，但这种变通方法可以做到这一点，</em> <a class="ae kv" href="https://github.com/theacodes/nox/issues/260" rel="noopener ugc nofollow" target="_blank"> <em class="ls">单击此处</em> </a> <em class="ls">了解更多信息。</em></p><p id="8c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您的环境准备好了，就包含启动测试套件的命令。我建议您使用pytest，下面是一个测试文件的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要执行上面文件中的测试，您只需在nox中运行<code class="fe mq mr ms mt b">pytest</code>，这转化为添加:<code class="fe mq mr ms mt b">session.run('pytest')</code></p><p id="905d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们已经完成了步骤1、2和4。但是跳过了3(配置项目)。正如您在前面的代码片段中看到的，为了测试您的代码，您必须使它可导入，最干净的方法是打包您的项目(要查看我们关于项目打包的帖子，<a class="ae kv" href="https://ploomber.io/posts/packaging/" rel="noopener ugc nofollow" target="_blank">单击此处</a>)。</p><p id="11a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你打包了你的项目，你就可以用<code class="fe mq mr ms mt b">pip install path/to/project</code>来设置它。</p><h1 id="8a3f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">测试您的开发和生产环境</strong></h1><p id="da95" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">TL；dr；开发单独的测试套件，您可以在一个具有开发依赖关系的环境中测试您的开发管道，并为API提供生产依赖关系。</em></p><p id="b2fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用nox分别测试您的开发和生产环境。下面是一些示例代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c417" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要运行您的测试，只需在终端中执行<code class="fe mq mr ms mt b">nox</code>。</p><h1 id="5ece" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">锁定文件</strong></h1><p id="c08d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">TL；dr；提供自动生成的锁文件，其中包含带有固定版本的开发/生产依赖项列表，以避免将来由于API更改而中断您的项目。</em></p><p id="0e4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不固定特定的版本，就无法知道求解器将安装的确切版本集，这对于开发目的来说很好，因为它给了您尝试新版本并检查是否可以升级它们的机会，但是您不希望在生产环境中出现这种不确定性。</p><p id="845b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题的方法是提供另一个文件，该文件列出了所有的依赖项，但包括特定的版本，这被称为<em class="ls">锁文件</em>。这样，您的环境将始终解析为同一组版本。</p><p id="02f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用以下命令生成具有固定依赖关系的文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a1a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出文件如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2f0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">锁文件对于保证生产中的确定性环境非常重要，请确保从您已经测试过的环境中生成它们。例如，您可以在测试会话结束时添加<code class="fe mq mr ms mt b">conda env export</code>命令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="05e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了固定版本之外，锁文件通常还提供其他功能，例如对每个包进行哈希处理，并将其与下载版本进行比较，以防止安装被篡改的软件。在撰写本文时，有一个名为<a class="ae kv" href="https://github.com/conda-incubator/conda-lock" rel="noopener ugc nofollow" target="_blank"> conda-lock </a>的新项目，旨在改进对conda锁文件的支持。</p><h1 id="cb3d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">闭幕词</strong></h1><p id="8294" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在你的项目中使用虚拟环境是开发更健壮的管道的第一步，但这并不是结束。将依赖项安装作为测试过程的一部分，保持较小的依赖项，将生产依赖项与开发依赖项分开，并提供锁文件，这些都是确保您的项目具有健壮设置的必要步骤。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="2cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">最初发布于</em><a class="ae kv" href="https://ploomber.io/posts/dependencies/" rel="noopener ugc nofollow" target="_blank"><em class="ls">http://ploomber . io</em></a></p></div></div>    
</body>
</html>