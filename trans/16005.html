<html>
<head>
<title>Using Cosine Similarity to Build a Movie Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用余弦相似度构建电影推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-cosine-similarity-to-build-a-movie-recommendation-system-ae7f20842599?source=collection_archive---------3-----------------------#2020-11-04">https://towardsdatascience.com/using-cosine-similarity-to-build-a-movie-recommendation-system-ae7f20842599?source=collection_archive---------3-----------------------#2020-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e79" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用余弦相似性构建基于Python的电影推荐系统的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c93ddd9985b70b0d0ac83808e23b332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ZloJ1wKzvFm1g2m2dz4FQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/jade87-3234870/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4011346" rel="noopener ugc nofollow" target="_blank"> Jade87 </a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4011346" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="d969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有想象过，在你已经喜欢的电影的基础上，你在高中学习的一个简单的公式会在推荐你一部电影的过程中发挥作用？</p><p id="fe27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们使用<strong class="lb iu">余弦相似度</strong>(归一化向量的点积)来构建一个<strong class="lb iu">电影推荐系统</strong>！</p><h1 id="1334" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是推荐系统？</h1><p id="db4b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">推荐系统</strong>是一类重要的机器学习算法，为用户提供“相关”建议。Youtube、亚马逊、网飞，都在推荐系统上发挥作用，系统根据你过去的活动(<strong class="lb iu">基于内容的过滤</strong>)或根据与你相似的其他用户的活动和偏好(<strong class="lb iu">协同过滤</strong>)向你推荐下一个视频或产品。同样，脸书也使用推荐系统来推荐你线下可能认识的脸书用户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/a63c5b560a8e2e9d885c4401d001f5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UFiSP77oIlL7ODAH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@glencarrie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·凯莉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推荐系统的工作基于内容或访问内容的用户之间的相似性。</p><p id="6e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以衡量两个项目之间的相似性。推荐系统使用这个<strong class="lb iu">相似矩阵</strong>向用户推荐下一个最相似的产品。</p><p id="aa1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将构建一个机器学习算法，根据用户喜欢的电影推荐电影。这个机器学习模型将基于<strong class="lb iu">余弦相似度</strong>。</p><h1 id="e233" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">获取数据集</h1><p id="1312" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">构建电影推荐系统的第一步是获取适当的数据。您可以从网上下载电影数据集，或者从下面的链接下载，该链接包含一个22MB的CSV文件，标题为“<strong class="lb iu"> movie_dataset.csv </strong>”:</p><div class="mt mu gp gr mv mw"><a href="https://github.com/MahnoorJaved98/Movie-Recommendation-System/blob/main/movie_dataset.csv" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">mahnoorjaved 98/电影推荐系统</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">github.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ks mw"/></div></div></a></div><p id="43ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来探索数据集吧！</p><p id="c457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的CSV文件总共包含了<strong class="lb iu"> 4802部电影</strong>和<strong class="lb iu"> 24个栏目</strong>:索引、预算、流派、主页、id、关键词、原创_语言、原创_标题、概述、人气、制作_公司、制作_国家、发行_日期、收入、运行时间、口语、状态、标语、标题、vote_average、vote_count、演员、剧组和导演(唉！).</p><p id="88ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有这些不同的特性中，我们感兴趣的是找出相似之处，以便提出下一个建议，这些特性如下:</p><blockquote class="nl nm nn"><p id="3ff8" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated"><strong class="lb iu">关键词</strong>、<strong class="lb iu">剧组</strong>、<strong class="lb iu">流派</strong> &amp; <strong class="lb iu">导演</strong>。</p></blockquote><p id="a3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">喜欢恐怖电影的用户很可能会喜欢另一部恐怖电影。一些用户可能喜欢在电影的演员阵容中看到他们最喜欢的演员。其他人可能喜欢某个人导演的电影。结合所有这些方面，我们入围的4个特征足以训练我们的推荐算法。</p><h1 id="c06e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">开始编码</strong></h1><p id="4b06" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，让我们从编码开始。首先，让我们导入我们需要的库，以及电影数据集的CSV文件。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="3450" class="nx lw it nt b gy ny nz l oa ob">import pandas as pd<br/>import numpy as np<br/>from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn.metrics.pairwise import cosine_similarity</span><span id="ec73" class="nx lw it nt b gy oc nz l oa ob">df = pd.read_csv(r"...\movie_dataset.csv")</span></pre><p id="466b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将导入两个重要的库用于数据分析和操作；<strong class="lb iu">熊猫</strong>和<strong class="lb iu"> numpy </strong>。我们还将导入Scikit-learn的<strong class="lb iu"> CountVectorizer，</strong>用于将一组文本文档转换成一个术语/标记计数的向量。</p><p id="a767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将从sklearn <strong class="lb iu">，</strong>中导入<strong class="lb iu">余弦_相似度</strong>作为我们相似度矩阵的度量(这将在后面详细讨论)。</p><p id="7823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将CSV文件读入数据帧<strong class="lb iu"> df </strong>，然后可以在Python IDE的变量浏览器中访问它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/f67c67d0ba3cc04935c984767754a07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNSNoupR00B1hpVfPZJxUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CSV加载到数据帧中(图片由作者提供)</p></figure><h1 id="ee41" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">功能列表</h1><p id="7365" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将列出我们将使用的功能。如上所述，考虑到我们手头的问题，我们将只使用与我们最相关的特性。因此，我们选择的功能将是<strong class="lb iu">关键词</strong>，<strong class="lb iu">演员</strong>，<strong class="lb iu">流派</strong> &amp; <strong class="lb iu">导演</strong>。</p><p id="5d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们将做一些<strong class="lb iu">数据预处理</strong>，并用空格/空字符串替换任何具有NaN值的行，这样在运行代码时就不会产生错误。这个预处理已经在for循环中完成了。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="4ffc" class="nx lw it nt b gy ny nz l oa ob">features = ['keywords', 'cast', 'genres', 'director']</span><span id="ebe3" class="nx lw it nt b gy oc nz l oa ob">for feature in features:<br/>    df[feature] = df[feature].fillna('')</span></pre><h1 id="a9ba" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将相关特征组合成单个特征</h1><p id="01a3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们将定义一个名为<strong class="lb iu"> combined_features的函数。该函数将把我们所有有用的特征(关键字、演员、流派&amp;导演)从它们各自的行中组合起来，并返回一个包含所有组合特征的行。</strong></p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="bdf8" class="nx lw it nt b gy ny nz l oa ob">def combined_features(row):<br/>    return row['keywords']+" "+row['cast']+" "+row['genres']+" "+row['director']</span><span id="adc2" class="nx lw it nt b gy oc nz l oa ob">df["combined_features"] = df.apply(combined_features, axis =1)</span></pre><p id="aa73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将添加一个新列，<strong class="lb iu"> combined_features </strong>到我们现有的dataframe (df)中，并将上述函数应用于每一行(轴= 1)。现在，数据帧的末尾将有一个额外的列，由多行组合特征组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/b74aa02dc8671a2ed4ae68732f582a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*7pDZim12uvdN9Tjs4rjNsQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的数据框架中的组合特征栏(图片由作者提供)</p></figure><h1 id="0dd8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">提取特征</h1><p id="4cda" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们将从数据中提取特征。</p><p id="000c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">sklearn.feature_extraction模块可用于从由文本和图像等格式组成的数据集中提取机器学习算法支持的格式的要素。我们将使用<strong class="lb iu"> CountVectorizer的fit . transform</strong>来计算文本的数量，并将转换后的矩阵<strong class="lb iu"> count_matrix </strong>打印成一个数组，以便更好地理解。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b3fd" class="nx lw it nt b gy ny nz l oa ob">cv = CountVectorizer()<br/>count_matrix = cv.fit_transform(df["combined_features"])<br/>print("Count Matrix:", count_matrix.toarray())</span></pre><h1 id="d17a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用余弦相似度</h1><p id="1fac" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将使用来自Sklearn的<strong class="lb iu">余弦相似度</strong>作为度量来计算两部电影之间的相似度。</p><p id="c535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">余弦相似性是一种用于衡量两个项目相似程度的度量。在数学上，它测量的是在多维空间中投影的两个向量之间的角度余弦。输出值范围从<strong class="lb iu">0–1</strong>。</p><blockquote class="nl nm nn"><p id="bea2" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it"> 0表示没有相似性，其中as 1表示两个项目100%相似。</em>T13】</strong></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ac2a107accd330f69adb3fd38d243fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ha1H7tU8dW_MS10N76-HTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">余弦相似度(图片由作者提供)</p></figure><p id="d4e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">python余弦相似度或余弦内核将相似度计算为输入样本X和y的归一化点积。我们将使用sk learn<strong class="lb iu">Cosine _ Similarity</strong>来查找计数矩阵中两个向量的cos θ <strong class="lb iu"> </strong>。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="a069" class="nx lw it nt b gy ny nz l oa ob">cosine_sim = cosine_similarity(count_matrix)</span></pre><p id="4e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> cosine_sim </strong>矩阵是一个numpy数组，用于计算每部电影之间的余弦相似度。下图可以看到，电影0与电影0的余弦相似度为1；它们100%相似(理应如此)。</p><p id="5956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，电影0和电影1之间的余弦相似度是0.105409(电影1和电影0之间的分数相同——顺序无关紧要)。</p><p id="3fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">电影0和4比电影0和3更相似(相似性分数为0.23094)(分数= 0.0377426)。</p><p id="0946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带有1的对角线表示情况是什么，每部电影“x”都与自己100%相似！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ce651985f7b60b23d43e198374fd40a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xs5gccVtnFdzU39j5PdFxA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">余弦相似矩阵(图片由作者提供)</p></figure><h1 id="07a7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用户喜欢的内容</h1><p id="91f6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下一步是在<strong class="lb iu"> movie_user_likes </strong>变量中输入用户喜欢的电影。</p><p id="c51c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们正在建立一个基于内容的过滤系统，我们需要知道用户的喜欢，以便预测类似的项目。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="f942" class="nx lw it nt b gy ny nz l oa ob">movie_user_likes = "Dead Poets Society"</span><span id="c62b" class="nx lw it nt b gy oc nz l oa ob">def get_index_from_title(title):<br/>    return df[df.title == title]["index"].values[0]</span><span id="c2f5" class="nx lw it nt b gy oc nz l oa ob">movie_index = get_index_from_title(movie_user_likes)</span></pre><p id="737b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我喜欢电影《死亡诗社》。接下来，我将构建一个函数来从这部电影的名称中获取索引。该索引将保存在<strong class="lb iu"> movie_index </strong>变量中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/48bc4810bb1c804ef14b6641f7e77eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*ugNPZGrGwAziP36UKO1_dA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户喜欢的电影的电影索引变量<strong class="bd oh"> </strong>(作者图片)</p></figure><h1 id="3b8f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生成相似电影矩阵</h1><p id="7270" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们将生成一个类似电影的列表。我们将使用我们给出的电影的<strong class="lb iu">电影_索引</strong>作为输入<strong class="lb iu">电影_用户_喜欢</strong>。enumerate()方法将向可迭代列表<strong class="lb iu">余弦_sim </strong>添加一个计数器，并以列表<strong class="lb iu">相似_电影</strong>的形式返回它，其中包含每个索引的相似性得分。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="8f4f" class="nx lw it nt b gy ny nz l oa ob">similar_movies = list(enumerate(cosine_sim[movie_index]))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/5bc476a34e5af1693a1ba676754248d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*Lb6Lhu__Dp2-ly8dYlU-Dw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相似电影列表(作者图片)</p></figure><h1 id="07e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">按降序对相似电影列表进行排序</h1><p id="b74b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下一步是对列表中的电影进行排序<strong class="lb iu">相似_电影</strong>。我们使用了参数reverse=True，因为我们希望列表按降序排列，最相似的条目在顶部。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="2d36" class="nx lw it nt b gy ny nz l oa ob">sorted_similar_movies = sorted(similar_movies, key=lambda x:x[1], reverse=True)</span></pre><p id="787c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> sorted_similar_movies </strong>将是按照与输入电影<strong class="lb iu"> movie_user_likes </strong>的相似性分数降序排序的所有电影的列表。</p><p id="74d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下图可以看出，相似度得分为0.9999999999999999993的最相似的一个在最上面，其索引号为2453(电影是我们作为输入给出的'死亡诗社'，有道理吧？).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e94017213d4f83f398248e82ead2e2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*FNUYEagVALLKGL5DJPqiqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相似分数排序的相似电影列表(图片由作者提供)</p></figure><h1 id="82c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">印刷相似的电影</h1><p id="83a6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，项目的最后一部分来了，打印电影的名字，类似于我们通过<strong class="lb iu"> movie_user_likes </strong>变量给系统输入的名字。</p><p id="b478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如<strong class="lb iu"> sorted_similar_movies </strong>列表所示，电影按其索引号排序。打印索引号对我们来说没有用，所以我们将定义一个简单的函数，将索引号转换成电影标题，就像在dataframe中一样。</p><blockquote class="nl nm nn"><p id="b68f" class="kz la no lb b lc ld ju le lf lg jx lh np lj lk ll nq ln lo lp nr lr ls lt lu im bi translated"><em class="it">索引号→电影名称</em></p></blockquote><p id="716d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们将在for循环中调用这个函数来打印来自<strong class="lb iu"> sorted_similar_movies </strong>的第一个“x”个电影。</p><p id="d75e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们将打印4802部电影中最相似的15部电影。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="18ea" class="nx lw it nt b gy ny nz l oa ob">def get_title_from_index(index):<br/>    return df[df.index == index]["title"].values[0]</span><span id="5e29" class="nx lw it nt b gy oc nz l oa ob">i=0<br/>for movie in sorted_similar_movies:<br/>    print(get_title_from_index(movie[0]))<br/>    i=i+1<br/>    if i&gt;15:<br/>        break</span></pre><h1 id="6c74" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">运行整个代码</strong></h1><p id="e462" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在应用程序来了。使用上述步骤编写您自己的推荐系统，并通过将您喜欢的电影交给<strong class="lb iu"> movie_user_likes </strong>来运行代码。</p><p id="a7f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我给了“<strong class="lb iu">死亡诗社</strong>”，它给我打印了以下类似的电影:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/e61a3e4072f1f988d0ab90f8aa50782f.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*h7vSO-OJoVS0yP1LCiaI7w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">IPython控制台(图片由作者提供)</p></figure><p id="d4ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看出，最相似的显然是电影本身。算法定义“<strong class="lb iu">无事生非</strong>”为下一部最相似的电影！(将它添加到我的“观察列表”😄)</p><p id="0deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文到此为止！本文提供了一种实践方法，通过在任何python IDE上编写代码，从头开始构建推荐系统。</p><p id="0551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，一旦建立了算法，是时候拿些爆米花，看你的系统推荐的电影了！！😁</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/02146440d03a3595bcd405201f02518f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sXmmyFliqX2DHJHeAp6aA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">爆米花时间！(照片由<a class="ae ky" href="https://unsplash.com/s/photos/cast-movie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@georgiavagim?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔治亚·瓦吉姆</a>拍摄)</p></figure></div></div>    
</body>
</html>