<html>
<head>
<title>Next level data visualization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一级数据可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/next-level-data-visualization-f00cb31f466e?source=collection_archive---------28-----------------------#2020-10-23">https://towardsdatascience.com/next-level-data-visualization-f00cb31f466e?source=collection_archive---------28-----------------------#2020-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0751" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">完整的Plotly手册</h2><div class=""/><div class=""><h2 id="4457" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">制作能激发灵感的图表/第1部分:制作定制图表</h2></div><p id="7044" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在古印度文献中，对哲学概念的解释通常以否定这个概念是关于什么而不是关于什么开始。利用一个反复出现的短语<a class="ae lo" href="https://en.wikipedia.org/wiki/Neti_neti" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> neti neti </em> </a>(意思是<em class="ln">既不是这个也不是那个</em>)，这个想法是，告诉什么东西不是，至少和解释那个概念/想法的实际意义一样重要。跟随这些古代哲学家的脚步，让我首先列举出本文不涉及的内容:</p><ul class=""><li id="7fbd" class="lp lq it kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">这篇文章不是关于如何在plotly中快速制作图表，通常只有一行代码，就像plotly express一样。如果这是你感兴趣的，请跟随威尔·科尔森的这篇<a class="ae lo" rel="noopener" target="_blank" href="/the-next-level-of-data-visualization-in-python-dd6e99039d5e">惊人的媒体文章</a>。</li><li id="13b7" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">本文也不是要列出所有可用于数据可视化的不同图表类型。如果这是你正在寻找的，看看这篇<a class="ae lo" href="https://visme.co/blog/types-of-graphs/" rel="noopener ugc nofollow" target="_blank">非常翔实的文章</a>萨曼莎·李乐。事实上，本文只讨论了两种不同的图表类型:折线图和散点图。</li></ul></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="f1b4" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">介绍</h1><p id="8422" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">任何数据分析项目都有两个基本目标。首先，以易于理解的形式整理数据，揭示隐藏的模式，并确定关键趋势。第二，也许更重要的是，通过深思熟虑的数据可视化将这些发现有效地传达给读者。这是一篇介绍性文章，讲述了如何开始考虑定制可视化，以方便地将关键数据特性传播给查看者。我们通过超越使plotly在数据分析师中如此受欢迎的单线图，并专注于个性化的图表布局和美学<strong class="kt jd">来实现这一目标。</strong></p><p id="4255" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">本文中使用的所有代码都可以在<a class="ae lo" href="https://github.com/Aseem139/Plotly/blob/main/PLOTLY_Medium_Part_01.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。这里展示的所有图表都是交互式的，并且是使用<a class="ae lo" href="https://www.jovian.ai" rel="noopener ugc nofollow" target="_blank"> jovian </a>渲染的，这是一个用于共享和管理jupyter笔记本的不可思议的工具。Usha Rengaraju的这篇文章包含了如何使用这个工具的所有细节。</p><figure class="ni nj nk nl gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nh"><img src="../Images/dd75df43ca2a5d616c9ad42e491a9462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xsjh_uWngjd9AIw-NcDG_g.jpeg"/></div></div><p class="nt nu gj gh gi nv nw bd b be z dk translated"><a class="ae lo" href="https://unsplash.com/s/photos/graph-drawing" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h2 id="fc9d" class="nx ml it bd mm ny nz dn mq oa ob dp mu la oc od mw le oe of my li og oh na iz bi translated">Plotly</h2><p id="5f4a" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">Plotly是数据可视化的自然选择库，因为它易于使用，文档记录良好，并允许定制图表。在接下来的章节中，我们先简要总结一下plotly架构，然后再进行可视化。</p><p id="5642" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然大多数人更喜欢使用高级的<code class="fe oi oj ok ol b">plotly.express</code>模块，但在本文中，我们将关注使用<code class="fe oi oj ok ol b">plotly.graph_objects.Figure</code>类来呈现图表。虽然plotly网站上有大量的<a class="ae lo" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank">文档</a>,但这些材料对于那些不熟悉可视化的人来说可能有点难以接受。因此，我努力提供一个清晰和简洁的语法解释。</p><p id="7374" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将使用的plotly <code class="fe oi oj ok ol b">graph_objects</code>由以下三个高级属性组成，绘制一个图表主要涉及指定这些属性:</p><ul class=""><li id="59d8" class="lp lq it kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated"><code class="fe oi oj ok ol b">data</code>属性包括从超过40种不同类型的轨迹中选择图表类型，如<code class="fe oi oj ok ol b"><a class="ae lo" href="https://plotly.com/python/line-and-scatter/" rel="noopener ugc nofollow" target="_blank">scatter</a></code>、<code class="fe oi oj ok ol b"><a class="ae lo" href="https://plotly.com/python/bar-charts/" rel="noopener ugc nofollow" target="_blank">bar</a></code>、<code class="fe oi oj ok ol b"><a class="ae lo" href="https://plotly.com/python/pie-charts/" rel="noopener ugc nofollow" target="_blank">pie</a></code>、<code class="fe oi oj ok ol b"><a class="ae lo" href="https://plotly.com/python/3d-surface-plots/" rel="noopener ugc nofollow" target="_blank">surface</a></code>、<code class="fe oi oj ok ol b"><a class="ae lo" href="https://plotly.com/python/choropleth-maps/" rel="noopener ugc nofollow" target="_blank">choropleth</a></code>等，并将数据传递给这些函数。</li><li id="cc69" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated"><code class="fe oi oj ok ol b">layout</code>属性控制图表的所有非数据相关方面，如文本字体、背景颜色、轴&amp;标记、边距、标题、图例等。在处理大型数据集时，我们将花费相当多的时间操纵这个属性来进行更改，如添加一个额外的y轴或在一个图形中绘制多个图表。</li><li id="ac9c" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated"><code class="fe oi oj ok ol b">frames</code>用于指定制作动画图表时帧的顺序。本系列的后续文章将广泛利用这一属性。</li></ul><p id="408f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于本文中制作的大多数图表，下面三个是我们将使用的标准库:</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="dd59" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于python的新手，可以看看我之前的一篇关于使用pandas进行数据争论的文章。其中一些工具将用于提取和转换可视化数据。</p><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/data-wrangling-in-pandas-a-downloadable-cheatsheet-84326d255a7b"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd jd gy z fp ow fr fs ox fu fw jc bi translated">使用熊猫进行数据争论的备忘单</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">将原始数据转换成函数形式</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf nr or"/></div></div></a></div><p id="5b99" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">本文的其余部分分为以下几个部分:</p><ol class=""><li id="dd1f" class="lp lq it kt b ku kv kx ky la lr le ls li lt lm pg lv lw lx bi translated"><strong class="kt jd">折线图</strong></li></ol><ul class=""><li id="bda0" class="lp lq it kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">基本折线图</li><li id="06ca" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">定制的折线图</li><li id="7f49" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">何时不使用折线图</li></ul><p id="218a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd"> 2。散点图</strong></p><ul class=""><li id="5ef2" class="lp lq it kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">基本散点图</li><li id="d1ca" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">带有下拉菜单的图表</li><li id="d778" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">散点图矩阵</li></ul></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="8e51" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">折线图</h1><h2 id="5c8a" class="nx ml it bd mm ny nz dn mq oa ob dp mu la oc od mw le oe of my li og oh na iz bi translated">基本折线图</h2><p id="39ca" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">还有什么比折线图更常规的呢？当考虑数据可视化时，这是首先想到的事情之一。我们首先利用gapminder数据集来呈现一个包含许多数据点的折线图。对于那些不熟悉这种数据可视化经典的人，请查看他们的<a class="ae lo" href="https://www.gapminder.org/data/" rel="noopener ugc nofollow" target="_blank">网站</a>和<a class="ae lo" href="https://www.gapminder.org/videos/200-years-that-changed-the-world/" rel="noopener ugc nofollow" target="_blank">这种基于gapminder数据的动画</a>，它在不到5分钟的时间内捕捉了近200年的世界历史。</p><p id="a963" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，我们使用一行<code class="fe oi oj ok ol b">plotly.express</code>代码制作折线图，其中绘图主要涉及指定<code class="fe oi oj ok ol b">x</code>和<code class="fe oi oj ok ol b">y</code>变量，绘图<code class="fe oi oj ok ol b">title</code>和用于<code class="fe oi oj ok ol b">color</code>编码数据的变量。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="3982" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们使用plotly <code class="fe oi oj ok ol b">graph_objects</code>制作同样的图表。</p><p id="93e5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们首先使用<code class="fe oi oj ok ol b">fig1 = go.Figure()</code>初始化一个空的go figure对象。然后，我们通过使用来自<code class="fe oi oj ok ol b">plotly.graph_objects</code>的<code class="fe oi oj ok ol b">go.Scatter</code>类为每个国家添加一个轨迹<code class="fe oi oj ok ol b">fig1.add_trace</code>来绘制一个折线图。这个类可以通过改变<code class="fe oi oj ok ol b">mode</code>参数来制作折线图和散点图，该参数可以采用由<code class="fe oi oj ok ol b">+</code>连接的<code class="fe oi oj ok ol b">"lines"</code>、<code class="fe oi oj ok ol b">"markers"</code>、&amp;、<code class="fe oi oj ok ol b">"text"</code>的任意组合。<code class="fe oi oj ok ol b">add_trace</code>用于向<code class="fe oi oj ok ol b">go.Figure()</code>对象提供<strong class="kt jd">数据参数</strong>。此外，我们还可以为后续图表提供<strong class="kt jd">布局参数</strong>和<strong class="kt jd">框架参数</strong>，我们将在后续文章中介绍。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a554" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是基本的折线图。我们使用只有一行代码的<code class="fe oi oj ok ol b">plotly.express</code>和使用基本上做同样事情的<code class="fe oi oj ok ol b">graph_objects</code>的稍长代码来绘制它。</p><p id="0209" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这张图表看起来不可怕吗？只有我有这种感觉吗？到处看到这样的图表，你不烦吗？</p><p id="b299" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们使用plotly <code class="fe oi oj ok ol b">graph_objects</code>类制作这个图表的原因是，在决定定制图表的<strong class="kt jd">数据</strong>和<strong class="kt jd">布局</strong> ( &amp; <strong class="kt jd">框架</strong>)属性时，它提供了很大的灵活性。</p><h2 id="17d0" class="nx ml it bd mm ny nz dn mq oa ob dp mu la oc od mw le oe of my li og oh na iz bi translated">定制的折线图</h2><p id="e12b" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">就数据可视化美学而言，<strong class="kt jd"> </strong>我一直很欣赏Nathan Yau在<a class="ae lo" href="https://flowingdata.com" rel="noopener ugc nofollow" target="_blank">流动数据</a>中的作品。例如，检查这张<a class="ae lo" href="https://flowingdata.com/2020/06/22/age-generation-populations/" rel="noopener ugc nofollow" target="_blank">图表</a>，然后将其与我们刚刚制作的图表进行比较。从默认设置的世界走向这种定制的图表是我在这篇文章和本系列后续文章中的最终目标。</p><p id="7865" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们开始定制那个可怕的图表。</p><p id="a700" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">配色方案。</strong>所有数据要么是离散的，要么是连续的。离散数据集是指各个数据点相互独立的数据集。在我们刚刚可视化的GDP数据集中，每个国家的GDP独立于其他国家的GDP，因此我们必须使用来自<code class="fe oi oj ok ol b">px.colors.qualitative</code>模块的颜色来可视化它。查看plotly <a class="ae lo" href="https://plotly.com/python/discrete-color/" rel="noopener ugc nofollow" target="_blank">文档</a>以获得该模块中所有可用颜色集的完整列表。这种颜色集中的所有颜色具有不同的<a class="ae lo" href="https://en.wikipedia.org/wiki/Hue" rel="noopener ugc nofollow" target="_blank">色调</a>但是具有相似的<a class="ae lo" href="http://learn.leighcotnoir.com/artspeak/elements-color/hue-value-saturation/" rel="noopener ugc nofollow" target="_blank">饱和度和值</a>。</p><p id="a4cc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">连续数据集的值在一个范围内变化，就像这张失业率图一样。我们使用顺序配色方案来可视化这种数据，其中数据的大小映射到颜色的强度。本系列的后续文章将更多地关注颜色以及如何有效地将颜色用于数据可视化。</p><p id="9f91" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">回到定制我们的折线图。我们使用<code class="fe oi oj ok ol b">cycle</code>工具通过<code class="fe oi oj ok ol b">palette = cycle(px.colors.qualitative.Pastel)</code>交互<code class="fe oi oj ok ol b"><strong class="kt jd">Pastel</strong></code>调色板中的不同颜色。每次我们绘制数据点时，我们使用<code class="fe oi oj ok ol b">marker_color=next(palette).</code>选择其中一种颜色</p><p id="437f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">轴。</strong>让我们开始格式化轴，去掉矩形网格，在长度为10的轴外添加记号(<code class="fe oi oj ok ol b">showgrid=False, ticks="outside", tickson="boundaries", ticklen=10</code>)。我们也去掉了y轴，有了粗黑的x轴(<code class="fe oi oj ok ol b">showline=True, linewidth=2.5, linecolor='black'</code>)。所有这些参数都被传递给<code class="fe oi oj ok ol b">update_xaxes</code>和<code class="fe oi oj ok ol b">update_yaxes.</code></p><p id="516d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">布局。</strong>最后，我们指定几个参数来定义图表的整体布局，即:</p><ul class=""><li id="e6c9" class="lp lq it kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">文本字体样式、大小和颜色。<code class="fe oi oj ok ol b">family="Courier New, monospace", size=18, color="black"</code></li><li id="838e" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">总体图表尺寸。<code class="fe oi oj ok ol b">width=1000, height=500</code></li><li id="dc85" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">图表背景和纸张颜色为白色。<code class="fe oi oj ok ol b">plot_bgcolor='#ffffff', paper_bgcolor = '#ffffff'</code>。看看这个在线工具<a class="ae lo" href="https://htmlcolorcodes.com/color-picker/" rel="noopener ugc nofollow" target="_blank">可以将任何颜色转换成十六进制格式，以便在python中使用。<code class="fe oi oj ok ol b">'#ffffff'</code>是白色的十六进制代码</a></li><li id="ac0e" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">标题及其水平位置。<code class="fe oi oj ok ol b"> title='GDP per capita of European Countries &lt;br&gt; 1952-2007', title_x=0.4.</code></li><li id="1c45" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">x和y轴标签。<code class="fe oi oj ok ol b">xaxis=dict(title='Year'), yaxis=dict(title='GDP per capita in USD').</code></li></ul><p id="3547" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">将所有这些放在一起，这就是我们得到的结果:</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="6821" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这张图表可能与Nathan Yau的一些作品不一样，但它仍然比默认的plotly图表好得多。这个图表代码也代表了我们将在本文中绘制的所有其他图表的基本框架。上图中的几个关键变量可以很容易地改变，以改变剧情的整体美感。这些包括绘图和纸张背景颜色(<code class="fe oi oj ok ol b">plot_bgcolor='#ffffff'</code> &amp; <code class="fe oi oj ok ol b">paper_bgcolor = '#ffffff')</code>)、渲染数据的颜色集(<code class="fe oi oj ok ol b">px.colors.qualitative.Pastel)</code>和轴布局(<code class="fe oi oj ok ol b">update_xaxes</code> &amp; <code class="fe oi oj ok ol b">update_yaxes)</code>)。一定要花时间玩这些。</p><h2 id="c0a0" class="nx ml it bd mm ny nz dn mq oa ob dp mu la oc od mw le oe of my li og oh na iz bi translated">何时不使用折线图</h2><p id="f970" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">现在让我们制作一个类似于上图的图表，但是是针对不同的数据集。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a977" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">随着变量数量的增加，折线图变得难以解释，因为不同变量对应的颜色可能难以区分，或者至少需要一些努力。一种选择是使用堆积面积图。只需将<code class="fe oi oj ok ol b">stackgroup=’one’</code>添加到上面代码中的add_trace函数中，就可以获得相同数据集的堆积面积图。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e513" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了比较不同的数据点，面积图优于线图。在上面的图表中，我们不仅可以看到一个国家排放了多少二氧化碳，还可以比较它与其他国家的表现。中国排放的二氧化碳略多于美国和EU-28国的总和，这是我们可以从堆积面积图中立即得出的结论，而同样的结论很难从简单的线图中得到解释。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="b1d8" class="mk ml it bd mm mn mo mp mq mr ms mt mu ki mv kj mw kl mx km my ko mz kp na nb bi translated">散点图</h1><h2 id="7ce3" class="nx ml it bd mm ny nz dn mq oa ob dp mu la oc od mw le oe of my li og oh na iz bi translated">基本散点图</h2><p id="347f" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">虽然折线图呈现了一个变量随时间变化的过程，但散点图也可用于绘制两个或多个相关或不相关变量之间的变化。我们从绘制一个公开可用的数据集开始，该数据集包含两个指数(<a class="ae lo" href="https://www.ncdc.noaa.gov/cag/global/time-series" rel="noopener ugc nofollow" target="_blank"> GCAG </a>和<a class="ae lo" href="https://data.giss.nasa.gov/gistemp/" rel="noopener ugc nofollow" target="_blank"> GISTEMP </a>)，测量自1880年以来的平均地表温度变化。这次我们使用<code class="fe oi oj ok ol b">plotly.graph_objects</code>的<code class="fe oi oj ok ol b">go.Scatter</code>类和<code class="fe oi oj ok ol b">mode='markers' </code>。代码的整体主干与以前基本相同。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="55ac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们添加另一个变量，在(大致)相同的持续时间内的平均海平面数据。结果是，当两个温度指数从-0.5到1.5变化时，海平面从0到10变化。如果我们在同一条轴上绘制这两条曲线，温度曲线基本上会变平。所以我们用<code class="fe oi oj ok ol b">fig = make_subplots(specs=[[{"secondary_y": True}]])</code>初始化一个有两个不同y轴的图形。现在，当使用<code class="fe oi oj ok ol b">fig.add_trace</code>将每个轨迹添加到该图时，我们必须通过提供一个额外的参数<code class="fe oi oj ok ol b">secondary_y.</code>来指定绘制它的y轴</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="1517" class="nx ml it bd mm ny nz dn mq oa ob dp mu la oc od mw le oe of my li og oh na iz bi translated">带有下拉菜单的图表</h2><p id="d9f4" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">如果我们想在同一张图表上绘制更多的变量呢？我们可以利用下拉菜单来选择单个变量，一次显示一个。为此，我们需要做到以下几点:</p><ol class=""><li id="0acd" class="lp lq it kt b ku kv kx ky la lr le ls li lt lm pg lv lw lx bi translated">向<code class="fe oi oj ok ol b">layout</code>添加一个新的参数，它包括所有要添加的按钮的列表<code class="fe oi oj ok ol b">buttons= list_updatemenus</code>和这个下拉菜单的位置<code class="fe oi oj ok ol b">x=1.2,y=0.8</code>。<code class="fe oi oj ok ol b">updatemenus=list([dict(buttons= list_updatemenus, x=1.2,y=0.8)])</code></li><li id="e1ff" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm pg lv lw lx bi translated">使用<code class="fe oi oj ok ol b">list_updatemenus. </code>指定下拉菜单的选项列表，包括:</li></ol><ul class=""><li id="0391" class="lp lq it kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated"><code class="fe oi oj ok ol b">label</code>:出现在下拉菜单中的变量名称</li><li id="acd1" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated"><code class="fe oi oj ok ol b">method</code>:决定当从下拉菜单中选择特定选项时如何修改图表。它可以是下列之一:<code class="fe oi oj ok ol b">restyle</code>(修改数据)、<code class="fe oi oj ok ol b">relayout</code>(修改布局)、<code class="fe oi oj ok ol b">update</code>(修改两个数据的&amp;布局)和<code class="fe oi oj ok ol b">animate</code>(开始或结束动画)。</li><li id="1c08" class="lp lq it kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated"><code class="fe oi oj ok ol b">args</code>:这包括(1) <code class="fe oi oj ok ol b">visible</code>一个列表，指定哪个数据集将以布尔列表的形式绘制。该列表的大小与添加到该图中的迹线数量相同。<code class="fe oi oj ok ol b">'visible': [True, False]</code>表示将显示两个<code class="fe oi oj ok ol b">go.Scatter</code>图中的第一个。(2) <code class="fe oi oj ok ol b">'title'</code>绘制变量时显示在顶部的标题。</li></ul><p id="9d6c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">将所有这些放在一起，我们得到以下结果:</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="805d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">尝试使用下拉菜单选择单个变量。</p><h2 id="e2e4" class="nx ml it bd mm ny nz dn mq oa ob dp mu la oc od mw le oe of my li og oh na iz bi translated">散布矩阵</h2><p id="47c7" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">使用下拉菜单可能并不总是一个好的选择，因为我们经常希望同时可视化几个变量，以揭示它们之间可能的关系。我们可以使用散点图来做到这一点，散点图是探索性数据分析的一部分。</p><p id="9fd0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将使用的天气数据集记录了几个变量，如最高和最低温度、风向和风速、阳光量和相对湿度。对于每个数据点，我们也知道结果，即是否下雨以及降雨量。现在的目标是可视化所有这些变量是如何影响降雨结果和降雨量的。我们首先给结果变量分配标签(0表示无雨，1表示下雨)。然后，我们使用<code class="fe oi oj ok ol b">go.Splom</code>模块在矩阵上绘制所有这些变量。同样，基本的代码主干保持不变。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="cb9a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意，我们没有指定调色板，而是使用了colorscale来代替<code class="fe oi oj ok ol b">colorscale='temps'</code>。查看<a class="ae lo" href="http://colorscale='temps'" rel="noopener ugc nofollow" target="_blank"> plotly文档</a>获得所有可用的<code class="fe oi oj ok ol b">colorscales.</code>列表<code class="fe oi oj ok ol b">showupperhalf</code>参数设置为true时将产生一个完整的矩阵，其中每个变量都绘制两次，一次在对角线下方，一次在对角线上方。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="om on l"/></div></figure><h1 id="ba9e" class="mk ml it bd mm mn ph mp mq mr pi mt mu ki pj kj mw kl pk km my ko pl kp na nb bi translated">结论</h1><p id="ccd8" class="pw-post-body-paragraph kr ks it kt b ku nc kd kw kx nd kg kz la ne lc ld le nf lg lh li ng lk ll lm im bi translated">在本文中，我们讨论了如何绘制基本的折线图，以及何时用面积图替换它。然后，我们讨论了如何绘制散点图以及何时用散点图替换散点图。在此过程中，我们讨论了如何定制plotly graph_objects来生成符合我们要求的图表。我们通过对基本的代码主干做一些小的改动来实现这种定制。</p><p id="3107" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">本系列的后续文章将重点讨论绘制地图，深入使用颜色和动画来实现高级数据可视化。感谢阅读。请分享您的反馈。</p></div></div>    
</body>
</html>