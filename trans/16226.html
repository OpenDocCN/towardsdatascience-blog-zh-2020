<html>
<head>
<title>How to Build a Semantic Search Engine With Transformers and Faiss</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Transformers和Faiss构建语义搜索引擎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-semantic-search-engine-with-transformers-and-faiss-dcbea307a0e8?source=collection_archive---------2-----------------------#2020-11-09">https://towardsdatascience.com/how-to-build-a-semantic-search-engine-with-transformers-and-faiss-dcbea307a0e8?source=collection_archive---------2-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="21a5" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/54212bf2076d6803aa511e6458e3289c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBBkSPAAW9QULwpFuSOt2w.png"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><h1 id="f07b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">介绍</h1><p id="ee40" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">您是否想过如何使用Transformers创建最先进的句子嵌入，并将其用于下游任务，如语义文本相似性？</p><p id="1246" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">在本教程中，你将学习如何用<a class="ae mm" href="https://github.com/UKPLab/sentence-transformers/" rel="noopener ugc nofollow" target="_blank">句子变形器</a>和<a class="ae mm" href="https://github.com/facebookresearch/faiss" rel="noopener ugc nofollow" target="_blank"> Faiss </a>构建一个基于向量的搜索引擎。如果你想直接进入代码，看看<a class="ae mm" href="https://github.com/kstathou/vector_engine" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>和<a class="ae mm" href="https://colab.research.google.com/drive/11WBCrwNzbNWN7QbMEwzy-8MZROOVQFnZ?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Google Colab notebook </a>。</p><p id="6c33" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">在本教程的第二部分，您将学习如何在一个Streamlit应用程序中服务搜索引擎，使用Docker和AWS Elastic Beanstalk部署它。</p><h1 id="75df" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">为什么要建立一个基于向量的搜索引擎？</h1><p id="1e8f" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">基于关键字的搜索引擎易于使用，并且在大多数情况下都工作得很好。你查询<em class="mn">机器学习</em>论文，它们会返回一堆结果，这些结果包含与查询完全匹配或相近的变体，比如<em class="mn">机器学习</em>。其中一些甚至可能返回包含查询同义词或出现在相似上下文中的单词的结果。其他的，如<a class="ae mm" href="https://www.elastic.co/elasticsearch/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>，以快速和可扩展的方式做所有这些事情，甚至更多。然而，基于关键字的搜索引擎通常会遇到以下问题:</p><ul class=""><li id="d113" class="mo mp iq ll b lm mh lq mi lu mq ly mr mc ms mg mt mu mv mw bi translated">复杂的查询或具有双重含义的单词。</li><li id="6f82" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg mt mu mv mw bi translated">长查询，如论文摘要或博客中的段落。</li><li id="c6ae" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg mt mu mv mw bi translated">不熟悉某个领域的行话的用户或希望进行探索性搜索的用户。</li></ul><p id="489e" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">基于向量的(也称为语义的)搜索引擎通过使用最先进的语言模型找到文本查询的数字表示，在高维向量空间中索引它们，并测量查询向量与索引文档的相似程度来解决这些缺陷。</p><h1 id="a5d6" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">索引、矢量化和排序方法</h1><p id="1ff3" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">在深入本教程之前，我将简要解释基于关键字和基于向量的搜索引擎如何(1) <strong class="ll ja">索引文档</strong>(即以易于检索的形式存储它们)，(2) <strong class="ll ja">对文本数据进行矢量化</strong>和(3) <strong class="ll ja">测量文档与查询的相关性</strong>。这将有助于我们突出两个系统之间的差异，并理解为什么基于向量的搜索引擎可能会为长文本查询提供更有意义的结果。</p><h2 id="d9a3" class="nc km iq bd kn nd ne dn kr nf ng dp kv lu nh ni kz ly nj nk ld mc nl nm lh iw bi translated"><strong class="ak"> 1。基于关键词的搜索引擎</strong></h2><p id="e29f" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">让我们用一个过于简化的版本<a class="ae mm" href="https://www.elastic.co/elasticsearch/service" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>作为例子。Elasticsearch使用一个<a class="ae mm" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html" rel="noopener ugc nofollow" target="_blank">标记器</a>将一个文档分割成标记(即有意义的文本单元)，这些标记被映射成数字序列并用于构建一个<a class="ae mm" href="https://en.wikipedia.org/wiki/Inverted_index" rel="noopener ugc nofollow" target="_blank">倒排索引</a>。</p><figure class="no np nq nr gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi nn"><img src="../Images/befbeb4d6a6ab58b5356823925897c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9Pvr6-h2WiLMEfmy"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated"><em class="ns">倒排索引:倒排索引使我们能够一次查找一个术语并检索包含该术语的所有文档的列表，而不是遍历每个文档来检查它是否包含查询术语。</em> <a class="ae mm" href="https://www.elastic.co/blog/found-indexing-for-beginners-part3/" rel="noopener ugc nofollow" target="_blank"> <em class="ns">图片</em> </a> <em class="ns">作者:</em><a class="ae mm" href="https://www.elastic.co/blog/author/morten-ingebrigtsen" rel="noopener ugc nofollow" target="_blank">Morten Ingebrigtsen</a></p></figure><p id="0124" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">与此同时，Elasticsearch用一个高维的加权向量来表示每个索引文档，其中每个不同的索引项都是一个维度，它们的值(或权重)用<a class="ae mm" href="http://www.tfidf.com/" rel="noopener ugc nofollow" target="_blank"> TF-IDF </a>来计算。</p><p id="c51b" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">为了找到相关的文档并对它们进行排序，Elasticsearch结合了布尔模型(BM)和向量空间模型(VSM)。BM标记哪些文档包含用户的查询，VSM对它们的相关程度进行评分。在搜索期间，使用相同的TF-IDF管道将查询转换为向量，然后文档<code class="fe nt nu nv nw b">d</code>对于查询<code class="fe nt nu nv nw b">q</code>的VSM分数是加权查询向量<code class="fe nt nu nv nw b">V(q)</code>和<code class="fe nt nu nv nw b">V(d)</code>的余弦相似度。</p><blockquote class="nx ny nz"><p id="add5" class="lj lk mn ll b lm mh lo lp lq mi ls lt oa mj lw lx ob mk ma mb oc ml me mf mg ij bi translated">这种度量相似性的方式非常简单，并且不可扩展。Elasticsearch背后的主力是Lucene，它采用了各种技巧，从增强字段到改变向量的标准化方式，来加速搜索并提高搜索质量。</p></blockquote><p id="b97e" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">Elasticsearch在大多数情况下都很有效，然而，我们也想创建一个关注单词上下文的系统。这就把我们带到了基于向量的搜索引擎。</p><h2 id="019b" class="nc km iq bd kn nd ne dn kr nf ng dp kv lu nh ni kz ly nj nk ld mc nl nm lh iw bi translated">2.基于向量的搜索引擎</h2><p id="d0d0" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">我们需要创建考虑单词上下文的文档表示。我们还需要一种高效可靠的方法来检索存储在索引中的相关文档。</p><p id="7df4" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated"><strong class="ll ja">创建密集文档向量</strong></p><p id="70f7" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">近年来，NLP社区在这方面取得了长足的进步，许多深度学习模型都是开源的，并由像<a class="ae mm" href="https://huggingface.co/" rel="noopener ugc nofollow" target="_blank"> Huggingface的变形金刚</a>这样的软件包分发，这些软件包提供了对最先进的预训练模型的访问。使用预训练模型有许多优点:</p><ul class=""><li id="51be" class="mo mp iq ll b lm mh lq mi lu mq ly mr mc ms mg mt mu mv mw bi translated">它们通常产生高质量的嵌入，因为它们是在大量文本数据上训练的。</li><li id="c036" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg mt mu mv mw bi translated">他们不要求你创建一个定制的标记器，因为变形金刚有他们自己的<a class="ae mm" href="https://github.com/huggingface/tokenizers" rel="noopener ugc nofollow" target="_blank">方法</a>。</li><li id="e2fd" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg mt mu mv mw bi translated">根据您的任务微调模型是很简单的。</li></ul><p id="a24d" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">这些模型为文档中的每个<strong class="ll ja">标记</strong>生成一个固定大小的向量。但是，我们如何获得文档级向量呢？这通常是通过平均或汇集单词向量来完成的。然而，这些方法<a class="ae mm" href="https://arxiv.org/abs/1908.10084" rel="noopener ugc nofollow" target="_blank">产生低于平均水平的句子和文档嵌入，通常比平均手套向量</a>更差。</p><p id="cde0" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">为了构建我们的语义搜索引擎，我们将使用<a class="ae mm" href="https://github.com/UKPLab/sentence-transformers" rel="noopener ugc nofollow" target="_blank">句子转换器</a>来微调基于BERT的模型，以生成语义上有意义的长文本序列嵌入。</p><p id="140e" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated"><strong class="ll ja">建立指数和衡量相关性</strong></p><p id="4c91" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">检索相关文档最简单的方法是测量查询向量和数据库中每个文档向量之间的余弦相似性，并返回得分最高的那些向量。不幸的是，这在实践中非常慢。</p><p id="a96a" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">首选的方法是使用<strong class="ll ja"> Faiss </strong>，一个用于高效相似性搜索和密集向量聚类的库。Faiss提供了大量的<a class="ae mm" href="https://github.com/facebookresearch/faiss/wiki/Faiss-indexes" rel="noopener ugc nofollow" target="_blank">指数</a>和<a class="ae mm" href="https://github.com/facebookresearch/faiss/wiki/Faiss-indexes-(composite)" rel="noopener ugc nofollow" target="_blank">综合指数</a>。此外，给定一个GPU，Faiss可以扩展到数十亿个向量！</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><h1 id="128e" class="kl km iq bd kn ko ok kq kr ks ol ku kv kw om ky kz la on lc ld le oo lg lh li bi translated">教程:用句子转换器和Faiss构建基于向量的搜索引擎</h1><p id="4de7" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">在这个实际例子中，我们将使用真实世界的数据。我通过用<a class="ae mm" href="https://github.com/orion-search/orion" rel="noopener ugc nofollow" target="_blank"> Orion </a>查询<a class="ae mm" href="https://www.microsoft.com/en-us/research/project/academic-knowledge/" rel="noopener ugc nofollow" target="_blank">微软学术图</a>，创建了一个包含2010年至2020年间发表的8430篇关于错误信息、虚假信息和假新闻的学术文章的数据集。</p><p id="d022" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">我检索了论文的摘要、标题、引文、出版年份和ID。我做了最少的数据清理工作，比如拿走没有摘要的文件。数据如下所示:</p><figure class="no np nq nr gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi op"><img src="../Images/23afd636c1d8b869daae3834aa3d2d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L0pkja2akcaZ0BnE"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><h2 id="6a99" class="nc km iq bd kn nd ne dn kr nf ng dp kv lu nh ni kz ly nj nk ld mc nl nm lh iw bi translated"><strong class="ak">导入Python包并从S3读取数据</strong></h2><p id="142e" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">让我们导入所需的包并读取数据。该文件是公开的，所以你可以<a class="ae mm" href="https://colab.research.google.com/drive/11WBCrwNzbNWN7QbMEwzy-8MZROOVQFnZ?usp=sharing" rel="noopener ugc nofollow" target="_blank">在Google Colab </a>上运行代码，或者通过<a class="ae mm" href="https://github.com/kstathou/vector_engine" rel="noopener ugc nofollow" target="_blank">访问GitHub repo </a>在本地运行代码！</p><figure class="no np nq nr gt ka"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="487c" class="nc km iq bd kn nd ne dn kr nf ng dp kv lu nh ni kz ly nj nk ld mc nl nm lh iw bi translated"><strong class="ak">使用句子转换器对文档进行矢量化</strong></h2><p id="3dd4" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">接下来，让我们对论文摘要进行编码。<a class="ae mm" href="https://github.com/UKPLab/sentence-transformers" rel="noopener ugc nofollow" target="_blank">句子变形器</a>提供了许多预训练的模型，其中一些可以在这个<a class="ae mm" href="https://docs.google.com/spreadsheets/d/14QplCdTCDwEmTqrn1LH4yrbKvdogK4oQvYO1K1aPR5M/" rel="noopener ugc nofollow" target="_blank">电子表格</a>中找到。这里，我们将使用在语义文本相似性任务中表现出色的<code class="fe nt nu nv nw b">distilbert-base-nli-stsb-mean-tokens</code>模型，它比BERT快得多，因为它要小得多。</p><p id="ac22" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">在这里，我们将:</p><ol class=""><li id="11ac" class="mo mp iq ll b lm mh lq mi lu mq ly mr mc ms mg os mu mv mw bi translated">通过将模型名称作为字符串传递来实例化转换器。</li><li id="2bbb" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg os mu mv mw bi translated">如果可用，切换到GPU。</li><li id="3c9c" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg os mu mv mw bi translated">使用`. encode()'方法对所有论文摘要进行矢量化处理。</li></ol><figure class="no np nq nr gt ka"><div class="bz fp l di"><div class="oq or l"/></div></figure><blockquote class="nx ny nz"><p id="cbf5" class="lj lk mn ll b lm mh lo lp lq mi ls lt oa mj lw lx ob mk ma mb oc ml me mf mg ij bi translated">使用转换器对文档进行矢量化时，建议使用GPU。Google Colab免费提供一个！<strong class="ll ja">如果你想在AWS上运行它，请查看我的指南</strong> <a class="ae mm" href="https://medium.com/@kstathou/how-to-set-up-a-gpu-instance-for-machine-learning-on-aws-b4fb8ba51a7c" rel="noopener"> <strong class="ll ja">如何在AWS上启动用于机器学习的GPU实例</strong> </a> <strong class="ll ja">。</strong></p></blockquote><h2 id="a711" class="nc km iq bd kn nd ne dn kr nf ng dp kv lu nh ni kz ly nj nk ld mc nl nm lh iw bi translated"><strong class="ak">用Faiss索引文档</strong></h2><p id="ff1a" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">Faiss包含在任意大小的向量组中搜索的算法，甚至是不适合RAM的向量组。要了解Faiss的更多信息，你可以阅读他们在arXiv或wiki上的论文。</p><p id="9e6f" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">Faiss是围绕<code class="fe nt nu nv nw b">Index</code>对象构建的，该对象包含可搜索向量，有时还对其进行预处理。它处理固定维度的向量集合<code class="fe nt nu nv nw b">d</code>，通常是几十到100个。</p><blockquote class="nx ny nz"><p id="2c1c" class="lj lk mn ll b lm mh lo lp lq mi ls lt oa mj lw lx ob mk ma mb oc ml me mf mg ij bi translated">Faiss只使用32位浮点矩阵。这意味着我们必须在构建索引之前改变输入的数据类型。</p></blockquote><p id="b820" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">这里，我们将使用执行强力L2距离搜索的<code class="fe nt nu nv nw b">IndexFlatL2</code>索引。它适用于我们的数据集，但是，对于大型数据集，它可能会非常慢，因为它与索引向量的数量成线性关系。Faiss还提供<a class="ae mm" href="https://github.com/facebookresearch/faiss/wiki/Faster-search" rel="noopener ugc nofollow" target="_blank">快速索引</a>！</p><p id="233f" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">为了用抽象向量创建索引，我们将:</p><ol class=""><li id="00f4" class="mo mp iq ll b lm mh lq mi lu mq ly mr mc ms mg os mu mv mw bi translated">将抽象向量的数据类型更改为<code class="fe nt nu nv nw b">float32</code>。</li><li id="d119" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg os mu mv mw bi translated">建立一个索引，并向它传递它将操作的向量的维数。</li><li id="5f35" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg os mu mv mw bi translated">将索引传递给<code class="fe nt nu nv nw b">IndexIDMap</code>，这个对象使我们能够为索引向量提供一个定制的id列表。</li><li id="bc59" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg os mu mv mw bi translated">将抽象向量及其ID映射添加到索引中。在我们的例子中，我们将把向量映射到Microsoft Academic Graph中的论文id。</li></ol><p id="2857" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">为了测试索引是否按预期工作，我们可以用一个索引向量查询它，并检索它最相似的文档以及它们的距离。第一个结果应该是我们的查询！</p><figure class="no np nq nr gt ka"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="no np nq nr gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ot"><img src="../Images/3941a72bfc5dbc6bc3cb800fa8baaa3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GnQRJ8qevRannp_Z"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">因为我们使用索引向量查询Faiss，所以第一个结果必须是查询，并且距离必须等于零！图片由Kostas Stathoulopoulos提供</p></figure><h2 id="e1de" class="nc km iq bd kn nd ne dn kr nf ng dp kv lu nh ni kz ly nj nk ld mc nl nm lh iw bi translated"><strong class="ak">使用用户查询进行搜索</strong></h2><p id="54a0" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">让我们尝试为一个新的、看不见的搜索查询找到相关的学术文章。在这个例子中，我将使用<a class="ae mm" href="https://misinforeview.hks.harvard.edu/article/can-whatsapp-benefit-from-debunked-fact-checked-stories-to-reduce-misinformation/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">的第一段来查询我们的索引。WhatsApp可以从被揭穿的事实核查的故事中受益以减少错误信息吗？</em> </a> <em class="mn"> </em>发表在《HKS误传评论》上的文章。</p><figure class="no np nq nr gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ou"><img src="../Images/9298a02d6a787d752390666a75d54895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*11ACSo4EPfOtkpnx"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><p id="2b89" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">要为新的查询检索学术文章，我们必须:</p><ol class=""><li id="fe1f" class="mo mp iq ll b lm mh lq mi lu mq ly mr mc ms mg os mu mv mw bi translated">用我们用于抽象向量的相同的句子蒸馏模型对查询进行编码。</li><li id="c766" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg os mu mv mw bi translated">将其数据类型更改为<code class="fe nt nu nv nw b">float32</code>。</li><li id="72ea" class="mo mp iq ll b lm mx lq my lu mz ly na mc nb mg os mu mv mw bi translated">使用编码的查询搜索索引。</li></ol><p id="ee86" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">为了方便起见，我将这些步骤包装在了<code class="fe nt nu nv nw b">vector_search()</code>函数中。</p><figure class="no np nq nr gt ka"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="7985" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">这篇文章讨论了错误信息、事实核查、WhatsApp以及巴西和印度的选举。我们希望基于向量的搜索引擎能够返回这些主题的结果。通过检查论文标题，大多数结果看起来与我们的查询非常相关。我们的搜索引擎工作正常！</p><figure class="no np nq nr gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ov"><img src="../Images/ad3e3be5805fef48a3ff47b41f5accfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7x2e08sFfM1T48Ay"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><h1 id="953c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="69c1" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">在本教程中，我们使用句子转换器和Faiss构建了一个基于向量的搜索引擎。我们的索引运行良好，但相当简单。我们可以通过使用领域特定的转换器来提高嵌入的质量，比如SciBERT已经在来自semanticscholar.org语料库的论文上进行了训练。我们还可以在返回结果之前删除重复项，并尝试使用其他索引。</p><p id="215a" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">对于那些使用Elasticsearch的人，Open Distro引入了一个<a class="ae mm" href="https://opendistro.github.io/for-elasticsearch/blog/odfe-updates/2020/04/Building-k-Nearest-Neighbor-(k-NN)-Similarity-Search-Engine-with-Elasticsearch/" rel="noopener ugc nofollow" target="_blank">近似k-NN相似性搜索特性</a>，它也是<a class="ae mm" href="https://aws.amazon.com/about-aws/whats-new/2020/03/build-k-nearest-neighbor-similarity-search-engine-with-amazon-elasticsearch-service/" rel="noopener ugc nofollow" target="_blank"> AWS Elasticsearch服务</a>的一部分。在另一篇博客中，我也会深入探讨这个问题！</p><p id="2510" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">最后，你可以在GitHub 上找到<a class="ae mm" href="https://github.com/kstathou/vector_engine" rel="noopener ugc nofollow" target="_blank">代码，然后用Google Colab </a>试一试<a class="ae mm" href="https://colab.research.google.com/drive/11WBCrwNzbNWN7QbMEwzy-8MZROOVQFnZ?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="c035" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参考</h1><p id="0a43" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg ij bi translated">[1]n . tha kur，n . Reimers，n . daxen Berger，j .和Gurevych，I .，2020年。增强SBERT:用于改进成对句子评分任务的双编码器的数据增强方法。<em class="mn"> arXiv预印本arXiv:2010.08240 </em>。</p><p id="6864" class="pw-post-body-paragraph lj lk iq ll b lm mh lo lp lq mi ls lt lu mj lw lx ly mk ma mb mc ml me mf mg ij bi translated">[2]j .约翰逊，m .杜泽和h .杰古，2019年。用GPU进行亿级相似性搜索。<em class="mn"> IEEE大数据汇刊</em>。</p></div></div>    
</body>
</html>