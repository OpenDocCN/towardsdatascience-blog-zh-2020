<html>
<head>
<title>Is Your Classifier Any Good?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的分类器好吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-your-classifier-any-good-796050a36f9a?source=collection_archive---------64-----------------------#2020-10-13">https://towardsdatascience.com/is-your-classifier-any-good-796050a36f9a?source=collection_archive---------64-----------------------#2020-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="661a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要陷入错误的评价标准</h2></div><p id="6c51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本帖是本书的一部分:<a class="ae le" href="https://www.pyqml.com/page?ref=medium_classifier&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">用Python动手做量子机器学习</strong> </a></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/f7647db09e980c25f84387a993ae42cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6O8eTni9IJBtRe6MPnpcA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者弗兰克·齐克特的图片，改编自电影《难忘的一夜》(1958年，<a class="ae le" href="https://www.pinewoodgroup.com/" rel="noopener ugc nofollow" target="_blank">松林制片厂</a>)</p></figure><p id="d7c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们旨在预测一名乘客是否在泰坦尼克号沉船事故中幸存。但是我们甚至不看数据，而不是训练一个复杂的模型。通过这种方式，我们发现产生看似好的结果实际上毫无价值是多么容易。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="36c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">预测泰坦尼克号上的幸存者是一项分类任务，因为有不同的结果值。具体来说，这是一个二元分类任务，因为正好有两个可能的预测(<code class="fe mc md me mf b">survived</code>或<code class="fe mc md me mf b">died</code>)。</p><p id="24d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开发复杂的机器学习算法之前，让我们实现我们可以想象的最简单的算法。猜测的分类器。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">随机分类器</p></figure><p id="8d13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们导入随机数生成器(第1行)并初始化它(第2行)。</p><p id="c778" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的分类器是一个将乘客数据作为输入并返回<code class="fe mc md me mf b">0</code>或<code class="fe mc md me mf b">1</code>作为输出的函数。与我们的数据相似，<code class="fe mc md me mf b">0</code>表示乘客死亡，<code class="fe mc md me mf b">1</code>表示乘客幸存。</p><p id="a9f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使用分类器，我们编写了一个Python函数，为训练集中的每个项目运行分类器。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">分类赛跑运动员</p></figure><p id="ef43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数将分类器函数作为第一个参数(我们可以稍后替换分类器)，将输入数据(如<code class="fe mc md me mf b">x</code>)作为第二个参数(第1行)。</p><p id="726f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它使用Python的<code class="fe mc md me mf b">map</code>函数来调用带有<code class="fe mc md me mf b">x</code>中每一项的分类器，并返回一个结果数组。</p><p id="de21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们运行它。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">运行分类器</p></figure><p id="5444" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">[0, 1, 0, ... 0, 1, 1]</code></p><p id="fa83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们使用<code class="fe mc md me mf b">train_input</code>运行分类器时，我们会收到一个预测列表。</p><p id="ae4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们的目标是正确预测实际结果，所以我们需要评估预测是否与实际结果匹配。</p><p id="d9be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看我们预测的准确性。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">评估分类器</p></figure><pre class="lg lh li lj gt mi mf mj mk aw ml bi"><span id="d55c" class="mm mn it mf b gy mo mp l mq mr">350 correct predictions out of 711. Accuracy 49 %</span></pre><p id="3b1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们定义另一个函数<code class="fe mc md me mf b">evaluate</code>。它将我们算法的预测和实际结果作为参数(第1行)。</p><p id="773a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">术语<code class="fe mc md me mf b">list(zip(predictions,actual))</code>(第4行)创建了一个包含两个条目的列表。2项列表是预测和相应的实际结果的配对。</p><p id="bbac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从预测与实际结果匹配的列表中选择这些<code class="fe mc md me mf b">item</code>(<code class="fe mc md me mf b">lambda item: item[0] == item[1]</code>)(第3行)。这些都是正确的预测。正确预测的列表长度除以乘客总数就是我们的<code class="fe mc md me mf b">Accuracy</code>。</p><p id="613d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！我们已经在一半的情况下(或多或少)是正确的。当从两个可能的标签中猜出一个时，这并不奇怪。</p><p id="a004" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是也许我们可以做得更好？我是说毫不费力。我们知道死亡的人比幸存的人多。如果我们总是预测一个乘客的死亡会怎么样？</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">总是预测有乘客死亡</p></figure><pre class="lg lh li lj gt mi mf mj mk aw ml bi"><span id="44d5" class="mm mn it mf b gy mo mp l mq mr">437 correct predictions out of 711. Accuracy 61 %</span></pre><p id="23db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们预测的准确率高达61%。不算太坏，是吗？这个值，也就是两个可能的实际值之比，就是患病率。</p><p id="7ec0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们考虑一个不同的任务。假设你是一名医生，你的任务是预测病人是否患有癌症。你的病人中只有1%患有癌症。如果你一直预测没有癌症，你的准确率会达到惊人的99%!但是你会错误地诊断出实际上患有癌症的病人。由于缺乏治疗，他们将会死去。</p><p id="2b92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许仅仅预测的准确性并不能很好地衡量我们算法的性能。</p><p id="bb37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">评估是每个机器学习算法的一个主要部分。乍一看，这似乎是微不足道的。然而，决定正确的措施是非常重要的一步。当你朝着更好的性能优化你的算法时，你将不可避免地在你的评估函数中朝着更好的分数优化。</p><p id="50dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是现在，我们保持简单。评估分类器性能的更好方法是查看混淆矩阵。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ms"><img src="../Images/30ec2b2a4c56ee58f120dd02efe66c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVGOUZ3BvTwEYOcD5_VBUg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者弗兰克·齐克特的图片</p></figure><p id="2d10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的想法是将预测值与实际值进行比较。在二元分类中，有两个可能的实际值:<code class="fe mc md me mf b">true</code>或<code class="fe mc md me mf b">false</code>。并且有两种可能的预测:<code class="fe mc md me mf b">true</code>或者<code class="fe mc md me mf b">false</code>。</p><p id="48c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有四种可能性:</p><ul class=""><li id="8ab4" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated"><strong class="kk iu">真否定</strong> (TN):一名乘客死亡被正确预测</li><li id="a89a" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated"><strong class="kk iu">假阳性</strong> (FN):一名死亡的乘客被错误地预测为存活</li><li id="cd77" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated"><strong class="kk iu">假阴性</strong> (FP):一名幸存的乘客被错误地预测死亡</li><li id="1ca9" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated"><strong class="kk iu">真阳性</strong> (TP):一名幸存乘客被正确预测</li></ul><p id="226a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来看看<code class="fe mc md me mf b">predict death</code>分类器的混淆矩阵。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">预测死亡分类器的混淆矩阵</p></figure><pre class="lg lh li lj gt mi mf mj mk aw ml bi"><span id="4c6f" class="mm mn it mf b gy mo mp l mq mr">array([[437,   0],<br/>       [274,   0]])</span></pre><p id="8436" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nh"> Scikit-Learn </em>提供了我们导入的<code class="fe mc md me mf b">confusion_matrix</code>方法(第1行)。它将实际值作为第一个参数，将预测值作为第二个参数(第3行)。</p><p id="70cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回一个二维数组。在第一行，它显示了真阴性(TN)和假阳性(FP)。在第二行，它显示了假阴性(FN)和真阳性(TP)。</p><p id="0f85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将目前测量的精度定义为:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ni"><img src="../Images/d6d857ccf1757125bbefbaed62b5f605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rf7hcrbfHj6h7QixJdz25g.png"/></div></div></figure><p id="a5c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它不关心是否存在系统误差，例如算法不能正确预测幸存的乘客(真阳性)，只要它在正确预测死亡的乘客(真阴性)方面表现良好。</p><p id="21ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">混淆矩阵为我们提供了分类器性能的更详细的度量。这些是:</p><ul class=""><li id="04f8" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated">精确</li><li id="93ec" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">召回</li><li id="0767" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">特征</li><li id="e06f" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">阴性预测值(NPV)</li></ul><p id="91ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">精度是“正面预测的准确性”。它只关注正面的预测，这些是乘客幸存的预测。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nj"><img src="../Images/3313331367d1dbd762a2ff249c9724b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIf5kQxm7R2nomPSzedOlw.png"/></div></div></figure><p id="7520" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一下代码:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">精确分数</p></figure><pre class="lg lh li lj gt mi mf mj mk aw ml bi"><span id="53b2" class="mm mn it mf b gy mo mp l mq mr">The precision score of the predict_death classifier is 0.0</span></pre><p id="61be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nh"> Scikit-Learn </em>提供了计算<code class="fe mc md me mf b">precision_score</code>的功能。它将实际值列表和预测值列表作为输入。</p><p id="5194" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们没有一个正面的预测，所以我们的精确度是不确定的。<em class="nh"> Scikit-Learn </em>将此解释为<code class="fe mc md me mf b">0.0</code>的分数。</p><p id="529a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">召回是“实际阳性的准确性”。它只关注实际的积极因素。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nk"><img src="../Images/f4c39387483e9a7d9ca3713918a005f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5EFrFi_jfl-4SenclCKQmw.png"/></div></div></figure><p id="898e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，它是:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">回忆分数</p></figure><pre class="lg lh li lj gt mi mf mj mk aw ml bi"><span id="d30a" class="mm mn it mf b gy mo mp l mq mr">The recall score of the predict_death classifier is 0.0</span></pre><p id="00bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一次，即使定义了<code class="fe mc md me mf b">recall</code>(实际阳性的数量大于0)，分数仍然是<code class="fe mc md me mf b">0.0</code>，因为我们的分类器没有正确预测单个存活。当它总是预示着死亡时，这并不奇怪。</p><p id="990c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特异性是“实际底片的准确性”。它只看实际的负面(死亡)。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nl"><img src="../Images/9e9333b2feb68d16799b4aa3ced88d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYyu9y0_PKSeI6Jqg3w-cg.png"/></div></div></figure><p id="f9fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而“负面预测值”(NPV)是“负面预测的准确性”。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nm"><img src="../Images/2628783f5936ae02ffa1d5565e11f31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7qKc1FC7p-VCwKs6prjvA.png"/></div></div></figure><p id="b2bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个功能不是现成的。但是利用我们从混淆矩阵中得到的值，我们可以很容易地计算它们:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">特异性和净现值</p></figure><pre class="lg lh li lj gt mi mf mj mk aw ml bi"><span id="a65a" class="mm mn it mf b gy mo mp l mq mr">The specificity score of the predict_death classifier is 1.00<br/>The npv score of the predict_death classifier is 0.61</span></pre><p id="ca25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe mc md me mf b">specificity</code>将混淆矩阵作为参数(第1行)。它将真阴性(<code class="fe mc md me mf b">matrix[0][0]</code>)除以真阴性和假阳性之和(<code class="fe mc md me mf b">matrix[0][1]</code>)(第2行)。</p><p id="e77f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe mc md me mf b">npv</code>将混淆矩阵作为一个参数(第4行)并将真否定除以真否定和假否定之和(<code class="fe mc md me mf b">matrix[1][0]</code>)。</p><p id="c4d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这四个分数提供了我们的分类器的性能的更详细的视图。</p><p id="92ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们也为我们的随机分类器计算这些分数:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">随机分类器的分数</p></figure><pre class="lg lh li lj gt mi mf mj mk aw ml bi"><span id="a76c" class="mm mn it mf b gy mo mp l mq mr">The precision score of the random classifier is 0.40<br/>The recall score of the random classifier is 0.52<br/>The specificity score of the random classifier is 0.51<br/>The npv score of the random classifier is 0.63</span></pre><p id="5549" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然<code class="fe mc md me mf b">predict death</code>分类器完全没有精确度和召回率，但它具有完美的特异性，并达到与我们测试数据集中的阴性百分比(患病率)相匹配的NPV分数。</p><p id="34cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随机分类器产生更平衡的分数。每次运行分类器，你都会得到一点点不同的分数。但是这些值似乎停留在一定的范围内。虽然这个分类器的精度通常低于<code class="fe mc md me mf b">0.4</code>，但是npv高于<code class="fe mc md me mf b">0.6</code>。</p><p id="fffa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">混淆矩阵和相关度量给你很多信息。但是有时候，你需要一个更简洁的度量标准。事实上，机器学习算法中的评估函数必须返回它可以优化的单个度量。</p><p id="f509" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个单一的测量应该揭露一个没有真正增加任何价值的分类器。</p><p id="aa01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本帖是本书的一部分:<a class="ae le" href="https://www.pyqml.com/page?ref=medium_classifier&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">用Python动手做量子机器学习</strong> </a> <strong class="kk iu">。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/c619638a1887080f768a33a2b3701b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*i9dsCzZEz502JFqL.png"/></div></figure><p id="0e1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里免费获得前三章<a class="ae le" href="https://www.pyqml.com/page?ref=medium_classifier&amp;dest=/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>