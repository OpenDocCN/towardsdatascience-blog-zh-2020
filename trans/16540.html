<html>
<head>
<title>How to Choose the Best Keras Pre-Trained Model for Image Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何选择最佳的Keras预训练模型进行图像分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-choose-the-best-keras-pre-trained-model-for-image-classification-b850ca4428d4?source=collection_archive---------6-----------------------#2020-11-15">https://towardsdatascience.com/how-to-choose-the-best-keras-pre-trained-model-for-image-classification-b850ca4428d4?source=collection_archive---------6-----------------------#2020-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1924" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有疑问的时候，用数据来决定！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/311bf5b64df264aceda52e111cfd128c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vOlNnNUgSsY1T_Zn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择过多。由<a class="ae ky" href="https://unsplash.com/@mmw189?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">m . W .</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="7860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决定在你的深度学习任务中使用哪个预先训练的模型，与经典的两难问题处于相同的水平，比如在网飞上看什么电影，在超市买什么麦片(附注:买糖最少、纤维含量最高的那种)。这篇文章将使用Python中的数据驱动方法来为<code class="fe lv lw lx ly b">cats_vs_dogs </code>数据集找出最佳的Keras预训练模型。这篇文章和提供的代码也将帮助您轻松地为您的问题数据集选择最佳的预训练模型。</p><h1 id="f816" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">目录</h1><ol class=""><li id="d09e" class="mr ms it lb b lc mt lf mu li mv lm mw lq mx lu my mz na nb bi translated"><a class="ae ky" href="#0014" rel="noopener ugc nofollow">背景</a></li><li id="c355" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="#f6be" rel="noopener ugc nofollow">选择型号的标准</a></li><li id="0e82" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="#e84f" rel="noopener ugc nofollow">代码</a></li><li id="cd6d" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="#2a6b" rel="noopener ugc nofollow">资源</a></li></ol><h1 id="0014" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">背景</h1><p id="b533" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">迁移学习是机器学习中的一种技术，我们可以采用在一项任务中开发的模型，并将其作为其他类似但不同的任务的起点。迁移学习在深度学习中非常流行，因为知识从一个“父”模型“迁移”到“子”模型意味着“子”模型可以用比“父”模型小得多的数据集训练到高精度。你可以在这个优秀的<a class="ae ky" rel="noopener" target="_blank" href="/a-comprehensive-hands-on-guide-to-transfer-learning-with-real-world-applications-in-deep-learning-212bf3b2f27a">【中帖】</a>找到更多关于迁移学习的细节</p><p id="9a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像TensorFlow和Pytorch这样的高级深度学习框架通过在包本身中包含几个预先训练的模型，使得利用迁移学习的力量变得非常容易。例如，<a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras" rel="noopener ugc nofollow" target="_blank">【tensor flow Keras API】</a>包含了18个在<a class="ae ky" href="https://en.wikipedia.org/wiki/ImageNet" rel="noopener ugc nofollow" target="_blank"> ["ImageNet"] </a>数据集上预训练的高度先进的模型架构。你可以把“ImageNet”想象成图像分类数据集的SAT。</p><p id="bd12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的大多数图像分类深度学习任务将从下载这18个预训练模型中的一个开始，稍微修改模型以适应手头的任务，并且仅训练自定义修改，同时冻结预训练模型中的层。由于“ImageNet”收集了许多真实世界的图像，因此这种方法在真实世界的图像分类任务中给出了非常高的准确度。</p><p id="7ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，选择使用18个预训练模型中的哪一个并不总是一门精确的科学。许多开发人员坚持他们熟悉的模型，并在过去给了他们很好的结果。作为一名数据科学家，我想知道是否有更好的、数据驱动的方法来选择预先训练的模型，不受个人偏见的影响。确实有！这篇文章的其余部分讨论了我的过程，代码可以直接用于你的项目。</p><h1 id="f6be" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">选择模型的标准</h1><p id="e8e5" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一般来说，在行业中执行任何机器学习任务时，都有两个相互竞争的标准:</p><ol class=""><li id="576a" class="mr ms it lb b lc ld lf lg li nk lm nl lq nm lu my mz na nb bi translated">模型的准确性:越高越好</li><li id="8f8c" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">模型训练和预测的速度:越快越好</li></ol><p id="df11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个标准非常简单。我们想要在验证数据上给我们最高准确度的模型，因为它可以做出有用的预测。我们还希望模型尽可能快地训练和预测，因为在生产中，我们可能需要每秒提供数百或数千个预测。</p><p id="737e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">够简单吗？嗯，就像生活中的所有事情一样，我们不能鱼与熊掌兼得(因此有了这个标题图像)！一般来说，为了获得更高的精度，我们需要使用“更深”或更大的模型。但是更大的模型有更多的参数，这使得它执行起来更慢。我们可以从下图<a class="ae ky" href="https://arxiv.org/pdf/1810.00736.pdf" rel="noopener ugc nofollow" target="_blank">【参考】</a>中看到模型的精度和规模/运算次数之间的权衡。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/799982ae238e157e3d1a929eeff91359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*Bfm3lhmIfQzyJAmFsL_71Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像分类精度与模型大小/运算次数的关系。一般来说，较大的模型往往具有较高的精度，但需要更多的运算，这使得它们速度较慢。<a class="ae ky" href="https://arxiv.org/pdf/1810.00736.pdf" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="4f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这是我们需要取得的平衡。对于行业中的大多数深度学习部署，我们选择最小的模型，为我们提供足够好的准确性。因此，我们需要在许多可用的模型中进行试验，以选择满足这些标准的模型。</p><p id="6517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果您只关心实现最高的精度，而不考虑对速度的影响，那么您的方法可以是使用集成技术来组合所有这些模型！事实上，在学术界和ML竞赛中，ensembling非常受欢迎。</p><h1 id="e84f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">密码</h1><p id="0a46" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我的方法很简单，如下图所示。我们将使用Python找到Keras中所有预训练的模型，然后逐个循环。在本文中，我们将在tensor flow<a class="ae ky" href="https://www.tensorflow.org/datasets/catalog/cats_vs_dogs" rel="noopener ugc nofollow" target="_blank">【cats _ vs _ dogs】</a>数据集上训练模型。您可以用任何其他数据集替换它，包括您自己的自定义数据集。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/465591d145c01692055f6e5c3a7b2c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*7YrE_M-BtyWkrVFIOdmdfA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择最佳预训练Keras模型的步骤</p></figure><h2 id="9e53" class="np ma it bd mb nq nr dn mf ns nt dp mj li nu nv ml lm nw nx mn lq ny nz mp oa bi translated">第一步</h2><p id="996f" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">第一步是导入必要的包。如果您缺少这些包，您可以使用<code class="fe lv lw lx ly b">pip install &lt;package-name&gt;</code>来安装它们。我们还会为后续的模型训练设置一个<code class="fe lv lw lx ly b">batch_size</code>。由于我使用的是低成本的GPU，我将只使用32的小批量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="e2e0" class="np ma it bd mb nq nr dn mf ns nt dp mj li nu nv ml lm nw nx mn lq ny nz mp oa bi translated">第二步</h2><p id="63c8" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">通过列出<code class="fe lv lw lx ly b">tf.keras.applications</code>中的所有函数，自动从Keras获得所有可用预训练模型的列表。由于每个模型都是通过从<code class="fe lv lw lx ly b">tf.keras.applications</code>调用一个函数来实例化的，当我们使用<code class="fe lv lw lx ly b">inspect.isfunction</code>列出这个模块中的所有函数时，我们得到了所有模型的列表。截至本文撰写时，在<a class="ae ky" href="https://www.tensorflow.org/versions/r2.2/api_docs/python/tf/keras/applications" rel="noopener ugc nofollow" target="_blank">【tensor flow 2.2】</a>中，我们可以使用的模型共有18个。</p><p id="b82d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过手动将元素添加到<code class="fe lv lw lx ly b">model_dictionary</code>以及遵循语法<code class="fe lv lw lx ly b">model_dictionary["new_model_name"] = new_model_function()</code>来将任何其他定制预训练模型添加到实验中，其中<code class="fe lv lw lx ly b">new_model_function()</code>应该返回定制预训练模型，而不返回最终输出<code class="fe lv lw lx ly b">Dense</code>层。如果您不想更改下面的任何其他代码，模型的输入形状应该是(224，224，3)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="cbce" class="np ma it bd mb nq nr dn mf ns nt dp mj li nu nv ml lm nw nx mn lq ny nz mp oa bi translated">第三步</h2><p id="a821" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">下载一些图片来运行实验。当您为您的用例运行实验时，您应该修改这个步骤来加载您的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d07b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="2382" class="np ma it ly b gy oh oi l oj ok">Num train images: 16283         <br/>Num validation images: 6979         <br/>Num classes: 2         <br/>Num iterations per epoch: 508</span></pre><h2 id="2269" class="np ma it bd mb nq nr dn mf ns nt dp mj li nu nv ml lm nw nx mn lq ny nz mp oa bi translated">第四步</h2><p id="fc8d" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">预处理输入图像。一些预先训练的模型要求图像的大小为(224，224，3)，而一些要求为(331，331，3)。我们使用这个步骤来准备两种尺寸的图像，并通过将每个像素除以255来归一化它们。我们还<em class="ol">一次性编码</em>标签，这样我们就可以在训练中使用<code class="fe lv lw lx ly b">categorical_crossentropy </code> loss。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="ebe3" class="np ma it bd mb nq nr dn mf ns nt dp mj li nu nv ml lm nw nx mn lq ny nz mp oa bi translated">第五步</h2><p id="95fc" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">通过下载没有输出层的预训练模型来循环每个模型，并冻结权重。然后，我们构建一个空的<code class="fe lv lw lx ly b">Sequential</code>模型，并首先向其中添加预训练的模型。然后，我们添加一个带有<code class="fe lv lw lx ly b">softmax</code>激活的单一输出密集层，并使用<code class="fe lv lw lx ly b">categorical_crossentropy</code>损失对其进行编译。最后，我们通过为<code class="fe lv lw lx ly b">3 epochs</code>调用<code class="fe lv lw lx ly b">model.fit</code>来训练模型。我们将参数的数量(模型的大小)和每个模型的最终精度记录到一个字典中，以可视化结果。如果在模型下载<code class="fe lv lw lx ly b">AttributeError: 'str' object has no attribute 'decode'</code>过程中出现以下错误，请安装一个较低版本的<code class="fe lv lw lx ly b">h5py</code><a class="ae ky" href="https://github.com/tensorflow/tensorflow/issues/44467" rel="noopener ugc nofollow" target="_blank">【source】</a></p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="1911" class="np ma it ly b gy oh oi l oj ok">pip uninstall h5py<br/>pip install h5py&lt;'3.0.0'</span></pre><p id="8dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在谷歌云平台上的一个带有一个<code class="fe lv lw lx ly b">NVIDIA Tesla T4</code> GPU的<code class="fe lv lw lx ly b">n1-standard-4</code> (4个vCPUs，15 GB RAM)上，整个过程需要大约3个小时。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="278a" class="np ma it bd mb nq nr dn mf ns nt dp mj li nu nv ml lm nw nx mn lq ny nz mp oa bi translated">第六步</h2><p id="e2e8" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们通过将其转换为数据帧并按<code class="fe lv lw lx ly b">num_model_params</code>的升序排序来可视化结果，因为我们的目标是选择具有足够精度的最小模型。在这个例子中，<code class="fe lv lw lx ly b">MobileNet</code>模型已经提供了<code class="fe lv lw lx ly b">97%</code>精度；因此，我们可以直接使用它。<code class="fe lv lw lx ly b">MobileNetV2</code>和<code class="fe lv lw lx ly b">NASNetMobile</code>是我们可以考虑进行微调实验的另外两个模型。如果我们选择的模型的准确性仍然不足以完成我们的任务，我们可以通过进一步微调这些选择的模型、添加数据扩充等来进行试验。我们将在一个已经被证明接近我们要求的模型上应用典型的深度学习模型改进实验。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="535b" class="np ma it ly b gy oh oi l oj ok">| model_name        | num_model_params | validation_accuracy |<br/>|-------------------|------------------|---------------------|<br/>| MobileNetV2       | 2257984          | 0.9475569725036621  |<br/>| MobileNet         | 3228864          | 0.9773606657981873  |<br/>| NASNetMobile      | 4269716          | 0.9753546118736267  |<br/>| DenseNet121       | 7037504          | 0.9273535013198853  |<br/>| DenseNet169       | 12642880         | 0.95572429895401    |<br/>| VGG16             | 14714688         | 0.9107322096824646  |<br/>| DenseNet201       | 18321984         | 0.9419687390327454  |<br/>| VGG19             | 20024384         | 0.8948273658752441  |<br/>| Xception          | 20861480         | 0.9550078511238098  |<br/>| InceptionV3       | 21802784         | 0.9859578609466553  |<br/>| ResNet50V2        | 23564800         | 0.9802263975143433  |<br/>| ResNet50          | 23587712         | 0.49620288610458374 |<br/>| ResNet101V2       | 42626560         | 0.9878206253051758  |<br/>| ResNet101         | 42658176         | 0.49620288610458374 |<br/>| InceptionResNetV2 | 54336736         | 0.9885370135307312  |<br/>| ResNet152V2       | 58331648         | 0.9840951561927795  |<br/>| ResNet152         | 58370944         | 0.49620288610458374 |<br/>| NASNetLarge       | 84916818         | 0.9795099496841431  |</span></pre><p id="3a62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标绘结果</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/f5a9c13156fa0cee954f920c0603f923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*B1AJQ0jkV84Ut9BGG3YVTg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模型精度与参数数量的结果</p></figure><h1 id="33a2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="4a32" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">总之，我介绍了一种数据驱动的方法，从Tensorflow Keras API中的一组预训练模型中选择最合适的模型。在大多数工业应用中，我们会选择参数数量最少的模型，为进一步研究提供足够好的精度。我们可以通过在[ <a class="ae ky" href="#e2e0" rel="noopener ugc nofollow">步骤2 </a> ]中手动将项目添加到<code class="fe lv lw lx ly b">model_dictionary</code>中，轻松扩展这种方法，以包括Keras未提供的其他型号。</p><p id="1bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，广泛的实验和数据驱动的决策是所有机器学习应用程序成功的关键。我希望这篇文章能激发你思考如何在日常工作中做出更多数据驱动的决策。</p><h1 id="2a6b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">资源</h1><ul class=""><li id="a783" class="mr ms it lb b lc mt lf mu li mv lm mw lq mx lu on mz na nb bi translated">你可以在<a class="ae ky" href="https://github.com/stephenleo/keras-model-selection/blob/main/keras_model_selection.ipynb" rel="noopener ugc nofollow" target="_blank">【GitHub】</a>找到这篇文章中用到的所有代码。</li><li id="979a" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu on mz na nb bi translated">您也可以使用Google Colab直接运行代码，无需任何设置。只需记得进入编辑→笔记本设置，选择一个<code class="fe lv lw lx ly b">GPU</code>硬件加速器:<a class="ae ky" href="https://colab.research.google.com/github/stephenleo/keras-model-selection/blob/main/keras_model_selection.ipynb" rel="noopener ugc nofollow" target="_blank">【在Colab中打开】</a></li></ul><p id="32c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p><p id="e1e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编辑:更新了GitHub gists的代码片段</p></div></div>    
</body>
</html>