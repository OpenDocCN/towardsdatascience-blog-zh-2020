<html>
<head>
<title>Docker Example for BI/Data Science Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BI/数据科学开发的Docker示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/docker-example-for-bi-data-science-development-16e305ab70fa?source=collection_archive---------32-----------------------#2020-11-10">https://towardsdatascience.com/docker-example-for-bi-data-science-development-16e305ab70fa?source=collection_archive---------32-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1ac0" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><p id="8aa0" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我发现Docker对于BI和数据科学开发工作流来说都是一个强大的工具。减轻“它在我的机器上工作”的问题本身就是非凡的，那么为什么不从健壮的业务解决方案的开发角度出发呢？在可伸缩性、工作流效率和最小化软件依赖性/共享库冲突之间找到平衡可能是困难的。然而，我发现Docker在这方面是一个非常强大的解决方案。通过Docker，我已经能够利用开发工具、框架和软件语言，而无需安装在主机上。这种方法提供了可复制的环境，包含了独立的过程。能够从特定版本的Python或Julia Docker映像进行编程和开发，而不用担心我的主机上的实际安装或依赖性兼容性问题，这是一种令人难以置信的体验(更不用说不再需要整合虚拟Python环境的管理)。</p><p id="1d68" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">尽管本文给出了一个简单的例子，展示了将Docker集成到BI/数据科学开发工作流中的强大功能，但它确实需要一些Python和Docker的基础知识背景。</p><h1 id="c39d" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">教程概述</h1><p id="6dd5" class="pw-post-body-paragraph jw jx iq jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ij bi translated">该示例将采用一种简单的交互式动态ML web应用程序的方法，该应用程序从外部数据库服务器MS SQL Server中提取参数依赖性。要预测的函数是笛卡尔坐标中的对数螺线函数(一个向量值函数)，web app本身会依赖于Dash框架(Plotly)。使用Docker Compose，Docker可以轻松管理多容器环境。一个容器将专用于运行模拟最终生产环境的开发MS SQL Server。另一个容器将用于主应用程序(Docker Compose将处理这两个容器之间的内部网络)。每个容器将引用一个环境文件，用于提供动态和可再现的环境，同时减少在任意文件中存储代码中的静态值。这些值将通过引用YAML文件的Python脚本进行连接，以确定环境变量值。这种方法可能看起来像是增加了多余的逻辑层，但是我发现这种模板方法最终会使事情变得简单得多(特别是当项目变得复杂时)。</p><p id="919d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为了管理代码结构，额外的离散Python文件将用于运行应用程序、为应用程序提供服务、保持预测功能、在应用程序的GUI结构中提供帮助，以及自动化开发数据库的播种/搭建。为了帮助搭建和播种开发数据库，我将提供一种方法，使用Python脚本作为该过程的启动程序，该程序调用bash文件在两个SQL文件的帮助下处理搭建方面。</p><p id="5a79" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">示例项目要在给定的机器上运行，只需安装Docker和Docker-Compose。要运行实际的web应用程序，请在运行Docker Compose UP命令之前取消Docker文件底部的注释。另一种方法是从正在运行的web应用程序容器中执行“python<em class="lx">dash _ app _ server . py</em>”(名称应该是<em class="lx">interactive-vector-valued-function-app _ dash-app _ x</em>)。如果web应用程序正在运行，它应该可以从端口8080访问(如果需要，可以在Docker Compose文件中更改)。点击此处获取项目代码的副本:</p><div class="ly lz gp gr ma mb"><a href="https://github.com/bmurders2/Interactive-Vector-Valued-Function-App" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd ja gy z fp mg fr fs mh fu fw iz bi translated">bmurders 2/交互式向量值函数应用程序</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">通过Dash实现的交互式ML/AI web应用程序。这个应用程序允许最终用户修改向量的参数…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">github.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp mq mb"/></div></div></a></div><p id="cb5f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">DEV、PRD和ENV缩写将分别用于表示开发、生产和环境的代码中。下面是项目结构的快照:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/f11c7524516a90673a91916fba7b4a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*zTMyUTmRrSU1U5gonz22ZQ.png"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">项目文件夹概述-按作者分类的图像</p></figure><h1 id="6ab0" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">主应用程序的Dockerfile</h1><p id="c882" class="pw-post-body-paragraph jw jx iq jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ij bi translated">主应用程序将从docker文件中派生出来，用于创建一个可重现的受控应用程序环境(针对开发和PRD)。从Python image 3.8.6-slim开始，项目代码与工作目录的定义一起被复制(或者，这里可以使用Git引用，而不是引用项目代码的本地目录)。然后，运行命令用于应用程序预期运行所必需的依赖性和环境配置(例如，包括来自外壳的<em class="lx"> sqlcmd </em> <strong class="jy ja"> </strong>)。我注释掉了Dockerfile的底部部分，该部分在作为非根用户启动容器时自动运行应用程序，以提升开发和测试环境。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">Web应用程序的Dockerfile</p></figure><h1 id="77b5" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Docker撰写设置</h1><p id="090a" class="pw-post-body-paragraph jw jx iq jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ij bi translated">除了建立容器编排配置之外，当docker-compose UP命令被执行时。将传入包含各自容器使用的环境变量的env文件。例如，<em class="lx"> dev_mssql.env </em>中的变量‘MSQL _ PID’将决定要启动的mssql服务器的类型(在本例中是Developer)。如果在正式流程的生产环境中，请确保您的组织中存在有效的许可证，除非附加到现有的生产SQL Server(无论是哪种情况，此示例都会复制生产环境以确保有效的调试和代码开发)。下图显示了的映射。env文件从<em class="lx"> docker-compose.yml </em>文件中复制到它们对应的Docker容器中。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/c9f747c1931c200101b90cbde3bafe7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0tjhlwO-3dzLSPBRtStMg.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">的可视化映射。env文件及其相应的服务</p></figure><h1 id="03e7" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Web应用程序文件</h1><p id="e0af" class="pw-post-body-paragraph jw jx iq jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ij bi translated">有一个主web应用程序文件(<em class="lx"> dash_app.py </em>)用于web应用程序的主要功能，包括dash和定制包的包导入。在高层次上，应用程序布局是在导入和所需对象的初始实例化之后定义的，这为应用程序布局提供了总体布局和结构。以下是预期的应用程序视觉呈现的概述(简单明了，带有一个图表和一个参数列表，作为其下方预测函数的输入)。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nj"><img src="../Images/fbb916db5212daca53bc3602f61319dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBw3OpmAPStw2Nr2677nzw.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">Web应用程序的可视化-作者图片</p></figure><p id="f884" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">布局所需的一切都可以在这里内联定义，除了对自定义导入的调用，即预测函数的选项卡式参数列表。水平选项卡列表将是一个数组，因此自定义导入<em class="lx"> gui_setup.py </em>将需要一个匹配这个输入要求的输出。这是为了管理潜在的动态变化，而不需要对主应用程序Python文件进行大量维护。对于每个参数选项卡，滑块用于确定相应的参数值。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">Web应用程序布局</p></figure><p id="6ec7" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">由于应用程序用户界面的简单性，Dash框架只需要两个应用程序回调:一个用于从GUI角度更新参数滑块，另一个用于传递预测函数所需的输入值，并返回plot对象。更新GUI滑块很简单，如下图所示。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">滑块参数值的更新功能</p></figure><p id="ab57" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">用于调用预测函数并返回绘图的第二个回调函数比第一个回调函数稍微复杂一些，因此将预测函数本身包装在一个单独的文件中有助于压缩这里的代码。在将输入参数传递给预测函数之后，预期的输出是一个Pandas数据帧，可以通过JSON格式使用Plotly进行绘制。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">实时更新绘图的功能</p></figure><p id="745e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">下面的代码是用来服务应用程序的。在这种情况下，将使用女服务员(Gunicorn是服务基于烧瓶的应用程序的另一个可靠选择)。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">为Web应用提供服务的代码</p></figure><h1 id="3e54" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">助手类和文件</h1><p id="dd83" class="pw-post-body-paragraph jw jx iq jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ij bi translated">在尝试播种和搭建开发数据库之前，了解相应数据库的生产环境结构是很重要的。该项目使用一个助手GUI文件<em class="lx"> gui_setup.py </em>，用于辅助主要的应用程序功能和呈现，它依赖于<em class="lx"> app_config.py </em>文件。然后，<em class="lx"> app_config.py </em>文件依赖于<em class="lx"> config.yml </em> <strong class="jy ja"> </strong>文件来确定检索所需值的环境变量名。为了本文的简洁，没有明确显示所有的项目代码。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nk"><img src="../Images/658722e6ca75d2980a93d1758a102b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sl8xv5jRlfQ8YnePF3Wu-w.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">提供给项目代码的应用程序配置参数概述—图片由作者提供</p></figure><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">YAML配置文件</p></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nl"><img src="../Images/c375eb0bd13b96baf82ce822af585021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NWEqZyM1ULSmB0EUGD8XQ.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated"><strong class="bd nm"> config.yml </strong>和<strong class="bd nm"> app_config.py </strong>的可视化关系—图片由作者提供</p></figure><h1 id="81b2" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设定开发数据库服务器的种子</h1><p id="6043" class="pw-post-body-paragraph jw jx iq jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ij bi translated">为了设置开发数据库服务器，我们将创建和播种预期的生产数据库、模式和表。这个过程的开始将包含在命令部分下的<em class="lx"> docker-compose.yml </em>文件中(这在容器启动时执行)。这里，将检查一个条件，以确保我们应该通过来自<em class="lx"> dev_app_env_vars.env </em>文件的环境变量继续播种开发数据库。如果这个条件成功，继续调用Python生成器文件，<em class="lx">MSSQL _ db _ data _ generator . py</em>(文件位置:<em class="lx"> app/helpers/seed_db </em>)。用于植入/搭建开发数据库的SQL文件将要求在调用时传递变量(这些变量在每个文件中显示为“$( &lt;变量&gt;)”。sql文件)。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nn"><img src="../Images/79dc034ae2b36e3fb51e1cf275250d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBzMKl3-xPbgQYKmrhMb0A.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">Docker-Compose文件的下半部分突出显示了对<strong class="bd nm">MSSQL _ db _ data _ generator . py</strong>的调用—图片由作者提供</p></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi no"><img src="../Images/5c8994e36bdf9e1ca37f450b8207b306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sABHe9DdqZgzVU9FV_16vg.png"/></div></div><p class="my mz gj gh gi na nb bd b be z dk translated">数据生成概述-按作者分类的图像</p></figure><p id="b717" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">参考同一个文件<em class="lx">MSSQL _ db _ data _ generator . py</em>中的<em class="lx">get _ default _ GUI _ cls _ values()</em>函数，下面是为数据库搭建执行<em class="lx">MSSQL _ db _ seed _ script . sh</em>(第26行)后将生成的数据插入开发数据库的代码。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">搭建并播种开发数据库</p></figure><p id="7b86" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">下面是由<em class="lx">MSSQL _ db _ seed _ script . sh:</em>调用的SQL代码</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">用于创建开发数据库的SQL代码</p></figure><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">用于创建开发数据库表的SQL代码</p></figure><h1 id="2ba4" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">预测函数</h1><p id="6f86" class="pw-post-body-paragraph jw jx iq jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ij bi translated">对于应用程序的预测函数，scikit-learn的两个离散支持向量回归模型将用于分别预测向量值函数曲线的x和y分量(对数螺线)。将预测结果作为Pandas数据框架进行训练和返回所需的代码非常简单。因为要预测的函数不是标量函数，而是向量值函数(由两个分量参数化的直线曲线)，所以务必注意x和y坐标的曲线步长。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nc nd l"/></div><p class="my mz gj gh gi na nb bd b be z dk translated">预测功能码</p></figure><p id="96de" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">web应用程序运行的最终结果将如下所示，带有模型的选项卡式交互式参数滑块:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi np"><img src="../Images/903a35cf7cca921ec463e3965db4e20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyfBByDKnQXmgTGq5wugzw.png"/></div></div></figure><h1 id="f113" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="2276" class="pw-post-body-paragraph jw jx iq jy b jz ls kb kc kd lt kf kg kh lu kj kk kl lv kn ko kp lw kr ks kt ij bi translated">这个工作示例演示了在任何运行Docker的机器上同时工作的自动化方法中编排多个流程是多么容易。尽管该示例的某些部分对于简单的曲线拟合函数来说可能有些过头，例如当交互式仪表板应用程序本身已经生成值时，使用数据库来保存这些值，但是底层方法展示了在应用于业务解决方案时可伸缩性和敏捷开发的功效。</p><p id="bd72" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我想通过一个工作实例来分享利用Docker进行BI/数据科学项目的方法。特别是考虑到Docker可以直接用于开发阶段，因为它减少了安装额外的软件工具或调试由于运行时不兼容问题引起的主机问题的需要。个人认为，Docker是业务创新的有力工具。</p></div></div>    
</body>
</html>