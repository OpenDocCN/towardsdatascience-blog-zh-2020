<html>
<head>
<title>Using Deep Learning to train a Deep Search Chess Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习来训练深度搜索象棋算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-a-chess-engine-with-deep-learning-b9477ff3ee3d?source=collection_archive---------28-----------------------#2020-10-26">https://towardsdatascience.com/creating-a-chess-engine-with-deep-learning-b9477ff3ee3d?source=collection_archive---------28-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="11dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及理解神经网络如何被用来间接解决问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/503fe09dc7c6090b5b72ee346651bded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73SfeqLGzbvmhqnzwt9XCw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哈桑·帕夏在<a class="ae ky" href="https://unsplash.com/s/photos/chess?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数国际象棋引擎中，搜索算法和启发式函数为国际象棋人工智能提供了对最佳走法的主要洞察力。大部分的编程和这背后的大部分“大脑”是启发式函数。</p><p id="9c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我说的启发式函数是什么意思？启发式函数是指对棋盘进行一定的度量，对每个度量赋予一定的权重，最后计算出每个棋手优势的一个数值的函数。国际象棋中的启发式函数通常考虑基本的东西，如棋子结构、中心控制和国王安全，但它也可以包括更复杂的计算，如节奏和采用不同战术的机会。</p><p id="fd94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个经验丰富、编程熟练的棋手能够构造一个好的启发式函数。不幸的是，我不是那种经验丰富的棋手。我已经决定使用神经网络为我创建一个启发式函数。</p><h1 id="e6eb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概念:</h1><p id="8fae" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该程序的概念是使用神经网络来评估电路板，然后安装搜索算法，检查所有未来位置并找到最高值，有点像最小-最大树。</p><h1 id="251d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">程序:</h1><h2 id="7dbf" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">步骤1-访问数据:</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3ba9" class="ms lw it nf b gy nj nk l nl nm">from pandas import read_csv<br/>import numpy as np<br/>import chess<br/>import os</span><span id="ff47" class="ms lw it nf b gy nn nk l nl nm">df = read_csv('C:\\Users\\v_sim\\Desktop\\Files\\Data\\chess.csv')<br/>df = df[df['winner']!='draw']<br/>moves = df['moves'].values[:100]<br/>winner = df['winner'].values<br/>X = []<br/>y = []</span></pre><p id="5fc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该脚本从我的电脑中提取csv文件，并导入程序运行所需的导入内容。Pandas用于csv数据提取，numpy用于数组操作，chess用于现成的棋盘，空列表用于表示网络的X和y值。</p><h2 id="98ae" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">步骤2-数据先决条件:</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="2a5d" class="ms lw it nf b gy nj nk l nl nm">def make_matrix(board): <br/>    pgn = board.epd()<br/>    foo = []  <br/>    pieces = pgn.split(" ", 1)[0]<br/>    rows = pieces.split("/")<br/>    for row in rows:<br/>        foo2 = []  <br/>        for thing in row:<br/>            if thing.isdigit():<br/>                for i in range(0, int(thing)):<br/>                    foo2.append('.')<br/>            else:<br/>                foo2.append(thing)<br/>        foo.append(foo2)<br/>    return foo</span><span id="da5e" class="ms lw it nf b gy nn nk l nl nm">def translate(matrix,chess_dict):<br/>    rows = []<br/>    for row in matrix:<br/>        terms = []<br/>        for term in row:<br/>            terms.append(chess_dict[term])<br/>        rows.append(terms)<br/>    return rows</span><span id="95fb" class="ms lw it nf b gy nn nk l nl nm">chess_dict = {<br/>    'p' : [1,0,0,0,0,0,0,0,0,0,0,0],<br/>    'P' : [0,0,0,0,0,0,1,0,0,0,0,0],<br/>    'n' : [0,1,0,0,0,0,0,0,0,0,0,0],<br/>    'N' : [0,0,0,0,0,0,0,1,0,0,0,0],<br/>    'b' : [0,0,1,0,0,0,0,0,0,0,0,0],<br/>    'B' : [0,0,0,0,0,0,0,0,1,0,0,0],<br/>    'r' : [0,0,0,1,0,0,0,0,0,0,0,0],<br/>    'R' : [0,0,0,0,0,0,0,0,0,1,0,0],<br/>    'q' : [0,0,0,0,1,0,0,0,0,0,0,0],<br/>    'Q' : [0,0,0,0,0,0,0,0,0,0,1,0],<br/>    'k' : [0,0,0,0,0,1,0,0,0,0,0,0],<br/>    'K' : [0,0,0,0,0,0,0,0,0,0,0,1],<br/>    '.' : [0,0,0,0,0,0,0,0,0,0,0,0],<br/>}</span></pre><p id="a427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本能够将类板转换成一个一键编码的棋盘。这是通过首先访问板的epd形式，然后将其分成行，最后使用字典翻译所有的方块来完成的。</p><h2 id="3e33" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">步骤3-创建数据集:</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="de92" class="ms lw it nf b gy nj nk l nl nm">for game in moves:<br/>    index = list(moves).index(game)<br/>    all_moves = game.split()<br/>    total_moves = len(all_moves)<br/>    if winner[index] == 'black':<br/>        game_winner = -1<br/>    else:<br/>        game_winner = 1<br/>    board = chess.Board()<br/>    for i in range(len(all_moves)):<br/>        board.push_san(all_moves[i])<br/>        value = game_winner * (i/total_moves)<br/>        matrix = make_matrix(board.copy())<br/>        rows = translate(matrix,chess_dict)<br/>        X.append([rows])<br/>        y.append(value)<br/>X = np.array(X).reshape(len(X),8,8,12)<br/>y = np.array(y)<br/>X.shape</span></pre><p id="b5d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信不信由你，这是所有奇迹发生的地方。神经网络将直接跳到将死，而不是使用棋子结构和发展来计算玩家的优势。<br/>我加载的数据集包括超过14000盘棋，给出了开局和走法的详细信息。我将为网络合成的数据将通过学习值“在玩家X将死之前还有多少步”来尝试和计算启发值。它通过数以千计的游戏来学习这种模式，直到它牢牢掌握了玩家的优势。</p><h2 id="b48d" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">步骤4-初始化神经网络:</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3439" class="ms lw it nf b gy nj nk l nl nm">from keras import callbacks, optimizers<br/>from keras.layers import (LSTM, BatchNormalization, Dense, Dropout, Flatten,<br/>                          TimeDistributed)<br/>from keras.layers.convolutional import Conv2D, MaxPooling2D<br/>from keras.models import Sequential, load_model, model_from_json<br/>model = Sequential()<br/>model.add(Conv2D(filters=64, kernel_size=1, activation='relu', input_shape=(8,8,12)))<br/>model.add(MaxPooling2D())<br/>model.add(Conv2D(filters=24, kernel_size=1, activation='relu'))<br/>model.add(MaxPooling2D())<br/>model.add(Conv2D(filters=10, kernel_size=1, activation='relu'))<br/>model.add(Flatten())<br/>model.add(BatchNormalization())<br/>model.add(Dense(1,activation = 'tanh'))</span><span id="2a71" class="ms lw it nf b gy nn nk l nl nm">model.predict(X)</span></pre><p id="0099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个基本的卷积神经网络，除了在前向传播回路的末端使用双曲正切。在这种情况下使用双曲正切，因为每个棋盘的属性值可以在-1和1之间，这完全符合双曲正切的范围。</p><h2 id="9f8c" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">步骤5-训练网络:</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="63ff" class="ms lw it nf b gy nj nk l nl nm">from matplotlib import pyplot as plt<br/>model.compile(optimizer='Nadam', loss='mse')<br/>dirx = 'C:\\Users\\v_sim\\Desktop\\Files\\Programs\\ML\\Best Models'<br/>os.chdir(dirx)<br/>h5 = 'chess' + '_best_model' + '.h5'<br/>checkpoint = callbacks.ModelCheckpoint(h5,<br/>                                           monitor='loss',<br/>                                           verbose=0,<br/>                                           save_best_only=True,<br/>                                           save_weights_only=True,<br/>                                           mode='auto',<br/>                                           period=1)<br/>es = callbacks.EarlyStopping(monitor='loss', mode='min', verbose=1, patience=5000/10)<br/>callback = [checkpoint,es]<br/>json = 'chess' + '_best_model' + '.json'<br/>model_json = model.to_json()<br/>with open(json, "w") as json_file:<br/>    json_file.write(model_json)<br/>print('Training Network...')<br/>history = model.fit(X,y,epochs = 1000,verbose = 2,callbacks = callback)<br/>plt.plot(history.history['loss'])</span></pre><p id="e934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是使用顺序keras模型进行机器学习的简单训练设置。</p><h2 id="827b" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">步骤6-观察评估:</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="277f" class="ms lw it nf b gy nj nk l nl nm">randint = np.random.randint(1,len(moves))<br/>randint2 = np.random.randint(1,len(moves[randint].split()))<br/>board = chess.Board()<br/>for i in range(randint2):<br/>    board.push_san(moves[randint].split()[i])<br/>matrix = make_matrix(board.copy())<br/>rows = translate(matrix,chess_dict)<br/>print('Board Evaluation:',model.predict([rows])[0][0])<br/>board</span></pre><p id="d545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步是可选的，只是为了看看你的网络评估是否合理。当使用上述训练参数训练神经网络时，以下是一些结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/2ef945709f67800181d9dda9beb75cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jE66RGpAI1FvQV1HYNDL8w.png"/></div></div></figure><p id="c5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个评价是对的。白棋处于很大的劣势，将他的白皇后移动到c6上的骑士可以拿的方格内。这就给了黑棋很大的物质优势。</p><p id="a325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，范围在-1和1之间，-1代表将死黑色，1代表将死白色</p><p id="22ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个确切值的原因还不清楚，但是神经网络是一个黑盒:它没有明确定义的规则来计算这个值</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/c410082b9dc331e014ef0798c2991601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwTpfL_zb-p4Mh_4YKHO_g.png"/></div></div></figure><p id="9130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一评估表明，机器人理解发展的概念，以及发展如何导致将死。白棋对中锋有绝对的控制，有车沿着e档支援。</p><p id="ddba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">骑士在中心有一个强大的前哨，盯着f7上的兵。在正确的支持下，对f7卒的攻击可以导致对皇后和石头的分叉。此外，没有兵可以攻击黑夜，除非f6上的骑士离开。</p><h2 id="5f23" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">步骤7-深度搜索算法:</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6823" class="ms lw it nf b gy nj nk l nl nm">import chess<br/>flatten = lambda l: [item for sublist in l for item in sublist]<br/>def search_positions(board,depth):<br/>    #legal_moves = str(boards[depth][board].legal_moves)[38:-2].replace(',','').split()<br/>    depth_list = []<br/>    for i in range(depth+1):<br/>        depth_list.append([])<br/>    depth_list[0].append(board)<br/>    for layer in depth_list:<br/>        layer_set = []<br/>        try:<br/>            stet = flatten(layer)<br/>        except:<br/>            stet = layer<br/>        for i in range(len(stet)):<br/>            legal_moves = str(stet[i].legal_moves)[38:-2].replace(',','').split()<br/>            legal_moveset = []<br/>            for move in legal_moves:<br/>                neo_board = stet[i].copy()<br/>                neo_board.push_san(move)<br/>                legal_moveset.append(neo_board)<br/>            layer_set.append(legal_moveset)<br/>        if depth_list.index(layer)+1 == len(depth_list):<br/>            break<br/>        depth_list[depth_list.index(layer)+1] = layer_set<br/>    return depth_list<br/>    <br/>boards = search_positions(chess.Board(),2)</span></pre><p id="55e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会深入研究我的深度搜索算法是如何工作的，它只是使用python-chess库中的合法走法和基本的列表函数来创建一个可能走法的树。</p><p id="f7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我只使用深度2，所以我只需要评估最后一组移动。当考虑每一步棋的最坏情况时，检查哪一步棋有最好的最坏情况，也就是在这种情况下最好的棋。</p><p id="b11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在不使用其他复杂的迭代器工具的情况下评估棋盘，我想到了一个有趣的“try:，except:”结构的应用程序，它将自己索引到下一个列表中，直到找到一个棋盘:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="474b" class="ms lw it nf b gy nj nk l nl nm">def evaluate(lst):<br/>    for i in range(len(lst)):<br/>        try:<br/>            matrix = make_matrix(lst[i])<br/>            rows = translate(matrix,chess_dict)<br/>            lst[i] = model.predict([rows])<br/>        except:<br/>            evaluate(lst[i])<br/>    return lst</span><span id="9159" class="ms lw it nf b gy nn nk l nl nm">evaluation = evaluate(boards[-1])</span></pre><p id="2210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷吧？</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="1460" class="ms lw it nf b gy nj nk l nl nm">maximum = 0<br/>for term in evaluation:<br/>    if np.mean(term) &gt; maximum:<br/>        maximum = np.mean(term)<br/>        index = evaluation.index(term)</span></pre><p id="1cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个最后的脚本向你展示了在给定的情况下最好的行动。</p><h1 id="ec1b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论:</h1><p id="5ee8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我认为这个程序是一个有趣的案例，其中神经网络不是最终的解决因素，而是机器学习问题最终解决方案的垫脚石。我认为，人们低估了神经网络绕过复杂的中间障碍的能力，这些障碍阻止人们达到目标。</p><p id="41bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望更多的人在更复杂的项目中使用神经网络作为中间步骤。</p><h1 id="56fd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我的链接:</h1><p id="a665" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你想看更多我的内容，点击这个<a class="ae ky" href="https://linktr.ee/victorsi" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">链接</strong> </a>。</p></div></div>    
</body>
</html>