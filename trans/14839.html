<html>
<head>
<title>Consistent Value Function Definitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一致值函数定义</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/consistent-value-function-definitions-e685a191c5de?source=collection_archive---------71-----------------------#2020-10-12">https://towardsdatascience.com/consistent-value-function-definitions-e685a191c5de?source=collection_archive---------71-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9be0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从数学上定义价值函数和策略，以及这些定义的一些涌现属性。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bf5f75fdba324ba5873a1114afb04a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LL50HlG2UdByYXi0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安托万·道特里在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将定义强化学习中使用的标准<em class="lv">γ</em>-贴现值函数。从这些定义出发，我将讨论值函数的两个重要涌现性质，它们证明了定义的自洽性。我将从数学上构建这些概念，重点是写出推导中的每一步，并讨论每一步的含义。这些方程是RL中许多重要数学证明的基础，完全理解它们对于建立RL的理论理解是重要的。</p><h1 id="ac85" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">价值函数</h1><p id="c171" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">价值函数是强化学习的核心。对于任何给定的状态，代理可以查询值函数来确定与处于该状态相关联的“值”。我们传统上将“价值”定义为未来获得的回报的总和。因为它依赖于代理人在未来会看到什么样的回报，所以必须为给定的行为策略定义一个价值函数；一项政策。也就是说，状态的值取决于代理在访问该状态后的行为；一个独立于行为的“价值”的讨论是没有意义的。</p><p id="aca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将策略定义为将状态映射到动作概率分布的函数。形式上，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5b8efd41d46a4fea0cc7fda535037500.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*uXKakjHrO_tYJIyJWeDRLQ.png"/></div></figure><p id="bc1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中𝒮表示代理可以访问的所有可能状态的集合(通常称为“状态空间”)，𝒜表示所有可能动作的集合(通常称为“动作空间”)，δ(𝒜表示动作集合上的标准单形。标准单纯形只是在动作空间上书写概率分布的一种形式方法。简而言之，策略接受一个状态，并返回代理在该状态下应该采取哪些操作的权重。大的权重导致选择该动作的频率，小的权重导致低的频率。</p><p id="cdf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了价值函数的直观定义和策略的正式定义，我们可以写出价值函数的正式定义:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6657f04ab3de9c62d809b66cbc8b9e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*sI7FMl1WTRaM0wzd-ukQxQ.png"/></div></figure><p id="8032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在偶发性问题设置中，我们可以假设终止后所有转换的γ=0，因此这些转换对总和仅贡献一系列零，可以忽略不计。</p><p id="f4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，上面给出的定义只是价值函数的<em class="lv">一个</em>可能的定义。强化学习的大部分理论是围绕上面定义的γ-折扣奖励值函数发展的，这也是我们将使用的定义。然而，也考虑了其他替代方法，尤其是最近，包括平均奖励值函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/49e0a644ac9f288acfad282a82e54015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4ypQKJARd8e-eEYqZykOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个简单的三态MDP。图片作者。</p></figure><p id="2034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面定义的价值函数提出了这样一个问题:“假设我们处于某个状态，我们可以期望在未来看到多少回报？”为了使用这个值函数来做出决策，代理可以查询可能的下一个状态的值。例如，假设一个代理处于状态A，有两个动作分别指向状态B和C，代理可以问<em class="lv"> v(B) </em>:“在状态B我会看到多少奖励？”或者<em class="lv"> v(C) </em>:“在C国我会看到多少奖励？”</p><p id="06f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用状态值函数来选择动作的困难在于它(a)要求代理提前知道动作的结果(例如，采取“向左”动作导致进入状态B ),以及(B)要求动作每次都确定性地导致相同的状态。强化学习框架旨在处理非常一般的问题设置，其中(a)和(b)不一定都为真。</p><p id="656b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这些挑战，我们引入了状态-动作值函数(一般简称为“动作值函数”)；但是我不喜欢这种命名约定)。状态-动作值函数定义为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/a7a00bb5dabc8ba5d347de071d66e8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*4W23s283ng044RUwskeHtQ.png"/></div></figure><p id="599b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先注意(顾名思义)这现在是一个状态<em class="lv">和</em>动作的函数，并返回未来奖励的平均值。这个和状态值函数的区别只在于(S，A，R，S，A，R，…)序列的第一个动作。在状态值函数的情况下，第一个动作是根据π(S₀分布的随机变量)；然而，在状态-动作值函数的情况下，第一个动作是非随机的并且是给定的。</p><p id="2c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过访问状态-动作值函数，代理不需要知道其环境的状态动态。它不需要知道在状态A中采取“左”的动作会导致状态B，状态B具有值<em class="lv"> v(B) </em>。相反，代理可以查询其状态-动作值函数，以获得在状态A中采取“向左”动作的值，<em class="lv"> q(A，left) </em>。正如我们将在下一节中看到的，代理人不再需要访问环境模型来做出决策这一事实是状态-动作值函数的一个定义性特征。直观地，状态-动作值函数隐含地学习环境动态的模型。</p><h1 id="5e88" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">贝尔曼一致性方程</h1><p id="9475" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><em class="lv"> v </em>和<em class="lv"> q </em>都满足一组所谓的贝尔曼一致性方程。也就是说，对于我们的任何状态和行为</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/0e8c5d274c801df705fdb1b19f3b8744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16IShxWJ5Q_hjKA1MPk3Pg.png"/></div></div></figure><p id="8516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="lv"> r(s，a) </em>是返回平均一步奖励给定状态<em class="lv"> s </em>和动作<em class="lv"> a </em>的函数。这有点复杂，所以让我们一点一点地来看。</p><p id="3561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等式(1)简单地说:如果对动作求平均，则状态<em class="lv"> s </em>的状态值函数等于状态<em class="lv"> s </em>的状态-动作值函数。将期望值写成一个和，我们得到</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/10d9f87ce4cda17e06bb0bc08dc707b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*zUbm-VXXzz5JIRl4vc71pQ.png"/></div></figure><p id="2e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即:在<em class="lv"> s </em>处的状态值函数是状态-动作值函数的所有可能动作的总和，由采取每个动作的概率加权。这是有道理的。两个价值函数对未来奖励有相同的定义，遵循政策π，并对γ折扣奖励进行求和。价值函数仅在第一步有所不同，无论行动是给我们的(状态-行动价值函数)，还是我们根据π(状态价值函数)对行动取平均值。</p><p id="6c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过访问状态-动作值函数，我们可以通过考虑序列中第一个动作的备选策略来构建任意多个可能的状态值函数。例如，假设代理想要考虑这样一个场景，其中(S，A~μ，R，S，A~π，R，S，A~π，R，…)第一个动作是从策略μ中选择的，所有未来的动作都是根据策略π选择的。这种策略组合的价值函数可以写成</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/bfc3789e6cf7e482ebeffd7087f6e828.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*9nRQgtmG0Q8m89a1073qOg.png"/></div></figure><p id="bd11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况发生在策略改进设置中，代理一次只能在一个状态下改进其策略。代理为第一个状态寻找更好的策略，假设它为所有未来状态遵循π，那么根据策略改进定理，我们可以证明这个新的联合策略至少与π一样好，如果不是更好的话。</p><p id="6c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等式(2)更复杂。让我们从简单的部分开始，这个新函数的定义<em class="lv"> r(s，a) </em>，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e51e264cc144c1ac67e41f16cc50bcc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*e9FjzNHiby-oPsxgfa-c3w.png"/></div></figure><p id="3666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我在下一次从状态<em class="lv"> s </em>开始并采取行动<em class="lv">a</em>的转变中看到的平均回报</p><p id="409f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解等式(2)的第二部分，我们先回忆一下价值函数的定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/14274006054d5e9a9efdc484c9f00952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWoJSnI-bB_YkTEXD46gwQ.png"/></div></div></figure><p id="69de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中期望是以<em class="lv"> s </em>和<em class="lv"> a、</em>为条件的，但是为了空间和清晰起见，我省略了这个细节。我还将第一次奖励的期望值替换为我们上面计算的平均奖励函数。</p><p id="c38d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在利用我们从第一个一致性方程(方程1)中学到的知识，我们可以写出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/c515b12d43e32293620e48c967b4d60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1nwHLW_8cCrmbyFtABrJw.png"/></div></div></figure><p id="710f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们恢复第二个一致性方程，方程(2)。</p><p id="6abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个第二一致性方程给了我们一些关于状态-动作值函数和状态值函数之间的区别的直觉。特别是，国家行为价值函数的不同之处仅在于序列的第一个奖励。在状态-行动的情况下，我们考虑由确定性行动<em class="lv"> a </em>选择的奖励，而不管该行动可能来自哪里(它可能被策略π采样，它可能被其他策略采样，等等)。).在状态值案例中，我们考虑平均奖励，其中根据策略π对所有行为取平均值。我们不能考虑作用的其他分布，也不能考虑特定的单个作用(这当然是作用分布的一个特例，所有的概率质量都在一个作用上)。</p><p id="3988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解价值函数和策略的定义，以及它们的一些核心涌现性质，对于RL证明中更严格的构造是至关重要的。拥有直觉有助于阅读证明和获得“基本想法”，但直觉本身不足以抓住RL中的一些微妙之处；因此经常导致不一致的误解或代码中的错误。例如，一个常见的误解是，访问一个国家行动价值函数意味着一个人可以通过对该国家行动价值函数的行动进行预期来计算<em class="lv">任何</em>其他政策的值。然而，很明显(希望如此),这种期望仅仅改变了轨迹中的第一步，但是所有以后的步骤都是关于原始策略π的。</p></div></div>    
</body>
</html>