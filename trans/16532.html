<html>
<head>
<title>A Tidy Prophet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整洁的预言家</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-tidy-prophet-5a23382d59e3?source=collection_archive---------41-----------------------#2020-11-14">https://towardsdatascience.com/a-tidy-prophet-5a23382d59e3?source=collection_archive---------41-----------------------#2020-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9fbbad5438c9ab1e0eb149c201e06856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dyoRf9moG3m6dBnBXLZ5hw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/s/photos/oracle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@vivalunastudios?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Viva Luna工作室</a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="b62c" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">在许多没有显式循环的情况下进行预测</h2></div><p id="0641" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于任何分析师/数据科学家来说，一个常见的问题是采用分析管道，然后在多个数据集上使用它。正如所料，R有几种方法来处理这个问题——显式循环、<a class="ae jd" rel="noopener" target="_blank" href="/dealing-with-apply-functions-in-r-ea99d3f49a71">*应用函数</a>和purrr。Purrr是新来者(特别是对于我们这些在RStudio出现之前就已经了解R的人来说)，但因为它承载了tidyverse背后所有深思熟虑的、富有表现力的设计，所以它可能是最强大的。</p><p id="0ce1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">脸书的<a class="ae jd" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank"> prophet </a>是一个越来越流行的时间序列建模包，有R和python APIs。它建立在概率编程语言stan的基础上，速度很快，擅长用相对较少的分析师工作量对高频率(daily plus)数据做出相当好的预测。实现prophet“大规模预测”的承诺需要拟合多个模型，这使得它成为展示purrr优势的一个很好的例子。</p><p id="69cc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用google trends每日数据进行搜索，将流行饮食与蔓越莓酱结合起来，看看tidyverse和prophet如何在几行代码中结合起来，预测尽可能多的时间序列。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lv lw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">蔓越莓不仅仅是用来喝的！</p></figure><p id="1812" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于那些不熟悉的人来说，<a class="ae jd" href="https://trends.google.com" rel="noopener ugc nofollow" target="_blank"> google trends </a>是一款用户可以输入搜索词并获得使用这些词的搜索历史的产品。可以并排放置多达五个搜索词，所有搜索词都按相同的因子缩放(我相信是屏幕上的最大值)，以查看搜索活动的时间轨迹。在这种情况下，我找到了五个关于蔓越莓酱的相关搜索。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lx"><img src="../Images/e177b7e9e2e0867f5c77c68b13e5a8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YaqCAzE44usq5o9I--V5fA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">谷歌趋势:keto超过旧石器时代两年运行在重要的蔓越莓酱搜索量！</p></figure><p id="38f3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在每年的美国感恩节附近都会看到一个强劲的峰值(注意，趋势数据是针对美国搜索而提取的)，这与我们的直觉相匹配，并为我们提供了一组有趣的时间序列来建模。</p><p id="8db5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了将我们的重点紧紧放在结合purrr和prophet上，我已经手动将下载的数据重新调整为长格式。我还将日期列重命名为ds，趋势卷列名设置为y，以符合prophet包的要求。文件的顶部看起来像这样:</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ly"><img src="../Images/4f69e74ad3adbd80489de2af42853a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUe71-zYDUsBgM_5zcPu1Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">方便成形的输入数据是你如何知道这是一个教程！</p></figure><p id="484f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了设置我们的示例，我们需要导入。csv文件作为我们的训练数据，并创建一个数据框架，以传递到拟合的先知模型进行预测(在代码中称为未来)。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lz lw l"/></div></figure><p id="803d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们的表格中的数据基本上是按照。csv文件。但是从Hadley Wickham T1的意义上来说，这并不十分整洁，因为对于我们的目的来说，每个搜索词(即表中的列的每个值<em class="ma">案例</em>、趋势数据)都是一个单独的案例或分析项目。</p><p id="e863" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请记住，我们的目标是将第一个案例的数据传递给prophet()，然后将下一个案例的数据传递给prophet()，直到处理完所有案例。</p><p id="4f49" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">分析大量案例的简洁方法是将给定案例所需的所有数据打包到表的一个单元格<strong class="kx jh">中，这样表的每一行都包含标识符、函数参数和分析单个案例所需的数据。nest()函数用于从我们现在拥有的普通平面tibble转换为具有嵌套列的tibble。它是嵌套的，因为新列的每个元素都是一个TiB ble——我们在tibbles中得到tibbles，就像嵌套的洋娃娃一样。嵌套的tibble在每个案例中只有一行(对我们来说是5行),而不会丢失原始表中的任何数据(本例中有1300行)。</strong></p><p id="b213" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整洁怎么样？</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lz lw l"/></div></figure><p id="bca9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第7行创建了嵌套的时间序列数据。使用默认参数调用nest()意味着所有非分组列都嵌套到一个名为<em class="ma"> data </em>的新列中。在第14行，我们还使用一个显式规范将未来数据案例嵌套到一个名为future的列中，其中嵌套的列名为<em class="ma"> future。</em></p><p id="122f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以在所有这些案例上训练我们的先知了！但是首先我们应该为prophet()调用准备一个额外的输入。如果你记得上面的图表数据，我们可能需要包括感恩节的假日效应。prophet包为此提供了两个选项，但是传入一个定义假日的data.frame与purrr一起使用效果更好。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="lz lw l"/></div></figure><p id="c08e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第12行最后做了本文承诺的事情，用一行代码在每种情况下拟合一个先知模型。我们使用了*map系列函数的最基本版本；map()有两个必需的参数:一个列表和一个函数名(不带括号！).map()所做的是遍历列表，依次获取每个成员，并将其作为函数的第一个参数传递给函数。每次调用函数的返回值都保存在一个列表中，map()调用返回所有函数返回的列表。在所有情况下都具有单个值的函数的附加参数(即，不是根据正在处理的数据列表的成员而变化的值)可以通过调用函数名后面的map()来传递。在我们的例子中，holidays=turkeyDayUSA论证了这一点。</p><p id="7ad8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们要传递的列表在哪里？map()的第一个参数是<em class="ma">数据。</em>回想一下，这是我们用nest()调用生成的<em class="ma"> nestedData </em>中的列名。在R中，data.frame(以及tibble，tidyverse的等价物)的每一列都是一个列表。也就是说<em class="ma">数据</em>是一个列表。因为map() <strong class="kx jh">也输出</strong>一个列表，这个输出可以用来创建一个tibble的列。mutate()函数在这里为我们处理这个问题，但是我们也可以很容易地用<code class="fe mb mc md me b">nestedResults$model=map(data,prophet,holidays=turkeyDayUSA)</code>直接添加列。模型列表的每个成员都是类先知(具有复杂结构)的对象这个小细节根本不会困扰R，也不应该困扰我们。</p><p id="b9e3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">坦白地说，所有这些都很难想象，所以我建议您运行代码(来自<a class="ae jd" href="https://github.com/lorenze3/aTidyProphet" rel="noopener ugc nofollow" target="_blank"> github repo </a>)，然后使用<em class="ma"> nestedData </em>表。你觉得nestedData$data[[1]]是什么？或者nestedData$data[[1]][1，:？</p><p id="cff0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">12号线只是一个开始。因为一旦我们理解了map()的工作方式和嵌套列的工作方式，我们就可以画一条线19。这里我们展示了pmap()，它只是对map的一个通用调用，允许从列表中提取任意数量的(可选的)命名参数并传递给函数。我们还利用了这样一个事实，即在单个mutate()调用中，我们可以创建变量，然后在下一个要创建的变量中使用它们来为第12行中的模型创建预测和绘图。是的，我们可以很容易地在一个mutate()调用中包含第12行的模型拟合。</p><p id="1d98" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将把从<em class="ma"> nestedResults </em>中提取情节的练习留给读者(提示:像访问常规列一样访问列名，然后记住它是一个列表！).</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/c4950e0b7f12f53cbb907e2f24cfdba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*u5DVB6QFszIzQmdXJfvKQw.jpeg"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">预言家预测keto蔓越莓酱去年达到顶峰</p></figure><p id="4ce1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这篇文章有助于解释purrr包的函数式编程工具。与其他tidy工具一样，*map函数简化并阐明了一项常见任务的编码。在这种情况下，该任务在多个案例上运行一组步骤。更简单和更清晰的代码意味着更少的时间调试和检查搜索<a class="ae jd" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank"> stackoverflow </a>和更多的时间尝试花哨的模型和向关键的利益相关者展示结果——这对任何人来说都是一个胜利。</p><p id="53b8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="ma">本文引用的完整代码和附带的源数据文件可以在</em><a class="ae jd" href="https://github.com/lorenze3/aTidyProphet" rel="noopener ugc nofollow" target="_blank"><em class="ma">github</em></a><em class="ma">上找到。</em></p></div></div>    
</body>
</html>