<html>
<head>
<title>New Serverless Bert with Huggingface, AWS Lambda, and AWS EFS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Huggingface、AWS Lambda和AWS EFS的新型无服务器Bert</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/new-serverless-bert-with-huggingface-aws-lambda-and-aws-efs-5d8954ce654?source=collection_archive---------31-----------------------#2020-11-15">https://towardsdatascience.com/new-serverless-bert-with-huggingface-aws-lambda-and-aws-efs-5d8954ce654?source=collection_archive---------31-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="55ff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用无服务器框架、AWS Lambda、AWS EFS、efsync、Terraform、HuggingFace的变形金刚库，构建一个无服务器问答API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/328b75638378c77c475bdf545d2a3c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8J8rHCzQ0OBvVr2GXUTRTQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Jean-Philippe Delberghe 在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e943" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">原载于2020年11月15日</em><a class="ae kv" href="https://www.philschmid.de/new-serverless-bert-with-huggingface-aws-lambda" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://www . philschmid . de</em></a><em class="ls">。</em></p><h1 id="5017" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">介绍</h1><p id="4978" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">4个月前，我写了文章<a class="ae kv" href="https://www.philschmid.de/serverless-bert-with-huggingface-and-aws-lambda" rel="noopener ugc nofollow" target="_blank">“使用HuggingFace和AWS Lambda的无服务器BERT”</a>，演示了如何通过AWS Lambda和HuggingFace的Transformers库以无服务器方式使用BERT。</p><p id="b2b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我已经预测过<a class="ae kv" href="https://www.philschmid.de/serverless-bert-with-huggingface-and-aws-lambda" rel="noopener ugc nofollow" target="_blank"> <em class="ls">“伯特和他的朋友罗伯塔、GPT-2、艾伯特和T5将在未来几年推动商业和商业理念，并将像互联网曾经做的那样改变/颠覆商业领域。”</em> </a></p><p id="eacd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从那以后，BERT在谷歌搜索中的使用从10%的英文查询增加到几乎100%的英文查询。但不是这样。谷歌现在用BERT为谷歌搜索提供超过70种语言的能力。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/c4b8cc8689b20861f667035b90ac9e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iY8Cer1akP2UhoqQapHYA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://youtu.be/ZL5x3ovujiM?t=484" rel="noopener ugc nofollow" target="_blank">https://youtu.be/ZL5x3ovujiM?t=484</a></p></figure><p id="16fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将解决我上一篇文章中的所有缺点，比如模型加载时间、依赖大小和使用。</p><p id="cc94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将构建和上次一样的“无服务器的BERT驱动的问答API”。但是，我们没有使用压缩技术来将Python依赖关系融入AWS Lambda函数，而是使用了一个名为<a class="ae kv" href="https://github.com/philschmid/efsync" rel="noopener ugc nofollow" target="_blank"> efsync </a>的工具。我构建了efsync来自动将依赖项上传到AWS EFS文件系统，然后将它们挂载到我们的AWS Lambda函数中。这允许我们将我们的机器学习模型包含到我们的函数中，而不需要从S3加载它。</p><h2 id="209c" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">TL；DR；</h2><p id="39a7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们将使用<a class="ae kv" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>、<a class="ae kv" href="https://docs.aws.amazon.com/lambda/latest/dg/welcome.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>、<a class="ae kv" href="https://aws.amazon.com/en/efs/" rel="noopener ugc nofollow" target="_blank"> AWS EFS </a>、<a class="ae kv" href="https://github.com/philschmid/efsync" rel="noopener ugc nofollow" target="_blank"> efsync </a>、<a class="ae kv" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、HuggingFace的<a class="ae kv" href="https://github.com/huggingface/transformers" rel="noopener ugc nofollow" target="_blank"> transformers </a>库以及在<a class="ae kv" href="https://rajpurkar.github.io/SQuAD-explorer/explore/v2.0/dev/" rel="noopener ugc nofollow" target="_blank"> SQuADv2 </a>上微调的Google的<code class="fe nd ne nf ng b">mobileBert</code>模型来构建一个无服务器问答API。</p><p id="a919" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这个<a class="ae kv" href="https://github.com/philschmid/new-serverless-bert-aws-lambda" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到它的完整代码。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="34a6" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">库和框架</h1><h2 id="be2b" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">无服务器框架</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/1608758fe1cfbf972502959d4bb56e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*dHzTTOIOqTcLKDbvj9etSA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a></p></figure><p id="5375" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>帮助我们开发和部署AWS Lambda功能。它是一个CLI，开箱即可提供结构、自动化和最佳实践。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="72ed" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">自动气象站λ</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9fac40b039a172c9433ec56b8986f759.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*wtvYRZg_iZmpjOhCZeUhAw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://aws.amazon.com/de/lambda/features/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda标志</a></p></figure><p id="afce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS Lambda是一种无服务器的计算服务，让你无需管理服务器就能运行代码。它只在需要的时候执行你的代码，并且自动伸缩，从每天几个请求到每秒几千个请求。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="508e" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">亚马逊弹性文件系统(EFS)</h2><p id="9a5a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://aws.amazon.com/de/efs/" rel="noopener ugc nofollow" target="_blank">亚马逊EFS </a>是一项完全托管的服务，可以轻松设置、扩展和优化亚马逊云中的文件存储。自2020年6月起，您可以将AWS EFS安装到AWS Lambda函数</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="5c53" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">Efsync</h2><p id="d28f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/philschmid/efsync" rel="noopener ugc nofollow" target="_blank"> Efsync </a>是一个CLI/SDK工具，可以自动将文件和依赖项同步到AWS EFS。它使您能够将AWS Lambda运行时的依赖项直接安装到EFS文件系统中，并在AWS Lambda函数中使用它们。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="d0e4" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">将（行星）地球化（以适合人类居住）</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ebee964592b65d22a2b87b3f288d6c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*Dysvf6oQfGc2kAB6frT61A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.terraform.io/logos.html" rel="noopener ugc nofollow" target="_blank"> Terraform标志</a></p></figure><p id="92ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>是一款基础设施即代码(IaC)工具，用于安全高效地构建云原生基础设施。Terraform使您能够使用HCL (HashiCorp配置语言)来描述您的云原生基础架构。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h2 id="c448" class="mr lu iq bd lv ms mt dn lz mu mv dp md lf mw mx mf lj my mz mh ln na nb mj nc bi translated">拥抱脸的变形金刚库</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/895fa9db59d40feb8ec6c218bfe0a623.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*RxIALlrjl39zLP8CcsBWdw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://huggingface.co/" rel="noopener ugc nofollow" target="_blank"> HugginFace标志</a></p></figure><p id="c9b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/huggingface/transformers" rel="noopener ugc nofollow" target="_blank">变形金刚库</a>为自然语言理解(NLU)和自然语言生成(NLG)提供最先进的机器学习架构，如BERT、GPT-2、罗伯塔、XLM、DistilBert、XLNet、T5。它还提供了100多种不同语言的数千个预训练模型。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="9caa" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">建筑</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/7201b67fcf56e61471bb34974e8c9e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQXLVkxXR4Hw4oD-kwhU-g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由菲利普·施密德创造</p></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="f20d" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">辅导的</h1><p id="b1bf" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在我们开始之前，确保您已经配置并设置了<a class="ae kv" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>和<a class="ae kv" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank">平台</a>。此外，您需要访问AWS帐户来创建EFS文件系统、API网关和AWS Lambda函数。</p><p id="2582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在教程中，我们将使用来自Google的预训练<code class="fe nd ne nf ng b">BERT</code>模型构建一个问答API。</p><p id="15ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将向lambda函数发送一个上下文(一小段)和一个问题，lambda函数将使用问题的答案进行响应。</p><p id="97e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">我们要做什么:</strong></p><ul class=""><li id="b084" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">使用<code class="fe nd ne nf ng b">terraform</code>创建所需的基础设施。</li><li id="2bd8" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">使用<code class="fe nd ne nf ng b">efsync</code>上传我们的Python依赖到AWS EFS。</li><li id="5f92" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">用无服务器框架创建一个Python Lambda函数。</li><li id="90fb" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">将<code class="fe nd ne nf ng b">BERT</code>模型添加到我们的函数中，并创建一个推理管道。</li><li id="e9f1" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">配置<code class="fe nd ne nf ng b">serverless.yaml</code>，添加EFS，设置一个API网关进行推理。</li><li id="a463" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">部署和测试功能。</li></ul><p id="3de9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将需要一个名为<code class="fe nd ne nf ng b">serverless-bert</code>的新IAM用户，并使用<code class="fe nd ne nf ng b">aws configure --profile serverless-bert</code>在AWS CLI中对其进行配置。这个IAM用户在完整教程中使用。如果你不知道怎么做，看看这个<a class="ae kv" href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="891e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">注意:</em> </strong> <em class="ls">我不建议使用</em> <code class="fe nd ne nf ng b"><em class="ls">AdministratorAccess</em></code>为生产使用创建IAM用户</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="35dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，我想说的是我们不会对每一步都进行详细说明。如果你想更多地了解如何在AWS Lambda中使用深度学习，我建议你看看我的其他文章:</p><ul class=""><li id="c82e" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><a class="ae kv" href="https://www.philschmid.de/scaling-machine-learning-from-zero-to-hero" rel="noopener ugc nofollow" target="_blank">从零到英雄的缩放机学习</a></li><li id="0352" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><a class="ae kv" href="https://www.philschmid.de/how-to-set-up-a-ci-cd-pipeline-for-aws-lambda-with-github-actions-and-serverless" rel="noopener ugc nofollow" target="_blank">如何使用GitHub操作和无服务器为AWS Lambda设置CI/CD管道</a></li><li id="a854" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><a class="ae kv" href="https://www.philschmid.de/serverless-bert-with-huggingface-and-aws-lambda" rel="noopener ugc nofollow" target="_blank">带HuggingFace和AWS Lambda的无服务器BERT</a></li><li id="a029" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><a class="ae kv" href="https://www.philschmid.de/efsync-my-first-open-source-mlops-toolkit" rel="noopener ugc nofollow" target="_blank"> efsync我的第一个开源MLOps工具包</a></li></ul><p id="e4d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在这个<a class="ae kv" href="https://github.com/philschmid/new-serverless-bert-aws-lambda" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到完整的代码。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="b7de" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">使用<code class="fe nd ne nf ng b">terraform</code>创建所需的基础设施</h1><p id="c07b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，我们使用terraform定义和创建所需的基础设施。如果你还没有设置，你可以看看这个教程。</p><p id="4855" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为基础设施，我们需要一个AWS EFS文件系统、一个访问点和一个挂载目标，以便能够在AWS Lambda函数中使用它。我们也可以创建一个VPC，但出于本教程的目的，我们将使用默认的VPC和他的子网。</p><p id="277f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们创建一个目录<code class="fe nd ne nf ng b">serverless-bert/</code>，其中包含本教程的所有代码，还有一个包含我们的<code class="fe nd ne nf ng b">main.tf</code>文件的子文件夹<code class="fe nd ne nf ng b">terraform/</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="dd83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们用我们首选的IDE打开<code class="fe nd ne nf ng b">main.tf</code>,并添加terraform资源。我为他们所有人提供了一个基本模板。如果您想定制它们或添加额外的资源，请查看<a class="ae kv" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs" rel="noopener ugc nofollow" target="_blank">文档</a>了解所有可能性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f0fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要更改EFS的名字，您可以编辑<code class="fe nd ne nf ng b">aws_efs_filesystem</code>资源中的值<code class="fe nd ne nf ng b">creation_token</code>。否则，EFS的名字将是“无服务器-伯特”。此外，我们在最后为<code class="fe nd ne nf ng b">efs_access_point_id</code>创建了一个SSM参数，以便稍后在我们的<code class="fe nd ne nf ng b">serverless.yaml</code>中使用。</p><p id="49c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用terraform，我们首先运行<code class="fe nd ne nf ng b">terraform init</code>来初始化我们的项目和提供者(AWS)。请注意，我们必须在<code class="fe nd ne nf ng b">terraform/</code>目录中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d7cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们用<code class="fe nd ne nf ng b">terraform plan</code>检查我们的IaC定义</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="e340" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，我们用<code class="fe nd ne nf ng b">terraform apply</code>创建我们的基础设施</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/85b5f3d7a8c4260f0c5933fc8382ecfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oMAf7pkKNE7s_Jvy9_W3w.png"/></div></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="fa1c" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">使用<code class="fe nd ne nf ng b">efsync</code>将我们的Python依赖关系上传到AWS EFS</h1><p id="ea78" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">下一步是在AWS EFS文件系统上添加和安装我们的依赖项。因此我们使用一个叫做<code class="fe nd ne nf ng b">efsync</code>的工具。我创建了<a class="ae kv" href="https://github.com/philschmid/efsync" rel="noopener ugc nofollow" target="_blank"> efsync </a>来将AWS Lambda运行时的依赖项直接安装到您的EFS文件系统中，并在AWS Lambda函数中使用它们。</p><p id="36e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行<code class="fe nd ne nf ng b">pip3 install efsync</code>安装efsync</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f572" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装完成后，我们在根目录<code class="fe nd ne nf ng b">serverless-bert/</code>中创建一个<code class="fe nd ne nf ng b">requirements.txt</code>，并向其中添加我们的依赖项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f490" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Efsync提供不同的<a class="ae kv" href="https://github.com/philschmid/efsync#sdk" rel="noopener ugc nofollow" target="_blank">配置</a>。这次我们使用带有<code class="fe nd ne nf ng b">yaml</code>配置的CLI。为此，我们在根目录中创建一个<code class="fe nd ne nf ng b">efsync.yaml</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="393f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们必须调整<code class="fe nd ne nf ng b">efs_filesystem_id</code>和<code class="fe nd ne nf ng b">subnet_Id</code>的值。通过在管理控制台中查找或使用这两个CLI命令来获取这些值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/cf2ba8d8b36c6df430ed68226a8e1626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ttQcupefOETEd5RtZTKVg.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/9a9ffbd8fcbbc3afc1d7db914368393f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9VO_zjVdTXES9bYV0t7cg.png"/></div></div></figure><p id="21b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，如果您之前更改了<code class="fe nd ne nf ng b">creation_token</code>，您必须在此处进行调整。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/5360ef6c9ea1f0777dd05863bfc6a7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roQBn3QobU02z6JZ-3XlXw.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/2b5181992ac80faccfa9b5fded49fe1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_7EW4rHJT7SR4ZrizRLYA.png"/></div></div></figure><p id="11d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以为<code class="fe nd ne nf ng b">efsync.yaml</code>配置选择一个<code class="fe nd ne nf ng b">subnet_Ids</code>。如果你想了解更多的配置选项，你可以在这里阅读更多的<a class="ae kv" href="https://github.com/philschmid/efsync" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="92ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在配置完我们的<code class="fe nd ne nf ng b">efsync.yaml</code>之后，我们运行<code class="fe nd ne nf ng b">efsync -cf efsync.yaml</code>在我们的AWS EFS文件系统上安装我们的Python依赖项。这大约需要5-10分钟。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/c7d4113f5e30c345b25e65e4e492341b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ro4qzEKBjdwxYhggoxDOg.png"/></div></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="cef3" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">使用无服务器框架创建Python Lambda函数</h1><p id="a5dd" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">第三，我们通过使用带有<code class="fe nd ne nf ng b">aws-python3</code>模板的无服务器CLI创建AWS Lambda函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="9ff9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个CLI命令将创建一个包含<code class="fe nd ne nf ng b">handler.py</code>、<code class="fe nd ne nf ng b">.gitignore</code>和<code class="fe nd ne nf ng b">serverless.yaml</code>文件的新目录。<code class="fe nd ne nf ng b">handler.py</code>包含一些基本的样板代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="0740" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">将<code class="fe nd ne nf ng b">BERT </code>模型添加到我们的函数中，并创建一个推理管道</h1><p id="6edb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">因为我们没有将Python依赖项包含到AWS Lambda函数中，所以我们有大约250MB的存储空间用于模型文件。对于那些不太熟悉AWS Lambda及其局限性的人，你可以查看这个<a class="ae kv" href="https://www.notion.so/add-the-mobileBERTmodel-from-to-our-function-and-create-an-inference-pipeline-b5530c56acb7437c8ef1a395c4436b7d" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="abcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想使用大于250MB的模型，您可以使用efsync将它们上传到EFS，然后从那里加载它们。更多 <a class="ae kv" href="https://www.philschmid.de/efsync-my-first-open-source-mlops-toolkit" rel="noopener ugc nofollow" target="_blank"> <em class="ls">此处阅读</em> </a> <em class="ls">。</em></p><p id="58f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要将我们的<code class="fe nd ne nf ng b">BERT</code>模型添加到我们的函数中，我们必须从HuggingFace 的<a class="ae kv" href="https://huggingface.co/models" rel="noopener ugc nofollow" target="_blank">模型中枢加载它。为此，我创建了一个python脚本。在执行这个脚本之前，我们必须将<code class="fe nd ne nf ng b">transformers</code>库安装到我们的本地环境中，并在我们的<code class="fe nd ne nf ng b">function/</code>目录中创建一个<code class="fe nd ne nf ng b">model</code>目录。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们安装了<code class="fe nd ne nf ng b">transformers</code>之后，我们在<code class="fe nd ne nf ng b">function/</code>目录下创建了<code class="fe nd ne nf ng b">get_model.py</code>文件，并包含了下面的脚本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="4e41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了执行这个脚本，我们在<code class="fe nd ne nf ng b">function/</code>目录中运行<code class="fe nd ne nf ng b">python3 get_model.py</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="298e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">提示</em> </strong> <em class="ls">:将</em> <code class="fe nd ne nf ng b"><em class="ls">model</em></code> <em class="ls">目录添加到gitignore中。</em></p><p id="7126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是调整我们的<code class="fe nd ne nf ng b">handler.py</code>，包括我们的<code class="fe nd ne nf ng b">serverless_pipeline()</code>。</p><p id="814e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们将所有需要的导入和我们的EFS文件系统添加到<code class="fe nd ne nf ng b">PYTHONPATH</code>中，这样我们就可以从那里导入我们的依赖项。因此我们使用<code class="fe nd ne nf ng b">sys.path.append(os.environ['EFS_PIP_PATH'])</code>。我们将在稍后的<code class="fe nd ne nf ng b">serverless.yaml</code>中定义<code class="fe nd ne nf ng b">EFS_PIP_PATH</code>。</p><p id="fa22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了<code class="fe nd ne nf ng b">serverless_pipeline()</code>函数，它初始化我们的模型和标记器，并返回一个<code class="fe nd ne nf ng b">predict</code>函数，我们可以在<code class="fe nd ne nf ng b">handler</code>中使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="b6ed" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">配置<code class="fe nd ne nf ng b">serverless.yaml</code>，添加EFS，设置推理的API网关。</h1><p id="7fa5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我为这个例子提供了完整的<code class="fe nd ne nf ng b">serverless.yaml</code>,但是我们检查了我们的EFS文件系统所需的所有细节，并省略了所有的标准配置。如果你想了解更多关于<code class="fe nd ne nf ng b">serverless.yaml</code>的知识，建议你去看看<a class="ae kv" href="https://www.philschmid.de/scaling-machine-learning-from-zero-to-hero" rel="noopener ugc nofollow" target="_blank">从零到英雄的缩放机学习</a>。在本文中，我介绍了每种配置，并解释了它们的用法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要用下面的命令安装<code class="fe nd ne nf ng b">serverless-pseudo-parameters</code>插件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="befa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe nd ne nf ng b">serverless-pseudo-parameters</code>插件让我们的<code class="fe nd ne nf ng b">AWS::AccountID</code>在<code class="fe nd ne nf ng b">serverless.yaml</code>中被引用。在<code class="fe nd ne nf ng b">custom</code>下或我们的<code class="fe nd ne nf ng b">functions</code>部分中引用了所有自定义变量。</p><p id="f5ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">自定义:</strong></p><ul class=""><li id="7796" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><code class="fe nd ne nf ng b">efsAccessPoint</code>应该是你的EFS接入点的价值。这里，我们使用我们的<code class="fe nd ne nf ng b">terraform</code>模板先前创建的SSM参数。</li><li id="e7a9" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe nd ne nf ng b">LocalMountPath</code>是EFS在AWS Lambda函数中的安装路径。</li><li id="dcd0" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated"><code class="fe nd ne nf ng b">efs_pip_path</code>是我们使用<code class="fe nd ne nf ng b">efsync</code>安装Python依赖项的路径。</li></ul><p id="ad0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">功能:</strong></p><ul class=""><li id="31c8" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><code class="fe nd ne nf ng b">securityGroupIds</code>可以是AWS帐户中的任何安全组。我们使用<code class="fe nd ne nf ng b">default</code>安全组id。这个应该是这样的<code class="fe nd ne nf ng b">sg-1018g448</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="eb7e" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated"><code class="fe nd ne nf ng b">subnetsId</code>应该与EFS文件系统具有相同的id。它们应该是这样的<code class="fe nd ne nf ng b">subnet-8f9a7de5</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="1657" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">部署和测试功能</h1><p id="35a2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了部署功能，我们运行<code class="fe nd ne nf ng b">serverless deploy --aws-profile serverless-bert</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="3346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个过程完成后，我们应该看到类似这样的东西。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/d46615dfa2d1d35c2ff1ea6e1379a317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vymbUL6gtMgrcU5Tsu86Lw.png"/></div></div></figure><p id="d1d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试我们的Lambda函数，我们可以使用失眠症、邮差或任何其他REST客户端。只需在请求体中添加一个带有<code class="fe nd ne nf ng b">context</code>和<code class="fe nd ne nf ng b">question</code>的JSON。让我们用colab笔记本中的例子来尝试一下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe nd ne nf ng b">serverless_pipeline()</code>用<code class="fe nd ne nf ng b">83.1</code>正确回答了我们的问题。此外，您可以看到完整的第一个请求花费了2900毫秒或29秒。其中15秒用来初始化我们函数中的模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/b10fa3110f4500de68ab28bc4376d77b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctJIDHsvhEWKFg6UYLj8gQ.png"/></div></div></figure><p id="0594" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个请求只用了390毫秒。</p><p id="fc7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最棒的是，如果有几个传入请求，我们的BERT模型会自动扩展！它可以扩展到数千个并行请求，而不用担心任何问题。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="251c" class="lt lu iq bd lv lw no ly lz ma np mc md jw nq jx mf jz nr ka mh kc ns kd mj mk bi translated">结论</h1><p id="c014" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们已经成功地实现了一个无服务器问答API。对于实现，我们以无服务器的方式使用IaC工具和“最先进的”NLP模型。从开发人员的角度来看，我们降低了复杂性，但包含了许多DevOps/MLOps步骤。我认为有必要包括DevOps/MLOps，如果你想在生产中运行可扩展的无服务器机器学习，它可以处理你的部署和供应。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="155e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到<a class="ae kv" href="https://github.com/philschmid/new-serverless-bert-aws-lambda" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>和完整的代码<a class="ae kv" href="https://github.com/philschmid/new-serverless-bert-aws-lambda" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="01bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。如果你有任何问题，随时联系我或评论这篇文章。你也可以在<a class="ae kv" href="https://twitter.com/_philschmid" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或者<a class="ae kv" href="https://www.linkedin.com/in/philipp-schmid-a6a2bb196/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上和我联系。</p></div></div>    
</body>
</html>