<html>
<head>
<title>PyCaret 2.2 is here — What’s new?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyCaret 2.2已经发布了，有什么新消息吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pycaret-2-2-is-here-whats-new-ad7612ca63b?source=collection_archive---------3-----------------------#2020-10-28">https://towardsdatascience.com/pycaret-2-2-is-here-whats-new-ad7612ca63b?source=collection_archive---------3-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2809b1dfd0161007c86890f9cdfefe5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e68NedKMNWlpfWzr6Xx4JA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">PyCaret 2.2现在可以使用pip下载。<a class="ae kc" href="https://www.pycaret.org" rel="noopener ugc nofollow" target="_blank">https://www.pycaret.org</a></p></figure><p id="969d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们很高兴宣布py caret 2.2—2020年10月的更新。</p><p id="3b36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyCaret是一个用Python编写的开源、<strong class="kf ir">低代码</strong>机器学习库，可以自动化机器学习工作流。它是一个端到端的机器学习和模型管理工具，可以加快机器学习实验周期，让你更有效率。</p><p id="8c2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与其他开源机器学习库相比，PyCaret是一个替代的低代码库，可以用来替换数百行代码。这使得实验快速有效。</p><p id="9867" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发行说明:【https://github.com/pycaret/pycaret/releases T4】</p><p id="2d38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文档:<a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://pycaret.readthedocs.io/en/latest/</a></p><h1 id="6d29" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正在安装PyCaret</h1><p id="d4f3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">安装PyCaret非常容易，只需要几分钟。我们强烈建议使用虚拟环境来避免与其他库的潜在冲突。参见下面的示例代码，创建一个conda环境<strong class="kf ir"> <em class="me"> </em> </strong>并在该conda环境中安装pycaret:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3a8c" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># create a conda environment </strong><br/>conda create --name yourenvname python=3.6  </span><span id="e7af" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># activate environment </strong><br/>conda activate yourenvname  </span><span id="6740" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># install pycaret </strong><br/>pip install pycaret<strong class="mk ir"> </strong></span><span id="1787" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># create notebook kernel linked with the conda environment <br/></strong>python -m<strong class="mk ir"> </strong>ipykernel install --user --name yourenvname --display-name "display-name"</span></pre><p id="44d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyCaret的默认安装是pycaret的精简版本，它只安装这里列出的<a class="ae kc" href="https://github.com/pycaret/pycaret/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank">硬依赖项</a>。要安装pycaret的完整版本，请使用以下代码:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f9b9" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># install the full version</strong><br/>pip install pycaret[full]</span></pre><p id="6ef0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您安装pycaret的完整版本时，这里列出的所有可选依赖项<a class="ae kc" href="https://github.com/pycaret/pycaret/blob/master/requirements-optional.txt" rel="noopener ugc nofollow" target="_blank">也会被安装。</a></p><h1 id="d326" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装每夜构建</h1><p id="9c8f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">PyCaret进化非常快。通常，您希望获得最新的特性，但是希望避免从源代码编译PyCaret或者等待下一个版本。幸运的是，您现在可以使用pip安装pycaret-nightly。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a8c7" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># install the nightly build<br/></strong>pip install pycaret-nightly<br/><br/><strong class="mk ir"># or install the full version of the nightly build<br/></strong>pip install pycaret-nightly[full]</span></pre><h1 id="ac7b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">PyCaret 2.2功能概述</h1><h1 id="07bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉支持GPU的培训</h1><p id="9722" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">PyCaret 2.2提供了使用GPU进行选择模型训练和超参数调整的选项。API的使用没有变化，但是，在某些情况下，必须安装额外的库，因为它们没有安装默认的精简版本或完整版本。以下模型现在可以在GPU上训练。</p><ul class=""><li id="c431" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">极端梯度增压(无需进一步安装)</li><li id="3239" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">CatBoost(无需进一步安装)</li><li id="1064" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">光线渐变增强器(需要安装GPU:<a class="ae kc" href="https://lightgbm.readthedocs.io/en/latest/GPU-Tutorial.html" rel="noopener ugc nofollow" target="_blank">https://lightgbm.readthedocs.io/en/latest/GPU-Tutorial.html</a></li><li id="9194" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">逻辑回归、岭分类器、随机森林、K近邻分类器、K近邻回归器、支持向量机、线性回归、岭回归、套索回归、K-均值聚类和基于密度的空间聚类(需要累积量&gt; = 0.15【https://github.com/rapidsai/cuml】T2</li></ul><p id="f630" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在GPU上启用光照梯度增强机器，您必须安装LightGBM的GPU启用版本。官方的分步指南是这里的<a class="ae kc" href="https://lightgbm.readthedocs.io/en/latest/GPU-Tutorial.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="ef36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你使用Google Colab，你可以为GPU安装Light Gradient Boosting Machine，但首先，你必须卸载Light GBM-CPU版本。在此之前，请确保在您的Colab会话中启用了GPU。使用以下代码安装支持GPU的LightGBM:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0522" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># uninstall lightgbm CPU</strong><br/>pip uninstall lightgbm -y</span><span id="56e2" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># install lightgbm GPU</strong><br/>pip install lightgbm --install-option=--gpu --install-option="--opencl-include-dir=/usr/local/cuda/include/" --install-option="--opencl-library=/usr/local/cuda/lib64/libOpenCL.so"</span></pre><p id="a66f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">截至今天，谷歌Colab上还不支持cuML 0.15。这在未来可能会改变，但现在，你可以免费使用预装了cuML 0.15的<a class="ae kc" href="https://blazingsql.com/" rel="noopener ugc nofollow" target="_blank"> blazingSQL </a>笔记本。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/05ce0285dd498d250d9ae1d36279f0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbP3mVXRF1FbrQ7HCRE2Bw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://blazingsql.com/" rel="noopener ugc nofollow" target="_blank">https://blazingsql.com/</a></p></figure><p id="b031" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">登录到您的帐户后，启动Python 3笔记本并使用以下代码安装pycaret:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="70f1" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># install pycaret on blazingSQL</strong><br/>!/opt/conda-environments/rapids-stable/bin/python -m pip install --upgrade pycaret</span></pre><p id="0c60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，如果你在本地机器上有GPU，或者你计划使用任何其他带有GPU的云服务，你可以遵循cuML的官方<a class="ae kc" href="https://rapids.ai/start.html#rapids-release-selector" rel="noopener ugc nofollow" target="_blank">安装指南</a>。</p><p id="2f5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设安装成功，在GPU上训练模型唯一需要做的就是在初始化设置函数时启用GPU。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e2b4" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># import dataset<br/></strong>from pycaret.datasets import get_data<br/>data = get_data('poker')</span><span id="f6cd" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># initialize the setup<br/></strong>from pycaret.classification import *<strong class="mk ir"><br/></strong>clf = setup(data, target = 'CLASS', use_gpu = True)</span></pre><p id="9fdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。您现在可以像在CPU上一样使用pycaret了。它会自动使用GPU进行模型训练，如果可能的话，还会使用CPU等效算法。甚至在开始训练之前，您可以通过使用以下命令来检查GPU上启用了哪些模型:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f0d5" class="mo lc iq mk b gy mp mq l mr ms">models(internal=True)[['Name', 'GPU Enabled']]</span></pre><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/2b62489528bf4404e0f3f3cd33d8b362.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*pnGKEl1DxIbaekvX4mUlcg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">模型输出(内部=真)</p></figure><p id="9c46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">CPU与GPU的性能指标评测比较(以秒为单位)</strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/f971a1cd1ffd634aa409df07a9fb2147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NmlkhZsXvkJBRE0KXPUuQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">基准比较CPU与GPU，数据集:扑克(100K x 88)</p></figure><h1 id="9718" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉超参数调谐</h1><p id="03bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在有了新的超参数调谐方法。在PyCaret 2.1之前，在PyCaret中调整模型的超参数的唯一方法是使用scikit-learn中的随机网格搜索。2.2中添加的新方法有:</p><ul class=""><li id="273e" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">scikit-learn(网格)</li><li id="7486" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">sci kit-优化(贝叶斯)</li><li id="b776" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">tune-sklearn(随机、网格、贝叶斯、超点、bohb)</li><li id="8571" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">optuna(随机，热塑性弹性体)</li></ul><p id="c91e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用这些新方法，增加了两个新参数<strong class="kf ir">‘搜索_库’</strong>和<strong class="kf ir">‘搜索_算法’</strong>。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ec21" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># train dt using default hyperparameters</strong><br/>dt = create_model('dt')</span><span id="274d" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># tune hyperparameters with scikit-learn (default)</strong><br/>tuned_dt_sklearn = tune_model(dt)</span><span id="ef28" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># tune hyperparameters with scikit-optimize</strong><br/>tuned_dt_skopt = tune_model(dt, search_library = 'scikit-optimize')</span><span id="8b4e" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># tune hyperparameters with optuna</strong><br/>tuned_dt_optuna = tune_model(dt, search_library = 'optuna')</span><span id="b768" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># tune hyperparameters with tune-sklearn</strong><br/>tuned_dt_tuneskl = tune_model(dt, search_library = 'tune-sklearn')</span></pre><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/7267b48a8eec7b6799864897f2646927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6_-0Q4u2EM7aTVuraF5Nw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">tune_model输出(dt，默认超参数AUC = 0.7401</p></figure><p id="e1b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">搜索_算法</strong>依赖于<strong class="kf ir">搜索_库</strong>。以下搜索算法可用于相应的搜索库:</p><ul class=""><li id="ecbb" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated">scikit-learn → random(默认)，网格</li><li id="50aa" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">sci kit-优化→贝叶斯(默认)</li><li id="8d1d" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">tune-sklearn →随机(默认)，网格，贝叶斯，超点，bohb</li><li id="d7df" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">optuna →随机，tpe(默认)</li></ul><p id="711d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有<strong class="kf ir"> partial_fit </strong>属性的估计器也支持提前停止。<a class="ae kc" href="https://github.com/pycaret/pycaret/releases" rel="noopener ugc nofollow" target="_blank">在发行说明中阅读更多关于它的</a>。</p><p id="dba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">不同调谐器的基准比较</strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/225d1cead923f456c1f48f4e159c9c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5rvZ2hZ1Js5NaIT_cQxgQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">PyCaret数据集:糖尿病中可用搜索库/搜索算法的基准比较</p></figure><h1 id="69d9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉内存和性能改进</h1><p id="ae27" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">PyCaret 2.2关注的是性能和功能。大量代码被重构，以在不影响用户体验的情况下改善内存占用和优化性能。</p><p id="ad3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个例子是所有的数字数据从以前的64位动态转换为32位，大大减少了内存占用。性能提升的另一个例子是跨所有功能的交叉验证，与以前按折叠顺序训练相比，现在跨多个内核自动并行化。</p><p id="352b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在著名的<a class="ae kc" href="https://www.kaggle.com/c/nyc-taxi-trip-duration" rel="noopener ugc nofollow" target="_blank">纽约出租车数据集</a>的500万个样本行上比较了PyCaret所有发布版本的性能。下图比较了完成设置初始化所需的时间:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d1fbc755dee01748b3f3e093c0ed5592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*RsXAhw770eS0zBk_WzMQpg.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来自纽约出租车数据集的5M行的基准性能比较</p></figure><p id="1925" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的比较都是在具有8个CPU内核的AMD64机器上进行的。</p><h1 id="7fdb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉添加自定义指标</h1><p id="5452" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在，您可以完全自定义(添加或删除)在交叉验证期间评估的指标。这意味着您不再局限于PyCaret的默认模型评估指标。增加了三个新功能<strong class="kf ir">获取指标、添加指标、</strong>和<strong class="kf ir">移除指标</strong>。用法超级简单。参见示例代码:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="615f" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># import dataset<br/></strong>from pycaret.datasets import get_data<br/>data = get_data('juice')</span><span id="07a7" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># initialize the setup<br/></strong>from pycaret.classification import *<strong class="mk ir"><br/></strong>clf = setup(data, target = 'Purchase')</span><span id="1ed7" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># check all metrics used for model evaluation<em class="me"><br/></em></strong>get_metrics()</span><span id="50d2" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># add Log Loss metric in pycaret</strong><br/>from sklearn.metrics import log_loss<br/>add_metric('logloss', 'LogLoss', log_loss, greater_is_better=False)</span><span id="b879" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># compare baseline models<em class="me"><br/></em></strong>best = compare_models()</span></pre><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/7f8a302992dd5a435a20d7d7a77a991b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWRHfKmqkZODpOuyEO34HQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">添加自定义指标后的compare_models输出</p></figure><p id="cb25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，在TT 被添加到<strong class="kf ir"> compare_models </strong>得分网格之前，一个新列“log loss”(<em class="me">所有新指标被添加到右侧)，因为我们使用<strong class="kf ir"> add_metric </strong>函数添加了指标。您可以使用<a class="ae kc" href="https://scikit-learn.org/stable/modules/classes.html#sklearn-metrics-metrics" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a> <strong class="kf ir"> </strong>中可用的任何指标，或者您可以使用<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.make_scorer.html" rel="noopener ugc nofollow" target="_blank"> make_scorer </a>函数创建自己的指标。您可以使用以下命令删除度量:</em></p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="23b8" class="mo lc iq mk b gy mp mq l mr ms">remove_metric('logloss')</span></pre><h1 id="4dd4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉迭代插补</h1><p id="b38f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">迭代插补是一种使用回归和分类估计器来输入缺失数据的技术，将每个特征建模为其他特征的函数。每个特征以循环方式进行估算，以前的预测用于新的预测。为了提高估算的质量，这个过程要重复几次。与简单的插补相比，它可以创建更接近真实值的合成值，但需要额外的处理时间。</p><p id="8cc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">忠于PyCaret的精神，用法非常简单:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6e8b" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># initialize setup</strong><br/>from pycaret.classification import *<strong class="mk ir"><br/></strong>clf = setup(data, target = 'Class', imputation_type="iterative")</span></pre><p id="df8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，它将使用光梯度增强机器作为分类特征(分类)和数值特征(回归)的估计器，这可以使用设置中的<strong class="kf ir">分类_迭代_估算</strong>和<strong class="kf ir">数值_迭代_估算</strong>参数进行更改。</p><p id="a75a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">迭代插补与简单插补的基准比较</strong></p><p id="c79f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了比较简单均值插补和迭代插补的结果，我们使用了包含大量缺失值的<a class="ae kc" href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/horse-colic.data" rel="noopener ugc nofollow" target="_blank">马疝气数据集</a>。下图比较了使用不同插补方法的逻辑回归的表现。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/a29e563a6c0ef21a52a0a35b9ae719ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCcFBUTrxeiIu0ZHIsZMyA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">安东尼·鲍姆的一篇博文:<a class="ae kc" href="https://www.linkedin.com/pulse/iterative-imputation-pycaret-22-antoni-baum/?trackingId=ByTfWY9y%2FogKIZV68ehF%2Bw%3D%3D" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/iterative-attumation-py caret-22-安东尼-鲍姆/ </a></p></figure><p id="4e4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与简单平均插补相比，使用KNN迭代插补作为分类和数值特征的估计量，平均AUC得分提高了0.014 (1.59%)。要了解更多关于这个功能的信息，你可以在这里阅读完整的博文<a class="ae kc" href="https://www.linkedin.com/pulse/iterative-imputation-pycaret-22-antoni-baum/?trackingId=ByTfWY9y%2FogKIZV68ehF%2Bw%3D%3D" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="0f91" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉折叠策略</h1><p id="eefb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">PyCaret 2.2提供了定义折叠策略的灵活性。在PyCaret 2.1之前，您不能定义交叉验证策略。它使用<strong class="kf ir">‘StratifiedKFold’</strong>进行分类，使用<strong class="kf ir">‘k fold’</strong>进行回归，这限制了PyCaret在某些用例中的使用，例如时间序列数据。</p><p id="04df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了克服这个问题，在设置功能中增加了一个新参数<strong class="kf ir">‘fold _ strategy’</strong><strong class="kf ir"/>。它可以采用以下值:</p><ul class=""><li id="2b4b" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated"><code class="fe nq nr ns mk b">kfold</code>为KFold CV</li><li id="d217" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe nq nr ns mk b">stratifiedkfold</code>为分层KFold CV</li><li id="d13a" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe nq nr ns mk b">groupkfold</code>为集团KFold CV</li><li id="238a" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe nq nr ns mk b">timeseries</code>为TimeSeriesSplit CV或者</li><li id="d86a" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">与scikit-learn兼容的自定义CV生成器对象。</li></ul><h1 id="9707" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉比较保留集上的模型</h1><p id="41b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果你之前用过PyCaret，你一定熟悉它最常用的函数<strong class="kf ir"> compare_models。</strong>此功能使用交叉验证来训练和评估模型库中所有可用估计器的性能。然而，问题是如果你正在处理非常大的数据集，compare_models可能要花很长时间才能完成。原因是它适合模型库中每个估计器的10倍。对于分类，这意味着总共有15 x 10 = 150个评估者。</p><p id="1adb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在PyCaret 2.2中，我们在compare_models <strong class="kf ir"> </strong>函数中引入了一个新参数<strong class="kf ir"> cross_validation </strong>，当该参数设置为False时，将对维持集上的所有指标进行评估，而不是进行交叉验证。而单独依赖维持指标可能并不可取，尤其是当数据集太小时。在处理大型数据集时，这无疑可以节省大量时间。</p><p id="1720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了量化影响，我们比较了<strong class="kf ir"> compare_models </strong>在两种场景中的性能(交叉验证=真，交叉验证=假)。用于比较的数据集是<a class="ae kc" href="https://github.com/pycaret/pycaret/blob/master/datasets/bank.csv" rel="noopener ugc nofollow" target="_blank">这里是</a> (45K x 50)</p><p id="b202" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="me">交叉验证(耗时7分13秒):</em> </strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/f0b03fb7d1788289d2d3765c47ca144e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8B7KNFqhwGUcm7X8s_jZg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">compare_models的输出(cross_validation = True)</p></figure><p id="ea3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="me">无交叉验证(耗时1分19秒):</em> </strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/de5aea8e778f5eadff5247be647e43b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ogwbErxNVt3vEkMRdmW1Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">compare_models的输出(cross_validation = False)</p></figure><h1 id="8ebb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉自定义转换</h1><p id="1efc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">谈到灵活性，这是一个全垒打。一个新的参数<strong class="kf ir"> custom_pipeline </strong>被添加到setup函数中，该函数可以接受任何转换器并附加到PyCaret的预处理管道中。所有自定义变换都在train_test_split之后分别应用于每个CV折叠，以避免目标泄漏的风险。用法非常简单:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="312a" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># import dataset<br/></strong>from pycaret.datasets import get_data<br/>data = get_data('juice')</span><span id="efa6" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># build custom transformations<br/></strong>from imblearn.over_sampling import SMOTE<br/>from sklearn.decomposition import PCA<br/>custom_pp = [("PCA",PCA()),("smote", SMOTE())]</span><span id="a486" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># initialize setup<br/></strong>from pycaret.classification import *<strong class="mk ir"><br/></strong>clf = setup(data, target = 'Purchase', custom_pipeline = custom_pp)</span></pre><h1 id="f2f3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉独立的训练和测试设备</h1><p id="a3ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是期待已久的，也是自第一次发布以来最受欢迎的特性之一。现在可以通过单独的测试集，而不是依赖pycaret内部的train_test_split <strong class="kf ir">。</strong>设置中增加了一个新参数<strong class="kf ir">‘测试数据’</strong>。当一个数据帧被传入test_data时，它被用作一个测试集，并且<strong class="kf ir"> train_size </strong>参数被忽略。test_data <strong class="kf ir"> </strong>必须加标签。请参见下面的示例代码:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6d33" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># loading dataset<em class="me"><br/></em></strong>import pandas as pd<br/>train_data = pd.read_csv('/path/train.csv')<br/>test_data = pd.read_csv('/path/test.csv')</span><span id="4f39" class="mo lc iq mk b gy mt mq l mr ms"><strong class="mk ir"># initializing setup<em class="me"><br/></em></strong>from pycaret.classification import *<br/>clf = setup(data = train_data, test_data = test_data)</span></pre><h1 id="10ab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉禁用预处理</h1><p id="b0e3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果您不想使用PyCaret的默认预处理管道，或者您已经有了转换后的数据集，而只想使用PyCaret的建模功能，这在以前是不可能的，但现在我们已经为您做好了准备。只需关闭设置中的'<strong class="kf ir">预处理'</strong>参数。当预处理设置为False时，除了在<strong class="kf ir"> custom_pipeline </strong>参数中传递的train_test_split和自定义转换之外，不应用任何转换。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8b75" class="mo lc iq mk b gy mp mq l mr ms"><strong class="mk ir"># initializing setup<em class="me"><br/></em></strong>from pycaret.classification import *<br/>clf = setup(data = train_data, preprocess = False) </span></pre><p id="cbfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，当在设置中关闭预处理时，您必须确保您的数据是建模就绪的，即没有缺失值、没有日期/时间戳、分类数据被编码等。)</p><h1 id="5397" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉其他变化</h1><ul class=""><li id="c24d" class="mu mv iq kf b kg lz kk ma ko nv ks nw kw nx la mz na nb nc bi translated">在<strong class="kf ir"> plot_model </strong>中添加了新的图“提升”、“增益”和“树”。</li><li id="8c3e" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">CatBoost现在与<strong class="kf ir"> plot_model </strong>功能兼容。它需要catboost &gt; = 0.23.2。</li><li id="b76d" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated">为了使使用和开发更容易，根据最佳实践，所有更新的pycaret函数都添加了类型提示。用户可以通过使用支持类型提示的IDE来利用它们。</li></ul><p id="efa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解PyCaret 2.2中所有更新的更多信息，请参见<a class="ae kc" href="https://github.com/pycaret/pycaret/releases" rel="noopener ugc nofollow" target="_blank">发行说明</a>。</p><p id="b57b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Python中的轻量级工作流自动化库，您可以实现的目标是无限的。如果你觉得这有用，请不要忘记给我们GitHub repo 上的⭐️。</p><p id="288a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想了解更多关于PyCaret的信息，请在LinkedIn 和Youtube 上关注我们。</p><h1 id="9b6a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重要链接</h1><p id="2d3f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae kc" href="https://www.pycaret.org/guide" rel="noopener ugc nofollow" target="_blank">用户指南</a> <br/> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a> <br/> <a class="ae kc" href="https://github.com/pycaret/pycaret/tree/master/tutorials" rel="noopener ugc nofollow" target="_blank">官方教程<br/> </a> <a class="ae kc" href="https://github.com/pycaret/pycaret/tree/master/examples" rel="noopener ugc nofollow" target="_blank">示例笔记本</a> <br/> <a class="ae kc" href="https://github.com/pycaret/pycaret/tree/master/resources" rel="noopener ugc nofollow" target="_blank">其他资源</a></p><h1 id="e3e6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">想了解某个特定模块？</h1><p id="5ed0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">单击下面的链接查看文档和工作示例。</p><p id="6476" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/classification.html" rel="noopener ugc nofollow" target="_blank">分类</a> <br/> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/regression.html" rel="noopener ugc nofollow" target="_blank">回归</a> <br/> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/clustering.html" rel="noopener ugc nofollow" target="_blank">聚类</a> <br/> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/anomaly.html" rel="noopener ugc nofollow" target="_blank">异常检测</a> <br/> <a class="ae kc" href="https://pycaret.readthedocs.io/en/latest/api/nlp.html" rel="noopener ugc nofollow" target="_blank">自然语言处理<br/></a>T29】关联规则挖掘</p></div></div>    
</body>
</html>