<html>
<head>
<title>Mastering Joins: Pandas merge(), concat(), append()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握连接:Pandas merge()、concat()、append()</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/masteriadsf-246b4c16daaf?source=collection_archive---------16-----------------------#2020-10-16">https://towardsdatascience.com/masteriadsf-246b4c16daaf?source=collection_archive---------16-----------------------#2020-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d18f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">通过熊猫连接数据</h2><div class=""/><div class=""><h2 id="d75d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从半连接/反连接到验证数据合并</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5adf23958dd7b2f9597b7949257f2deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOgl-MNERBMeabRLZjmYoQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来自<a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4502863" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae lh" href="https://pixabay.com/users/danielkirsch-4218687/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4502863" rel="noopener ugc nofollow" target="_blank">丹尼尔·克什</a></p></figure><p id="78d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于每个数据科学项目或数据集，您需要执行多项分析，并创建绘图以获得真知灼见。通常，原始数据不会出现在一个巨大的表中，而是出现在许多单独的表中。要回答您的问题，您应该掌握将多个表连接成一个表，然后对它们执行操作的技能。</p><p id="b594" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以通过学习不同种类的合并操作来获得这些技能，例如内部连接、左右连接、自连接和反连接、索引合并等。</p><blockquote class="me mf mg"><p id="248f" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">本文中使用的样本数据和笔记本可以在<a class="ae lh" href="https://github.com/BexTuychiev/medium_stories/tree/master/merge_data_article" rel="noopener ugc nofollow" target="_blank"> this </a> GitHub repo中找到。</p></blockquote><div class="ml mm gp gr mn mo"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jd gy z fp mt fr fs mu fu fw jc bi translated">通过我的推荐链接加入Medium-BEXGBoost</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc lb mo"/></div></div></a></div><p id="6a69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">获得由强大的AI-Alpha信号选择和总结的最佳和最新的ML和AI论文:</p><div class="ml mm gp gr mn mo"><a href="https://alphasignal.ai/?referrer=Bex" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd jd gy z fp mt fr fs mu fu fw jc bi translated">阿尔法信号|机器学习的极品。艾总结的。</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">留在循环中，不用花无数时间浏览下一个突破；我们的算法识别…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">alphasignal.ai</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc lb mo"/></div></div></a></div></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="b458" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">设置</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="84de" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">熊猫合并()</h2><p id="a843" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">Pandas提供了几种在数据帧上执行合并的方法。在所有其他方法中，<code class="fe ok ol om on b">merge()</code>方法是最灵活的。它是一个dataframe方法，一般语法如下:</p><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="2809" class="nl nm it on b gy os ot l ou ov">df1.merge(df2, on='common_column')</span></pre><p id="9a19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当组合表格时，有两个术语您应该熟悉:您首先使用的表格的名称称为<strong class="lk jd">左表、</strong>，而另一个称为<strong class="lk jd">右表</strong>。在上面的代码片段中，左边的表是<code class="fe ok ol om on b">df1</code>，右边的表是<code class="fe ok ol om on b">df2</code>。此外，动词join、combine和merge都可以互换使用。</p><p id="ce63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们看看如何执行内部连接:</p><p id="a72b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">内部联接将只返回两个表中具有匹配值的行。在连接过程中，您必须知道两个表中的公共列名。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/ba4acd91423f4f09db635f038852e9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JvBemWFmgQ3X5q597zbpWA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片作者<a class="ae lh" href="https://medium.com/@ibexorigin" rel="noopener">作者</a></p></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="6bbb" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">基础探索</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/0c2f9368d810b72459ca931b52491b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*taA4FzZ9dUve_X2b5BhSeA.png"/></div></figure><p id="9d84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们有两张表:</p><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="0aa9" class="nl nm it on b gy os ot l ou ov">&gt;&gt;&gt; user_usage.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/76d8cc68fe0d9b923fb448c0e5e2e7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*FER5DPi2qEEBVZ6NVQ1HPw.png"/></div></figure><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="c2fd" class="nl nm it on b gy os ot l ou ov">&gt;&gt;&gt; user_devices.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/262d7fad7a7b218816613145dd45b0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*6KLybUy_A_uZFbe1G4TLew.png"/></div></figure><p id="8395" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我从<a class="ae lh" href="http://www.killbiller.com/" rel="noopener ugc nofollow" target="_blank"> KillBiller </a>应用程序下载了这些数据。KillBiller是一项免费服务，可以比较英国和爱尔兰的所有移动资费。第一个<code class="fe ok ol om on b">user_usage</code>表包含用户移动使用的月度统计数据。<code class="fe ok ol om on b">user_devices</code>表提供了每个用户手机的详细信息，如操作系统和手机型号。</p><h2 id="ff9a" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">问题1:</h2><p id="5680" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">有多少用户使用Android OS，又有多少用户使用iOS？</p><p id="2fc6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要回答这个问题，我们需要两个表中的信息。两个表之间有一个链接属性:<code class="fe ok ol om on b">use_id</code>。我们将在合并中使用此列:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/788752dc668f7a7b291ee6f7ce7a7128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*gZZ7_LcC13cGtKcy6Vy0_g.png"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="f626" class="nl nm it on b gy os ot l ou ov">Number of users for each OS: android    157<br/>                             ios          2<br/>Name: platform, dtype: int64</span></pre><p id="4955" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的数据集中，这两个操作系统之间存在巨大的差异。</p><p id="c895" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的合并中，我们使用了一个内部连接的例子。在<code class="fe ok ol om on b">merge()</code>函数中，<code class="fe ok ol om on b">how</code>参数默认设置为<code class="fe ok ol om on b">inner</code>，所以我们没有必要把它写出来。当使用<code class="fe ok ol om on b">merge()</code>函数合并两个表时，我们使用<code class="fe ok ol om on b">on</code>参数来指定公共列。如果有多个，也可以将一列列表传递给参数，剩下的由<code class="fe ok ol om on b">pandas</code>处理。</p><p id="9921" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，作为右表，我对<code class="fe ok ol om on b">user_devices</code>表进行了子集化，以排除与问题无关的列。</p><p id="eb16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，随着我们进一步探索，我们会注意到两个数据集中给定用户的数量是不同的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="d59f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两个表中匹配的用户id的数量都是159。这意味着有用户id在<code class="fe ok ol om on b">user_devices</code>表中而不在<code class="fe ok ol om on b">user_usage</code>表中，反之亦然。所以，我们想问的下一个问题是:</p><h2 id="2dc6" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">问题2</h2><p id="9042" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">有多少用户使用Android OS和iOS，包括所有不在<code class="fe ok ol om on b">user_usage</code>表中的用户？</p><p id="cb65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以用左连接<strong class="lk jd">或右连接</strong>来回答这个问题。首先，让我们看看单侧连接的一般情况:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/c4037db3bea21a36766688ad500b09c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AquabdsurS4uYZLeWJQdPA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片作者<a class="ae lh" href="https://medium.com/@ibexorigin" rel="noopener">作者</a></p></figure><p id="2f9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个<strong class="lk jd">左连接</strong>将返回所有的左表行，包括右表中的匹配行。一个<strong class="lk jd">右连接</strong>将返回所有的右表行，包括来自左表的匹配行。注意，在这两种类型的连接中，<code class="fe ok ol om on b">pandas</code>将把一个<code class="fe ok ol om on b">NaN</code>值放入没有匹配的单元格中。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/5ba88964bcdbab8fbd8f240694903aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*I4HZgZMGxHMronp66LrCvw.png"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="5864" class="nl nm it on b gy os ot l ou ov">Number of users for each OS: android    184<br/>                             ios         88<br/>Name: platform, dtype: int64</span></pre><p id="1afb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用左连接可以获得相同的结果。我们可以交换这些表，并将关键字<code class="fe ok ol om on b">left</code>传递给参数<code class="fe ok ol om on b">how</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/8124a2dbc7f43bd0065a95e35a4d027a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*lQGVCq1PGM0prU7SKGKK2w.png"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="197d" class="nl nm it on b gy os ot l ou ov">Number of users for each OS: android    184<br/>                             ios         88<br/>Name: platform, dtype: int64</span></pre><p id="0f1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用外部连接返回交集和两个表中的所有其他行:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/0610c3974295042e394637d239f79379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6pgCp9LDlq4ZkfNTqWhT7g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片作者<a class="ae lh" href="https://medium.com/@ibexorigin" rel="noopener">作者</a></p></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="f7b2" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">熊猫合并()，后缀</h2><p id="bd05" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">假设我们在两个表中都有相同名称的列。因为在我们的例子中，我们没有同名的列，所以我将把一列复制到另一列中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1f49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们在两个表中都有了<code class="fe ok ol om on b">monthly_mb</code>列。让我们看看当我们加入他们时会发生什么:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/8f9b4afd1ba77da4036263aa4f25c519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLaIs1xMKvp3XJK5_YAJdg.png"/></div></div></figure><p id="d377" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们查看列名，两个同名的列通过添加<code class="fe ok ol om on b">_x</code>和<code class="fe ok ol om on b">_y</code>后缀进行了重命名。这里，<code class="fe ok ol om on b">_x</code>为左表，<code class="fe ok ol om on b">_y</code>为右表。这是我们不指定后缀时的默认行为。我们可以很容易地控制后缀:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/aa12385fd6f427a48ba720dd1fdaccaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PuOIahGJT1TYuRit2OzVg.png"/></div></div></figure><p id="8b6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在好多了。当它们具有相同的名称时，使用这样的后缀来指示列的来源表。注意，<code class="fe ok ol om on b">suffixes</code>参数接受一个值的<strong class="lk jd">元组</strong>，而不是一个列表，并且顺序很重要！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="c850" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">熊猫合并()，左_开，右_开</h2><p id="2c89" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">还有一种情况是，您希望在一个公共列上进行联接，但是这些列有不同的名称。<code class="fe ok ol om on b">pandas</code>为这样做提供了一个方便的参数，不需要改变列名。让我们重命名<code class="fe ok ol om on b">use_id</code>列，这样我可以向您展示一个例子。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="697d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们用一个<code class="fe ok ol om on b">inner</code>连接来组合这些表:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="b992" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用merge函数的<code class="fe ok ol om on b">left_on</code>和<code class="fe ok ol om on b">right_on</code>参数来指定公共列的名称。您应该将左表中的列名传递给<code class="fe ok ol om on b">left_on</code>，反之亦然。注意，当我们使用不同命名的公共列时，<code class="fe ok ol om on b">pandas</code>会将两个列都作为副本，所以不要忘记删除其中一个:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/ca7a4118c499d55b8ccced22726d007c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STZsgz9ytnq2uvS9D4iSIA.png"/></div></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="66fd" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">熊猫合并索引</h2><p id="7d22" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">也可以在一个公共索引上进行合并。任何使用索引的连接类型的语法都是相同的。<code class="fe ok ol om on b">pandas</code>足够聪明，知道你指的是指数:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/0c267ae7f60db6297732b28bc53d9c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDwM1rGssacm1XRmzB2wUA.png"/></div></div></figure><p id="d523" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们有不同名称的索引时，事情会变得有点棘手。与列类似，我们将不得不使用<code class="fe ok ol om on b">left_on</code>和<code class="fe ok ol om on b">right_on</code>参数。此外，还有两个参数表明我们正在合并一个索引:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/749b5810083ac41bb19b088888273431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dbO7ZVGWDfUHDWYa6pvTQ.png"/></div></div></figure><p id="d605" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将<code class="fe ok ol om on b">left_index</code>和<code class="fe ok ol om on b">right_index</code>设置为<code class="fe ok ol om on b">True</code>,以表示我们正在合并索引。这也给出了重复的值:一个作为索引，一个作为列。因此，在合并时不要忘记删除列！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="ae11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您要合并的表有多级索引，那么您可以将一个索引名称列表传递给<code class="fe ok ol om on b">on</code>或<code class="fe ok ol om on b">left/right_on</code>参数，这样就完成了！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="0a56" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">熊猫把桌子连在一起</h2><p id="d491" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">在某些情况下，您可能希望将一个表连接到它自己。在下列情况下，将表与其自身联接会很有帮助:1。等级关系2。顺序关系3。图形数据</p><p id="e68b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将表连接到自身的一般情况:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/996550ed07a39b96f438b28d95d340c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fo22llDluD-IKtenxCHygQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@ibexorigin" rel="noopener">作者</a></p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e3a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，自合并有时非常有用。当使用自联接时，通常会联接同一个表的不同列。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="c1ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，我们完成的所有连接都从两个表中返回了数据。但是有时，您可能希望根据其他表上的值来筛选您的表。<code class="fe ok ol om on b">pandas</code>不直接提供此功能。但是我们可以很快地设计步骤。</p><h2 id="9c1c" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">半加盟熊猫</h2><p id="6a4c" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">当您希望根据其他表中的观察值对数据进行子集划分时，半连接非常有用。半连接:</p><p id="9c5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">1.返回两个表的交集，类似于内部联接。</p><p id="4d30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.只返回左<strong class="lk jd">表</strong>中的列，不返回右<strong class="lk jd">表</strong>中的列。</p><p id="d625" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.没有重复。</p><p id="5c07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">回到我们的小桌子上:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/9c93b926af4e82af549b95d918943658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6o8jfyWH_W8E6TG47c6n2Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片作者<a class="ae lh" href="https://medium.com/@ibexorigin" rel="noopener">作者</a></p></figure><p id="659c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如您所看到的，半连接非常类似于内部连接，但是它只包括左表中的结果。现在回到我们的示例数据，我们想知道两个表中所有用户的统计信息。但是我们不希望最终的表包含<code class="fe ok ol om on b">user_devices</code>表的列。我们可以用三个步骤来解决这个问题:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/f1fcc2572d90f310228b0ccd4b4fd634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bHMLl7amkAxMxGiv1mW39Q.png"/></div></div></figure><p id="f757" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了内部连接后，我们希望用最终表中的值对原始左表进行子集化:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="c50c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">变量<code class="fe ok ol om on b">in_both</code>现在是一个<code class="fe ok ol om on b">Boolean Series</code>，我们可以用它来子集化左边的表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/004427c85b8f6c5616516371fed663cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvuYCUbWm3UvPU021RFD_w.png"/></div></div></figure><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="0490" class="nl nm it on b gy os ot l ou ov">&gt;&gt;&gt; users_in_both.shape<br/>(159, 4)</span></pre><p id="0e1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果如我们所料。如果您将这个连接与我们所做的第一个<code class="fe ok ol om on b">inner</code>连接进行比较，它是同一个表，但是没有右边表中的列:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/fac934d8dda94c94c7ae067cfc8e09a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKQeuixMqrmvGJ4hQH-4Pg.png"/></div></div></figure><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="d345" class="nl nm it on b gy os ot l ou ov">&gt;&gt;&gt; inner.shape<br/>(159, 8)</span></pre><p id="aed7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个棘手的案子。请多重读和练习这一节，以便更好地理解它。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="74c6" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">反对加入的熊猫</h2><p id="ec5a" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">反连接与半连接完全相反。反联接:</p><p id="8b31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">1.返回左表，<strong class="lk jd">不含</strong>交叉点</p><p id="8409" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.仅返回左表中的列。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/9655e48fb577fc6c4d0ed06f5300923c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tjddozfdIUFMq0Z9OtDOw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@ibexorigin" rel="noopener">作者</a></p></figure><p id="184e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一个例子，让我们在半连接中做与上一步完全相反的事情。让我们找出所有只在<code class="fe ok ol om on b">user_usage</code>表中的用户。第一步:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/6b2f71cca3a88d6ca3265d160782f8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44Vit1LhNNX2kahpXF9i8w.png"/></div></div></figure><p id="db36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我给你介绍另一个有用的参数:<code class="fe ok ol om on b">indicator</code>。当设置为<code class="fe ok ol om on b">True</code>时，合并的结果表将有一个额外的列<code class="fe ok ol om on b">_merge</code>。它指示一行是两个表的结果还是一个表的结果。如您所见，在没有匹配的行中有一个<code class="fe ok ol om on b">left_only</code>字符串。现在，我们想对这些行进行子集划分:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="77e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我使用了<code class="fe ok ol om on b">.loc</code>子集来立即获取用户id。现在我们可以使用这个pandas <code class="fe ok ol om on b">series</code>来子集化原来的左表:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/6c97601e9600daf8f70a326f66ffd277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzQsuB6zUlSnvSMNoyeEQA.png"/></div></div></figure><pre class="ks kt ku kv gt oo on op oq aw or bi"><span id="84fe" class="nl nm it on b gy os ot l ou ov">&gt;&gt;&gt; left_only_users.shape</span><span id="eb79" class="nl nm it on b gy pl ot l ou ov">(81, 4)</span></pre><p id="2ff3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，这有点复杂，所以开始练习吧。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="1f46" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">熊猫系列()</h2><p id="976d" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">最后，我们介绍了大部分的<code class="fe ok ol om on b">merge</code>函数。现在，<code class="fe ok ol om on b">pd.concat()</code>用于沿特定轴连接/添加两个或多个表格。它还提供了一些操作轴的功能。该函数的一种常见用法是垂直添加表格。</p><h2 id="5ddd" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">数据帧的垂直连接</h2><p id="28b8" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">要垂直添加两个或更多表格，我们使用<code class="fe ok ol om on b">concat()</code>方法，将<code class="fe ok ol om on b">axis</code>参数设置为<code class="fe ok ol om on b">index</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/ff4d98ba2700761506b1c47bb8b63586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*-qHh9zhRJGoVeLkQgmCwmA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片作者<a class="ae lh" href="https://medium.com/@ibexorigin" rel="noopener">作者</a></p></figure><p id="e923" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们分三部分加载其中一个示例表:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4a17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意我是如何使用<code class="fe ok ol om on b">chunksize</code>参数的！了解这一点很有帮助，因为它在加载大型数据集时会非常有用。</p><p id="42e7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当使用<code class="fe ok ol om on b">concat()</code>函数时，我们总是传递要连接在一个列表中的表。为了指定连接轴，我们使用<code class="fe ok ol om on b">axis</code>参数。我强烈建议您将字符串值传递给<code class="fe ok ol om on b">axis</code>参数，如<code class="fe ok ol om on b">index</code>和<code class="fe ok ol om on b">columns</code>。传递0或1可能会让很多人感到困惑。因此，提高代码可读性是一个很好的实践。</p><p id="5de4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ok ol om on b">concat()</code>功能不关注轴标签。如果您的所有表中都有编号索引，那么当您进行连接时，它们将会混合在一起。因此，解决问题的一个有用参数是<code class="fe ok ol om on b">ignore_index</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/e42a99d7f9c32e828939359cfb80ad78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIl7PBD_jOuxc5twQcl9cA.png"/></div></div></figure><p id="4879" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将重置索引，它将从0计数到n-1。</p><p id="a838" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ok ol om on b">concat()</code>的另一个用例是当你有相似的表但有不同的列名时。当连接具有不同列名的表时，使用带有合适字符串<code class="fe ok ol om on b">value</code>的<code class="fe ok ol om on b">join</code>参数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/56bc57701d810648f35e47c1e2ff7359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnG6sox42g6yZ6MQyOh6xg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@ibexorigin" rel="noopener">作者</a></p></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/43239db54271ad4842693d1ea305f584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5hqRqGTVjHpncYhs82O1w.png"/></div></div></figure><p id="1177" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用带有<code class="fe ok ol om on b">inner</code>值的<code class="fe ok ol om on b">concat</code>会产生一个单列数据框架，因为它是表之间唯一的公共列。使用<code class="fe ok ol om on b">left</code>、<code class="fe ok ol om on b">right</code>或<code class="fe ok ol om on b">outer</code>会得到预期的结果，但是值是垂直堆叠的。</p><h2 id="c415" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">熊猫追加()</h2><p id="05ac" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated"><code class="fe ok ol om on b">.append()</code>方法:</p><ol class=""><li id="9fb5" class="pn po it lk b ll lm lo lp lr pp lv pq lz pr md ps pt pu pv bi translated"><code class="fe ok ol om on b">concat()</code>方法的简化版</li></ol><p id="caa3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.支持:<code class="fe ok ol om on b">ignore_index</code></p><p id="0499" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.不支持:<code class="fe ok ol om on b">join</code>等差异。</p><p id="9bee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个区别是它是一个DataFrame方法。这意味着它是在数据帧上调用的，而不是像<code class="fe ok ol om on b">pd.concat</code>那样显式调用。简单的例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="4e68" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">数据映射的类型</h2><p id="cad3" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">我们在上面看到了几种类型的连接。我们明确地告诉这些方法我们希望在每个方法中使用的连接类型，并相信它会返回正确的结果。但是，有一些方法可以确保我们得到正确的结果。要用代码完成这项任务，您必须理解合并中的四种数据映射类型:</p><ol class=""><li id="86b3" class="pn po it lk b ll lm lo lp lr pp lv pq lz pr md ps pt pu pv bi translated">一对一</li></ol><p id="3a29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.一对多</p><p id="0812" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.多对一</p><p id="7d88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">4.多对多</p><p id="c74c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们来细说一下。当我们使用一对一映射时，我们希望我们的连接应该为左侧表中的每一行返回一个且只有一个匹配。如果我们用一对一映射连接一个有200行的表，结果也应该包含200行。</p><p id="375f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，如果是一对多，我们允许左侧表中的一行有多个匹配。让我们看看如何用代码实现这个想法:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/d6d3d14f6959c6b0472dc7904d34676f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGCa36qIC099G8LwpexNdw.png"/></div></div></figure><p id="03c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ok ol om on b">merge()</code>方法为验证这类合并提供了一个有用的参数。它只接受四个值:</p><ol class=""><li id="00f5" class="pn po it lk b ll lm lo lp lr pp lv pq lz pr md ps pt pu pv bi translated"><code class="fe ok ol om on b">one_to_one</code></li></ol><p id="d97f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.<code class="fe ok ol om on b">one_to_many</code></p><p id="7944" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.<code class="fe ok ol om on b">many_to_one</code></p><p id="e137" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">4.<code class="fe ok ol om on b">many_to_many</code></p><p id="ab92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，如果我们验证不正确的映射，<code class="fe ok ol om on b">pandas</code>将引发<code class="fe ok ol om on b">MergeError</code>:</p><p id="de36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://gist.github.com/64bb2102575ffc9edf587cebbcd59605" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/64bb2102575ffc9edf587cebbcd59605</a></p><p id="7086" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，合并产生了一个错误。让我们将其设置为正确的映射:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/8aea7c84d232e23b23dfc6da5cb9ea83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YaTZ5vzuTuzd1aCtU2jRlQ.png"/></div></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="a887" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">验证串联</h2><p id="5f2b" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">使用<code class="fe ok ol om on b">.concat()</code>方法时，也可以在轴上验证。它有<code class="fe ok ol om on b">verify_integrity</code>参数，默认设置为<code class="fe ok ol om on b">False</code>。设置为True时，如果轴或列有重复名称，将引发ValueError:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h2 id="bfc3" class="nl nm it bd nn no np dn nq nr ns dp nt lr nu nv nw lv nx ny nz lz oa ob oc iz bi translated">结论</h2><p id="5386" class="pw-post-body-paragraph li lj it lk b ll of kd ln lo og kg lq lr oh lt lu lv oi lx ly lz oj mb mc md im bi translated">最后，我想在这篇文章中涵盖的事情结束了。我们讨论了很多连接数据的不同方法。信不信由你，这个主题还有更多的内容，比如<code class="fe ok ol om on b">merge_ordered()</code>和<code class="fe ok ol om on b">merge_asof()</code>方法，但是它们可能是另一篇文章的主题。</p><p id="6ce6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这恰恰说明了<code class="fe ok ol om on b">pandas</code>库的深度和广度，以及你可以用它做什么。我打算将本文作为学习组合数据的一站式平台，并希望您将在实践中使用它。</p></div></div>    
</body>
</html>