<html>
<head>
<title>Magic of the Sobel Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sobel算子的魔力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/magic-of-the-sobel-operator-bbbcb15af20d?source=collection_archive---------34-----------------------#2020-11-11">https://towardsdatascience.com/magic-of-the-sobel-operator-bbbcb15af20d?source=collection_archive---------34-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9498" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">无监督贝叶斯推理(降低维度和挖掘特征)</h2><div class=""/><div class=""><h2 id="3eb0" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用边缘的低级特征检测</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/19103f07ebadb97bcc410c1006e053d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcvxVsBw3V4AYiMPYHqjjQ.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片由朱利叶斯·德罗斯特在T2 Unsplash上拍摄</p></figure><p id="c756" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，你们一直在等待的时刻到了，这是我们无监督贝叶斯推理系列的下一步:我们对Sobel算子的深入研究。</p><p id="a3c9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一种真正神奇的边缘检测算法，它实现了低级特征提取和降维，从本质上降低了图像中的噪声。它在面部识别应用中特别有用。</p><p id="71f3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">1968年Irwin Sobel和Gary Feldman(斯坦福人工智能实验室)的爱子，该算法是许多现代边缘检测技术的灵感。通过在给定图像上卷积两个相对的核或掩模(例如，见左下)(每个都能够检测水平或垂直边缘)，我们可以创建一个噪声更小、平滑的表示(见右下)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/74c4c021f7f536f65bbfb4beab2de8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*m9XHMKQPY6mKYsaykuVAsw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片由作者提供，使用<a class="ae le" href="https://scikit-image.org/" rel="noopener ugc nofollow" target="_blank"> Scikit-Image </a>生成</p></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mc md l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://scikit-image.org/docs/dev/auto_examples/edges/plot_edge_filter.html" rel="noopener ugc nofollow" target="_blank"> Sobel算子实现</a>示例由<a class="ae le" href="https://scikit-image.org/" rel="noopener ugc nofollow" target="_blank"> SciKit-Image </a>作者修改</p></figure><p id="5319" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">作为用于图像强度函数的梯度近似计算的离散微分算子技术，用简单的英语来说，该算法通过对每个像素(锚像素)与其周围像素(基本上近似图像的导数)之间的差异进行微分来检测像素通道值(通常是亮度)的变化。</p><p id="c759" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这导致平滑原始图像并产生较低维度的输出，其中可以更清楚地看到低级几何特征。然后，这些输出可以用作更复杂的分类算法的输入，或者作为通过KLD(kull back-lei bler Divergence)进行无监督概率聚类的示例(T10)。</p><h1 id="d7b7" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">那么它是如何工作的呢？</h1><p id="fe8b" class="pw-post-body-paragraph lf lg iq lh b li mw ka lk ll mx kd ln lo my lq lr ls mz lu lv lw na ly lz ma ij bi translated">生成低维输出需要我们对图像求导。首先，我们计算x和y方向的导数。我们创建两个3×3的内核(见矩阵)，在相应轴的中心有0，在垂直于中心0的中心正方形有2，在每个角上有1。每个非零值应该在零的顶部/右侧为正(取决于轴),在相应侧为负。这些内核被命名为Gx和Gy。</p><p id="43d2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些以下列格式出现:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mc md l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者代码</p></figure><p id="cc96" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后，这些核将在我们的图像上进行卷积，将每个核的中心像素放置在图像中的每个像素上。对于每个内核，我们使用矩阵乘法来计算输出图像中新的对应像素的亮度值。因此，我们最终得到两个输出图像(每个笛卡尔方向一个)。</p><p id="7b7d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">目的是找到图像中的像素和梯度矩阵(核)(Gx和Gy)中的所有像素之间的差异/变化。更精确地说，这可以表示为。</p><h2 id="7264" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lo ng nh mq ls ni nj ms lw nk nl mu iw bi translated">旁注:</h2><p id="9615" class="pw-post-body-paragraph lf lg iq lh b li mw ka lk ll mx kd ln lo my lq lr ls mz lu lv lw na ly lz ma ij bi translated">严格来说我们没有召集任何人。虽然我们喜欢在人工智能和机器学习领域提到“卷积”，但卷积会涉及翻转原始图像。从数学上来说，当我们提到卷积时，我们实际上是在计算输入的每个3×3区域和每个像素的掩模之间的互相关。输出图像是遮罩和输入之间的总体协方差。这就是检测边缘的方法。</p><h2 id="82ec" class="nb mf iq bd mg nc nd dn mk ne nf dp mo lo ng nh mq ls ni nj ms lw nk nl mu iw bi translated">回到我们的索贝尔解释…</h2><p id="ce6a" class="pw-post-body-paragraph lf lg iq lh b li mw ka lk ll mx kd ln lo my lq lr ls mz lu lv lw na ly lz ma ij bi translated">对掩码和输入的3×3部分之间的每个矩阵乘法的计算值求和，以产生输出图像中像素的最终值。这将生成一个新图像，该图像包含原始图像中存在的垂直和水平边缘的信息。这是原始图像的几何特征表示。此外，因为该算子保证每次产生相同的输出，所以该技术允许对图像分割任务进行稳定的边缘检测。</p><p id="872f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">根据这些输出，我们可以计算任意给定像素(x，y)处的梯度幅度和梯度方向(使用反正切运算符):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mc md l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者代码</p></figure><p id="a107" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由此我们可以确定，那些具有大幅度的像素更可能是图像中的边缘，而方向通知我们关于边缘的方向(尽管方向对于生成我们的输出是不需要的)。</p><h1 id="dd0d" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">一个简单的实现:</h1><p id="2a18" class="pw-post-body-paragraph lf lg iq lh b li mw ka lk ll mx kd ln lo my lq lr ls mz lu lv lw na ly lz ma ij bi translated">下面是Sobel操作符在python中的一个简单实现(使用NumPy ),让您对这个过程有一个大致的了解(对于所有初学编码的人来说)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mc md l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者代码</p></figure><p id="dafc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">该实现是Wikipedia伪代码示例的python变体，旨在展示如何实现该算法，同时演示该过程中的各个步骤。</p><h1 id="4c4b" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">我们为什么关心？</h1><p id="60e8" class="pw-post-body-paragraph lf lg iq lh b li mw ka lk ll mx kd ln lo my lq lr ls mz lu lv lw na ly lz ma ij bi translated">尽管该算子产生的梯度近似相对粗糙，但它确实提供了一种计算图像的边缘、角和其他几何特征的极其高效的计算方法。反过来，它为许多降维和特征提取技术铺平了道路，如局部二进制模式<strong class="lh ja"> ( </strong> <a class="ae le" rel="noopener" target="_blank" href="/the-power-of-local-binary-patterns-3134178af1c7"> <strong class="lh ja">)有关这种技术的更多详细信息，请参见我的另一篇博客</strong> </a> <strong class="lh ja"> ) </strong>。</p><p id="9f0d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">仅依赖几何特征确实有在数据编码过程中丢失重要信息的风险，但是，这种权衡允许数据的快速预处理，进而允许快速训练。因此，这种技术在纹理和几何特征被认为对定义输入非常重要的情况下特别有用。这就是为什么使用Sobel算子可以以相对高的准确度完成面部识别。但是，如果试图对使用颜色作为主要区分因素的输入进行分类或分组，这种技术可能不是最佳选择。</p><p id="39e0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在使用其他分类器或用于贝叶斯推理方法之前，这种方法对于获得几何特征的低维表示以及维数和噪声减少的极好起点仍然是非常有效的。</p><h1 id="ccbf" class="me mf iq bd mg mh mi mj mk ml mm mn mo kf mp kg mq ki mr kj ms kl mt km mu mv bi translated">参考资料:</h1><p id="ca53" class="pw-post-body-paragraph lf lg iq lh b li mw ka lk ll mx kd ln lo my lq lr ls mz lu lv lw na ly lz ma ij bi translated">[1] D. Kroon，2009，短文大学特文特，基于核的图像导数的数值优化。</p><p id="928f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://en.wikipedia.org/wiki/Sobel_operator" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Sobel_operator</a></p></div></div>    
</body>
</html>