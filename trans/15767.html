<html>
<head>
<title>A Python script to sort DICOM files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对DICOM文件进行排序的Python脚本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-python-script-to-sort-dicom-files-f1623a7f40b8?source=collection_archive---------12-----------------------#2020-10-30">https://towardsdatascience.com/a-python-script-to-sort-dicom-files-f1623a7f40b8?source=collection_archive---------12-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4caf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这个脚本将帮助您理解和组织您的医学图像数据集</h2></div><p id="979f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章是我之前介绍DICOM文件的后续文章。特别感谢我的好朋友吉安·马可·康特博士帮助我写这篇文章。</p><p id="79c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单回顾一下，DICOM文件是存储医学图像的主要格式。所有临床算法必须能够读写DICOM。但是这些文件很难组织。DICOM文件在文件头中保存了与图像相关的信息，文件头可能很大。文件分为4层:</p><ol class=""><li id="4b98" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">病人</li><li id="1a96" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">研究</li><li id="68fd" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">系列</li><li id="5670" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">情况</li></ol><p id="e816" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我将分享一些python代码，这些代码读取一组DICOM文件，提取标题信息，并将文件复制到分层的文件夹结构中，以便轻松加载数据科学任务。</p><p id="3383" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多很好的资源可以用来使用Python或其他语言解析DICOM。<a class="ae lp" href="https://dicomsort.com/documentation.html" rel="noopener ugc nofollow" target="_blank"> DicomSort </a>有一个灵活的GUI，可以根据文件头中的任何字段来组织文件(DicomSort也可以作为一个带有“pip install dicomsort”的Python包获得)。我还想感谢<a class="ae lp" href="https://gist.github.com/somada141/8dd67a02e330a657cf9e" rel="noopener ugc nofollow" target="_blank">这个报告</a>让我开始阅读DICOM像素数据集的代码。最后，<a class="ae lp" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3354356/" rel="noopener ugc nofollow" target="_blank">这篇伟大的论文</a>中有一节是关于图像压缩的，我在这里简单地提一下。</p><p id="2302" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，我决定编写自己的实用程序，因为我喜欢确切地知道我的代码在做什么，它还提供了对DICOM头的介绍，这是任何从事医学成像项目的数据科学家的基本知识。</p><p id="e02b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经为CT和MRI检查验证了这个代码；它应该适用于任何设备——所有DICOM文件都会报告患者、研究和系列信息。</p><h2 id="039f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated"><strong class="ak">所需的代码包</strong></h2><p id="0e75" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这段代码使用Python包<a class="ae lp" href="https://pydicom.github.io/" rel="noopener ugc nofollow" target="_blank"> PyDicom </a>来读写Dicom文件。</p><p id="0d39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想简单提一下<a class="ae lp" href="http://gdcm.sourceforge.net/wiki/index.php/Main_Page" rel="noopener ugc nofollow" target="_blank"> GDCM包</a>。DICOM文件可能在存储期间或通过DICOM接收器传输期间进行图像压缩。例如，在我们的机构，所有的DICOMs都有JPEG2000压缩。GDCM是一个基于C的包，允许PyDicom读取这些加密文件。它以conda包(“conda install gdcm”)的形式提供，或者使用cmake从源代码构建。我在下面的代码中偷偷添加了几行代码，使用GDCM来解压缩像素数据，这样我以后就不用担心了。</p><p id="c49a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">更新——自从写了这篇文章，我开始使用比GDCM更容易安装的</em><a class="ae lp" href="https://github.com/pydicom/pylibjpeg" rel="noopener ugc nofollow" target="_blank"><em class="mo">pylibjpeg</em></a><em class="mo">包。我在文章末尾补充了更多的信息。</em></p><h2 id="8696" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated"><strong class="ak">代码演练</strong></h2><p id="43ac" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">完整的、不间断的代码版本在本文末尾。</p><p id="cb15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们指定哪个目录包含我们的DICOM文件(“src”)，以及它们将被复制到哪里(“dst”)。请注意，该文件是复制的，而不是移动的，因此我们最终将存储每个文件的2个副本。我们将不分先后地阅读DICOM文件——每个文件在文件头中都包含足够的信息，可以准确地识别它来自哪里。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c39d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于列表中的每个文件，我们将使用PyDicom包将文件头作为字典加载。</p><p id="ddd7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在<em class="mo">患者</em>、<em class="mo">研究</em>和<em class="mo">系列</em>级别对DICOM文件进行分类(有关这些术语含义的更多信息，我鼓励您通读我的<a class="ae lp" rel="noopener" target="_blank" href="/understanding-dicom-bce665e62b72">之前的介绍</a>)。我还添加了一个额外的级别，即<em class="mo">研究日期</em>，如果您希望对同一患者进行多项研究，这将是非常有用的信息。</p><p id="e7ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个字段分别与<em class="mo">患者</em>、<em class="mo">研究</em>和<em class="mo">系列</em>相关联:一个<em class="mo">唯一标识符(UID) </em>和一个<em class="mo">文本描述</em>。您将看到的大多数DICOM数据集都是使用uid排序的。尽管uid总是唯一的，但是它们会导致很长的文件夹树，不容易理解。我已选择将每个文件保存在<em class="mo">文本描述</em>下，同时保留<em class="mo">患者ID </em>以提供一层匿名性(尽管患者姓名仍将出现在标题中)。</p><p id="e614" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在几个数据集上使用这段代码，我还没有遇到过<em class="mo">病历报告</em>或<em class="mo">系列</em>信息丢失的情况，但是在极小的可能性下，我们会用“NA”替换它。</p><p id="5ee9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我将包含一个小函数，用于清理“禁止”字符的文本描述，删除空格，并将文本转换为小写，这使得目录名更加清晰。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="657b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文件名将由<em class="mo">设备</em> (CT、MRI等)连接而成。)、<em class="mo">系列UID </em>和<em class="mo">实例号</em>。我将包含<em class="mo">研究UID </em>，但是这会产生一个很长的文件名。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5743" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我将删除任何JPEG2000或任何其他文件压缩。这是使用GDCM包完成的，它是一个可选的包，可以安装在PyDicom的下面。这不是100%万无一失的(像DICOM的大部分内容一样)，因此我的新手尝试/例外语句:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="54d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脚本的其余部分创建了我们的分层文件夹树。同样，我增加了一个额外的按研究日期排序的级别。否则，可能很难区分我们单独的病历报告，并且如果两份病历报告有相同的描述，所有系列将被集中在一个文件夹中。</p><h2 id="ac1e" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated"><strong class="ak">使用数据集上的代码</strong></h2><p id="c168" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">为了测试这段代码，让我们在数据集上运行它。我选择了2019年RSNA·卡格尔比赛，该比赛以诊断颅内出血的头部CT为特色。</p><p id="a466" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，所有的文件都保存在一个目录中，这也是数据最初可用的方式。让我们看看这个脚本是否能帮助我们组织它:</p><div class="mp mq mr ms gt ab cb"><figure class="mw mt mx my mz na nb paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><img src="../Images/a1a47f91862bd214c60d379983e9dd39.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*CCdb64auScOD5baxngRinQ.png"/></div></figure><figure class="mw mt ni my mz na nb paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><img src="../Images/3a8523b7e3aba7b720476770c6334b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*Dud6avDsEj8XYeQNhBl5zw.png"/></div><p class="nj nk gj gh gi nl nm bd b be z dk nn di no np translated">图一。该代码按照患者、日期、研究描述和系列描述(右)将我们的非结构化DICOM文件列表(左)解析为嵌套的文件夹结构。文件也根据设备、系列UID和实例号进行重命名。图片作者。</p></figure></div><p id="d5e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然文件列表很长，我们只能看到最上面的文件夹，但是请注意，文件已经按照<em class="mo">患者ID </em>(已被取消识别)<em class="mo">扫描日期</em>、以及<em class="mo">系列</em>和<em class="mo">研究</em>描述进行了分类，这些描述告诉我们一些关于我们正在查看的图像的信息。此外，这些文件已被重命名为<em class="mo">模态</em>、<em class="mo">系列UID </em>和<em class="mo">实例号</em>，以便于按行排序。</p><h2 id="3146" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">完整代码</h2><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="37a9" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">更新—用于文件压缩的新软件包</h2><p id="414a" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">自从写了这篇文章，我遇到了比我上面提到的GDCM包更容易安装和配置的pylibjpeg包。</p><p id="e5bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pylibjpeg有几个依赖项，下面是我从我的<em class="mo"> requirements.txt </em>中复制的列表</p><pre class="mp mq mr ms gt nq nr ns nt aw nu bi"><span id="237e" class="lq lr iq nr b gy nv nw l nx ny">pylibjpeg<br/>pylibjpeg-openjpeg<br/>pylibjpeg-libjpeg<br/>pydicom</span></pre></div></div>    
</body>
</html>