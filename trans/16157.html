<html>
<head>
<title>Packaging in Python: Tools and Formats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的打包:工具和格式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/packaging-in-python-tools-and-formats-743ead5f39ee?source=collection_archive---------5-----------------------#2020-11-07">https://towardsdatascience.com/packaging-in-python-tools-and-formats-743ead5f39ee?source=collection_archive---------5-----------------------#2020-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b671" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">9个问题的16种解决方案——你知道哪些？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8d1c8d5746ad77ab660bddb6ca12635b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0xw0ShpAuuxmT9R7aSHfQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建</p></figure><p id="79f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di"/>虚拟环境是一个隔离的Python环境。它有自己安装的<code class="fe md me mf mg b">site-packages</code>，可以不同于系统<code class="fe md me mf mg b">site-packages</code>。别担心，我们稍后会更详细地讨论。</p><p id="6a32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看完这篇文章，你就明白下面这些工具是什么了，它们解决了哪些问题:pip，pyenv，venv，virtualenv，pipx，pipenv，pip-tools，setup.py，requirements.txt，requirementst.in，Pipfile，Pipfile.lock，twine，poem，flint，hatch。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="feab" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">包装类型</h1><p id="8549" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">对于本文，您需要区分两种类型的(打包)代码:</p><ul class=""><li id="8130" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><strong class="la iu">库</strong>由其他库或应用程序<strong class="la iu">导入</strong>。库不会自己运行；它们总是由应用程序运行。Python中库的例子有Numpy，SciPy，Pandas，Flask，Django，<a class="ae nu" href="https://pypi.org/project/click/" rel="noopener ugc nofollow" target="_blank">点击</a>，</li><li id="2edd" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">应用</strong>被<strong class="la iu">执行</strong>。Python应用的例子有<a class="ae nu" href="https://pypi.org/project/awscli/" rel="noopener ugc nofollow" target="_blank"> awscli </a>、<a class="ae nu" href="https://pypi.org/project/jupyter/" rel="noopener ugc nofollow" target="_blank"> Jupyter </a>(笔记本)、任何用<a class="ae nu" href="https://pypi.org/project/Flask/" rel="noopener ugc nofollow" target="_blank"> Flask </a>或<a class="ae nu" href="https://pypi.org/project/Django/" rel="noopener ugc nofollow" target="_blank"> Django </a>创建的网站。</li></ul><p id="e1d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以进一步区分它们，例如库和框架。或者命令行应用程序、具有图形用户界面的应用程序、服务等等。但是对于本文，我们只需要区分库和应用程序。</p><p id="ed05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，有些应用程序还包含可以导入的代码，或者有些库具有作为应用程序提供的部分功能。在这些情况下，您可以将它们用作库(包括项目中的代码)或应用程序(只是执行它们)。你是指挥官。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="e350" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">基础知识:pip、站点包和提示符</h1><p id="2b70" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Python将<code class="fe md me mf mg b">pip</code>作为默认的包管理器。你像这样使用它:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="024b" class="oe mp it mg b gy of og l oh oi">pip install mpu</span></pre><p id="32b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您运行它时，您应该会看到以下消息:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="b608" class="oe mp it mg b gy of og l oh oi">Collecting mpu<br/>  Using cached <a class="ae nu" href="https://files.pythonhosted.org/packages/a6/3a/c4c04201c9cd8c5845f85915d644cb14b16200680e5fa424af01c411e140/mpu-0.23.1-py3-none-any.whl" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/a6/3a/c4c04201c9cd8c5845f85915d644cb14b16200680e5fa424af01c411e140/mpu-0.23.1-py3-none-any.whl</a><br/>Installing collected packages: mpu<br/>Successfully installed mpu-0.23.1</span></pre><p id="0393" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了能够向您展示输出和我插入的内容，我开始了包含我用<code class="fe md me mf mg b">$</code>输入的命令的行:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="3187" class="oe mp it mg b gy of og l oh oi">$ pip install mpu<br/>Collecting mpu<br/>  Using cached <a class="ae nu" href="https://files.pythonhosted.org/packages/a6/3a/c4c04201c9cd8c5845f85915d644cb14b16200680e5fa424af01c411e140/mpu-0.23.1-py3-none-any.whl" rel="noopener ugc nofollow" target="_blank">https://files.pythonhosted.org/packages/a6/3a/c4c04201c9cd8c5845f85915d644cb14b16200680e5fa424af01c411e140/mpu-0.23.1-py3-none-any.whl</a><br/>Installing collected packages: mpu<br/>Successfully installed mpu-0.23.1</span></pre><p id="6a1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe md me mf mg b">$</code>叫做<strong class="la iu">提示</strong>。在Python内部，提示是<code class="fe md me mf mg b">&gt;&gt;&gt;</code>:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="4e8a" class="oe mp it mg b gy of og l oh oi">$ python<br/>&gt;&gt;&gt; import mpu<br/>&gt;&gt;&gt; mpu.__file__<br/>'/home/moose/venv/lib/python3.7/site-packages/mpu/__init__.py'</span></pre><p id="e6f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个命令显示了软件包<code class="fe md me mf mg b">mpu</code>的安装位置。默认情况下，这是系统的Python位置。这意味着所有Python包共享同一套已安装的库。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="03a4" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题1:需要不同的Python版本</h1><p id="4ee1" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">我们安装了Python 3.6，但是应用程序需要Python 3.8。我们无法升级我们的系统Python版本，例如，因为我们缺少管理员权限，或者因为其他东西会损坏。</p><h1 id="eb63" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:pyenv</h1><p id="c3f2" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><a class="ae nu" href="https://github.com/pyenv/pyenv" rel="noopener ugc nofollow" target="_blank"> Pyenv </a>允许你安装任何你想要的Python版本。您还可以使用<code class="fe md me mf mg b">pyenv</code>在Python环境之间轻松切换:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="3fd4" class="oe mp it mg b gy of og l oh oi">$ python --version<br/>Python 3.6.0</span><span id="f23c" class="oe mp it mg b gy oo og l oh oi">$ pyenv global 3.8.6</span><span id="bd29" class="oe mp it mg b gy oo og l oh oi">$ python --version<br/>Python 3.8.6</span><span id="1c46" class="oe mp it mg b gy oo og l oh oi">$ pip --version<br/>pip 20.2.1 from /home/math/.pyenv/versions/3.8.6/lib/python3.8/site-packages/pip (python 3.8)</span></pre><p id="1669" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更多信息，请阅读我的文章<a class="ae nu" href="https://medium.com/python-in-plain-english/a-beginners-guide-to-python-development-on-windows-10-e9d80601f483" rel="noopener">Python开发初学者指南</a>。详细安装说明，直接去【pyenv官方网站。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="ce8f" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题2:包装和配送大楼</h1><p id="8248" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">你通常不仅仅使用裸Python。作为开发者，我们站在巨人的肩膀上——整个免费软件生态系统。在Python的初期，人们只是复制文件。Python文件在导入时也称为<strong class="la iu">模块</strong>。如果我们在一个带有<code class="fe md me mf mg b">__init__.py</code>的文件夹中有多个Python文件，它们可以互相导入。这个文件夹被称为<strong class="la iu">包</strong>。包可以包含其他包——也有<code class="fe md me mf mg b">__init__.py</code>的子文件夹，然后被称为<strong class="la iu">子包</strong>。</p><p id="4c27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">复制文件和文件夹不方便。如果该代码的作者进行了更新，我可能需要更新几十个文件。我需要在第一时间知道是否有更新。我可能还需要安装数百个依赖项。通过复制粘贴来做这件事将是地狱。</p><p id="1e57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要一种更方便的方式来分发这些包。</p><h1 id="2235" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:来源分配</h1><p id="aec3" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">包装系统需要三个核心组件:</p><ul class=""><li id="4e81" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><strong class="la iu">包格式</strong>:Python中最简单的格式叫做<em class="op">源码分发</em>。它本质上是一个具有特定结构的ZIP文件。该文件的一个重要部分是可以指定包的依赖关系。它还应该包含其他元数据，比如包的名称、作者和许可信息。</li><li id="c77b" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">软件包管理器</strong>:安装软件包的程序。pip在Python中安装包。</li><li id="fdf4" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">软件仓库</strong>:包管理者可以寻找包的中心位置。在Python生态系统中，<a class="ae nu" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank">pypi.org</a>是公共的。我甚至不知道还有其他公开的。当然，您可以创建私有的。</li></ul><p id="1f98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，我们需要一种方法来指定元数据和依赖关系。这是通过<code class="fe md me mf mg b">setup.py</code>文件完成的。它通常看起来像这样:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="89ef" class="oe mp it mg b gy of og l oh oi">from setuptools import setup</span><span id="3fef" class="oe mp it mg b gy oo og l oh oi">setup(<br/>    name="my_awesome_package",<br/>    version="0.1.0",<br/>    install_requires=["requests", "click"]<br/>)</span></pre><p id="dd96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用更多的<a class="ae nu" href="https://www.python.org/dev/peps/pep-0440/#version-specifiers" rel="noopener ugc nofollow" target="_blank">版本说明符</a>，例如:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="326f" class="oe mp it mg b gy of og l oh oi">numpy&gt;3.0.0  # 3.0.1 is acceptable, but not 3.0.0<br/>numpy~=3.1   # 3.1 or later, but not version 4.0 or later.<br/>numpy~=3.1.2 # 3.1.2 or later, but not version 3.2.0 or later.</span></pre><p id="6b99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了创建源分布，我们运行</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="9dc6" class="oe mp it mg b gy of og l oh oi">$ python setup.py sdist</span></pre><p id="b55f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不太喜欢<code class="fe md me mf mg b">setup.py</code>文件，因为它是代码。对于元数据，我更喜欢使用配置文件。Setuptools允许使用一个<code class="fe md me mf mg b">setup.cfg</code>文件。您仍然需要一个setup.py，但它可以简化为:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="1af0" class="oe mp it mg b gy of og l oh oi">from setuptools import setup</span><span id="5cfe" class="oe mp it mg b gy oo og l oh oi">setup()</span></pre><p id="b353" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后你就有了如下的<code class="fe md me mf mg b">setup.cfg</code>文件。有关于<a class="ae nu" href="https://setuptools.readthedocs.io/en/latest/setuptools.html#configuring-setup-using-setup-cfg-files" rel="noopener ugc nofollow" target="_blank"> setup.cfg </a>格式的文档。</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="b52c" class="oe mp it mg b gy of og l oh oi">[metadata]<br/>name = my_awesome_package</span><span id="15ef" class="oe mp it mg b gy oo og l oh oi">author = Martin Thoma<br/>author_email = <a class="ae nu" href="mailto:info@martin-thoma.de" rel="noopener ugc nofollow" target="_blank">info@martin-thoma.de</a><br/>maintainer = Martin Thoma<br/>maintainer_email = <a class="ae nu" href="mailto:info@martin-thoma.de" rel="noopener ugc nofollow" target="_blank">info@martin-thoma.de</a></span><span id="db9a" class="oe mp it mg b gy oo og l oh oi"># keep in sync with my_awesome_package/__init__.py<br/>version = 0.23.1</span><span id="b28e" class="oe mp it mg b gy oo og l oh oi">description = Martins Python Utilities<br/>long_description = file: README.md<br/>long_description_content_type = text/markdown<br/>keywords = utility,</span><span id="697b" class="oe mp it mg b gy oo og l oh oi">platforms = Linux</span><span id="2474" class="oe mp it mg b gy oo og l oh oi">url = <a class="ae nu" href="https://github.com/MartinThoma/mpu" rel="noopener ugc nofollow" target="_blank">https://github.com/MartinThoma/mpu</a><br/>download_url = <a class="ae nu" href="https://github.com/MartinThoma/mpu" rel="noopener ugc nofollow" target="_blank">https://github.com/MartinThoma/mpu</a></span><span id="28e5" class="oe mp it mg b gy oo og l oh oi">license = MIT</span><span id="a65b" class="oe mp it mg b gy oo og l oh oi"># <a class="ae nu" href="https://pypi.org/pypi?%3Aaction=list_classifiers" rel="noopener ugc nofollow" target="_blank">https://pypi.org/pypi?%3Aaction=list_classifiers</a><br/>classifiers =<br/>    Development Status :: 3 - Alpha<br/>    Environment :: Console<br/>    Intended Audience :: Developers<br/>    Intended Audience :: Information Technology<br/>    License :: OSI Approved :: MIT License<br/>    Natural Language :: English<br/>    Operating System :: OS Independent<br/>    Programming Language :: Python :: 3.7<br/>    Programming Language :: Python :: 3.8<br/>    Programming Language :: Python :: 3.9<br/>    Topic :: Software Development<br/>    Topic :: Utilities</span><span id="cc1b" class="oe mp it mg b gy oo og l oh oi">[options]<br/>packages = find:<br/>python_requires = &gt;=3.7<br/>install_requires = <br/>    requests<br/>    click</span><span id="9bb7" class="oe mp it mg b gy oo og l oh oi">[tool:pytest]<br/>addopts = --doctest-modules --ignore=docs/ --durations=3 --timeout=30<br/>doctest_encoding = utf-8</span><span id="6e3c" class="oe mp it mg b gy oo og l oh oi">[pydocstyle]<br/>match_dir = mpu<br/>ignore = D105, D413, D107, D416, D212, D203, D417</span><span id="029c" class="oe mp it mg b gy oo og l oh oi">[flake8]<br/>max-complexity=10<br/>max_line_length = 88<br/>exclude = tests/*,.tox/*,.nox/*,docs/*<br/>ignore = H301,H306,H404,H405,W503,D105,D413,D103</span><span id="c7a6" class="oe mp it mg b gy oo og l oh oi">[mutmut]<br/>backup = False<br/>runner = python -m pytest<br/>tests_dir = tests/</span><span id="7398" class="oe mp it mg b gy oo og l oh oi">[mypy]<br/>ignore_missing_imports = True</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="9f4f" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题3:安全上传</h1><p id="4483" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">您希望将包安全地上传到PyPI。你需要认证，你想确定没有人篡改你的包。</p><h1 id="8adb" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:缠绕</h1><p id="1ee5" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">通过<code class="fe md me mf mg b">pip install twine</code>安装<a class="ae nu" href="https://pypi.org/project/twine/" rel="noopener ugc nofollow" target="_blank">绳</a>，您可以上传您的分发文件:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="b174" class="oe mp it mg b gy of og l oh oi">twine upload dist/*</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="6b0f" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题4:依赖冲突</h1><p id="ebf9" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">你想在版本<code class="fe md me mf mg b">1.2.3</code>中安装需要库<code class="fe md me mf mg b">requests</code>的<code class="fe md me mf mg b">youtube-downloader</code>，在版本<code class="fe md me mf mg b">3.2.1</code>中安装需要库<code class="fe md me mf mg b">requests</code>的<code class="fe md me mf mg b">vimeo-downloader</code>。因此库<code class="fe md me mf mg b">requests</code>是两个应用程序的依赖项。这两个应用程序都需要用Python 3.8来执行。这是一个问题，因为两个应用程序都将<code class="fe md me mf mg b">requests</code>存储在同一个<code class="fe md me mf mg b">site-packages</code>目录中。一旦你安装了一个版本，另一个就没了。您需要两个不同的环境来运行这两个应用程序。</p><blockquote class="oq"><p id="7148" class="or os it bd ot ou ov ow ox oy oz lt dk translated">python环境是Python可执行文件、pip和一组已安装的软件包。不同的环境是相互隔离的，因此不会相互影响。</p></blockquote><p id="d759" class="pw-post-body-paragraph ky kz it la b lb pa ju ld le pb jx lg lh pc lj lk ll pd ln lo lp pe lr ls lt im bi translated">我们通过创建虚拟环境来解决这种依赖性冲突。我们称之为<em class="op">虚拟</em>，因为它们实际上共享Python可执行文件和其他东西，比如shells的环境变量。</p><h1 id="606e" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:venv</h1><p id="66b8" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Python有<a class="ae nu" href="https://docs.python.org/3/library/venv.html" rel="noopener ugc nofollow" target="_blank"> venv模块</a>,碰巧也是可执行的。您可以创建和使用一个全新的虚拟环境，如下所示:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="a178" class="oe mp it mg b gy of og l oh oi">$ python -m venv my-fresh-venv<br/>$ source my-fresh-venv/bin/activate</span><span id="47dc" class="oe mp it mg b gy oo og l oh oi">(my-fresh-venv)$ pip --version<br/>pip 20.1.1 from /home/moose/my-fresh-venv/lib/python3.8/site-packages/pip (python 3.8)</span></pre><p id="3fe8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">环境之所以被称为“新鲜”，是因为里面什么都没有。在<code class="fe md me mf mg b">source</code>-调用<code class="fe md me mf mg b">activate</code>脚本后安装的所有东西都将被安装在这个本地目录中。这意味着当你在一个这样的虚拟环境中安装<code class="fe md me mf mg b">youtube-downloader</code>而在另一个虚拟环境中安装<code class="fe md me mf mg b">vimeo-downloader</code>时，你可以同时拥有两者。你可以通过执行<code class="fe md me mf mg b">deactivate</code>走出虚拟环境。</p><p id="4d6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多细节，我推荐你阅读<a class="ae nu" href="https://realpython.com/python-virtual-environments-a-primer/" rel="noopener ugc nofollow" target="_blank"> Python虚拟环境:初级读本</a>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="458f" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题5:不方便</h1><p id="4809" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">您仍然需要一直在虚拟环境之间切换，这很不方便。</p><h1 id="ac47" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:pipx</h1><p id="e85f" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><a class="ae nu" href="https://github.com/pipxproject/pipx" rel="noopener ugc nofollow" target="_blank"> pipx </a>自动将软件包安装到它们自己的虚拟环境中。它还会自动执行该环境中的应用程序😍</p><p id="4e58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:这只对应用有意义！您需要在与应用程序相同的环境中使用库。所以永远不要用pipx安装库。用pipx安装应用程序(间接安装库)。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="67cb" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题6:更改第三方代码</h1><p id="f882" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">作为一名应用程序开发人员，我想确保我的应用程序能够正常工作。我想独立于我使用的第三方软件的潜在突破性变化。</p><p id="7033" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比如，想想1.2.3版本中需要<code class="fe md me mf mg b">requests</code>的<code class="fe md me mf mg b">youtube-downloader</code>。在某些时候，可能是在开发期间，那个版本的请求可能是最新的版本。然后<code class="fe md me mf mg b">youtube-downloader</code>的开发就停止了，但是<code class="fe md me mf mg b">requests</code>一直在改。</p><h1 id="bfbd" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:依赖固定</h1><p id="c347" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">给出您想要安装的确切版本:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="b21f" class="oe mp it mg b gy of og l oh oi">numpy==3.2.1<br/>scipy==1.2.3<br/>pandas==4.5.6</span></pre><p id="7b31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果你在<code class="fe md me mf mg b">setup.py</code>中这样做，这本身就有一个问题。您将在相同环境中的其他软件包上强制使用这个版本。Python在这里相当混乱:一旦另一个包在同一环境的另一个版本中安装了您的一个依赖项，它就会被简单地覆盖。您的依赖项可能仍然有效，但是您没有得到预期的版本。</p><p id="fd55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于应用程序，您可以像这样将依赖项固定在<code class="fe md me mf mg b">setup.py</code>中，并告诉您的用户使用<code class="fe md me mf mg b">pipx</code>来安装它们。这样你和你的用户都会很开心💕</p><p id="6ef0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于库，您不能这样做。根据定义，库包含在其他代码中。可能包含大量库的代码。如果它们都固定了它们的依赖关系，那么很可能会出现依赖冲突。如果开发的库本身有几个依赖项，这会使库开发变得困难。</p><p id="9122" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常的做法是不在<code class="fe md me mf mg b">setup.py</code>文件中固定依赖关系，而是创建一个带有固定依赖关系的平面文本文件。<a class="ae nu" href="https://www.python.org/dev/peps/pep-0440/" rel="noopener ugc nofollow" target="_blank"> PEP 440 </a>在2013年定义了格式或要求文件。它通常被称为<code class="fe md me mf mg b">requirements.txt</code>或<code class="fe md me mf mg b">requirements-dev.txt</code>，通常看起来像这样:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="8d90" class="oe mp it mg b gy of og l oh oi">numpy==3.2.1<br/>scipy==1.2.3<br/>pandas==4.5.6</span></pre><p id="0022" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以根据PEP 440指定下载包的位置(例如，不仅是名称，还有git存储库)。</p><p id="c524" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">requirements.txt中的包(包括它们的依赖项)可以与</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="156f" class="oe mp it mg b gy of og l oh oi">$ pip install -r requirements.txt</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3080" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题7:改变传递依赖关系</h1><p id="d92a" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">想象你写的代码依赖于包<code class="fe md me mf mg b">foo</code>和<code class="fe md me mf mg b">bar</code>。这两个包本身也可能有依赖关系。这些依赖被称为代码的<em class="op">传递</em>依赖。它们是间接依赖关系。你需要关心的原因如下。</p><p id="a07e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设发布了多个版本的<code class="fe md me mf mg b">foo</code>和<code class="fe md me mf mg b">bar</code>。<code class="fe md me mf mg b">foo</code>和<code class="fe md me mf mg b">bar</code>恰好都有一个依赖关系:<code class="fe md me mf mg b">fizz</code></p><p id="e9b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">情况是这样的:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="966c" class="oe mp it mg b gy of og l oh oi">foo 1.0.0 requires fizz==1.0.0<br/>foo 1.2.0 requires fizz&gt;=1.5.0, fizz&lt;2.0.0<br/>foo 2.0.0 requires fizz&gt;=1.5.0, fizz&lt;3.0.0</span><span id="28db" class="oe mp it mg b gy oo og l oh oi">bar 1.0.0 requires fizz&gt;2.0.0<br/>bar 1.0.1 requires fizz==3.0.0</span><span id="3df4" class="oe mp it mg b gy oo og l oh oi">fizz 1.0.0 is available<br/>fizz 1.2.0 is available<br/>fizz 1.5.0 is available<br/>fizz 2.0.0 is available<br/>fizz 2.0.1 is available<br/>fizz 3.0.0 is available</span></pre><p id="390e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能想说“我需要<code class="fe md me mf mg b">foo==2.0.0</code>和<code class="fe md me mf mg b">bar==1.0.0</code>。有两个问题:</p><ol class=""><li id="8d0e" class="nl nm it la b lb lc le lf lh nn ll no lp np lt pf nr ns nt bi translated"><strong class="la iu">依赖满足可能很难</strong>:客户需要弄清楚这两个需求只能由<code class="fe md me mf mg b">fizz==2.0.0</code>或<code class="fe md me mf mg b">fizz==2.0.1</code>来满足。这可能很耗时，因为Python源代码发行版没有很好地设计，也没有很好地公开这些信息(<a class="ae nu" href="https://github.com/python-poetry/poetry/issues/2094" rel="noopener ugc nofollow" target="_blank">示例讨论</a>)。依赖关系解析器实际上需要下载包来找到依赖关系。</li><li id="4930" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt pf nr ns nt bi translated"><strong class="la iu">中断传递性变更</strong>:包foo和bar无法声明它们的依赖关系。你安装了它们，事情就正常了，因为你碰巧有<code class="fe md me mf mg b">foo==2.0.0</code>、<code class="fe md me mf mg b">bar==1.0.0</code>、<code class="fe md me mf mg b">fizz==2.0.1</code>。但是过了一会儿，<code class="fe md me mf mg b">fizz==3.0.0</code>就放出来了。不用告诉<code class="fe md me mf mg b">pip</code>要安装什么，它就会安装最新版本的<code class="fe md me mf mg b">fizz</code>。之前没有人测试过，因为它不存在。你的用户是第一个，这对他们来说是坏消息😢</li></ol><h1 id="d8d6" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:固定传递依赖关系</h1><p id="455a" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">您还需要找出可传递的依赖关系，并准确地告诉pip要安装什么。为此，我从一个<code class="fe md me mf mg b">setup.py</code>或<code class="fe md me mf mg b">requirements.in</code>文件开始。<code class="fe md me mf mg b">requirements.in</code>文件包含了我所知道的必须实现的内容——它与setup.py文件非常相似。与<code class="fe md me mf mg b">setup.py</code>文件不同，它是一个平面文本文件。</p><p id="4a0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我使用<a class="ae nu" href="https://pypi.org/project/pip-tools/" rel="noopener ugc nofollow" target="_blank"> pip-tools </a>中的<code class="fe md me mf mg b">pip-compile</code>来寻找传递依赖关系。它将生成如下所示的<code class="fe md me mf mg b">requirements.txt</code>文件:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="a396" class="oe mp it mg b gy of og l oh oi">#<br/># This file is autogenerated by pip-compile<br/># To update, run:<br/>#<br/>#    pip-compile setup.py<br/>#<br/>foo==2.0.0   # via setup.py<br/>bar==1.0.0   # via setup.py<br/>fizz==2.0.1  # via foo, bar</span></pre><p id="15d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常情况下，我有以下内容:</p><ul class=""><li id="a954" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><strong class="la iu"> setup.py </strong>:定义抽象依赖和已知的最低版本/最高版本。</li><li id="034a" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu"> requirements.txt </strong>:我知道的一个版本组合<a class="ae nu" href="https://blog.codinghorror.com/the-works-on-my-machine-certification-program/" rel="noopener ugc nofollow" target="_blank">在我的机器</a>上工作。对于我控制安装的web服务，这也用于通过<code class="fe md me mf mg b">pip install -r requirements.txt</code>安装依赖项</li><li id="5c0f" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">需求-开发在</strong>中:我使用的开发工具。pytest、flake8、flake8插件、mypy、black之类的东西……看我的<a class="ae nu" rel="noopener" target="_blank" href="/static-code-analysis-for-python-bdce10b8d287">静态代码分析贴</a>。</li><li id="529f" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu"> requirements-dev.txt </strong>:我使用的工具的确切版本+它们的传递依赖。这些也安装在<a class="ae nu" href="https://levelup.gitconnected.com/ci-pipelines-for-python-projects-9ac2830d2e38" rel="noopener ugc nofollow" target="_blank"> CI管道</a>中。对于应用程序，我还在这里包含了<code class="fe md me mf mg b">requirements.txt</code>文件。请注意，我创建了一个包含了<code class="fe md me mf mg b">requirements.txt</code>的组合<code class="fe md me mf mg b">requirements-dev.txt</code>。如果我在安装<code class="fe md me mf mg b">requirements-dev.txt</code>之前安装<code class="fe md me mf mg b">requirements.txt</code>，它可能会改变版本。这意味着我不会对完全相同的包版本进行测试。如果我在<code class="fe md me mf mg b">requirements-dev.txt</code>之后安装<code class="fe md me mf mg b">requirements.txt</code>，我可以为开发工具破坏一些东西。因此我通过<br/> <code class="fe md me mf mg b">pip-compile --output-file requirements-dev.txt requirements.txt</code>创建了一个组合文件</li></ul><p id="de80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想确定完全一样，你也可以加上<code class="fe md me mf mg b">--generate-hashes</code>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="006a" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题8:非Python代码</h1><p id="ab7c" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">像<a class="ae nu" href="https://pypi.org/project/cryptography/" rel="noopener ugc nofollow" target="_blank"> cryptography </a>这样的包都有用c写的代码，如果你安装了cryptography的源代码发行版，你需要能够编译那些代码。您可能没有安装像gcc这样的编译器，编译需要相当多的时间。</p><h1 id="bb52" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:构建的发行版(轮子)</h1><p id="cce8" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">软件包创建者也可以上传构建的发行版，例如作为wheels文件。这可以防止你自己编译东西。事情是这样做的:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="5c0b" class="oe mp it mg b gy of og l oh oi">$ pip install wheels<br/>$ python setup.py bdist_wheel</span></pre><p id="c172" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，<a class="ae nu" href="https://pypi.org/project/numpy/#files" rel="noopener ugc nofollow" target="_blank"> NumPy </a>这样做:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/92cbf57bd52ecbcedb1133013fb6e5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YE4EWu3Ld-iUdbaZ3aNRlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pypi.org的截图是作者拍摄的。</p></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="6fd4" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">问题9:构建系统的规范</h1><p id="1a88" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Python生态系统非常依赖setuptools。不管setuptools有多好，总会有人们遗漏的功能。但是我们有一段时间不能改变构建系统。</p><h1 id="bada" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">解决方案:pyproject.toml</h1><p id="97f3" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><a class="ae nu" href="https://www.python.org/dev/peps/pep-0517/" rel="noopener ugc nofollow" target="_blank">人教版517 </a>和<a class="ae nu" href="https://www.python.org/dev/peps/pep-0518" rel="noopener ugc nofollow" target="_blank">人教版518 </a>规定了<code class="fe md me mf mg b">pyproject.toml</code>文件格式。看起来是这样的:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="ff46" class="oe mp it mg b gy of og l oh oi">[build-system]<br/>requires = ["poetry-core&gt;=1.0.0"]<br/>build-backend = "poetry.core.masonry.api"</span></pre><p id="40aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，不多。它告诉pip构建您的包需要什么。但这是迈向更大灵活性的良好一步。</p><p id="a649" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其他工具，像poem和black，使用这个文件为他们的<code class="fe md me mf mg b">pyproject.toml</code>配置，类似于<code class="fe md me mf mg b">flake8</code>、<code class="fe md me mf mg b">pytest</code>、<code class="fe md me mf mg b">pylint</code>和更多允许你添加配置到<code class="fe md me mf mg b">setup.cfg</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/d235f924b1b9eea1eb818de1342cf308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9tfyWksoPahaApbn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Giorgio Trovato 在<a class="ae nu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="fb39" class="mo mp it bd mq mr oj mt mu mv ok mx my jz ol ka na kc om kd nc kf on kg ne nf bi translated">荣誉奖</h1><p id="5192" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">本节中的工具相对广泛，但是到今天为止，它们并没有真正解决上面的工具没有解决的任何问题。它们可能比其他的更方便使用。</p><h2 id="3f8f" class="oe mp it bd mq pi pj dn mu pk pl dp my lh pm pn na ll po pp nc lp pq pr ne ps bi translated">virtualenv和virtualenvwrapper</h2><p id="b92d" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">第三方工具<a class="ae nu" href="https://pypi.org/project/virtualenv/" rel="noopener ugc nofollow" target="_blank"> virtualenv </a>存在于核心模块<a class="ae nu" href="https://docs.python.org/3/library/venv.html" rel="noopener ugc nofollow" target="_blank"> venv </a>之前。它们并不完全相同，但对我来说，<code class="fe md me mf mg b">venv</code>已经足够好了。如果有人能告诉我一个问题的解决方案是virtualenv(而不是venv ),我会很高兴🙂</p><p id="9b7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae nu" href="https://virtualenvwrapper.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> virtualenvwrapper </a>扩展virtualenv。</p><h2 id="1a8f" class="oe mp it bd mq pi pj dn mu pk pl dp my lh pm pn na ll po pp nc lp pq pr ne ps bi translated">pipenv</h2><p id="38dc" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Pipenv是一个依赖管理和打包的工具。它介绍了<a class="ae nu" href="https://github.com/pypa/pipfile" rel="noopener ugc nofollow" target="_blank">两个新文件</a>:</p><ul class=""><li id="4f6b" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><strong class="la iu"> Pipfile </strong>:一个TOML文件。它的内容在思想上类似于<code class="fe md me mf mg b">requirements.in</code>的内容:抽象依赖。</li><li id="bd2c" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu"> Pipfile.lock </strong>:一个TOML文件。它的内容在思想上类似于<code class="fe md me mf mg b">requirements.txt</code>的内容:固定的具体依赖，包括可传递的依赖。</li></ul><p id="cfeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上，它包装了venv。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="4d0e" class="oe mp it bd mq pi pj dn mu pk pl dp my lh pm pn na ll po pp nc lp pq pr ne ps bi translated">诗意</h2><p id="2451" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><a class="ae nu" href="https://pypi.org/project/poetry/" rel="noopener ugc nofollow" target="_blank">诗歌</a>是一个依赖管理和打包的工具。它结合了许多工具，但其核心功能与pipenv相同。主要区别在于它使用了<code class="fe md me mf mg b">pyproject.toml</code>和<code class="fe md me mf mg b">poetry.lock</code>而不是<code class="fe md me mf mg b">Pipfile</code>和<code class="fe md me mf mg b">Pipfile.lock</code>。<a class="pt pu ep" href="https://medium.com/u/8a7cdd475d09?source=post_page-----743ead5f39ee--------------------------------" rel="noopener" target="_blank">霜明</a>写了一篇<a class="ae nu" href="https://frostming.com/2019/01-04/pipenv-poetry" rel="noopener ugc nofollow" target="_blank">诗与pipenv </a>的详细比较。</p><p id="6486" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">诗歌包装或替换的项目有:</p><ul class=""><li id="d1e9" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><strong class="la iu">脚手架</strong> : <code class="fe md me mf mg b">poetry new project-name</code> vs <a class="ae nu" href="https://github.com/MartinThoma/cookiecutter-python-package" rel="noopener ugc nofollow" target="_blank">千篇一律</a></li><li id="4923" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">建筑分布</strong> : <code class="fe md me mf mg b">poetry build</code> vs <code class="fe md me mf mg b">python setup.py build sdist_build</code></li><li id="cb1e" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">依赖管理</strong> : <code class="fe md me mf mg b">poetry add foobar</code> vs手动编辑setup.py / requirements.txt文件。然后，poems将创建一个虚拟环境，一个与<code class="fe md me mf mg b">Pipfile.lock</code>概念相同的<code class="fe md me mf mg b">poetry.lock</code>文件，并更新<code class="fe md me mf mg b">pyproject.toml</code>。你可以在下面看到一个例子。它们使用自己的依赖部分，这与其他任何部分都不兼容。我希望他们搬到PEP 631(更新见<a class="ae nu" href="https://github.com/python-poetry/poetry/issues/3332" rel="noopener ugc nofollow" target="_blank">期</a>)。</li><li id="d8fa" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">上传到PyPI </strong> : <code class="fe md me mf mg b">poetry publish</code> vs <code class="fe md me mf mg b">twine upload dist/*</code></li><li id="18b8" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">凹凸版</strong> : <code class="fe md me mf mg b">poetry version minor</code> vs手动编辑<code class="fe md me mf mg b">setup.py</code> / <code class="fe md me mf mg b">setup.cfg</code>或使用<a class="ae nu" href="https://pypi.org/project/bumpversion/" rel="noopener ugc nofollow" target="_blank">凹凸版</a>。⚠️尽管诗歌在包含一个版本的脚手架中生成了一个<code class="fe md me mf mg b">__init__.py</code>，但<code class="fe md me mf mg b">poetry version</code>并没有改变这一点！</li></ul><p id="6b0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它背离了指定依赖关系的事实上的标准<code class="fe md me mf mg b">setup.py</code> / <code class="fe md me mf mg b">setup.cfg</code>。相反，诗歌期望依赖关系在它的配置中:</p><pre class="kj kk kl km gt oa mg ob oc aw od bi"><span id="4e80" class="oe mp it mg b gy of og l oh oi">[tool.poetry]<br/>name = "mpu"<br/>version = "0.1.0"<br/>description = ""<br/>authors = ["Martin Thoma &lt;<a class="ae nu" href="mailto:info@martin-thoma.de" rel="noopener ugc nofollow" target="_blank">info@martin-thoma.de</a>&gt;"]<br/>license = "MIT"</span><span id="e118" class="oe mp it mg b gy oo og l oh oi">[tool.poetry.dependencies]<br/>python = "^3.8"<br/>awscli = "^1.18.172"<br/>pydantic = "^1.7.2"<br/>click = "^7.1.2"</span><span id="eb7e" class="oe mp it mg b gy oo og l oh oi">[tool.poetry.dev-dependencies]</span></pre><p id="83ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望他们也能实现<a class="ae nu" href="https://www.python.org/dev/peps/pep-0621/" rel="noopener ugc nofollow" target="_blank"> PEP 621 </a>和<a class="ae nu" href="https://www.python.org/dev/peps/pep-0631/" rel="noopener ugc nofollow" target="_blank"> PEP 631 </a>，在<code class="fe md me mf mg b">[project]</code>部分给元数据和依赖项一个正式的位置。让我们看看，<a class="ae nu" href="https://github.com/python-poetry/poetry/issues/3332" rel="noopener ugc nofollow" target="_blank">也许他们改变了那个</a>。</p><p id="0d60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些人喜欢有一个什么都做的工具。我宁愿选择Unix哲学:</p><blockquote class="pv pw px"><p id="1938" class="ky kz op la b lb lc ju ld le lf jx lg py li lj lk pz lm ln lo qa lq lr ls lt im bi translated">让每个程序做好一件事。要做一项新的工作，就要重新构建，而不是通过添加新的“特性”使旧的程序变得复杂。</p></blockquote><p id="94f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于诗歌结合了很多工具，它没有做什么也很重要:</p><ul class=""><li id="5e1f" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><strong class="la iu">包管理</strong>:你还需要pip。并且pip支持<a class="ae nu" href="https://pip.pypa.io/en/stable/reference/pip/#pep-517-and-518-support" rel="noopener ugc nofollow" target="_blank"> pyproject.toml </a>。</li><li id="ee48" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">脚手架</strong> : Cookiecutter有很多模板。我自己创建了两个:一个用于<a class="ae nu" href="https://github.com/MartinThoma/cookiecutter-python-package" rel="noopener ugc nofollow" target="_blank">典型的Python项目</a>，一个用于<a class="ae nu" href="https://github.com/MartinThoma/cookiecutter-flake8-plugin" rel="noopener ugc nofollow" target="_blank"> Flake8插件</a>。</li><li id="f60c" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated">Setup.py :你可能不需要自己创建一个，但是poems会为你创建一个Setup.py文件。看看发行版文件就知道了。</li></ul><p id="b938" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还应该指出，诗歌有一个超级好的命令行界面和视觉愉悦的网站。</p><h2 id="0a2d" class="oe mp it bd mq pi pj dn mu pk pl dp my lh pm pn na ll po pp nc lp pq pr ne ps bi translated">舱口</h2><p id="c92b" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><a class="ae nu" href="https://pypi.org/project/hatch/" rel="noopener ugc nofollow" target="_blank">孵化</a>也旨在替代相当多的工具:</p><ul class=""><li id="363f" class="nl nm it la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><strong class="la iu">脚手架</strong> : <code class="fe md me mf mg b">hatch new project-name</code> vs <a class="ae nu" href="https://github.com/MartinThoma/cookiecutter-python-package" rel="noopener ugc nofollow" target="_blank">千篇一律</a></li><li id="ee70" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">凹凸版</strong> : <code class="fe md me mf mg b">hatch grow minor</code> vs手动编辑<code class="fe md me mf mg b">setup.py</code> / <code class="fe md me mf mg b">setup.cfg</code>或使用<a class="ae nu" href="https://pypi.org/project/bumpversion/" rel="noopener ugc nofollow" target="_blank">凹凸版</a></li><li id="c9bd" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">运行pytest </strong> : <code class="fe md me mf mg b">hatch test</code> vs <code class="fe md me mf mg b">pytest</code></li><li id="a836" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">创建虚拟环境</strong> : <code class="fe md me mf mg b">hatch env my-venv</code> vs <code class="fe md me mf mg b">python -m venv my-venv</code></li><li id="b2f8" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">安装包</strong> : <code class="fe md me mf mg b">hatch install package</code> vs <code class="fe md me mf mg b">pip install package</code></li></ul><p id="8749" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在尝试孵化时犯了几个错误。</p><h2 id="b39e" class="oe mp it bd mq pi pj dn mu pk pl dp my lh pm pn na ll po pp nc lp pq pr ne ps bi translated">菲丽</h2><p id="a790" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Flit是一种将Python包和模块放在PyPI上的方法。它是setuptools的第三方替代品。在这个意义上，它类似于setuptools + twine或诗歌的一部分。</p><h2 id="86d8" class="oe mp it bd mq pi pj dn mu pk pl dp my lh pm pn na ll po pp nc lp pq pr ne ps bi translated">康达</h2><p id="7528" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Conda是Anaconda的包管理器。它比pip更强大，可以构建/安装任意语言的代码。有了<code class="fe md me mf mg b">pyproject.toml</code>，我想知道康达在未来是否有必要🤔</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="22e1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">红鲱鱼</h1><ul class=""><li id="3f2f" class="nl nm it la b lb ng le nh lh qb ll qc lp qd lt nq nr ns nt bi translated">这是在Python中安装东西的最古老的方法。它类似于<code class="fe md me mf mg b">pip</code>，但是你不能(轻易)卸载用<code class="fe md me mf mg b">easy_install</code>安装的东西</li><li id="bf88" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><code class="fe md me mf mg b">distutils</code>:虽然是核心Python，但是已经不用了。<code class="fe md me mf mg b">setuptools</code>更强大，到处安装。</li><li id="a125" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated">我不确定那是否曾经发生过？</li><li id="a1f3" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><code class="fe md me mf mg b">pyvenv</code>:弃用，支持<code class="fe md me mf mg b">venv</code>。</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="6531" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">摘要</h1><ul class=""><li id="1bb3" class="nl nm it la b lb ng le nh lh qb ll qc lp qd lt nq nr ns nt bi translated"><code class="fe md me mf mg b">pip</code>是蟒蛇<strong class="la iu">的包经理</strong>。它转到Python <strong class="la iu">包索引</strong>PyPI.org来安装你的包和它们的依赖项。</li><li id="edf6" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">抽象依赖</strong>可以用setup.py、requirements.in、Pipfile或者pyproject.toml来表示，你只需要一个。</li><li id="e297" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">具体的依赖关系</strong>可以用requirements.txt，Pipfile.lock，或者poetry.lock来表示，你只需要一个。</li><li id="dbac" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">构建包</strong>是用setuptools或者诗歌完成的。</li><li id="4adb" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">上传包</strong>是用麻线或者诗歌完成的。</li><li id="7c4d" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu">虚拟环境</strong>由venv或poem/pipenv/hatch/conda创建</li><li id="30be" class="nl nm it la b lb nv le nw lh nx ll ny lp nz lt nq nr ns nt bi translated"><strong class="la iu"> pipx </strong>如果要安装应用的话很酷。不要用在图书馆。</li></ul></div></div>    
</body>
</html>