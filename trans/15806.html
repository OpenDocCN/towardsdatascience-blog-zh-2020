<html>
<head>
<title>Getting started with Dask and SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dask和SQL入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-dask-and-sql-b8e2058dd563?source=collection_archive---------51-----------------------#2020-10-30">https://towardsdatascience.com/getting-started-with-dask-and-sql-b8e2058dd563?source=collection_archive---------51-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">免责声明:作者为Coiled工作，Coiled是这篇文章中的一个供应商。</em></p><p id="9550" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很多人谈论“民主化”数据科学和机器学习。从可广泛访问的意义上来说，还有什么比SQL、PyData和将数据科学扩展到更大的数据集和模型更民主呢？</p><p id="8d35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Dask正迅速成为可扩展计算的首选技术。尽管有强大而灵活的dataframe API，Dask在历史上并不支持SQL来查询大多数原始数据。</p><p id="f481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们来看看dask-sql，这是一个令人兴奋的新开源库，它为dask提供了一个sql前端。跟着一起的还有<a class="ae km" href="https://github.com/coiled/notebooks-blog/blob/main/notebooks/dask-sql-demo.ipynb" rel="noopener ugc nofollow" target="_blank">这本笔记本</a>。如果你想免费访问一些严肃的Dask集群，你也可以把它加载到Coiled Cloud上。为此，在此登录<a class="ae km" href="https://cloud.coiled.io/?utm_source=distrib_ml_future_post&amp;utm_medium=blog&amp;utm_campaign=blog_referalls_3" rel="noopener ugc nofollow" target="_blank"> Coiled Cloud，导航到</a><a class="ae km" href="https://cloud.coiled.io/examples/notebooks" rel="noopener ugc nofollow" target="_blank">我们的示例笔记本</a>，并启动dask-sql笔记本。</p><p id="60c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们:</p><ul class=""><li id="94a8" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">启动Dask集群并使用dask-sql在其上运行sql查询！</li><li id="2255" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">进行一些基本的速度测试，</li><li id="97a2" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">使用SQL和缓存数据来加速我们的分析，</li><li id="2c4a" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">调查dask-sql中的SQL内置助手函数，</li><li id="def8" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">提供一个从大数据快速绘图的例子。</li></ul><p id="278b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常感谢dask-sql 的创建者Nils Braun，感谢他对这篇文章的深思熟虑和建设性的反馈。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/74576220a0702a72c7a7e3e57364921d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fjUyehuL_2xBhmHP"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="06ac" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">启动Dask集群并为SQL做好准备</h1><p id="ee86" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">dask-sql是免费的+开源的，可以在任何dask集群上运行，所以你可以在任何环境下运行它(只需要很少的修改)。在AWS (Azure和GCP即将推出)上运行集群的一个简单方法是使用盘绕云。简单的一个原因是你不需要和Docker和/或Kubernetes混在一起！这就是我们在这里要做的，并且可以随意编码。</p><p id="e569" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还没有注册Coiled beta，<a class="ae km" href="https://cloud.coiled.io/?utm_source=dask_sql_post&amp;utm_medium=blog&amp;utm_campaign=blog_referalls_2" rel="noopener ugc nofollow" target="_blank">你可以在这里用Github或Google ID免费注册。</a></p><p id="4cf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们执行导入并启动我们的集群！</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="fe54" class="mz ls iq mv b gy na nb l nc nd">import coiled from dask.distributed<br/>import Client</span><span id="2b17" class="mz ls iq mv b gy ne nb l nc nd">cluster = coiled.Cluster(n_workers=20)<br/>client = Client(cluster) </span><span id="1816" class="mz ls iq mv b gy ne nb l nc nd">client</span></pre><p id="ba0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将安装dask-sql。这是一个简单的安装，但可能需要一两分钟。</p><h1 id="f37e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">分析云中的数据</h1><p id="3bbb" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">至此，我们已经准备好开始查询数据了！</p><p id="fd1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在运行我们的第一个SQL查询之前，让我们在感兴趣的数据集上用一个“starter”查询来测试一下:这个查询计算纽约出租车数据集中2019年记录的乘客计数的平均小费金额。</p><p id="450f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们用SQL再试一次。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="bd60" class="mz ls iq mv b gy na nb l nc nd">import dask.dataframe as dd</span><span id="053f" class="mz ls iq mv b gy ne nb l nc nd">df = dd.read_csv(<br/>       "s3://nyc-tlc/trip data/yellow_tripdata_2019-*.csv", <br/>       dtype={ "payment_type": "UInt8", <br/>               "VendorID": "UInt8", <br/>               "passenger_count": "UInt8", <br/>               "RatecodeID": "UInt8" },<br/>       storage_options={"anon": True} ) </span><span id="682a" class="mz ls iq mv b gy ne nb l nc nd">df.groupby("passenger_count").tip_amount.mean().compute()</span></pre><p id="2053" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！</p><p id="e25b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的集群和代码正在运行。</p><h1 id="e667" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">现在让我们用dask-sql来尝试一些SQL！</h1><p id="9bc4" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">dask-sql使用一些代码来“自动地”定位我们将需要的JVM共享库，但是它在这个部署在云上的Jupyter容器中没有找到正确的路径。</p><p id="33e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们稍后看到的，dask-sql使用一个Java库来处理一些查询分析，所以我们将给出一个关于JVM路径的提示。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="0e6c" class="mz ls iq mv b gy na nb l nc nd">import os </span><span id="9382" class="mz ls iq mv b gy ne nb l nc nd">os.environ["JAVA_HOME"] = "/opt/conda/lib/server"</span></pre><p id="867c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dask-sql使用一个完善的Java库Apache方解石来解析sql并对查询执行一些初始工作。这是一件好事，因为这意味着dask-sql没有重新发明另一个查询解析器和优化器，尽管它确实创建了对JVM的依赖。注意，启动和管理JVM的速度缺点只是在解析查询时出现的问题，而不是在执行查询时出现的问题。我们很快就会看到，这并没有显著增加开销。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="d937" class="mz ls iq mv b gy na nb l nc nd">from dask_sql </span><span id="cf9a" class="mz ls iq mv b gy ne nb l nc nd">import Context c = Context()</span></pre><p id="3906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个上下文实例将让我们运行查询…但首先我们需要一些数据源。</p><p id="57a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用dask-sql定义数据源有多种方法，但最简单的一种方法是提供dask数据帧作为数据源。Dask数据帧:</p><ul class=""><li id="0653" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">是懒惰的，所以直到需要时才检索数据，</li><li id="636d" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">可以发现数据模式，</li><li id="25e3" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">支持核外访问—这是一种不需要将数据加载到内存中的奇特说法(例如，数据可能不适合内存，或者您可能希望内存用于其他计算)，</li><li id="c518" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">知道如何从底层来源检索数据(例如，“S3的CSV文件”)。</li></ul><p id="c00d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在我们的SQL查询中使用数据，我们需要在dask-sql中为它分配一个标识符(名称)。</p><p id="1bb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下代码:</p><ol class=""><li id="8115" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nf kt ku kv bi translated">将表名taxi与df相关联</li><li id="61f2" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nf kt ku kv bi translated">创建一个查询来计算该表中的行数</li><li id="c3d9" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nf kt ku kv bi translated">以Dask数据帧的形式返回惰性结果集的句柄</li></ol><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="4788" class="mz ls iq mv b gy na nb l nc nd">c.register_dask_table(df, "taxi")</span><span id="4c02" class="mz ls iq mv b gy ne nb l nc nd">result = c.sql('SELECT count(1) FROM taxi') result</span></pre><p id="60af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在几乎所有情况下，运行c.sql(…)实际上不会运行完整的查询，而只是产生一个表示结果的Dask dataframe句柄。(在dask-sql文档中有一些边缘情况确实会触发即时计算，但长期目标是尽可能地减少懒惰。)</p><p id="cb00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何得到实际的行数？同样的方式，我们评估任何其他小Dask结果，我们想检索:通过。计算()</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="ad0a" class="mz ls iq mv b gy na nb l nc nd">result.compute()</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d7016b24476148bb24b94a71d2b293ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*adGlpl01VEsHEXOp"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">(图片由作者提供)</p></figure><p id="f5b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们已经运行了第一个dask-sql查询并获得了结果！</p><h1 id="28d6" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">转速试验</h1><p id="9be9" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">现在让我们再来看一下“起始查询”——根据乘客数量计算平均小费金额的查询。</p><p id="d31c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有两个目标:</p><ul class=""><li id="312b" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">用Dask/Python和SQL编写相同的查询，可以看到它们工作并产生相同的结果，</li><li id="89ff" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">对执行进行计时，以验证SQL不会增加任何显著的性能开销</li></ul><p id="907b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在尝试这样做，这也是查看Dask任务流仪表板的好时机，可以看到集群的运行情况。您可以通过JupyterLab扩展或通过Coiled Cloud GUI来实现这一点。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="183b" class="mz ls iq mv b gy na nb l nc nd">%%time </span><span id="3ae1" class="mz ls iq mv b gy ne nb l nc nd">df.groupby("passenger_count").tip_amount.mean().compute() </span><span id="7765" class="mz ls iq mv b gy ne nb l nc nd">%%time </span><span id="c55d" class="mz ls iq mv b gy ne nb l nc nd">c.sql('SELECT avg(tip_amount) FROM taxi GROUP BY passenger_count').compute()</span></pre><p id="e63b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该看到相同的输出(我们看到两者都是大约25秒)。此外，您应该会看到几乎相同的挂钟时间。SQL处理增加了100毫秒或更少的时间，并且是一次性的固定成本。</p><h1 id="1dd9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">SQL +缓存数据=涡轮增压分析</h1><p id="393c" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">让我们看看如何通过在集群中缓存该数据集，然后对缓存的数据运行SQL查询来加速分析。</p><p id="2187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不仅速度快，而且有利于整个团队，因为:</p><ul class=""><li id="24d4" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">我们可以向其他Dask分析师公开这个数据集，鼓励他们共享一个“大型RAM池”集群来分析数据，</li><li id="c965" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><a class="ae km" href="https://dask-sql.readthedocs.io/en/latest/pages/server.html" rel="noopener ugc nofollow" target="_blank"> dask-sql公开了Presto wire协议</a>，因此使用Presto兼容客户端或可视化工具的人可以零编程访问这些数据！</li></ul><p id="8247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将要求Dask缓存该表。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="85e8" class="mz ls iq mv b gy na nb l nc nd">dfp = df.persist()</span></pre><p id="da77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能需要几秒钟(对于非常大的数据集，可能需要更长时间)才能加载到集群RAM中。</p><p id="bf55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在Dask Graph仪表板中实时查看块加载情况。这显示任务在计算时变成绿色，然后在结果载入内存时变成红色。在这种情况下，每个任务从S3检索数据的一个分区。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ng"><img src="../Images/0adef9c1bac220bb445d9a7ac19c1088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qjNLuoFdgZqPTDu7"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">(图片由作者提供)</p></figure><p id="7365" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在其他情况下，我们可能不想查看GUI，而是以编程方式等待数据加载。</p><p id="d8e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用distributed.wait(…)来实现:</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="f764" class="mz ls iq mv b gy na nb l nc nd">import dask.distributed</span><span id="ab81" class="mz ls iq mv b gy ne nb l nc nd">cached_tasks = dask.distributed.wait(dfp)</span><span id="4cd8" class="mz ls iq mv b gy ne nb l nc nd">print(f'cached {len(cached_tasks[0])} results')</span></pre><p id="6fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将为数据集的这种新的缓存风格赋予一个新的表名(上面我们将df.persist的结果分配给它的dfp)。</p><p id="007b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dfp有点不透明，所以我们将这个表命名为taxi_cached。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="bbda" class="mz ls iq mv b gy na nb l nc nd">c.register_dask_table(dfp, "taxi_cached")</span></pre><p id="18c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个快速测试，看看它在内存不足的情况下运行的速度有多快，让我们再次计算行数。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="4c7a" class="mz ls iq mv b gy na nb l nc nd">result = c.sql('SELECT count(1) FROM taxi_cached')</span><span id="4703" class="mz ls iq mv b gy ne nb l nc nd">result.compute()</span></pre><p id="42f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们也尝试一下按乘客计数查询平均小费，这次是从缓存中查询。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="627c" class="mz ls iq mv b gy na nb l nc nd">%%time </span><span id="d76e" class="mz ls iq mv b gy ne nb l nc nd">c.sql('SELECT avg(tip_amount) FROM taxi_cached GROUP BY passenger_count').compute()</span></pre><p id="5d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不足为奇的是，由于从缓存的数据中工作消除了作业中的大部分I/O、解析和服务，它的运行速度比以前快得多。</p><h1 id="0397" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">SQL内置函数</h1><p id="689e" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">dask-sql还在sql中公开了许多助手函数——就像传统的关系数据库公开数学、日期/时间处理、字符串操作等助手函数一样。</p><p id="ae6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是对静态文字值运行的floor函数:</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="c2cd" class="mz ls iq mv b gy na nb l nc nd">c.sql('SELECT floor(3.14)').compute()</span></pre><p id="16d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用floor来离散化(或划分)行程距离，我们可以查看距离桶的粗粒度平均费用。</p><p id="b6d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的下一个查询查看距离在0到50之间的乘车，拆分(分组)分段(floor())距离，然后对于每个分段，返回分段距离、平均费用和乘车次数。</p><p id="5f8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们知道——基于我们的查询——报告输出将只包含50行和3列，我们可以安全地<em class="kl">计算</em>,并在本地获得一个作为常规Pandas数据帧的结果。如果我们的结果非常大——或者是我们希望在后续操作中使用的中间转换——我们要么将它写入持久存储，要么将结果保存在集群中。毕竟，大型数据集不适合我们的本地流程，Dask <em class="kl">客户端</em>和<em class="kl"> dask-sql上下文</em>对象就在本地流程中(注意，dask-sql查询的输出可以再次输入Dask-sql——这使得在SQL中获得类似的“视图”成为可能)。</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="5974" class="mz ls iq mv b gy na nb l nc nd">%%time</span><span id="f35f" class="mz ls iq mv b gy ne nb l nc nd">c.sql("""SELECT floor(trip_distance) <br/>AS dist, avg(fare_amount) as fare, count(1) as t <br/>FROM taxi_cached <br/>WHERE trip_distance &lt; 50 AND trip_distance &gt;= 0 <br/>GROUP BY floor(trip_distance)<br/>""").compute()</span></pre><p id="b0c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Dask已经实现了如此多的计算构建块，dask-sql能够涵盖大多数sql组件——包括子查询、连接和聚合。</p><h1 id="c297" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">贡献的机会</h1><p id="2a75" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">如果您查看dask-sql文档，您会注意到还没有实现多少帮助函数。例如，大多数数据库都有几个日期和时间处理助手函数，而现在dask-sql并没有实现所有这些函数。</p><p id="298e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数数据库都有几个字符串处理辅助函数，而今天dask-sql只有一个。</p><p id="56af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个添加有价值的功能并对库做出贡献的好机会，因为实现这些功能只需要找到现有的Dask函数并将其连接起来。</p><p id="2a57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可能想添加很多功能，但每个功能都很小，所以这是一个很好的众包机会。点击这里可以看到现有的实现<a class="ae km" href="https://github.com/nils-braun/dask-sql" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="0f62" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">再举一个例子:从大数据中快速绘图</h1><p id="3835" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">因为我们的结果反馈很快，而且作为熊猫的数据框架，我们可以很容易地进行可视化。这种模式可以帮助我们接近实时的交互式数据探索和可视化。</p><p id="e4c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您没有安装matplotlib，可以使用以下命令安装它:</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="2195" class="mz ls iq mv b gy na nb l nc nd">! conda install -y matplotlib -c conda-forge</span></pre><p id="9b4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以运行一个查询，并立即使用Pandas绘图语法绘制结果的可视化图形！</p><pre class="lc ld le lf gt mu mv mw mx aw my bi"><span id="5f64" class="mz ls iq mv b gy na nb l nc nd">c.sql("""SELECT floor(trip_distance) <br/>AS dist, avg(fare_amount) as fare <br/>FROM taxi_cached <br/>WHERE trip_distance &lt; 50 AND trip_distance &gt;= 0 <br/>GROUP BY floor(trip_distance) <br/>""").compute().plot(x='dist', y='fare')</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/be74eff3af2808e1381b2be3475a7a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/0*Hf20ePBf10r2MhCS"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="de04" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">引擎盖下的一瞥</h1><p id="4568" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">技术如何契合？</em>T11】</strong></p><p id="2fca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dask-sql依赖于完善的Apache方解石(<a class="ae km" href="https://calcite.apache.org/" rel="noopener ugc nofollow" target="_blank">https://calcite.apache.org/</a>)，一个Java项目</p><ul class=""><li id="7258" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">解析SQL</li><li id="fa0f" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">将查询表示为操作符树</li><li id="f460" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">规范化和优化查询</li><li id="b3b4" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">方解石的优化器是可扩展的，因此有许多“插件”可以在将来添加更多的功能</li></ul><p id="49f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太多了！还剩下什么？</p><p id="ddf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方解石的输出是一个逻辑操作符树的查询表示。这些是像投影(把它们想象成选择的抽象)和过滤器(哪里的抽象)这样的东西。</p><p id="d111" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dask-sql的下一项工作是提供插件，将纯粹抽象的操作符转换成用Dask APIs表达操作的逻辑。结果仍然是逻辑操作符，但是更具体一些——类似于您自己编写Dask dataframe查询所得到的结果，因此它可以在您的Dask集群上执行。在执行时，Dask提供操作的物理实现，例如，根据数据的存储方式而变化。</p><h1 id="c189" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">创造更多机会</h1><p id="05c8" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">协同增效如今已经是老生常谈了。但是向Dask添加一个SQL前端使大量新用户和新用例能够共享最先进的Python数据解决方案。</p><p id="9f8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，精通SQL但不写命令性代码的分析师和商务人士现在可以利用Dask、PyData、Coiled等等……同时与喜欢编码的人合作。</p><p id="9f06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dask-sql中的自定义函数支持意味着编码人员可以围绕复杂的流程创建简单的包装器(例如，应用机器学习模型对记录进行评分)，sql用户可以使用这些函数创建报告。</p><p id="107a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，通过Presto的数据库服务器功能(也许很快就是JDBC，因为方解石包括JDBC支持)，可以采用像Tableau这样的可视化解决方案，并将其指向Dask集群进行大规模可视化分析。</p><p id="5bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接:</p><ul class=""><li id="d714" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">Dask、Coiled和PyData<a class="ae km" href="https://coiled.io/blog/pydata-dask/" rel="noopener ugc nofollow" target="_blank">https://coiled.io/blog/pydata-dask/</a></li><li id="777f" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">https://dask-sql.readthedocs.io/的Dask SQL文档<a class="ae km" href="https://dask-sql.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"/></li><li id="15b7" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">Dask SQL来源【https://github.com/nils-braun/dask-sql T4】</li><li id="a584" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">阿帕奇方解石<a class="ae km" href="https://calcite.apache.org/" rel="noopener ugc nofollow" target="_blank">https://calcite.apache.org/</a></li></ul><p id="a7f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果您喜欢这种方法，“感觉需要速度”，并且有可用的GPU，一定要看看<a class="ae km" href="https://blazingsql.com/" rel="noopener ugc nofollow" target="_blank"> BlazingSQL </a>，它在GPU计算的基础上提供了类似的SQL+Dask架构，以获得令人惊叹的查询速度。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="9308" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于2020年10月30日</em><a class="ae km" href="https://coiled.io/blog/getting-started-with-dask-and-sql/" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://coiled . io</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>