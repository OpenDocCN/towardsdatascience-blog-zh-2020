<html>
<head>
<title>Memory Management And Garbage Collection In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的内存管理和垃圾收集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/memory-management-and-garbage-collection-in-python-c1cb51d1612c?source=collection_archive---------2-----------------------#2020-10-03">https://towardsdatascience.com/memory-management-and-garbage-collection-in-python-c1cb51d1612c?source=collection_archive---------2-----------------------#2020-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d0afb6c5165ff30805b46a8b87c9f630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsWPPhAdLSpujc6T6FfCYw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">伯纳德·赫曼特在<a class="ae jd" href="https://unsplash.com/@bernardhermant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="00f0" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">引用计数和分代垃圾收集</h2></div><p id="e487" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您在学习Python时有以下问题，那么您就来对地方了:</p><ul class=""><li id="9ad9" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">Python中是如何管理内存的？</li><li id="733b" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">什么是垃圾收集？</li><li id="aace" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">哪些算法用于内存管理？</li><li id="9acc" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">什么是循环引用？</li><li id="53eb" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Python对象是如何存储在内存中的？</li></ul><p id="7c6c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看我能否回答这些问题以及本文中的其他问题:</p><p id="f09a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我从基础开始。</p><h2 id="d450" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">Python是一种动态类型语言。</h2><p id="b2d1" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">当我们在Python中给变量赋值时，我们不声明变量的类型。它说明了程序运行时变量的种类。其他语言，如C、C++、Java等..在给变量赋值之前，有一个严格的变量声明。</p><p id="1a8b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你在下面看到的，我们只需要给一个对象分配一个变量，Python就会检测这个对象的类型。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/ce395fc17ce0ab7aabcf4ccbf4cf96e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJhfhKJhCE__j_1pwPzRSA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Python动态检测对象的类型。图片由作者用<a class="ae jd" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作</p></figure><h2 id="1f25" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">Python对象是如何存储在内存中的？</h2><p id="9d07" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在C、C++和Java中，我们有变量和对象。Python有名字，没有变量。Python对象以名称和引用的形式存储在内存中。名称只是一个对象的标签，所以一个对象可以有多个名称。引用是指向一个对象的名称(指针)。</p><h2 id="c342" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">每个Python对象都有三样东西。</h2><p id="f879" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Python对象有三样东西:类型、值和引用计数。当我们给一个变量命名时，它的类型会被Python自动检测出来，正如我们上面提到的。值在定义对象时声明。Reference count是指向该对象的名称数。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/8c5aaec77ece3242796b0c0bffabde3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0MVfelkQrJ_zBym4b3CSA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">每个Python对象都有三样东西。图片由作者用<a class="ae jd" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作</p></figure><h1 id="8aa0" class="nj mg jg bd mh nk nl nm mk nn no np mn km nq kn mq kp nr kq mt ks ns kt mw nt bi translated">垃圾收集:</h1><p id="4e60" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">垃圾收集是在对象不再使用时释放内存。这个系统销毁未使用的对象，而<em class="nu">为新对象重用</em>它的内存槽。你可以把这想象成电脑中的回收系统。</p><p id="4e1e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Python有一个自动化的垃圾收集。它有一个算法来释放不再需要的对象。Python有两种方法从内存中删除不用的对象。</p><h1 id="246c" class="nj mg jg bd mh nk nl nm mk nn no np mn km nq kn mq kp nr kq mt ks ns kt mw nt bi translated">1.引用计数:</h1><p id="0da0" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">引用总是被计数并存储在内存中。</p><p id="7dd1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下面的例子中，我们将c赋值为50。即使我们赋一个新的变量，对象是一样的，引用计数增加1！因为每个对象都有自己的ID，所以我们打印对象的ID来查看它们是相同还是不同。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/4a373a7be10c710965c3251175e32f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whUt-uxczSkN-c7eA91Yfg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者用<a class="ae jd" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作</p></figure><p id="cf7e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们像下面这样改变<strong class="kx jh"> a </strong>的值时，我们创建了一个新对象。现在，<strong class="kx jh"> a </strong>指向60，<strong class="kx jh">b</strong>c<strong class="kx jh">指向50。</strong></p><p id="fdf4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们将<strong class="kx jh"> a </strong>改为none时，我们创建了一个None对象。现在前面的整数对象没有引用了，它被垃圾回收删除了。</p><p id="14d2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将<strong class="kx jh"> b </strong>分配给一个布尔对象。之前的整数对象没有被删除，因为它仍然有一个被<strong class="kx jh"> c </strong>引用的对象。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/6f312d5d69595d12de652f699444382f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUUqMbS8EVOjKidzop1ilA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者用<a class="ae jd" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作</p></figure><p id="0415" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们删除<strong class="kx jh"> c </strong>。我们将对<strong class="kx jh"> c </strong>的引用计数减一。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/e1516563434e5fd74be5e2d72c512110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ACkEMs80c4s0O6UkFD-Pw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由作者用<a class="ae jd" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作</p></figure><p id="b895" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所述，<strong class="kx jh"> del() </strong>语句并没有删除对象，它删除了对象的名字(和引用)。当引用计数为零时，对象被垃圾回收从系统中删除。</p><h2 id="b229" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">参考计数的商品和次品:</h2><p id="331f" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">通过引用计数进行垃圾收集有优点也有缺点。比如容易实现。程序员不必担心删除不再使用的对象。但是，这种内存管理对内存本身是不利的！该算法总是计算对象的引用数，并将引用数存储在内存中，以保持内存的清洁，确保程序有效运行。</p><p id="524e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，一切看起来都很好，但是…</p><h2 id="b845" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">有问题！</h2><p id="f2ab" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">引用计数垃圾收集中最重要的问题是它在循环引用中不起作用。</p><h2 id="67be" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">什么是循环引用或引用循环？</h2><p id="2fc2" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">这是一种物体指向自身的情况。最简单的循环引用是将一个列表附加到自身。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/af04724d91a4582c8df5dcb5024cebf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLikrePar4vLUPqvo1S2xg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">最简单的循环引用。图片由作者用<a class="ae jd" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作</p></figure><p id="443d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">单独的引用计数不能销毁具有循环引用的对象。如果引用计数不为零，则不能删除该对象。</p><p id="2cf9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个问题的解决方案是第二种垃圾收集方法。</p><h2 id="65af" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">2.分代垃圾收集:</h2><p id="b8ae" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">分代垃圾收集是一种基于跟踪的垃圾收集。它可以中断循环引用并删除未使用的对象，即使这些对象是自己引用的。</p><h2 id="d00c" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">分代垃圾收集是如何工作的？</h2><p id="84d0" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Python跟踪内存中的每个对象。程序运行时会创建3个列表。第0、1和2代列表。</p><p id="ba6f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">新创建的对象放在第0代列表中。为要丢弃的对象创建一个列表。检测到参考周期。如果一个对象没有外部引用，它将被丢弃。在此过程后幸存的对象被放入第1代列表中。相同的步骤适用于第1代列表。第1代列表中的幸存者被放入第2代列表中。第2代列表中的对象会一直保留在那里，直到程序执行结束。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/37323b4056b99b5e03af0f355c75d298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q759CB0_RMWcEfwmOBO85g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">分代垃圾收集。图片由作者用<a class="ae jd" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作</p></figure><h1 id="a030" class="nj mg jg bd mh nk nl nm mk nn no np mn km nq kn mq kp nr kq mt ks ns kt mw nt bi translated">结论:</h1><p id="9ba0" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">Python是一种高级语言，我们不必手动进行内存管理。Python的垃圾收集算法对于打开内存空间非常有用。垃圾收集在Python中以两种方式实现:引用计数和分代。当对象的引用计数达到0时，引用计数垃圾收集算法会立即清理该对象。如果你有一个循环，引用计数没有达到零，你等待分代垃圾收集算法运行并清理对象。虽然程序员不需要考虑Python中的垃圾收集，但是理解幕后发生的事情是很有用的。</p><p id="04c2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望我能回答文章开头的问题。对于您找不到答案的问题:</p><h2 id="d9f1" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">延伸阅读:</h2><ol class=""><li id="6958" class="lr ls jg kx b ky my lb mz le oa li ob lm oc lq od lx ly lz bi translated">Python中的可变和不可变对象。</li></ol><p id="ca58" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://medium.com/@307/mutable-and-immutable-objects-in-python-11412474b253" rel="noopener">这里的</a>是一篇冷门却很棒的媒体文章</p><p id="a78d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.如何理解Python中的变量？</p><p id="6ea6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://standupdev.com/wiki/doku.php?id=python_tuples_are_immutable_but_may_change" rel="noopener ugc nofollow" target="_blank">这里</a>是一篇关于元组的有趣文章。</p><p id="3f89" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.本地和全局命名空间。</p><p id="3bf8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里是来自realpython.com的详细解释</p><p id="8fb7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">4.跟踪垃圾收集。</p><p id="47d9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="noopener ugc nofollow" target="_blank">这里的</a>是指向“基于轨迹的算法”的维基百科链接。</p><p id="671e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">5.堆栈和堆内存。</p><p id="49ff" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.geeksforgeeks.org/how-are-variables-stored-in-python-stack-or-heap/" rel="noopener ugc nofollow" target="_blank">这里</a>是geekforgeeks对“变量如何存储”的解释。</p><h1 id="9f97" class="nj mg jg bd mh nk nl nm mk nn no np mn km nq kn mq kp nr kq mt ks ns kt mw nt bi translated">联系我</h1><p id="72bc" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">如果你想了解我的最新文章，请在<a class="ae jd" href="https://seymatas.medium.com/" rel="noopener"> Medium </a>上关注我。你可以在<a class="ae jd" href="https://www.linkedin.com/in/seyma-tas/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，并在<strong class="kx jh">seymatas@gmail.com给我发电子邮件！</strong></p><p id="c3d3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">非常感谢您的任何建议和意见！</p></div></div>    
</body>
</html>