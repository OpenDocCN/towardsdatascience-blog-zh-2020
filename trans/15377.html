<html>
<head>
<title>Demystifying Apache Arrow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开阿帕奇箭的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-apache-arrow-8ba2b4fc5cd4?source=collection_archive---------29-----------------------#2020-10-22">https://towardsdatascience.com/demystifying-apache-arrow-8ba2b4fc5cd4?source=collection_archive---------29-----------------------#2020-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cc8f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解关于一种工具的更多信息，该工具可以在两秒钟内在您的笔记本电脑上过滤和聚合20亿行</h2></div><p id="b34c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我作为数据科学家的工作中，我在一系列看似不相关的情况下遇到过Apache Arrow。然而，我总是很难准确地描述它是什么，它做什么。</p><p id="8395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arrow的官方描述是:</p><blockquote class="lb lc ld"><p id="0e4e" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">用于内存分析的跨语言开发平台</p></blockquote><p id="8f33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很抽象——而且有充分的理由。该项目雄心勃勃，旨在为大范围的数据处理任务提供主干。这意味着它位于较低的级别，为更高级的、面向用户的分析工具(如pandas或dplyr)提供构建模块。</p><p id="a61b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于那些在日常工作中偶尔遇到这个项目的用户来说，这个项目的重要性可能很难理解，因为它的大部分工作都是在幕后进行的。</p><p id="160d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我描述了我在工作中遇到的Apache Arrow的一些面向用户的特性，并解释了为什么它们都是Apache Arrow旨在解决的更基本问题的各个方面。</p><p id="ad37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过连接这些点，可以清楚地了解为什么Arrow不仅是解决当今一些实际问题的有用工具，而且是最令人兴奋的新兴工具之一，有可能成为未来数据科学工作流的大部分背后的引擎。</p><h2 id="415f" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">更快的csv读取</h2><p id="ad7b" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">Arrow的一个显著特点是，它可以将CSV读入熊猫图<a class="ae li" href="https://youtu.be/fyj4FyH3XdU?t=1030" rel="noopener ugc nofollow" target="_blank">，</a>比<code class="fe mh mi mj mk b">pandas.read.csv</code>快10倍以上。</p><p id="d500" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这实际上是一个两步过程:Arrow将数据读入内存中的Arrow表，该表实际上只是记录批次的集合，然后将Arrow表转换为pandas数据帧。</p><p id="bb64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，加速是Arrow底层设计的结果:</p><ul class=""><li id="9562" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">Arrow有自己的内存存储格式。当我们使用Arrow将数据加载到pandas时，我们实际上是将数据加载到Arrow格式(数据帧的内存格式)，然后将其转换为Pandas内存格式。因此，读取CSV的部分加速来自于箭头列格式本身的精心设计。</li><li id="d83b" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">箭头中的数据以记录批的形式存储在内存中，记录批是一种2D数据结构，包含等长的连续数据列。可以从这些批处理中创建一个'<a class="ae li" href="http://arrow.apache.org/docs/python/data.html#tables" rel="noopener ugc nofollow" target="_blank">表</a>，而不需要额外的内存复制，因为表可以有“分块”列(即数据段，每个部分代表一个连续的内存块)。这种设计意味着可以并行读取数据，而不是pandas的单线程方法。</li></ul><h2 id="71f1" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">PySpark中更快的用户定义函数(UDF)</h2><p id="4ee4" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">在Apache Spark中运行Python用户定义函数一直非常慢——慢到通常建议不要在任何大规模的数据集上运行。</p><p id="1b1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，Apache Arrow使得在JVM和Python进程之间高效地传输数据成为可能。结合矢量化UDF，这导致了<a class="ae li" href="https://spark.apache.org/docs/latest/sql-pyspark-pandas-with-arrow.html#apache-arrow-in-pyspark" rel="noopener ugc nofollow" target="_blank">巨大的加速</a>。</p><p id="23ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是怎么回事？</p><p id="32c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在引入Arrow之前，将数据从Java表示转换为Python表示的过程非常缓慢——包括序列化和解序列化。它也是一次一行，速度较慢，因为许多优化的数据处理操作对以列格式保存的数据最有效，每列中的数据保存在内存的连续部分中。</p><p id="fe98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arrow的使用几乎完全消除了序列化和解序列化步骤，还允许以列批处理方式处理数据，这意味着可以使用更高效的矢量化算法。</p><p id="eb20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arrow能够在不同语言之间传输数据，而不会产生很大的序列化/反序列化开销，这是一个关键特性，使得用一种语言实现的算法更容易被使用其他语言的数据科学家使用。</p><h2 id="6a5c" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">将文件夹中的文件作为单个表格读取</h2><p id="b663" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">Arrow能够将包含许多数据文件的文件夹读入单个数据帧。Arrow还支持读取数据被<a class="ae li" href="https://blog.cloudera.com/improving-query-performance-using-partitioning-in-apache-hive/" rel="noopener ugc nofollow" target="_blank">划分到子文件夹</a>的文件夹。</p><p id="3c9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此功能说明了记录批次周围的箭头的高级设计。如果所有东西都是一个记录批，那么源数据是存储在一个文件中还是多个文件中就无关紧要了。</p><h2 id="46e1" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">读取拼花文件</h2><p id="696c" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">Arrow可用于将parquet文件读入Python和R等数据科学工具，正确表示目标工具中的数据类型。由于parquet是一种自描述格式，并且在模式中指定了列的数据类型，因此获得正确的数据类型似乎并不困难。但是仍然需要一个翻译的过程来将数据加载到不同的数据科学工具中，这是令人惊讶的复杂。</p><p id="94c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在历史上，pandas整数类型不允许整数为空，尽管在parquet文件中这是可能的。类似的怪癖也适用于其他语言。Arrow为我们处理这个翻译过程。数据总是首先被加载到Arrow格式中，但是Arrow提供了翻译器，然后能够将其转换成特定于语言的内存格式，比如pandas dataframe。这意味着对于每个目标格式，需要一个格式到箭头的翻译器，这是对当前需要“n取2”个翻译器(每对工具一个)的巨大改进。</p><p id="4092" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arrow的目标是最终完全消除这个翻译问题:理想情况下，数据帧应该有单一的内存格式，而不是每个工具都有自己的表示形式。</p><h2 id="b814" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">编写拼花文件</h2><p id="a427" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">Arrow可以很容易地将pandas和R等工具中保存在内存中的数据以Parquet格式写入磁盘。</p><p id="5901" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么不直接将数据以Arrow格式保存到磁盘上，从而拥有一个在磁盘上和内存中相同的单一的跨语言数据格式呢？一个最大的原因是，Parquet通常产生较小的数据文件，如果您是IO绑定的，这是更可取的。如果你从像AWS S3这样的云存储中加载数据，情况尤其如此。</p><p id="e683" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Julien LeDem在一篇讨论两种<a class="ae li" href="https://www.kdnuggets.com/2017/02/apache-arrow-parquet-columnar-data.html" rel="noopener ugc nofollow" target="_blank">格式</a>的博客文章中进一步解释了这一点:</p><blockquote class="lb lc ld"><p id="71a2" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">列数据和内存中数据的权衡是不同的。对于磁盘上的数据，通常IO主导延迟，这可以通过以CPU为代价的激进压缩来解决。在内存中，访问速度要快得多，我们希望通过关注缓存局部性、流水线和SIMD指令来优化CPU吞吐量。</p></blockquote><p id="ae80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得在内存和磁盘格式的开发中密切合作，在两种表示之间进行可预测和快速的转换是可取的——这正是Arrow和Parquet格式所提供的。</p><h1 id="84a8" class="mz lk iq bd ll na nb nc lo nd ne nf lr jw ng jx lu jz nh ka lx kc ni kd ma nj bi translated">这些想法是如何联系在一起的？</h1><p id="6a72" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">虽然非常有用，但迄今为止讨论的面向用户的特性并不是革命性的。真正的力量在于底层构建模块的潜力，它可以实现数据科学工具的新方法。目前(2020年秋季)，Arrow背后的团队仍在进行一些工作。</p><h2 id="65a8" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">记录批次和分块</h2><p id="1e05" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">在Apache Arrow中，数据帧由记录批次组成。如果存储在磁盘上的Parquet文件中，这些批处理可以非常快地读入内存中的Arrow格式。</p><p id="9252" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经看到这可以用来将csv文件读入内存。但更广泛地说，这一概念打开了整个数据科学工作流的大门，这些工作流是并行的，并对记录批次进行操作，从而消除了将整个表存储在内存中的需要。</p><h2 id="a1ae" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">数据帧的一种常见(跨语言)内存表示</h2><p id="f366" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">目前，数据科学工具及其数据帧的内存表示的紧密耦合意味着用一种语言编写的算法不容易移植到其他语言。这意味着相同的标准操作，如过滤器和聚合，会被无休止地重写，优化不容易在工具之间转换。</p><p id="3679" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Arrow提供了在内存中表示数据帧的标准，以及允许多种语言和引用相同内存数据的机制。</p><p id="eb93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这<a class="ae li" href="https://docs.google.com/document/d/10RoUZmiMQRi_J1FcPeVAUAMJ6d_ZuiEbaM2Y33sNPu4/edit" rel="noopener ugc nofollow" target="_blank">为</a>的发展创造了机会</p><p id="a842" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">C++中的一个原生箭头列查询执行引擎，不仅用于C++中，也用于Python、R和Ruby等用户空间语言中。</p><p id="38cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将提供一个单一的、高度优化的代码库，可用于多种语言。对维护和贡献这个库感兴趣的开发人员将会更多，因为它可以在各种工具上使用。</p><h1 id="5e4a" class="mz lk iq bd ll na nb nc lo nd ne nf lr jw ng jx lu jz nh ka lx kc ni kd ma nj bi translated">伟大的想法</h1><p id="dceb" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">这些想法在Arrow作为“数据API”的描述中结合在一起。其思想是Arrow提供了一种跨语言的内存数据格式，以及一种相关的查询执行语言，为分析库提供了构建块。像任何好的API一样，Arrow为常见问题提供了一个高性能的解决方案，用户不需要完全理解实现。</p><p id="d6a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">借助分析库，这为数据处理能力的重大变革铺平了道路:</p><ul class=""><li id="00bb" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">默认情况下被并行化</li><li id="cde5" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">在数据帧上应用高度优化的计算</li><li id="39e0" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">不再需要处理整个数据集必须适合内存的约束</li></ul><p id="e733" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同时通过在单台机器上或通过网络在工具之间更快地传输数据，打破工具之间共享数据的障碍。</p><p id="7797" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在R 中Arrow包的<a class="ae li" href="https://arrow.apache.org/docs/r/articles/dataset.html" rel="noopener ugc nofollow" target="_blank">插图中一窥这种方法的潜力，其中一个37gb的数据集有20亿行，在一台笔记本电脑上处理和聚合不到2秒钟。</a></p><p id="14dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将现有的高级数据科学工具和语言(如SQL、pandas和R)置于何处？</p><p id="a241" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如插图所示，Arrow的目的不是直接与这些工具竞争。相反，更高级的工具可以使用箭头，对它们面向用户的API施加很少的约束。因此，它允许在不同工具的表达能力和特性方面继续创新，同时提高性能并为作者节省重新发明通用组件的任务。</p><h1 id="5cbc" class="mz lk iq bd ll na nb nc lo nd ne nf lr jw ng jx lu jz nh ka lx kc ni kd ma nj bi translated">进一步阅读</h1><p id="3ded" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated"><a class="ae li" href="https://arrow.apache.org/overview/" rel="noopener ugc nofollow" target="_blank">https://arrow.apache.org/overview/</a><br/>T3】https://arrow.apache.org/use_cases/<br/>T6】https://arrow.apache.org/powered_by/<br/><a class="ae li" href="https://arrow.apache.org/blog/" rel="noopener ugc nofollow" target="_blank">https://arrow.apache.org/blog/</a><br/><a class="ae li" href="https://ursalabs.org/blog/" rel="noopener ugc nofollow" target="_blank">https://ursalabs.org/blog/</a><br/><a class="ae li" href="https://wesmckinney.com/archives.html" rel="noopener ugc nofollow" target="_blank">https://wesmckinney.com/archives.html</a><br/><a class="ae li" href="https://www.youtube.com/watch?v=fyj4FyH3XdU" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=fyj4FyH3XdU</a></p><p id="1745" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头设计文档:</p><p id="6c77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae li" href="https://github.com/apache/arrow/pull/4225" rel="noopener ugc nofollow" target="_blank">文件系统API </a> <br/> <a class="ae li" href="https://docs.google.com/document/d/1bVhzifD38qDypnSjtf8exvpP3sSB5x_Kw9m-n66FB2c/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">数据集API </a> <br/> <a class="ae li" href="https://docs.google.com/document/d/1XHe_j87n2VHGzEbnLe786GHbbcbrzbjgG8D0IXWAeHg/edit#heading=h.g70gstc7jq4h" rel="noopener ugc nofollow" target="_blank">数据框架API </a> <br/> <a class="ae li" href="https://docs.google.com/document/d/10RoUZmiMQRi_J1FcPeVAUAMJ6d_ZuiEbaM2Y33sNPu4/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> C++查询引擎</a></p></div></div>    
</body>
</html>