<html>
<head>
<title>Bayesian Generalized Linear Models with Pyro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Pyro的贝叶斯广义线性模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bayesian-generalized-linear-models-with-pyro-b80bc08d7b75?source=collection_archive---------12-----------------------#2020-10-27">https://towardsdatascience.com/bayesian-generalized-linear-models-with-pyro-b80bc08d7b75?source=collection_archive---------12-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/beb16c50b78d5e4a2807c3aac1569624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ic9Ou8ZXZeiADVCXpOaKIw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://www.pexels.com/@negativespace" rel="noopener ugc nofollow" target="_blank">负空间</a>从<a class="ae jd" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</p></figure><h2 id="1447" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="3992" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">使用线性模型和Pyro预测房价，实现完全透明的方法</h2></div><p id="9c09" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">面对预测或分析数据项目时，最常见的“第一攻击线”之一是广义线性模型(GLMs)，最常见的是线性或逻辑回归。</p><p id="94aa" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">GLMs试图将响应变量<em class="ma"> y </em>建模为特征的线性组合<em class="ma"> X </em>的函数。线性组合的原因主要是为了便于解释；我们希望不仅能够很好地预测<em class="ma"> y </em>，而且能够解释每个特征对我们反应的影响。</p><p id="e986" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因此，我们通常指定GLM作为我们的响应，它是如下特征和系数的组合:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mb"><img src="../Images/c82e102dc58c3d10e00765144d8f1bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGQUVR9JThVNKWnBSwHoIw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="8665" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">其中<em class="ma"> f </em>是我们的线性组合的函数，系数用希腊字母<em class="ma"> β </em>表示</p><p id="b3cd" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然像<code class="fe mg mh mi mj b">sklearn</code>这样的库提供了丰富多样的回归模型，但是它们有一个主要的缺点，那就是它们创建了<em class="ma"> β </em>的点估计，而没有考虑不确定性。也就是说，虽然我们可以找出该系数最可能的值，但我们不会估计该系数的其他值的可能性有多大。其他软件包如<code class="fe mg mh mi mj b">statsmodels</code>提供了一些不确定性的度量，但是是在一系列分析师可能无法验证(或了解)的隐含假设下提供的。</p><p id="f394" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在本文中，我们将讨论如何利用PyTorch和Pyro来生成GLM模型，这些模型创建参数和预测的不确定性估计，并通过一组非常明确的假设来实现。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="fd12" class="mr ms jg bd mt mu mv mw mx my mz na nb kv nc kw nd ky ne kz nf lb ng lc nh ni bi translated">采用Scikit-learn的线性回归</h1><p id="84b2" class="pw-post-body-paragraph le lf jg lg b lh nj kq lj lk nk kt lm ln nl lp lq lr nm lt lu lv nn lx ly lz ij bi translated">我们将从探索一个来自<code class="fe mg mh mi mj b">sklearn</code>的简单线性回归开始，看看它在一个内置数据集上的表现，即加州住房数据集。</p><p id="3fa5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将从导入所有需要的库开始:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="67b7" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，让我们导入住房数据集，并探索其功能:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><pre class="mc md me mf gt nq mj nr ns aw nt bi"><span id="9389" class="nu ms jg mj b gy nv nw l nx ny">&gt;&gt;&gt; Data shape is (20640, 8)<br/>&gt;&gt;&gt; Target shape is (20640,)</span></pre><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/adda464df64e856ccca71b629b75ed5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fPKNqfYqXsBDB2_uARtNw.png"/></div></div></figure><p id="07ed" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">许多库中的基本线性回归模型假设响应正态分布在预测平均值周围。但是，一般来说房价不会呈正态分布。在这个数据集中，价格的分布也是不正常的，它更接近于一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Gamma_distribution" rel="noopener ugc nofollow" target="_blank">伽马分布</a>(实际上，我们不会总是直接从数据中获得，但可能必须查看残差，但这个简单的替代方案在我们的情况下是有效的)。因此，如果我们能够建立模型，将这一点考虑在内，那就太好了。</p><p id="5bd4" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">首先，让我们探索一下<code class="fe mg mh mi mj b">sklearn</code>线性回归对这些数据的表现。我们可以将数据分为训练集和测试集，以估计我们的算法将如何工作:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><pre class="mc md me mf gt nq mj nr ns aw nt bi"><span id="6155" class="nu ms jg mj b gy nv nw l nx ny">&gt;&gt;&gt; (16512, 8) (16512,)<br/>&gt;&gt;&gt; (4128, 8) (4128,)</span></pre><p id="f390" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们来拟合我们的线性回归:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><pre class="mc md me mf gt nq mj nr ns aw nt bi"><span id="acdf" class="nu ms jg mj b gy nv nw l nx ny">&gt;&gt;&gt; beta_intercept: -3664645.74<br/>&gt;&gt;&gt; beta_MedInc: 44223.44<br/>&gt;&gt;&gt; beta_HouseAge: 944.77<br/>&gt;&gt;&gt; beta_AveRooms: -11532.16<br/>&gt;&gt;&gt; beta_AveBedrms: 66340.59<br/>&gt;&gt;&gt; beta_Population: -0.16<br/>&gt;&gt;&gt; beta_AveOccup: -411.33<br/>&gt;&gt;&gt; beta_Latitude: -41808.42<br/>&gt;&gt;&gt; beta_Longitude: -43108.51</span></pre><p id="5641" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们定义一个函数来绘制我们的预测和持续测试集的真实值:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/cce1b0af8d0a417102f37f454287a4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZ7ySGC30IciKrigyqjTCw.png"/></div></div></figure><p id="2cff" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们的数据中有一些观察结果是经过审查的。也就是说，他们的标签似乎是50万美元以上的房子。我们可以定义另一个函数，它只画出未被删除的点:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/aacc4519820e80a5cf017fe37eb14307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKeuJ5NG-yWDz6FJCvoEtw.png"/></div></div></figure><p id="a4f5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然这种方法可以产生令人满意的结果，但它有几个主要缺点:</p><ul class=""><li id="40db" class="ob oc jg lg b lh li lk ll ln od lr oe lv of lz og oh oi oj bi translated">首先，线性模型通常忽略价格来自伽玛分布的事实。它对每个点的期望值的计算是基于来自正态分布的平均值。</li><li id="8a9c" class="ob oc jg lg b lh ok lk ol ln om lr on lv oo lz og oh oi oj bi translated">第二，对于每个系数，我们只能得到其最可能值的点估计。然而，我们可能对考虑不确定性的范围感兴趣。例如，我们可能想知道每增加一间卧室，价格上涨的幅度是多少。</li></ul><p id="839b" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了解决这些问题，我们可以使用<a class="ae jd" href="https://pyro.ai/" rel="noopener ugc nofollow" target="_blank"> Pyro </a>和<a class="ae jd" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>来构建我们自己的线性模型，这将解决刚才提到的所有痛点。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="409c" class="mr ms jg bd mt mu mv mw mx my mz na nb kv nc kw nd ky ne kz nf lb ng lc nh ni bi translated">用Pyro重建线性模型</h1><p id="49fd" class="pw-post-body-paragraph le lf jg lg b lh nj kq lj lk nk kt lm ln nl lp lq lr nm lt lu lv nn lx ly lz ij bi translated">首先，让我们尝试用Pyro复制简单线性回归的结果。这将让我们直观地了解不同的火焰元素是如何工作的:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5224" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">首先，我们将在Pyro中定义我们的模型。Pyro模型被定义为函数(实际上它们被定义为可调用的，但最简单的可调用是函数)。该函数将接受我们的特征𝑋、我们的目标𝑦，以及更容易命名先验的特征名称:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="67db" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">本质上，我们在这里所做的是将我们的线性回归定义为以下参数的线性组合</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi op"><img src="../Images/7cb2dfe32f1ced2e72f69bccd85f862a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mp7Y1r2o8gq_fqra8gQITA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="f100" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，与传统的线性回归不同，我们将每个β系数以及误差项定义为一个分布，而不是单个值。也就是说，对于每个系数，我们可以问，在给定我们观察到的数据的情况下，该系数可以假设的可能值的范围是什么。我们给每一个发行版起了一个名字(例如“<code class="fe mg mh mi mj b">beta_intercept</code>”)，以便以后参考。</p><p id="241e" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们必须定义每个系数的先验。先验是我们对这一价值的“最佳猜测”。我们选择的优先顺序是:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/af6ee29d467428fa7a30f429abfa4730.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*WPV_CiybbjC6cpm07EoBWw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>准备的配方</p></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/35c52ea96909b8d250340f2282e89756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*0bXL9j9U6tAERsDAUEM9OQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="5f1c" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些不是非常有用的先验知识，但它们通常用于回归系数和误差项。</p><p id="9878" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">需要注意的重要一点是，在构建模型时，我们必须明确这些选择。也就是说，我们必须清楚什么是系数值、误差项以及预测值周围值的分布的合理先验。</p><p id="38c5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一旦先验被定义，我们可以要求Pyro通过MCMC采样器的魔力将它们更新为越来越好的猜测:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><pre class="mc md me mf gt nq mj nr ns aw nt bi"><span id="13b9" class="nu ms jg mj b gy nv nw l nx ny">&gt;&gt;&gt; Sample: 100%|██████████| 3100/3100 [22:45,  2.27it/s, step size=7.72e-04, acc. prob=0.955]</span><span id="c011" class="nu ms jg mj b gy os nw l nx ny">&gt;&gt;&gt; Inference ran for 22.75 minutes</span></pre><p id="2b63" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果您对这里发生的事情感兴趣，我建议您查看我以前的文章，其中探讨了使用MCMC方法优化单个参数。</p><p id="b130" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以使用<code class="fe mg mh mi mj b">.summary()</code>方法研究MCMC采样器为每个系数找到的估计值:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><pre class="mc md me mf gt nq mj nr ns aw nt bi"><span id="dff6" class="nu ms jg mj b gy nv nw l nx ny">&gt;&gt;&gt;</span><span id="28fb" class="nu ms jg mj b gy os nw l nx ny">                  mean    std   median    5.0%   95.0% n_eff r_hat<br/> beta_intercept   1.58   0.01    1.58   1.56   1.59   9.48  1.21<br/>    beta_MedInc   1.96   0.02    1.96   1.93   1.98   2.83  2.28<br/>  beta_HouseAge   0.80   0.09    0.80   0.68   0.93   2.41  3.00<br/>  beta_AveRooms  -1.88   0.02   -1.87  -1.90  -1.86   2.56  2.53<br/> beta_AveBedrms   1.63   0.01    1.64   1.61   1.65   4.59  1.45<br/>beta_Population  81.19  18.19   87.50  71.45  87.91   9.00  1.13<br/>  beta_AveOccup  -0.56   0.01   -0.56  -0.57  -0.55   4.61  1.97<br/>  beta_Latitude  -0.57   0.04   -0.58  -0.63  -0.52   2.39  3.23<br/> beta_Longitude  -2.37   3.30   -2.12  -7.11   1.80   2.44  2.82<br/>      sigma  15062.73 460.33 14933.00 14908.34  15057.25  12.98 1.09<br/><br/>Number of divergences: 0</span></pre><p id="f47e" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些看起来不太对…平均值似乎与<code class="fe mg mh mi mj b">sklearn</code>回归发现的点估计值非常不同。</p><p id="df85" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们从采样器中获取单个样本，并将它们转换成数据帧(它们作为字典返回)。我们可以获取每个分布的平均值作为系数点估计，然后为我们的数据点计算一组预测。然后，我们可以将它们与我们已知的房价值进行比较:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ot"><img src="../Images/db32c1b1d254d6ae0adb533f7fb2aa6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-W3IVRuVFrKV0DR4KUeTPA.png"/></div></div></figure><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c4ee" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们绘制结果并计算我们预测的𝑅值:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/76857929f0211d202df82baf224ee67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSnq1sC2iQOGl9kXXm79cg.png"/></div></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/529afa625c22439ac1afc93d26c740be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzAViJmYDVeYuwgq0yDJPg.png"/></div></div></figure><p id="f5a9" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">那看起来像一场灾难！发生了什么事？</p><p id="e9ad" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们定义一个函数，当给定一个系数数据帧时，它将为我们画出系数的分布:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/4a78f7f8d9046ac7593d91a15109ae22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svx1xLjHUPuy006RaQGwvA.png"/></div></div></figure><p id="9e24" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">那些情节看起来不像是融合了。</p><p id="a04a" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">对于这个问题，MCMC方法很难处理不同尺度的数据。当我们的特征和目标被缩放时，它们工作得更好。让我们通过数据缩放来探索相同方法的性能</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="50a9" class="mr ms jg bd mt mu mv mw mx my mz na nb kv nc kw nd ky ne kz nf lb ng lc nh ni bi translated">扩展我们的数据</h1><p id="fd40" class="pw-post-body-paragraph le lf jg lg b lh nj kq lj lk nk kt lm ln nl lp lq lr nm lt lu lv nn lx ly lz ij bi translated">我们将使用来自<code class="fe mg mh mi mj b">sklearn</code>的标准缩放器来缩放我们的X和y数据。标准缩放器将缩放X轴上的每个要素，使其平均值为0.0，标准差为1.0。为此，它将采用每个变量的平均x̅和标准差𝑠</p><p id="0863" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这意味着，不是试图在原始数据上找到一组系数</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ou"><img src="../Images/bbc9f8ae070378a8e8184734b1f3b3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kabL9xLL7iGRl0R79Wnmg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用https://www.codecogs.com/latex/eqneditor.php<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">配制的配方</a></p></figure><p id="557c" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们将在缩放后的数据上找到一组系数:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ov"><img src="../Images/b22cf76fbe7a5b5276c462db9e544089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ncb5UyAwo59fwXI5MAQ2hw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用https://www.codecogs.com/latex/eqneditor.php<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">配制的配方</a></p></figure><p id="c73e" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在哪里</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a18ffffbd495cfdd4bbedbbdf0edad7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*X9OMMs90wI_Z0W4OjhvcJw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="f29c" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">也就是说，y被缩放到0–1之间，X的列已经标准化。</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><pre class="mc md me mf gt nq mj nr ns aw nt bi"><span id="b225" class="nu ms jg mj b gy nv nw l nx ny">&gt;&gt;&gt; Sample: 100%|██████████| 3100/3100 [05:27,  9.46it/s, step size=1.71e-02, acc. prob=0.926]</span><span id="172b" class="nu ms jg mj b gy os nw l nx ny">&gt;&gt;&gt; Inference ran for 5.46 minutes</span></pre><p id="5ecc" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们的算法现在运行得更快了，但如果我们恢复算法找到的系数，这些将是缩放数据的系数。我们希望将它们转换回未缩放的数据，这样我们就可以问这样的问题:“房子里每多一间卧室，对价格会有什么影响？”</p><p id="c0aa" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">幸运的是，我们可以操纵我们的方程来检索未缩放数据的系数。我们从原始方程开始</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ov"><img src="../Images/b22cf76fbe7a5b5276c462db9e544089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ncb5UyAwo59fwXI5MAQ2hw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="a9b3" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们展开每一部分:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ox"><img src="../Images/7ed6dc3afe3edf1c7169983bfaba8ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmRSDM0DfxQhybWnTcF64A.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="dfd5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后，我们可以将等式重新排列如下:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oy"><img src="../Images/acc6b8370f2b81e1442d1f7c4904ab7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UX_ZY55C624qUqyC5RnwIQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="f82f" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">忆及</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/a18ffffbd495cfdd4bbedbbdf0edad7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*X9OMMs90wI_Z0W4OjhvcJw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="9ebf" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们最终可以将公式改写如下:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oz"><img src="../Images/54147ca8f32c4766b0f46545307821de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*347oN7Bh9Y6gEqI7xbX5dQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="cc28" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以创建一个函数来执行从缩放数据到未缩放数据的系数处理</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3a86" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然后，在我们再次从字典中检索系数之后，我们只对检索到的系数使用该函数:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f8bb" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们来对比一下预测结果:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/c34f87df0767d564a1daf04c61af8b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTfPDvctZXCsJCKFEnHF4A.png"/></div></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/7f43d9716f7d9c5b81d1da86688a891d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6sfha3HqF3tPKTsf7YE6A.png"/></div></div></figure><p id="f7b5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些值似乎更接近于通过<code class="fe mg mh mi mj b">sklearn</code>的线性回归得到的值。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/a1694536c8ac2ebb89b11d89e2fcd500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UZXTYau9nd3GW7lxfSwng.png"/></div></div></figure><p id="9a46" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">看起来我们的表现不相上下。这些分布看起来接近于我们从scikit-learn获得的值。我们还得到了每个系数的概率分布，这样我们就可以看到我们找到的值的置信度。</p><p id="51d9" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，我们实际上可以使用Pyro做得更好！回想一下，我们看到我们的房价不是正态分布，而是遵循伽玛分布。我们可以修改代码以在模型中反映出来。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="5427" class="mr ms jg bd mt mu mv mw mx my mz na nb kv nc kw nd ky ne kz nf lb ng lc nh ni bi translated">使用伽马分布改进我们的预测</h1><p id="4237" class="pw-post-body-paragraph le lf jg lg b lh nj kq lj lk nk kt lm ln nl lp lq lr nm lt lu lv nn lx ly lz ij bi translated">为了更好地反映房屋分布，我们可以对目标值采用伽玛分布。与由其平均值和标准偏差定义的正态分布不同，伽马分布由两个正参数定义，即形状和比率。</p><p id="c165" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当构建非正态分布的模型时，我们需要使用一个<strong class="lg jq">链接函数</strong>，它会将我们参数的线性组合转换为分布的期望值或平均值。我们还想知道平均值和分布参数之间的关系。幸运的是，对于伽马分布，这被定义为:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/f2accf48b02d75d58f148eadc5b595b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*3nd_cORp548SDlrK6hYvWg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="574c" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，如果形状和速率参数都是正的，这意味着平均值也必须是正的。我们需要确保我们的链接函数能够捕捉到这一点。因此，我将对线性方程使用以下链接函数:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pb"><img src="../Images/44bac432953284821e6d072d5a77c57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cTpXQYOwZpT3qNYTPIJew.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="1dc2" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">或者</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pc"><img src="../Images/8d9d8b3cbf6557d1a543650efb630f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6l039YSjtOA71LLQ1tVwWA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="8bca" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">熟悉<code class="fe mg mh mi mj b">statsmodels</code>包的读者会知道它有一个GLM模块(关于<code class="fe mg mh mi mj b">statsmodels</code> GLMs的更多细节，我推荐<a class="ae jd" rel="noopener" target="_blank" href="/generalized-linear-models-9cbf848bb8ab">这篇文章</a>)，它可以通过使用<code class="fe mg mh mi mj b">statsmodels.genmod.families.family.Gamma</code>族和<code class="fe mg mh mi mj b">statsmodels.genmod.families.links.log</code>链接函数来对这里提出的关系进行建模。然而，出于本文的目的，我想展示在贝叶斯框架中重现这一功能的过程。</p><p id="9217" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有趣的是，为了恢复未缩放数据的系数，除了常数之外，数学计算非常相似。请记住:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/80563557a5c8c42c347a4ee1da4a8cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*mX7JDtlpdrtMqNvpnHzjcg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="b2b6" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">而且</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pe"><img src="../Images/39dc6352ea473269e38ecd7b81851e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wlcvh87BPJUX6EBxoSxPBQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="d71f" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以发现我们的方程可以写成:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pf"><img src="../Images/d615a5c6282c96574dc52fdc2c1ca37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVufSuuRsWnSC4Kkv6-5TQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="f173" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">或者</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pg"><img src="../Images/dc93d8d4d217c67e63490e943a294a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1tmoN9dm6ou1KAkq-O86Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="3962" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们定义我们的模型，但是现在使用伽马分布:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8f21" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">你会注意到我们的代码略有不同，但我们仍然在计算我们的<em class="ma"> X </em>数据和我们的系数的线性组合，只是现在我们取该组合的<code class="fe mg mh mi mj b">exp</code>来获得我们的数据点的平均值。我们还对速率参数进行采样，并使用平均值和速率来计算适当的形状参数。</p><p id="0f28" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">给定我们的形状和速率参数，我们可以定义一个伽马分布，并要求Pyro优化我们的系数和速率参数，以便建立一个最有可能基于我们的数据的模型。</p><p id="bc4f" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们优化这个新模型，看看结果:</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><pre class="mc md me mf gt nq mj nr ns aw nt bi"><span id="fba1" class="nu ms jg mj b gy nv nw l nx ny">&gt;&gt;&gt; Sample: 100%|██████████| 3100/3100 [11:08,  4.64it/s, step size=1.47e-02, acc. prob=0.930]</span><span id="dfb5" class="nu ms jg mj b gy os nw l nx ny">&gt;&gt;&gt; Inference ran for 11.14 minutes</span></pre><p id="9018" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们也可以从这个采样器中获取系数。但是，这一次我们要稍微区别对待<code class="fe mg mh mi mj b">y_max</code>的值。</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="df9e" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们通过计算预测值并将其与观测值进行比较来比较该模型的性能</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/01e3dbd5ef6c56a6cae830e87fc7651c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Alu9B6o4z6aXsDxfHLb5Pw.png"/></div></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/c5d991df69e436096bbb044ab7b70493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fua280Jbyw49EyrgN8LgcA.png"/></div></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/a221ee1b61512938381790a5db85e242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shBb1czuvjxBt3TnrY5_iQ.png"/></div></div></figure><p id="cec2" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们如何解释这些系数？</p><p id="8213" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">嗯，他们现在用一个系数来修改我们的价格。回想一下，我们的等式现在是:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/2a027edec43e3ffddd3305069a2d0e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*n-fjhA9fDxV4aZjzV9V_gg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="6718" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这相当于</p><figure class="mc md me mf gt is gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/ad7f2f4ac904b1840ecdafdca99d4335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7V6LaO7cQXBFwDXxPZp-vg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用<a class="ae jd" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">https://www.codecogs.com/latex/eqneditor.php</a>制备的配方</p></figure><p id="2097" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">所以<code class="fe mg mh mi mj b">x_1</code>每增加一个单位，房价就会增加<code class="fe mg mh mi mj b">e^{x_1}</code>倍。</p><p id="3946" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">例如，<code class="fe mg mh mi mj b">beta_AvgRooms</code>的平均值约为0.007，因此每增加一个房间，房价平均会增加e^0.007 = 1.007的系数(因此，如果一栋房子的价格为250，000美元，增加一个房间将使其价值为251，756美元)。</p><p id="11f2" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这两个模型之间的其他参数似乎在定性上一致，但采用伽马分布的模型为我们提供了对未知数据的更好预测。</p><p id="b1af" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，仍然存在运行时间的问题。一般来说，如果我们想在合理的时间内进行推理，就不得不求助于变分推理的方法。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="ead2" class="mr ms jg bd mt mu mv mw mx my mz na nb kv nc kw nd ky ne kz nf lb ng lc nh ni bi translated">更快的SVI运行时间</h1><p id="c2e3" class="pw-post-body-paragraph le lf jg lg b lh nj kq lj lk nk kt lm ln nl lp lq lr nm lt lu lv nn lx ly lz ij bi translated">Pyro实现了随机变分推理(SVI ),以加快推理速度。在SVI方法中，我们不是试图直接从后验分布中取样，而是简单地优化一些预定义分布的参数，以匹配我们的观察数据。</p><p id="6e65" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">例如，我们可以选择将所有系数和比率表示为正态分布。通过这种方式，SVI只需找到每个正态分布的适当均值和标准差，使其尽可能与我们的数据一致。</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><pre class="mc md me mf gt nq mj nr ns aw nt bi"><span id="8a49" class="nu ms jg mj b gy nv nw l nx ny">&gt;&gt;&gt; iter: 0, normalized loss:5.28<br/>&gt;&gt;&gt; iter: 250, normalized loss:-0.64<br/>&gt;&gt;&gt; iter: 500, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 750, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 1000, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 1250, normalized loss:-0.69<br/>&gt;&gt;&gt; iter: 1500, normalized loss:-0.69<br/>&gt;&gt;&gt; iter: 1750, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 2000, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 2250, normalized loss:-0.69<br/>&gt;&gt;&gt; iter: 2500, normalized loss:-0.69<br/>&gt;&gt;&gt; iter: 2750, normalized loss:-0.69<br/>&gt;&gt;&gt; iter: 3000, normalized loss:-0.69<br/>&gt;&gt;&gt; iter: 3250, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 3500, normalized loss:-0.69<br/>&gt;&gt;&gt; iter: 3750, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 4000, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 4250, normalized loss:-0.69<br/>&gt;&gt;&gt; iter: 4500, normalized loss:-0.68<br/>&gt;&gt;&gt; iter: 4750, normalized loss:-0.68</span><span id="63f0" class="nu ms jg mj b gy os nw l nx ny">&gt;&gt;&gt; Inference ran for 0.74 minutes</span></pre><p id="8006" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从SVI样本中获取结果比从MCMC样本中获取结果要复杂一些，因为样本返回的是一个具有梯度的张量字典，并且它还返回了一个名为<code class="fe mg mh mi mj b">obs</code>的附加关键字，该关键字与我们的系数分析无关(它是一组对训练数据的估计)。</p><figure class="mc md me mf gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/5a4f1e41010a19ae53825eaee873580d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bbFSowzu6PXaQ1hSqQ49g.png"/></div></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/cfe485c87283ad7417297ce051322c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNKk6b7Z5ZEkBEU1uq3OBA.png"/></div></div></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/2c2fd66d335faafb31d19bdc36242120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4CtGv7dwnpVKCPw1Gxl3A.png"/></div></div></figure><p id="781c" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们开始吧。我们现在可以使用Pyro构建定制的GLMs，使用MCMC采样方法或SVI优化方法。</p><p id="1524" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Pyro的一个重要特性是它迫使作者非常明确地说明他们的假设和他们对数据生成过程的理解。这对于在进行任何建模之前促进对数据的深入探索非常有用，有助于更深入地理解所有重要因素。</p><p id="c403" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如需本文的Colab笔记本版本，请访问<a class="ae jd" href="https://colab.research.google.com/drive/1MpbGkI_JEVmfzEuh68PRGWgFP5fSEIoe" rel="noopener ugc nofollow" target="_blank">此链接</a></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1715" class="mr ms jg bd mt mu mv mw mx my mz na nb kv nc kw nd ky ne kz nf lb ng lc nh ni bi translated">结果摘要</h1><p id="cb92" class="pw-post-body-paragraph le lf jg lg b lh nj kq lj lk nk kt lm ln nl lp lq lr nm lt lu lv nn lx ly lz ij bi translated">在完成了这个博客的笔记本版本之后，我开始描绘我观察到的运行时和性能结果。通过运行相同的代码40次，每次都有不同的训练/测试分割，我能够对我在本文中展示的结果有信心。</p><p id="070a" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">就R性能而言，伽玛分布始终优于正态分布模型，如下图所示。</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pj"><img src="../Images/39ef4886f10ede0861a3c5f1cb92f1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EX1cfmRwi_rNoT8Y74Ux4g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用Plotly准备的图像</p></figure><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pj"><img src="../Images/ef2e6cc95c4411a33a939cb0ff90b045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdS6PRZz72FI6NrFzrZZaQ.png"/></div></div></figure><p id="af75" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">值得注意的是，线性回归模型(<code class="fe mg mh mi mj b">sklearn</code>的线性回归)的R值中明显的高标准偏差，以及在缩放数据并采用MCMC方法后产生的模型是单次训练/测试分割的结果，这导致了数据系数的严重错误估计。基于伽马分布的方法更适用于误导性的训练/测试分割。</p><p id="a9fd" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">此外，我还分析了每种方法的运行时间，结果如下图所示:</p><figure class="mc md me mf gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pj"><img src="../Images/b085f085becad1bc98ab7d6a636cfd01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IOA9rFFm8gh2iyRkL5r1MA.png"/></div></div></figure><p id="6b40" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如您所见，虽然<code class="fe mg mh mi mj b">sklearn</code>的线性回归始终优于所有其他方法，但采用基于SVI的方法是一种相对较快的解决方案，它结合了自定义指定GLM的灵活性和许多问题所需的快速运行时间。</p><p id="5ad2" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">此外，如果我们愿意，我们也可以编写我们自己的自定义指南，使用系数的正态分布以外的分布。</p><p id="e925" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">总的来说，我们可以看到Pyro提供了一套丰富的方法来为不同的问题建立线性模型，它结合了概率规划中涉及的明确性和最近成为焦点的可解释性。我希望这篇文章能为希望利用即将到来的概率编程语言的分析师和科学家提供很好的指导。</p></div></div>    
</body>
</html>