<html>
<head>
<title>How to build a KNN classification model from scratch and visualize it using Streamlit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从头开始构建KNN分类模型，并使用Streamlit对其进行可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-knn-classification-model-from-scratch-and-visualize-it-using-streamlit-9fe8059cc418?source=collection_archive---------29-----------------------#2020-10-11">https://towardsdatascience.com/how-to-build-a-knn-classification-model-from-scratch-and-visualize-it-using-streamlit-9fe8059cc418?source=collection_archive---------29-----------------------#2020-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecb3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">虽然像sklearn这样的图书馆让我们的生活变得更加容易，但是从头开始制作一个模型总是一个好的实践。在本教程中，我们将从头构建一个KNN分类模型，并使用Streamlit构建一个web应用程序对其进行可视化。下面是最终应用程序的演示。</h2></div><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/7ee15d192cfac0c3943c37bc28a9bfe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8g8p7TCmmp51JRwVxSxOVg.gif"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">最终Streamlit应用的截屏</p></figure><h1 id="08a9" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">KNN概述</h1><p id="e1f4" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">KNN或K近邻用于分类和回归。在本教程中，我们将使用它进行分类。由于目标标签是已知的，所以这是一种有监督的算法。它本质上接受一个输入，并找到K个最接近它的点。然后检查最近点的标注，并将输入分类为出现次数最多的标注。假设我们想要建立一个模型，根据输入的体重、身高将动物分类为狗或猫。如果K = 3，我们找到离输入最近的3个点并检查它们的标签。如果3个最近点中的2个有标签“狗”，我们的模型将输入分类为“狗”。如果3个最近的点中的2个有标签“猫”，我们的模型将输入分类为“猫”</p><h2 id="11c1" class="mq ld it bd le mr ms dn li mt mu dp lm md mv mw lo mh mx my lq ml mz na ls nb bi translated">步伐</h2><ul class=""><li id="3119" class="nc nd it lw b lx ly ma mb md ne mh nf ml ng mp nh ni nj nk bi translated">标准化数据集并存储它，即确保所有值都在0和1之间。</li><li id="c974" class="nc nd it lw b lx nl ma nm md nn mh no ml np mp nh ni nj nk bi translated">取一个输入数据点，并从数据集中的所有记录中找出距离。将距离存储在列表中。</li><li id="320d" class="nc nd it lw b lx nl ma nm md nn mh no ml np mp nh ni nj nk bi translated">对包含距离的列表进行排序，并检查排序列表中前K条记录的标签</li><li id="a3e0" class="nc nd it lw b lx nl ma nm md nn mh no ml np mp nh ni nj nk bi translated">将输入分类为在前K条记录中出现次数最多的标签</li></ul><blockquote class="nq nr ns"><p id="0f5a" class="lu lv nt lw b lx nu ju lz ma nv jx mc nw nx mf mg ny nz mj mk oa ob mn mo mp im bi translated">首先，我们将创建所有我们需要的助手函数。然后我们再把它们结合起来，加入一些streamlit函数，构建一个web app。</p></blockquote><p id="de53" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">为了便于理解和可视化，我们将使用具有2个要素和二进制标签(即“0”和“1”)的数据集。</p><h1 id="895b" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated"><strong class="ak">助手功能</strong></h1><h2 id="bc31" class="mq ld it bd le mr ms dn li mt mu dp lm md mv mw lo mh mx my lq ml mz na ls nb bi translated">标准化数据的函数</h2><p id="652d" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">为了规范化一个值列表，我们迭代每个值，并找到列表中的值和最小值之间的差。然后我们将它除以列表中最大值和最小值的差。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/bec07d2d5ded925871d00b1eb7794c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/1*oA32uOqzHBydiO536GeY1Q.gif"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">标准化数据的方程式</p></figure><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="79f8" class="mq ld it oe b gy oi oj l ok ol"><em class="nt">def</em> <strong class="oe iu">min_max_normalize(<em class="nt">lst</em>)</strong>:<br/>    minimum = min(lst)<br/>    maximum = max(lst)<br/>    normalized = [(val - minimum)/(maximum - minimum) for val in <br/>    lst]                               <br/>    return normalized</span></pre><p id="0eb0" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">该函数接受一个值列表，并返回规范化的值</p><h2 id="a076" class="mq ld it bd le mr ms dn li mt mu dp lm md mv mw lo mh mx my lq ml mz na ls nb bi translated">计算欧几里德距离的函数</h2><p id="3b0b" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">该函数将用于计算两个给定点之间的距离。我们将使用欧几里德公式来计算距离。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/7159b9c266355dcde8c1d35559084213.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/1*eL2PsgWIa7y_l3IA0eaTfA.gif"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">计算欧几里德距离的公式</p></figure><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="4e41" class="mq ld it oe b gy oi oj l ok ol"><em class="nt">def</em> <strong class="oe iu">distance(<em class="nt">element1</em> , <em class="nt">element2</em>):</strong><br/>    x_distance = (element1[0] - element2[0])**2<br/>    y_distance = (element1[1] - element2[1])**2<br/>    return (x_distance + y_distance)**0.5</span></pre><p id="c176" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">该函数接受两个2D点，并返回它们之间的欧几里得距离。由于我们考虑的数据集只有两个要素，因此我们只考虑x和y坐标。随着特征数量的增加，该函数将需要改变以找到所有指数之间的平方差。</p><h2 id="b175" class="mq ld it bd le mr ms dn li mt mu dp lm md mv mw lo mh mx my lq ml mz na ls nb bi translated"><strong class="ak">查找输入点和数据集中所有点之间距离的函数</strong></h2><p id="b2fc" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">我们迭代数据集中的每个值，并使用上面的<strong class="lw iu"> <em class="nt">距离</em> </strong> <em class="nt"> </em>函数来计算两点之间的距离。然后，我们存储距离并进行排序。</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="114f" class="mq ld it oe b gy oi oj l ok ol"><em class="nt">def</em> <strong class="oe iu">find_nearest(<em class="nt">x</em> , <em class="nt">y</em> , <em class="nt">input</em> , <em class="nt">k</em>):<br/>    </strong>distances = []<br/>    for id,element in enumerate(x):<br/>        distances.append([distance(input , element),id])<br/>    distances = sorted(distances)<br/>    predicted_label = get_label(distances[0:k] , y)<br/>    return predicted_label, distances[0:k] , distances[k:]</span></pre><p id="8904" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">该函数将以下参数作为输入:</p><ul class=""><li id="f508" class="nc nd it lw b lx nu ma nv md on mh oo ml op mp nh ni nj nk bi translated"><strong class="lw iu"> x: </strong>这是包含这两个特征的数据集</li><li id="642e" class="nc nd it lw b lx nl ma nm md nn mh no ml np mp nh ni nj nk bi translated"><strong class="lw iu"> y: </strong>这包含了<strong class="lw iu"> x </strong>中每一行的标签。它们是分别映射的，即<strong class="lw iu"> x[i] </strong>的标签是<strong class="lw iu"> y[i] </strong></li><li id="c6ac" class="nc nd it lw b lx nl ma nm md nn mh no ml np mp nh ni nj nk bi translated"><strong class="lw iu">输入:</strong>这是一个2D数组，包含我们想要分类的点的特征</li><li id="4b9f" class="nc nd it lw b lx nl ma nm md nn mh no ml np mp nh ni nj nk bi translated">k: 我们希望模型考虑的最近邻的数量</li></ul><p id="5349" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">首先，我们创建一个空数组来存储距离。我们需要在数据集中存储记录的距离和索引。该索引可以在<strong class="lw iu"> y </strong>数组中使用，以找到该记录的标签。</p><p id="5533" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">然后我们对距离进行排序。接下来，我们使用<strong class="lw iu"> get_label </strong>函数(将在下面讨论)来获取最常出现的标签。</p><p id="3ebb" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">由于<strong class="lw iu">距离</strong>数组被排序，前k个<strong class="lw iu"> </strong>元素，即<strong class="lw iu">距离【0:k】</strong>是我们输入的k个最近邻。我们返回输入的预测标签、k个最近的邻居和其余的邻居。</p><h2 id="1bc8" class="mq ld it bd le mr ms dn li mt mu dp lm md mv mw lo mh mx my lq ml mz na ls nb bi translated"><strong class="ak">查找最常出现的标签的功能</strong></h2><p id="13a3" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">我们基本上得到k个最近的邻居，检查每个邻居的标签。在我们的例子中，我们只有两个标签“0”和“1”。如果邻居的标签是“0 ”,我们对“0”的出现增加计数，并对“1”进行同样的操作。我们比较两个标签出现的次数，并返回计数较高的标签。</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="782d" class="mq ld it oe b gy oi oj l ok ol"><em class="nt">def</em> <strong class="oe iu">get_label(<em class="nt">neighbours</em>, <em class="nt">y</em>):<br/>    </strong>zero_count , one_count = 0,0<br/>    for element in neighbours:<br/>      if y[element[1]] == 0:<br/>         zero_count +=1<br/>      elif y[element[1]] == 1:<br/>         one_count +=1<br/>    if zero_count == one_count:<br/>         return y[neighbours[0][1]]<br/>    return 1 if one_count &gt; zero_count else 0</span></pre><p id="29da" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">该函数将k个最近邻作为输入。<strong class="lw iu">邻居</strong>中的每条记录都包含距输入点的距离及其原始id。我们使用id和y数组来获取记录的标签。然后我们检查标签并返回预测的标签。</p><blockquote class="oq"><p id="bb90" class="or os it bd ot ou ov ow ox oy oz mp dk translated">我们已经创建了所需的助手函数。现在我们将它们与一些streamlit函数结合起来。令人兴奋的东西！😎</p></blockquote><h1 id="cd45" class="lc ld it bd le lf lg lh li lj lk ll lm jz pa ka lo kc pb kd lq kf pc kg ls lt bi translated">必需的库</h1><p id="050b" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">我们将使用Plotly来绘制我们的图形，因为Plotly绘制交互式图形。对于我们的数据集，我们将从sklearn.datasets导入一个数据集。</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="7dad" class="mq ld it oe b gy oi oj l ok ol">import streamlit as st<br/>import pandas as pd<br/>from sklearn.datasets import make_blobs<br/>import plotly.express as px<br/>import plotly.graph_objects as go</span></pre><p id="6860" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">我将把教程的剩余部分分成三个部分</p><ol class=""><li id="68d8" class="nc nd it lw b lx nu ma nv md on mh oo ml op mp pd ni nj nk bi translated">用户输入</li><li id="f741" class="nc nd it lw b lx nl ma nm md nn mh no ml np mp pd ni nj nk bi translated">导入数据集并将其可视化</li><li id="71e7" class="nc nd it lw b lx nl ma nm md nn mh no ml np mp pd ni nj nk bi translated">可视化预测</li></ol><h1 id="3aeb" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">用户输入</h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="pf pg di ph bf pi"><div class="gh gi pe"><img src="../Images/a22fc0a36f18bf9b7f985c58cf50c664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Us1cYJFJn45oDca21Cc91A.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">App截图</p></figure><p id="8587" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">我们将使用streamlit的<strong class="lw iu"> title </strong>方法显示一个标题，使用<strong class="lw iu"> slider </strong>方法创建一个数字滑块来获取用户的输入。由于我们的数据是标准化的，我们希望输入也是标准化的。因此，我们限制用户输入0到1之间的值。我们还可以从用户那里获取输入，并使用数据集中的最小和最大值来规范化输入。</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="9856" class="mq ld it oe b gy oi oj l ok ol">st.title("KNN Visualize")</span><span id="ca1a" class="mq ld it oe b gy pj oj l ok ol">x_input = st.slider("Choose X input", <em class="nt">min_value</em>=0.0, <em class="nt">max_value</em>=1.0,<em class="nt">key</em>='x')</span><span id="bbd6" class="mq ld it oe b gy pj oj l ok ol">y_input = st.slider("Choose Y input", <em class="nt">min_value</em>=0.0, <em class="nt">max_value</em>=1.0,<em class="nt">key</em>='y')</span><span id="85af" class="mq ld it oe b gy pj oj l ok ol">k = st.slider("Choose value of K", <em class="nt">min_value</em>=1, <em class="nt">max_value</em>=10,<em class="nt">key</em>='k')</span><span id="75e4" class="mq ld it oe b gy pj oj l ok ol">input = (x_input,y_input)</span></pre><p id="ebd6" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">每次滑块值更改时，整个python脚本都会重新运行，变量将根据滑块包含新值。</p><h1 id="6da2" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">导入数据集并将其可视化</h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/4861da26ee8af2e7edc4c203ad2f28cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*4ksG_OVow9gH12Ph1TD5cw.jpeg"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">App截图</p></figure><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="b9d7" class="mq ld it oe b gy oi oj l ok ol">x , y = make_blobs(<em class="nt">n_samples</em> = 100 , <em class="nt">n_features</em> = 2 , <em class="nt">centers</em> = 2, <em class="nt">random_state</em>= 2)</span></pre><p id="8835" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated"><strong class="lw iu"> make_blobs </strong>函数为我们创建了一个数据集，它看起来类似于上图中的分布。在现实世界中，数据集不会如此合作，但这个数据集现在已经足够了。我建议你使用<strong class="lw iu"> matplotlib </strong>绘制一个散点图，看看数据的分布情况。</p><p id="8d5b" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated"><strong class="lw iu"> x </strong>包含特性，<strong class="lw iu"> y </strong>包含各自的标签</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="8822" class="mq ld it oe b gy oi oj l ok ol"># Normalizing Data<br/>x[:,0] = min_max_normalize(x[:,0])<br/>x[:,1] = min_max_normalize(x[:,1])</span><span id="edda" class="mq ld it oe b gy pj oj l ok ol"># Dataframe<br/>df = pd.DataFrame(x , <em class="nt">columns</em> = ['Feature1' , 'Feature2'] )<br/>df['Label'] = y</span><span id="1f42" class="mq ld it oe b gy pj oj l ok ol">st.dataframe(df)</span></pre><p id="79b3" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">首先，我们使用之前创建的规范化辅助函数来规范化我们的数据。然后我们结合x和y数组来创建一个数据帧。我们使用streamlit的<strong class="lw iu">数据帧</strong>方法来查看数据帧。</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="a17f" class="mq ld it oe b gy oi oj l ok ol"># Initial Data Plot</span><span id="85bb" class="mq ld it oe b gy pj oj l ok ol">fig = px.scatter(df, <em class="nt">x</em> = 'Feature1' , <em class="nt">y</em>='Feature2', <em class="nt">symbol</em>='Label',<em class="nt">symbol_map</em>={'0':'square-dot' , '1':'circle'})</span><span id="a749" class="mq ld it oe b gy pj oj l ok ol">fig.add_trace(<br/>    go.Scatter(<em class="nt">x</em>= [input[0]], <em class="nt">y</em>=[input[1]], <em class="nt">name</em> = "Point to  Classify", )<br/>)</span><span id="c227" class="mq ld it oe b gy pj oj l ok ol">st.plotly_chart(fig)</span></pre><p id="f5b1" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">你可以阅读<a class="ae pl" href="https://plotly.com/python/line-and-scatter/" rel="noopener ugc nofollow" target="_blank"> Plotly的文档</a>来更好的理解上面的代码。我们用刚刚创建的数据帧的散点图创建一个图形。我们还添加了输入点，以便更好地理解它相对于数据集中其他点的位置。Streamlit的<strong class="lw iu"> plotly_chart </strong>方法以plotly图形为参数，在我们的app上绘制交互图形。</p><h1 id="3124" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated"><strong class="ak">预测并可视化它</strong></h1><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/0e541cd7f8e958ae75956d8e05b4a1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJjHc8-PmeMFD079JkWE8g.jpeg"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">App截图</p></figure><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="b0e6" class="mq ld it oe b gy oi oj l ok ol">#Finding Nearest Neighbours</span><span id="7301" class="mq ld it oe b gy pj oj l ok ol">predicted_label , nearest_neighbours, far_neighbours = find_nearest(x ,y , input ,k)</span><span id="375e" class="mq ld it oe b gy pj oj l ok ol">st.title('Prediction')</span><span id="13c9" class="mq ld it oe b gy pj oj l ok ol">st.subheader('Predicted Label : {}'.format(predicted_label))</span></pre><p id="0bbf" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">我们使用我们之前创建的find_nearest函数来获得预测的标签和id、k个最近邻居和远邻居的距离。</p><p id="fa4a" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">我们显示预测的标签us streamlit的<strong class="lw iu">子标题</strong>方法</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="4fbb" class="mq ld it oe b gy oi oj l ok ol">nearest_neighbours = [[neighbour[1],x[neighbour[1],0],x[neighbour[1],1],neighbour[0],y[neighbour[1]]] for neighbour in nearest_neighbours]</span><span id="bc1e" class="mq ld it oe b gy pj oj l ok ol">nearest_neighbours = pd.DataFrame(nearest_neighbours , <em class="nt">columns</em> = ['id','Feature1','Feature2','Distance','Label'])</span><span id="7843" class="mq ld it oe b gy pj oj l ok ol">st.dataframe(nearest_neighbours)</span></pre><p id="0bfb" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">上述代码基本上使用最近邻的id，并将id、距离与记录及其标注的feature1、feature2值相结合。我们使用组合列表来创建包含最近邻居信息的数据帧。然后我们使用streamlit的dataframe方法来显示它。这个数据框架将帮助我们理解下面的图表。</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="57e9" class="mq ld it oe b gy oi oj l ok ol">far_neighbours = [[neighbour[1],x[neighbour[1],0],x[neighbour[1],1],neighbour[0],y[neighbour[1]]] for neighbour in far_neighbours]</span><span id="3932" class="mq ld it oe b gy pj oj l ok ol">far_neighbours = pd.DataFrame(far_neighbours , <em class="nt">columns</em> = ['id','Feature1','Feature2','Distance','Label'])</span><span id="22cc" class="mq ld it oe b gy pj oj l ok ol">fig2 = px.scatter(far_neighbours,<em class="nt">x</em>='Feature1',<em class="nt">y</em>='Feature2',<em class="nt">symbol</em>='Label',<em class="nt">symbol_map</em>={'0':'square-dot' , '1':'circle'})</span></pre><p id="7008" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">我们为远邻居创建一个类似的数据帧。我们使用Plotly来绘制散点图。我们现在将添加输入和将输入连接到其k个最近邻居的线。</p><pre class="kr ks kt ku gt od oe of og aw oh bi"><span id="dec0" class="mq ld it oe b gy oi oj l ok ol">for index,neighbour in nearest_neighbours.iterrows():<br/>    fig2.add_trace(<br/>       go.Scatter( <em class="nt">x</em>=[input[0], neighbour['Feature1']], <em class="nt">y</em>=[input[1],<br/>       neighbour['Feature2']],<em class="nt">mode</em>='lines+markers' , <em class="nt">name</em> = 'id<br/>       {}'.format(<em class="nt">int</em>(neighbour['id'])) )<br/>    )</span><span id="7f4c" class="mq ld it oe b gy pj oj l ok ol">st.plotly_chart(fig2)</span></pre><p id="25b2" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">我们迭代每个邻居，并在邻居和我们创建的图形的输入点之间添加一条线。最后，我们使用<strong class="lw iu"> plotly_chart </strong>方法绘制图形。</p><blockquote class="oq"><p id="52bb" class="or os it bd ot ou ov ow ox oy oz mp dk translated">就这样👏我们从头开始创建了一个KNN分类器，并创建了一个Streamlit应用程序来可视化它</p></blockquote><p id="9600" class="pw-post-body-paragraph lu lv it lw b lx pn ju lz ma po jx mc md pp mf mg mh pq mj mk ml pr mn mo mp im bi translated">如果您有兴趣部署您的streamlit应用程序，请查看我的教程。</p><p id="2b3f" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">你可以在这里找到GitHub回购<a class="ae pl" href="https://github.com/rahulbanerjee26/KNN-Streamlit" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="49f0" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated"><strong class="lw iu">我对机器学习的世界还是相当陌生的，如果你发现任何错误或任何可以优化的代码，请让我知道！我总是乐于接受反馈😃</strong></p></div><div class="ab cl ps pt hx pu" role="separator"><span class="pv bw bk pw px py"/><span class="pv bw bk pw px py"/><span class="pv bw bk pw px"/></div><div class="im in io ip iq"><p id="9dc9" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">我最近用WordPress创建了一个博客，如果你能看看的话，我会很高兴的😃</p><div class="pz qa gp gr qb qc"><a href="https://realpythonproject.com/" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">Python项目教程-使用这些Python项目教程改进您的简历/作品集。</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">使用Streamlit共享部署您的机器学习Web应用程序在我以前的文章中，我谈到过构建一个…</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">realpythonproject.com</p></div></div></div></a></div><p id="826f" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">在LinkedIn上与我联系</p><div class="pz qa gp gr qb qc"><a href="https://www.linkedin.com/in/rahulbanerjee2699/" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">Rahul baner JEE——产品工程实习生——EY | LinkedIn</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">查看Rahul Banerjee在世界上最大的职业社区LinkedIn上的个人资料。拉胡尔有4个工作列在他们的…</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">www.linkedin.com</p></div></div><div class="ql l"><div class="qm l qn qo qp ql qq kw qc"/></div></div></a></div><p id="3901" class="pw-post-body-paragraph lu lv it lw b lx nu ju lz ma nv jx mc md nx mf mg mh nz mj mk ml ob mn mo mp im bi translated">在Twitter上与我联系</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="qr qs l"/></div></figure></div></div>    
</body>
</html>