<html>
<head>
<title>How to Handle Missing Data with Python and KNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python和KNN处理缺失数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/missing-value-imputation-with-python-and-k-nearest-neighbors-308e7abd273d?source=collection_archive---------16-----------------------#2020-10-21">https://towardsdatascience.com/missing-value-imputation-with-python-and-k-nearest-neighbors-308e7abd273d?source=collection_archive---------16-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e7e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用机器学习算法处理缺失数据</h2></div><p id="c27e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缺失值插补并不是一项很难完成的任务。方法范围从简单的平均值插补和完全删除观察到更先进的技术，如<a class="ae le" rel="noopener" target="_blank" href="/stop-using-mean-to-fill-missing-data-678c0d396e22">小鼠</a>。如今，更具挑战性的任务是选择使用哪种方法。今天我们将探索一种简单而高效的估算缺失数据的方法——KNN算法。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/7233cd2aeb245fb85ec100b05e25683f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ull_i8m7a16nTEbw.jpg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><a class="ae le" href="https://www.freepik.com/photos/background" rel="noopener ugc nofollow" target="_blank">背景照片</a>由<a class="ae le" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank"> freepik </a>创作</p></figure><p id="1ca8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">KNN代表<em class="lv">K-最近邻</em>，这是一种基于定义的最近邻数量进行预测的简单算法。它计算要分类的实例与训练集中所有其他实例之间的距离。您可以从这里了解如何从头开始实现它:</p><div class="lw lx gp gr ly lz"><a rel="noopener follow" target="_blank" href="/lets-make-a-knn-classifier-from-scratch-e73c43da346d"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">让我们从头开始制作一个KNN分类器</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">你只需要一点钱和一点时间。包括源代码。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn lp lz"/></div></div></a></div><p id="47cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顾名思义，我们不会将该算法用于分类目的，而是用于填充缺失值。本文将使用房价数据集，这是一个简单而著名的数据集，只有500多个条目。这里可以下载<a class="ae le" href="https://www.kaggle.com/arslanali4343/real-estate-dataset" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b2bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章的结构如下:</p><ul class=""><li id="ad82" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated">数据集加载和浏览</li><li id="f867" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">KNN插补</li><li id="8fed" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">估算优化</li><li id="a080" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">结论</li></ul></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="704c" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">数据集加载和浏览</h1><p id="1fa2" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">如前所述，您可以通过<a class="ae le" href="https://www.kaggle.com/arslanali4343/real-estate-dataset" rel="noopener ugc nofollow" target="_blank">链接</a>下载房屋数据集。此外，确保你已经进口了<em class="lv">熊猫</em>和<em class="lv">熊猫</em>。这是前几行的样子:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi og"><img src="../Images/ccef2eae3e4e3cbc804c47cc236bb750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7RJ_m9RN3AoE5msgekDxQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="50d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，数据集的缺失值非常少，一个属性中只有五个缺失值:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oh"><img src="../Images/1d90d0bbef7ba35dc5cc507881c02b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*ZgdZJYHzljhqygpAuDyefA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="6b94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们改变这一点。这不是你通常会做的事情，但是我们需要更多的缺失值。首先，让我们创建两个随机数数组，范围从1到数据集的长度。第一个数组有35个元素，第二个有20个元素(任意选择):</p><pre class="lg lh li lj gt oi oj ok ol aw om bi"><span id="29ab" class="on nk it oj b gy oo op l oq or">i1 = np.random.choice(a=df.index, size=35)<br/>i2 = np.random.choice(a=df.index, size=20)</span></pre><p id="522f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是第一个数组的样子:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi os"><img src="../Images/b742a35ef9757fa22f183cb934318399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a46gBCkwhwr18aFb6_EVFQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="9879" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你的数组会有所不同，因为随机过程是随机的。接下来，我们将用NANs替换特定指数的现有值。方法如下:</p><pre class="lg lh li lj gt oi oj ok ol aw om bi"><span id="3ce0" class="on nk it oj b gy oo op l oq or">df.loc[i1, 'INDUS'] = np.nan<br/>df.loc[i2, 'TAX'] = np.nan</span></pre><p id="3eca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们再次检查丢失的值—这一次，计数不同:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/812e2742073b21635d3ac384fbba28c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*IEvp0MQ2DMdSlc48zh6GkQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="40da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们从估算开始所需要的。让我们在下一节做这件事。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="55d6" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">KNN插补</h1><p id="4272" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">整个插补归结为4行代码，其中一行是库导入。我们需要来自<code class="fe ou ov ow oj b">sklearn.impute</code>的<code class="fe ou ov ow oj b">KNNImputer</code>，然后以一种众所周知的Scikit-Learn方式创建它的一个实例。该类需要一个强制参数—<code class="fe ou ov ow oj b">n_neighbors</code>。它告诉估算者参数k的大小。</p><p id="0d5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们选择一个任意的数字3。我们稍后将优化这个参数，但是3已经足够好了。接下来，我们可以在我们的估算器上调用<code class="fe ou ov ow oj b">fit_transform</code>方法来估算缺失数据。</p><p id="0de1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们将把得到的数组转换成一个<code class="fe ou ov ow oj b">pandas.DataFrame</code>对象，以便于解释。代码如下:</p><pre class="lg lh li lj gt oi oj ok ol aw om bi"><span id="1e88" class="on nk it oj b gy oo op l oq or">from sklearn.impute import KNNImputer<br/><br/>imputer = KNNImputer(n_neighbors=3)<br/>imputed = imputer.fit_transform(df)<br/>df_imputed = pd.DataFrame(imputed, columns=df.columns)</span></pre><p id="f05a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那不是很容易吗？现在让我们检查缺失值:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/7ffa21d1762ea4883609c912ea07fcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*j7jG4kQ3mJO_GndUAuqyrA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="7f4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不出所料，一个都没有。然而，还有一个问题——<strong class="kk iu">我们如何为K选择正确的值？</strong></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="ee7e" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">估算优化</h1><p id="3945" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">由于目标变量是连续的(MEDV)，该住房数据集旨在通过回归算法进行预测建模。这意味着我们可以训练许多预测模型，其中缺失值用不同的K值进行估算，并看看哪一个执行得最好。</p><p id="cee9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是首先，进口。我们需要从Scikit-Learn获得一些东西——将数据集分成训练和测试子集，训练模型，并验证它。我们选择了<em class="lv">随机森林</em>算法进行训练，但是这个决定又是任意的。RMSE被用于验证:</p><pre class="lg lh li lj gt oi oj ok ol aw om bi"><span id="8262" class="on nk it oj b gy oo op l oq or">from sklearn.model_selection import train_test_split<br/>from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import mean_squared_error<br/><br/>rmse = lambda y, yhat: np.sqrt(mean_squared_error(y, yhat))</span></pre><p id="2262" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是执行优化所需的步骤:</p><ol class=""><li id="69e2" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld oy mu mv mw bi translated">迭代K的可能范围——1到20之间的所有奇数都可以</li><li id="69c5" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld oy mu mv mw bi translated">使用当前K值进行插补</li><li id="0310" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld oy mu mv mw bi translated">将数据集分成训练和测试子集</li><li id="4d9d" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld oy mu mv mw bi translated">符合随机森林模型</li><li id="edff" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld oy mu mv mw bi translated">在测试集上预测</li><li id="fa3d" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld oy mu mv mw bi translated">使用RMSE评估</li></ol><p id="7b2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这听起来很多，但归结起来大约有15行代码。以下是片段:</p><pre class="lg lh li lj gt oi oj ok ol aw om bi"><span id="3325" class="on nk it oj b gy oo op l oq or">def optimize_k(data, target):<br/>    errors = []<br/>    for k in range(1, 20, 2):<br/>        imputer = KNNImputer(n_neighbors=k)<br/>        imputed = imputer.fit_transform(data)<br/>        df_imputed = pd.DataFrame(imputed, columns=df.columns)<br/>        <br/>        X = df_imputed.drop(target, axis=1)<br/>        y = df_imputed[target]<br/>        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)<br/><br/>        model = RandomForestRegressor()<br/>        model.fit(X_train, y_train)<br/>        preds = model.predict(X_test)<br/>        error = rmse(y_test, preds)<br/>        errors.append({'K': k, 'RMSE': error})<br/>        <br/>    return errors</span></pre><p id="c0ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以用修改后的数据集(3列中缺少值)调用<code class="fe ou ov ow oj b">optimize_k</code>函数，并传入目标变量(MEDV):</p><pre class="lg lh li lj gt oi oj ok ol aw om bi"><span id="dc51" class="on nk it oj b gy oo op l oq or">k_errors = optimize_k(data=df, target='MEDV')</span></pre><p id="15f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！<code class="fe ou ov ow oj b">k_errors</code>数组看起来像这样:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/6273d613045a493b67075a37b0de899f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*4JKeHZy0EfQtvgM96KB6pg.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="5f3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，直观地表示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pa"><img src="../Images/8567a3bcd4cfcce6be73c8781b9b572d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*moSRTh6pW8BklKQo52z_XQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="d141" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来<strong class="kk iu"> K=15 </strong>是给定范围内的最佳值，因为它产生的误差最小。我们将不讨论错误的解释，因为这超出了本文的范围。让我们在下一部分总结一下。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="673e" class="nj nk it bd nl nm nn no np nq nr ns nt jz nu ka nv kc nw kd nx kf ny kg nz oa bi translated">离别赠言</h1><p id="02f9" class="pw-post-body-paragraph ki kj it kk b kl ob ju kn ko oc jx kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">缺失数据插补很容易，至少是编码部分。是<strong class="kk iu">推理</strong>让它变得困难——理解哪些属性应该被估算，哪些不应该被估算。例如，由于客户没有使用该类型的服务，可能会丢失一些值，因此进行插补毫无意义。</p><p id="7a40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">咨询领域专家并研究该领域永远是一条路要走。实际的编码很容易。</p><p id="9926" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://mailchi.mp/46a3d2989d9b/bdssubscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">加入我的私人邮件列表，获取更多有用的见解。</strong>T3】</a></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="15b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">喜欢这篇文章吗？成为</em> <a class="ae le" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="lv">中等会员</em> </a> <em class="lv">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="lw lx gp gr ly lz"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">通过我的推荐链接加入Medium-Dario rade ci</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="pb l mk ml mm mi mn lp lz"/></div></div></a></div></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="7055" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">原载于2020年10月21日https://betterdatascience.com</em><a class="ae le" href="https://betterdatascience.com/impute-missing-data-with-python-and-knn/" rel="noopener ugc nofollow" target="_blank"><em class="lv"/></a><em class="lv">。</em></p></div></div>    
</body>
</html>