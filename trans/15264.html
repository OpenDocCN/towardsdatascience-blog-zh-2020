<html>
<head>
<title>Shortest Paths and Dijkstra’s Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最短路径和Dijkstra算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/shortest-paths-and-dijkstras-algorithm-68c9ec30eff0?source=collection_archive---------24-----------------------#2020-10-20">https://towardsdatascience.com/shortest-paths-and-dijkstras-algorithm-68c9ec30eff0?source=collection_archive---------24-----------------------#2020-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b6e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">地球上最经典的图形算法，解释。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45978f8e03965deace9e13b5ebe4d0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLy3oWIbLWv2ARIjX_uPIQ.png"/></div></div></figure><p id="fe51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题的经典表述是:</p><p id="785f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果给我一个节点图，每个节点都与其他几个节点相连，并且连接的距离不同，那么从图中的一个节点开始，到图中每个节点的最短路径是什么？</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ff2c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">深度优先</h1><p id="8e07" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">为了实现Dijkstra算法，我们首先需要定义一个节点和一条边:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0a67" class="mz ly it mv b gy na nb l nc nd">class Node:<br/>    def __init__(self, value):<br/><br/>        self.value = value<br/>        self.edges = set()<br/><br/>        self.distance = -1<br/><br/>    @staticmethod<br/>    def add_edge(a, b, dist):<br/>        a.edges.add((b, dist))<br/>        b.edges.add((a, dist))</span></pre><p id="c714" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本例中，我定义了一个节点，它包含一个值(基本上是一个id)，一个初始化为-1(无穷大)的距离。此外，该节点包含一个边列表，每个边都是该边连接到的目标节点(自自身)和到目标节点的距离的元组。</p><p id="a09d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，我该如何填充从一个起始节点到图中每个节点的最短距离呢？</p><p id="3846" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上很简单。在起始节点，我将其距离更新为0，并且对于该节点具有的每条边，如果目标节点未被访问(距离= -1)或者目标节点的当前距离大于新距离，我递归地将目标节点的距离更新为当前节点的距离加上边距离:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="902c" class="mz ly it mv b gy na nb l nc nd">def update_distance(self, dist):<br/><br/>    if self.distance &lt; 0 or dist &lt; self.distance:<br/><br/>        self.distance = dist<br/>        for e in self.edges:<br/>            e[0].update_distance(dist + e[1])</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="d053" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将所有这些与一个示例图放在一起:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45978f8e03965deace9e13b5ebe4d0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLy3oWIbLWv2ARIjX_uPIQ.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">节点= [1，2，3，4] <br/>边= [(1，2，1)，(1，3，10)，(1，4，20)，(2，3，30)，(2，4，40)，(3，4，50)]</p></figure><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="db8f" class="mz ly it mv b gy na nb l nc nd">class Node:<br/>    def __init__(self, value):<br/><br/>        self.value = value<br/>        self.edges = set()<br/><br/>        self.distance = -1<br/><br/>    @staticmethod<br/>    def add_edge(a, b, dist):<br/>        a.edges.add((b, dist))<br/>        b.edges.add((a, dist))<br/><br/>    def update_distance(self, dist):<br/><br/>        if self.distance &lt; 0 or dist &lt; self.distance:<br/><br/>            self.distance = dist<br/>            for e in self.edges:<br/>                e[0].update_distance(dist + e[1])<br/><br/><br/>def create_graph1():<br/><br/>    node1 = Node(1)<br/>    node2 = Node(2)<br/>    node3 = Node(3)<br/>    node4 = Node(4)<br/><br/>    Node.add_edge(node1, node2, 1)<br/>    Node.add_edge(node1, node3, 10)<br/>    Node.add_edge(node1, node4, 20)<br/>    Node.add_edge(node2, node3, 30)<br/>    Node.add_edge(node2, node4, 40)<br/>    Node.add_edge(node3, node4, 50)<br/><br/>    return [node1, node2, node3, node4]<br/><br/><br/>def print_nodes(nodes):<br/><br/>    print('print nodes --')<br/>    for node in nodes:<br/>        print(f'value: {node.value}, distance: {node.distance}')<br/><br/><br/>nodes = create_graph1()<br/>nodes[0].update_distance(0) # set start node distance 0<br/>print_nodes(nodes)</span><span id="2769" class="mz ly it mv b gy ni nb l nc nd">'''<br/>print nodes --<br/>value: 1, distance: 0<br/>value: 2, distance: 1<br/>value: 3, distance: 10<br/>value: 4, distance: 20<br/>'''</span></pre><p id="288b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我将从节点2到节点4的距离更新为1，那么节点4的最短距离应该是2，因为现在我可以从节点1到2，然后从2到4，距离为2。我们来看看是不是这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e0863e50dd2685d5f6dbd556d344b54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDFyDZAhqGNUFdUs8BaUeg.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">节点= [1，2，3，4] <br/>边= [(1，2，1)，(1，3，10)，(1，4，20)，(2，3，30)，(2，4，1)，(3，4，50)]</p></figure><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0fcc" class="mz ly it mv b gy na nb l nc nd">def create_graph2():<br/><br/>    node1 = Node(1)<br/>    node2 = Node(2)<br/>    node3 = Node(3)<br/>    node4 = Node(4)<br/><br/>    Node.add_edge(node1, node2, 1)<br/>    Node.add_edge(node1, node3, 10)<br/>    Node.add_edge(node1, node4, 20)<br/>    Node.add_edge(node2, node3, 30)<br/>    Node.add_edge(node2, node4, 1)<br/>    Node.add_edge(node3, node4, 50)<br/><br/>    return [node1, node2, node3, node4]</span><span id="9d75" class="mz ly it mv b gy ni nb l nc nd">nodes = create_graph2()<br/>print_nodes(nodes)<br/>nodes[0].update_distance(0)<br/>print_nodes(nodes)</span><span id="0899" class="mz ly it mv b gy ni nb l nc nd">'''<br/>print nodes --<br/>value: 1, distance: 0<br/>value: 2, distance: 1<br/>value: 3, distance: 10<br/>value: 4, distance: 2<br/>'''</span></pre><p id="d467" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来有用！</p><h1 id="beed" class="lx ly it bd lz ma nj mc md me nk mg mh jz nl ka mj kc nm kd ml kf nn kg mn mo bi translated">性能分析，深度优先</h1><p id="709f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">那还不算太糟，是吗？</p><p id="f75c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是让我们暂停一下，想想这个过程需要多长时间。</p><p id="8aa8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从起始节点开始，如果起始节点连接到所有其他节点，那么update_distance中的第一个循环是O(n-1)，其中n是图中的节点数。在update_distance内部，我们在连接的目标节点上递归调用update_distance，在最坏的情况下，目标节点也可能连接到所有其他节点，并且只有一条边保证不会被遍历(与当前节点的边)，因此第二次递归update_distance是O(n-2)。</p><p id="5bf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至此，不难认识到整体算法的复杂度为O((n-1) * (n-2) * … * 2 * 1) = O(n！)在最坏的情况下。不太好。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ef9c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">最小堆</h1><p id="7028" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">看起来我们有一些改进要做，这就是Dijkstra算法要做的。</p><p id="b8a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从一个很巧妙的观察就能理解算法。在上面的图2中，节点1直接连接到节点2、3、4。其中最小的距离是到节点2的距离，为1。现在你知道到节点2的最短距离最多是1，还能再短一点吗？答案是否定的，因为从节点1到节点2的任何间接路径都必须经过节点3或节点4，这两个节点的距离都大于1。</p><p id="63c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常重要的见解，因为这意味着在处理完节点2之后，我不必再查看节点2，因为知道到节点2的最短距离是1。这避免了检查从节点1到节点3到节点2的距离的冗余，因为我们肯定知道该距离将大于节点2的现有距离。</p><p id="10de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实现这一点，我们采用了最小堆数据结构。它的实现可以有很大的不同，但是操作很简单，我可以把任何对象放到它上面，当我请求堆返回一个对象时，它总是返回带有最小关联键的对象。</p><p id="de57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是Dijkstra算法的最小堆实现:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="21da" class="mz ly it mv b gy na nb l nc nd">import heapq as hq<br/><br/>class Node:<br/>    def __init__(self, value):<br/><br/>        self.value = value<br/>        self.edges = set()<br/><br/>        self.distance = -1<br/>        self.visited = False<br/><br/>    @staticmethod<br/>    def add_edge(a, b, dist):<br/>        a.edges.add((b, dist))<br/>        b.edges.add((a, dist))<br/><br/><br/>def calc_distance(start):<br/><br/>    h = []<br/><br/>    start.distance = 0<br/><br/>    hq.heappush(h, (start.distance, start))<br/><br/>    while len(h) &gt; 0:<br/><br/>        cur = hq.heappop(h)<br/><br/>        # check if the nodes has been updated<br/>        if cur[0] != cur[1].distance:<br/>            continue<br/><br/>        for e in cur[1].edges:<br/>            new_distance = cur[1].distance + e[1]<br/><br/>            if e[0].distance &lt; 0 or new_distance &lt; e[0].distance:<br/>                e[0].distance = new_distance<br/>                hq.heappush(h, (new_distance, e[0]))<br/><br/><br/>def create_graph1():<br/><br/>    node1 = Node(1)<br/>    node2 = Node(2)<br/>    node3 = Node(3)<br/>    node4 = Node(4)<br/><br/>    Node.add_edge(node1, node2, 1)<br/>    Node.add_edge(node1, node3, 10)<br/>    Node.add_edge(node1, node4, 20)<br/>    Node.add_edge(node2, node3, 30)<br/>    Node.add_edge(node2, node4, 1)<br/>    Node.add_edge(node3, node4, 50)<br/><br/>    return [node1, node2, node3, node4]<br/><br/><br/>def print_nodes(nodes):<br/><br/>    print('print nodes --')<br/>    for node in nodes:<br/>        print(f'value: {node.value}, distance: {node.distance}')<br/><br/><br/>nodes = create_graph1()<br/>print_nodes(nodes)<br/>calc_distance(nodes[0])<br/>print_nodes(nodes)</span><span id="3d2f" class="mz ly it mv b gy ni nb l nc nd">'''</span><span id="eb39" class="mz ly it mv b gy ni nb l nc nd">print nodes --<br/>value: 1, distance: 0<br/>value: 2, distance: 1<br/>value: 3, distance: 10<br/>value: 4, distance: 2<br/>'''</span></pre><p id="f3ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有用！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="018c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">性能分析，最小堆</h1><p id="552f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">让我们稍微讨论一下新算法的性能。</p><p id="b617" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从第一个节点开始，我们将其距离设置为零，并将其添加到min堆中，将其当前距离作为排序关键字。然后，只要min堆不为空，就不断地弹出具有最小键的节点，循环遍历其所有连接的节点，并更新它们的最短距离，如果新距离更短，则将它们推送到min堆上。</p><p id="64dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要注意的一件重要事情是循环中的以下几行:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0427" class="mz ly it mv b gy na nb l nc nd"># check if the nodes has been updated<br/>if cur[0] != cur[1].distance:<br/>    continue</span></pre><p id="420c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将检查堆上对象的键是否与节点的当前最短距离相同。考虑以下情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/896a57c8efe2899ddd64b888c438917a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QM_p6rOY5WQUONHnwvjBQw.png"/></div></div><p class="ne nf gj gh gi ng nh bd b be z dk translated">节点= [1，2，3，4] <br/>边= [(1，2，1)，(1，3，4)，(2，4，10)，(3，4，2)]</p></figure><p id="604b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我有4个节点的图:1，2，3，4</p><p id="9874" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">节点1 —节点2，距离1</p><p id="d197" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">节点1 —节点3，距离4</p><p id="c55c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">节点2 —节点4，距离10</p><p id="d47f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">节点3 —节点4，距离2</p><p id="c5fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Start:将开始节点推到堆上，距离为0</p><p id="4e5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[(0，node1_dist0)]</p><p id="11bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">迭代1:在第一次迭代中，最小堆包含键为0的node1，然后弹出它，并将它的邻居添加到堆中。</p><p id="26ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[(1，节点2_dist1)，(4，节点3_dist4)]</p><p id="5db8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">迭代2:去掉node2并添加它的邻居。</p><p id="d166" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[(4，节点3 _分布4)，(11，节点4 _分布11)]</p><p id="1926" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">迭代3:删除节点3并添加其邻居。</p><p id="6619" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是等等！节点3的邻居节点4已经在队列中，唯一的区别是它的最短距离现在更新为6:</p><p id="fc66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[(6，节点4_dist6)，(11，节点4_dist6)]</p><p id="8d21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以看到，堆中实际上有两个节点4的条目，一个具有键6，一个具有键11，只有一个条目的键等于当前节点4的距离值。</p><p id="4fbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一次迭代中，具有键6的条目被弹出，因为它是最小的键，并且它的邻居被处理，但是因为它的邻居都已经具有最短的距离，所以它们不会进入队列。只剩下一个条目:</p><p id="3250" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[(11，node4_dist6)]</p><p id="1722" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，您显然想忽略它，因为node4已经被处理了，并且您可以知道的方式是键和node4的最短距离彼此不相等。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="5641" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于当前已知的最小堆实现，弹出函数是O(log(n))运算。因为如果有边，你将把一个节点推到堆上，所以算法的复杂度是O(e * log(n))，其中e是边的数量。</p><p id="11b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，还有更多。你能拥有的最大边数是多少？如果每个节点都与其他节点相连，图中有n个节点，那么边的总数是n * (n + 1) / 2。所以e实际上是O(n**2)的量级，算法实际上是O((n ** 2) * log(n))的量级</p><p id="7679" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是从上面的例子中可以看出，由于node4有两条边，所以它在堆中出现了两次，如果我们可以将现有的边11更新为6，我们实际上就不必添加它两次。恰好有一种特殊类型的堆允许您这样做。它叫做<a class="ae no" href="https://en.wikipedia.org/wiki/Fibonacci_heap" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">斐波那契堆</strong> </a>。在这种情况下，您可以将键从11个减少到6个，并且在堆中只让node4出现一次，不管有多少条边连接到它。</p><p id="1274" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">斐波那契堆中的decrease关键函数是O(1)，常数运算，所以你的整体复杂度归结为O(n*log(n) + e)。你加e的原因是你必须减少e倍的key。</p><p id="c8aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，如果我们认为原始的最小堆算法具有运行时间为O(log(n))(基本上是用键11弹出节点4条目所花费的时间)的减少键功能，那么原始算法的复杂度可以更精确地定义为O((n + e) * log(n))。</p></div></div>    
</body>
</html>