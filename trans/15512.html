<html>
<head>
<title>Talking to Python from Javascript: Flask and the fetch API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Javascript: Flask和fetch API与Python对话</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/talking-to-python-from-javascript-flask-and-the-fetch-api-e0ef3573c451?source=collection_archive---------2-----------------------#2020-10-26">https://towardsdatascience.com/talking-to-python-from-javascript-flask-and-the-fetch-api-e0ef3573c451?source=collection_archive---------2-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe0b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python处理动态web界面或可视化所需的数据。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e2d1f1888f6abab25f8491f43bc6f7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfJSAMAkQ0cb6smWizGP2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个样本网络— D. Ellis 2020</p></figure><p id="f4d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在数据科学领域，通常需要使用一系列工具，每种工具都与其工作相关。一个需要使用web界面可视化的角色，但是处理Python脚本，通常最好在<a class="ae lu" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> d3 </a>或<a class="ae lu" href="https://threejs.org/" rel="noopener ugc nofollow" target="_blank"> THREE.js </a>中构建一个定制的可视化来显示它，然后根据需要获取数据。本文介绍了如何创建一个简单的flask应用程序，它可以使用Fetch API向web接口提供数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f566" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建烧瓶应用程序</h1><p id="5bc9" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们首先构建一个包含一个空的<code class="fe mz na nb nc b">templates</code>文件夹和一个<code class="fe mz na nb nc b">app.py</code>文件的存储库。</p><h2 id="d7a0" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">App.py</h2><p id="bb90" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们的<code class="fe mz na nb nc b">app.py</code>文件包含创建web界面所需的数据。为此，我们使用flask ( <code class="fe mz na nb nc b">pip install flask</code> ) python库。为此，我们可以使用以下模板:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="b022" class="nd md it nc b gy nt nu l nv nw">########  imports  ##########<br/>from flask import Flask, jsonify, request, render_template<br/>app = Flask(__name__)</span><span id="ba24" class="nd md it nc b gy nx nu l nv nw">#############################<br/># Additional code goes here #<br/>#############################</span><span id="044e" class="nd md it nc b gy nx nu l nv nw">#########  run app  #########<br/>app.run(debug=True)</span></pre><p id="3c92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们首先导入所需的功能、应用程序结构和运行命令来启动应用程序。</p><h2 id="6aca" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">Index.html</h2><p id="f4a2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">定义了flask应用程序后，我们现在需要创建一个模板网页。这可以通过将文件<code class="fe mz na nb nc b">index.html</code>放在模板目录中来完成。</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="847d" class="nd md it nc b gy nt nu l nv nw">&lt;body&gt;<br/>&lt;h1&gt; Python Fetch Example&lt;/h1&gt;<br/>&lt;p id='embed'&gt;<strong class="nc iu">{{embed}}</strong>&lt;/p&gt;</span><span id="084b" class="nd md it nc b gy nx nu l nv nw">&lt;p id='mylog'/&gt;<br/>&lt;body&gt;</span></pre><p id="bf6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们使用它作为模板，所以我们可以对某些关键字使用react风格的替换语法。在这个例子中，下面代码片段中的<code class="fe mz na nb nc b">{{embed}}</code>将被替换为<code class="fe mz na nb nc b">embed_example</code>字符串。</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="86da" class="nd md it nc b gy nt nu l nv nw"><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route(<strong class="nc iu">'/'</strong>)<br/>def home_page():<br/>    example_embed='This string is from python'<br/>    return render_template('index.html', embed=example_embed)</span></pre><p id="b28d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这定义了当到达flask app的主页时运行的代码，需要在 <code class="fe mz na nb nc b">app.py</code> <strong class="la iu">内的</strong> <code class="fe mz na nb nc b">imports</code> <strong class="la iu">和</strong> <code class="fe mz na nb nc b">app.run()</code> <strong class="la iu">行之间添加<strong class="la iu">。</strong></strong></p><h2 id="2f70" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated"><strong class="ak">运行应用程序</strong></h2><p id="0296" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">最后，我们可以运行应用程序，使用<code class="fe mz na nb nc b">python app.py</code>并在web浏览器中导航到<code class="fe mz na nb nc b"><a class="ae lu" href="https://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:5000/</a></code>进行查看。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="deaf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">获取和发布—它们是如何工作的？</h1><p id="3bbc" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在传输数据时，我们依赖于fetch API中的GET和POST函数。这些术语不言自明:</p><ul class=""><li id="d910" class="ny nz it la b lb lc le lf lh oa ll ob lp oc lt od oe of og bi translated">POST是指将信息发送到一个位置，类似于寄信。</li><li id="5223" class="ny nz it la b lb oh le oi lh oj ll ok lp ol lt od oe of og bi translated">GET指的是数据的检索——你知道你有邮件，所以你去邮局领取(索取)。</li></ul><h2 id="976a" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">测试功能</h2><p id="4660" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在<code class="fe mz na nb nc b">app.py</code>中，我们可以为GET请求创建一个URL。下面的代码定义了调用URL时的响应。</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="cbc6" class="nd md it nc b gy nt nu l nv nw"><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('<strong class="nc iu">/test</strong>', methods=['GET', 'POST'])<br/>def testfn():</span><span id="e152" class="nd md it nc b gy nx nu l nv nw">    # GET request<br/>    if request.method == 'GET':<br/>        message = {'greeting':'Hello from Flask!'}<br/>        return jsonify(message)  # serialize and use JSON headers</span><span id="2ad0" class="nd md it nc b gy nx nu l nv nw">    # POST request<br/>    if request.method == 'POST':<br/>        print(request.get_json())  # parse as JSON<br/>        return 'Sucesss', 200</span></pre><p id="54d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一个GET请求之后，我们定义一个包含一个<code class="fe mz na nb nc b">greeting</code>元素的字典并序列化它。接下来，这将被发送回调用的javascript程序。</p><p id="1fd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在将下面的代码添加到<code class="fe mz na nb nc b">app.run()</code>命令之前并执行它之后，我们可以访问<code class="fe mz na nb nc b"><a class="ae lu" href="https://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:5000/</a>test</code>——它应该会产生下面的结果:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="b39b" class="nd md it nc b gy nt nu l nv nw">{<br/>  "greeting": "Hello from Flask!"<br/>}</span></pre><h2 id="1684" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">从Javascript调用数据</h2><p id="d0df" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">现在我们已经设置了服务器端的东西，我们可以使用fetch命令从其中检索数据。为此，我们可以使用如下的<code class="fe mz na nb nc b">fetch</code>承诺:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="2a13" class="nd md it nc b gy nt nu l nv nw">  fetch(<strong class="nc iu">'/test'</strong>)<br/>      .then(function (response) {<br/>          return response.json();<br/>      }).then(function (text) {<br/>          console.log('GET response:');<br/>          console.log(text.greeting); <br/>      });</span></pre><p id="cf95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们对<code class="fe mz na nb nc b">/test</code>运行一个GET请求，它将返回的JSON字符串转换成一个对象，然后将<code class="fe mz na nb nc b">greeting</code>元素打印到web控制台。通常，JavaScript代码应该嵌套在HTML文档中的<code class="fe mz na nb nc b">&lt;script&gt;</code>标记之间。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e131" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从服务器请求数据</h1><p id="60dc" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">现在我们有了一个工作示例，我们可以扩展它以包含实际数据。实际上，这可能涉及访问数据库、解密一些信息或过滤一个表。</p><p id="a25c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于本教程的目的，我们将创建一个数据数组，并从中索引元素:</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="0bb4" class="nd md it nc b gy nt nu l nv nw">######## Example data, in sets of 3 ############<br/>data = list(range(1,300,3))<br/>print (data)</span></pre><h2 id="f1b0" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">设置寻呼呼叫</h2><p id="a199" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在我们的Flask应用程序中，我们可以向GET请求添加可选参数——在本例中，是我们感兴趣的数组索引。这是通过页面URL <code class="fe mz na nb nc b">/getdata/&lt;index_no&gt;</code>中的附加页面扩展指定的。然后，该参数被传递到页面函数中，并在return命令中进行处理(<code class="fe mz na nb nc b">data[int(index_no)]</code>)。</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="b838" class="nd md it nc b gy nt nu l nv nw">######## Data fetch ############<br/><a class="ae lu" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('<strong class="nc iu">/getdata/&lt;index_no&gt;</strong>', methods=['GET','POST'])<br/>def data_get(index_no):<br/>    <br/>    if request.method == 'POST': # POST request<br/>        print(request.get_text())  # parse as text<br/>        return 'OK', 200<br/>    <br/>    else: # GET request<br/>        return 't_in = %s ; result: %s ;'%(index_no, data[int(index_no)])</span></pre><h2 id="76da" class="nd md it bd me ne nf dn mi ng nh dp mm lh ni nj mo ll nk nl mq lp nm nn ms no bi translated">写入提取请求</h2><p id="6a81" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">fetch请求保持不变，只是将GET URL改为包含我们感兴趣的数据元素的索引。这是在<code class="fe mz na nb nc b">index.html</code>的JS脚本中完成的。</p><pre class="kj kk kl km gt np nc nq nr aw ns bi"><span id="aff1" class="nd md it nc b gy nt nu l nv nw">var index = 33;</span><span id="f35a" class="nd md it nc b gy nx nu l nv nw">fetch(<strong class="nc iu">`/getdata/${index}`</strong>)<br/>      .then(function (response) {<br/>          return response.text();<br/>      }).then(function (text) {<br/>          console.log('GET response text:');<br/>          console.log(text); <br/>      });</span></pre><p id="3a6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，我们不是返回一个对象，而是返回一个字符串并解析它。然后可以根据需要在代码中使用它——无论是更新图形还是显示消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="53c8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="ed67" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我们探索了一种使用python提取数据并将其提供给javascript代码进行可视化的方法(替代方法包括web/TCP套接字和文件流)。我们能够创建一个服务器端python代码来预处理或解密数据，并且只向客户端提供所需的信息。</p><p id="fb63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们有不断更新的数据、大型(高资源)数据集或我们不能直接提供给客户端的敏感数据，这是非常有用的。</p><p id="137a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="om">本文中使用的附带示例代码可以在:</em>找到</p><div class="on oo gp gr op oq"><a href="https://github.com/wolfiex/FlaskFetch" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">wolfiex/FlaskFetch</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">使用Fetch API在flask和一个提供服务的网页之间进行通信</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">github.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>