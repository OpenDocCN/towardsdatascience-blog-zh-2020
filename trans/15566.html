<html>
<head>
<title>PySnpTools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PySnpTools</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pysnptools-9038f994fdd7?source=collection_archive---------56-----------------------#2020-10-26">https://towardsdatascience.com/pysnptools-9038f994fdd7?source=collection_archive---------56-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7ed6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Python中读取和操作基因组数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c4c5489e863aee3787b54c5a0b002e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GsDwve66wIS-uDB8"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">国立癌症研究所</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="0b3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PySnpTools是一个Python库，用于读取和操作Python中的基因组数据。它允许用户有效地选择和重新排序个体(行)和SNP位置(列)。然后，它只读取选定的数据。PySnpTools最初是为了支持<a class="ae kv" href="https://fastlmm.github.io/" rel="noopener ugc nofollow" target="_blank">快速LMM</a>——一种全基因组关联研究(GWAS)工具——而开发的，现在支持大内存和集群规模的工作。</p><blockquote class="ls lt lu"><p id="55d4" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><strong class="ky ir">2022年3月22日更新</strong>:更新示例以匹配<a class="ae kv" href="https://nbviewer.org/github/fastlmm/PySnpTools/blob/master/doc/ipynb/paper.ipynb" rel="noopener ugc nofollow" target="_blank">本笔记本</a>。</p></blockquote><h1 id="2d77" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">介绍</h1><p id="076d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当我们开发快速LMM包(1；2;3;4;5;6)，我们厌倦了重新编写代码来支持越来越多的文件格式(<em class="lv">例如</em>，PLINK的Bed，Dat，Pheno等。) (7;8).此外，我们注意到自己重复地进行类似的操作，例如，</p><ul class=""><li id="9ab1" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">读取SNP子集(列)的数据，</li><li id="f17b" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">对我们的表型数据中的个体(行)进行重新排序，以匹配它们在SNP数据中的顺序，以及</li><li id="225d" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">填补缺失数据和规范化数据。</li></ul><p id="1481" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">受NumPy和Pandas的启发，我们创建了PySnpTools，这是一个开源库，使这些操作变得简单。</p><p id="96bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在西雅图的PyData 2015大会上展示了PySnpTools的第一个公开版本。</p><blockquote class="ls lt lu"><p id="e9b5" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">在会议上，Travis oli phant(NumPy的主要创建者)推荐了PySnpTools读取和操作基因组数据的方法(9)。</p></blockquote><p id="18ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">会议结束后不久，希拉里·菲纽肯(麻省理工学院和哈佛大学布罗德研究所菲纽肯实验室的负责人)写信给我们:</p><blockquote class="ls lt lu"><p id="2482" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">“我一直喜欢PySnpTools，并向其他使用Python (10)的统计遗传学家推荐它！”</p></blockquote><p id="4e0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自会议以来，随着FaST-LMM发展到支持多达100万个样本的数据集(6)，我们扩展了PySnpTools以简化:</p><ul class=""><li id="55c1" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">大于内存的数据集</li><li id="c9ff" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">在多个处理器或任何集群上运行循环，以及</li><li id="bdf7" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">在本地或从/向任何远程存储器读写文件。</li></ul><p id="1fb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我们已经使用多线程来加快读床速度，并增加了对BGEN格式的支持。</p><p id="2f08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文讲述了如何安装PySnpTools，并描述了PySnpTools关注的基因组数据。然后给出了核心用法的例子。最后，它列出了PySnpTools的其他特性，并提供了与其他数据集方法的简要比较。</p><h1 id="8d3f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">安装PySnpTools</h1><p id="f4fd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">要使用PySnpTools:</p><p id="06db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">pip install pysnptools</code></p><p id="85fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://github.com/fastlmm/PySnpTools" rel="noopener ugc nofollow" target="_blank">https://github.com/fastlmm/PySnpTools</a>找到Jupyter笔记本、完整的API文档和示例以及源代码。</p><h1 id="e012" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">基因组数据</h1><p id="d2c1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们感兴趣的基因组数据通常由500，000到150万列组成——每个SNP或变体一列(这是已知人类不同的基因组位置)。数据包括每个人的一行。一千到一百万行是典型的。初始数据中的值可能是0、1、2或缺失(代表在一个基因组位置为一个个体测量的次要等位基因的数量)。标准化后，值是64位或32位浮点数，缺少的值用NaN(“非数字”)表示。</p><p id="0f91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图1显示了PySnpTools对基因组数据的内存表示。被称为<code class="fe nk nl nm nn b">iid</code>的两个字符串标识每个个体。一个名为<code class="fe nk nl nm nn b"><strong class="ky ir">sid</strong></code>的字符串识别每个SNP。一种叫做<code class="fe nk nl nm nn b"><strong class="ky ir">val</strong></code>的浮动，告诉一个SNP个体的等位基因数。最后，名为<code class="fe nk nl nm nn b"><strong class="ky ir">pos</strong></code>的三重浮点表示每个SNP的位置(染色体数目、遗传距离和碱基对位置)。对于<code class="fe nk nl nm nn b"><strong class="ky ir">val</strong></code>中的一个给定位置，PySnpTools可以轻松找到对应的<code class="fe nk nl nm nn b"><strong class="ky ir">iid</strong></code>、<code class="fe nk nl nm nn b"><strong class="ky ir">sid</strong></code>、<strong class="ky ir"> </strong> <code class="fe nk nl nm nn b"><strong class="ky ir">pos.</strong></code> <strong class="ky ir"> </strong>而且，对于任何感兴趣的<code class="fe nk nl nm nn b"><strong class="ky ir">iids</strong></code> <strong class="ky ir"> </strong>或<code class="fe nk nl nm nn b"><strong class="ky ir">sids</strong></code> <strong class="ky ir"> </strong>，PySnpTools都可以轻松高效地在<code class="fe nk nl nm nn b"><strong class="ky ir">val</strong></code>中找到对应的位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/4f56db5986fc03532e219e2f8e0e0e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdFvVbhYi0xrgkE-Rp7Hlw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。PySnpTools的基因组数据的内存表示</p></figure><p id="8563" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于表型和协变量数据(<em class="lv">例如</em>，年龄、性别、身高、体重、疾病的存在)，PySnpTools使用相同的表示法。对于这样的数据，<code class="fe nk nl nm nn b"><strong class="ky ir">sid</strong></code> <strong class="ky ir"> </strong>给出特征的名称(<em class="lv">如</em>，“高度”)，而<code class="fe nk nl nm nn b"><strong class="ky ir">pos</strong></code>被忽略。<code class="fe nk nl nm nn b"><strong class="ky ir">val</strong></code> <strong class="ky ir"> </strong>数组作为浮点数，也可以通过0.0和1.0表示二进制数据。我们通过hot-one编码处理分类数据。</p><h1 id="08d1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">读取基因组文件:一个例子</h1><p id="2f39" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">PySnpTools将从文件中读取基因组数据的Python对象称为SnpReader。下面是如何为流行的Bed文件格式创建SnpReader:我们告诉它要读取什么文件以及如何读取。(这个SnpReader还没有从它的文件中读取任何内容。)</p><p id="3bbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="b86c" class="nt ma iq nn b gy nu nv l nw nx"><em class="lv"># Download BED files and return local file name</em><br/><strong class="nn ir">from</strong> <strong class="nn ir">pysnptools.util</strong> <strong class="nn ir">import</strong> example_file<br/>all_bed_file = example_file("doc/ipynb/all.*",endswith="*.bed"</span><span id="cf4f" class="nt ma iq nn b gy ny nv l nw nx"><strong class="nn ir">from pysnptools.snpreader import Bed<br/></strong>snpreader = Bed(<!-- -->all_bed_file<!-- -->, count_A1=True)<br/>print(snpreader)</span></pre><p id="f51a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="caa5" class="nt ma iq nn b gy nu nv l nw nx">Bed("[...]/all.bed",count_A1=True)</span></pre><p id="fa6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以向SNP阅读器询问个体的数量和SNP的数量。我们也可以，例如，要求它为第一个体的<code class="fe nk nl nm nn b"><strong class="ky ir">iid</strong></code> <strong class="ky ir"> </strong>。我们可以另外向它索要最后一个SNP的<code class="fe nk nl nm nn b"><strong class="ky ir">sid</strong></code> <strong class="ky ir"> </strong>。(Bed SnpReader只读取回答这些问题所需的小文件。)</p><p id="8785" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="aca6" class="nt ma iq nn b gy nu nv l nw nx">print(snpreader.iid_count,snpreader.sid_count)<br/>print(snpreader.iid[0])<br/>print(snpreader.sid[-1])</span></pre><p id="8917" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="ed65" class="nt ma iq nn b gy nu nv l nw nx">500 5000<br/>['cid0P0' 'cid0P0']<br/>snp124_m0_.23m1_.08</span></pre><p id="3bba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们可以将所有基因组数据读入内存，创建一个新的SnpReader，称为SnpData。因为SnpData是SnpReader，我们可以再次询问个体和SNP的数量。</p><p id="4228" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="88bb" class="nt ma iq nn b gy nu nv l nw nx">snpdata = snpreader.read()<br/>print(snpdata)<br/>print(snpdata.iid_count, snpdata.sid_count)</span></pre><p id="06bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="47e5" class="nt ma iq nn b gy nu nv l nw nx">SnpData(Bed('all.bed',count_A1=True))<br/>500 5000</span></pre><p id="8968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SnpData是一个SnpReader，它包含一个其他SNP reader没有的额外的<code class="fe nk nl nm nn b"><strong class="ky ir">val</strong></code> <strong class="ky ir"> </strong>属性。<code class="fe nk nl nm nn b"><strong class="ky ir">val</strong></code> <strong class="ky ir"> </strong>属性是基因组数据的(内存中)NumPy数组。</p><p id="a142" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们可以显示前7个个体和前7个SNPs的基因组数据。我们还可以找到所有基因组数据的平均值。</p><p id="abe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="7394" class="nt ma iq nn b gy nu nv l nw nx"><strong class="nn ir">import</strong> <strong class="nn ir">numpy</strong> <strong class="nn ir">as</strong> <strong class="nn ir">np<br/></strong>print(snpdata.val[:7,:7])<br/>print(np.mean(snpdata.val))</span></pre><p id="585b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="41a3" class="nt ma iq nn b gy nu nv l nw nx">[[0. 0. 1. 2. 0. 1. 2.]<br/> [0. 0. 1. 1. 0. 0. 2.]<br/> [0. 0. 1. 2. 1. 0. 0.]<br/> [0. 0. 0. 2. 0. 0. 0.]<br/> [0. 0. 0. 0. 0. 0. 2.]<br/> [0. 0. 1. 0. 0. 0. 2.]<br/> [0. 0. 2. 1. 0. 1. 2.]]<br/>0.521412</span></pre><p id="dd12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我们可以在一行中做所有的事情。</p><p id="c60e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="c84e" class="nt ma iq nn b gy nu nv l nw nx">print(np.mean(Bed(all_bed_file,count_A1=<strong class="nn ir">True</strong>).read().val))</span></pre><p id="1537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="b21b" class="nt ma iq nn b gy nu nv l nw nx">0.521412</span></pre><h1 id="2e64" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">SnpData</h1><p id="b973" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">SnpData，特殊的内存SnpReader，由任何SnpReader的<code class="fe nk nl nm nn b"><strong class="ky ir">read()</strong></code> <strong class="ky ir"> </strong>方法创建。我们还可以从头开始创建SnpData。</p><p id="2ac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们为三个个体和两个SNP创建<code class="fe nk nl nm nn b"><strong class="ky ir">snpdata1</strong></code> <strong class="ky ir"> </strong>。我们用NaN标记一个缺失值，然后求平均值(忽略缺失值)。</p><p id="39a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="0aab" class="nt ma iq nn b gy nu nv l nw nx"><strong class="nn ir">from pysnptools.snpreader import SnpData</strong><br/>snpdata1 = SnpData(iid=[['f1','c1'],['f1','c2'],<br/>                       ['f2','c1']],<br/>                   sid=['snp1','snp2'],<br/>                   val=[[0,1],[2,.5],[.5,np.nan]])<br/>print(np.nanmean(snpdata1.val))</span></pre><p id="0cf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="4378" class="nt ma iq nn b gy nu nv l nw nx">0.8</span></pre><h1 id="0a0d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">在读取前选择并重新排序数据<em class="nz"/></h1><p id="cc58" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设我们只关心前7个个体和前7个SNP的基因组数据。PySnpTools使从磁盘中读取所需的数据变得很容易。我们在read方法之前使用类似NumPy的索引。</p><p id="d2ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="fd2e" class="nt ma iq nn b gy nu nv l nw nx">snpreader = Bed(all_bed_file,count_A1=<strong class="nn ir">True</strong>)<br/>snpdata77 = snpreader[:7,:7].read()<br/>print(snpdata77.val)</span></pre><p id="38bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="153b" class="nt ma iq nn b gy nu nv l nw nx">[[0. 0. 1. 2. 0. 1. 2.]<br/> [0. 0. 1. 1. 0. 0. 2.]<br/> [0. 0. 1. 2. 1. 0. 0.]<br/> [0. 0. 0. 2. 0. 0. 0.]<br/> [0. 0. 0. 0. 0. 0. 2.]<br/> [0. 0. 1. 0. 0. 0. 2.]<br/> [0. 0. 2. 1. 0. 1. 2.]]</span></pre><p id="7d7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">支持所有类似NumPy的花哨索引:切片、布尔、整数列表、负整数(11)。此外，PySnpTools允许同时对行和列进行有趣的索引。</p><p id="bceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将索引附加到任何SnpReader，创建一个新的SnpReader。这里有一个极端的例子。它说，“创造一个阅读器</p><ul class=""><li id="f2d0" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">来自bed格式的文件“all.bed”</li><li id="6a60" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">个体以相反的顺序并且对于每第二个SNP</li><li id="f7a3" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">对于前5个这样的个体和前5个这样的SNP</li><li id="b01d" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">对于第一个和最后一个个体以及第一个、第二个和第五个SNP，</li><li id="6c67" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">然后读。"</li></ul><p id="d9d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样，只从磁盘中读取最终所需的数据。</p><p id="1103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="0d54" class="nt ma iq nn b gy nu nv l nw nx">print(Bed(all_bed_file,count_A1=<strong class="nn ir">True</strong>)[::-1,::2][:5,:5]<br/>       [[0,-1],[True,True,False,False,True]]<br/>       .read().val)</span></pre><p id="60b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="c979" class="nt ma iq nn b gy nu nv l nw nx">[[0. 0. 1.]<br/> [0. 1. 1.]]</span></pre><h1 id="d68c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">通过单个(行)和SNP(列)标识符进行索引</strong></h1><p id="014c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们已经看到了如何使用基于位置的索引来操作SnpReaders。如果我们转而希望通过<code class="fe nk nl nm nn b"><strong class="ky ir">iid</strong></code> <strong class="ky ir"> </strong>(个体的标识符)或<code class="fe nk nl nm nn b"><strong class="ky ir">sid</strong></code><strong class="ky ir"/>(SNPs的标识符)来操纵SnpReaders呢？这是一个更像熊猫的场景。在这种情况下，我们可以使用<code class="fe nk nl nm nn b"><strong class="ky ir">iid_to_index()</strong></code> <strong class="ky ir"> </strong>或<code class="fe nk nl nm nn b"><strong class="ky ir">sid_to_index()</strong></code> <strong class="ky ir"> </strong>的方法。</p><p id="6893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子显示了如何读取三个感兴趣的SNP，每个SNP由<code class="fe nk nl nm nn b"><strong class="ky ir">sid</strong></code>而不是位置识别。</p><p id="f84d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输入:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="8645" class="nt ma iq nn b gy nu nv l nw nx">desired_sid_list = ['snp1750_m0_.02m1_.04',<br/>              'snp0_m0_.37m1_.24','snp122_m0_.26m1_.34']<br/>snpreader = Bed(all_bed_file,count_A1=<strong class="nn ir">True</strong>)<br/>desired_snpreader = \<br/>    snpreader[:,snpreader.sid_to_index(desired_sid_list)]<br/>print(desired_snpreader.iid_count,<br/>      desired_snpreader.sid_count)</span></pre><p id="8891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">输出:</em></p><pre class="kg kh ki kj gt np nn nq nr aw ns bi"><span id="af38" class="nt ma iq nn b gy nu nv l nw nx">500 3</span></pre><h1 id="6936" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">读者和伪读者</h1><p id="e45b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">PySnpTools包括这些常见文件格式的SNP reader:Bed、Pheno、Dat、Ped、Dense。它还定义了这些新的二进制格式:SnpNpz、SnpHdf5和SnpMemMap。最后一点很有趣，因为它使用NumPy的内存映射数组来提供对大于内存容量的数据的内存访问。PySnpTools还定义了一种称为DistributedBed的格式，这种格式提供了对密集存储在几十个(或几百或几千个)Bed文件中的数据的随机访问。</p><p id="a606" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，PySnpTools还包括SnpGen，可以称之为“伪阅读器”。对于任何使用SnpGen的程序来说，它看起来像一个文件阅读器，但它不是从磁盘读取数据，而是动态生成随机的基因组数据。基于用户提供的种子的这一代是确定性的。</p><p id="cb4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了阅读SNPS，PySnpTools还包括大量内核数据的读者和伪读者。(核数据表示个体之间成对的相似性。)</p><p id="ee7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果PySnpTools不支持感兴趣的数据格式，您有两种选择。如果您的数据相对较小，您可以使用其他Python工具读取它，然后创建内存中的SnpData(或SnpMemMap)对象。如果需要更高的性能，可以为该格式编写一个新的SnpReader模块。在这两种情况下，为SnpReader编写的任何程序都将自动使用新的数据格式。</p><h1 id="0e48" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">超越阅读</h1><p id="5f2d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最近，当我们努力将快速LMM扩展到100万个样本时，我们向PySnpTools添加了更多功能。PySnpTools现在包括以下工具:</p><ul class=""><li id="8115" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">标准化SNP数据和内核，</li><li id="8a94" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">交叉(和排序)来自任何数量SnpReaders的个体(在一行中)，</li><li id="91a6" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">有效地处理大整数范围，</li><li id="ccd2" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">编写循环，以便它们可以在多个处理器或任何集群(由一个模块定义)上运行，以及</li><li id="c833" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">向任何本地或任何分布式文件系统(由模块定义)读写文件。</li></ul><h1 id="94e2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">与其他数据集格式相比</h1><p id="fada" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在PyData 2015上，Joshua Bloom比较了用于数据科学的数据集工具(12)。表1用PySnpTools更新了他的表。基本上，与<a class="ae kv" href="http://xarray.pydata.org/" rel="noopener ugc nofollow" target="_blank"> xarray </a>非常相似，PySnpTools用不可变的索引行和列标识符来修饰2d NumPy数组。这给了我们方便和高效率，但比其他方法更特殊的目的。PySnpTools还延迟了所有的复制(和读取)，直到<code class="fe nk nl nm nn b"><strong class="ky ir">read()</strong></code> <strong class="ky ir"> </strong>方法被显式调用，这给了我们效率和可预测性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/c08958ae2d0a1e6c62e1f89296c68b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yA48r07m6Ppqk0BZE-VfGQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">表1。Bloom的数据科学数据集，加上PySnpTools</p></figure><h1 id="329e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="4ccf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">PySnpTools是一个Python库，用于读取和操作基因组数据。受NumPy和Pandas的启发，PySnpTools可以被认为是一种向基因组数据添加熊猫式索引的方法。要安装PySnpTools:</p><p id="1187" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">pip install pysnptools</code></p><p id="8964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://github.com/fastlmm/PySnpTools" rel="noopener ugc nofollow" target="_blank">https://github.com/fastlmm/PySnpTools</a>找到Jupyter笔记本、完整的API文档和示例以及源代码。</p><h2 id="0730" class="nt ma iq bd mb ob oc dn mf od oe dp mj lf of og ml lj oh oi mn ln oj ok mp ol bi translated">感谢</h2><p id="2206" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">感谢FaST-LMM团队中的每个人，他们的使用和反馈为PySnpTools的设计提供了信息。特别感谢Christoph Lippert，他编写了我们最初的BED reader，以及David Heckerman，他鼓励了PySnpTools的开发。</p><h2 id="5f76" class="nt ma iq bd mb ob oc dn mf od oe dp mj lf of og ml lj oh oi mn ln oj ok mp ol bi translated">参考</h2><p id="98d6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">1.<em class="lv">用于全基因组关联研究的快速线性混合模型。</em><strong class="ky ir">【Lippert，c .】<em class="lv">等</em> </strong> 2011，《自然方法》，8 833–835页。</p><p id="042b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<em class="lv">对扩展的威康信托数据进行详尽的上位SNP关联分析。</em> <strong class="ky ir"> Lippert，c .等人</strong> 2013年，科学报告3，1099。</p><p id="8cce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<em class="lv">基于核的遗传变异集关联测试的能力和计算效率更高。</em> <strong class="ky ir">李柏特，C，<em class="lv">等</em> </strong> 2014，生物信息学30，22。</p><p id="9ece" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.<em class="lv">对全基因组关联研究线性混合模型的进一步改进。</em> <strong class="ky ir"> Widmer，c .，<em class="lv">等</em> </strong> 2015，科学报告，4 6874。</p><p id="26b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.<em class="lv">遗传力估计的线性混合模型。</em> <strong class="ky ir">赫克曼，D. <em class="lv">等人</em>。</strong> 2016年美国国家科学院院刊113期(27)。</p><p id="8559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">6.用于全基因组关联研究的Ludicrous Speed线性混合模型。 <strong class="ky ir">卡迪，C. &amp;海克尔马，D. </strong> 2019，bioRxiv 154682。</p><p id="d72e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">7.珀塞尔，s .普林克。【http://zzz.bwh.harvard.edu/plink/.在线】<a class="ae kv" href="http://zzz.bwh.harvard.edu/plink/." rel="noopener ugc nofollow" target="_blank"/></p><p id="967c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">8.<em class="lv"> PLINK:全基因组关联和基于人群的工具集。</em> <strong class="ky ir"> Purcell，S. <em class="lv">等</em> </strong> 2007，美国人类遗传学杂志，81。</p><p id="3e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">9.奥列芬特，t。2015.</p><p id="4573" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">10.个人通信。2015.</p><p id="639c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">11.分度<strong class="ky ir">。</strong> <em class="lv"> NumPy用户指南。</em>【在线】<a class="ae kv" href="https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html." rel="noopener ugc nofollow" target="_blank">https://docs . scipy . org/doc/numpy/reference/arrays . indexing . html</a></p><p id="8835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">12.机器学习的系统观点。 <strong class="ky ir">布鲁姆，J. </strong>西雅图:s.n .，2015。PyData。</p></div></div>    
</body>
</html>