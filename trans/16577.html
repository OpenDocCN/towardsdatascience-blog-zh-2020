<html>
<head>
<title>How to Avoid a Pandas Pandemonium, Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免熊猫大混乱，第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-avoid-a-pandas-pandemonium-part-ii-3426f53d7fba?source=collection_archive---------43-----------------------#2020-11-15">https://towardsdatascience.com/how-to-avoid-a-pandas-pandemonium-part-ii-3426f53d7fba?source=collection_archive---------43-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f86c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入探究熊猫的常见错误。第二部分:加速和内存优化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/722bc7b256ec58ac7dc3ce99c44bdd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2HW0Nn3c5wTbZOc6"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@killerfvith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alex wong </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="67e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@protagonistwu/how-to-avoid-a-pandas-pandemonium-e1bed456530" rel="noopener"> <strong class="ky ir">第一部分</strong> </a>中，我们回顾了如何编写干净的代码并找出常见的无声故障。在<strong class="ky ir">第二部分</strong>中，我们致力于加速你的运行时间并降低你的内存占用。</p><p id="62dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还做了一个<a class="ae kv" href="https://github.com/pambot/notebooks/blob/master/pandas-pandemonium.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本，上面有整个课程</a>，包括两部分。</p><p id="2542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是前一部分的一些代码设置，但是我把它放在这里是为了让这一部分能够独立存在。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="fa81" class="lx ly iq lt b gy lz ma l mb mc"><em class="md"># for neatness, it helps to keep all of your imports up top</em><br/><strong class="lt ir">import</strong> <strong class="lt ir">sys</strong><br/><strong class="lt ir">import</strong> <strong class="lt ir">traceback</strong><br/><strong class="lt ir">import</strong> <strong class="lt ir">numba</strong><br/><strong class="lt ir">import</strong> <strong class="lt ir">numpy</strong> <strong class="lt ir">as</strong> <strong class="lt ir">np</strong><br/><strong class="lt ir">import</strong> <strong class="lt ir">pandas</strong> <strong class="lt ir">as</strong> <strong class="lt ir">pd</strong><br/><strong class="lt ir">import</strong> <strong class="lt ir">numpy.random</strong> <strong class="lt ir">as</strong> <strong class="lt ir">nr</strong><br/><strong class="lt ir">import</strong> <strong class="lt ir">matplotlib.pyplot</strong> <strong class="lt ir">as</strong> <strong class="lt ir">plt</strong><br/><br/>% matplotlib inline<em class="md"># generate some fake data to play with</em><br/>data = {<br/>    "day_of_week": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"] * 1000,<br/>    "booleans": [<strong class="lt ir">True</strong>, <strong class="lt ir">False</strong>] * 3500,<br/>    "positive_ints": nr.randint(0, 100, size=7000),<br/>    "mixed_ints": nr.randint(-100, 100, size=7000),<br/>    "lat1": nr.randn(7000) * 30,<br/>    "lon1": nr.randn(7000) * 30,<br/>    "lat2": nr.randn(7000) * 30,<br/>    "lon2": nr.randn(7000) * 30,<br/>}<br/><br/>df_large = pd.DataFrame(data)</span><span id="ad85" class="lx ly iq lt b gy me ma l mb mc"><em class="md"># let's copy this pro-actively, copy vs. view is in part i</em><br/>large_copy = df_large.copy()</span><span id="a0bc" class="lx ly iq lt b gy me ma l mb mc">df_large.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/9d7ee7e5c3ef8ddcf6335614b966f1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NfUt16e1vmAvBLChYv7Mg.png"/></div></div></figure><h1 id="8acf" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">启动你的熊猫</h1><p id="91a6" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">既然您已经有了很好的编码习惯，是时候尝试提升性能了。从矢量化到实时编译，您可以使用一系列方法来加快代码运行速度。为了测量瓶颈和量化性能增益，让我们介绍一下<code class="fe nc nd ne lt b">timeit</code>，一个漂亮的Jupyter性能测量笔记本工具。你需要知道的是，将<code class="fe nc nd ne lt b">%timeit</code>放在一行代码之前将测量该行代码的运行时间，而将<code class="fe nc nd ne lt b">%%timeit</code>放在一个代码块中将测量整个代码块的运行时间。</p><p id="5d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我选择了哈弗辛函数，因为它是一个很好的例子，这个函数看起来有点复杂，但实际上很容易优化。我在<a class="ae kv" href="https://stackoverflow.com/questions/4913349/haversine-formula-in-python-bearing-and-distance-between-two-gps-points" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>上找到了这个示例函数。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6363" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">def</strong> haversine(lat1, lon1, lat2, lon2):<br/>    """Haversine calculates the distance between two points on a sphere."""<br/>    lat1, lon1, lat2, lon2 = map(np.deg2rad, [lat1, lon1, lat2, lon2])<br/>    dlat = lat2 - lat1<br/>    dlon = lon2 - lon1<br/>    a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2<br/>    c = 2 * np.arcsin(np.sqrt(a)) <br/>    <strong class="lt ir">return</strong> c</span><span id="358c" class="lx ly iq lt b gy me ma l mb mc"><br/>%timeit haversine(100, -100, 50, -50)</span><span id="a141" class="lx ly iq lt b gy me ma l mb mc">&gt; 14.3 µs ± 308 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></pre><h2 id="6de8" class="lx ly iq bd mh nf ng dn ml nh ni dp mp lf nj nk mr lj nl nm mt ln nn no mv np bi translated">遍历行的三种不同方式</h2><p id="adcc" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">您可能已经知道Pandas是在Numpy的基础上构建的，以利用仅由底层C代码提供的优化，同时保持其可访问的Python接口。然而，就像任何脚踏两个世界的事物一样，你需要知道边界在哪里，以充分利用它的双重性。根据迭代数据帧的方式，您可以充分利用或完全忽略这些优化。</p><p id="bc10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您对Pandas完全陌生，并且只是将DataFrames视为嵌套Python列表的包装器，那么您的第一反应可能是一次遍历一行，比如使用<code class="fe nc nd ne lt b">df.iterrows()</code>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="56f5" class="lx ly iq lt b gy lz ma l mb mc">%%timeit</span><span id="f829" class="lx ly iq lt b gy me ma l mb mc"># `iterrows` is a generator that yields indices and rows<br/>dists = []<br/>for i, r in large_copy.iterrows():<br/>    dists.append(haversine(r["lat1"], r["lon1"], r["lat2"], r["lon2"]))</span><span id="e571" class="lx ly iq lt b gy me ma l mb mc">large_copy["spherical_dist"] = dists</span><span id="be45" class="lx ly iq lt b gy me ma l mb mc">&gt; 736 ms ± 29.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="0b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个循环740毫秒是3/4秒，真的可以累加。100，000行将花费您20个小时。</p><p id="553c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nc nd ne lt b">df.apply()</code>方法有一个稍微优化的方法，它对DataFrame和Series对象都有效。您定义一个自定义函数并发送它，在某些情况下，它会尝试推断更快的方法来更快地处理DataFrame列。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="96d0" class="lx ly iq lt b gy lz ma l mb mc">large_copy["spherical_dist"] = large_copy.apply(<br/>    lambda r: haversine(r["lat1"], r["lon1"], r["lat2"], r["lon2"]), axis=1<br/>)</span><span id="7d8a" class="lx ly iq lt b gy me ma l mb mc">&gt; 387 ms ± 31.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="35f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种进步，但并不惊人。您需要做的是使用矢量化，简单地说，就是向Numpy兼容函数中输入一系列值，这些值通常一次取一个值，这样C代码就可以自由地在内部分割向量并进行并行处理。Numpy函数通常可以接受单个值、一个向量或一个矩阵。如果内部处理可以在每一步都作用于单个值或值的向量，则可以使用现成的矢量化。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2bb1" class="lx ly iq lt b gy lz ma l mb mc">%timeit large_copy["spherical_dist"] = haversine(\<br/>    large_copy["lat1"], \<br/>    large_copy["lon1"], \<br/>    large_copy["lat2"], \<br/>    large_copy["lon2"] \<br/>)</span><span id="fc72" class="lx ly iq lt b gy me ma l mb mc">&gt; 2.17 ms ± 188 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></pre><p id="e0dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这大约是100倍的速度提升——20小时缩短到大约4分钟。请注意，我没有以任何方式更改原始函数。如果你去看代码，你可以自己追踪这些值是如何既可以是单个值也可以是一个序列的。</p><h2 id="0ae9" class="lx ly iq bd mh nf ng dn ml nh ni dp mp lf nj nk mr lj nl nm mt ln nn no mv np bi translated">迭代的一些经验法则</h2><p id="6b4a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">与索引一样，Pandas可以灵活地处理每行的值。以下是一些经验法则:</p><ul class=""><li id="ba5c" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">如果要对列的每个值应用相同的变换，应该使用矢量化。</li><li id="d669" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">如果需要条件矢量化，请使用布尔索引。</li><li id="aaf2" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">也适用于字符串！即<code class="fe nc nd ne lt b">Series.str.replace("remove_word", "")</code></li><li id="e5f6" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">你应该只对不能广播的特定功能使用<code class="fe nc nd ne lt b">apply</code>。即<code class="fe nc nd ne lt b">pd.to_datetime()</code></li></ul><h2 id="cbc0" class="lx ly iq bd mh nf ng dn ml nh ni dp mp lf nj nk mr lj nl nm mt ln nn no mv np bi translated">用Numba进行实时编译</h2><p id="7370" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">不能矢量化怎么办？这是否意味着你被<code class="fe nc nd ne lt b">df.apply()</code>困住了？不一定——如果您的代码可以表示为纯Python和Numpy数组的组合，您应该尝试Numba，看看您的代码是否可以为您加速。编写Numba与编写Cython完全不同，如果你只懂Python，那么编写cy thon就很像编写一种全新的编程语言。同样，只要你的代码可以用纯Python和Numpy来表达，这实际上就是在现有函数的基础上添加一些装饰器。</p><p id="b634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子基于一些函数，这些函数计算一个给定的复数是否是Mandlebrot集合的一部分，并通过尝试每个像素坐标来可视化产生的分形。取自<a class="ae kv" href="http://numba.pydata.org/numba-doc/0.15.1/examples.html" rel="noopener ugc nofollow" target="_blank"> Numba docs </a>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9eea" class="lx ly iq lt b gy lz ma l mb mc"><strong class="lt ir">def</strong> mandel(x, y, max_iters):<br/>    """<br/>    Given the real and imaginary parts of a complex number,<br/>    determine if it is a candidate for membership in the Mandelbrot<br/>    set given a fixed number of iterations.<br/>    """<br/>    i = 0<br/>    c = complex(x,y)<br/>    z = 0.0j<br/>    for i in range(max_iters):<br/>        z = z*z + c<br/>        if (z.real*z.real + z.imag*z.imag) &gt;= 4:<br/>            <strong class="lt ir">return</strong> i<br/>    <strong class="lt ir">return</strong> 255</span><span id="939f" class="lx ly iq lt b gy me ma l mb mc"><strong class="lt ir">def</strong> create_fractal(min_x, max_x, min_y, max_y, image, iters):<br/>    height = image.shape[0]<br/>    width = image.shape[1]</span><span id="9a88" class="lx ly iq lt b gy me ma l mb mc">    pixel_size_x = (max_x - min_x) / width<br/>        pixel_size_y = (max_y - min_y) / height<br/>        for x in range(width):<br/>            real = min_x + x * pixel_size_x<br/>            for y in range(height):<br/>                imag = min_y + y * pixel_size_y<br/>                color = mandel(real, imag, iters)<br/>                image[y, x] = color</span><span id="179b" class="lx ly iq lt b gy me ma l mb mc">    <strong class="lt ir">return</strong> image</span><span id="173e" class="lx ly iq lt b gy me ma l mb mc"><br/>image = pd.DataFrame()<br/>image["pixels"] = np.zeros(1, dtype=np.uint8)</span><span id="56c0" class="lx ly iq lt b gy me ma l mb mc">%timeit create_fractal(-2.0, 1.0, -1.0, 1.0, image, 20)</span><span id="312d" class="lx ly iq lt b gy me ma l mb mc">&gt; 30.5 ms ± 11.4 ms per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="5154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是完全相同的功能，但在顶部有Numba装饰。我不得不使输入数据非常非常小，因为<code class="fe nc nd ne lt b">timeit</code>运行许多次迭代来测量速度。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9229" class="lx ly iq lt b gy lz ma l mb mc">@numba.jit<strong class="lt ir"><br/>def</strong> mandel(x, y, max_iters):<br/>    """<br/>    Given the real and imaginary parts of a complex number,<br/>    determine if it is a candidate for membership in the Mandelbrot<br/>    set given a fixed number of iterations.<br/>    """<br/>    i = 0<br/>    c = complex(x,y)<br/>    z = 0.0j<br/>    for i in range(max_iters):<br/>        z = z*z + c<br/>        if (z.real*z.real + z.imag*z.imag) &gt;= 4:<br/>            <strong class="lt ir">return</strong> i<br/>    <strong class="lt ir">return</strong> 255</span><span id="8c1d" class="lx ly iq lt b gy me ma l mb mc">@numba.jit<br/><strong class="lt ir">def</strong> create_fractal(min_x, max_x, min_y, max_y, image, iters):<br/>    height = image.shape[0]<br/>    width = image.shape[1]</span><span id="9853" class="lx ly iq lt b gy me ma l mb mc">    pixel_size_x = (max_x - min_x) / width<br/>        pixel_size_y = (max_y - min_y) / height<br/>        for x in range(width):<br/>            real = min_x + x * pixel_size_x<br/>            for y in range(height):<br/>                imag = min_y + y * pixel_size_y<br/>                color = mandel(real, imag, iters)<br/>                image[y, x] = color</span><span id="07b9" class="lx ly iq lt b gy me ma l mb mc"><strong class="lt ir">    return</strong> image<br/></span><span id="de9a" class="lx ly iq lt b gy me ma l mb mc">image = pd.DataFrame()<br/>image["pixels"] = np.zeros(1, dtype=np.uint8)</span><span id="4505" class="lx ly iq lt b gy me ma l mb mc">%timeit create_fractal(-2.0, 1.0, -1.0, 1.0, image, 20)</span><span id="043a" class="lx ly iq lt b gy me ma l mb mc">&gt; 1.63 ms ± 84 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="3ecb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是打字5秒钟速度的18倍。如果你的函数需要一些复杂的循环和条件混合在一起，看看你是否能运用一些Numba魔法还是值得的。</p><p id="f6de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您感到好奇，这就是当您将<code class="fe nc nd ne lt b">create_fractal</code>函数应用到全零的实际输入时它的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/c93fd41b66d75bbc193172c62b25036e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OcErwX7fYuVQygpHjvWaw.png"/></div></div></figure><h1 id="c5eb" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">管理你的记忆</h1><p id="e47f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果您使用Pandas已经有一段时间了，那么您可能在某个时候遇到过中等大小的数据帧使您的Python进程崩溃的情况。令人困惑的是，当数据帧看起来没有那么大时，或者也许你记得上周在同一台笔记本电脑上处理更大的东西，但那台没有崩溃。怎么回事？</p><p id="0145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">熊猫记忆问题的最大元凶可能是:</p><ul class=""><li id="3c9d" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">你的引用仍然附加在变量上，这意味着它们不会被垃圾回收。</li><li id="5bdb" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">你有太多的数据帧副本。</li><li id="e8e6" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">您可以进行更多的就地操作，这不会产生数据帧的副本。</li><li id="291b" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe nc nd ne lt b">object</code>数据类型比固定数据类型占用更多的内存。</li></ul><h2 id="ca9f" class="lx ly iq bd mh nf ng dn ml nh ni dp mp lf nj nk mr lj nl nm mt ln nn no mv np bi translated">碎片帐集</h2><p id="f892" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">垃圾收集是Python通过释放对程序不再有用的内存来释放内存的过程。您可以通过移除对该对象的引用来释放内存引用的对象。这将标记以前引用的对象以释放内存。</p><p id="edf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让垃圾收集帮助您管理内存的最佳方式是将您能做的任何事情包装到函数中。在函数中声明的变量只作用于函数，所以当函数结束运行时，它们会被丢弃。另一方面，全局变量(如<code class="fe nc nd ne lt b">large_copy</code>)一直保留到Python进程结束(即笔记本内核关闭)。即使你<code class="fe nc nd ne lt b">del</code>了一个变量，它也只是减少了1个引用，但是如果引用计数不是0，被引用的对象实际上并没有被删除。这就是为什么全局变量会破坏你认为你的记忆。</p><p id="af12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只是为了好玩，您可以通过使用<code class="fe nc nd ne lt b">sys.getrefcount(var_name)</code>来查看变量的引用计数。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="c59b" class="lx ly iq lt b gy lz ma l mb mc"><em class="md"># `foo` is a reference</em><br/>foo = []</span><span id="9c8a" class="lx ly iq lt b gy me ma l mb mc">sys.getrefcount(foo) # this temporarily bumps it up to 2</span><span id="c11f" class="lx ly iq lt b gy me ma l mb mc">&gt; 2</span><span id="8f29" class="lx ly iq lt b gy me ma l mb mc"># yet another global reference bumps it up again <br/>foo.append(foo)</span><span id="e6cf" class="lx ly iq lt b gy me ma l mb mc">sys.getrefcount(foo)</span><span id="d61d" class="lx ly iq lt b gy me ma l mb mc">&gt; 3</span></pre><p id="1e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，<code class="fe nc nd ne lt b">del</code>将无法对其进行垃圾收集，全局范围内引用过多。</p><h2 id="68aa" class="lx ly iq bd mh nf ng dn ml nh ni dp mp lf nj nk mr lj nl nm mt ln nn no mv np bi translated">数据类型占用大量内存</h2><p id="4ab7" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">又是那些讨厌的<code class="fe nc nd ne lt b">object</code>dtype！毫不奇怪，告诉熊猫你需要能够在任何时间任何地方存储任何东西意味着它会为你存储的东西预先分配大量的初始内存。如果您存储的是复杂的东西，这没问题，但是如果您存储的是可以简单表示的东西，您可能想看看是否可以将dtype改为更适合您情况的类型。</p><p id="9803" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查数据帧占用了多少内存实际上比你想象的要容易。它已经内置到DataFrame对象中。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="beb2" class="lx ly iq lt b gy lz ma l mb mc">large_copy.info(memory_usage="deep")</span><span id="cfc2" class="lx ly iq lt b gy me ma l mb mc">&gt;<br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 7000 entries, 0 to 6999<br/>Data columns (total 8 columns):<br/>day_of_week      7000 non-null object<br/>booleans         7000 non-null bool<br/>positive_ints    7000 non-null int64<br/>mixed_ints       7000 non-null int64<br/>lat1             7000 non-null float64<br/>lon1             7000 non-null float64<br/>lat2             7000 non-null float64<br/>lon2             7000 non-null float64<br/>dtypes: bool(1), float64(4), int64(2), object(1)<br/>memory usage: 773.5 KB</span></pre><p id="de7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">节约内存的一个常见做法是向下转换。例如，如果您知道您的整数不需要64位，就将它们转换为32位。但是，正如我们将会看到的，并不是所有的向下投射都具有同等的影响力。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d267" class="lx ly iq lt b gy lz ma l mb mc">large_copy["positive_ints"] = large_copy["positive_ints"].astype(np.int32)</span><span id="569a" class="lx ly iq lt b gy me ma l mb mc">large_copy.info(memory_usage="deep")</span><span id="1b63" class="lx ly iq lt b gy me ma l mb mc">&gt;<br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 7000 entries, 0 to 6999<br/>Data columns (total 8 columns):<br/>day_of_week      7000 non-null object<br/>booleans         7000 non-null bool<br/>positive_ints    7000 non-null int32<br/>mixed_ints       7000 non-null int64<br/>lat1             7000 non-null float64<br/>lon1             7000 non-null float64<br/>lat2             7000 non-null float64<br/>lon2             7000 non-null float64<br/>dtypes: bool(1), float64(4), int32(1), int64(1), object(1)<br/>memory usage: 746.2 KB</span></pre><p id="7ec4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3%的降幅其实并不显著。如果你有字符串列，并且它们被存储为一个<code class="fe nc nd ne lt b">object</code>类型，那么它们总是比浮点数和整数更容易占用内存。</p><p id="9455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的<code class="fe nc nd ne lt b">str</code>类型在熊猫中都被存储为<code class="fe nc nd ne lt b">object</code>，因为它们可以是任意长度。您可以将字符串列向下转换为固定长度的<code class="fe nc nd ne lt b">str</code>类型。例如，这个限制为10个字符:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5098" class="lx ly iq lt b gy lz ma l mb mc">large_copy["day_of_week"] = large_copy["day_of_week"].astype("|S10")</span><span id="552e" class="lx ly iq lt b gy me ma l mb mc">large_copy.info(memory_usage="deep")</span><span id="90cf" class="lx ly iq lt b gy me ma l mb mc">&gt;<br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 7000 entries, 0 to 6999<br/>Data columns (total 8 columns):<br/>day_of_week      7000 non-null object<br/>booleans         7000 non-null bool<br/>positive_ints    7000 non-null int32<br/>mixed_ints       7000 non-null int64<br/>lat1             7000 non-null float64<br/>lon1             7000 non-null float64<br/>lat2             7000 non-null float64<br/>lon2             7000 non-null float64<br/>dtypes: bool(1), float64(4), int32(1), int64(1), object(1)<br/>memory usage: 636.8 KB</span></pre><p id="3f3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">降价18%并不坏，但是我们还能做得更多吗？你碰巧知道在<code class="fe nc nd ne lt b">day_of_week</code>一周最多只有7天。有一种<code class="fe nc nd ne lt b">category</code>类型可以利用由一小组重复元素组成的列。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="712e" class="lx ly iq lt b gy lz ma l mb mc">large_copy["day_of_week"] = large_copy["day_of_week"].astype("category")</span><span id="a60d" class="lx ly iq lt b gy me ma l mb mc">large_copy.info(memory_usage="deep")</span><span id="933e" class="lx ly iq lt b gy me ma l mb mc">&gt;<br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 7000 entries, 0 to 6999<br/>Data columns (total 8 columns):<br/>day_of_week      7000 non-null category<br/>booleans         7000 non-null bool<br/>positive_ints    7000 non-null int32<br/>mixed_ints       7000 non-null int64<br/>lat1             7000 non-null float64<br/>lon1             7000 non-null float64<br/>lat2             7000 non-null float64<br/>lon2             7000 non-null float64<br/>dtypes: bool(1), category(1), float64(4), int32(1), int64(1)<br/>memory usage: 315.2 KB</span></pre><p id="be2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅从一个专栏来看，就减少了59%!</p><h1 id="816c" class="mg ly iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论，第二部分</h1><p id="1bed" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我几乎惭愧地承认，在我开始寻找优化之前，我花了几年时间使用Pandas，即使在今天，我也没有对我制作的每一台笔记本进行优化。但是，通过一些简单的技巧，您可以看到几行代码的差异，甚至是如何处理单个列，会导致10-100倍的速度提升和50%以上的内存减少。这绝对是一套不错的锦囊妙计。</p><p id="b286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您错过了它，请查看<a class="ae kv" href="https://medium.com/@protagonistwu/how-to-avoid-a-pandas-pandemonium-e1bed456530" rel="noopener">第一部分:编写好的代码并发现无声的失败。</a></p></div></div>    
</body>
</html>