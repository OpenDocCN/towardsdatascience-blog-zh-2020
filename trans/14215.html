<html>
<head>
<title>Detecting cycles in linked lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检测链表中的循环</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/detecting-cycles-in-linked-lists-an-analogy-559c3639ef43?source=collection_archive---------51-----------------------#2020-09-30">https://towardsdatascience.com/detecting-cycles-in-linked-lists-an-analogy-559c3639ef43?source=collection_archive---------51-----------------------#2020-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6916" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用类比理解龟兔算法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3494e5324ef77c275802ae96395408cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oO_0LgwSvG56yE9aubX1Rw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)用野兔和乌龟探测周期</p></figure><p id="9930" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们开始用算法思考时，链表是我们首先遇到的一些数据结构。在这个主题上经常遇到的问题是检测链表中的循环。</p><p id="41c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，让我们来解决这个问题。但是在那之前...</p><h1 id="90cb" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么是链表？</h1><p id="aa6e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">想象一个狭窄的隧道。隧道里的每一个点都指向前方的一个点。你知道这个隧道的入口。一旦踏入隧道，里面完全是漆黑一片，其他什么都看不到。但是还是有希望的。如果你在X点，那么你前面的Y点会出现一道光，所以你现在可以移动到Y点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/d74d3baa89f1d90876ff94eeaa803560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/0*N8TiiN7_SitCOV29.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)正前方的聚光灯亮起</p></figure><p id="ad71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">灯在你前面的台阶上一直亮着，当你一到达那里就消失了。所以你只能一步一步地前进(不知道后面是什么，也不知道前面还有什么)</p><p id="3684" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果隧道到了尽头，你就能看到前方的阳光。所以一旦你踏上“最后一步”，你就会知道隧道已经结束了。隧道就是你的<em class="mp">链表</em>。</p><h1 id="cef8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">什么是循环？</h1><p id="ca43" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">想象你在这样一个隧道前面。但是你被警告隧道可能有一个<em class="mp">周期</em>，即“隧道的尽头”可能链接回隧道中间的某个地方。所以事实上隧道没有尽头。例如，想象一个9字形的隧道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/0ea6fc27b03e06505881793e328b4c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*CMya8htTz9jRUCkV.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)陷入噩梦循环</p></figure><p id="fbf3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果隧道没有周期，它有一个实际的终点，从那里你可以看到阳光，知道你已经到达了终点。如果你最终走过一个有循环的隧道，你会一直循环下去，永远被困在黑暗中，不知道隧道的尽头是否有光明，或者你是否被困在一个噩梦般的循环中。</p><h1 id="1d78" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">问题出在哪里？</h1><p id="c14a" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">你的工作是想出一个策略，让你能检测出你面前的这个隧道是否有循环，也就是<em class="mp">你能检测出你的链表是否有循环</em>？假设你在隧道里，你意识到隧道有一个循环，你可以用无线电发出求救信号，有人会来救你。</p><h1 id="79b8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">很酷的策略！</h1><p id="8a6b" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">你邀请你的两个爱冒险的朋友过来。他们将被送进装有无线电的隧道。他们同时进入隧道，但其中一人会以比另一人慢的速度行走。</p><p id="58f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果隧道没有循环，一切都很好，两个朋友都将退出隧道(当然，更快的一个会更快退出)。</p><p id="55ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mp">如果隧道确实有周期</em>怎么办？嗯，速度快的会先陷入循环。他一直跑来跑去。较慢的一个也将在稍后陷入循环。他也不停的跑来跑去。但最终…这两个人会相遇！！</p><p id="b750" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">他们为什么会相遇？这看起来很直观，但是我们需要<em class="mp">证据</em>。一个明智的朋友低声说“想想相对速度”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/29bc2f8e493358183767dcf97663f9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*zo8OWL3MvbKAUAU5.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)一个证明的想法！</p></figure><p id="68f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从慢一点的人的角度想想。他相对于自己是静止的，而较快的人以非零速度运动。当你站在环形轨道上不动，而你的朋友在绕着它跑，会发生什么？他撞到了你。瞧啊。</p><h1 id="0d3f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">总结</h1><p id="cfd7" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">因此，在我们的隧道(也称为链表)中检测循环的策略是——使用两个装有无线电(指针)的朋友，一个慢一个快来遍历隧道。如果他们中的任何一个离开隧道，他们会用无线电通知你，你知道隧道没有循环。否则，如果隧道确实有一个循环，他们将会相遇，一旦他们相遇，将会用无线电通知你，你将会知道确实有一个循环。</p><h1 id="bb48" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">名字是…</h1><p id="b7d2" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">毫不奇怪，这种算法的一个名字显然是<em class="mp">龟兔赛跑算法</em></p><h1 id="533f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">我们来编码吧！</h1><p id="8560" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们将我们的策略翻译成python代码。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="0788" class="mx ls iq mt b gy my mz l na nb">class ListNode:<br/>    def __init__(self, x=None):<br/>         self.val = x<br/>         self.next = None</span><span id="5ca0" class="mx ls iq mt b gy nc mz l na nb">def hasCycle(head: ListNode) -&gt; bool:<br/>    ''' Return True if linked list has a cycle, else false'''<br/>    <br/>    #Base case : If linked list has &lt;= 1 element, no cycle<br/>    if head is None or head.next is None:<br/>         return False</span><span id="fbdf" class="mx ls iq mt b gy nc mz l na nb">    #Position slow and fast pointers at start and start+1 position<br/>    slow_pointer = head<br/>    fast_pointer = head.next</span><span id="d9b4" class="mx ls iq mt b gy nc mz l na nb">    #Traverse linked list while fast_pointer is not at end of list<br/>    while(fast_pointer is not None):<br/>        #If pointers meet, return True<br/>        if slow_pointer == fast_pointer:<br/>            return True<br/>        #if fast pointer is 1 step before end of list, return False<br/>        elif fast_pointer.next is None:<br/>            return False<br/>        #else move fast_pointer up by 2 steps, slow_pointer by 1<br/>        else:<br/>            slow_pointer = slow_pointer.next<br/>            fast_pointer = fast_pointer.next.next</span><span id="ad32" class="mx ls iq mt b gy nc mz l na nb">    #Fast_pointer has reached end of list, return False<br/>    return False</span></pre></div></div>    
</body>
</html>