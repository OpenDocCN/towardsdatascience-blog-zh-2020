<html>
<head>
<title>Five challenges of graph processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形处理的五大挑战</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-challenges-of-graph-processing-94e0a4041431?source=collection_archive---------48-----------------------#2020-10-27">https://towardsdatascience.com/five-challenges-of-graph-processing-94e0a4041431?source=collection_archive---------48-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c57b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">图计算从业者必须克服的最相关问题的总结。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94e70abdbf30ad6add73efa733589d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NnVpAk_5NbXrSP3B"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@othentikisra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> israel palacio </a>拍摄</p></figure><p id="d36c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" rel="noopener" target="_blank" href="/graph-processing-a-problem-with-no-clear-victor-3683c483f5dc">之前的一篇文章</a>中，我公开了我对缺乏清晰的图形处理平台/解决方案/框架/架构的看法。然而，图形处理必须处理的主要问题是什么？把这几行作为开胃菜送给那些好奇的人。</p><p id="2fb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(除非另有说明，否则图片属于作者所有)。</p><div class="ls lt gp gr lu lv"><a rel="noopener follow" target="_blank" href="/graph-processing-a-problem-with-no-clear-victor-3683c483f5dc"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">图形处理:一个没有明确胜利者的问题</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">你知道最流行的图形处理解决方案吗？没有吗？别担心。现在还没有。</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="42fc" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">1.图形是非结构化的</h1><p id="a0b7" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">图是顶点<em class="no"> V </em>和连接这些顶点的边<em class="no"> E </em>的集合。一个图<em class="no"> G=(V，E) </em>可以是有向的，也可以是无向的。在有向图中，从顶点<em class="no"> u </em>到顶点<em class="no"> v </em>的任何边都有方向(<em class="no"> u </em> → <em class="no"> v </em>)。这就是，我们可以从<em class="no"> u </em>到<em class="no"> v </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f784df80561a37cf0c7b751ac3f90068.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*s0S19hjUhKSeSASrf_eU7A.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="16c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果图是无向的，我们就没有方向。这就是，<em class="no"> u </em>连接到<em class="no"> v </em>上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/36ad0c69b444c820c3af6fdb88eeabea.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*pnPq9K0Rcp0aVHLKJz7CVw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="1f56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，我们可以有权重为W(e) 的边。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ae878b2f4460b65dd417ec2ba9b4ff56.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*Dl5-57PX7RdNZDrm1eFnOg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="d695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和权重为W(u)，W(v)的顶点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/118f51ec01461aa4b9c7ce19da4ad405.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*0jCedK0Ut9TtsyLJ-KfGBg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="5e7a" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">2.图形表示</h1><p id="3414" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">图形特别适合于<strong class="ky ir">代表绝对任何东西</strong>。从社会网络到原子力之间的相互作用。这种程度的自由很难转化成计算机。图的一个非常计算机友好的表示是<strong class="ky ir">邻接矩阵</strong> <em class="no"> A </em>。<em class="no"> A </em>是一个大小为<em class="no"> |V| x |V| </em>的方阵，其中<em class="no"> A </em> ᵢ <em class="no"> ⱼ </em>表示在顶点<em class="no"> i </em>和<em class="no"> j </em>之间存在一条边。对于无向图，<em class="no"> A </em>是对称矩阵。例如，对于图表</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/abff0a48bd4444581934b372514f641c.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*_OWJmvaQ4RtOQjoMCEZ3HQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在邻接矩阵中得到它的表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ca08ab901c3a744c5840841e8d87eb6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*gkjTROlgkRqoRtW-s8ADiw.png"/></div></figure><p id="10bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为前面的表示是矩阵，所以我们可以使用所有可用的代数运算工具。例如，通过对每一列的值求和，我们得到了针对每个顶点的边的数量。此外，我们可以使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Spectral_graph_theory" rel="noopener ugc nofollow" target="_blank">谱图理论</a>计算特征值和特征向量，这些特征值和特征向量可以给我们提供有趣的信息。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d67d" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">3.记忆</h1><p id="ca84" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">但是还有其他方面需要考虑。<strong class="ky ir">内存利用率怎么样？</strong>想想上面的邻接矩阵，对于一个4 x 4的矩阵(16个单元)，我们有10个空单元(等于0)。为这个矩阵分配内存时，我们浪费了62%的分配内存和不相关的信息。对于非常大的稀疏矩阵，这种成本是不可接受的。我们在很多情况下都有稀疏矩阵，想想社交网络。脸书有26亿活跃用户，每个档案最多只能有5000个好友。此外，一些操作变得很麻烦。例如，知道相邻顶点涉及整个矩阵的操作。</p><p id="9b7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，我们有其他更“内存友好”或者至少更适合某些场景的解决方案。一个<strong class="ky ir">邻接表</strong>是一个列表，其中每一项代表图中的一个顶点。对于每个顶点，我们都存储指向其相邻顶点(邻居)的指针。以上面的例子为例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/eae291dd9284c555019a6a017b20f17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*op1TANl5Z500gktqsNetCQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">邻接表将存储的信息限制在相邻顶点。顶点<em class="no"> a </em>可以访问其相邻顶点的引用列表。这有助于实现可以穿过图顶点的<strong class="ky ir">遍历</strong>操作，并使得存储附加数据增强数据<strong class="ky ir">位置</strong>成为可能。</p><p id="028e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从性能的角度来看，这就是图形成为一种非常难以处理的数据结构的地方。假设我们想要访问顶点<em class="no">a</em>(<em class="no">γ(a)</em>)的所有邻居。<em class="no"> a </em>的相邻顶点是:自身、<em class="no"> b </em>和<em class="no"> d </em>。这意味着我们必须访问<em class="no"> b </em>和<em class="no"> d </em>的内存位置。如果这些内存碎片还没有被缓存，会发生什么？这是一个缓存缺失，这意味着我们必须从主内存中取出图形的一部分。对于具有大量邻居的顶点，缓存缺失将反复重复。这直接影响了图形遍历器的性能。在大多数图形算法中，内存访问缺乏局部性是一个性能限制。</p><p id="e495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个有趣的问题是<strong class="ky ir">当图形不适合主存</strong>时会发生什么？就性能而言，高速缓存未命中代价高昂，但访问二级存储器的代价要高几个数量级。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="e572" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">4.分布式解决方案</h1><p id="211c" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果我们考虑分布式解决方案，缺乏本地性可能是一个巨大的性能瓶颈。对于跨节点拆分图形的分布式内存解决方案，我们可能有这样的解决方案:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/21a3e1f58c695f50edf2f174c0673818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*bwOIkeu29Xiw4IHRcqaQKQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="c1cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于在nodeA中运行的操作，对顶点<em class="no"> c </em>或<em class="no"> d </em>的任何访问都必须从其他节点检索信息。如果可以修改边权重，复杂性会增加。谁是边缘的主人？顶点呢？像<a class="ae kv" href="http://glaros.dtc.umn.edu/gkhome/metis/metis/overview" rel="noopener ugc nofollow" target="_blank"> Metis </a>这样的解决方案可以跨<em class="no"> n </em>个库或节点给你最好的图划分。然而，使算法适应分布式分区并不容易。并且计算最佳分区是一个昂贵的操作。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="fb97" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">5.平行</h1><p id="d309" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">而<strong class="ky ir">并行</strong>呢？这取决于要并行化的问题或算法。然而，在诸如广度优先搜索(BFS)或深度优先搜索(DFS)之类的经典迭代器中，利用诸如队列或堆栈之类的并发访问数据结构存在明显的问题。例如，这是BFS的伪代码:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="587d" class="ob ms iq nx b gy oc od l oe of">1  procedure BFS(G, root) is<br/>2      let Q be a queue<br/>3      label root as discovered<br/>4      Q.enqueue(root)<br/>5      while Q is not empty do<br/>6          v := Q.dequeue()<br/>7          if v is the goal then<br/>8              return v<br/>9          for all edges from v to w in G.adjacentEdges(v) do<br/>10             if w is not labeled as discovered then<br/>11                 label w as discovered<br/>12                 w.parent := v<br/>13                 Q.enqueue(w)</span></pre><p id="76ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们认为上面的伪代码是并行运行的，我们必须保证自动访问/修改<em class="no"> Q </em>和labels结构。这给多个并行实例带来了巨大的瓶颈，会导致非常差的性能。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="49f7" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">摘要</h1><p id="54cf" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在这篇文章中，我介绍了在设计基于图形的解决方案时，图形带来的一些潜在问题。您可能会发现许多其他问题。不过，我觉得这些是主要的。你会发现还有其他一些特别难以克服的问题。我很想听听。</p><p id="f63e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>