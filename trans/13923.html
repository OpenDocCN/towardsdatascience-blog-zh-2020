<html>
<head>
<title>System Design of URL Shortening Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">URL缩短服务的系统设计</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/system-design-of-url-shortening-service-b325b18c8f88?source=collection_archive---------2-----------------------#2020-09-25">https://towardsdatascience.com/system-design-of-url-shortening-service-b325b18c8f88?source=collection_archive---------2-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="caa5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提供缩短URL的web服务的系统设计分析</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03ae88be6c1cbad884aa83d5f39d8838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtnlQ75PWim1jAihN37Ehw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@markusspiske?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">马库斯·斯皮斯克</strong> </a>发自<a class="ae ky" href="https://www.pexels.com/photo/working-pattern-internet-abstract-1089438/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz">佩克斯</strong> </a></p></figure><p id="72b0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">系统设计是软件工程中<strong class="lc iu"> <em class="lw">最重要也是最令人畏惧的</em> </strong>方面。这个观点来自于我自己在一个建筑助理课程中的学习经历。当我开始我的助理架构课程时，我很难理解设计一个系统的想法。</p><p id="2b8d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个主要原因是软件架构书籍中使用的术语一开始很难理解，并且没有清晰的逐步指南。每个人似乎都有不同的方法。</p><p id="bc1e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以，我根据我学习建筑课程的经验着手<a class="ae ky" rel="noopener" target="_blank" href="/system-design-101-b8f15162ef7c?source=friends_link&amp;sk=be3d26de1f9d1671b4abe379aae814f8">设计一个系统</a>。这是初学者系统设计系列的一部分(下面给出了链接)。对于这一个，让我们设计URL缩短服务。</p><p id="f038" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在<a class="lx ly ep" href="https://medium.com/u/504c7870fdb6?source=post_page-----b325b18c8f88--------------------------------" rel="noopener" target="_blank">中</a>，我们可以看到网址相当大，尤其是好友链接；当分享一篇文章时，我们倾向于缩短URL。一些已知的URL缩短服务有TinyURL、bit.ly、goo.gl、rb.gy等。我们将设计这样一个网址缩短服务。</p><h2 id="5e6d" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★系统的定义:</h2><p id="1e80" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">我们需要明确系统的目标。<em class="lw">系统设计是一个如此庞大的话题；如果我们不把它缩小到一个特定的目的，那么设计系统就会变得复杂，尤其是对于新手来说。URL缩短服务为长URL提供较短的别名。当用户点击缩短的链接时，他们将被重定向到原来的网址。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/a3bd5144d3cfb97f3bb49d21c02a7799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-Ic3p3vbUGS_8bh2-wbmg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="f9e9" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★系统要求:</h2><p id="2795" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">在这一部分，我们决定系统的功能。我们需要关注的需求是什么？<strong class="lc iu">我们可以将系统需求分为两部分:</strong></p><ul class=""><li id="64d1" class="my mz it lc b ld le lg lh lj na ln nb lr nc lv nd ne nf ng bi translated"><strong class="lc iu">功能需求:</strong></li></ul><p id="ae96" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">用户给出一个URL作为输入；我们的服务应该为该URL生成一个更短且唯一的别名。当用户点击较短的链接时，我们的系统应该将他们重定向到原来的链接。链接可能会在一段时间后过期。用户可以指定到期时间。<em class="lw">我们这里不考虑用户自定义链接。</em></p><p id="dd15" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是系统必须提供的一个需求。这是系统的主要目标。</p><ul class=""><li id="ad02" class="my mz it lc b ld le lg lh lj na ln nb lr nc lv nd ne nf ng bi translated"><strong class="lc iu">非功能性需求:</strong></li></ul><p id="33a2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在是需要分析的更关键的需求。如果我们不满足这个要求，它可能对项目的商业计划有害。那么，让我们定义一下我们的nfr:</p><blockquote class="nh ni nj"><p id="d3a4" class="la lb lw lc b ld le ju lf lg lh jx li nk lk ll lm nl lo lp lq nm ls lt lu lv im bi translated">系统应该是高度可用的。如果服务关闭，所有URL重定向都将失败。URL重定向应该实时发生。没有人应该能够预测缩短的链接。</p></blockquote><p id="7520" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">性能、可修改性、可用性、可伸缩性、可靠性等。是系统设计中一些重要的质量要求。这些‘能力’是我们分析一个系统并确定我们的系统设计是否恰当所需要的。</strong></p><p id="1c66" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个系统中，可用性是主要的质量属性。安全性是另一个重要的属性。通常，可用性和可伸缩性是系统设计的重要特征。默认情况下，性能是重要的，没有人希望构建一个性能更差的系统，对吗？！</p><h2 id="3d12" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★系统需要处理多少请求？</h2><p id="fc61" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">让我们假设，一个用户可能请求一个新的URL，并使用它100次进行重定向。因此，写和读的比率应该是1:100。所以系统的读取量很大。</p><p id="2026" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们需要在服务中处理多少URL请求？假设我们可能每秒收到200个URL请求。所以，一个月的计算，我们可以有30天* 24小时* 3600秒*200 =~ 500 M的请求。</p><p id="38ab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，每月会有近5亿个新的URL缩短请求。那么，重定向请求将是500M * 100 = 50亿。</p><p id="d4d5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要计算年份，你必须将这个数乘以12。</p><h2 id="7f90" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★我们需要多少储物空间？</h2><p id="c04d" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">让我们假设，系统将所有的URL缩短请求和它们的缩短链接存储了5年。由于我们预计每个月会有5亿个新的URL，我们预计存储的对象总数将是500 M * (5 * 12)个月= 30 B。</p><p id="1855" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在让我们假设每个存储的对象大约有100个字节。我们将需要300亿* 100字节= 3 TB的总存储容量。</p><p id="2f3c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们想要缓存一些经常被访问的流行URL，如果我们遵循80–20规则，这意味着我们从缓存中保留20%的请求。</p><p id="f363" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因为我们每秒有20K个请求，我们将得到</p><p id="8251" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="lw"> 20K * 60秒* 60分钟* 24小时=每天~ 17亿</em> </strong></p><p id="22f5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们计划缓存20%的请求，我们将需要</p><p id="156d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"><em class="lw">0.2 * 17亿* 100字节= 34GB内存。</em>T11】</strong></p><h2 id="6ef1" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★数据流:</h2><p id="a865" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated"><strong class="lc iu"> <em class="lw">对于系统设计的新手，请记住，“如果你对系统设计从哪里开始感到困惑，请尝试从数据流开始。”</em>T15】</strong></p><p id="0b21" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，服务器端组件的主要任务之一是为输入URL生成唯一的键。在这里，我们的输入数据只是一个URL。因此，我们需要将它们存储为一个字符串。输出是URL的另一个缩短版本。如果有人点击这个缩短的网址，它会重定向到原来的网址。现在，每个输出URL需要是唯一的。</p><h2 id="089b" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★为给定的URL生成一个简短的唯一键</h2><p id="f050" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated"><em class="lw">例如，我们可以取一个随机缩短的网址“</em>【rb.gy/ln9zeb】<em class="lw">”。最后几个字符应该构成一个唯一的键。所以，我们的输入是用户给的一个长URL。</em></p><p id="0590" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们需要计算输入URL的唯一散列。如果我们使用base64编码，6个字符长的密钥将给我们64个^(6)= ~ 687亿个可能的字符串，这对于我们的系统应该足够了。</p><p id="c0df" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">问题:</strong>如果多个用户输入同一个网址，系统应该不会提供相同的缩短网址。如果一些字符串是重复的，系统会有什么行为？</p><p id="1b29" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">解决方案:</strong>我们可以将带有递增序列号的输入URL附加到每个请求URL。它应该使网址唯一。但是，序列号的溢出可能是一个问题。假设user-id是惟一的，我们可以将user-id附加到输入URL。</p><h2 id="bf6c" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★唯一密钥生成:</h2><p id="bacb" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">在系统中，user-id应该是唯一的，这样我们就可以计算唯一的散列。我们可以有一个独立的唯一密钥生成服务(UGS)，它预先生成随机id并将它们存储在数据库中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/4f492abd76bf44c790b35840758b9dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ihEEDoWj-NdEON-PTAGKQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图:UGS唯一密钥生成服务(图片由作者提供)</p></figure><p id="5d92" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每当我们需要一个新的密钥时，我们可以从已经生成的id中选择一个。这种方法可以使事情变得更快，因为当一个新的请求到来时，我们不需要创建一个ID，确保它的唯一性，等等。UGS将确保所有的id都是唯一的，它们可以存储在数据库中，这样就不需要每次都生成id。</p><p id="942f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因为我们需要一个字节来存储一个字符，所以我们可以将所有这些键存储在:</p><p id="f79f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">6(字符)* 68.7B(唯一键)~= 412 GB。</p><h2 id="0f4a" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★可用性和可靠性:</h2><p id="da2e" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">如果我们只保留UGS的一份拷贝，那就是单点故障。所以，我们需要做一个UGS的复制品。如果主服务器死了，备用服务器可以处理用户的请求。</p><p id="5965" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">每个UGS服务器都可以缓存key-DB中的一些密钥。它可以加快速度。但是，我们必须小心；如果一个服务器在使用完所有密钥之前就死掉了，我们就会丢失那些密钥。但是，我们可以假设，这是可以接受的，因为我们有将近68B个唯一的六字母键。</strong></p><p id="f386" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了确保可用性，我们需要确保消除系统中的单点故障。数据复制将消除单点故障并提供备份。我们可以保留多个副本，以确保数据库服务器的可靠性。此外，为了实现不间断服务，其他服务器也需要副本。</p><h2 id="2a3c" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★数据存储:</h2><p id="970f" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">在这个系统中，我们需要存储数十亿条记录。我们保存的每个对象可能小于1 KB。一个URL数据与另一个不相关。因此，我们可以使用NoSQL数据库，如Cassandra、DynamoDB等。NoSQL选择将更容易扩展，这是我们的要求之一。</p><h2 id="4116" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★可扩展性:</h2><p id="d9a3" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">为了支持数十亿个URL，我们需要对数据库进行分区，以便将数据存储到不同的数据库服务器中。</p><p id="70ce" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">I)我们可以根据哈希键的第一个字母对数据库进行分区。我们可以将以“A”开头的密钥放在一台服务器上，将“B”放在另一台服务器上。这被称为<strong class="lc iu">基于范围的分区。</strong></p><p id="d4dc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种方法的问题是它会导致不平衡的分区。例如，另一方面，以“z”开头的单词很少；我们可能有太多以字母“e”开头的URL。</p><p id="7c36" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以将不经常出现的字母组合到一个数据库分区中。</p><p id="a5f2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">ii)我们还可以基于我们存储的对象的散列进行分区。我们可以采用关键字的散列来确定可以存储数据对象的分区。哈希函数将生成一个服务器号，我们将密钥存储在该服务器中。这个过程可以使分布更加随机。这就是<strong class="lc iu">基于散列的分区。</strong></p><p id="2df8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果这种方法仍然导致分区过载，我们需要使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Consistent_hashing" rel="noopener ugc nofollow" target="_blank">一致散列法</a>。</p><h2 id="279d" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★缓存:</h2><p id="9b3a" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">我们可以缓存用户经常访问的URL。在查询数据库之前，UGS服务器可以检查缓存是否具有所需的URL。那么它不需要再次进行查询。</p><p id="d56d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">缓存满了会怎么样？我们可能会用新的或流行的URL替换旧的未使用的链接。我们可以为我们的系统选择最近最少使用的(LRU)缓存回收策略。在此策略中，我们首先删除最近最少使用的URL。</p><h2 id="1815" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★负载平衡器:</h2><p id="e4df" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">我们可以在系统的不同位置添加一个负载平衡层，在URL缩短服务器、数据库和缓存服务器之前。</p><p id="e6b4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以使用简单的循环法来分配请求。在这种方法中，LB在后端服务器之间平均分配传入的请求。这种LB方法实现起来很简单。如果一个服务器死了，LB将停止向它发送任何流量。</p><p id="20c4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">问题:如果一个服务器过载，LB不会停止向这个服务器发送新的请求。我们以后可能需要一个智能LB。</p><h2 id="884a" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★一段时间后链接过期:</h2><p id="c4e2" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">如果到了URL的到期时间，链接会发生什么？</p><p id="9b8d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以在数据存储中搜索并删除它们。这里的问题是，如果我们选择搜索过期的链接，将它们从我们的数据存储中删除，这会给我们的数据库带来很大的压力。</p><p id="134e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以用另一种方法。我们可以定期慢慢删除过期的链接。即使一些死链接存在的时间更长，它也不应该返回给用户。</p><p id="4d15" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果用户试图访问过期的链接，我们可以删除该链接并向用户返回一个错误。定期清理过程可以运行，从我们的数据库中删除过期的链接。随着存储越来越便宜，一些链接可能会留在那里，即使我们在清理时错过了。</p><p id="090f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">移除链接后，我们可以将它放回数据库以供重用。</p><h2 id="be11" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">★安全性:</h2><p id="3aac" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">我们可以将每个URL的访问类型(公共/私有)存储在数据库中。如果用户试图访问他没有权限的URL，系统会发回一个错误(HTTP 401)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/ead62f7ddd38f830fdb1d73ee679cefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Amr7wQ53nzcex_poys4bPQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图:URL缩短服务的最终设计(图片由作者提供)</p></figure><h2 id="4cbf" class="lz ma it bd mb mc md dn me mf mg dp mh lj mi mj mk ln ml mm mn lr mo mp mq mr bi translated">结论:</h2><p id="54b1" class="pw-post-body-paragraph la lb it lc b ld ms ju lf lg mt jx li lj mu ll lm ln mv lp lq lr mw lt lu lv im bi translated">在这个系统中，我们没有考虑UI部分。因为这是一个web服务，所以也不讨论客户端部分。唯一密钥生成是该系统的重要部分。因此，我们添加了一个额外的服务来创建和存储URL的唯一键。为了确保服务的可用性，我们使用了服务器复制，这样，如果一台服务器出现故障，其他服务器仍然可以提供服务。数据库也被复制以确保数据的可靠性。缓存服务器用于存储一些流行的查询，以加快延迟。并且添加了负载平衡器，以便在后端服务器之间平均分配传入的请求。</p><p id="379b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">来源:钻研系统设计面试课程。</p><p id="4089" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="lw">感谢您阅读本文。</em> <strong class="lc iu"> <em class="lw">过得愉快😃</em> </strong></p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><blockquote class="nh ni nj"><p id="ef01" class="la lb lw lc b ld le ju lf lg lh jx li nk lk ll lm nl lo lp lq nm ls lt lu lv im bi translated">本文是面向初学者的系统设计系列文章的一部分。这里是<a class="ae ky" href="https://medium.com/@ashchk/all-the-article-links-in-one-place-85c8526ead70?source=friends_link&amp;sk=7e6ee3a65895cc893a32f97d5496bed4" rel="noopener">链接</a>。</p></blockquote></div></div>    
</body>
</html>