<html>
<head>
<title>Build SMS Spam Classification Model using Naive Bayes &amp; Random Forest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用朴素贝叶斯和随机森林建立垃圾短信分类模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-sms-spam-classification-model-using-naive-bayes-random-forest-43465d6617ed?source=collection_archive---------13-----------------------#2020-11-05">https://towardsdatascience.com/build-sms-spam-classification-model-using-naive-bayes-random-forest-43465d6617ed?source=collection_archive---------13-----------------------#2020-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9931" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对数据科学感兴趣，并且正在寻找入门项目，那么垃圾短信分类项目是你应该着手的项目之一！在本教程中，我们将一步一步地从导入库到完整的模型预测，然后测量模型的准确性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/aa33bb216bf94fda7c3591068c19157b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZ0JACBXzTv4t-bdBy3o8A.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Dhaval的图片(在iPad上绘制)</p></figure><h1 id="d37c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">关于垃圾短信分类</h1><p id="28ea" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">一个好的文本分类器是这样一种分类器，它能在合理的时间范围内以可接受的准确度有效地对大量文本文档进行分类，并提供人类可读的分类规则以进行可能的微调。如果分类器的训练也很快，这可能在一些应用领域中成为分类器的良好资产。已经设计了许多用于自动文本分类的技术和算法。</p><p id="fe1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">文本分类任务可以被定义为基于在训练阶段在分类系统中获得的知识将类别标签分配给新文档。在训练阶段，给我们一组附有类别标签的文档，并使用学习方法构建一个分类系统。分类是数据挖掘和机器学习领域的一项重要任务，然而，文本分类中的大多数学习方法都来自于机器学习研究。</p><h1 id="e6ba" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Python和Pandas构建垃圾短信分类</h1><p id="a85b" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">对于这个项目，我会使用谷歌Colab，但你也可以使用python笔记本来达到同样的目的。</p><p id="6c1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">导入库</strong></p><p id="4a93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将导入所需的库，如pandas、matplotlib、numpy、sklearn</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="f4ac" class="mm lf it mi b gy mn mo l mp mq">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import scipy as sp<br/>from google.colab import drive<br/>from sklearn import feature_extraction, model_selection, naive_bayes, metrics, svm<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import precision_recall_fscore_support as score<br/>%matplotlib inline<br/><em class="mr">drive.mount</em>('/content/drive')</span></pre><p id="05de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>如果您没有使用Google Colab，可以删除代码片段的最后一行。最后一行是为了在Google Colab上安装我的Google Drive，这样我就可以使用我的Drive中的数据集。</p><p id="4417" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">导入数据集</strong></p><p id="1f61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我会上传我的GitHub repo中的数据集，可以在这里找到<a class="ae ms" href="https://github.com/dhavalthakur/SMS-Spam-Classification-using-Naive-Bayes-Random-Forest-NN" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="f0ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下载数据集后，我们将使用pandas的read_csv函数导入它。</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="a640" class="mm lf it mi b gy mn mo l mp mq">dataset = pd.read_csv(<em class="mr">"/content/drive/My Drive/SMS_Spam_Classification/spam.csv",</em> encoding='latin-1')</span></pre><p id="71bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:请使用您自己的数据集路径。</strong></p><p id="a2b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经导入了数据集，让我们看看是否使用head()函数导入了格式不正确的数据集。</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="e9d0" class="mm lf it mi b gy mn mo l mp mq">dataset.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/1ad8b40954f6c8dbe9444737bc409e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylTy_59I3lRdIUJPqKVIOQ.png"/></div></div></figure><p id="1140" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的数据集片段中，我看到了我们不需要的列名！因此，现在的任务是清理和重新格式化数据，以便我们使用它来构建我们的模型。</p><p id="714e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">数据清理&amp;探索</strong></p><p id="7485" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们必须删除未命名的列。为此，我们将使用drop函数。</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="5958" class="mm lf it mi b gy mn mo l mp mq"><em class="mr">#removing unnamed columns</em><br/>dataset = dataset.drop('Unnamed: 2', 1)<br/>dataset = dataset.drop('Unnamed: 3', 1)<br/>dataset = dataset.drop('Unnamed: 4', 1)</span></pre><p id="8421" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，下一个任务是将列<strong class="js iu"> v1 </strong>和<strong class="js iu"> v2 </strong>分别重命名为标签和消息！</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="9916" class="mm lf it mi b gy mn mo l mp mq">dataset = dataset.rename(columns = {'v1':'label','v2':'message'})</span></pre><p id="ece4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，另外(这是一个可选的步骤，但是做一些数据探索总是好的:P)</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="1a7b" class="mm lf it mi b gy mn mo l mp mq">dataset.groupby('label').describe()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mu"><img src="../Images/c6f22fe25ff9c6e8c4eaf3c3ee43b9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6Q45n1jSFR6NuCKsDD_jA.png"/></div></div></figure><p id="4969" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们想知道在我们的数据集中有多少邮件是垃圾邮件。为此:</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="1913" class="mm lf it mi b gy mn mo l mp mq">count_Class=pd.value_counts(dataset["label"], sort= True)<br/>count_Class.plot(kind = 'bar',color = ["green","red"])<br/>plt.title('Bar Plot')<br/>plt.show();</span></pre><p id="379a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">解释:</strong>这里我们设置sort = True，使用熊猫的value_counts方法。这段代码将为垃圾邮件类<strong class="js iu">和非垃圾邮件类</strong>和非垃圾邮件类<strong class="js iu">分别制作一个<strong class="js iu">绿色</strong>和<strong class="js iu">红色</strong>的条形图。</strong></p><p id="b2e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能会得到类似如下的输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/99903fbac40cbb27b0b2b9c15546a246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*Qa8gUoYvTqkiD8qxE5jPUA.png"/></div></figure><p id="f227" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到我们有很多垃圾邮件，而垃圾邮件却很少。在本教程中，我们将继续使用这个数据集，但不增加它(没有过采样/欠采样)。</p><h1 id="615d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实现用于垃圾短信分类的朴素贝叶斯</h1><p id="faef" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">首先，让我将垃圾邮件和非垃圾邮件分别编码为1和0。</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="acbe" class="mm lf it mi b gy mn mo l mp mq"><em class="mr"># Classifying spam and not spam msgs as 1 and 0</em><br/><br/>dataset["label"]=dataset["label"].map({'spam':1,'ham':0})<br/>X_train, X_test, y_train, y_test = model_selection.train_test_split(X, dataset['label'], test_size=0.70, random_state=42)</span></pre><p id="d4ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，上面代码片段的第二行使用sklearn库splot方法将数据分成训练和测试数据集。这里我提到了测试数据的大小是整个数据集的70%。(您可以在这里根据您的意愿进行更改)</p><p id="a06c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">奖励:</strong> <em class="mr"> DONT知道数据集的拆分及其好处吗？</em> <a class="ae ms" href="https://dhavalthakur.medium.com/splitting-datasets-from-0-to-hero-2d8a3d5267ad" rel="noopener"> <em class="mr">阅读我的这篇文章，我在这里解释了所有</em> </a> <em class="mr">！</em></p><p id="f2a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我将使用多项式朴素贝叶斯算法！</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="4a2c" class="mm lf it mi b gy mn mo l mp mq">list_alpha = np.arange(1/100000, 20, 0.11)<br/>score_train = np.zeros(len(list_alpha))<br/>score_test = np.zeros(len(list_alpha))<br/>recall_test = np.zeros(len(list_alpha))<br/>precision_test= np.zeros(len(list_alpha))<br/>count = 0<br/><strong class="mi iu">for</strong> alpha <strong class="mi iu">in</strong> list_alpha:<br/>    bayes = naive_bayes.MultinomialNB(alpha=alpha)<br/>    bayes.fit(X_train, y_train)<br/>    score_train[count] = bayes.score(X_train, y_train)<br/>    score_test[count]= bayes.score(X_test, y_test)<br/>    recall_test[count] = metrics.recall_score(y_test, bayes.predict(X_test))<br/>    precision_test[count] = metrics.precision_score(y_test, bayes.predict(X_test))<br/>    count = count + 1</span></pre><p id="76d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您所看到的，我还加入了一个回忆测试和精度测试，以便更准确地评估我的模型的性能。</p><p id="35f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，对于不同的α值，我会制作一个表格来查看各种度量，如训练准确度、测试准确度、测试召回率、测试精确度。</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="7fcc" class="mm lf it mi b gy mn mo l mp mq">matrix = np.matrix(np.c_[list_alpha, score_train, score_test, recall_test, precision_test])<br/>models = pd.DataFrame(data = matrix, columns = <br/>             ['alpha', 'Train Accuracy', 'Test Accuracy', 'Test Recall', 'Test Precision'])<br/>models.head(n=10)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/cd7adc01eb5ff469682dd32c5ae93a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEhnXHsGFij0_9Ed2QjqBA.png"/></div></div></figure><p id="542f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们必须看到测试精度的最佳指标，因为我在这里更关心它。请注意，我们并不总是必须使用精度来评估我们的模型。它总是取决于您的用例！</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="767f" class="mm lf it mi b gy mn mo l mp mq">best_index = models['Test Precision'].idxmax()<br/>models.iloc[best_index, :]</span><span id="9d5d" class="mm lf it mi b gy mx mo l mp mq"><strong class="mi iu">OUTPUT: -</strong></span><span id="1a60" class="mm lf it mi b gy mx mo l mp mq">alpha             10.670010<br/>Train Accuracy     0.977259<br/>Test Accuracy      0.962574<br/>Test Recall        0.720307<br/>Test Precision     1.000000</span></pre><h1 id="17e2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实现随机森林</h1><p id="e962" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我将使用RandomForestClassifier函数，n_estimators为100(您可以根据自己的意愿更改它以获得最佳结果)</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="8a52" class="mm lf it mi b gy mn mo l mp mq">rf = RandomForestClassifier(n_estimators=100,max_depth=<strong class="mi iu">None</strong>,n_jobs=-1)<br/>rf_model = rf.fit(X_train,y_train)</span></pre><p id="4816" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码片段中，上次我用X_train和y_train拟合我的模型。</p><p id="af47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看预测。我会使用预测功能和计算精度，召回，f分数，以及准确性措施。</p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="40c5" class="mm lf it mi b gy mn mo l mp mq">y_pred=rf_model.predict(X_test)<br/>precision,recall,fscore,support =score(y_test,y_pred,pos_label=1, average ='binary')<br/>print('Precision : <strong class="mi iu">{}</strong> / Recall : <strong class="mi iu">{}</strong> / fscore : <strong class="mi iu">{}</strong> / Accuracy: <strong class="mi iu">{}</strong>'.format(round(precision,3),round(recall,3),round(fscore,3),round((y_pred==y_test).sum()/len(y_test),3)))</span></pre><p id="802c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">车型评价</strong></p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="3895" class="mm lf it mi b gy mn mo l mp mq">Precision : 0.995 / Recall : 0.726 / fscore : 0.839 / Accuracy: 0.963</span></pre><p id="edda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们看到，我们的模型的准确性约为96 %,我认为这相当不错。它的精度值也接近1，这也是一个不错的值。</p><p id="fd70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的下一篇文章中，我将使用NLP和神经网络，并解释我们如何才能得到一个更准确的模型！</p><p id="7dc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这个教程，请分享给你的朋友或在社交媒体上！</p><p id="16a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想聊聊数据科学吗？在<a class="ae ms" href="https://www.linkedin.com/in/thedhavalthakur/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上Ping我！</p></div></div>    
</body>
</html>