<html>
<head>
<title>The Magic of Python Context Managers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python上下文管理器的魔力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-magic-of-python-context-managers-adb92ace1dd0?source=collection_archive---------8-----------------------#2020-10-01">https://towardsdatascience.com/the-magic-of-python-context-managers-adb92ace1dd0?source=collection_archive---------8-----------------------#2020-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f4ed" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="bcbd" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用和创建令人敬畏的Python上下文管理器的方法，这将使您的代码更可读、更可靠、更不容易出错…</h2></div><p id="1d3d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">资源管理是任何编程语言都需要做的事情之一。无论您处理的是锁、文件、会话还是数据库连接，您都必须确保关闭并释放这些资源，以便它们正常运行。通常，人们会使用<code class="fe ln lo lp lq b">try/finally</code>来完成这个任务——使用<code class="fe ln lo lp lq b">try</code>块中的资源，并在<code class="fe ln lo lp lq b">finally</code>块中释放它。然而在Python中，有一种更好的方法——使用<code class="fe ln lo lp lq b">with</code>语句实现<em class="lr">上下文管理协议</em>。</p><p id="bd21" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因此，在这篇文章中，我们将探索它是什么，它是如何工作的，最重要的是你可以在哪里找到以及如何实现你自己的令人敬畏的<em class="lr">上下文管理器</em>！</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/1422a793a368cdbad938043198ce5132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3csmEnWN6AJ3ZWhSokRMg.jpeg"/></div></div><p class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae mi" href="https://unsplash.com/@beckerworks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·贝克尔</a>在<a class="ae mi" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="cb72" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">什么是上下文管理器？</h1><p id="f674" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">即使你没有听说过Python的<em class="lr">上下文管理器</em>，你也已经知道——根据介绍——它是<code class="fe ln lo lp lq b">try/finally</code>块的替代品。使用打开文件时常用的<code class="fe ln lo lp lq b">with</code>语句实现。与<code class="fe ln lo lp lq b">try/finally</code>相同，引入这种模式是为了保证某些操作将在程序块的末尾执行，即使出现异常或程序终止。</p><p id="24d7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从表面上看，<em class="lr">上下文管理协议</em>只是围绕代码块的<code class="fe ln lo lp lq b">with</code>语句。实际上，它包括两个特殊的(<em class="lr"> dunder </em>)方法- <code class="fe ln lo lp lq b">__enter__</code>和<code class="fe ln lo lp lq b">__exit__</code> -分别方便设置和拆卸。</p><p id="a747" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当代码中遇到<code class="fe ln lo lp lq b">with</code>语句时，<code class="fe ln lo lp lq b">__enter__</code>方法被触发，其返回值被放入<code class="fe ln lo lp lq b">as</code>限定符后面的变量中。在<code class="fe ln lo lp lq b">with</code>块的主体执行后，<code class="fe ln lo lp lq b">__exit__</code>方法被调用来执行teardown -完成<code class="fe ln lo lp lq b">finally</code>块的角色。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a40c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面的代码展示了使用<code class="fe ln lo lp lq b">try/finally</code>的版本和使用<code class="fe ln lo lp lq b">with</code>语句实现简单定时器的更优雅的版本。我在上面提到过，实现这样的<em class="lr">上下文管理器</em>需要<code class="fe ln lo lp lq b">__enter__</code>和<code class="fe ln lo lp lq b">__exit__</code>，但是我们如何着手创建它们呢？让我们看看这个<code class="fe ln lo lp lq b">Timer</code>类的代码:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bda4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这段代码片段显示了实现了<code class="fe ln lo lp lq b">__enter__</code>和<code class="fe ln lo lp lq b">__exit__</code>方法的<code class="fe ln lo lp lq b">Timer</code>类。<code class="fe ln lo lp lq b">__enter__</code>方法只启动定时器并返回<code class="fe ln lo lp lq b">self</code>，它将在<code class="fe ln lo lp lq b">with ... as some_var</code>中被赋值。在<code class="fe ln lo lp lq b">with</code>语句体完成后，用3个参数调用<code class="fe ln lo lp lq b">__exit__</code>方法——异常类型、异常值和回溯。如果在<code class="fe ln lo lp lq b">with</code>语句体中一切顺利，这些都等于<code class="fe ln lo lp lq b">None</code>。如果出现异常，就会用异常数据填充，我们可以在<code class="fe ln lo lp lq b">__exit__</code>方法中处理这些数据。在这种情况下，我们忽略异常处理，只停止计时器并计算运行时间，将其存储在上下文管理器的属性中。</p><p id="97b0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们已经在这里看到了<code class="fe ln lo lp lq b">with</code>语句的实现和示例用法，但是为了有更多的关于<em class="lr">实际上发生了什么的可视化示例，让我们看看在没有Python的语法糖的情况下，这些特殊的方法是如何被调用的:</em></p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5cbb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">既然我们已经确定了什么是上下文管理器，它是如何工作的以及如何实现它，让我们看看使用它的好处——只是为了有更多的动力从<code class="fe ln lo lp lq b">try/finally</code>语句切换到<code class="fe ln lo lp lq b">with</code>语句。</p><p id="51e7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">第一个好处是整个安装和拆卸都在上下文管理器对象的控制下进行。这可以防止错误并减少样板代码，从而使API更安全、更易于使用。使用它的另一个原因是<code class="fe ln lo lp lq b">with</code>块突出了关键部分，并鼓励您减少该部分的代码量，这通常也是一个好的实践。最后，也是最重要的一点，这是一个很好的重构工具，它将常见的设置和拆卸代码分离出来，并转移到一个地方，即<code class="fe ln lo lp lq b">__enter__</code>和<code class="fe ln lo lp lq b">__exit__</code>方法。</p><p id="9b07" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">也就是说，如果你以前没有使用过上下文管理器，我希望我说服你开始使用它们而不是<code class="fe ln lo lp lq b">try/finally</code>。所以，现在让我们看看一些很酷很有用的上下文管理器，你应该开始把它们包含在你的代码中！</p><h1 id="f249" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">使用<code class="fe ln lo lp lq b">@contextmanager</code>使其变得简单</h1><p id="ddda" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">在上一节中，我们探讨了如何使用<code class="fe ln lo lp lq b">__enter__</code>和<code class="fe ln lo lp lq b">__exit__</code>方法实现上下文管理器。这很简单，但是我们可以使用<code class="fe ln lo lp lq b">contextlib</code>，更具体地使用<code class="fe ln lo lp lq b">@contextmanager</code>，让它变得更简单。</p><p id="2a82" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ln lo lp lq b">@contextmanager</code>是一个装饰器，可以用来编写独立的上下文管理函数。因此，我们不需要创建整个类并实现<code class="fe ln lo lp lq b">__enter__</code>和<code class="fe ln lo lp lq b">__exit__</code>方法，我们只需要创建一个生成器:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1416" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个代码片段实现了与上一节中的<code class="fe ln lo lp lq b">Timer</code>类非常相似的上下文管理器。然而这一次，我们需要更少的代码。这段代码有两部分——在<code class="fe ln lo lp lq b">yield</code>之前的所有内容和在<code class="fe ln lo lp lq b">yield</code>之后的所有内容。<code class="fe ln lo lp lq b">yield</code>之前的代码接替<code class="fe ln lo lp lq b">__enter__</code>方法的工作，<code class="fe ln lo lp lq b">yield</code>本身就是<code class="fe ln lo lp lq b">__enter__</code>方法的<code class="fe ln lo lp lq b">return</code>语句。<code class="fe ln lo lp lq b">yield</code>之后的一切都是<code class="fe ln lo lp lq b">__exit__</code>方法的一部分。</p><p id="3785" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如您在上面看到的，像这样使用单个函数创建上下文管理器需要使用<code class="fe ln lo lp lq b">try/finally</code>，因为如果在<code class="fe ln lo lp lq b">with</code>语句体中出现异常，它将在带有<code class="fe ln lo lp lq b">yield</code>的行中被引发，我们将需要在对应于<code class="fe ln lo lp lq b">__exit__</code>方法的<code class="fe ln lo lp lq b">finally</code>块中处理它。</p><p id="ea29" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如我已经提到的，这可以用于自包含的上下文管理器。然而，它不适合需要成为对象一部分的上下文管理器，例如连接或锁。</p><p id="5b71" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">尽管使用单一函数构建上下文管理器会迫使您使用<code class="fe ln lo lp lq b">try/finally</code>，并且只能用于更简单的用例，但在我看来，这仍然是构建更精简的上下文管理器的优雅而实用的选择。</p><h1 id="54b4" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">现实生活中的例子</h1><p id="6ac9" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">现在让我们从理论转到实际有用的上下文管理器，您可以自己构建它。</p><h1 id="d7f9" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">日志记录上下文管理器</h1><p id="01a2" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">当需要尝试找出代码中的一些bug时，您可能会首先查看日志来找到问题的根源。然而，这些日志可能被默认设置为<em class="lr">错误</em>或<em class="lr">警告</em>级别，这可能不足以用于调试目的。更改整个程序的日志级别应该很容易，但是更改特定代码段的日志级别可能会更复杂——不过，这可以通过下面的上下文管理器轻松解决:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="6465" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">超时上下文管理器</h1><p id="05ed" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">在本文的开始，我们是在玩代码的计时块。相反，我们将尝试为由<code class="fe ln lo lp lq b">with</code>语句包围的块设置超时:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="32a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面的代码为这个上下文管理器声明了名为<code class="fe ln lo lp lq b">timeout</code>的类，因为这个任务不能在单个函数中完成。为了能够实现这种超时，我们还需要使用信号——更具体地说是<code class="fe ln lo lp lq b">SIGALRM</code>。我们首先使用<code class="fe ln lo lp lq b">signal.signal(...)</code>将handler设置为<code class="fe ln lo lp lq b">SIGALRM</code>，这意味着当内核引发<code class="fe ln lo lp lq b">SIGALRM</code>时，我们的handler函数将被调用。至于这个处理函数(<code class="fe ln lo lp lq b">_timeout_handler</code>)，它所做的只是抛出<code class="fe ln lo lp lq b">TimeoutError</code>，如果没有及时完成，它将停止执行<code class="fe ln lo lp lq b">with</code>语句的主体。处理程序就绪后，我们还需要开始指定秒数的倒计时，这由<code class="fe ln lo lp lq b">signal.alarm(self.seconds)</code>完成。</p><p id="59bf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">至于<code class="fe ln lo lp lq b">__exit__</code>方法——如果上下文管理器的主体设法在时间到期前完成，那么<code class="fe ln lo lp lq b">SIGALRM</code>将被<code class="fe ln lo lp lq b">signal.alarm(0)</code>取消，程序可以继续。另一方面，如果由于超时而产生信号，那么<code class="fe ln lo lp lq b">_timeout_handler</code>将产生<code class="fe ln lo lp lq b">TimeoutError</code>，而<code class="fe ln lo lp lq b">TimeoutError</code>将被<code class="fe ln lo lp lq b">__exit__</code>捕获并抑制，那么<code class="fe ln lo lp lq b">with</code>语句的主体将被中断，代码的剩余部分可以继续执行。</p><h1 id="9504" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">利用已经存在的东西</h1><p id="fe86" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">除了上面的上下文管理器，在标准库或者其他常用的库中已经有很多有用的了，比如<code class="fe ln lo lp lq b">request</code>或者<code class="fe ln lo lp lq b">sqlite3</code>。让我们看看能在里面找到什么。</p><h1 id="5fa3" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">临时更改小数精度</h1><p id="f885" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">如果您正在进行大量的数学运算并需要特定的精度，那么您可能会遇到需要临时更改十进制数精度的情况:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="361a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面的代码演示了没有上下文管理器和有上下文管理器的两个选项。第二种选择显然更简短，可读性更强。它还排除了临时上下文，使其不容易出错。</p><h1 id="52ac" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">从<code class="fe ln lo lp lq b">contextlib</code>开始的所有事情</h1><p id="1a8f" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">当使用<code class="fe ln lo lp lq b">@contextmanager</code>时，我们已经偷看了<code class="fe ln lo lp lq b">contextlib</code>，但是还有更多我们可以使用的东西——作为第一个例子，让我们看看<code class="fe ln lo lp lq b">redirect_stdout</code>和<code class="fe ln lo lp lq b">redirect_stderr</code>:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9332" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你有工具或者函数默认输出所有数据到<code class="fe ln lo lp lq b">stdout</code>或者<code class="fe ln lo lp lq b">stderr</code>，但是你更喜欢它输出数据到其他地方——比如文件——那么这两个上下文管理器可能会很有帮助。和前面的例子一样，这极大地提高了代码的可读性，并消除了不必要的视觉干扰。</p><p id="72ec" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">另一个来自<code class="fe ln lo lp lq b">contextlib</code>的便利工具是<code class="fe ln lo lp lq b">suppress</code>上下文管理器，它将抑制任何不想要的异常和错误:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5425" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正确处理异常当然更好，但是有时候你只需要去掉那个讨厌的<code class="fe ln lo lp lq b">DeprecationWarning</code>，这个上下文管理器至少会让它可读。</p><p id="21bf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我要提到的<code class="fe ln lo lp lq b">contextlib</code>中的最后一个实际上是我最喜欢的，它叫做<code class="fe ln lo lp lq b">closing</code>:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e834" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个上下文管理器将关闭作为参数传递给它的任何资源——在上面的例子中——这将是<code class="fe ln lo lp lq b">page</code>对象。至于在后台实际发生了什么——上下文管理器实际上只是强制调用<code class="fe ln lo lp lq b">page</code>对象的<code class="fe ln lo lp lq b">.close()</code>方法，就像使用<code class="fe ln lo lp lq b">try/finally</code>选项一样。</p><h1 id="991c" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">用于更好测试的上下文管理器</h1><p id="a956" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">如果你想让人们使用、阅读或维护你写的测试，你必须让它们易读易懂，而<code class="fe ln lo lp lq b">mock.patch</code>上下文管理器可以帮助你做到这一点:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="057a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">将<code class="fe ln lo lp lq b">mock.patch</code>与上下文管理器一起使用可以让您摆脱不必要的<code class="fe ln lo lp lq b">.start()</code>和<code class="fe ln lo lp lq b">.stop()</code>调用，并帮助您定义这个特定模拟的明确范围。这个工具的好处是它既能与<code class="fe ln lo lp lq b">unittest</code>一起工作，也能与<code class="fe ln lo lp lq b">pytest</code>一起工作，尽管它是标准库的一部分(因此也是<code class="fe ln lo lp lq b">unittest</code>)。</p><p id="bcb4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">说到<code class="fe ln lo lp lq b">pytest</code>，让我们也从这个库中展示至少一个非常有用的上下文管理器:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="53a4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个例子展示了<code class="fe ln lo lp lq b">pytest.raises</code>的非常简单的用法，它断言代码块引发了所提供的异常。如果没有，那么测试失败。这对于测试预计会引发异常或以其他方式失败的代码路径非常方便。</p><h1 id="6ccd" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">跨请求保持会话</h1><p id="28eb" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">从<code class="fe ln lo lp lq b">pytest</code>前往另一个伟大的图书馆——<code class="fe ln lo lp lq b">requests</code>。通常，您可能需要在HTTP请求之间保留cookies，需要保持TCP连接活动，或者只想对同一台主机执行多个请求。<code class="fe ln lo lp lq b">requests</code>提供了良好的上下文管理器来帮助应对这些挑战，即管理会话:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e39b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">除了解决上述问题，这个上下文管理器还可以帮助提高性能，因为它将重用底层连接，从而避免为每个请求/响应对打开新的连接。</p><h1 id="6309" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">管理SQLite事务</h1><p id="117b" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">最后但同样重要的是，还有用于管理SQLite事务的上下文管理器。除了让你的代码更整洁，这个上下文管理器还提供了在异常情况下回滚更改的能力，以及在<code class="fe ln lo lp lq b">with</code>语句体成功完成时自动提交:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="fbbf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这个例子中，您还可以看到<code class="fe ln lo lp lq b">closing</code>上下文管理器的良好使用，它有助于处理不再使用的连接对象，这进一步简化了代码，并确保我们不会让任何连接挂起。</p><h1 id="c96f" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">结论</h1><p id="5af3" class="pw-post-body-paragraph kr ks it kt b ku nb kd kw kx nc kg kz la nd lc ld le ne lg lh li nf lk ll lm im bi translated">我想强调的一点是，上下文管理器不仅仅是资源管理工具，而是一种特性，它允许您提取和分解任何一对操作的常见设置和拆卸，而不仅仅是像锁或网络连接这样的常见用例。这也是python的一大特色，你可能在其他语言中找不到。它简洁而优雅，所以希望本文向您展示了上下文管理器的强大功能，并向您介绍了在代码中使用它们的更多方法。🙂</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="0ee5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="lr">本文最初发布于</em><a class="ae mi" href="https://martinheinz.dev/blog/34?utm_source=tds&amp;utm_medium=referral&amp;utm_campaign=blog_post_34" rel="noopener ugc nofollow" target="_blank"><em class="lr">martinheinz . dev</em></a></p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/ultimate-setup-for-your-next-python-project-179bda8a7c2c"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">下一个Python项目的最终设置</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">从零开始任何项目都可能是一项艰巨的任务…但如果您有这个最终的Python项目蓝图就不会了！</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og mc ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/writing-more-idiomatic-and-pythonic-code-c22e900eaf83"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">编写更加地道和Pythonic化的代码</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使你的Python代码可读、有效、简洁和可靠的习惯用法和惯例。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og mc ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/ultimate-guide-to-python-debugging-854dea731e1b"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">Python调试终极指南</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">让我们探索使用Python日志记录、回溯、装饰器等等进行调试的艺术…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oi l od oe of ob og mc ns"/></div></div></a></div></div></div>    
</body>
</html>