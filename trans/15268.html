<html>
<head>
<title>Building a Database — Without a Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建数据库—没有数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-database-without-a-database-41fcbf586dd6?source=collection_archive---------28-----------------------#2020-10-20">https://towardsdatascience.com/building-a-database-without-a-database-41fcbf586dd6?source=collection_archive---------28-----------------------#2020-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a53" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建pythonic数据库类来获取、清理、转换、合并和标记数据——所有这些都不需要数据库</h2></div><p id="52fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">机器学习实践者和数据工程师都很清楚数据来源、收集、清理、转换、合并和标记的可重复性。这些活动的目的是为简化、探索性分析或建模准备数据。例如，<a class="ae ln" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>通过它们的<a class="ae ln" href="https://scikit-learn.org/stable/modules/compose.html" rel="noopener ugc nofollow" target="_blank"> Pipeline </a>类在抽象数据管道方面做得非常出色。尽管如此，从多个来源提取数据的问题仍然存在，因为没有多少简单的抽象使数据争论者的生活更容易。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/761677ee6f22c8145dc77ba28ff64590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*DgoxLiNJ5cCe0QSuZB0QNA.png"/></div><p class="md me gj gh gi mf mg bd b be z dk translated">Python数据库类|📸由<a class="ae ln" href="https://www.linkedin.com/in/dylancunningham/" rel="noopener ugc nofollow" target="_blank">我</a></p></figure><p id="109a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">问题陈述:</strong>不同的数据是不同的，合并起来很麻烦。</p><p id="b0d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">解决方案:</strong>开发一个pythonic数据库抽象，以一种易于使用、健壮且生产就绪的方式合并您的数据。</p><h2 id="7e15" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">目录</h2><ol class=""><li id="95e3" class="na nb it kk b kl nc ko nd kr ne kv nf kz ng ld nh ni nj nk bi translated">抽象</li><li id="dd8b" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">数据库—没有数据库—抽象</li><li id="4a30" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">介绍Python数据库抽象</li><li id="bc78" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">如何</li></ol><h2 id="832b" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">关键概念</h2><p id="88f2" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">抽象使得编程生活更容易管理。一个数据库——没有数据库——抽象将使您的数据争论生活更加舒适，并且将是您的生产管道的一个健壮的补充。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="bcb5" class="nt mi it bd mj nu nv nw mm nx ny nz mp jz oa ka ms kc ob kd mv kf oc kg my od bi translated">1.抽象</h1><p id="9ed4" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">为了不重复网上的文章，我将不解释抽象，但这里有两个参考:</p><ul class=""><li id="a210" class="na nb it kk b kl km ko kp kr oe kv of kz og ld oh ni nj nk bi translated"><a class="ae ln" href="https://medium.com/@mattburgess/critical-concept-abstraction-ba9e9c0f225e" rel="noopener">关键概念:抽象</a>(通过媒介)</li><li id="5305" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld oh ni nj nk bi translated">"<a class="ae ln" href="https://stackify.com/oop-concept-abstraction/" rel="noopener ugc nofollow" target="_blank">面向初学者的OOP概念:什么是抽象？</a>(通过Stackify)</li></ul><blockquote class="oi"><p id="90de" class="oj ok it bd ol om on oo op oq or ld dk translated">抽象被定义为位于更复杂的事物之上，并使其对用户更简单的事物。—马特·伯吉斯在《批判的概念:抽象》中</p></blockquote></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="4732" class="nt mi it bd mj nu nv nw mm nx ny nz mp jz oa ka ms kc ob kd mv kf oc kg my od bi translated">2.数据库—没有数据库—抽象</h1><p id="2e57" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">没有数据库的数据库抽象(我称之为数据库抽象；不要与SQL数据库混淆)至少有四个用途:</p><ul class=""><li id="85b7" class="na nb it kk b kl km ko kp kr oe kv of kz og ld oh ni nj nk bi translated">您只需要编写一次数据争论代码</li><li id="d42f" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld oh ni nj nk bi translated">生产一个ML模型是非常容易的</li><li id="9f06" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld oh ni nj nk bi translated">您不需要数据存储</li><li id="15d5" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld oh ni nj nk bi translated">争论操作的顺序被保留并且是灵活的。</li></ul><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="ot ou di ov bf ow"><div class="gh gi os"><img src="../Images/cf6fc7774fbc8dec49ce832335288451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPIu_lOM0plejMUMbMC-ew.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">Python数据库抽象图|📸由<a class="ae ln" href="https://www.linkedin.com/in/dylancunningham/" rel="noopener ugc nofollow" target="_blank">我</a></p></figure><h2 id="932f" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated"><strong class="ak">你只需要写一次数据角力代码。</strong></h2><p id="9e46" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">如果有足够的远见，数据库抽象将抽象出重复进行所有争论操作的需要。挑战是使抽象足够好，以允许用户以健壮和易于使用的方式灵活地应用他们喜欢的任何操作。</p><p id="66ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是众所周知的数据争论操作的一个不全面的列表:查询、排序、转换、填充空值和合并。为每一个实验和/或每一个生产模型编写代码来完成这些操作(甚至更多)是很难的。</p><h2 id="3e7d" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">生产一个ML模型是非常容易的。</h2><p id="bcfb" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">ML管道的最终目标是做出预测(例如，对于大多数ML任务)。数据科学家面临的一个问题是可重复性。当数据科学家处于试验阶段时，他们会应用各种各样的争论操作来测试哪个是最佳的。将最佳操作转移到生产场景并不总是容易的。</p><p id="d7d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据库抽象将允许科学家以可重复的方式轻松地从实验阶段过渡到生产阶段，然后再返回。</p><h2 id="c492" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated"><strong class="ak">你不需要数据存储。</strong></h2><p id="20e6" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">数据库抽象不需要本地或基于云的数据存储，但是您可能希望授予用户这种能力。在我的例子中，我不想管理数据库。我只是构建与web APIs、网页等交互的功能。</p><blockquote class="oi"><p id="60ec" class="oj ok it bd ol om ox oy oz pa pb ld dk translated">他们的数据库是我的数据库，但他们的数据库问题不是我的问题。</p></blockquote><p id="bcb2" class="pw-post-body-paragraph ki kj it kk b kl pc ju kn ko pd jx kq kr pe kt ku kv pf kx ky kz pg lb lc ld im bi translated">注意:这种抽象的一个限制是查询速度。如果您管理自己的数据库，您可能会提高查询的性能。</p><h2 id="2e8a" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated"><strong class="ak">角力作战的秩序被保留了下来，而且很灵活。</strong></h2><p id="06a7" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">这个目的很重要，也是一个考虑不周的问题。把操作的顺序留给用户自己去理解和记忆是一个过分的要求。解决方案是构建一次——将操作的逻辑和顺序记录下来并构建一次——然后就不必再构建一次了。</p><p id="c59d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">操作顺序失败示例:下面的折线图显示，如果您对已经向前填充的价格序列计算移动平均，那么您的结果将会滞后。滞后的信息是不理想的。对于这些争论不休的任务，正确的操作顺序是在跨日期展开系列之前计算移动平均值，合并到主数据集，然后向前填充。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/8c60f55da13ced10327238d6f404a266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1KIN3CX9QRCJtUuk15NYDw.png"/></div><p class="md me gj gh gi mf mg bd b be z dk translated">📸由<a class="ae ln" href="https://www.linkedin.com/in/dylancunningham/" rel="noopener ugc nofollow" target="_blank">我</a></p></figure></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="d100" class="nt mi it bd mj nu nv nw mm nx ny nz mp jz oa ka ms kc ob kd mv kf oc kg my od bi translated">3.介绍Python数据库抽象</h1><p id="0647" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">下面的数据库抽象是以生产就绪的方式合并、转换和合并数据的强大而健壮的方法。它是生产管道的第一步(见上图)。事实上，您可能会以某种方式创新和合并scikit-learn管道功能。一种可能是创建一个名为MyPipeline的新类，确保继承您的数据库类。然后，您的服务、lambda或脚本可以使用您需要的所有功能来调用MyPipeline。</p><p id="4226" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会注意到我没有为你做所有的工作。这种抽象25%集中在金融领域。唯一的数据源是<a class="ae ln" href="https://alpaca.markets/" rel="noopener ugc nofollow" target="_blank">羊驼</a>(我只展示我的类如何与羊驼交互，因为他们的API很简单，我的目的是教你如何钓鱼，而不是给你一个装满鱼的数据库)。你可能想要/需要更多的数据来源。此外，我的代码假设被争论的数据是时间序列数据。其余75%的代码通常已经准备好供您复制、粘贴和开箱即用。我建议您根据自己的需要修改这段代码。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="2459" class="nt mi it bd mj nu nv nw mm nx ny nz mp jz oa ka ms kc ob kd mv kf oc kg my od bi translated">4.如何</h1><p id="ab07" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">在我们进入所有代码之前，我想向您展示一个用户或系统如何与这个数据库类交互。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="d358" class="mh mi it pj b gy pn po l pp pq">dct = # shown later<br/><br/>database = Database(dct).build()</span></pre><p id="a1ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单吧？</p><blockquote class="pr ps pt"><p id="3485" class="ki kj pu kk b kl km ju kn ko kp jx kq pv ks kt ku pw kw kx ky px la lb lc ld im bi translated"><em class="it">请注意，我将带您回顾数据库课程。例如，在我解释</em>构建<em class="it">方法之前，我解释一下</em>特性<em class="it">和</em>目标<em class="it">方法，当</em>构建<em class="it">方法使用</em>特性<em class="it">和</em>目标<em class="it">方法时。</em></p></blockquote></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="8ec9" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">初始化</h2><p id="772c" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu"> <em class="pu">首先</em> </strong>，我们创建自己的类对象，并为用户提供一种与我们的抽象轻松交互的方式:通过<em class="pu"> __init__ </em>方法。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="ed24" class="mh mi it pj b gy pn po l pp pq">class Database:<br/>    final_dataset = None<br/>    data_cache_ = {<br/>        'alpaca': {},<br/>    }<br/><br/>    def __init__(self, dct: dict, jobs: int=1):<br/>        <em class="pu">"""<br/>        Initialize<br/><br/>        :param dct: user parameters<br/>        :param jobs: number of processes<br/>        """<br/>        </em>self.dct = dct<br/>        self.jobs = jobs<br/>        self.config = dct<br/><br/>        self.date_dataset = pd.DataFrame(<br/>            index=pd.date_range(<br/>                start=self.config.get(<br/>                    'globals', {}).setdefault(<br/>                    'start_date', '2010-01-01'),<br/>                end=self.config.get(<br/>                    'globals').setdefault(<br/>                    'end_date', str(datetime.now().date() \<br/>                                    - timedelta(days=252 / 4))),<br/>                name='Date'))<br/><br/>    def cache_data(self, source: str, key: str, json_data: dict):<br/>        <em class="pu">"""<br/>        Cache unique raw data<br/><br/>        :param source: data source (e.g., alpaca)<br/>        :param key: unique identifier of raw data<br/>        :param json_data: response from data request<br/>        """<br/>        </em>_ = self.data_cache_.get(source).setdefault(key, json_data)</span></pre><p id="adc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们希望用户传入一个字典(如果需要，您可以构建自己的类，允许用户以字符串形式指定存储json文件的文件路径),指定所需数据的位置、如何获取数据、应用什么转换、用什么命名数据等。这是用户需要的一切。</p><p id="2ab1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们了解用户词典的外观之前，这里有一些后续要点:</p><ol class=""><li id="0d72" class="na nb it kk b kl km ko kp kr oe kv of kz og ld nh ni nj nk bi translated">数据缓存:由于我们不依赖于数据存储，如果我们要查询数据并对相同的数据应用不同的操作，那么我们希望缓存原始数据，这样我们就不会多次查询相同的数据。缓存原始数据将加快你的工作。</li><li id="bd1f" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">多处理引擎:用户可以指定运行作业的作业或进程的数量。你所需要的是一个多重处理引擎。(如果你想了解更多关于如何设置你的引擎的知识，我将很快写一篇关于马科斯·洛佩兹·德·普拉多在他的一本书中谈到的引擎的文章，<a class="ae ln" href="https://www.amazon.com/Advances-Financial-Machine-Learning-Marcos/dp/1119482089" rel="noopener ugc nofollow" target="_blank">这里</a>。)</li><li id="81c4" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">样本外(OOS)数据:我写这个类的方式有一些细微差别。例如，我用金融机器学习的视角写了这个类。在金融机器学习中，我们的数据一般是时间/价格序列数据。所以，我把最后的252/4=63天留作纸上交易。该论文数据集被认为是样本外的。(最后，我得到了训练、验证、测试和OOS数据集。)</li></ol></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="5270" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">用户交互</h2><p id="a5f8" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu"> <em class="pu">第二个</em> </strong>，这个类提供了足够有用的结构，而且也很灵活。在我的例子中，用户交互非常冗长。我希望用户交互清晰无误。我还希望用户能够轻松地抬起和移动。为此，数据库类需要一个包含不同级别的<em class="pu">键:值</em>对的字典，如下所示。</p><p id="1bca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一级键是<em class="pu">全局</em>、<em class="pu">目标</em>和<em class="pu">特征</em>。Globals用于指定整个数据集级别的参数。Target用于指定应该为目标使用什么数据，以及应该应用什么标记技术(即转换)。特征用于指定哪些数据应该用作建模的特征。</p><p id="d9cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二层的<em class="pu">键:值</em>对需要关于数据源、参数(kwargs)、从源返回的数据的名称、要删除的特性(不需要，取决于源输出)以及数据类型的信息。</p><p id="b949" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三层的<em class="pu"> key: value </em>对允许对底层数据进行转换。这些变换以一种易于理解的方式逐一应用于每个单独的特征。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="a463" class="mh mi it pj b gy pn po l pp pq">dct = {<br/>    "globals": {<br/>        "start_date": "2010-01-01"<br/>    },<br/>    "target": {<br/>        "source": "alpaca",<br/>        "kwargs": {<br/>            "timeframe": "day",<br/>            "symbols": "AAPL",<br/>            "limit": "0",<br/>            "start": "2000-01-01"},<br/>        "clean": {<br/>            "names": [<br/>                "open",<br/>                "high",<br/>                "low",<br/>                "target",<br/>                "volume"<br/>            ],<br/>            "drop": [<br/>                "open",<br/>                "high",<br/>                "low",<br/>                "volume"<br/>            ],<br/>            "types": [<br/>                "float"<br/>            ]<br/>        },<br/>        "transformations": [<br/>            {<br/>                "function": "trend_scanning_label",<br/>                "kwargs": {<br/>                    "name": "target"<br/>                }<br/>            }<br/>        ]<br/>    },<br/>    "features": [<br/>        {<br/>            "source": "alpaca",<br/>            "kwargs": {<br/>                "timeframe": "day",<br/>                "symbols": "AAPL",<br/>                "limit": "0",<br/>                "start": "2000-01-01"<br/>            },<br/>            "clean": {<br/>                "names": [<br/>                    "open",<br/>                    "high",<br/>                    "low",<br/>                    "close",<br/>                    "volume"<br/>                ],<br/>                "drop": [<br/>                    "open",<br/>                    "high",<br/>                    "low",<br/>                    "volume"<br/>                ],<br/>                "types": [<br/>                    "float"<br/>                ],<br/>            },<br/>            "transformations": [<br/>                {<br/>                    "function": "rsi",<br/>                    "kwargs": {<br/>                        "days": 14<br/>                    }<br/>                }<br/>            ]<br/>        }<br/>    ]<br/>}</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="b2fa" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">要求</h2><p id="6e6a" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu"> <em class="pu">第三个</em> </strong>，below方法请求数据，不考虑API。这个方法将url、headers和kwargs作为参数。数据以字典的形式返回，稍后进行处理。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="9da6" class="mh mi it pj b gy pn po l pp pq">@staticmethod<br/>def request_data(base_url: str, headers: dict=None, **kwargs):<br/>    <em class="pu">"""<br/>    Request data through web api<br/><br/>    :param base_url: data source base url<br/>    :param headers: headers to pass through requests<br/>    :param kwargs: params to pass through requests<br/>    """<br/>    </em>if headers is None:<br/>        response = requests.get(base_url, params=kwargs)<br/>    else:<br/>        response = requests.get(<br/>            base_url, params=kwargs, headers=headers)<br/>    return response.json()</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="3a0a" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">净化</h2><p id="ed4e" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu"> <em class="pu">第四个</em> </strong>，下面的方法根据上面用户字典中的clean键清洗数据集。传递给该方法的数据将是来自request_data方法(如上)的结果，作为pandas数据帧。之所以有参数date_int_s，是因为有些日期时间数据有秒，有时没有(默认值设置为False)。</p><p id="2840" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特征被命名。列被删除。数据类型已设置。索引已排序。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="a09d" class="mh mi it pj b gy pn po l pp pq">@staticmethod<br/>def _clean_dataset(<br/>        dataset: pd.DataFrame, dct: dict, date_int_s: bool=False):<br/>    <em class="pu">"""<br/>    Clean dataset<br/><br/>    :param dataset: dataframe needing cleaned<br/>    :param dct: clean dict with names, drop, and types keys<br/>    :param date_int_s: make True if date is an integer with seconds<br/>    """<br/>    </em>dataset.columns = ['DateTime'] + dct.get('clean').get('names')<br/>    dataset.drop(<br/>        dct.get('clean').get('drop', []), axis=1, inplace=True)<br/>    if date_int_s:<br/>        dataset = dataset.assign(<br/>            DateTime=pd.to_datetime(<br/>                dataset.DateTime, unit='s').dt.date)<br/>    else:<br/>        dataset = dataset.assign(<br/>            DateTime=pd.to_datetime(dataset.DateTime).dt.date)<br/>    dataset.set_index('DateTime', inplace=True)<br/>    names = [name for name in dct.get('clean').get(<br/>        'names') if name not in dct.get('clean').get('drop', [])]<br/>    dataset = dataset.astype({<br/>        name: dtype for name, dtype in zip(names, dct.get(<br/>            'clean').get('types'))})<br/>    return dataset.sort_index(ascending=True)</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="e5bf" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">数据源</h2><p id="060a" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu"> <em class="pu">第五个</em> </strong>，我们需要数据来源。在这个例子中，我使用了一个源，Alpaca，但是，正如我前面提到的，你的源方法可以是任何种类的:Web APIs，网页，S3，SQL Server，CSV，你能想到的。</p><p id="46e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们不要触及这些方法的所有细节，但这里有一些要点:</p><ol class=""><li id="d8dd" class="na nb it kk b kl km ko kp kr oe kv of kz og ld nh ni nj nk bi translated">多重处理:我们创建一个函数来与多重处理引擎交互。</li><li id="4d07" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">第三方软件包:我不喜欢依赖第三方软件包，除非它们非常有用。numpy 、<a class="ae ln" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>和<a class="ae ln" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>是非常有用的第三方软件包的例子。有针对羊驼的API的包，但是他们的web API足够简单。</li><li id="031c" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">步骤:使成为查询和缓存的唯一标识符，设置头和kwargs，从数据请求中查询并获取字典，缓存以备将来使用，使用多重处理在数据帧中快速创建数据行，然后清理数据帧。</li></ol><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="1d18" class="mh mi it pj b gy pn po l pp pq">@staticmethod<br/>def _mp_alpaca(molecule):<br/>    out = []<br/>    for tickerset in molecule:<br/>        for bar in tickerset[list(tickerset.keys())[0]]:<br/>            out.append([bar.get('t'), bar.get('o'), bar.get('h'),<br/>                        bar.get('l'), bar.get('c'), bar.get('v')])<br/>    return out<br/><br/>def alpaca(self, dct: dict):<br/>    <em class="pu">"""<br/>    Get data using Alpaca's web api<br/><br/>    :param dct: dict of config source info<br/>    """<br/>    </em>key = str(sorted([(key, value) for key, value in dct.get(<br/>        'kwargs').items()]))<br/>    headers = {<br/>        'APCA-API-KEY-ID': os.environ['APCA_API_KEY_ID'],<br/>        'APCA-API-SECRET-KEY': os.environ['APCA_API_SECRET_KEY']<br/>    }<br/>    timeframe = dct.get('kwargs').get('timeframe')<br/>    kwargs = {key: value for key, value in dct.get(<br/>        'kwargs').items() if key != 'timeframe'}<br/><br/>    if self.data_cache_.get('alpaca').get(key, False):<br/>        json_data = self.data_cache_.get('alpaca').get(key)<br/>    else:<br/>        base_url = 'https://data.alpaca.markets'<br/>        json_data = self.request_data(<br/>            base_url=F'{base_url}/v1/bars/{timeframe}',<br/>            headers=headers, **kwargs)<br/>        self.cache_data(<br/>            source='alpaca', key=key, json_data=json_data)<br/><br/>    tickersets = [{ticker: barsets}<br/>                  for ticker, barsets in json_data.items()]<br/>    out = mp_pandas_obj(<br/>        func=self._mp_alpaca, pd_obj=('molecule', tickersets),<br/>        num_threads=1)<br/>    dataset = pd.DataFrame.from_records(sum(out, []))<br/>    dataset = self._clean_dataset(<br/>        dataset=dataset, dct=dct, date_int_s=True)<br/>    return dataset</span></pre><p id="b27f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:确保您的环境变量中有APCA API密钥ID和APCA API密钥。您可以从您的帐户中获取它们。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="7d97" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">转换</h2><p id="4a40" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu"> <em class="pu">第六个</em> </strong>，我们需要一个方法来转换我们来源的数据；我们希望以某种方式构建它，以便从用户那里抽象出代码和争论任务的序列，使它灵活，并使它健壮。</p><p id="d7c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的转换方法采用一个数据帧和一个要应用的转换列表。输出是一个转换后的要素，该要素被合并并正向填充到日期日期集中。如上所述，这个顺序是关键。稍后，您将看到这个新转换的特性是如何合并到我们的目标系列中的。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="550c" class="mh mi it pj b gy pn po l pp pq">def transform(<br/>        self, dataset: pd.DataFrame, transformation_lst: list):<br/>    <em class="pu">"""<br/>    Apply transformations to dataset<br/><br/>    :param dataset: dataframe needing transformed<br/>    :param transformation_lst: list of dicts of transformations<br/>    """<br/>    </em>for transformation_dct in transformation_lst:<br/>        if '.' in transformation_dct.get('function'):<br/>            function = globals()[transformation_dct.get(<br/>                'function').split('.')[0]]<br/>            for notation_part in transformation_dct.get(<br/>                    'function').split('.')[1:]:<br/>                function = getattr(function, notation_part)<br/>        else:<br/>            function = globals()[<br/>                transformation_dct.get('function')]<br/>        if transformation_dct.get('kwargs', False):<br/>            if transformation_dct.get('kwargs').get(<br/>                    'other', False) and \<br/>                    isinstance(transformation_dct.get('kwargs').get(<br/>                        'other', 1), dict):<br/>                sub_query_dct = transformation_dct.get(<br/>                    'kwargs').get('other')<br/>                dataset0 = self._get_data(dct=sub_query_dct)<br/>                if sub_query_dct.get('transformations', False):<br/>                    dataset0 = self.transform(<br/>                        dataset=dataset0,<br/>                        transformation_lst=sub_query_dct.get(<br/>                            'transformations'))<br/>                    dataset0 = self.date_dataset.copy().merge(<br/>                        dataset0, how='left', left_index=True,<br/>                        right_index=True).ffill()<br/>                else:<br/>                    dataset0 = self.date_dataset.copy().merge(<br/>                        dataset0, how='left', left_index=True,<br/>                        right_index=True).ffill()<br/>                dataset = self.date_dataset.copy().merge(<br/>                    dataset, how='left', left_index=True,<br/>                    right_index=True).ffill()<br/>                dataset = function(dataset, dataset0)<br/>                continue<br/>            else:<br/>                dataset = function(<br/>                    dataset, **transformation_dct.get('kwargs'))<br/>        else:<br/>            dataset = function(dataset)<br/>        dataset = self.date_dataset.copy().merge(<br/>            dataset, how='left', left_index=True, right_index=True)<br/>    return dataset</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="9938" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">目标</h2><p id="eedd" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu">第七个</strong>，下面的函数采用第一级的<em class="pu">键:值</em>对，称为目标，请求数据并转换它，或者简单地将数据合并到一个日期数据集。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="c4b0" class="mh mi it pj b gy pn po l pp pq">def target(self, transform: bool=True):<br/>    <em class="pu">"""<br/>    Make target dataset</em></span><span id="c6b6" class="mh mi it pj b gy py po l pp pq"><em class="pu">    :param transform: False if using self.target standalone<br/>    """<br/>    </em>target_dct = self.config.get('target')<br/>    dataset = getattr(self, target_dct.get('source'))(target_dct)<br/>    if transform and target_dct.get('transformations', False):<br/>        dataset = self.transform(<br/>            dataset=dataset, <br/>            transformation_lst=target_dct.get('transformations'))<br/>    else:<br/>        dataset = self.date_dataset.copy().merge(<br/>            dataset, how='left', left_index=True, right_index=True)<br/>    return dataset</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="1f1b" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">检索数据</h2><p id="2f1f" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu">第八个</strong>，我们需要一个检索数据的函数。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="f270" class="mh mi it pj b gy pn po l pp pq">def _get_data(self, dct: dict):<br/>    function = getattr(self, dct.get('source'))<br/>    dataset = function(dct)<br/>    return dataset</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="067b" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">特征</h2><p id="065d" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated"><strong class="kk iu">第九个</strong>，我们需要一种快速获取特性并转换它们的方法:下面的方法。</p><p id="e6a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于我们如何创建一个与我们的多处理引擎交互的方法，我们创建一个用于多处理特征的检索和转换的方法。一旦完成，最终的结果是一个数据集，将所有正确的争论和转换技术应用-在他们适当的顺序。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="2a81" class="mh mi it pj b gy pn po l pp pq">def _mp_features(self, molecule):<br/>    out = []<br/>    for feature_dct in molecule:<br/>        dataset = self._get_data(dct=feature_dct)<br/>        if feature_dct.get('transformations', False):<br/>            dataset = self.transform(<br/>                dataset=dataset,<br/>                transformation_lst=feature_dct.get(<br/>                    'transformations'))<br/>        else:<br/>            dataset = self.date_dataset.copy().merge(<br/>                dataset, how='left', left_index=True, <br/>                right_index=True)<br/>        out.append(dataset)<br/>    return out</span><span id="e32c" class="mh mi it pj b gy py po l pp pq">@property<br/>def features(self):<br/>    <em class="pu">"""<br/>    Makes features dataset<br/>    """<br/>    </em>if self.config.get('features', False):<br/>        features_lst = self.config.get('features')<br/>        try:<br/>            out = mp_pandas_obj(<br/>                func=self._mp_features,<br/>                pd_obj=('molecule', features_lst),<br/>                num_threads=self.jobs)<br/>        except AssertionError:<br/>            out = mp_pandas_obj(<br/>                func=self._mp_features,<br/>                pd_obj=('molecule', features_lst), num_threads=1)<br/>        dataset = pd.concat(sum(out, []), axis=1)<br/>        dataset = self.date_dataset.copy().merge(<br/>            dataset, how='left', left_index=True, right_index=True)<br/>    else:<br/>        raise Exception('you need features in your dct file')<br/>    return dataset</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="a4bf" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">建设</h2><p id="a13b" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">第十个，最后我们来看最重要的方法:让它们都活起来的方法。这是用户调用来启动构建过程的方法。</p><p id="41d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该方法简单地创建了final_dataset，该数据集包括转换后的目标和转换后的特征。如果用户在其字典中没有指定目标，则只有变换后的要素将构成final_dataset。</p><pre class="lw lx ly lz gt pi pj pk pl aw pm bi"><span id="1818" class="mh mi it pj b gy pn po l pp pq">def build(self):<br/>    <em class="pu">"""<br/>    Build dataset<br/>    """<br/>    </em>if self.config.get('target', False) and self.config.get(<br/>            'target', False):<br/>        self.final_dataset = self.target.copy(), how='left',<br/>            left_index=True, right_index=True).merge(<br/>            self.features.copy(), how='left', left_index=True,<br/>            right_index=True)<br/>        self.final_dataset = self.final_dataset.ffill().loc[<br/>            self.investment.dropna().index]<br/>    # only make features dataset<br/>    else:<br/>        self.final_dataset = self.features.ffill()<br/>    return self</span></pre></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="7137" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">结论</h2><p id="8966" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">在本文中，我们讨论并证明了争论任务有一个适当的操作顺序。我们构建了一个类来抽象用户自己应用这些操作的需求；我们以一种新颖的方式做到了这一点。</p><p id="22c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢，我会喜欢你的反馈/挑战。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="5bbb" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">后续步骤</h2><ol class=""><li id="0b6f" class="na nb it kk b kl nc ko nd kr ne kv nf kz ng ld nh ni nj nk bi translated">错误处理:如果你想加强用户通过你的抽象所传递的字典的结构，那么你将想增加好的错误处理和可解释的错误消息来帮助你的用户。有许多错误处理将使用户的生活更容易。</li><li id="64fa" class="na nb it kk b kl nl ko nm kr nn kv no kz np ld nh ni nj nk bi translated">你应该有一个<a class="ae ln" href="https://docs.python.org/3/library/abc.html" rel="noopener ugc nofollow" target="_blank">抽象</a>类来执行某些方法。我认为这个数据库类是一个“基类”，因为其他抽象可以很容易地继承这个类。例如，在本文中，我简要解释了一种将数据库类的功能扩展到MyPipeline类的方法。</li></ol></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="f7e9" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">把所有的放在一起</h2><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="pz qa l"/></div></figure></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h2 id="a789" class="mh mi it bd mj mk ml dn mm mn mo dp mp kr mq mr ms kv mt mu mv kz mw mx my mz bi translated">参考</h2><p id="5490" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">[1] M. Lopez de Prado，金融机器学习的进展(2018)，威利</p></div></div>    
</body>
</html>