<html>
<head>
<title>Ancient Silk Road on Bicycle — Nomad Cyclist Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自行车上的古丝绸之路——游牧自行车人问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ancient-silk-road-on-bicycle-nomad-cyclist-problem-c0c6db8bb217?source=collection_archive---------48-----------------------#2020-10-19">https://towardsdatascience.com/ancient-silk-road-on-bicycle-nomad-cyclist-problem-c0c6db8bb217?source=collection_archive---------48-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8ac1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">旅行商问题的分步指南及其在自行车旅游规划中的应用</h2></div><p id="0f51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">丝绸之路是一个古老的路线网络，包括中国西部、中亚、西亚和南亚的几十个城市。过去，从一个城市到另一个城市的最短已知路径通常成为路线的一部分。例外是为了避免暴徒，恶劣的天气和耗尽食物和水的风险。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/c7f31520f19b0e3aa7aa91b1e8cbad14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ViYiQo4aZpZKdtGI.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">沿着古丝绸之路的一条路线——(与<a class="ae lr" href="https://www.openstreetmap.org/" rel="noopener ugc nofollow" target="_blank">OpenStreetMap.org</a>一起画的路线)</p></figure><p id="c27e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的几个朋友计划明年骑自行车穿越古丝绸之路。这将是一次人力驱动的旅行，就像过去大多数人通过这些路线旅行一样。我的朋友不是职业自行车运动员。所以，在这数千公里的旅程中，每一桨都必须划向正确的方向。</p><p id="deac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最初认为这是一个疯狂的想法，但后来我意识到这将是一生一次的旅行。所以，我决定尝试编程来计划这次旅行。</p><h1 id="d844" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">城市</h1><p id="5d53" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这些骑自行车的人已经计划好了以下几个丝绸之路上不可错过的主要古城:</p><p id="9325" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">中国🇨🇳Xi(丝绸贸易的起源地)</p><p id="0794" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">中国🇨🇳兰州</p><p id="e3b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">中国🇨🇳敦煌</p><p id="da28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">中国🇨🇳高昌</p><p id="505c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">中国🇨🇳乌鲁木齐市</p><p id="2a7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哈萨克斯坦阿拉木图🇰🇿</p><p id="c4fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">吉尔吉斯斯坦🇰🇬比什凯克</p><p id="b959" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乌兹别克斯坦🇺🇿塔什干</p><p id="e9c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">塔吉克斯坦🇹🇯杜尚别</p><p id="e8a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乌兹别克斯坦🇺🇿boy sun</p><p id="b2f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乌兹别克斯坦🇺🇿撒马尔罕</p><p id="d6a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乌兹别克斯坦布哈拉🇺🇿</p><p id="fb27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">土库曼斯坦🇹🇲梅尔夫</p><p id="0dbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">土库曼斯坦🇹🇲阿什哈巴德</p><p id="0c81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">伊朗🇮🇷德黑兰</p><p id="ba4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">伊朗🇮🇷大不里士</p><p id="3f7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">土耳其🇹🇷安卡拉</p><p id="4ab2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">土耳其🇹🇷伊斯坦布尔</p><p id="c9c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">沿途有很多城市有丰富的历史遗迹，在古代贸易中有重要意义，但是不可能在人力自行车旅行中包括所有的城市。比如巴基斯坦的塔西拉，中国的喀什。</p><h1 id="cf90" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">旅行推销员问题</h1><p id="d7c2" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">为了找到穿过所有这些城市的最短路线，让我们使用经典的旅行商问题(以下简称TSP)算法。TSP是一个优化问题。TSP说</p><blockquote class="mp mq mr"><p id="305d" class="kf kg ms kh b ki kj jr kk kl km ju kn mt kp kq kr mu kt ku kv mv kx ky kz la ij bi translated"><em class="iq">“给定一个要游览的城市列表以及这些城市之间的距离，游览所有这些地点并返回我们出发地点的最短路径是什么”</em></p></blockquote><p id="5e63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在原始TSP中，我们计算的路线是一条封闭路线，并且我们的开始和结束位置必须相同。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mw"><img src="../Images/9d3c3f9a9a1221a1fd8a3cd516b29281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ccS4Owzsr0h1Y-8z.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">旅行推销员问题——点代表城市，线代表道路——(<a class="ae lr" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">TSP on Wikipedia</a>)</p></figure><p id="71a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是作为骑自行车的人，我们感兴趣的是沿途的城市，而不是回到起点。TSP有许多变体，让我们把TSP的这种变体称为“<strong class="kh ir">游牧自行车手问题</strong>”。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mx"><img src="../Images/1061ee9bee215dec33debf8636d4bf70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kArLCUm2zbhCbMpc.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">开放旅游旅行推销员问题(图片由作者提供)</p></figure><h1 id="5c38" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">距离矩阵</h1><p id="66b7" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">距离矩阵是制定几乎所有涉及路径的优化问题的起点。例如最短路径问题、旅行商问题、车辆路径问题和物流路径优化。</p><p id="7ca5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看下面的距离矩阵:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi my"><img src="../Images/258ec9afb936e1a5049caf1079bca920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/0*EmvUfPOCwSg_Iq8y.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">丝绸之路距离矩阵—第一部分(图片由作者提供)</p></figure><p id="7309" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第2行第1列的单元格的值为626。这是从兰州到西安的公里数。然而，从西安到兰州的距离是627，由第一行第二列中的单元表示。</p><p id="9793" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上表中每个像元的值是以公里为单位的道路长度，从左侧的城市到顶部标题中的城市。</p><p id="6e24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用2D数组(或者Python中的2D列表)来存储距离矩阵值。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="35b1" class="ne lt iq na b gy nf ng l nh ni"><em class="ms"># distance matrix<br/></em>D <strong class="na ir">=</strong> [[0, 627, 1724, 2396, 2531, 3179],<br/>    [626, 0, 1096, 1768, 1903, 2551],<br/>    [1723, 1095, 0, 929, 1064, 1713],<br/>    [2395, 1766, 849, 0, 163, 811],<br/>    [2531, 1903, 985, 163, 0, 656],<br/>    [3186, 2557, 1640, 817, 664, 0]]</span></pre><p id="a306" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于真实世界的位置，我们可以使用简单的API调用，使用<a class="ae lr" href="https://developers.google.com/maps/documentation/distance-matrix/overview" rel="noopener ugc nofollow" target="_blank">谷歌地图距离矩阵API </a>和<a class="ae lr" href="https://docs.mapbox.com/help/glossary/matrix-api/" rel="noopener ugc nofollow" target="_blank"> Mapbox的矩阵API </a>轻松计算我们位置的距离矩阵。</p><h1 id="5104" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计算距离矩阵</h1><p id="d268" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">手动计算多个城市的距离矩阵变得很烦人。让我们写一些脚本来为我们计算距离矩阵。</p><p id="e114" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用Google Maps Matrix API计算距离矩阵，我们只需提供地点的名称。但是我决定硬编码城市的经度，纬度坐标。我认为当不止一个地方有相似的名字时，坐标可以避免混淆。</p><p id="087e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nj nk nl na b">getCities</code>方法给出了城市+坐标的列表。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="e3d9" class="ne lt iq na b gy nf ng l nh ni"><strong class="na ir">def</strong> <strong class="na ir">getCities</strong>():<br/>    <em class="ms"># locations to visit<br/></em>    cities <strong class="na ir">=</strong> [<br/>        {<br/>            "name": "Xi'an, Shaanxi, China",<br/>            "location": [34.341576, 108.939774]<br/>        },<br/>        {<br/>            "name": "Lanzhou, China",<br/>            "location": [36.061089, 103.834305]<br/>        },<br/><br/>        ...<br/>		<br/>        {<br/>            "name": "Istanbul, Turkey",<br/>            "location": [41.022576, 28.961477]<br/>        }<br/>    ]<br/>    <strong class="na ir">return</strong> cities</span></pre><h1 id="1e8a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计算距离矩阵</h1><p id="ade6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">计算距离矩阵现在很容易。我们只需要调用一个gmap API端点，提供两个列表:起点和终点，我们希望计算它们之间的距离，并以JSON的形式返回我们的距离矩阵，该矩阵将被解析并转换为我们在上面看到的2D列表<code class="fe nj nk nl na b">D</code>。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="e81d" class="ne lt iq na b gy nf ng l nh ni">import requests, traceback<br/><br/><strong class="na ir">def</strong> <strong class="na ir">gmapMatrix</strong>(origins, destinations):<br/>    API_KEY <strong class="na ir">=</strong> GET_GMAP_API_KEY() <em class="ms"># &lt;&lt;= gmap api key<br/></em>    URL <strong class="na ir">=</strong>f"https://maps.googleapis.com/maps/api/distancematrix/json?units=metric&amp;origins={origins}&amp;destinations={destinations}&amp;key={API_KEY}"<br/><br/>    <strong class="na ir">try</strong>:<br/>        r <strong class="na ir">=</strong> requests.get(URL)<br/>        jsn <strong class="na ir">=</strong> r.json()<br/><br/>        <strong class="na ir">return</strong> jsn<br/>    <strong class="na ir">except</strong> Exception:<br/>        traceback.print_exc()<br/>        <strong class="na ir">return</strong> None</span></pre><p id="dca0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们找到我们的距离矩阵。好吧，没那么容易。原来谷歌的Matrix APIs有一些限制。</p><p id="dcb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据谷歌地图矩阵API:</p><ol class=""><li id="50ed" class="nm nn iq kh b ki kj kl km ko no ks np kw nq la nr ns nt nu bi translated">发送到距离矩阵API的每个查询都会生成元素，其中起点数量乘以目标数量等于元素数量</li><li id="3b03" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">每个请求最多允许25个起点或25个目的地</li><li id="d2c0" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">每个服务器端请求最多允许100个元素</li></ol><h1 id="26ec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计算超过100个元素的距离矩阵</h1><p id="86b8" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们有大约20个城市。20*20等于400。我们超过了100个元素的限制。我们必须将我们的请求分成100个一批，获取距离并构建我们的<code class="fe nj nk nl na b">20 x 20</code>距离矩阵。</p><p id="76dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你熟悉深度学习中的卷积神经网络，你可能知道我们<em class="ms">取一小部分矩阵，做一些运算，计算另一个矩阵</em>的卷积技术。这个过程是一步一步的，每次只对矩阵的一小部分起作用。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d999e14ce865d7d43d823ee9cb139475.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*67Dt0T6ju0JtuegIH3eK8Q.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">一次查看矩阵的一小部分(<a class="ae lr" href="https://en.wikipedia.org/wiki/Convolutional_neural_network" rel="noopener ugc nofollow" target="_blank">卷积神经网络，维基百科</a>)</p></figure><p id="179e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">别担心，我们处理100个元素限制的计算比卷积神经网络简单得多。</p><p id="8396" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看项目代码中的<code class="fe nj nk nl na b"><a class="ae lr" href="https://github.com/emadehsan/nomad-cyclist/blob/0f42ef8a06bdf2be0b7c0fdec32661d16efded38/distance_matrix.py#L26" rel="noopener ugc nofollow" target="_blank">convolveAndComputeDistMatrix</a></code>方法。该方法遍历距离矩阵，仅挑选100个项目来寻找距离，并构造一个距离矩阵<code class="fe nj nk nl na b">20 x 20</code>...我们想要的距离矩阵。</p><h1 id="db6a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">履行</h1><p id="0df9" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">让我们把我们的游牧自行车手问题(TSP)公式化为一个线性规划问题。为了解决一个线性规划问题，我们通常需要4样东西</p><ul class=""><li id="49a7" class="nm nn iq kh b ki kj kl km ko no ks np kw nq la ob ns nt nu bi translated">决策变量</li><li id="b44b" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la ob ns nt nu bi translated">限制</li><li id="1b5e" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la ob ns nt nu bi translated">目标</li><li id="0609" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la ob ns nt nu bi translated">解决者</li></ul><h1 id="ab06" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">解决者</h1><p id="7077" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">(优化)解算器是一个软件或库，它采用以某种方式定义(建模)的优化问题，并试图找到该问题的最佳解决方案。我们的工作是对问题进行适当的建模，求解者承担繁重的工作。</p><p id="e6f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用OR-Tools，这是一个由Google AI团队开发的开源库，用于解决优化问题。</p><p id="18a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看如何为或工具初始化或工具的线性规划求解问题建模</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="a5b0" class="ne lt iq na b gy nf ng l nh ni">from ortools.linear_solver import pywraplp<br/><br/>s <strong class="na ir">=</strong> pywraplp.Solver('TSP', \<br/>        pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)</span></pre><h1 id="4dd2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">决策变量</h1><p id="6986" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">简而言之，决策变量是包含线性规划算法输出的变量。我们的算法做出的决定！</p><p id="89bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于TSP，决策变量将是与距离矩阵大小相同的2D列表。它将在像元中包含<code class="fe nj nk nl na b">1</code>，其对应的道路必须被访问，因此是输出路径的一部分。以及<code class="fe nj nk nl na b">0</code>在不得通行的道路上。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/33163ca34064ce53d40f2cdb16db0ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/0*Z-Met3gt-dlSCyW4.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">可视化旅行商问题的决策变量(图片由作者提供)</p></figure><p id="241e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据OR-Tools <a class="ae lr" href="https://developers.google.com/optimization/reference/python/linear_solver/pywraplp#intvar" rel="noopener ugc nofollow" target="_blank">线性求解器文档</a>，我们使用<code class="fe nj nk nl na b">IntVar</code>定义一个整数决策变量。</p><p id="035f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在普通的Python代码中，我们将创建一个名为<code class="fe nj nk nl na b">count</code>的变量，它将保存某个任务完成的次数。我们可能会从0开始，并随着每个任务不断增加，直到程序结束，其中会包含一些我们感兴趣的有用值。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="ca94" class="ne lt iq na b gy nf ng l nh ni">count <strong class="na ir">=</strong> 0</span></pre><p id="0541" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要定义相同的变量，但要由OR-Tools线性求解器使用，我们将按如下方式定义它(现在它将被称为决策变量)。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="9ffe" class="ne lt iq na b gy nf ng l nh ni"><em class="ms"># IntVar(lowerBound, upperBound, name)<br/></em>count <strong class="na ir">=</strong> s.IntVar(0, 100, 'count_var')</span></pre><p id="e651" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们也必须提供界限。这告诉规划求解找到一个从下限到上限的整数值。这有助于缩小可能的输出范围，求解器可以更快地找到解决方案。</p><p id="2111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们定义TSP的决策变量。这将是一个由<code class="fe nj nk nl na b">IntVar</code>组成的2d Python列表。但是在这里，城市的边界将是从<code class="fe nj nk nl na b">0</code>到<code class="fe nj nk nl na b">1</code>，除了那些没有找到内部距离的城市，它们的边界将是从<code class="fe nj nk nl na b">0</code>到<code class="fe nj nk nl na b">0</code>。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="2507" class="ne lt iq na b gy nf ng l nh ni">x <strong class="na ir">=</strong> [[s.IntVar(0, 0 <strong class="na ir">if</strong> D[i][j] <strong class="na ir">is</strong> None <strong class="na ir">else</strong> 1, '') \<br/>        <strong class="na ir">for</strong> j <strong class="na ir">in</strong> range(n)] <strong class="na ir">for</strong> i <strong class="na ir">in</strong> range(n)]</span></pre><h1 id="a60a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">限制</h1><p id="f3bb" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">将约束视为必须遵守的限制或规则。根据TSP，</p><p id="d66f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">"我们必须在一条封闭的道路上游览每一个城市一次."</p><p id="b3ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先我们将解决一个封闭旅游的TSP问题。然后我们将修改它，为我们的游牧骑行者提供一条开放的最短路径。因此，在我们的解决方案中，必须只有一条路通往城市，并且只有一条路通往城外。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="4c8f" class="ne lt iq na b gy nf ng l nh ni"><strong class="na ir">for</strong> i <strong class="na ir">in</strong> range(n):  <br/>    <em class="ms"># in i-th row, only one element can be used in the tour<br/></em>    <em class="ms"># i.e. only 1 outgoing road from i-th city must be used<br/>    # in the tour<br/></em>    s.Add(1 <strong class="na ir">==</strong> sum(x[i][j] <strong class="na ir">for</strong> j <strong class="na ir">in</strong> range(n))) <br/><br/>    <em class="ms"># in j-th column, only one element can be used in the tour<br/></em>    <em class="ms"># i.e. only 1 incoming road to j-th city must be used in tour<br/></em>    s.Add(1 <strong class="na ir">==</strong> sum(x[j][i] <strong class="na ir">for</strong> j <strong class="na ir">in</strong> range(n))) <br/><br/>    <em class="ms"># a city must not be assigned a path to itself in the tour<br/></em>    <em class="ms"># no direct road from i-th city to i-th city again must be taken<br/></em>    s.Add(0 <strong class="na ir">==</strong> x[i][i])</span></pre><p id="5d4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上约束是不够的。有时存在有问题的子区域，每个子区域覆盖不同城市的子集，但没有一个子区域覆盖所有城市。我们想在所有城市进行一次(最短的)旅行。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d6550a864437a72e4c1d6c38516cf1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*k2RaRrIzOW_ba4mO.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">有问题的(断开的)子旅行团(图片由作者提供)</p></figure><p id="9f4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们知道，任何由6个城市组成的封闭路径都有6条弧线(边/路)连接它们(如上图)。因此，我们告诉我们的求解程序，如果一个旅行是一个子旅行(即它覆盖的城市少于距离矩阵中的城市总数)，连接这些城市的道路必须少于这个子旅行中的城市数。这将强制求解程序查找未闭合的子区域，最终成功找到连接所有城市的闭合(最短)旅行。</p><p id="a042" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们不能找到所有可能的次区域，并把它们包含在我们的约束中。避免这种子区域的方法是，在第一次运行我们的算法时，我们找到一个解决方案，如果它包含子区域，我们再次运行算法，这次我们告诉它保持这些子区域不闭合。我们不断重复这个过程，直到我们找到一个覆盖所有城市的最佳旅游路线，而不是小的不相连的子区域。</p><p id="af3e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们对这个约束进行建模:</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="65fa" class="ne lt iq na b gy nf ng l nh ni"><em class="ms"># Subtours from previous run (if any)<br/></em><strong class="na ir">for</strong> sub <strong class="na ir">in</strong> Subtours:<br/>    <em class="ms"># list containing total outgoing+incoming arcs to <br/></em>    <em class="ms"># each city in this subtour<br/></em>    K <strong class="na ir">=</strong> [ x[sub[i]][sub[j]] <strong class="na ir">+</strong> x[sub[j]][sub[i]] \<br/>         <strong class="na ir">for</strong> i <strong class="na ir">in</strong> range(len(sub)<strong class="na ir">-</strong>1) <strong class="na ir">for</strong> j <strong class="na ir">in</strong> range(i<strong class="na ir">+</strong>1,len(sub)) ]<br/>    <br/>    <em class="ms"># sum of arcs (roads used) between these cities must <br/></em>    <em class="ms"># be less than number of cities in this subtour<br/></em>    s.Add(len(sub)<strong class="na ir">-</strong>1 <strong class="na ir">&gt;=</strong> sum(K))</span></pre><h1 id="6e18" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">目标</h1><p id="750c" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们整数规划算法的目标。在我们的例子中，我们希望尽可能缩短我们访问所有城市的距离。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="0da5" class="ne lt iq na b gy nf ng l nh ni"><em class="ms"># minimize the total distance of the tour<br/></em>s.Minimize(s.Sum(x[i][j]<strong class="na ir">*</strong>(0 <strong class="na ir">if</strong> D[i][j] <strong class="na ir">is</strong> None <strong class="na ir">else</strong> D[i][j]) \<br/>                   <strong class="na ir">for</strong> i <strong class="na ir">in</strong> range(n) <strong class="na ir">for</strong> j <strong class="na ir">in</strong> range(n)))</span></pre><p id="d448" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，找到一条穿过这些城市的最短路径，同时遵守上述约束。这是一条最短的路径。因为可能有多条长度相同的最短路径。</p><h1 id="f215" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">游牧骑自行车者问题</h1><p id="37c6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">TSP与开放路线将是我们的游牧自行车的问题。让我们现有的算法找到开放路线而不是封闭路线的一个简单技巧是在距离矩阵中添加一个虚拟城市。将这个虚拟城市到所有其他城市的距离设置为0。</p><p id="cb04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当求解程序找到最优解时，在封闭路径上的某个地方会有一个虚拟城市。我们简单地删除这个虚拟城市和它的进出弧线(道路),为我们的游牧自行车手提供一条开放的路线。</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="1392" class="ne lt iq na b gy nf ng l nh ni"><em class="ms"># to make the loops run 1 more time then current size of<br/># our lists so we could add another row / column item<br/></em>n1 <strong class="na ir">=</strong> n <strong class="na ir">+</strong> 1<br/><br/><em class="ms"># if i or j are equal to n, that means we are in the last <br/># row / column. just add a 0 element here<br/></em>E <strong class="na ir">=</strong> [[0 <strong class="na ir">if</strong> n <strong class="na ir">in</strong> (i,j) <strong class="na ir">else</strong> D[i][j] \<br/>    <strong class="na ir">for</strong> j <strong class="na ir">in</strong> range(n1)] <strong class="na ir">for</strong> i <strong class="na ir">in</strong> range(n1)]</span></pre><p id="4127" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由此产生的路线将是最短的单程和开放的旅游覆盖所有城市。</p><h1 id="fa2f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">手动v计算路线比较</h1><p id="a526" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">根据我们的求解程序，我们必须按照这个顺序在城市中循环</p><pre class="lc ld le lf gt mz na nb nc aw nd bi"><span id="1a44" class="ne lt iq na b gy nf ng l nh ni">Shortest Path for our Cycling Tour:<br/>    Cities:  Xi'an  Lanzhou  Dunhuang  Gaochang  Urumqi  Khorgas  Horgos  Almaty  Bishkek  Tashkent  Samarqand  Dushanbe  Baysun  Bukhara  Merv  Ashgabat  Tehran  Tabriz  Ankara  Istanbul<br/> City Index      0        1         2         3       4        5       6       7        8         9         12        10      11       13    14        15      16      17      18        19<br/>   Distance      0      627      1096       929     163      656      -1     332      237       631        310       292     196      341   353       400     948     632    1463       451<br/> Cumulative      0      627      1723      2652    2815     3471    3470    3802     4039      4670       4980      5272    5468     5809  6162      6562    7510    8142    9605     10056</span></pre><p id="a5c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上述输出不可读的情况下，相同输出的照片:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oe"><img src="../Images/e4081164e232d6c0cf8f69e882ba2658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w5ZzLENOfOgLA-W1.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">算法计算的游牧骑行旅行(图片由作者提供)</p></figure><p id="e16c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在决定了要参观的城市之后，我们对参观这些地方的顺序做了一个粗略的计划。在谷歌地图上，你不能在超过10个地方之间创建一条路线(我想)。</p><p id="0d42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们之前计划的中国丝绸之路城市路线的第一站，与我们的算法建议的路线相匹配:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi of"><img src="../Images/9999c2bc6e77cd5c66a76470669ff399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WJ5O9J24Gr0bsGHZ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">丝绸之路的中国部分—(在<a class="ae lr" href="https://goo.gl/maps/HguetrsnzNPHCFDK8" rel="noopener ugc nofollow" target="_blank">谷歌地图</a>上绘制)</p></figure><p id="cc0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们计划的中东到欧洲之旅的最后一站…这也与算法输出相匹配:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi og"><img src="../Images/0674b8aa31ee7bd935459054a6dcad45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BANHoA_E05ZDfFMw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">穿越中东的丝绸之路—(在<a class="ae lr" href="https://goo.gl/maps/HWXHU9e3zS5evcqQA" rel="noopener ugc nofollow" target="_blank">谷歌地图</a>上绘制)</p></figure><p id="6e65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们手动规划的中亚城市路线的第二段(中间):</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oh"><img src="../Images/8ac327a5dd6abffb4a7444725942d6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BkrjFQaBwxoDbDvM.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">中亚——丝绸之路——(在<a class="ae lr" href="https://goo.gl/maps/TU6fX2Za3edWrAYs7" rel="noopener ugc nofollow" target="_blank">谷歌地图</a>上绘制)</p></figure><p id="024f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据我们的算法，除了中亚的几个城市之外，最短路线与我们手动规划的路线的90%匹配:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oi"><img src="../Images/be12c7ec2982fc163bc3f6171716faa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aXOrESV-AHjTgSiC.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">中亚——最短路径——丝绸之路——(<a class="ae lr" href="http://maps.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌地图</a>)</p></figure><p id="323b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当骑自行车数千公里时，即使少走几百公里也能让我们感觉如释重负。我们希望这是对旅行推销员问题和游牧自行车手问题的一个很好的指导。我们接下来要考虑的一个重要问题是海拔。</p><h1 id="1907" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">规划自己的路线</h1><p id="36a3" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">所有的项目代码都在GitHub上，上面有很多有用的评论。您可以随意定制它并提出拉取请求。</p><p id="1606" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里使用的(TSP)线性规划算法摘自Serge Kruk的<a class="ae lr" href="https://amzn.to/3iPceJD" rel="noopener ugc nofollow" target="_blank">实用Python AI项目</a>一书。如果你想学习路线优化算法或者一般的优化算法，强烈推荐。</p><p id="2ccb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将增加考虑海拔和攀爬难度的选项，这对于计划游览的骑行者来说是非常重要的。</p></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="1ed2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ms">原载于2020年10月19日</em><a class="ae lr" href="https://alternate.parts/blog/nomad-cyclist" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://alternate . parts</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>