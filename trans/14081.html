<html>
<head>
<title>Kubernetes pattern for applications with external environment configuration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有外部环境配置的应用程序的Kubernetes模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubernetes-pattern-for-applications-with-external-environment-configuration-a42d7bdd7e97?source=collection_archive---------21-----------------------#2020-09-28">https://towardsdatascience.com/kubernetes-pattern-for-applications-with-external-environment-configuration-a42d7bdd7e97?source=collection_archive---------21-----------------------#2020-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="04d5" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="afd7" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">通过使用git-sync、Kubernetes init-containers、配置映射和卷，将配置生命周期与应用程序生命周期分离</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/60ecd47c2224d7e0c110a062b93d6479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9_q6cqcdw9bRjIZpiA-fQ.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">将配置生命周期与应用程序生命周期分离。(图片由作者提供)</p></figure><p id="9d99" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">每个应用程序都需要配置，我们需要在不重新创建应用程序工件或映像的情况下灵活地适应这种配置。这构成了连续交付方法的模式。</p><h1 id="4ef3" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">问题</h1><p id="327c" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">在一个容器化的世界中，我们如何让应用适应不同的开发、试运行、沙盒和生产环境？答案是使用外部配置数据，这对于每个环境都是不同的。</p><p id="75ae" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通常，最好将所有配置数据保存在一个地方，而不是分散在不同的资源定义文件中。例如，一个这样的地方可以是具有以下两个主要优点的Git存储库:</p><ul class=""><li id="1642" class="mx my iq lg b lh li lk ll ln mz lr na lv nb lz nc nd ne nf bi translated">您可以免费获得版本控制配置数据和审计。</li><li id="1ac1" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated">所有工程师都有权限更改不同环境的配置，包括生产环境</li></ul><p id="639e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">坏处呢？您已经弄清楚了:围绕敏感配置数据的安全问题。在那里保存任何凭证是一种反模式，因此一个想法是使用占位符。</p><h1 id="ef66" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">解决办法</h1><p id="b5a0" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">Kubernetes为常规和机密数据提供本地配置资源。这些是分别用于通用目的和敏感数据的<strong class="lg ja">配置图</strong>和<strong class="lg ja">秘密</strong>对象。我们可以以同样的方式使用这两者，因为它们都提供了键值对的存储和管理。除了实际的数据编码(对于机密来说是Base64)之外，配置映射和机密的使用在技术上没有区别。</p><p id="88a4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">简单地说，我们问题的解决方案在于在应用程序启动之前使用Git存储库。占位符被替换为来自Secrets的值，Secrets可以通过Terraform或任何用于Kubernetes的GitOps连续交付工具创建。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="ee23" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们来看一个例子:</p><p id="c005" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">假设您有一个Git存储库，其中包含为每个环境分组的文件，工程师可以在其中更改任何内容，安全凭证是不可见的，而是用占位符替换。</p><p id="4487" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ns">database . properties</em><strong class="lg ja"/>就是这样一个既有简单配置数据又有凭证的文件</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="3607" class="ny mb iq nu b gy nz oa l ob oc">connectionHost=${mysql_hostname}<br/>connectionUserName=${mysql_username}<br/>connectionPassword=${mysql_password}<br/>connectionPort=3306</span><span id="f348" class="ny mb iq nu b gy od oa l ob oc">connectionPool.maxIdle=90<br/>connectionPool.maxActive=100<br/>connectionPool.maxWait=20000<br/>connectionPool.testSQL=SELECT 1</span></pre><p id="39ee" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们上面提到了用于替换占位符的秘密。一旦创建了秘密并保存了数据，我们就可以使用秘密的密钥作为映射到Pod中装载的卷的文件。一个秘密备份的卷包含与条目一样多的文件，映射的关键字作为文件名，映射的值作为文件内容。</p><p id="0045" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当通过Kubernetes API更新密码时，安装的密码卷中的文件也会更新。因此，如果应用程序支持配置文件的热重新加载，它可以立即从这样的更新中受益。在我们的例子中，我们保持这个例子简单，我们将考虑一次性配置加载，而不是热重新加载。</p><p id="4e21" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ns">输入-占位符-文件-秘密</em> <strong class="lg ja"> </strong>内容:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="0d29" class="ny mb iq nu b gy nz oa l ob oc">apiVersion: v1</span><span id="8b0b" class="ny mb iq nu b gy od oa l ob oc">data:</span><span id="4339" class="ny mb iq nu b gy od oa l ob oc">input-placeholders.properties: bXlzcWxfaG9zdG5hbWU9bG9jYWxob3N0Cm15c3FsX3VzZXJuYW1lPXJvb3QKbXlzcWxfcGFzc3dvcmQ9cGFzc3dvcmQ=</span><span id="f4e3" class="ny mb iq nu b gy od oa l ob oc">kind: Secret</span><span id="41f8" class="ny mb iq nu b gy od oa l ob oc">metadata:</span><span id="fda7" class="ny mb iq nu b gy od oa l ob oc">creationTimestamp: "2020-09-27T10:04:01Z"</span><span id="46d0" class="ny mb iq nu b gy od oa l ob oc">name: input-placeholders-files-secret</span><span id="8e0a" class="ny mb iq nu b gy od oa l ob oc">namespace: my-main-application</span><span id="ff86" class="ny mb iq nu b gy od oa l ob oc">resourceVersion: "45565287"</span><span id="d9f2" class="ny mb iq nu b gy od oa l ob oc">selfLink: /api/v1/namespaces/my-main-application/secrets/input-placeholders-files-secret</span><span id="fe73" class="ny mb iq nu b gy od oa l ob oc">uid: 818229c3-b986-44a9-a8a5-e235557f98a7</span><span id="58f2" class="ny mb iq nu b gy od oa l ob oc">type: Opaque</span></pre><p id="28ac" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在我们有了秘密和属性项目，让我们把它们粘在一起。</p><p id="2a80" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Kubernetes有另一个资源:<strong class="lg ja"> init容器。</strong>它通过为与初始化相关的任务提供独立的生命周期来分离关注点，与主应用程序容器不同。这允许保持容器的单一目的，并且应用程序容器可以由只关注应用程序逻辑的工程师创建。通常，init容器应该很小，运行迅速，并成功完成。</p><p id="53bc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Kubernetes中的Init容器是Pod定义的一部分，它们按顺序一个接一个地执行，在应用程序容器启动之前，所有这些容器都必须成功终止。从这个意义上说，init容器就像Java类中帮助对象初始化的构造函数指令。</p><p id="1a7c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">除了Kubernetes中的init容器和秘密之外，Pod中的<strong class="lg ja">卷</strong>共享非常适合这种配置和应用程序容器的链接。容器可以共享(外部)卷，但是它们还不能直接共享位于容器内的目录。</p><p id="561b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在我们的示例中，我们使用了一个<strong class="lg ja"> </strong> init容器<strong class="lg ja"/>(<em class="ns">properties-sync</em>)<strong class="lg ja"/>，它提供了Git客户端功能，其唯一目的是克隆一个Git存储库。在Pod上安装一个空目录，并在<a class="ae oe" href="https://github.com/kubernetes/git-sync" rel="noopener ugc nofollow" target="_blank"> git-sync </a>的帮助下将Git存储库克隆到其中:</p><ul class=""><li id="3c5a" class="mx my iq lg b lh li lk ll ln mz lr na lv nb lz nc nd ne nf bi translated">一个简单的命令将Git存储库放入本地目录。</li><li id="47cf" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated">可以一次或定期从分支的头、git标签或特定的git散列中提取。</li><li id="d2b9" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated">可以通过认证或不认证的HTTP或SSH。</li></ul><p id="4c7c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">另一个<strong class="lg ja"> </strong> init容器<strong class="lg ja"> </strong> ( <em class="ns">属性-占位符-替换</em>)用于占位符替换<strong class="lg ja"> </strong>使用包含克隆项目的共享卷，并将最终结果移动到主应用程序容器使用这些文件的新文件夹中。</p><p id="d2b1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，对于<em class="ns">属性-占位符-替换</em> init容器，我们需要一些来自基本映像的帮助来将配置数据复制到共享Pod卷。<a class="ae oe" href="https://www.busybox.net/" rel="noopener ugc nofollow" target="_blank"> busybox </a>是一个不错的选择，它仍然很小，但是允许我们使用普通的Unix cp命令来完成这个任务。</p><p id="c54d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因为两个init容器都是同一个Pod的一部分，所以它们可以访问同一个卷来共享数据。我们使用相同的机制将克隆的文件从init容器共享到主应用程序容器。</p><p id="7c19" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><em class="ns">替换-占位符-后缀-挂钩</em> <strong class="lg ja"> </strong> ConfigMap是用于占位符替换的实际脚本</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="b59d" class="ny mb iq nu b gy nz oa l ob oc">kind: ConfigMap<br/>apiVersion: v1<br/>metadata:<br/>  name: "replace-placeholders-poststart-hook"<br/>  labels:<br/>    app: "my-main-application"<br/>data:<br/>  replace-placeholders.sh: |<br/>      replace() {<br/><br/>        local placeholders_input_files_location=$1<br/>        local files_to_update_location=$2<br/><br/>        local input_file=merged-secret-files.properties<br/>        rm $input_file<br/><br/>        echo "--- Starting to merge all the secret files."<br/><br/>          for properties_file in $placeholders_input_files_location/*.properties; do<br/>                (cat "${properties_file}"; echo) &gt;&gt; $input_file;<br/>          done<br/><br/>        echo "--- Finished to merge all the secret files."<br/><br/>        if [ -f "$input_file" ]<br/>        then<br/><br/>          echo "--- $input_file will be used to replace the placeholders."<br/><br/>          while IFS='=' read -r placeholder_key placeholder_value<br/>          do<br/><br/>              local placeholder_prefix='${'<br/>              local placeholder_suffix='}'<br/>              local placeholder_to_replace="${placeholder_prefix}${placeholder_key}${placeholder_suffix}"<br/><br/>              find $files_to_update_location -type f -exec sed -i "s+${placeholder_to_replace}+${placeholder_value}+g" {} \;<br/><br/>          done &lt; "$input_file"<br/><br/>          echo "--- Copy properties files to correct location /properties"<br/><br/>          cp -R $files_to_update_location/*  /properties<br/><br/>        else<br/>          echo "--- No input file found to replace the placeholders: $input_file."<br/>        fi<br/>      }<br/><br/>      replace "$INPUT_PLACEHOLDERS" "$GIT_SYNC_ROOT/sync/environments/$ENVIRONMENT_TYPE"</span></pre><p id="5643" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在主应用程序的以下部署中，它作为卷被引用和装载:</p><pre class="kp kq kr ks gt nt nu nv nw aw nx bi"><span id="c7d5" class="ny mb iq nu b gy nz oa l ob oc">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-main-application<br/>spec:<br/>  replicas: 1<br/>  strategy:<br/>    type: RollingUpdate<br/>  selector:<br/>    matchLabels:<br/>      app: my-main-application<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: my-main-application<br/>    spec:<br/>      imagePullSecrets:<br/>        - name: gitlab-registry<br/>      initContainers:<br/>        - name: properties-sync<br/>          image: "jlowin/git-sync"<br/>          imagePullPolicy: Always<br/>          volumeMounts:<br/>            - name: gitconfig-project<br/>              mountPath: /opt/properties_from_git<br/>          env:<br/>            - name: GIT_SYNC_REPO<br/>              value: "https://gitlab.com/my-domain/properties-project.git"<br/>            - name: GIT_SYNC_BRANCH<br/>              value: "master"<br/>            - name: GIT_SYNC_WAIT<br/>              value: "30"<br/>            - name: GIT_SYNC_USERNAME<br/>              value: "&lt;some-username&gt;"<br/>            - name: GIT_SYNC_PASSWORD<br/>              value: "&lt;some-password&gt;"<br/>            - name: GIT_SYNC_ROOT<br/>              value: /opt/properties_from_git<br/>            - name: GIT_SYNC_DEST<br/>              value: sync<br/>            - name: GIT_SYNC_ONE_TIME<br/>              value: "true"<br/>        - name: properties-placeholders-replacement<br/>          image: busybox<br/>          env:<br/>            - name: ENVIRONMENT_TYPE<br/>              value: "development"<br/>            - name: INPUT_PLACEHOLDERS<br/>              value: /opt/placeholders_from_secrets<br/>            - name: GIT_SYNC_ROOT<br/>              value: /opt/properties_from_git<br/>          volumeMounts:<br/>            - name: input-placeholders-files<br/>              mountPath: /opt/placeholders_from_secrets/input-placeholders.properties<br/>              subPath: input-placeholders.properties<br/>            - name: replace-placeholders-script-volume<br/>              mountPath: /opt/replace-placeholders.sh<br/>              subPath: replace-placeholders.sh<br/>            - name: gitconfig-project<br/>              mountPath: /opt/properties_from_git<br/>            - name: properties<br/>              mountPath: /properties<br/>          command: ['/bin/sh', '-c', '/opt/replace-placeholders.sh; echo finished;']<br/>      containers:<br/>        - name: my-main-application<br/>          image: "registry.gitlab.com/my-domain/my-main-application-image-tag:v1"<br/>          imagePullPolicy: IfNotPresent<br/>          ports:<br/>            - name: http<br/>              containerPort: 8080<br/>              protocol: TCP<br/>          volumeMounts:<br/>            - name: properties<br/>              mountPath: /properties<br/>      volumes:<br/>        - name: input-placeholders-files<br/>          secret:<br/>            secretName: input-placeholders-files-secret<br/>        - name: gitconfig-project<br/>          emptyDir: {}<br/>        - name: properties<br/>          emptyDir: {}<br/>        - name: replace-placeholders-script-volume<br/>          configMap:<br/>            defaultMode: 0755<br/>            name: "replace-placeholders-poststart-hook"</span></pre><p id="42ef" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">部署的Pod模板规范包含以下内容:</p><ul class=""><li id="fa49" class="mx my iq lg b lh li lk ll ln mz lr na lv nb lz nc nd ne nf bi translated"><em class="ns">输入-占位符-文件</em>-包含秘密存储的<em class="ns">输入-占位符.属性</em></li><li id="5a41" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated"><em class="ns"> gitconfig-project </em> —类型为<em class="ns"> emptyDir，</em>它在托管此Pod的节点上创建为一个空目录；这里克隆了Git项目。</li><li id="e41a" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated"><em class="ns">属性</em> —配置数据的最终目的地，占位符替换为Secret中的值，由主应用程序容器使用</li><li id="352a" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated"><em class="ns">replace-placeholders-script-volume</em>—包含用于替换Git项目中占位符的脚本，从config map<em class="ns">replace-placeholders-poststart-hook</em>挂载</li></ul><p id="fd01" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">正如您所注意到的，部署包含两个init容器<em class="ns">属性-同步</em>和<em class="ns">属性-占位符-替换</em> <strong class="lg ja"> </strong>和<strong class="lg ja"> </strong>主应用程序容器<strong class="lg ja"/><em class="ns">my-main-application</em>。</p><p id="cf10" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">属性-同步:</strong></p><ul class=""><li id="8df5" class="mx my iq lg b lh li lk ll ln mz lr na lv nb lz nc nd ne nf bi translated">在启动时被调用，并从映像<a class="ae oe" href="https://hub.docker.com/r/jlowin/git-sync/dockerfile" rel="noopener ugc nofollow" target="_blank"><em class="ns">jlowin/git-sync</em></a>构建。</li><li id="43a2" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated"><em class="ns"> GIT_SYNC_ONE_TIME </em>告诉它只同步一次，这只是为了保持示例的简单，并且不使用sidecar。</li><li id="53ec" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated">从<em class="ns"> gitconfig-project </em>挂载的<em class="ns"> GIT_SYNC_ROOT </em>是GIT文件的目标文件夹。</li><li id="691f" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated">与下一个init容器共享<em class="ns"> gitconfig-project </em>卷。</li></ul><p id="293c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">属性-占位符-替换:</strong></p><ul class=""><li id="b52d" class="mx my iq lg b lh li lk ll ln mz lr na lv nb lz nc nd ne nf bi translated">在<em class="ns"> properties-sync </em>之后立即启动，并安装上述4个卷:<em class="ns">输入-占位符-文件、git config-项目、属性、替换-占位符-脚本-卷</em></li><li id="a937" class="mx my iq lg b lh ng lk nh ln ni lr nj lv nk lz nc nd ne nf bi translated">最后是运行从config map<em class="ns">replace-placeholders-post start-hook</em>挂载的<em class="ns">/opt/replace-placeholders . sh</em>脚本</li></ul><p id="1d52" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">我的主应用:</strong></p><ul class=""><li id="19fc" class="mx my iq lg b lh li lk ll ln mz lr na lv nb lz nc nd ne nf bi translated">正在挂载卷<em class="ns">属性</em>以访问由<em class="ns">属性-占位符-替换</em>初始化容器复制的配置。</li></ul></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="00a0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用这种模式，我们不仅可以使用版本化的配置数据，还可以克服存储在环境变量、配置映射或机密中的配置数据的大小限制。Kubernetes配置资源有其局限性:由于Secrets/ConfigMaps的大小限制为1 MB，它们不能存储任意大的数据，并且不太适合所有的配置应用程序数据。真实世界的Kubernetes集群还对每个名称空间或项目可以使用的ConfigMap的数量设置了单独的配额，因此config map并不是一个金锤。</p><p id="8466" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我希望您喜欢阅读本分步指南，并理解如何使用不同的Kubernetes对象来定义配置模式，以便使应用程序适应云上不同的配置需求。</p></div></div>    
</body>
</html>