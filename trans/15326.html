<html>
<head>
<title>In-Depth Look At Data Structures In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Julia中的数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/in-depth-look-at-data-structures-in-julia-d22171a8f5ed?source=collection_archive---------34-----------------------#2020-10-21">https://towardsdatascience.com/in-depth-look-at-data-structures-in-julia-d22171a8f5ed?source=collection_archive---------34-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1167" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">朱莉娅综合教程</h2><div class=""/><div class=""><h2 id="c979" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Julia编程语言中数据结构的快速介绍。</h2></div><blockquote class="kr"><p id="554c" class="ks kt it bd ku kv kw kx ky kz la lb dk translated">本文视频:</p></blockquote><figure class="lc ld le lf lg lh"><div class="bz fp l di"><div class="li lj l"/></div></figure><figure class="ll lm ln lo gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lk"><img src="../Images/5c235e3b5bfbe7992451a36a8cbfc882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAZwAc9to4TXrDrDeE46tg.jpeg"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="kr"><p id="8959" class="ks kt it bd ku kv kw kx ky kz la lb dk translated"><a class="ae lz" href="https://github.com/emmettgb/JuliaLessons" rel="noopener ugc nofollow" target="_blank"> Github库</a></p><p id="b2a1" class="ks kt it bd ku kv ma mb mc md me lb dk translated"><a class="ae lz" href="https://github.com/emmettgb/JuliaLessons/blob/master/5/Comprehensive%20Julia%20Tutorials%205.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><h1 id="69a6" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">介绍</h1><p id="cfe7" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">在之前的Julia教程中，我们讨论了如何对类型和函数使用Julia的多重分派。多重分派是一个简单的系统，用于在相同的方法参数下对不同的函数调用应用不同的类型。该结构中的关键组件是类型，更具体地说，是数据类型。</p><p id="f333" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">数据类型是计算机编程的基础。任何编程工作都将涉及操纵、移动和使用基本数据类型。在语言中创建的类型本身只是其他类型(通常是数据类型)的容器。</p><h1 id="eeb9" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki nx kj mr kl ny km mt ko nz kp mv mw bi translated">基本数据类型</h1><p id="c69b" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">我们可以在Julia编程语言中存储的第一种数据是基本数据类型。基本数据类型包括数字、文本、字符和布尔值等数据。</p><h2 id="1086" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">布尔代数学体系的</h2><p id="6009" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">布尔类型是一种指示条件是否为真的类型。布尔值可以用最终压缩为1或0的真/假值来表示，也可以用表示类型条件的整数(1或0)来表示。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="3339" class="oa mg it om b gy oq or l os ot">typeof(true)</span><span id="c352" class="oa mg it om b gy ou or l os ot">Bool</span></pre><p id="9042" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">同样，在Julia语言中，我们也可以将布尔值断言为表示真或假的整数:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="2850" class="oa mg it om b gy oq or l os ot">Bool(1)</span><span id="429d" class="oa mg it om b gy ou or l os ot">true</span></pre><h2 id="8f30" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">整数</h2><p id="05f9" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">编程中的整数数据类型类似于数学中的整数数据类型。整数是没有小数值的整数。通常，每当我们在Julia中处理整数时，我们都会处理Int64数据类型。这意味着该整数有64位。或者，也有Int32s和BigInts。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="d5a8" class="oa mg it om b gy oq or l os ot">typeof(5)</span><span id="f44f" class="oa mg it om b gy ou or l os ot">Int64</span></pre><h2 id="adb0" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">漂浮物</h2><p id="2722" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">浮点数是小数点后有第二个数字的整数，或者是一个小数值。浮点可以被认为是两个独立的数据片段，小数值之前的整数和整数之后的小数值。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="35d9" class="oa mg it om b gy oq or l os ot">typeof(5.5)<br/>Float64</span></pre><h2 id="06c2" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">复杂而庞大</h2><p id="320e" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">复杂的浮点数在Julia语言中经常出现。复浮点数就是既有虚值又有实值的浮点数。需要注意的是，这意味着这些类型不是真正的<strong class="mz jd"/>。通常科学计算需要一个真实的数据类型，因此你可能需要断言一些复杂的浮点数。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="478c" class="oa mg it om b gy oq or l os ot">typeof(5.5 + 5.5im)</span><span id="6338" class="oa mg it om b gy ou or l os ot">Complex(Float64)</span></pre><p id="3743" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">该数据类型第二部分中的“im”表示前面的数字是虚数。</p><p id="d4e0" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">另一方面，大数据类型是实数，但超出了大多数64位整数和浮点数应用程序的能力，并且是精确的。这是Julia语言的一个显著特点，因为它允许巨大的整数和浮点数据类型毫无问题地通过多个函数传递——这是很少有语言能够做到的。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="84db" class="oa mg it om b gy oq or l os ot"># Big Int<br/>big(51515235151351335)</span><span id="e944" class="oa mg it om b gy ou or l os ot"># Big Float<br/>big(5.4172473471347374147)</span></pre><h2 id="c8f5" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">标志</h2><p id="07e9" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">符号数据类型是Julia语言从函数范式中获得的另一个伟大的东西。符号可以用来表示从参数到字典键的任何东西——它们在这方面做得相当好。一般来说，符号数据类型在编程语言中是一个很好的东西，因为它可以用来表示基本上任何东西，因此得名:符号。在Julia中，只需在关键字前加一个冒号就可以写出符号，例如:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="a67d" class="oa mg it om b gy oq or l os ot">typeof(:Symbol)</span><span id="c799" class="oa mg it om b gy ou or l os ot">Symbol</span></pre><h2 id="6053" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">字符串和字符</h2><p id="53fb" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">字符串是一个非常简单的概念，它是由一组连续的unicode/ascii字符组成的字符组合。正如第3部分——循环中所演示的，字符串可以循环显示下一个数据类型，chars。如果您还没有阅读第3部分，您可以在这里查看:</p><div class="ov ow gp gr ox oy"><a rel="noopener follow" target="_blank" href="/getting-familiar-with-loops-in-julia-cfbcc344728c"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd jd gy z fp pd fr fs pe fu fw jc bi translated">熟悉Julia中的循环</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">Julia编程语言中循环和条件一起使用的介绍。</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">towardsdatascience.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm lt oy"/></div></div></a></div><p id="b1ba" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">字符串用引号分隔。另一方面，字符用撇号分隔。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="ee38" class="oa mg it om b gy oq or l os ot">typeof("Hello")</span><span id="9777" class="oa mg it om b gy ou or l os ot">String</span><span id="1d5b" class="oa mg it om b gy ou or l os ot">typeof('h')</span><span id="0457" class="oa mg it om b gy ou or l os ot">char</span></pre><p id="889c" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">浮点数用于表示ASCII中的字符。因此，我们总是可以将asset chars转换成floats:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="ecf7" class="oa mg it om b gy oq or l os ot">float('5')</span></pre><blockquote class="pn po pp"><p id="a983" class="mx my pq mz b na ns kd nc nd nt kg nf pr nu ni nj ps nv nm nn pt nw nq nr lb im bi translated">有趣的事实:这就是标签编码的工作原理</p></blockquote><h1 id="b96f" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki nx kj mr kl ny km mt ko nz kp mv mw bi translated">数据结构</h1><p id="272a" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">所有的分类数据、向量数据和矩阵数据都将充当其他类型数据的容器。考虑由多种数据类型组成的数组的例子，如整数、浮点、布尔或字符串。</p><h2 id="9fe5" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">数组</h2><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="4d3a" class="oa mg it om b gy oq or l os ot">element_wise = [5, 10, 15, 15]</span></pre><p id="9633" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">这个新数组是包含4个Int64s的数组。我们可以根据它们在数组中的位置用数字对它们进行索引:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="ba5b" class="oa mg it om b gy oq or l os ot">element_wise[1] == 5</span><span id="90a2" class="oa mg it om b gy ou or l os ot">true</span><span id="1bbd" class="oa mg it om b gy ou or l os ot">element_wise[2] == 10</span><span id="66c4" class="oa mg it om b gy ou or l os ot">true</span></pre><p id="f152" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">我们还可以在类型中看到这一点:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="4261" class="oa mg it om b gy oq or l os ot">typeof(element_wise)<br/>Array{Int64, 1}</span></pre><blockquote class="kr"><p id="f510" class="ks kt it bd ku kv kw kx ky kz la lb dk translated">为什么括号很重要:</p></blockquote><p id="9fa3" class="pw-post-body-paragraph mx my it mz b na pu kd nc nd pv kg nf ng pw ni nj nk px nm nn no py nq nr lb im bi translated">您可能已经注意到，无论何时创建数组，它通常都在方括号的范围内。如果没有这些括号，这个数据集合的类型将是一个元组。虽然我没有深入研究元组，但它们是一种非常有效的数据类型——但如果您需要数组，这肯定不是您想要的。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="6458" class="oa mg it om b gy oq or l os ot">h = 5,10,15,20<br/>typeof(h)</span><span id="5a64" class="oa mg it om b gy ou or l os ot">NTuple{4, Int64}</span></pre><p id="6868" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">此外，不使用括号会使函数无法理解哪个参数对应于哪个变量。考虑追加！()方法。追加！方法有两个参数，第一个是您想要追加的数据，第二个是您想要追加的数据。如果我们使用括号，这是可行的，因为数组被视为一个参数。但是，使用逗号会出现ArgumentError。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="164a" class="oa mg it om b gy oq or l os ot">         parameters<br/>           v    v<br/>append!([5,10], 15)</span><span id="3604" class="oa mg it om b gy ou or l os ot">      parameters<br/>       v  v  v</span><span id="1d46" class="oa mg it om b gy ou or l os ot">append!(5,10,15)</span></pre><h2 id="f833" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">字典</h2><p id="07f7" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">在Julia中，字典需要被明确定义，否则它将返回一个元组。这是一种非常有价值的动态类型，在处理数据集或JSON数据时会进一步体现这一点。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="e610" class="oa mg it om b gy oq or l os ot">data = Dict(:A =&gt; [5,10,15], :B =&gt; [11, 12, 13)</span></pre><p id="cea5" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">使用字典，我们可以通过调用相应的符号键来调用数据，在本例中:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="42a8" class="oa mg it om b gy oq or l os ot">data[:A]</span><span id="f8ab" class="oa mg it om b gy ou or l os ot">[5, 10, 15]</span></pre><h2 id="43a6" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">双；对；副</h2><p id="4b3b" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">对实际上是元组类型，但重要的是要认识到对是元组，但元组不是对。pair与我们一秒钟前用来访问字典的部分内容完全相同，并且可以用相同的方式创建:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="1b84" class="oa mg it om b gy oq or l os ot">key = :A =&gt; [5,10,15]</span></pre><h2 id="fc10" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">一组</h2><p id="a9c9" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">集合只是从一个类型中提取的唯一值。例如，如果我们断言一个数组的集合类型，我们将获得该数组中的每个唯一值:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="0470" class="oa mg it om b gy oq or l os ot">arr = [5, 5, 7, 7, 6, 4, 5]</span><span id="d090" class="oa mg it om b gy ou or l os ot">set = Set(arr)</span><span id="de48" class="oa mg it om b gy ou or l os ot">println(set)</span><span id="7f0c" class="oa mg it om b gy ou or l os ot">[5, 7, 6, 4]</span></pre><h2 id="9717" class="oa mg it bd mh ob oc dn ml od oe dp mp ng of og mr nk oh oi mt no oj ok mv iz bi translated">元组</h2><p id="0df0" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">元组是数据类型的一般化结构，不一定具有已定义的结构。元组可以被认为是一个组织性较差的数组。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="05ee" class="oa mg it om b gy oq or l os ot">h = 5, 10, 15</span></pre><h1 id="a434" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki nx kj mr kl ny km mt ko nz kp mv mw bi translated">创建类型</h1><p id="592a" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">有时，处理原始数据类型可能是乏味和令人疲惫的，尤其是当一个函数需要处理许多参数时。这就是结构的用武之地。创建一个结构将产生一个新的类型，它可以保存任意的和预定义的数据结构。我们可以通过使用struct关键字，后跟定义和数据来创建结构。</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="d46a" class="oa mg it om b gy oq or l os ot">struct typer<br/>    h<br/>    v<br/>end</span></pre><p id="c9fc" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">有了这个类型，我们现在可以给它分配一个新变量，提供必要的数据作为构造函数的参数:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="64ed" class="oa mg it om b gy oq or l os ot">w = typer(5, 10)</span></pre><p id="82a2" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">在这个实例中，struct typer是我们保存数据h和v的新类型，我们可以通过调用struct.data来访问这些数据:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="5b79" class="oa mg it om b gy oq or l os ot">typer.h</span><span id="4376" class="oa mg it om b gy ou or l os ot">5</span><span id="48c6" class="oa mg it om b gy ou or l os ot">typer.v</span><span id="2ebe" class="oa mg it om b gy ou or l os ot">10</span></pre><p id="7b84" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">我们还可以通过函数传递这个新类型，例如从我们的typer结构中添加我们的h和v数据:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="066a" class="oa mg it om b gy oq or l os ot">function addtyper(typer)<br/>    return(typer.h + typer.v)<br/>end</span></pre><p id="7cee" class="pw-post-body-paragraph mx my it mz b na ns kd nc nd nt kg nf ng nu ni nj nk nv nm nn no nw nq nr lb im bi translated">值得注意的是，在Julia语言中，构造类型中的数据是不可变的。这可以通过在类型前放置关键字mutable来改变:</p><pre class="ll lm ln lo gt ol om on oo aw op bi"><span id="974c" class="oa mg it om b gy oq or l os ot">mutable struct typer<br/>    h<br/>    v<br/>end</span></pre><h1 id="6a7d" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki nx kj mr kl ny km mt ko nz kp mv mw bi translated">结论</h1><p id="e65a" class="pw-post-body-paragraph mx my it mz b na nb kd nc nd ne kg nf ng nh ni nj nk nl nm nn no np nq nr lb im bi translated">数据类型一直是编程中非常重要的事情，这个问题在数据科学的世界中更为明显。大多数编程只是简单地使用数据结构和构造类型来处理数据类型。也就是说，理解数据类型对程序员来说非常重要。在Julia中有许多类型，有些你可以自己构造，但是学习如何利用和操作这些类型将是成为一个伟大的程序员的关键。</p></div></div>    
</body>
</html>