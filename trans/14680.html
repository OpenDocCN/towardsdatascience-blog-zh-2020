<html>
<head>
<title>XPath for Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的XPath</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/xpath-for-python-89f4423415e0?source=collection_archive---------0-----------------------#2020-10-10">https://towardsdatascience.com/xpath-for-python-89f4423415e0?source=collection_archive---------0-----------------------#2020-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e49f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="d61e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习网页抓取的规则</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/fb76e0cf926646eb3b8024e00ce19d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k0vKUp3DRKq2BfJ9"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@davidpaschke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·帕施克</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4fa6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">ML路径语言(XPath)在web抓取和自动化领域是一个非常不受重视的工具。想象一下RegEx，但是对于网页来说——那就是XPath。</p><p id="56ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">网页的每个元素都是由文档对象模型(DOM)组织的。DOM是一个类似树的结构，其中每个元素代表一个节点，有到父节点和子节点的路径。</p><p id="5bcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">XPath为我们提供了一种快速遍历这棵树的语言。而且，像RegEx一样，我们可以向节点选择添加逻辑，使我们的查询更强大。</p><p id="666d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将涵盖:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="7c57" class="ms mt it mo b gy mu mv l mw mx"><strong class="mo jd">&gt; XPath Essentials<br/></strong>  - Testing Our Queries<br/>  - The Root<br/>  - Paths in XPath</span><span id="f5e3" class="ms mt it mo b gy my mv l mw mx"><strong class="mo jd">&gt; Navigating the Tree</strong><br/>  - Node Indexing<br/>  - Extracting XPaths from the Browser</span><span id="b25f" class="ms mt it mo b gy my mv l mw mx"><strong class="mo jd">&gt; XPath Logic</strong></span><span id="f9d4" class="ms mt it mo b gy my mv l mw mx"><strong class="mo jd">&gt; Example with Python</strong></span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="c570" class="ng mt it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">XPath基础</h1><h2 id="d715" class="ms mt it bd nh nx ny dn nl nz oa dp np lr ob oc nr lv od oe nt lz of og nv iz bi translated">测试我们的查询</h2><p id="9cf8" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">首先，在我们做任何事情之前，我们需要理解如何测试我们的XPath字符串。幸运的是，我们可以在网络浏览器中这样做。</p><p id="7f97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在整篇文章中，我将使用Chrome，但在所有现代浏览器中，这个过程都非常相似。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/819f79090e459a977e7a89b89f9d7dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJdtvpwtTgYAYZCTu9BvZg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">点击Chrome &gt;更多工具&gt;开发者工具中的选项下拉菜单。</p></figure><p id="f3e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的网页上，我们打开开发者工具——在Windows上点击<strong class="lk jd"> Fn+12 </strong>,或者从浏览器选项菜单中打开(请参阅上面的Chrome)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/0e86d464d0c5adbd272d0cb6d26b233a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7jHFLvla54R230eZMNKGw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们可以使用开发人员工具中的搜索栏来检查XPath字符串是否有效。</p></figure><p id="cab4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们单击<strong class="lk jd"> ctrl+F </strong>在元素窗口中打开搜索栏。在这里，我们可以通过字符串、选择器或XPath进行搜索。</p><p id="96d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个方法是快速测试XPath查询的最简单的方法。</p><p id="ddee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们的查询匹配某些内容，那么该元素将被突出显示为黄色。当我们的查询匹配多个元素时，我们可以使用搜索栏右侧的箭头在它们之间循环！</p><h2 id="f511" class="ms mt it bd nh nx ny dn nl nz oa dp np lr ob oc nr lv od oe nt lz of og nv iz bi translated">根</h2><p id="d1a0" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">让我们从查询的最开始开始。以<code class="fe oo op oq mo b">//div</code>为例，<code class="fe oo op oq mo b">//</code>是什么意思？</p><p id="6426" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个XPath查询都从XML树的根——最顶层的元素开始。对于HTML文档，这是<code class="fe oo op oq mo b">&lt;html&gt;</code>标签。</p><p id="cffc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果我们写<code class="fe oo op oq mo b">html//div</code>，我们就说“寻找任何属于<code class="fe oo op oq mo b">div</code>的<code class="fe oo op oq mo b">html</code>的后代节点”。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/24631a4346ab190294c4a03e762c037f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5eJcR8HimdtlVSvyT_JjWA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">页面元素的树形表示。</p></figure><p id="0564" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果是，我们的查询将同时找到<code class="fe oo op oq mo b"><strong class="lk jd">html</strong>/<strong class="lk jd">div</strong></code>和<code class="fe oo op oq mo b"><strong class="lk jd">html</strong>/body/div/div/article/div/<strong class="lk jd">div</strong></code>。这是因为在这两种情况下，我们看到的是<code class="fe oo op oq mo b">html</code>的后代<code class="fe oo op oq mo b">div</code>。</p><p id="3a36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们的XPath查询总是从根(<code class="fe oo op oq mo b">html</code>)开始，所以我们不需要编写<code class="fe oo op oq mo b">html//div</code>。相反，我们写<code class="fe oo op oq mo b">//div</code>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="5826" class="ng mt it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">导航树</h1><h2 id="badf" class="ms mt it bd nh nx ny dn nl nz oa dp np lr ob oc nr lv od oe nt lz of og nv iz bi translated">路径表达式</h2><p id="ff06" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">我们刚刚使用的例子叫做路径表达式。有几个这样的例子，它们非常有用:</p><ul class=""><li id="3091" class="os ot it lk b ll lm lo lp lr ou lv ov lz ow md ox oy oz pa bi translated"><code class="fe oo op oq mo b">//</code> —匹配任何后代节点</li><li id="8157" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated"><code class="fe oo op oq mo b">/</code> —仅匹配子节点(直接跟随另一个节点的节点):</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/58bd878d231901b7eb2a308d3e27a0b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-RsRpySE8cyOG8CGMD4Bw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">为了匹配<strong class="bd ph"> span </strong>元素，我们需要在使用单个<strong class="bd ph"> / </strong>时包含所有子节点。</p></figure><ul class=""><li id="9fec" class="os ot it lk b ll lm lo lp lr ou lv ov lz ow md ox oy oz pa bi translated"><code class="fe oo op oq mo b">.</code> —匹配当前活动节点(稍后将详细介绍)</li><li id="c742" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated"><code class="fe oo op oq mo b">..</code> —匹配当前活动节点的父节点</li><li id="7c1d" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated"><code class="fe oo op oq mo b">@</code> —选择当前节点的一个属性(例如<code class="fe oo op oq mo b">href</code>):</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/3b0e4c7a63bcfce50e77dffc8e33f196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcFapUM1b5JBwvTI1PjE6A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们可以使用属性选择器<strong class="bd ph"> @ </strong>按属性进行搜索。</p></figure><p id="8e77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了这些路径表达式的组合，我们可以轻松地遍历XML树。</p><p id="f270" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，回到我们的示例HTML部分——我们可以通过找到带有属性<code class="fe oo op oq mo b">class="u-textScreenReader"</code>的<code class="fe oo op oq mo b">span</code>标签来选择<code class="fe oo op oq mo b">a</code>标签，并沿着树向上遍历到它的父节点，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/3dcc510f09b70d8053dccc224ad0e76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzjnQmNp-JJ42apwjAqLWg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd ph">..语法允许我们在XML树中向上移动。</strong></p></figure><h2 id="d5de" class="ms mt it bd nh nx ny dn nl nz oa dp np lr ob oc nr lv od oe nt lz of og nv iz bi translated">节点顺序</h2><p id="8352" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">我们DOM中的每个节点都有编号。如果我们有一个包含五个<code class="fe oo op oq mo b">li</code>条目的列表<code class="fe oo op oq mo b">ul</code>，我们可以通过从1到5的索引来访问每一个条目:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="9a6d" class="ms mt it mo b gy mu mv l mw mx">&lt;ul&gt;<br/>    &lt;li&gt;London&lt;/li&gt;<br/>    &lt;li&gt;Miami&lt;/li&gt;<br/>    &lt;li&gt;New Dehli&lt;/li&gt;<br/>&lt;/li&gt;</span></pre><p id="1da6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们查询<code class="fe oo op oq mo b">//ul/li[1]</code>，我们将返回<code class="fe oo op oq mo b">&lt;li&gt;London&lt;/li&gt;</code>——注意，值是<strong class="lk jd">而不是</strong>零索引的。XPath索引从<code class="fe oo op oq mo b">1</code>开始。</p><h2 id="203d" class="ms mt it bd nh nx ny dn nl nz oa dp np lr ob oc nr lv od oe nt lz of og nv iz bi translated">从浏览器复制XPath</h2><p id="9a73" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">Chrome(可能是大多数现代浏览器)中一个非常方便的特性是直接从<strong class="lk jd">元素</strong>窗口获取节点的XPath。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/7dd1e7746a7ae679fc56fa02aea4fcd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4emNv12DSPjV6IsY8R8RNg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">右键点击一个元素，点击<strong class="bd ph">复制&gt;复制XPath </strong>。</p></figure><p id="b00c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我们右键单击需要XPath的元素，然后单击Copy &gt; Copy XPath并粘贴该元素的XPath。我们的<code class="fe oo op oq mo b">span</code>元素返回:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="e830" class="ms mt it mo b gy mu mv l mw mx">//*[<a class="ae lh" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a>="_obv.shell._surface_1600536527994"]/div/div[1]/div[2] /div[1]/div[1]/a/span[1]</span></pre><p id="067d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者，我们可以复制完整的XPath，它提供了从根到元素的完整路径。对于我们的<code class="fe oo op oq mo b">span</code>元素，这看起来像:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="8e0d" class="ms mt it mo b gy mu mv l mw mx">/html/body/div[1]/div[2]/div/div[1]/div[2]/div[1]/div[1]/a/span[1]</span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="624a" class="ng mt it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">高级逻辑</h1><p id="271f" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">现在，你是否想把下面的方法称为“先进”是值得商榷的。</p><p id="f624" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，我证明了这一点，因为通过单独使用前面的路径表达式，我们可以非常容易地遍历DOM。在许多情况下，我们不再需要任何东西。但时不时地，这些“先进”的方法会非常有用。</p><h2 id="df9a" class="ms mt it bd nh nx ny dn nl nz oa dp np lr ob oc nr lv od oe nt lz of og nv iz bi translated">功能</h2><p id="dfa9" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">有许多XPath函数我们不会在这里讨论，但是一些最常见的是:</p><ul class=""><li id="a905" class="os ot it lk b ll lm lo lp lr ou lv ov lz ow md ox oy oz pa bi translated"><code class="fe oo op oq mo b">contains</code> —在字符串<code class="fe oo op oq mo b">B</code>中搜索字符串<code class="fe oo op oq mo b">A</code>，其中<code class="fe oo op oq mo b">contains(B, A)</code>:</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/b03824c4cbb78c142f8c7fdeb915a298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hjUQs52XNorLcZQx4Gyvg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用<strong class="bd ph"> contains </strong>函数的例子，我们也可以使用<strong class="bd ph"> contains(text()，‘Home’)</strong>并得到相同的结果。图片作者。</p></figure><ul class=""><li id="154e" class="os ot it lk b ll lm lo lp lr ou lv ov lz ow md ox oy oz pa bi translated"><code class="fe oo op oq mo b">not</code> —我们用它来否定部分查询，比如我们想要所有不包含类<code class="fe oo op oq mo b">svgIcon-use</code>的<code class="fe oo op oq mo b">span</code>元素:</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/29631cc787ecb1887308ee075ec7d4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiZvrR-g04Uqftg6Fss1Wg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们使用<strong class="bd ph">而不是</strong>来选择没有类<strong class="bd ph">‘u-textScreenReader’</strong>的span节点<strong class="bd ph">。</strong></p></figure><ul class=""><li id="c02e" class="os ot it lk b ll lm lo lp lr ou lv ov lz ow md ox oy oz pa bi translated"><code class="fe oo op oq mo b">boolean</code> —与<code class="fe oo op oq mo b">not</code>相等且相反，如果我们希望所有的<code class="fe oo op oq mo b">span</code>元素都包含一个<code class="fe oo op oq mo b">svg</code>子节点:</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/a9338effe08ba0dd840835ac6b4531ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAHWm0UttcC3vqS05FGrRQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们使用<strong class="bd ph">布尔</strong>来选择带有类<strong class="bd ph">‘u-textScreenReader’</strong>的跨度节点<strong class="bd ph">。</strong></p></figure><ul class=""><li id="2aa8" class="os ot it lk b ll lm lo lp lr ou lv ov lz ow md ox oy oz pa bi translated"><code class="fe oo op oq mo b">starts-with</code> —类似于<code class="fe oo op oq mo b">contains</code>，但不包含字符串<code class="fe oo op oq mo b">A</code>，字符串<code class="fe oo op oq mo b">B</code>必须以字符串<code class="fe oo op oq mo b">A</code>开头。</li><li id="8fec" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated">我相信你能解决这个问题</li></ul><p id="9ebf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些函数只是XPath表面的一小部分。一些我们还没有涉及到的项目(我已经添加了关于它们的文章的链接):</p><ul class=""><li id="aa38" class="os ot it lk b ll lm lo lp lr ou lv ov lz ow md ox oy oz pa bi translated"><a class="ae lh" href="https://www.w3schools.com/xml/xpath_axes.asp" rel="noopener ugc nofollow" target="_blank">更多XPath轴</a></li><li id="9ecb" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated"><a class="ae lh" href="https://www.w3schools.com/xml/xpath_operators.asp" rel="noopener ugc nofollow" target="_blank"> XPath运算符</a></li><li id="5258" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated"><a class="ae lh" href="https://www.w3schools.com/xml/xpath_syntax.asp" rel="noopener ugc nofollow" target="_blank">选择未知节点</a></li><li id="c90f" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/XPath/Functions" rel="noopener ugc nofollow" target="_blank">XPath函数的完整列表</a></li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="51b6" class="ng mt it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">硒中的XPath</h1><p id="e0d3" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">Selenium是熟悉Python中XPath的最佳方式(它也适用于许多其他语言)。如果你不熟悉它，我写了这篇文章介绍框架的设置和基础——它非常容易使用！</p><p id="3f05" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦有了Selenium设置，我们就可以使用<code class="fe oo op oq mo b">find_elements_by_xpath</code>方法选择满足XPath查询的网页的所有元素。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/ba4c39fa624ddf2d6d40be93daae71b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5WoaVmF1xVXjCMsJpyAAQ.png"/></div></div></figure><p id="a15b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将在<a class="ae lh" href="https://webscraper.io/" rel="noopener ugc nofollow" target="_blank"> webscraper.io </a>上尝试一下。在那里，我们可以看到每一项都包含在一个带有<code class="fe oo op oq mo b">class="thumbnail"</code>的<code class="fe oo op oq mo b">div</code>元素中。这里，我们重点介绍了Acer Aspire产品。</p><p id="28cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，回到Selenium和XPath。首先，我们需要初始化我们的web驱动程序，并导航到Web Scraper培训网站:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="6a56" class="ms mt it mo b gy mu mv l mw mx">from selenium import webdriver<br/>driver = webdriver.Chrome('chromedriver.exe')<br/>driver.get('<a class="ae lh" href="https://webscraper.io/test-sites/e-commerce/scroll" rel="noopener ugc nofollow" target="_blank">https://webscraper.io/test-sites/e-commerce/scroll</a>')</span></pre><p id="f9f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们需要选择类为<code class="fe oo op oq mo b">thumbnail</code>的所有<code class="fe oo op oq mo b">div</code>元素:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/16343e61988e8632df28a0a10cfff6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLsLHyQWWtNxpzH73qxIyw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们可以很容易地通过选择任何带有<strong class="bd ph"> //div </strong>的div来选择这些，并且只过滤那些具有带有<strong class="bd ph"> [@class='thumbnail'] </strong>的缩略图类的div。</p></figure><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="6146" class="ms mt it mo b gy mu mv l mw mx">shop_elems = driver.find_elements_by_xpath(<br/>    "<strong class="mo jd">//div[@class='thumbnail']"</strong><br/>)</span></pre><h2 id="0049" class="ms mt it bd nh nx ny dn nl nz oa dp np lr ob oc nr lv od oe nt lz of og nv iz bi translated">Selenium网站元素</h2><p id="732a" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">如果我们打印出<code class="fe oo op oq mo b">shop_elems</code>的值，我们将返回一个<strong class="lk jd"> WebElement </strong>对象的列表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/019b13a638b35ae7f20e2ad3c64f4450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MqiMXXHfZ0M5Nrz0etDLdg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Selenium将返回我们选择作为WebElement对象的每个元素。</p></figure><p id="7325" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太好了，我们有了我们的商店容器WebElements —现在做什么？嗯，我们可以将这些对象视为单独的XML树。</p><p id="ad98" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用WebElement <code class="fe oo op oq mo b">get_element</code>方法结合<code class="fe oo op oq mo b">By.XPATH</code>来实现这一点，这是一个新的导入:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="7ac6" class="ms mt it mo b gy mu mv l mw mx">from selenium.webdriver.common.by import By</span><span id="70d9" class="ms mt it mo b gy my mv l mw mx">shop_elems[0].get_element(By.XPATH, <em class="pq">&lt;XPath Query Here&gt;</em>)</span></pre><p id="61ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，我们将<code class="fe oo op oq mo b">div[@class="thumbnail"]</code>的第一个实例设置为活动的，我们可以使用<code class="fe oo op oq mo b">.</code>在XPath查询中选择当前活动的节点。</p><p id="0a1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用这个新方法遍历页面上的每个条目容器，并迭代地提取每个条目的细节！</p><h2 id="5aa1" class="ms mt it bd nh nx ny dn nl nz oa dp np lr ob oc nr lv od oe nt lz of og nv iz bi translated">使用活动节点的XPaths</h2><p id="6ca4" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">让我们尝试在<code class="fe oo op oq mo b">shop_elems</code>中提取每个web元素的项目名称。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/2cb9faf434689057ef5f87fcc23d5e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4kJTYphaflcdD0dumxw3A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">项目名称位于<strong class="bd ph"> a </strong>子代a标签的<strong class="bd ph">标题</strong>或<strong class="bd ph">文本</strong>字段中。</p></figure><p id="7708" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">回到浏览器，我们可以在descendant <code class="fe oo op oq mo b">&lt;a&gt;</code>标签中找到项目名称。由于没有其他的后代<code class="fe oo op oq mo b">&lt;a&gt;</code>标签，我们可以只使用<code class="fe oo op oq mo b">//a</code>来选择这个元素。这给了我们<code class="fe oo op oq mo b">//div[@class='thumbnail']//<strong class="lk jd">a</strong></code>。</p><p id="95fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的代码中，<code class="fe oo op oq mo b">shop_elems</code>中包含的WebElements将<code class="fe oo op oq mo b">div[@class='thumbnail']</code>设置为活动节点，我们用<code class="fe oo op oq mo b">.</code>选择它:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="cb93" class="ms mt it mo b gy mu mv l mw mx">shop_elems[0].find_element(By.XPATH, "<strong class="mo jd">.//a</strong>")</span></pre><p id="7b42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要获得商品名称，我们只需访问对象的<code class="fe oo op oq mo b">text</code>值。我们可以将它集成到一个for循环中，从我们的WebScraper.io电子商务页面中提取每个商品名称:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="3b64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仅此而已；我们用XPath和Selenium提取了电子商务首页上的商品名称。我们可以结合更多的XPath查询来提取更多的信息，比如价格、评级、评论数量等。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="5d39" class="ng mt it bd nh ni nj nk nl nm nn no np ki nq kj nr kl ns km nt ko nu kp nv nw bi translated">结束了</h1><p id="d4e3" class="pw-post-body-paragraph li lj it lk b ll oh kd ln lo oi kg lq lr oj lt lu lv ok lx ly lz ol mb mc md im bi translated">这就是对XPath和Selenium的介绍。我们涵盖了:</p><ul class=""><li id="18fa" class="os ot it lk b ll lm lo lp lr ou lv ov lz ow md ox oy oz pa bi translated">DOM、节点和分支</li><li id="ec95" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated">测试XPath查询— <strong class="lk jd"> Fn+12 </strong>，<strong class="lk jd"> Ctrl+F </strong></li><li id="6351" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated">导航树</li><li id="6984" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated">从浏览器中提取XPaths</li><li id="24b5" class="os ot it lk b ll pb lo pc lr pd lv pe lz pf md ox oy oz pa bi translated">一些更高级的XPath逻辑</li></ul><p id="102e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我以前说过的，这只是触及了XPath的表面，我肯定会推荐您从事自己的小型web抓取/自动化项目并学习更多！</p><p id="d792" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喜欢这篇文章。如果您有任何想法或问题，请通过<a class="ae lh" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中告诉我！如果你想要更多这样的内容，我也会在YouTube 上发布。</p><p id="7d22" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="67c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="pq">*除非另有说明，所有图片均为作者所有。</em></p></div></div>    
</body>
</html>