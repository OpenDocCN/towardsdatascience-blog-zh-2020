<html>
<head>
<title>Supercharging your Mobile Apps with GPU Accelerated Machine Learning using the Android NDK, Vulkan and Kompute</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GPU加速您的移动应用程序使用Android NDK、Vulkan和Kompute加速机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gpu-accelerated-machine-learning-in-your-mobile-applications-using-the-android-ndk-vulkan-kompute-1e9da37b7617?source=collection_archive---------33-----------------------#2020-10-13">https://towardsdatascience.com/gpu-accelerated-machine-learning-in-your-mobile-applications-using-the-android-ndk-vulkan-kompute-1e9da37b7617?source=collection_archive---------33-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5fa5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个手把手的教程，教你如何利用你的手机GPU加速数据处理和机器学习。您将学习如何使用原生开发工具包(NDK)、Kompute框架和Vulkan SDK构建一个简单的Android应用程序。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/88ad02529450aeea47fcb68caa27fb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dfCkMbt_3Wr61Nq-ii4iDw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安卓NDK中的Kompute(图片由作者提供)</p></figure><p id="18fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如今，一些智能手机配备了笔记本电脑级别的硬件——携带高达16GB的RAM、高速多核CPU和能够在4k显示器上渲染高性能复杂图形应用的GPU。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/6d3b4b63fa1aa6ee9efcd6ba9b68e480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4MmQ0BsdGYws9At9aLFUg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="713f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随着移动硬件<a class="ae ls" href="https://www.mobilemarketer.com/news/mobile-games-sparked-60-of-2019-global-game-revenue-study-finds/569658/" rel="noopener ugc nofollow" target="_blank">不断改进</a> e，挖掘这种能力——特别是GPU处理能力——对于设备上的数据处理能力变得越来越重要。最近，围绕<a class="ae ls" href="https://en.wikipedia.org/wiki/Edge_computing" rel="noopener ugc nofollow" target="_blank">边缘计算</a>、<a class="ae ls" href="https://en.wikipedia.org/wiki/Federated_architecture" rel="noopener ugc nofollow" target="_blank">联合架构</a>、<a class="ae ls" href="https://arxiv.org/abs/1910.06663" rel="noopener ugc nofollow" target="_blank">移动深度学习</a>等，这已经开启了令人兴奋的机遇。</p><p id="c169" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文提供了一个技术深度，向您展示了如何利用移动跨供应商GPU的强大功能。您将学习如何使用<a class="ae ls" href="https://developer.android.com/ndk" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Android原生开发套件</strong> </a> <strong class="kx ir"> </strong>和<a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Kompute框架</strong> </a>为Android设备编写GPU优化代码。最终结果将是在Android Studio中创建的移动应用程序，它能够使用我们将从头开始编写的GPU加速机器学习模型，以及允许用户向模型发送输入的用户界面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/250fe67657c6a367d7bca17b5f4cc191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-q-MWIg4rOlyhBTrJiMUA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Android Studio在模拟器中运行项目(图片由作者提供)</p></figure><p id="0a10" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了编程经验之外，不需要任何背景知识<strong class="kx ir">，但是如果你对参考的底层AI / GPU计算概念感兴趣，我们建议查看我们以前的文章，“移动设备中的<a class="ae ls" rel="noopener" target="_blank" href="/machine-learning-and-data-processing-in-the-gpu-with-vulkan-kompute-c9350e5e5d3a">机器学习&amp;跨厂商GPU使用Kompute &amp; Vulkan </a>变得简单”。</strong></p><p id="0b3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在  <strong class="kx ir">资源库的<a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/tree/master/examples/android/android-simple" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">示例文件夹中找到完整的代码。</strong></a></strong></p><h1 id="d5e6" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">Android本地开发套件(NDK)</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/a434b6116a126dc1de8eaa8fdd8abe8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rlyOdmPMb70f_qPRntClg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安卓NDK图(图片由作者提供)</p></figure><p id="ac67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae ls" href="https://developer.android.com/ndk" rel="noopener ugc nofollow" target="_blank">原生开发套件(NDK) </a>是Android解决方案之一，旨在解决移动应用不断增长的计算需求。NDK框架使开发人员能够编写低级、高效的C和C++代码，这些代码可以通过流行的<a class="ae ls" href="https://en.wikipedia.org/wiki/Java_Native_Interface" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Java本地接口</strong> </a> <strong class="kx ir"> </strong>绑定与Java/Kotlin应用程序代码进行互操作。</p><p id="5caa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种工具使移动应用程序开发人员不仅可以编写高效的代码，还可以利用现有的用C++编写的优化框架进行高级数据处理或机器学习。</p><h1 id="8ab8" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">进入Kompute &amp; Vulkan SDK</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/69fe34f4969de848be6f3e7c63c68b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*mzEbYNdCJ129eSz3"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与Khronos成员一起玩“瓦尔多在哪里”(图片由Vincent Hindriksen通过<a class="ae ls" href="https://streamhpc.com/blog/2017-05-04/what-is-khronos-as-of-today/" rel="noopener ugc nofollow" target="_blank"> StreamHPC </a>提供)</p></figure><p id="0440" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Vulkan是由Khronos Group领导的一个开源项目，Khronos Group是一个由几家科技公司组成的联盟，致力于定义和推进移动和桌面媒体(和计算)技术的开放标准。</p><p id="fec7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大量高调(和新)的框架已经采用Vulkan作为他们的核心GPU处理SDK。Android NDK的主文档页面有一个完整的章节<a class="ae ls" href="https://developer.android.com/ndk/guides/graphics" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">专门介绍Vulkan </strong> </a>，以及展示如何在Android移动设备中使用它的实例。</p><p id="f790" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您所想象的，Vulkan SDK提供了对GPU的非常低级的访问，这允许非常专业的优化。这对于数据处理和GPU开发人员来说是一笔巨大的财富——主要缺点是冗长，需要500–2000多行代码才能获得编写应用程序逻辑所需的基本样板文件。这可能导致昂贵的开发周期和错误，从而导致更大的问题。这是我们启动Kompute项目的主要动机之一。</p><p id="9e8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae ls" href="https://github.com/axsaucedo/vulkan-kompute#vulkan-kompute" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Kompute </strong> </a>是一个构建在Vulkan SDK之上的框架，它抽象了大量所需的样板代码，引入了展示Vulkan计算能力的最佳实践。Kompute是GPU计算框架，我们将在本教程中使用它来构建我们的移动Android应用程序中的机器学习模块。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/d2dcfcf18bf93b58d2dd857ee46bc8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hkFiBPfbdHQqhHKA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kompute <a class="ae ls" href="https://ethicalml.github.io/vulkan-kompute/" rel="noopener ugc nofollow" target="_blank">文档</a>(图片由作者提供)</p></figure><h1 id="efb1" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">移动开发中的机器学习</h1><p id="916d" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">在本帖中，我们将基于我们在“<a class="ae ls" rel="noopener" target="_blank" href="/machine-learning-and-data-processing-in-the-gpu-with-vulkan-kompute-c9350e5e5d3a">移动设备中的机器学习&amp;跨厂商GPU使用Kompute &amp; Vulkan </a>”文章中创建的机器学习用例。我们不会像在那篇文章中那样详细地讨论基础概念，但是我们仍然会在这一节中介绍所需的高级直觉。</p><p id="fd32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要一个允许我们公开机器学习逻辑的接口，这主要需要两个功能:</p><ol class=""><li id="9120" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated"><code class="fe nd ne nf ng b">train(…) </code> —允许机器学习模型学习从提供的输入预测输出的功能</li><li id="78e3" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq mz na nb nc bi translated"><code class="fe nd ne nf ng b">predict(...)</code> —预测未知实例输出的函数。</li></ol><p id="9cbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可以在下图中概述的两个工作流程中看到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/ed02a8a4aea14ecfa3798cd6fda8a005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZE0_pQd6kjy0y5I0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据科学流程(图片由作者提供)</p></figure><p id="3059" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">特别是在应用程序开发中，这也将是机器学习工作流的一种常见模式，无论是预测性还是解释性建模用例。这通常包括利用用户在直接(或间接)与应用程序交互时生成的数据。这些数据可以作为机器学习模型的训练特征。新模型的训练可以通过数据科学家执行的手动“离线”工作流来执行，或者通过自动触发再训练模型来执行。</p><h1 id="cd83" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">Android Studio项目概述</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/d421fbb52b1da1a0605554343454b459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*If89pXcj4hSNJDTEFEdFNw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">项目文件结构(图片由作者提供)</p></figure><p id="7a09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将从提供Android Studio项目中核心组件的高级概述开始，包括Kompute C++绑定、Android用户界面、Kotlin中的应用程序逻辑构建以及所需的构建文件。如果你对某个领域感兴趣，你可以跳到下面相应的部分。</p><p id="238e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您需要确保安装了<a class="ae ls" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Android Studio </strong> </a>，还需要安装<a class="ae ls" href="https://developer.android.com/ndk/guides#download-ndk" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">Android NDK</strong></a>——其余的依赖项将在IDE中打开项目时自动安装和配置。</p><p id="cfff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在您已经安装了所有的东西，您可以导入项目了。为此，你首先要克隆<a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">完整的Kompute库</strong> </a>并导入<code class="fe nd ne nf ng b">examples/android/android-simple/</code>下的Android Studio项目。现在，您应该能够看到项目加载和配置构建。一旦它打开，你就可以在模拟器或你自己的安卓手机上运行它。这个项目在Pixel 2模拟器和三星Galaxy手机上进行了测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/4fce717aa488f92d59c710e82b7f4a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZXTUuwtfxXi1sHQeGmZYg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终的GPU加速Kompute应用程序(图片由作者提供)</p></figure><p id="0943" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您加载项目时，您会注意到文件结构中的以下关键组件，我们将在下面的部分中进一步详细分析这些组件:</p><ul class=""><li id="a737" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated"><strong class="kx ir"> Android SDK应用</strong>—Android UI、资产资源、构建文件和Kotlin/Java组件，提供与UI和C++ Kompute ML绑定交互的相关应用逻辑。</li><li id="46d2" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><strong class="kx ir">安卓NDK Kompute ML模块</strong> —通过安卓NDK配置的用于GPU加速处理的Kompute ML C++代码和绑定。</li></ul><h1 id="6140" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">Android SDK应用程序</h1><p id="a69e" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">本节涵盖了Android SDK Java/Kotlin和用户界面组件，这些组件将直观地展示高级业务逻辑如何与本地C++ JNI绑定进行交互。</p><p id="2da3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用户界面主要由输入文本框和显示文本标签组成，使用户能够与GPU加速ML处理C++内核进行交互(如下图所示)。如果你对所使用的视图很好奇，你可以在你的Android Studio项目中查看，或者直接打开<code class="fe nd ne nf ng b"><a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/res/layout/activity_kompute_jni.xml" rel="noopener ugc nofollow" target="_blank">activity_kompute_jni.xml</a></code> <a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/res/layout/activity_kompute_jni.xml" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/a0212b9005e57d4e402ab973a5d64ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TFHzF8zt6xQXvHDsuFlxA.png"/></div></div></figure><p id="e08e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的移动应用程序的核心可以在<code class="fe nd ne nf ng b"><a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/java/com/ethicalml/kompute/KomputeJni.kt" rel="noopener ugc nofollow" target="_blank">KomputeJni.kt</a></code> <a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/java/com/ethicalml/kompute/KomputeJni.kt" rel="noopener ugc nofollow" target="_blank">文件</a>内的<code class="fe nd ne nf ng b">app/src/main/java/com/ethicalml/kompute</code>文件夹中找到。这个Kotlin文件包含我们的Android应用程序的主要业务逻辑。</p><p id="4ac7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们在下面的代码块中查看该类的简化版本，我们会注意到以下要点:</p><ul class=""><li id="bd52" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated"><code class="fe nd ne nf ng b">fun onCreate(…)</code> —此函数在Android活动初始化时调用(当应用程序加载时)</li><li id="3864" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">fun KomputeButtonOnClick(…)</code> —当主“KOMPUTE”按钮被按下时，该函数被触发，并使用用户界面文本框中的数据触发C++ Jni绑定函数。</li><li id="6ef0" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">external fun initVulkan(): Boolean</code> —该函数是C++ JNI函数之一，将被绑定到Vulkan初始化C++函数。</li><li id="73e9" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">external fun kompute(...): FloatArray</code> —这是C++ JNI函数，它将训练ML模型并对提供的输入运行推理，返回推理结果。</li><li id="5328" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">external fun komputeParams(...): FloatArray</code> —训练模型并返回学习参数<code class="fe nd ne nf ng b">weight 1</code>、<code class="fe nd ne nf ng b">weight 2</code>和<code class="fe nd ne nf ng b">bias</code>的C++ JNI函数。</li><li id="579e" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">companion object { ...("kompute-jni") }</code> —这是您将为C++输出共享库指定的名称，该库将包含带有所有相关绑定函数的已编译C++源代码。</li></ul><p id="9570" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您还会注意到，<code class="fe nd ne nf ng b">external fun</code>函数没有任何定义——这是因为定义是在C++ JNI函数绑定中提供的，这将在<a class="ae ls" href="http://jni" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> C++ JNI绑定部分</strong> </a>中介绍。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5d4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，为了更详细地介绍每个函数，我们从<code class="fe nd ne nf ng b">onCreate</code>函数开始。这个函数负责初始化应用程序中所有相关的组件。这包括:</p><ul class=""><li id="e26a" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated"><code class="fe nd ne nf ng b">val binding</code> —这是允许我们访问UI中所有文本框和元素的主要对象。</li><li id="385e" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated">这是我们第一次调用C++ JNI函数，它主要负责初始化Vulkan。如果成功，它返回<code class="fe nd ne nf ng b">true</code>，我们在一个<code class="fe nd ne nf ng b">android.widget.Toast</code>弹出窗口中显示相应的成功消息——否则显示一个错误。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="24a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来我们有<code class="fe nd ne nf ng b">KomputeButtonOnClick(...)</code>功能。当用户按下应用程序中的<code class="fe nd ne nf ng b">“KOMPUTE”</code>按钮时，该功能被触发。该函数的主要目的是从UI中的输入文本框中检索输入，然后使用输入数据通过JNI C++绑定执行ML训练/推理步骤，最后在UI文本标签中显示结果输出。更详细地说:</p><ul class=""><li id="7daf" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated"><code class="fe nd ne nf ng b">val &lt;elementname&gt; = findViewById&lt;EditText&gt;(R.id.&lt;elementname&gt;) </code> —这是创建变量的步骤的格式，该变量包含相应的输入文本框。在这种情况下,<code class="fe nd ne nf ng b">&lt;elementname&gt;</code>是我们正在交互的元素的名称。</li><li id="c853" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">xi, xj and y</code>—<code class="fe nd ne nf ng b">FloatArray</code>元素从相应输入框中的文本创建，然后用于ML模型处理。</li><li id="6c53" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">val out = kompute(xi, xj, y)</code> —这里我们运行C++ JNI绑定函数<code class="fe nd ne nf ng b">kompute</code>，它通过我们在C++中创建的KomputeModelML类训练和处理数据。</li><li id="44b9" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">val params = komputeParams(xi, xj, y)</code> —这里我们运行C++ JNI绑定函数，该函数训练并返回Kompute机器学习模型的学习参数。</li><li id="6c6b" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">&lt;elementname&gt;.text = &lt;value&gt;</code> —遵循此格式的行基本上会覆盖UI中的文本标签以显示输出。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="18eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后几个函数只被显式设置为绑定到C++ JNI绑定的外部函数。此外,<code class="fe nd ne nf ng b">companion object</code>部分提供了共享库的名称，该共享库将包含本活动中引用的各个绑定。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7064" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在资源库中的<code class="fe nd ne nf ng b"><a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/java/com/ethicalml/kompute/KomputeJni.kt" rel="noopener ugc nofollow" target="_blank">KomputeJni.kt</a></code>文件<a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/java/com/ethicalml/kompute/KomputeJni.kt" rel="noopener ugc nofollow" target="_blank">中找到完整的文件。</a></p><h1 id="823a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">安卓NDK Kompute ML模块</h1><p id="75fa" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">本节涵盖了<strong class="kx ir"> Android NDK Kompute ML模块</strong>文件，其中包括构建系统，以及使用<a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Kompute框架</strong> </a>的C++源代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b49a56f8caabb79fa685b32777de0b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*c-LUmEwPLAKgZ3t4.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kompute <a class="ae ls" href="https://ethicalml.github.io/vulkan-kompute/overview/reference.html" rel="noopener ugc nofollow" target="_blank">建筑设计</a>(图片由作者提供)</p></figure><p id="0414" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将使用Kompute的核心组件，如附图所示。也就是说，我们将使用Kompute Tensors在GPU中加载相关数据，使用相应的Kompute操作处理它，并使用Kompute序列和Kompute管理器协调它。我们不会详细讨论Kompute架构，但是如果你想了解更多的底层概念，你可以查看关于底层实现的更详细的文章。</p><p id="b440" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Android NDK绑定模块中的核心组件包括:</p><ul class=""><li id="dd44" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated"><strong class="kx ir"> JNI绑定函数</strong> —可以从Java/Kotlin Android SDK应用代码中调用的原生函数。</li><li id="cbca" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><strong class="kx ir"> KomputeModelML类</strong> —公开Kompute GPU加速ML模型逻辑的类。</li><li id="2b8b" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><strong class="kx ir"> CMake构建文件</strong> —负责编译和链接所有相关库的C++构建文件。</li></ul><h2 id="3685" class="nu lv iq bd lw nv nw dn ma nx ny dp me le nz oa mg li ob oc mi lm od oe mk of bi translated">JNI结合函数</h2><p id="98c7" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">在这种情况下，JNI绑定通过<code class="fe nd ne nf ng b"><a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/cpp/KomputeJniNative.cpp" rel="noopener ugc nofollow" target="_blank">KomputeJniNative.cpp</a></code> <a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/cpp/KomputeJniNative.cpp" rel="noopener ugc nofollow" target="_blank">文件</a>提供。下面是这个类的框架——为了简单起见，函数代码逻辑已经被编辑过了，下面会有更详细的解释。</p><p id="d4ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JNI绑定函数必须匹配Java/Kotlin代码中定义的类函数。该函数的格式为:</p><ul class=""><li id="3dfd" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated"><code class="fe nd ne nf ng b">Java_&lt;modulepath&gt;_&lt;class&gt;_&lt;functionname&gt;(env, thiz, ...params)</code></li></ul><p id="a432" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，这个类在<code class="fe nd ne nf ng b">com.ethicalml.kompute</code>模块中，在类<code class="fe nd ne nf ng b">KomputeJni</code>和它各自的函数中——下面的函数名称将反映这个结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5cab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">再深入一层，我们现在可以浏览文件的每个部分。从导入开始，我们可以看到下面的导入以及概述其核心功能的注释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="abb8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Android应用程序中，我们实际上需要手动初始化Vulkan动态库(这是在Android之外通常不会做的事情)。之所以需要这样做，是因为Vulkan库实际上并没有链接到Android手机中。Android避免进行任何链接的原因是为了向后兼容，主要是为了确保如果在旧手机中找不到Vulkan库，应用程序不会崩溃。</p><p id="d44d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着我们需要在C++代码中手动找到这个库，如果找到了，就将每个函数链接到它各自的内存地址指针，这样我们的C++框架就可以使用它了。幸运的是，这是Kompute自动做的事情，我们不会在本文中涉及细节，因为它本身可能需要一篇文章，但如果你感兴趣，你可以在<a class="ae ls" href="https://marcelbraghetto.github.io/a-simple-triangle/2019/06/16/part-17/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">这篇文章</strong> </a>中阅读更多关于它的内容，你可以看到Kompute如何使用<code class="fe nd ne nf ng b"><a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/tree/45ddfe524b9ed63c5fe1fc33773c8f93a18e2fac/vk_ndk_wrapper_include" rel="noopener ugc nofollow" target="_blank">vk_ndk_wrapper_include</a></code> <a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/tree/45ddfe524b9ed63c5fe1fc33773c8f93a18e2fac/vk_ndk_wrapper_include" rel="noopener ugc nofollow" target="_blank">文件</a>在<a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/45ddfe524b9ed63c5fe1fc33773c8f93a18e2fac/src/include/kompute/Core.hpp#L5" rel="noopener ugc nofollow" target="_blank"> Core.hpp头文件</a>中动态导入Vulkan。</p><p id="8407" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面您可以看到公开了<code class="fe nd ne nf ng b">initVulkan</code>逻辑— <code class="fe nd ne nf ng b">Java_com_ethicalml_kompute_KomputeJni_initVulkan(...)</code>的函数的实现。你可以在这个函数中看到我们运行<code class="fe nd ne nf ng b">InitVulkan()</code>直到Vulkan库成功初始化，或者如果达到最大重试次数则失败。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dd38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦Vulkan被初始化，就可以调用剩余的函数。第一个是<code class="fe nd ne nf ng b">kompute</code>函数，它负责训练模型和运行推理请求。该函数接收输入Xi和Xj值，以及模型将从中学习的预期预测值。然后，它将返回把Xi和Xj视为看不见的数据的预测。函数基本上会调用<code class="fe nd ne nf ng b">KomputeModelML</code>类的<code class="fe nd ne nf ng b">train</code>函数和<code class="fe nd ne nf ng b">predict</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2150" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后剩下的将会暴露给Java/Kotlin代码的JNI函数是<code class="fe nd ne nf ng b">komputeParams</code>函数，它负责返回机器学习模型学习的参数，即<code class="fe nd ne nf ng b">weight 1</code>、<code class="fe nd ne nf ng b">weight 2</code>和<code class="fe nd ne nf ng b">bias</code>参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5f5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一剩下的函数是我们在JNI逻辑中使用的效用函数——即<code class="fe nd ne nf ng b"><a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/45ddfe524b9ed63c5fe1fc33773c8f93a18e2fac/examples/android/android-simple/app/src/main/cpp/KomputeJniNative.cpp#L32" rel="noopener ugc nofollow" target="_blank">jfloatArrayToVector</a></code>和<code class="fe nd ne nf ng b"><a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/45ddfe524b9ed63c5fe1fc33773c8f93a18e2fac/examples/android/android-simple/app/src/main/cpp/KomputeJniNative.cpp#L41" rel="noopener ugc nofollow" target="_blank">vectorToJFloatArray</a></code> —这些函数是不言自明的，所以我们将让感兴趣的读者在源代码中进一步探索。</p><h2 id="2141" class="nu lv iq bd lw nv nw dn ma nx ny dp me le nz oa mg li ob oc mi lm od oe mk of bi translated">KomputeModelML类</h2><p id="aac0" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">既然我们已经介绍了绑定到Kotlin / Java类的关键函数，我们可以介绍包含Kompute GPU加速逻辑的<code class="fe nd ne nf ng b">KomputeModelML</code> C++类。</p><p id="2878" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">KomputeModelML类的头文件如下所示，它包含以下关键组件:</p><ul class=""><li id="c13c" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated"><code class="fe nd ne nf ng b">#include "kompute/Kompute.hpp”</code> —包含我们将在这个项目中使用的所有Kompute依赖项的头</li><li id="4c6b" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">void train(...)</code>-使用逻辑回归模型的GPU本机代码来训练机器学习模型。它接受输入数组<code class="fe nd ne nf ng b">X</code>，以及包含预期输出的数组<code class="fe nd ne nf ng b">y</code>。</li><li id="d13c" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">std::vector&lt;float&gt; predict(...)</code>—执行推理请求。在这种实现中，它不使用GPU代码，因为通常在推理端通过并行化获得的性能收益较少。然而，如果并行处理多个输入，仍有预期的性能增益(此功能允许)。</li><li id="da65" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">std::vector&lt;float&gt; get_params()</code>—以<code class="fe nd ne nf ng b">[ &lt;weight_1&gt;, &lt;weight_2&gt;, &lt;bias&gt; ]</code>的格式返回包含学习参数的数组。</li><li id="e568" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">static std::string LR_SHADER</code>—<a class="ae ls" href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language" rel="noopener ugc nofollow" target="_blank">着色器代码，将在GPU </a>内部作为机器码执行。Kompute允许我们传递包含代码的字符串，但是对于生产部署，可以将着色器转换为二进制文件，也可以使用可用的实用程序转换为头文件。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="026d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您对完整的实现感兴趣，您可以在<a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/tree/v0.3.2/examples/android/android-simple" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到所有文件。此外，如果你对这些技术的理论和潜在的基本概念感兴趣，这将在我们之前的文章中全面介绍。</p><h2 id="e7f0" class="nu lv iq bd lw nv nw dn ma nx ny dp me le nz oa mg li ob oc mi lm od oe mk of bi translated">CMake生成文件</h2><p id="44c3" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated"><code class="fe nd ne nf ng b"><a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/cpp/CMakeLists.txt" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">CMakeLists.txt</strong></a></code> <a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/v0.3.2/examples/android/android-simple/app/src/main/cpp/CMakeLists.txt" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">构建文件</strong> </a>是Android NDK工作流程中非常重要的组件。如果您希望将Kompute添加到您自己的项目中，这一部分变得尤为重要。cmake文件很小，所以我们将分别介绍每一行。</p><p id="ee97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要确保Kompute库是可用的。通常你会运行Kompute构建的<code class="fe nd ne nf ng b">INSTALL </code>目标来使用/导入各自的库。然而，在这种情况下，我们需要确保Kompute是为正确的Android CPU架构构建的——我们最简单的选择是添加主存储库作为构建的一部分，这意味着Kompute也将为正确的移动架构构建。如果你想把它包含在你的项目中，你只需要确保路径是相对于Kompute克隆文件夹的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4015" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在将变量VK_ANDROID_INCLUDE_DIR设置为vulkan include目录。这包含了Vulkan需要的所有包含文件——为了完整起见，Kompute使用了<code class="fe nd ne nf ng b">vulkan.h</code>头文件和<code class="fe nd ne nf ng b">vulkan.hpp</code> C++头文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8180" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在能够添加Java/Kotlin Android Studio项目将使用的库，在本例中是共享库<code class="fe nd ne nf ng b"><strong class="kx ir">kompute-jni</strong></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="77fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在能够添加所有相关的<code class="fe nd ne nf ng b">include</code>目录。这包括我们上面定义的<code class="fe nd ne nf ng b">VK_ANDROID_INCLUDE_DIR</code>，以及包含Android <code class="fe nd ne nf ng b">log.h</code>的<code class="fe nd ne nf ng b">VK_ANDROID_COMMON_DIR</code>。<code class="fe nd ne nf ng b">single_include</code>包含来自Kompute的<code class="fe nd ne nf ng b">kompute/Kompute.hpp</code>报头。最后，我们需要导入Kompute动态库包装器<code class="fe nd ne nf ng b">vk_ndk_wrapper_include</code>，这是动态导入Vulkan库所必需的。这背后的逻辑本身可以成为一系列文章，所以我们不会深入这个兔子洞，但如果你感兴趣，你可以在<a class="ae ls" href="https://marcelbraghetto.github.io/a-simple-triangle/2019/06/16/part-17/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">这篇文章</strong> </a>中阅读更多内容，你可以看到Kompute如何动态导入<a class="ae ls" href="https://github.com/EthicalML/vulkan-kompute/blob/45ddfe524b9ed63c5fe1fc33773c8f93a18e2fac/src/include/kompute/Core.hpp#L5" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">Vulkan</strong></a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1d66" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了编译这个项目，我们需要确保设置了<code class="fe nd ne nf ng b">VK_USE_PLATFORM_ANDROID_KHR</code>，因为这是启用Android配置的原因。对于这个项目，我们也用<code class="fe nd ne nf ng b">KOMPUTE_DISABLE_VK_DEBUG_LAYERS.</code>禁用Vulkan调试层</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="85b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们能够将相关的库链接到我们的<code class="fe nd ne nf ng b">kompute-jni</code>共享库目标。这包括:</p><ul class=""><li id="e18f" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated"><code class="fe nd ne nf ng b">kompute </code> —这是在Kompute构建中创建的库。</li><li id="da1a" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">kompute_vk_ndk_wrapper</code> —这个库也是由Kompute build创建的，包含动态加载和包装Vulkan库的代码。</li><li id="8f35" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">log</code> —这是Android日志库，Kompute需要它来覆盖日志记录。</li><li id="b02e" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><code class="fe nd ne nf ng b">android</code> —这是Android项目使用的Android库。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1780" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就这样——您现在可以运行应用程序了，它将执行完整的构建。然后你应该能够在你的Android Studio模拟器中或者你的物理手机中看到Kompute应用程序，在那里你将能够触发你的设备上GPU的处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/250fe67657c6a367d7bca17b5f4cc191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-q-MWIg4rOlyhBTrJiMUA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Android Studio在模拟器中运行项目(图片由作者提供)</p></figure><h1 id="4431" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">下一步是什么？</h1><p id="1817" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">恭喜你，你一路走到了最后！虽然这篇文章涵盖了广泛的主题，但是也有大量的概念被浏览过。其中包括底层Android开发工作流、Vulkan概念、GPU计算基础、机器学习最佳实践以及更高级的Kompute概念。幸运的是，网上有资源可以扩展你在这些方面的知识。以下是我推荐的一些进一步阅读的链接:</p><ul class=""><li id="ed2d" class="mu mv iq kx b ky kz lb lc le mw li mx lm my lq np na nb nc bi translated">"<a class="ae ls" rel="noopener" target="_blank" href="/machine-learning-and-data-processing-in-the-gpu-with-vulkan-kompute-c9350e5e5d3a">利用Kompute简化移动设备中的机器学习&amp;跨供应商GPU&amp;Vulkan</a>文章，深入探讨理论和概念</li><li id="6a58" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated">“<a class="ae ls" rel="noopener" target="_blank" href="/parallelizing-heavy-gpu-workloads-via-multi-queue-operations-50a38b15a1dc">使用Kompute </a>通过多队列并发并行化GPU密集型工作负载”采用更先进的Kompute概念</li><li id="3ed1" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><a class="ae ls" href="https://axsaucedo.github.io/vulkan-kompute/" rel="noopener ugc nofollow" target="_blank"> Kompute文档</a>了解更多细节和更多示例</li><li id="16d4" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><a class="ae ls" href="https://ethical.institute/mle.html" rel="noopener ugc nofollow" target="_blank">机器学习工程师时事通讯</a>如果你想了解关于机器学习的最新文章</li><li id="1e76" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><a class="ae ls" href="https://developer.android.com/ndk/guides" rel="noopener ugc nofollow" target="_blank"> Android NDK入门文档</a>如果您想深入了解本地开发套件</li><li id="3823" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><a class="ae ls" href="https://github.com/EthicalML/awesome-production-machine-learning/" rel="noopener ugc nofollow" target="_blank">令人敬畏的生产机器学习</a>开源工具列表，用于部署、监控、版本化和扩展您的机器学习</li><li id="5757" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><a class="ae ls" href="https://www.fast.ai/2018/09/26/ml-launch/" rel="noopener ugc nofollow" target="_blank">FastAI的编码人员ML课程简介</a>进一步学习机器学习概念</li><li id="0691" class="mu mv iq kx b ky nh lb ni le nj li nk lm nl lq np na nb nc bi translated"><a class="ae ls" href="https://vulkan-tutorial.com/" rel="noopener ugc nofollow" target="_blank"> Vulkan SDK教程</a>深入了解底层Vulkan组件</li></ul></div></div>    
</body>
</html>