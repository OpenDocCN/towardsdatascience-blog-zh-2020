<html>
<head>
<title>Bitwise operators and chaining comparisons in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas中的按位运算符和链接比较</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bitwise-operators-and-chaining-comparisons-in-pandas-d3a559487525?source=collection_archive---------18-----------------------#2020-11-13">https://towardsdatascience.com/bitwise-operators-and-chaining-comparisons-in-pandas-d3a559487525?source=collection_archive---------18-----------------------#2020-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="31fb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Pandas中的比较链接和运算符优先级的重要性</h2></div><p id="0ee0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在学习熊猫的时候，很自然会有使用Python的布尔运算符(<code class="fe le lf lg lh b">and</code>、<code class="fe le lf lg lh b">or</code>等)的倾向。)来链接条件，因为在Python中就是这样做的。然而，这些不是我们应该在Pandas(或NumPy)中使用的操作符。让我解释一下为什么…</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/d5f1a464e496c8cd03205b4a1cf5d6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1p71f7yFTzCatzzftF3yA.jpeg"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图片来自<a class="ae ly" href="https://unsplash.com/photos/xrVDYZRGdw4" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="fa5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，链接比较非常简单:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="a310" class="md me it lh b gy mf mg l mh mi">x = 4<br/>x==4 and x%2==0<br/>True</span></pre><p id="27a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们只是检查<code class="fe le lf lg lh b">x</code>是否等于<code class="fe le lf lg lh b">4</code><em class="mj"/>以及<em class="mj"> </em>是否为偶数。同样，我们可以将多个条件链接在一起，如下所示:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="4e9c" class="md me it lh b gy mf mg l mh mi">b = 'random string'<br/>x==4 and x%2==0 and b.endswith('ing')<br/>True</span></pre><p id="e5f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为我们正在比较布尔值(<code class="fe le lf lg lh b">True</code>或<code class="fe le lf lg lh b">False</code>)或<a class="ae ly" href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noopener ugc nofollow" target="_blank">true/falsy</a><em class="mj"/>值(计算为<code class="fe le lf lg lh b">True</code>或<code class="fe le lf lg lh b">False</code>的值)，对于上面的例子，这些值产生了一个表达式<code class="fe le lf lg lh b">True and True and True</code>。</p><h2 id="1146" class="md me it bd mk ml mm dn mn mo mp dp mq kr mr ms mt kv mu mv mw kz mx my mz na bi translated">比较布尔数组</h2><p id="29bb" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">然而，一个常见的错误是认为这同样适用于布尔值数组，这是应用一些比较的结果。例如:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="8523" class="md me it lh b gy mf mg l mh mi">x = np.array([2,4,6])<br/>x%2==0 and x!=3<br/>ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</span></pre><p id="d290" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，上面产生了一个<code class="fe le lf lg lh b">ValueError</code>。这种情况下发生了什么变化？不同之处在于，我们不再比较布尔值，因为<code class="fe le lf lg lh b">x%2==0</code>产生:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="dd74" class="md me it lh b gy mf mg l mh mi">array([ True, True, True])</span></pre><p id="3166" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这显然既不是<code class="fe le lf lg lh b">True</code>也不是<code class="fe le lf lg lh b">False</code>。Python通过错误告诉我们，我们需要对结果应用聚合函数来消除歧义，<code class="fe le lf lg lh b">a.any()</code>或<code class="fe le lf lg lh b">a.all()</code>。这样做会将数组缩减为一个值:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="77e6" class="md me it lh b gy mf mg l mh mi">(x%2==0).any()<br/>True</span></pre><p id="3cd9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在可以将其与另一个布尔值进行比较。</p><h2 id="b1df" class="md me it bd mk ml mm dn mn mo mp dp mq kr mr ms mt kv mu mv mw kz mx my mz na bi translated">按位运算符</h2><p id="068c" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">当我们处理一个数组或一个Pandas DataFrame列，并希望<strong class="kk iu">基于一个以上的比较</strong>进行过滤时，我们将需要计算基于元素的操作，在本例中，<strong class="kk iu">基于逻辑元素的</strong> <strong class="kk iu">操作</strong>。</p><p id="fbc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经讨论了python的布尔操作符为什么不是我们想要的，因为它们要求被比较的项可以被评估为<code class="fe le lf lg lh b">True</code>或<code class="fe le lf lg lh b">False</code>。对于基于逻辑元素的操作，我们应该使用python的按位操作符<a class="ae ly" href="https://wiki.python.org/moin/BitwiseOperators" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"/></a><strong class="kk iu">&lt;&lt;</strong><strong class="kk iu">&gt;&gt;</strong><strong class="kk iu">&amp;</strong><strong class="kk iu">|</strong><strong class="kk iu">~</strong>和<strong class="kk iu"> ^.</strong></p><p id="6c00" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以将python的按位运算符视为布尔运算符，但它是基于元素应用的(在布尔数组上):</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="6fd0" class="md me it lh b gy mf mg l mh mi">x%2==0<br/>array([ True, True, True])</span><span id="82ac" class="md me it lh b gy ng mg l mh mi">x==4<br/>array([False, True, False])</span><span id="3e5d" class="md me it lh b gy ng mg l mh mi">(x%2==0) &amp; (x==4)<br/>array([False, True, False])</span></pre><p id="2417" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以在这里，我们在两个结果布尔向量之间应用了一个<strong class="kk iu">按位AND</strong>(<strong class="kk iu">&amp;</strong>)<strong class="kk iu"/>，这产生了另一个形状相同的数组，该数组是通过对其元素应用逐元素操作而得到的。</p><p id="1ec6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python对于所有布尔运算符以及下面列出的其他运算符都有一个等价的按位运算符:</p><ul class=""><li id="1e35" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated"><code class="fe le lf lg lh b">x &amp; y</code>做一个“按位<code class="fe le lf lg lh b">AND</code>”。如果<code class="fe le lf lg lh b">x</code>和<code class="fe le lf lg lh b">y</code>的对应位为<code class="fe le lf lg lh b">1</code>，则输出的每一位为<code class="fe le lf lg lh b">1</code>，否则为<code class="fe le lf lg lh b">0</code>。</li><li id="b173" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated"><code class="fe le lf lg lh b">x | y </code>做一个“按位<code class="fe le lf lg lh b">OR</code>”。如果<code class="fe le lf lg lh b">x</code>和<code class="fe le lf lg lh b">y</code>的对应位为0，则输出的每一位为<code class="fe le lf lg lh b">0</code>，否则为<code class="fe le lf lg lh b">1</code>。</li><li id="5159" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated"><code class="fe le lf lg lh b">~x</code>返回<code class="fe le lf lg lh b">x</code> ( <code class="fe le lf lg lh b">NOT</code>)的补码——通过切换每个<code class="fe le lf lg lh b">1</code>得到一个<code class="fe le lf lg lh b">0</code>，每个<code class="fe le lf lg lh b">0</code>得到一个<code class="fe le lf lg lh b">1</code>。这个和<code class="fe le lf lg lh b">-x-1</code>一样。</li><li id="fe22" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated"><code class="fe le lf lg lh b">x ^ y</code>做“按位异或”(<code class="fe le lf lg lh b">XOR</code>)。如果<code class="fe le lf lg lh b">y</code>中的位是<code class="fe le lf lg lh b">0</code>，则输出的每一位与x中对应的位相同，如果<code class="fe le lf lg lh b">y</code>中的位是<code class="fe le lf lg lh b">1</code>，则输出的每一位是<code class="fe le lf lg lh b">x</code>中位的补码。</li></ul><p id="0594" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还有按位移位操作符<code class="fe le lf lg lh b">&gt;&gt;</code>和<code class="fe le lf lg lh b">&lt;&lt;</code>(见这里的<a class="ae ly" href="https://wiki.python.org/moin/BitwiseOperators" rel="noopener ugc nofollow" target="_blank"/>)。</p><h2 id="6322" class="md me it bd mk ml mm dn mn mo mp dp mq kr mr ms mt kv mu mv mw kz mx my mz na bi translated">运算符优先级</h2><p id="42e6" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">回到上面的例子，需要考虑的一个重要方面是，使用按位运算符<strong class="kk iu">时，括号很重要！</strong></p><p id="7458" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为按位运算符<strong class="kk iu">比比较运算符</strong>具有更高的优先级，这意味着按位运算将在比较运算的之前<strong class="kk iu">。</strong></p><p id="adf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python文档的<em class="mj">表达式</em>部分，在<a class="ae ly" href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="noopener ugc nofollow" target="_blank"> <em class="mj">运算符优先级</em> </a> <em class="mj">，</em>下，我们将找到一个包含所有Python运算符优先级的表格，从最低优先级(最少绑定)到最高优先级(最多绑定):</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nv"><img src="../Images/7c4da31a85f4e851b2573da5d8ef33b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsorMcrTUFSG9cnMCoUBuQ.png"/></div></div><p class="lu lv gj gh gi lw lx bd b be z dk translated">图片来自<a class="ae ly" href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="noopener ugc nofollow" target="_blank"> python文档</a></p></figure><p id="bdff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更清楚地理解上述内容，假设我们有一个包含乘法运算符(<strong class="kk iu"> * </strong>)和幂运算符(<strong class="kk iu"> ** </strong>)的表达式:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="24dd" class="md me it lh b gy mf mg l mh mi">3*2**2<br/>12</span></pre><p id="ef45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于取幂运算符的优先级更高(看它是如何出现在表中较低位置的)，python会先对<code class="fe le lf lg lh b">2**2</code>求值，也就是<code class="fe le lf lg lh b">4</code>，然后是<code class="fe le lf lg lh b">3*4=12</code>。如果我们想给乘法一个更高的优先级，我们必须把表达式括起来:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="16ca" class="md me it lh b gy mf mg l mh mi">(3*2)**2<br/>36</span></pre><p id="5550" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们如何写数学表达式。</p><p id="22b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这同样适用于按位运算符。由于<code class="fe le lf lg lh b">==</code>的优先级比<code class="fe le lf lg lh b">&amp;</code>低，我们需要用括号括起比较表达式，以便首先对它们求值:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="037b" class="md me it lh b gy mf mg l mh mi">(x%2==0) &amp; (x==4)</span></pre><h2 id="c21c" class="md me it bd mk ml mm dn mn mo mp dp mq kr mr ms mt kv mu mv mw kz mx my mz na bi translated">链式运算符比较</h2><p id="e599" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">另一个常见的错误，是试图将连锁运营商视为:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="858d" class="md me it lh b gy mf mg l mh mi">x = np.array([2,4,6])</span><span id="fefd" class="md me it lh b gy ng mg l mh mi">1&lt;x&lt;10<br/>ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</span></pre><p id="a2a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NumPy(或Pandas)不支持这一点，它会产生一个<code class="fe le lf lg lh b">ValueError</code>。这里的问题是，Python在内部将上述内容转化为:</p><pre class="lj lk ll lm gt lz lh ma mb aw mc bi"><span id="2070" class="md me it lh b gy mf mg l mh mi">(1 &lt; x) and (x &gt; 10)</span></pre><p id="5119" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这又把我们带到了与上例相同的错误:<code class="fe le lf lg lh b">and</code>隐式调用<code class="fe le lf lg lh b">bool</code>，而<code class="fe le lf lg lh b">NumPy</code>只允许隐式强制为单个元素的布尔值(不是带有<code class="fe le lf lg lh b">size&gt;1</code>的数组)，因为带有许多值的布尔数组既不计算<code class="fe le lf lg lh b">True</code>也不计算<code class="fe le lf lg lh b">False</code>。</p><p id="b440" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上在PEP 535中已经提出要实现这一点，尽管它仍然被推迟了。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="720a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在接下来的帖子中，我将讨论熊猫中更高级的比较操作，并回顾一些需要记住的有用提示。</p><p id="8618" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常感谢你花时间阅读这篇文章，希望你喜欢:)</p></div></div>    
</body>
</html>