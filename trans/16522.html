<html>
<head>
<title>What are the 10 most popular standard libraries in python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python中最流行的10个标准库是什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-are-the-10-most-popular-standard-libraries-in-python-359defb104d6?source=collection_archive---------31-----------------------#2020-11-14">https://towardsdatascience.com/what-are-the-10-most-popular-standard-libraries-in-python-359defb104d6?source=collection_archive---------31-----------------------#2020-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5e27" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于GitHub存储库的样本数据集探索流行的python标准库。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6407e1766c725b53e6628575ccddf04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gehCkzHnxv1ZJRuW"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰西卡·鲁斯切洛在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="kw kx ky"><p id="1626" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">Python以其有用的库和包而闻名，即使没有软件工程背景的人也可以编程。</p></blockquote><p id="993f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如今，Python是人工智能和机器学习领域最受欢迎的编程语言之一。Python以其有用的库和包而闻名，即使没有软件工程背景的人也可以编程。Python有一组用Python语言发布的标准库，如<em class="lb"> DateTime </em>、<em class="lb"> math、</em>或<em class="lb"> random </em>。在本文中，我们的目标是在GitHub的python库中找到10个最有用的标准库。为了实现我们的目标，我们研究了GitHub中不同的python库，并收集了它们常用的库来回答这个问题。为了开始我们的研究，首先，我们收集了GitHub中5个著名的python库去年的提交。然后，我们解析这些存储库中的python源文件，并收集提交中使用的库。最后，我们可视化了这些GitHub repos的提交中使用的10个最流行的python标准库。</p><p id="4d7d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这篇文章结构如下:</p><p id="96cf" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">1.如何收集数据？</p><p id="b4cb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">2.如何解析Python源代码？</p><p id="21df" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">3.GitHub库中最受欢迎的10个python库是什么？</p><p id="a4c3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">4.结论</p><p id="1b53" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">5.参考</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><ol class=""><li id="cbf4" class="mg mh iq lc b ld le lg lh lw mi lx mj ly mk lv ml mm mn mo bi translated"><strong class="lc ir">如何收集数据？</strong></li></ol><p id="00ad" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">有不同的方法可以访问GitHub存储库中的数据，如<em class="lb"> GitHub torrent </em>、<em class="lb"> Git API调用、</em>或<em class="lb"> google big query </em>。但是，在本文中，我们想尝试一个新的非常有用的python包，名为<a class="ae kv" href="https://github.com/ishepard/pydriller" rel="noopener ugc nofollow" target="_blank"> Pydriller </a>，来收集我们需要的数据。Pydriller快速且易于使用。我通过我的博士研究熟悉了这个有趣的包。你可以在这里查看Pydriller <a class="ae kv" href="https://pydriller.readthedocs.io/en/latest/intro.html" rel="noopener ugc nofollow" target="_blank">的文档。从Pydriller开始，首先，我们安装这个包:</a></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e713" class="mu mv iq mq b gy mw mx l my mz">pip install pydriller</span></pre><p id="8c96" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在GitHub中，每次提交可以更改一个或多个源文件。在GitHub等版本控制系统中，每次提交都有一个文件，名为“<em class="lb">diff”</em>。它通过提交特定的提交来存储源文件中应用的更改。在GitHub库的提交中查找库的方法之一是在“<em class="lb">diff”</em>文件中搜索正则表达式。但同样，我们想在这篇文章中尝试一些不同的东西。我们在应用提交之前和之后比较源文件的两个不同版本，然后收集这两个文件在库名上的差异。通过这种方法，我们可以发现这些库在不同的提交中使用的频率。好消息是Pydriller允许我们在提交之前和之后访问源文件的版本。下面是收集数据所需的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Pydriller收集GitHub中5个著名的python库</p></figure><p id="6563" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们在GitHub上收集了去年提交的5大python项目:<a class="ae kv" href="https://github.com/django/django" rel="noopener ugc nofollow" target="_blank"><em class="lb">【Django】</em></a><a class="ae kv" href="https://github.com/pandas-dev/pandas" rel="noopener ugc nofollow" target="_blank"><em class="lb">熊猫</em></a><a class="ae kv" href="https://github.com/numpy/numpy" rel="noopener ugc nofollow" target="_blank"><em class="lb">NumP</em></a><em class="lb">y</em><a class="ae kv" href="https://github.com/home-assistant/core" rel="noopener ugc nofollow" target="_blank"><em class="lb">home assistant</em></a><a class="ae kv" href="https://github.com/donnemartin/system-design-primer" rel="noopener ugc nofollow" target="_blank"><em class="lb">系统-设计-初级</em> </a>。<strong class="lc ir">"<em class="lb">repository mining</em>"</strong>是Pydriller中主要的API调用之一。我们可以用<em class="lb">repository mining</em>:<strong class="lc ir"><em class="lb"/></strong><strong class="lc ir"><em class="lb"/></strong>中的两个参数定义一个时间段来收集不同存储库中的提交。此外，我们考虑提交所有以“<em class="lb">结尾的源文件。py </em>“因为在这些库中有其他编程语言的源文件，但是我们专注于python库。我们收集三个特征:<em class="lb">【commit . hash】</em><em class="lb">source _ code _ before’</em><em class="lb">【source _ code】</em>。Pydriller中的<strong class="lc ir"><em class="lb">commit . hash</em></strong><em class="lb"/>返回提交id，<strong class="lc ir"> source_code_before </strong>是应用提交前源文件的版本，<strong class="lc ir"> source_code </strong>显示提交提交后源文件的内容。这是我们收集的数据的标题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/3c12813adafdffe40fc0e790092d8c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggjEUWtbCrSCy9JYtEqrAg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“图片由作者提供”:tf_source.head()</p></figure><p id="1d53" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">到目前为止，我们收集了开始旅程所需的数据。在下一节中，我们将学习如何在这些源文件中探索库。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="24dd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> 2。如何解析python源代码？</strong></p><p id="b3e0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">从源代码中提取信息的方法之一是将源代码转换成抽象语法树。然后，我们可以遍历树并收集目标节点。但是，重要的一点是，我们只想收集python标准库，而不是存储库中使用的所有包，比如只在存储库中有意义的本地定义的库。Python标准库是用python语言发布的。因此，为了将标准包与其他包分开，我们需要拉取python中所有有效的标准库。然后，我们可以编写一个函数来收集源代码中的库名。我们可以将这一部分分为两步:</p><p id="de4f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">2.1.收集python中所有可用标准库的列表</p><p id="1974" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">2.2.构建一个基于AST收集库名的函数</p><p id="e209" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> 2.1。收集python中所有可用标准库的列表</strong></p><p id="78cf" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在<a class="ae kv" href="https://docs.python.org/3/py-modindex.html" rel="noopener ugc nofollow" target="_blank"> python网站</a>上，有一个python中所有标准库的列表，还有一个小描述。这个页面按照字母名称对所有python标准库进行排序，帮助我们了解python中的所有标准库。我把所有python标准库的列表<a class="ae kv" href="https://github.com/arghavanmo/Py_std_libraries/blob/main/py_st_lib.csv" rel="noopener ugc nofollow" target="_blank">放在这里</a>放在一个<em class="lb">中。csv </em>格式。</p><p id="9c37" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> 2。2.构建一个函数来收集基于AST的库名</strong></p><p id="d53f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在我们有了所有标准python库的列表，我们需要从python GitHub存储库中收集样本数据集中的库名。正如我们提到的，方法之一是遍历AST。在本文中，我们的目标节点是<strong class="lc ir"><em class="lb">【import】</em></strong>和<strong class="lc ir"><em class="lb">【import from】</em></strong>。我们希望有一个函数遍历解析树，找到目标节点，并返回库的名称。下面是一个这样做的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用python代码收集库名的类</p></figure><p id="9741" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了更好地理解这个类是如何工作的，这里有一个简单的代码。这个示例代码只有两行，分别导入两个不同的库。其中一个库是python标准库:<em class="lb"> tokenize </em>另一个是本地库:<em class="lb"> assistant </em>。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2f23" class="mu mv iq mq b gy mw mx l my mz">import tokenize as tz<br/>import assistant as ass</span></pre><p id="e95a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">下面是这个示例代码的解析树的转储。可以发现，我们需要收集的是作为<strong class="lc ir"> <em class="lb">【名称】</em> </strong>自变量的<strong class="lc ir"> <em class="lb">别名</em> </strong>类。此外，我们需要检查库的名称是否在我们从python原始网站收集的所有标准库的列表中。我们拯救了。csv文件在一个名为<strong class="lc ir"><em class="lb">【API _ name】</em></strong>的列表中。如果我们在这个示例代码上应用这个类<em class="lb"> FuncParser，</em>，它将只返回<em class="lb"> "tokenize" </em>，因为另一个库<em class="lb"> assistant </em>在python标准库列表中不可用。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="aec1" class="mu mv iq mq b gy mw mx l my mz">Module(body=[Import(names=[alias(name='tokenize', asname='tz')]), Import(names=[alias(name='assistant', asname='ass')])])</span></pre></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="1c23" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> 3。python库中最流行的10个基于GitHub提交的标准库是什么？</strong></p><p id="1aea" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">到目前为止，我们在GitHub中收集了5个著名的python repo的样本数据集，并构建了一个类来收集python代码中的库名。现在，我们需要将这个函数应用于来自GitHub的样本数据，并找到提交这些存储库时使用的前10个库。正如我们前面所讨论的，我们将提交提交之前源文件的AST与提交提交之后同一源文件的AST进行比较。然后我们收集不同的库节点。首先，我将向您展示如何比较这两个AST的分步示例，最后，我将所有代码一个接一个地放在一起，循环遍历整个数据集，并计算每个库的出现次数。</p><p id="1ee1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">3.1.在  <em class="lb"> </em>提交提交之前，收集库名<strong class="lc ir"> <em class="lb">列表</em></strong></p><p id="b029" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">正如您在第1节中看到的，我们将样本数据集存储在<em class="lb">“TF _ source”中。我选择这个数据集的第一行来解释整个过程。<strong class="lc ir">TF _ source[' Commit _ before '][0]</strong>返回在我们的示例数据集中应用第一次提交之前的代码内容。然后，我们应用<strong class="lc ir"> FuncParser() </strong>来收集这个源文件中的所有库名，并将结果返回到<strong class="lc ir"> file_contents </strong>列表中。我们在之前创建一个名为<strong class="lc ir">tokens _的数据帧，并存储这个列表。</strong></em></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="774a" class="mu mv iq mq b gy mw mx l my mz"><br/> text_before=str(<strong class="mq ir">tf_source[‘Commit_before’][0]</strong>)<br/> <br/> bf_obj = <strong class="mq ir">FuncParser</strong>()<br/> bf_tree = ast.parse(text_before)<br/> <strong class="mq ir">file_contents</strong> = []<br/> bf_obj.visit(bf_tree)<br/> dtobj_before = pd.DataFrame(file_contents, columns=[‘token’])<br/> <strong class="mq ir">tokens_before </strong>=pd.DataFrame(dtobj_before[‘token’].value_counts())</span></pre><p id="128a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">3.2.在 提交提交后，收集库名<strong class="lc ir"> <em class="lb">的列表</em></strong></p><p id="8c79" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们重复与3.1相同的过程。，但这次对源文件的内容提交了commit后，<strong class="lc ir">TF _ source[' Commit _ after '][0]。</strong>同样，我们将结果存储在一个数据帧中，称为，<strong class="lc ir"> tokens_after。</strong></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="57f2" class="mu mv iq mq b gy mw mx l my mz">text_after=str(<strong class="mq ir">tf_source</strong>[‘Commit_after’][0])<br/> <br/><br/> aft_obj = <strong class="mq ir">FuncParser</strong>()<br/> aft_tree = ast.parse(text_after)<br/> <strong class="mq ir">file_contents </strong>= []<br/> aft_obj.visit(aft_tree)<br/> dtobj_after = pd.DataFrame(file_contents, columns=[‘token’])<br/> <strong class="mq ir">tokens_after </strong>=pd.DataFrame(dtobj_after[‘token’].value_counts())</span></pre><p id="ae15" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">3.3.提取两个列表之间的差异</p><p id="b128" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在这一步中，我们从<strong class="lc ir">令牌_after </strong>中减去<strong class="lc ir">令牌_before </strong>中的<strong class="lc ir">令牌_ after</strong>来计算它们的差值。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2ba3" class="mu mv iq mq b gy mw mx l my mz">diff = tokens_after.<strong class="mq ir">subtract</strong>(tokens_before)<br/>diff_token = diff[(diff.select_dtypes(include=[‘number’]) != 0).any(1)]<br/> diff_token=diff_token.fillna(0)<br/> diff_token= diff_token.abs()<br/> <strong class="mq ir">diff_token </strong>= diff_token.reset_index()</span></pre><p id="72dd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">3.4.计算库的数量</p><p id="7c2c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">最后，我们统计每个库在<strong class="lc ir"> diff_token </strong>数据帧中出现的次数。为此，我们创建一个名为<em class="lb"> py_lib </em>的字典，并统计库的出现次数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3563" class="mu mv iq mq b gy mw mx l my mz"><strong class="mq ir">py_lib</strong>={}<br/>j=0 <br/>for j in range(0,len(diff_token)):<br/>        word = diff_token['index'][j].lower()<br/>        if word in py_lib:<br/>            py_lib[word]+=diff_token['token'][j]<br/>        else:<br/>            py_lib[word]=1<br/>        j+=1</span></pre><p id="a549" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了将上述步骤应用到我们在第1节中收集的整个样本数据中，我在步骤的开头添加了一个循环。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">收集整个样本数据集中的库</p></figure><p id="82c6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在我们收集了GitHub中python库提交的所有库及其频率，我们希望在<strong class="lc ir"> <em class="lb"> py_lib </em> </strong>字典中找到前10个库。我们可以用下面的代码收集字典中的前10个值。我们可以看到，基于我们的样本数据集，诸如<em class="lb">‘warnings’，【sys’</em>或<em class="lb">‘datetime’</em>之类的库位于前10名python标准库的列表中。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2030" class="mu mv iq mq b gy mw mx l my mz">from operator import itemgetter</span><span id="cc30" class="mu mv iq mq b gy nd mx l my mz">d=sorted(py_lib.items(), key=itemgetter(1),reverse=True)[:10]</span><span id="a146" class="mu mv iq mq b gy nd mx l my mz">[('warnings', 96.0),<br/> ('sys', 73.0),<br/> ('datetime', 28.0),<br/> ('test', 27.0),<br/> ('os', 22.0),<br/> ('collections', 18.0),<br/> ('io', 16.0),<br/> ('gc', 10.0),<br/> ('functools', 9.0),<br/> ('threading', 7.0)]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/d8b171f50d55a41ba0ac2144a2b608aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vNc0hNHdP0lgG03mw2qtw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“作者图片”:基于GitHub样本数据集的python十大标准库</p></figure><p id="481f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">另外，我们可以绘制python库的单词云图和它们的频率。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1216" class="mu mv iq mq b gy mw mx l my mz">import matplotlib.pyplot as plt<br/>from wordcloud import WordCloud</span><span id="581f" class="mu mv iq mq b gy nd mx l my mz"><br/>wordcloud = WordCloud(background_color='black',max_font_size = 50)<br/>wordcloud.generate_from_frequencies(frequencies=py_lib)<br/>plt.figure(figsize=(8,6))<br/>plt.imshow(wordcloud, interpolation="bilinear")<br/>plt.axis("off")<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/6c5fd24756a364ab8e010ffa73e8ba1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2X3MguHtRqQ3VuA0y3LDyw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“Image by Author”:基于GitHub样本数据集的流行python库的单词云图</p></figure><p id="3487" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> 4。结论</strong></p><p id="54be" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在本文中，我们试图基于一个样本数据集收集10个最流行的python库。该数据集包含GitHub中5个著名python库去年的提交。我们使用Pydriller从GitHub收集数据。我们比较提交提交前后源文件的AST，并收集这些提交中使用的库的列表。然后，我们在word云图中绘制最流行的python库。</p><p id="9373" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">复制这篇文章的所有代码都可以在GitHub的<a class="ae kv" href="https://github.com/arghavanmo/Py_std_libraries" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="a263" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir"> 5。参考文献</strong></p><p id="9b0b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">[1]牟，李，郭刚，张，李，王，田，金，张(2014).用于程序语言处理的树形结构卷积神经网络。<em class="lb"> arXiv预印本arXiv:1409.5718 </em>。</p><p id="892d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">[2] Spadini，d .，Aniche，m .，Bacchelli，a .，2018，10月。Pydriller:用于挖掘软件仓库的Python框架。在<em class="lb">2018年第26届ACM欧洲软件工程会议和软件工程基础研讨会会议录</em>(第908–911页)。</p><p id="0c3f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">[3]d .舒勒和t .齐默尔曼(2008年5月)。从版本档案中挖掘使用经验。在<em class="lb">2008年矿业软件库国际工作会议论文集</em>(第121-124页)。</p><p id="eceb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><a class="ae kv" href="https://github.com/ishepard/pydriller" rel="noopener ugc nofollow" target="_blank">https://github.com/ishepard/pydriller</a></p><p id="8606" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><a class="ae kv" href="https://docs.python.org/3/py-modindex.html#cap-p" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/py-modindex.html#cap-p</a></p></div></div>    
</body>
</html>