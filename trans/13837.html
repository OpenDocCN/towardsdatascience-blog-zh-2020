<html>
<head>
<title>Writing advanced SQL queries in pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用pandas编写高级SQL查询</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-advanced-sql-queries-in-pandas-1dc494a17afe?source=collection_archive---------10-----------------------#2020-09-23">https://towardsdatascience.com/writing-advanced-sql-queries-in-pandas-1dc494a17afe?source=collection_archive---------10-----------------------#2020-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="12b5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用您的SQL数据操作技能来学习熊猫</h2></div><p id="bdbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">能够熟练地使用SQL和pandas(Python中的一个数据分析库)操作数据，对于数据分析师、数据科学家和任何处理数据的人来说都是一项很有价值的技能。在本帖中，我们将看看精选的一些高级SQL查询及其在pandas中的对应项。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/a295c66c6cf40c5e60666fa2f5630e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v7b8eDDEzeMGDwDi"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">照片由<a class="ae lu" href="https://unsplash.com/@fabioha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比奥</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e1f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你还是熊猫新手，你可能想看看<a class="ae lu" href="https://pandas.pydata.org/docs/user_guide/10min.html" rel="noopener ugc nofollow" target="_blank"> 10分钟见熊猫</a>或<a class="ae lu" rel="noopener" target="_blank" href="/writing-5-common-sql-queries-in-pandas-90b52f17ad76">我之前的帖子</a>，在那里我讨论了基本查询和它们在熊猫中的对等物的并排比较。这篇文章假设读者熟悉SQL查询。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e18d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">0.资料组📦</h1><p id="0a0f" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们将创建一个小数据集来使用。假设我们有两个假想的人在过去两年的旅行数据:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="e47c" class="ne md it na b gy nf ng l nh ni">df = pd.DataFrame({'name': ['Ann', 'Ann', 'Ann', 'Bob', 'Bob'], <br/>                   'destination': ['Japan', 'Korea', 'Switzerland', <br/>                                   'USA', 'Switzerland'], <br/>                   'dep_date': ['2019-02-02', '2019-01-01', <br/>                                '2020-01-11', '2019-05-05', <br/>                                '2020-01-11'], <br/>                   'duration': [7, 21, 14, 10, 14]})<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/254dd108666f72f6b8d6fa66e268c4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*szeZ5Q1HGs1zwzL_IB4Gpg.png"/></div></figure><p id="d03f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将<em class="nk"> dep_date </em>定义为前往目的地的出发日期，并假设<em class="nk"> duration </em>以天数表示行程长度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7495" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.比较🔎</h1><h2 id="8496" class="ne md it bd me nl nm dn mi nn no dp mm kr np nq mo kv nr ns mq kz nt nu ms nv bi translated">📍 1.1.换档:超前()和滞后()</h2><p id="9d5a" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们先从基本版的<code class="fe nw nx ny na b">LEAD() </code>和<code class="fe nw nx ny na b">LAG()</code>说起。对于每一次行程，我们来拉下一次行程的出发日期:<em class="nk"> lead1 </em>，第二次下一次行程:<em class="nk"> lead2 </em>，上一次行程:<em class="nk"> lag1 </em>，第三次上一次行程:<em class="nk"> lag3 </em> <strong class="kk iu">。</strong></p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="c248" class="ne md it na b gy nf ng l nh ni">SELECT name<br/>       , destination<br/>       , dep_date<br/>       , duration<br/>       , LEAD(dep_date) OVER(ORDER BY dep_date, name) AS lead1<br/>       , LEAD(dep_date, 2) OVER(ORDER BY dep_date, name) AS lead2<br/>       , LAG(dep_date) OVER(ORDER BY dep_date, name) AS lag1<br/>       , LAG(dep_date, 3) OVER(ORDER BY dep_date, name) AS lag3<br/>FROM df</span></pre><p id="0a0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在熊猫身上得到同样的产量，我们使用<code class="fe nw nx ny na b">shift()</code>:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="44a7" class="ne md it na b gy nf ng l nh ni">df.sort_values(['dep_date', 'name'], inplace=True)<br/>df.assign(lead1 = df['dep_date'].shift(-1),<br/>          lead2 = df['dep_date'].shift(-2),<br/>          lag1 = df['dep_date'].shift(),<br/>          lag3 = df['dep_date'].shift(3))</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nz"><img src="../Images/88df2c2a7881d6356321129f2e232cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2OwyCoa1W2dc4REQyPaEWw.png"/></div></div></figure><p id="88aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一行中，我们用<code class="fe nw nx ny na b">sort_values()</code>对数据进行了排序，因为我们对所有的移位操作使用了相同的逻辑。这样做比我们每次创建新列时都要对数据进行排序更有效，如下所示:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="2d6d" class="ne md it na b gy nf ng l nh ni">df.assign(lead1 = df.sort_values(['dep_date', 'name'])['dep_date']<br/>                    .shift(-1),<br/>          lead2 = df.sort_values(['dep_date', 'name'])['dep_date']<br/>                    .shift(-2),<br/>          lag1 = df.sort_values(['dep_date', 'name'])['dep_date']<br/>                   .shift(),<br/>          lag3 = df.sort_values(['dep_date', 'name'])['dep_date']<br/>                   .shift(3))</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oa"><img src="../Images/79d18714bb4d57195c2c56699e7c662f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGbSRHrAbnS6qokTvWkB-g.png"/></div></div></figure><p id="1f9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种低效方法的输出将包含正确的值，但是行的顺序将与原始数据相同，并且不会被排序。</p><p id="d977" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看剩下的4行代码。在熊猫中，我们可以用<code class="fe nw nx ny na b">assign()</code>创建多个栏目。但是，新的列还没有添加到DataFrame中。如果我们想添加新的列到<code class="fe nw nx ny na b">df</code>，我们需要这样分配:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="72eb" class="ne md it na b gy nf ng l nh ni">df.sort_values(['dep_date', 'name'], inplace=True)<br/>df = df.assign(lead1 = df['dep_date'].shift(-1),<br/>               lead2 = df['dep_date'].shift(-2),<br/>               lag1 = df['dep_date'].shift(),<br/>               lag3 = df['dep_date'].shift(3))</span></pre><p id="c945" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在最后一节看另一个带有<code class="fe nw nx ny na b">PARTITION BY()</code>的<code class="fe nw nx ny na b">LEAD()</code>的例子。现在，让我们看看如何操作日期/日期时间列。</p><h2 id="363d" class="ne md it bd me nl nm dn mi nn no dp mm kr np nq mo kv nr ns mq kz nt nu ms nv bi translated">📍 1.2.Date/datetime: DATENAME()，DATEDIFF()，DATEADD()</h2><p id="6140" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在本节中，我们将从出发日期开始提取一周的日名称:<em class="nk">日</em>，从出发日期开始的月份名称:<em class="nk">月</em>，从上一次旅行开始经过的天数:<em class="nk">差</em>和到达日期:<em class="nk"> arr_date </em>。</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="0ac3" class="ne md it na b gy nf ng l nh ni">SELECT name<br/>       , destination<br/>       , dep_date<br/>       , duration<br/>       , DATENAME(WEEKDAY, dep_date) AS day<br/>       , DATENAME(MONTH, dep_date) AS month<br/>       , DATEDIFF(DAY,  <br/>                  LAG(dep_date) OVER(ORDER BY dep_date, name), <br/>                  dep_date) AS diff<br/>       , DATEADD(DAY, day, dep_date) AS arr_date<br/>FROM df</span></pre><p id="1a92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们必须确保列数据类型是正确的:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="bd9a" class="ne md it na b gy nf ng l nh ni"># Convert to proper dtype<br/>df['dep_date'] = pd.to_datetime(df['dep_date'])<br/>df['duration'] = pd.to_timedelta(df['duration'], 'D')</span></pre><p id="7869" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<em class="nk"> dep_date </em>转换为datetime将允许我们使用<code class="fe nw nx ny na b">.dt</code>访问器访问许多日期部分。例如:<code class="fe nw nx ny na b">df[‘dep_date’].dt.year</code>将给出年份(相当于SQL中的<code class="fe nw nx ny na b">DATEPART(YEAR, dep_date)</code>)。</p><p id="c648" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<em class="nk">持续时间</em>转换为timedelta允许我们将其添加到一个日期时间列，以获得另一个日期时间列。</p><p id="0788" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成数据类型转换后，让我们来看一下比较:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="8140" class="ne md it na b gy nf ng l nh ni">df.sort_values(['dep_date', 'name'], inplace=True)<br/>df.assign(day = df['dep_date'].dt.day_name(),<br/>          month = df['dep_date'].dt.month_name(),<br/>          diff = df['dep_date'] - df['dep_date'].shift(),<br/>          arr_date = df['dep_date'] + df['duration'])</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/661f5a31547fa5b0ea679cc399c1198d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*ww2BkjEqYJS1fPxId5aBhQ.png"/></div></figure><p id="3a5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，一旦正确设置了数据类型，操作就变得简单了。值得注意的是，我们可以用DataFrame的<code class="fe nw nx ny na b">dtypes</code>属性检查列的数据类型。这里有一个例子:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="cd95" class="ne md it na b gy nf ng l nh ni">df.sort_values(['dep_date', 'name'], inplace=True)<br/>df.assign(day = df['dep_date'].dt.day_name(),<br/>          month = df['dep_date'].dt.month_name(),<br/>          diff = df['dep_date'] - df['dep_date'].shift(),<br/>          arr_date = df['dep_date'] + df['duration']).dtypes</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3aa239820498603b19a2a6f8a2dc6715.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*Twxf2HST0KfvYMeXc_gttA.png"/></div></figure><p id="6bcf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在pandas中，当发现两个日期之间的差异时，它返回一个timedelta列。因此，我们可以看到列<em class="nk"> diff </em>实际上是一个时间增量。</p><h2 id="8e39" class="ne md it bd me nl nm dn mi nn no dp mm kr np nq mo kv nr ns mq kz nt nu ms nv bi translated">📍 1.3.排名:ROW_NUMBER()，RANK()，DENSE_RANK()</h2><p id="21d8" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">您可能以前在SQL中至少使用过这些函数中的一个。这三者之间的关键区别是他们在排名关系和排名之后的待遇。让我们创建三个列，分别使用以下方法根据<em class="nk">持续时间</em>对每个记录进行排序:<em class="nk"> row_number_d，rank_d </em>和<em class="nk"> dense_rank_d. </em></p><p id="0810" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe nw nx ny na b">ROW_NUMBER()</code>时，领带的等级与其他两种不同。为了控制如何用<code class="fe nw nx ny na b">ROW_NUMBER()</code>处理平局，我们使用<em class="nk">名称</em>来打破平局。</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="ba79" class="ne md it na b gy nf ng l nh ni">SELECT name<br/>       , destination<br/>       , dep_date<br/>       , duration<br/>       , ROW_NUMBER() OVER(ORDER BY duration, name) AS row_number_d<br/>       , RANK() OVER(ORDER BY duration) AS rank_d<br/>       , DENSE_RANK() OVER(ORDER BY duration) AS dense_rank_d<br/>FROM df</span></pre><p id="d031" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">pandas中的查询可以通过<code class="fe nw nx ny na b">rank()</code>实现:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="6b5d" class="ne md it na b gy nf ng l nh ni">df.sort_values(['duration', 'name']).assign(<br/>    row_number_d = df['duration'].rank(method='first').astype(int),<br/>    rank_d = df['duration'].rank(method='min').astype(int),<br/>    dense_rank_d = df['duration'].rank(method='dense').astype(int))</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ef1faabbcf1aebbf42779e02dfadb1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*_8D_E_zeWa3yO8tuF4P7Cw.png"/></div></figure><p id="514f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，我们在<code class="fe nw nx ny na b">rank()</code>中指定了相关的方法。值得注意的是，这里还有我们没有涉及的其他变化。如果你有兴趣了解一下，看看<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rank.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="a090" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在这个例子中做了一些稍微不同的事情。与前两节中的例子不同，我们没有对数据进行适当的排序。相反，我们将方法链接起来，根本没有修改数据。</p><p id="585a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能也注意到了我们已经包括了<code class="fe nw nx ny na b">astype(int)</code>。这是为了将浮点数中的秩转换成整数。如果您喜欢看到浮动，那么可以删除这部分代码:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="0731" class="ne md it na b gy nf ng l nh ni">df.sort_values(['duration', 'name']).assign(<br/>    row_number_d = df['duration'].rank(method='first'),<br/>    rank_d = df['duration'].rank(method='min'),<br/>    dense_rank_d = df['duration'].rank(method='dense'))</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2e97429a39ca88406ef7336025fd7468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*3KRlpyQVZaUVEv3voB1Gyg.png"/></div></figure><h2 id="7ba5" class="ne md it bd me nl nm dn mi nn no dp mm kr np nq mo kv nr ns mq kz nt nu ms nv bi translated">📍 1.4.聚合窗口函数和分区</h2><p id="9cda" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在本节中，我们将为最长的旅行持续时间创建列:<em class="nk"> max_dur </em>，所有旅行的总持续时间:<em class="nk"> sum_dur </em>，每人旅行的平均持续时间:<em class="nk"> avg_dur_name </em>以及每人旅行时间的累计总和:<em class="nk"> cum_sum_dur_name。</em></p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="ad33" class="ne md it na b gy nf ng l nh ni">SELECT name<br/>       , destination<br/>       , dep_date <br/>       , duration<br/>       , MAX(duration) OVER() AS max_dur<br/>       , SUM(duration) OVER() AS sum_dur<br/>       , AVG(duration) OVER(PARTITION BY name) AS avg_dur_name<br/>       , SUM(duration) OVER(PARTITION BY name ORDER BY dep_date<br/>                            RANGE BETWEEN UNBOUNDED PRECEDING<br/>                            AND CURRENT ROW) AS cum_sum_dur_name<br/>FROM df</span></pre><p id="5d07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">熊猫可以这样做:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="acd9" class="ne md it na b gy nf ng l nh ni">df.assign(max_dur=df['duration'].max(),<br/>          sum_dur=df['duration'].sum(),<br/>          avg_dur_name=df.groupby('name')['duration']<br/>                         .transform('mean'),<br/>          cum_sum_dur_name=df.sort_values('dep_date')<br/>                             .groupby('name')['duration']<br/>                             .transform('cumsum'))</span></pre><p id="3930" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<a class="ae lu" href="https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html" rel="noopener ugc nofollow" target="_blank">广播</a>，所以在pandas中添加诸如<em class="nk"> max_dur </em>和<em class="nk"> sum_dur </em>之类的聚合统计数据很简单。本质上，如果我们试图给pandas中的一个新列分配一个标量值，该值将在所有行中传播。<code class="fe nw nx ny na b">PARTITION BY</code>由<code class="fe nw nx ny na b">groupby()</code>和<code class="fe nw nx ny na b">transform()</code>组合实现。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi of"><img src="../Images/cfb71c0a6a0366b9a5f74ff2c895fa57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUtWlUTic_SNZ5HhSJd3Kg.png"/></div></div></figure><p id="46ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此输出中，数据的顺序与之前相同(即未排序)，但它将按照SQL中每个人的<em class="nk"> dep_date </em>排序。我们仅在创建<em class="nk"> cum_sum_dur_name </em>时对数据进行了排序。如果我们希望对输出进行排序，代码将变为:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="d050" class="ne md it na b gy nf ng l nh ni">df.sort_values(['name', 'dep_date'], inplace=True)<br/>df.assign(max_dur=df['duration'].max(),<br/>          sum_dur=df['duration'].sum(),<br/>          avg_dur_name=df.groupby('name')['duration']<br/>                         .transform('mean'),<br/>          cum_sum_dur_name=df.groupby('name')['duration']<br/>                             .transform('cumsum'))</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi og"><img src="../Images/5960c041ff15c29f22d9bef367ce96c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KXfG2k5tXt_vnUW74HIBWQ.png"/></div></div></figure><p id="81bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将与SQL输出相同。</p><h2 id="e1ff" class="ne md it bd me nl nm dn mi nn no dp mm kr np nq mo kv nr ns mq kz nt nu ms nv bi translated">📍 1.5.把它放在一起</h2><p id="122b" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">最后，让我们编写一个查询，覆盖我们刚刚访问过的四个不同区域。这是我们的最后一个例子:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="3502" class="ne md it na b gy nf ng l nh ni">SELECT ROW_NUMBER() OVER(PARTITION BY name <br/>                         ORDER BY dep_date) AS number<br/>       , name<br/>       , destination<br/>       , DATENAME(MONTH, dep_date) AS dep_month<br/>       , dep_date<br/>       , DATEADD(DAY, duration, dep_date) AS arr_date<br/>       , LEAD(dep_date) OVER(PARTITION BY NAME <br/>                             ORDER BY dep_date) AS next_dep_date<br/>       , DATEDIFF(DAY, <br/>                  dep_date, <br/>                  LEAD(dep_date) OVER(PARTITION BY NAME <br/>                                      ORDER BY dep_date)) AS gap<br/>       , duration<br/>       , AVG(1.0 * duration) OVER() AS avg_dur<br/>       , AVG(1.0 * duration) OVER(PARTITION BY name) AS avg_dur_name<br/>       , SUM(duration) OVER(PARTITION BY name ORDER BY dep_date<br/>                            RANGE BETWEEN UNBOUNDED PRECEDING <br/>                            AND CURRENT ROW) AS cum_sum_dur_name   <br/>FROM df<br/>ORDER BY name, dep_date</span></pre><p id="2972" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我相信当我们练习自己的时候，我们会学到更多。我鼓励您在看到我们将要看到的比较之前，自己尝试将这个SQL查询翻译成pandas。👀</p><p id="5c74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是对比:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="415f" class="ne md it na b gy nf ng l nh ni"># Convert to proper type<br/>df['dep_date'] = pd.to_datetime(df['dep_date'])<br/>df['duration'] = pd.to_timedelta(df['duration'], 'D')</span><span id="0784" class="ne md it na b gy oh ng l nh ni"># Sort data<br/>df.sort_values(['name', 'dep_date'], inplace=True)</span><span id="d02b" class="ne md it na b gy oh ng l nh ni"># Append new columns to data<br/>df = df.assign(number=df.groupby('name')['dep_date']<br/>                        .rank('min')<br/>                        .astype(int),<br/>               dep_month = df['dep_date'].dt.month_name(),<br/>               arr_date = df['dep_date'] + df['duration'],<br/>               next_dep_date = df.groupby('name')['dep_date']<br/>                                 .transform(lambda x: x.shift(-1)),<br/>               gap = df.groupby('name')['dep_date']<br/>                       .transform(lambda x: x.shift(-1))-<br/>                                            df['dep_date'],<br/>               avg_dur = df['duration'].mean(),<br/>               avg_dur_name = df.groupby('name')['duration']<br/>                                .transform(lambda x: x.mean()),<br/>               cum_sum_dur_name = df.groupby('name')['duration']<br/>                                   .transform(lambda x: x.cumsum()))</span><span id="df1b" class="ne md it na b gy oh ng l nh ni"># Reorder columns<br/>columns = ['number', 'name', 'destination', 'dep_month', <br/>           'dep_date', 'arr_date', 'next_dep_date', <br/>           'gap', 'duration', 'avg_dur', 'avg_dur_name', <br/>           'cum_sum_dur_name']<br/>df[columns]</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9c6a6eed9b5b0077ae9a56c8de12377b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*cLyBld0mYpi7XYNNSHBrCg.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">输出—第1部分</p></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/3c275d1a9c2c54f06b318d5429e88f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*Vm-ghYhZGQ1bBRMfQjtT7w.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">输出—第二部分</p></figure><p id="bdd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经转换了数据类型，对数据进行了分类，并用新列对其进行了修改。为了以与SQL查询相同的方式查看列排序的数据，我们使用了一个列出列顺序的列表。如果只运行<code class="fe nw nx ny na b">df</code>，列的排序会有所不同。</p><p id="d38a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能已经注意到<em class="nk"> avg_dur </em>是用天数、小时数和分钟数的组合来表示的:“13天04:48:00”。这相当于13 + (4*60+48) / (24*60) = 13.2天。如果我们只想看到13.2，那么我们可以用这个代码片段替换<code class="fe nw nx ny na b">df[‘duration’].mean()</code>，它在找到平均值之前将<em class="nk">持续时间</em>转换为数字类型:<code class="fe nw nx ny na b">pd.to_numeric(df[‘duration’].dt.days).mean()</code>。</p><p id="5aec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当创建<em class="nk"> avg_dur_name </em>和<em class="nk"> cum_sum_dur_name </em>时，我们使用了<code class="fe nw nx ny na b">lambda</code>函数，而不是使用这样的语法:</p><pre class="lf lg lh li gt mz na nb nc aw nd bi"><span id="bdd3" class="ne md it na b gy nf ng l nh ni">avg_dur_name = df.groupby('name')['duration'].transform('mean'),<br/>cum_sum_dur_name = df.groupby('name')['duration']<br/>                     .transform('cumsum')</span></pre><p id="eae7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为如果我们试图这样做，我们将会遇到一个在这里描述的问题<a class="ae lu" href="https://github.com/pandas-dev/pandas/issues/17382" rel="noopener ugc nofollow" target="_blank"/>。因此，我们使用了一种变通办法。</p><p id="8962" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Voila❕这番话结束了我们的比较。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ok"><img src="../Images/28e8f5ef1979dacb0b09838eb1fa9bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KhNlqXI1tviS29uE"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lu" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="3527" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nk">您想访问更多这样的内容吗？媒体会员可以无限制地访问媒体上的任何文章。如果你使用</em> <a class="ae lu" href="https://zluvsand.medium.com/membership" rel="noopener"> <em class="nk">我的推荐链接</em></a><em class="nk">成为会员，你的一部分会费会直接去支持我。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f8d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你看我的帖子。希望这篇文章对你有用，✂️，并了解更多关于熊猫的知识。如果你有兴趣了解更多关于熊猫的信息，这里有我的一些帖子的链接:</p><p id="5658" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">◼️️<a class="ae lu" rel="noopener" target="_blank" href="/writing-5-common-sql-queries-in-pandas-90b52f17ad76">pandas中数据聚合的5个技巧</a> <br/> ◼️️ <a class="ae lu" rel="noopener" target="_blank" href="/writing-5-common-sql-queries-in-pandas-90b52f17ad76">在pandas中编写5个常见的SQL查询</a> <br/> ◼️️ <a class="ae lu" rel="noopener" target="_blank" href="/5-tips-for-pandas-users-e73681d16d17">给pandas用户的5个技巧</a> <br/> ◼️️ <a class="ae lu" rel="noopener" target="_blank" href="/transforming-variables-in-a-pandas-dataframe-bce2c6ef91a1">如何转换pandas数据框架中的变量</a></p><p id="c31a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再见🏃💨</p></div></div>    
</body>
</html>