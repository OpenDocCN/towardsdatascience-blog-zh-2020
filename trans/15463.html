<html>
<head>
<title>How to build a Dask distributed cluster for AutoML pipeline search with TPOT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TPOT构建Dask分布式集群进行自动管道搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-dask-distributed-cluster-for-automl-pipeline-search-with-tpot-34ab6cf6bf65?source=collection_archive---------18-----------------------#2020-10-24">https://towardsdatascience.com/how-to-build-a-dask-distributed-cluster-for-automl-pipeline-search-with-tpot-34ab6cf6bf65?source=collection_archive---------18-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3e2a" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="cf6b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">这是一个深入的教程，指导您通过开源python库(即Dask和TPOT)建立可扩展的自动化机器学习模型管道搜索所需的所有步骤。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/063877875e7bf3ba0dc6dc6f88010c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yUdKIcgVlRefEY_F"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@fabioha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比奥</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="72bd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您是否曾经遇到过这样的情况:您知道自己已经尽了最大努力清理数据集，但却无法选择最佳模型？你有很多CPU，但是它们在不同的主机上吗？那么这就是给你的指南！我们将探索<a class="ae le" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>，特别是Dask的分布式<a class="ae le" href="https://distributed.dask.org/en/latest/" rel="noopener ugc nofollow" target="_blank">库</a>，不仅并行化我们的TPOT管道搜索，而且将它们分布在不同的机器上。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="6070" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">Dask是什么？</h1><p id="fcd7" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated"><a class="ae le" href="https://github.com/dask/dask-tutorial" rel="noopener ugc nofollow" target="_blank"> Dask </a>是一个开源并行计算库，可以扩展现有的Python生态系统。它与通用数据科学堆栈集成良好；<a class="ae le" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>、<a class="ae le" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>和<a class="ae le" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>。有了Dask，我们可以从笔记本电脑到整个集群进行大规模计算。我们将关注后者。</p><h1 id="5037" class="mi mj iq bd mk ml nf mn mo mp ng mr ms kf nh kg mu ki ni kj mw kl nj km my mz bi translated">Dask分布式是什么？</h1><p id="db39" class="pw-post-body-paragraph lf lg iq lh b li na ka lk ll nb kd ln lo nc lq lr ls nd lu lv lw ne ly lz ma ij bi translated"><strong class="lh ja"> Dask.distributed </strong>:是一个轻量级的开源Python分布式计算库。</p><p id="c4cc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">架构: Dask.distributed是一个集中管理的、分布式的、动态的任务调度器。它有三个主要过程:</p><ol class=""><li id="a8a5" class="nk nl iq lh b li lj ll lm lo nm ls nn lw no ma np nq nr ns bi translated"><strong class="lh ja">dask-scheduler:<em class="nt"/></strong>中央dask-scheduler进程协调分布在多台机器上的多个dask-worker进程的动作以及多个客户端的并发请求。</li><li id="8ce7" class="nk nl iq lh b li nu ll nv lo nw ls nx lw ny ma np nq nr ns bi translated"><strong class="lh ja">dask-worker:</strong><em class="nt"/>dask-worker分布在多台机器上，处理多个客户端的并发请求。</li><li id="d3c0" class="nk nl iq lh b li nu ll nv lo nw ls nx lw ny ma np nq nr ns bi translated"><strong class="lh ja">dask-client:</strong>dask-client是dask.distributed用户的主要入口点</li></ol></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="c191" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">设置调度程序和工人的步骤:</strong></p><p id="065e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在本例中，我们将使用<a class="ae le" href="https://www.vmware.com/products/esxi-and-esx.html" rel="noopener ugc nofollow" target="_blank"> VMware ESXi </a>在一台主机上创建3台虚拟机。一个是调度程序，同时运行<a class="ae le" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> jupyter笔记本</a>，另外两个是工人。这只是一个概念验证设置。不可否认，这不是启动集群工作者的最有效的方法。尽管如此，这将提出一个更通用的流程，然后可以采用云解决方案和/或<a class="ae le" href="https://kubernetes.dask.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Dask Kubernetes </a>。</p><p id="1d80" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将从调度程序实例开始。首先点击<strong class="lh ja">创建/注册虚拟机&gt;创建新的虚拟机&gt;然后</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/007dc42b111e7d6697272fe08f1320d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mBY1nUFyVxOYC11Puf3fA.png"/></div></div></figure><p id="7677" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您可以选择任何名称，但我建议指定一个容易识别的名称，如cluster-master。对于这个例子，我在所有机器上都使用了Ubuntu 20.04.1 live server 。这不是强制性的，但强烈建议<em class="nt">在所有机器中使用相同的分布。这些机器将用于对大型数据集进行计算。因此，<em class="nt">强烈建议</em>为每台机器分配大量RAM，如果不可能，至少<a class="ae le" href="https://linuxize.com/post/how-to-add-swap-space-on-ubuntu-18-04/" rel="noopener ugc nofollow" target="_blank">设置交换内存</a>。对于本例，我们将在每台机器上使用24 Gb的RAM和8个vCPUs。</em></p><blockquote class="oa ob oc"><p id="6b30" class="lf lg nt lh b li lj ka lk ll lm kd ln od lp lq lr oe lt lu lv of lx ly lz ma ij bi translated">在本教程中，我们将使用熊猫数据帧。对于特别大的数据集，我们可以使用Dask的<a class="ae le" href="https://docs.dask.org/en/latest/dataframe.html#dataframe" rel="noopener ugc nofollow" target="_blank">数据框架</a>对象。达斯克。数据帧是一个大型并行数据帧，由许多较小的数据帧组成，沿着索引分割。这些Pandas数据帧可能存在于磁盘上，用于单台机器或集群中许多不同机器上的大内存计算。</p></blockquote><p id="dd9f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是我们虚拟机规格的快照。你可以根据你的需要改变这些。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/f13deac7e878eec82f51f9cffb681ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLeQ-3Zw3TWstu_WPSH9rg.png"/></div></div></figure><p id="508d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对工作机器重复该过程。我们选择相同的规格，但这不是强制性的。在每台机器上安装操作系统后，我们将通过SSH安装必要的软件。对于这样的小集群，我们选择<a class="ae le" href="https://github.com/duncs/clusterssh" rel="noopener ugc nofollow" target="_blank"> ClusterSSH </a>。ClusterSSH是围绕XTerm和SSH等标准Linux工具的Tk/Perl包装器。我们将使用它同时向所有机器复制命令。事不宜迟，言归正传。</p><p id="e462" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">运行以下命令在本地机器上安装ClusterSSH。在本教程中，我们将通过SSH从我们的个人计算机管理集群。我们将不配置集群。我们将通过在CLI中传递用户名和IP地址来连接到机器。对于更大或多个集群，建议编辑位于<code class="fe oh oi oj ok b">~/.csshrc</code>的配置文件。</p><pre class="kp kq kr ks gt ol ok om on aw oo bi"><span id="fe19" class="op mj iq ok b gy oq or l os ot">sudo apt-get install clusterssh<br/>clusterssh cluster-master-name@cluster-master-ip cluster-worker1-name@cluster-worker1-ip cluster-worker2-name@cluster-worker2-ip</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/95a448749db0fd169f47b47cd638467b.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*GNt_Xa0h-22cpmUTDTN_Fg.png"/></div></figure><p id="8812" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上图中，您在CLUSTERSSH灰色窗口中键入的任何内容都将被复制到所有机器上。您也可以在每个窗口上分别键入单独的shell命令。我们希望将以下命令复制到所有计算机上:</p><pre class="kp kq kr ks gt ol ok om on aw oo bi"><span id="c842" class="op mj iq ok b gy oq or l os ot">sudo apt-get update<br/>sudo apt-get upgrade -y<br/>wget <a class="ae le" href="https://repo.anaconda.com/archive/Anaconda3-2020.07-Linux-x86_64.sh" rel="noopener ugc nofollow" target="_blank">https://repo.anaconda.com/archive/Anaconda3-2020.07-Linux-x86_64.sh</a><br/>chmod 755 Anaconda3-2020.07-Linux-x86_64.sh<br/>bash Anaconda3-2020.07-Linux-x86_64.sh<br/>conda init</span></pre><p id="d383" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后我们必须重启shell，这非常简单，我们可以通过ClusterSSH断开连接并重新连接。如果您将<a class="ae le" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank"> Anaconda3 </a>安装到不同的位置，只需导出路径并运行<code class="fe oh oi oj ok b">./anaconda3/condabin/conda init</code>。重新连接后，运行以下命令来安装<a class="ae le" href="https://github.com/EpistasisLab/tpot" rel="noopener ugc nofollow" target="_blank"> TPOT </a>和Dask的必要先决条件。请注意，除了<a class="ae le" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>之外，我们还为TPOT的额外功能安装了所有可选的依赖项。</p><pre class="kp kq kr ks gt ol ok om on aw oo bi"><span id="6c8b" class="op mj iq ok b gy oq or l os ot">conda install -c conda-forge tpot xgboost dask distributed dask-ml scikit-mdr skrebate -y<br/>conda update conda<br/>conda update --all</span></pre></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="81f7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">建立分布式集群的步骤:</strong></p><p id="6d29" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，我们需要设置调度程序，这样我们可以稍后连接其余的机器。尽管所有这些机器都驻留在同一个主机中，但为了涵盖一般情况，我们不会通过LAN连接它们。我们开始吧！我们将使用一个名为<a class="ae le" href="https://linux.die.net/man/1/screen" rel="noopener ugc nofollow" target="_blank"> screen </a>的终端复用器来管理一个ssh会话中的多个shells。这里有一个你需要的选项的快速备忘单:</p><pre class="kp kq kr ks gt ol ok om on aw oo bi"><span id="ab01" class="op mj iq ok b gy oq or l os ot">screen -S session_name #Starts a new screen named session_name<br/>screen -r #Resumes a screen session<br/>screen -ls #Returns the session IDs of running screens<br/>screen -X -S &lt;id or name&gt; kill #Kills the specified screen<br/>While inside an attached screen: Ctrl+a d #Detaches the current screen</span></pre><p id="37e0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">太好了！现在我们准备在屏幕中设置调度程序！单击主/调度程序虚拟机实例SSH窗口，并键入以下内容:</p><pre class="kp kq kr ks gt ol ok om on aw oo bi"><span id="9868" class="op mj iq ok b gy oq or l os ot">screen -S scheduler</span><span id="046f" class="op mj iq ok b gy ov or l os ot">dask-scheduler</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/36e394f3f1cbb82bf6fe788cb5c210b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*5MYLTibVVNpbhtlbXFU-yQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">您应该会看到这个输出！</p></figure><p id="4e7a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，调度程序的IP地址会有所不同。调度程序本身位于<code class="fe oh oi oj ok b">8786</code>港口，这是我们将所有工人指向的地方。<code class="fe oh oi oj ok b">8787</code>端口托管dask <a class="ae le" href="https://docs.dask.org/en/latest/diagnostics-distributed.html" rel="noopener ugc nofollow" target="_blank">仪表板</a>。在我们连接所有的工人之后，我们将稍后回到这一点。现在，按下<code class="fe oh oi oj ok b">Ctrl+a d</code>分离屏幕。现在让我们设置我们的jupyter笔记本:</p><pre class="kp kq kr ks gt ol ok om on aw oo bi"><span id="ee0e" class="op mj iq ok b gy oq or l os ot">screen -S notebook</span><span id="b9f0" class="op mj iq ok b gy ov or l os ot">jupyter notebook --no-browser --port=8888</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9f16ceb8a3a9b054c4328d21c8e43831.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*ot6P2dcRW1TMTmNT809n0w.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">保存令牌！你以后会需要它的。</p></figure><p id="8390" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">保存令牌，分离屏幕并关闭SSH连接。不要关闭到其他机器的SSH连接。我们现在必须将主虚拟机实例中远程笔记本的端口转发到本地端口，以便我们可以从浏览器访问它。我们可以使用以下命令来实现这一点:</p><pre class="kp kq kr ks gt ol ok om on aw oo bi"><span id="a170" class="op mj iq ok b gy oq or l os ot">ssh <strong class="ok ja">-</strong>N <strong class="ok ja">-</strong>f <strong class="ok ja">-</strong>L localhost<strong class="ok ja">:</strong>8003<strong class="ok ja">:</strong>localhost<strong class="ok ja">:</strong>8888 remoteuser<strong class="ok ja">@</strong>remotehost</span><span id="1608" class="op mj iq ok b gy ov or l os ot">#Forwards the port 8888 of our remote machine to port 8003 of our local machine. We can now access it in our browser at localhost:8003</span></pre><p id="6f85" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在指定的端口(我们选择8003)上转到您的本地主机，输入您保存的令牌，瞧！笔记本在远程机器上运行，而我们在本地机器上编辑它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/311794609d231d56f63152af20cfdb62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItjE7qZdeeODOP0UUmTUbw.png"/></div></div></figure><p id="2bec" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，我们可以继续设置所有工作线程来指向调度程序。这很简单。我们通过灰色的ClusterSSH终端创建一个屏幕，这次是在所有的workers中，并将它们指向主VM实例中的调度程序。</p><pre class="kp kq kr ks gt ol ok om on aw oo bi"><span id="537b" class="op mj iq ok b gy oq or l os ot">screen -S worker</span><span id="5d4d" class="op mj iq ok b gy ov or l os ot">dask-worker IP-of-the-scheduler:8786 --nprocs 1 --nthreads 8</span></pre><p id="e59b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">拆下屏幕，一切就绪。客户端已连接，调度程序已启动并正在运行，您还有一个仪表板来检查一切！使用nprocs和nthreads参数分别选择每个工作线程的进程数和线程数。这个选择取决于工作量。Dask的主要撰稿人Matthew Rocklin建议如下:</p><blockquote class="oa ob oc"><p id="cc83" class="lf lg nt lh b li lj ka lk ll lm kd ln od lp lq lr oe lt lu lv of lx ly lz ma ij bi translated">如果您主要处理数字工作负载，比如Numpy、Pandas和Scikit-Learn代码中常见的，每个进程使用几个进程和多个线程是很好的，这不受Python的<a class="ae le" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a> (GIL)的影响。但是，如果您将大部分计算时间花在处理纯Python对象(如字符串或字典)上，那么您可能希望通过用更少的线程处理更多的进程来避免GIL问题。使用更多的进程避免了GIL问题，但是由于进程间的通信而增加了成本。如果您的计算需要大量的内部通信，您可能希望避免许多进程。来源:MRocklin - <a class="ae le" href="https://stackoverflow.com/questions/49406987/how-do-we-choose-nthreads-and-nprocs-per-worker-in-dask-distributed/49407253" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a></p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="2c10" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">什么是TPOT？</strong></p><p id="cf54" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="http://epistasislab.github.io/tpot/" rel="noopener ugc nofollow" target="_blank"> TPOT </a>是一个Python自动机器学习(AutoML)工具，它使用遗传编程来优化机器学习管道。TPOT构建在scikit-learn库之上，就像Dask一样，它使用现有的Python APIs和数据结构。这意味着对于scikit-learn用户来说，它的用法应该非常直观。它还可以很好地与Dask集成！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/14e06224c336d01064a8433ea609f9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yc5A3nvnQjC8k7HGdsXFxg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd pa">机器学习管道示例</strong> —来源:<a class="ae le" href="http://epistasislab.github.io/tpot/" rel="noopener ugc nofollow" target="_blank">文档</a></p></figure><p id="b7d3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">TPOT快速概览:</strong></p><p id="83d0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">TPOT使用进化算法来寻找最佳管道。但是<em class="nt">什么是管道</em>？在机器学习项目中，你很少有理想的数据格式来创建一个性能模型。您可以执行多种转换，如<a class="ae le" href="https://en.wikipedia.org/wiki/Imputation_(statistics)" rel="noopener ugc nofollow" target="_blank">输入</a>，特征缩放和标准化或分类变量编码——其本身有多种实施方式，即一键编码或目标编码。然后你可以通过装袋、助推或堆叠模型来创造一个整体。最终的模型将使用上述部分或全部的组合。这叫做管道。TPOT尝试了各种管道，让它们“随机变异”，就像活的有机体一样(或者病毒和染色体外DNA，如果你想卖弄学问的话)，直到它找到一个性能更好的管道。你可以在这里阅读完整的TPOT论文。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/0e9e0cf4bd7fa4a33fa67d1d37964e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dcB9BH46DG4vkp_9NsNGw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd pa">TPOT管道</strong>的一个例子——来源:<a class="ae le" href="http://epistasislab.github.io/tpot/" rel="noopener ugc nofollow" target="_blank">文档</a></p></figure><p id="9cc5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，让我们使用我们的集群来寻找数据集的最佳管道。下面的笔记本大部分摘自文档，有一些细微的改动。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="6813" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当TPOT运行时，你可以在调度器的<code class="fe oh oi oj ok b">localhost:8787</code>查看仪表盘。如果您不在远程调度器中，您可以在本地机器的<code class="fe oh oi oj ok b">IP-of-scheduler:8787</code>处检查它。仪表板提供了对每一代进程的洞察、对工作人员和整个集群的基本系统监控、每个工作人员的日志和调用堆栈，以及一个非常，<em class="nt">非常</em>酷的图表。以下是dask仪表板运行时的外观:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/22bbc92ad763fa9964a26e1c72c8035c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sobtd-tTPwj0ZONUNWWb1A.png"/></div></div></figure><p id="8596" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，我想提一下，Dask的主要贡献者成立了一家名为<a class="ae le" href="https://coiled.io/" rel="noopener ugc nofollow" target="_blank"> coiled </a>的公司，为托管Dask集群和python扩展提供云和企业解决方案。他们目前处于测试阶段，并在云中提供多达100个免费CPU来演示他们的平台。</p></div></div>    
</body>
</html>