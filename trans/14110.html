<html>
<head>
<title>Pipeline, ColumnTransformer and FeatureUnion explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了管道、列转换器和功能联合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pipeline-columntransformer-and-featureunion-explained-f5491f815f?source=collection_archive---------2-----------------------#2020-09-29">https://towardsdatascience.com/pipeline-columntransformer-and-featureunion-explained-f5491f815f?source=collection_archive---------2-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">他们做什么，何时使用</h2></div><p id="8ddf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这三个强大的工具，对于任何想掌握使用<a class="ae le" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> sklearn </em> </a>的人来说，都是必须知道的。因此，在建立机器学习模型时，学会如何有效地使用这些方法至关重要。</p><p id="660a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始之前，让我们首先在两个术语上达成一致:</p><ul class=""><li id="940d" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld ll lm ln lo bi translated"><strong class="kk iu"> Transformer: </strong> <a class="ae le" href="https://scikit-learn.org/stable/data_transforms.html" rel="noopener ugc nofollow" target="_blank"> <em class="lf">一个transformer </em>是指用</a> <code class="fe lp lq lr ls b"><a class="ae le" href="https://scikit-learn.org/stable/data_transforms.html" rel="noopener ugc nofollow" target="_blank">fit</a>()</code> <a class="ae le" href="https://scikit-learn.org/stable/data_transforms.html" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe lp lq lr ls b"><a class="ae le" href="https://scikit-learn.org/stable/data_transforms.html" rel="noopener ugc nofollow" target="_blank">transform</a>()</code> <a class="ae le" href="https://scikit-learn.org/stable/data_transforms.html" rel="noopener ugc nofollow" target="_blank">方法清理、缩小、扩展或生成特征</a>的对象。简而言之，转换器可以帮助您将数据转换为机器学习模型所需的格式。<code class="fe lp lq lr ls b">OneHotEncoder</code>和<code class="fe lp lq lr ls b">MinMaxScaler</code>就是变形金刚的例子。</li><li id="cadc" class="lg lh it kk b kl lt ko lu kr lv kv lw kz lx ld ll lm ln lo bi translated"><strong class="kk iu">估计器:</strong> <em class="lf">一个</em> <em class="lf">估计器</em>是指一个机器学习模型<em class="lf">。</em>是用<code class="fe lp lq lr ls b">fit()</code>和<code class="fe lp lq lr ls b">predict()</code>方法的对象。在这篇文章中，我们将交替使用评估者和模型。这里有一些估计量的例子。</li></ul><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/6254ebe744d8356f07b2f90e14619d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qribT0HiAXF8wuEw"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">马丁·桑切斯在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="582b" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">0.设置</h1><p id="3631" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">如果你想在你的电脑上跟着代码走，确保你已经安装了pandas，seaborn和sklearn。我已经在Jupyter Notebook中使用并测试了Python 3.7.1中的脚本。</p><p id="6271" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们导入所需的包和餐馆小费的数据集。关于这个数据集的细节，包括数据字典，可以在这里找到<a class="ae le" href="https://vincentarelbundock.github.io/Rdatasets/doc/reshape2/tips.html" rel="noopener ugc nofollow" target="_blank">(这个源实际上是针对R的，但它似乎指的是同一个底层数据集)。</a></p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nu"><img src="../Images/a51d8f43e10cf0690e33e17bd59fdc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*ZkouUy5kqTGOKP5WeEOo_Q.png"/></div></div></figure><p id="8493" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用少量的记录可以很容易地监控每一步的输入和输出。因此，我们将只使用数据集中的5条记录作为样本。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="13e5" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">1.管道</h1><p id="1f85" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">假设我们想要使用<em class="lf">吸烟者</em>、<em class="lf">日</em>和<em class="lf">时间</em>列来预测<em class="lf">总账单。</em>我们将删除<em class="lf"> size </em>列，并首先对数据进行分区:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7daf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，原始数据不处于我们可以直接将其输入机器学习模型的状态。因此，将数据转换为模型可接受且有用的状态成为建模的必要前提。让我们做以下转换作为准备:</p><ol class=""><li id="b021" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld nv lm ln lo bi translated">用' missing '估算缺失值</li><li id="8f60" class="lg lh it kk b kl lt ko lu kr lv kv lw kz lx ld nv lm ln lo bi translated">一次性编码它们</li></ol><p id="df86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一种方法可以完成这两个步骤:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="73ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能已经注意到，当映射回测试数据集的列名时，我们使用了来自训练数据集的列名。这是因为我更喜欢使用数据中的列名，这些数据是转换器被训练的数据。然而，如果我们使用测试数据集，它会给出相同的结果。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0ee67333ce28942433da7cb7a36ddad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*qIOGookdsAW17GO13z6DLg.png"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/388da748688eb979bc85df82b632db2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*iQbGKSKOS90MIhUwS4d_Ng.png"/></div></figure><p id="2191" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每个数据集，我们首先看到原始数据，然后是插补后的输出，最后是编码后的输出。这种方法可以完成工作。然而，我们手动地将上一步的输出作为输入提供给下一步，并且有多个中间输出。我们还必须对测试数据重复每一步。随着步骤数量的增加，维护起来会变得更加繁琐，也更容易出错。我们可以用<code class="fe lp lq lr ls b">Pipeline</code>编写更精简的代码:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/29847d8ec69a1ba9ecbc165c667013a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*UThNuaICtNjh1EBFHlX2Hg.png"/></div></figure><p id="6d8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe lp lq lr ls b">Pipeline</code>时，每一步都将其输出作为输入传递给下一步。因此，我们不必手动跟踪数据的不同版本。这种方法为我们提供了完全相同的最终输出，但代码更加优雅。</p><p id="3ca3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看了转换后的数据后，是时候在我们的示例中添加一个模型了。让我们调整代码，为第一种方法添加一个简单的模型:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1fb28d08b2a1df46786431240062dce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*Z3HSUpMqHAqtHn-bFL5d0g.png"/></div></figure><p id="415d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将对管道方法做同样的事情:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1fb28d08b2a1df46786431240062dce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*Z3HSUpMqHAqtHn-bFL5d0g.png"/></div></figure><p id="97b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能已经注意到，一旦我们训练了一条管道，做预测是多么简单。调用一行代码:<code class="fe lp lq lr ls b">pipe.predict(X)</code>对原始数据进行转换，然后返回一个预测。也很容易看出步骤的顺序。让我们直观地总结一下这两种方法:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/330377bdb1a9ba32dea86723e160f426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*ONryJuHGGUZ6PUmYTMiFxQ.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="1357" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe lp lq lr ls b">Pipeline</code>不仅可以组织和简化你的代码，还有很多其他的好处，下面是其中的一些:</p><ol class=""><li id="120d" class="lg lh it kk b kl km ko kp kr li kv lj kz lk ld nv lm ln lo bi translated"><strong class="kk iu">微调管道的能力:</strong>在构建模型时，您是否曾经不得不后退一步，尝试不同的方法来预处理数据并再次运行模型，以查看预处理步骤中的调整是否提高了模型的适用性？优化模型时，cogs不仅存在于模型超参数中，还存在于预处理步骤的实现中。考虑到这一点，当我们有一个统一变压器和估计器的单一管道对象时，我们能够微调整个管道的超参数，包括变压器和具有<code class="fe lp lq lr ls b">GridSearchCV</code>或<code class="fe lp lq lr ls b">RandomizedSearchCV</code>的估计器。</li><li id="02c2" class="lg lh it kk b kl lt ko lu kr lv kv lw kz lx ld nv lm ln lo bi translated"><strong class="kk iu">更容易部署:</strong>在训练模型时用于准备数据的所有转换步骤也应该应用于生产环境中进行预测时的数据。当我们训练一个<code class="fe lp lq lr ls b">Pipeline</code>时，我们训练一个包含数据转换器和模型的单一对象。一旦经过训练，这个<code class="fe lp lq lr ls b">Pipeline</code>对象可以用于更平滑的部署。</li></ol></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="6ce8" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">2.列变压器()</h1><p id="4e7d" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在前面的例子中，我们以同样的方式估算和编码所有的列。然而，我们经常需要对不同的列组应用不同的变压器组。例如，我们希望将<code class="fe lp lq lr ls b">OneHotEncoder</code>仅应用于分类列，而不是数字列。这就是<code class="fe lp lq lr ls b">ColumnTransformer</code>的用武之地。这一次，我们将对数据集进行分区，保留所有列，这样我们既有数字特征又有分类特征。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/20dfff5afa14892cf56f2141cddb63e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*YFghMmP1ScxntjuHUFbHiQ.png"/></div></figure><p id="cd91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经根据数据类型将特性分成了两组。可以根据数据的适当情况进行列分组。例如，如果不同的预处理管道更适合分类列，那么分类列可以进一步分成多个组。</p><p id="77ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上一节的代码现在不再有效，因为我们有多种数据类型。让我们来看一个例子，在这个例子中，我们使用<code class="fe lp lq lr ls b">ColumnTransformer</code>和<code class="fe lp lq lr ls b">Pipeline</code>在存在多种数据类型的情况下进行与之前相同的转换。</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ec478bd942d8bc4e4ed5f3d9d28108b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*P55V4MqEdFS31A5S2fhGfQ.png"/></div></figure><p id="1b84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分类列的输出与上一节的输出相同。唯一不同的是这个版本多了一列:<em class="lf">大小</em>。我们已经将<code class="fe lp lq lr ls b">cat_pipe</code>(之前在第1节中称为<code class="fe lp lq lr ls b">pipe</code>)传递给<code class="fe lp lq lr ls b">ColumnTransformer</code>来转换分类列，并指定<code class="fe lp lq lr ls b">remainder='passthrough'</code>保持剩余的列不变。</p><p id="169d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果也转换数字列不是很好吗？特别是，让我们用中值<em class="lf">大小</em>估算缺失值，并在0和1之间缩放:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/fdb3b753e850076c9734855de07ee423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*VFWCc44Du1kQV1OJZrFFfQ.png"/></div></figure><p id="e456" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在所有的列都是估算的，范围在0和1之间。使用<code class="fe lp lq lr ls b">ColumnTransformer</code>和<code class="fe lp lq lr ls b">Pipeline</code>，我们将数据分成两组，对每组应用不同的管道和不同的变压器组，然后将结果粘贴在一起:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi od"><img src="../Images/540c9a361095ad0e45d751091b011de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*BNwN3cmbLLoU9CQoJgFSKQ.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="c96d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管在我们的示例中，数字管道和分类管道中有相同数量的步骤，但是管道中可以有任意数量的步骤，因为它们彼此独立。现在，让我们在示例中添加一个模型:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8bba178acff155c1e245d47e09e67be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*H--mm8coLqAFdubwq6w6ww.png"/></div></figure><p id="f8fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了将<code class="fe lp lq lr ls b">ColumnTransformer</code>中指定的预处理步骤与模型放在一起，我们在外部使用了一个<code class="fe lp lq lr ls b">Pipeline</code>。这是它的视觉表现:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi of"><img src="../Images/fea4f4d4c30535e9bdcd1b524896cec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*jkjsxby0QGgERSnRKJlA0w.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="014d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们需要对不同的列子集进行不同的操作时,<code class="fe lp lq lr ls b">ColumnTransformer</code>很好地补充了<code class="fe lp lq lr ls b">Pipeline</code>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="2fb4" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">3.功能联盟</h1><p id="e756" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated"><em class="lf">本节中省略了代码后的输出，因为它们与第2节中的输出相同。列变压器。</em></p><p id="4a8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lp lq lr ls b">FeatureUnion</code>是另一个有用的工具。它能够做<code class="fe lp lq lr ls b">ColumnTransformer</code>刚刚做的事情，但是方式更长:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1897" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以认为<code class="fe lp lq lr ls b">FeatureUnion</code>创建了数据的副本，并行转换这些副本，然后将结果粘贴在一起。这里的术语“复制”与其说是一个技术参考，不如说是一个帮助概念化的类比。</p><p id="d261" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个管道的开始，我们添加了一个额外的步骤，在那里我们使用一个定制的转换器选择相关的列:在第14行和第19行的<code class="fe lp lq lr ls b">ColumnSelector</code>。下面是我们如何直观地总结上面的脚本:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4379b705fc440cae37026788706295d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*rcxISJ9JiW1EUoqjEl3n-g.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="8f6d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，是时候向脚本添加一个模型了:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0b88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它看起来和我们用<code class="fe lp lq lr ls b">ColumnTransformer</code>做的非常相似。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3a8a991833d73626ee0d86796c66ef33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*CCZdpkE_Zt_nY4UNN-_OJQ.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="f1f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如本例所示，使用<code class="fe lp lq lr ls b">FeatureUnion </code>比使用<code class="fe lp lq lr ls b">ColumnTransformer</code>更加冗长。因此，在我看来，在类似的情况下最好使用<code class="fe lp lq lr ls b">ColumnTransformer</code>。不过，<code class="fe lp lq lr ls b">FeatureUnion </code>绝对有它的位置。如果你曾经需要以不同的方式转换相同的输入数据，并把它们作为特征使用，<code class="fe lp lq lr ls b">FeatureUnion</code>就是其中之一。例如，如果您正在处理一个文本数据，并且既想对数据进行tf-idf矢量化，又想提取文本长度，<code class="fe lp lq lr ls b">FeatureUnion</code>是一个完美的工具。这里有一篇专门的文章:<a class="ae le" rel="noopener" target="_blank" href="/featureunion-columntransformer-pipeline-for-preprocessing-text-data-9dcb233dbcb6"> <em class="lf"> FeatureUnion，ColumnTransformer &amp; Pipeline，用于预处理文本数据</em> </a></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="190a" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">4.摘要</h1><p id="0d62" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">你可能已经注意到了，<code class="fe lp lq lr ls b">Pipeline</code>是超级巨星。<code class="fe lp lq lr ls b">ColumnTransformer</code>和<code class="fe lp lq lr ls b">FeatureUnion</code>是与<code class="fe lp lq lr ls b">Pipeline</code>一起使用的附加工具。<code class="fe lp lq lr ls b">ColumnTransformer</code>更适合我们并行分而治之，而<code class="fe lp lq lr ls b">FeatureUnion</code>允许我们对相同的输入数据并行应用多个转换器。下面是一个简单的总结:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oi"><img src="../Images/84fddeb5d1fb67cdec1b2564f20abde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AK5wzlfqqY-k_PFmCWIWNw.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="62ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lf">您想要访问更多这样的内容吗？媒体会员可以无限制地访问媒体上的任何文章。如果您使用</em> <a class="ae le" href="https://zluvsand.medium.com/membership" rel="noopener"> <em class="lf">我的推荐链接</em></a><em class="lf">成为会员，您的一部分会费将直接用于支持我。</em></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi oj"><img src="../Images/785c9a076af4d7e32de3d59a01b1847f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9G3jvjjOHit7WFaA"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@jeremythomasphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰瑞米·托马斯</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="3291" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你看我的帖子。希望这篇文章能帮助你更多地了解这些有用的工具。我希望你能在你的数据科学项目中使用它们。如果你感兴趣，这里有我的一些帖子的链接:</p><p id="b795" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">◼ <a class="ae le" rel="noopener" target="_blank" href="/featureunion-columntransformer-pipeline-for-preprocessing-text-data-9dcb233dbcb6"> FeatureUnion，ColumnTransformer &amp;用于预处理文本数据的管道</a> <br/> ◼ <a class="ae le" rel="noopener" target="_blank" href="/two-ways-to-create-custom-transformers-with-scikit-learn-b9089acacd37">用Scikit创建自定义变形器的两种方法——学习</a><br/>◼<a class="ae le" rel="noopener" target="_blank" href="/exploratory-text-analysis-in-python-8cf42b758d9e">python中的探索性文本分析</a><br/>◼<a class="ae le" rel="noopener" target="_blank" href="/preprocessing-text-in-python-923828c4114f">python中的预处理文本</a><br/>◼<a class="ae le" rel="noopener" target="_blank" href="/sentiment-classification-in-python-da31833da01b">python中的情感分类</a> <br/> ◼ <a class="ae le" rel="noopener" target="_blank" href="/5-tips-for-pandas-users-e73681d16d17">给熊猫用户的5个提示</a> <br/> ️◼ <a class="ae le" rel="noopener" target="_blank" href="/writing-5-common-sql-queries-in-pandas-90b52f17ad76">熊猫中数据聚合的5个提示</a> <br/></p><p id="c7da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再见🏃💨</p></div></div>    
</body>
</html>