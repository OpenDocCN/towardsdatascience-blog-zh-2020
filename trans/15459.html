<html>
<head>
<title>Regularization. What, Why, When, and How?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正规化。什么，为什么，什么时候，怎么做？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/regularization-what-why-when-and-how-d4a329b6b27f?source=collection_archive---------14-----------------------#2020-10-24">https://towardsdatascience.com/regularization-what-why-when-and-how-d4a329b6b27f?source=collection_archive---------14-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="25d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在这篇文章中，我想深入探讨一下正规化。</h2></div><h1 id="77f2" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">什么？</h1><p id="29ca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">什么是正规化？</strong></p><p id="bcaa" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">正则化是一种约束模型的方法，以准确地拟合我们的数据，而不是过度拟合。它也可以被认为是惩罚我们模型中不必要的复杂性。深度学习实践者主要使用3种类型的正则化技术。它们是:</p><ol class=""><li id="ff52" class="ly lz iq kz b la lt ld lu lg ma lk mb lo mc ls md me mf mg bi translated">L1正则化或拉索正则化</li><li id="4073" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">L2正则化或岭正则化</li><li id="5d8d" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">拒绝传统社会的人</li></ol><blockquote class="mm mn mo"><p id="995a" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated"><strong class="kz ir">侧栏</strong>:其他技术也可以对我们的模型产生正则化效果。你可以通过更多的数据来限制我们函数的搜索空间，从而防止过度拟合。这可以通过数据扩充等技术来实现，这些技术可以创建更多的数据来训练，从而减少过度拟合。<br/>有许多其他解决过度拟合的方法，如集合和提前停止，它们可以帮助防止过度拟合，但不被视为正则化，因为它们不限制搜索空间或惩罚复杂性。尽管你应该记住这些，因为调整并不是解决过度拟合的唯一方法。</p></blockquote><h1 id="f6e5" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">为什么？</h1><p id="aecc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">我们为什么需要正规化？</strong></p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mt"><img src="../Images/e2e9d03b6dc11dead02c40ee0c6be9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkJjUzk4BeCt7JoRU7WL3Q.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">图1:欠适与过适。图片由作者提供。灵感来自<a class="ae nj" href="https://www.youtube.com/channel/UCcIXc5mJsHVYTZR1maL5l9w" rel="noopener ugc nofollow" target="_blank">吴恩达</a></p></figure><p id="32dd" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在图1中，我们看到3条曲线。左边的预测分数做得很差，右边的预测分数做得<strong class="kz ir">【太好】</strong>。我们可以直观地看出左边的图不对，但是为什么右边的不好呢？我们的模型准确预测点的位置，这不好吗？</p><p id="37ba" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">答案是<strong class="kz ir">不</strong>，原因如下。我们的数据包含一些噪音，我们不希望我们的模型预测噪音，因为噪音是随机的。所以右边的图也不理想，我们想要像中间的图一样的东西。</p><p id="db51" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">拟合不足是由于我们的模型过于简单，或者训练时间不够长造成的。过度拟合是一个更难的问题。<br/>过度拟合可能是由于过于复杂的模型(学习噪音)造成的，或者是我们的模型函数的搜索空间太大，我们没有足够的数据来限制搜索。</p><p id="5000" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">所以正则化是一种停止过度拟合的方法。</p><h1 id="99e5" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">什么时候？</h1><p id="9d9b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">我们什么时候使用正规化？</strong></p><p id="e9a1" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">每当我们怀疑我们的模型过度拟合时，我们就使用正则化。过度拟合的最大迹象是验证指标的糟糕表现。验证集是模型尚未看到的数据集的一部分。</p><p id="bbe5" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">因为我们想检测我们的模型是仅从数据中学习，还是受到噪声的严重影响，所以我们使用噪声与训练集不同的验证集。因此，如果我们的模型过度拟合训练数据，它将在我们的验证集上预测不佳。</p><p id="ed1e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在培训期间，我们还会不断测量验证指标。如果我们看到验证指标没有显著提高，或者恶化，这是我们的模型过度拟合的警告信号。然后我们需要应用正则化技术。</p><blockquote class="mm mn mo"><p id="8005" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated"><strong class="kz ir">注意</strong>:有些规则化技术没有缺点，应该一直使用<strong class="kz ir"/>。这方面的一个例子是数据扩充。使用数据扩充没有坏处，无论模型是否过度拟合都应该使用。</p></blockquote><h1 id="8a7d" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">怎么会？</h1><p id="c145" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> L1正规化</strong></p><p id="461a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">L1正则化通过添加基于由某个值l(通常称为λ)缩放的参数的绝对值的惩罚来工作。</p><p id="bbe3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">最初我们的损失函数是:<strong class="kz ir"> Loss = f(preds，y) <br/> </strong>其中<em class="mp"> y是目标输出，preds是预测</em><strong class="kz ir"><br/></strong><em class="mp">preds = WX+b</em>，其中<em class="mp"> W是参数，X是输入，b是偏差。</em></p><p id="0051" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">对于L1正则化，我们添加了l*|W|的额外项，其中W是权重矩阵(参数)。因此，L1正则化后的损失函数为</p><blockquote class="nk"><p id="4836" class="nl nm iq bd nn no np nq nr ns nt ls dk translated">损失= f(preds，y) + l*abs(W)</p></blockquote><p id="8686" class="pw-post-body-paragraph kx ky iq kz b la nu jr lc ld nv ju lf lg nw li lj lk nx lm ln lo ny lq lr ls ij bi translated"><strong class="kz ir"> L2正规化</strong></p><p id="7c7a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">L2正则化非常类似于L1正则化，除了罚项是由某个因子l(λ)缩放的参数的平方</p><blockquote class="nk"><p id="4fb8" class="nl nm iq bd nn no np nq nr ns nt ls dk translated">损失= f(preds，y) + l*(W)</p></blockquote><p id="962a" class="pw-post-body-paragraph kx ky iq kz b la nu jr lc ld nv ju lf lg nw li lj lk nx lm ln lo ny lq lr ls ij bi translated"><strong class="kz ir"><em class="mp">L1与L2正规化的区别</em> </strong></p><p id="5f30" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">L1正则化和L2正则化之间的区别在于，损失函数相对于L1正则化的参数的梯度与参数的<strong class="kz ir">无关，因此一些参数可以一直设置为零，因此完全被忽略。</strong></p><p id="a38b" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">但是在L2正则化中，损失函数的梯度<strong class="kz ir">线性地依赖于参数</strong>，因此参数不可能为零。它们只是渐近地接近零。这意味着没有一个参数被完全忽略，每个参数对预测的影响总是最小的。</p><p id="8c67" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这种差异是选择正规化类型的关键，如果你知道你有无用的功能，L1可能是一个更好的选择。如果你想考虑所有的功能，L2可能是一个更好的选择。</p><blockquote class="mm mn mo"><p id="4fcd" class="kx ky mp kz b la lt jr lc ld lu ju lf mq lv li lj mr lw lm ln ms lx lq lr ls ij bi translated">细微差别:深度学习中有一个细微差别，通过使用L1和L2正则化，可以使用两全其美的方法。这被称为弹性网正则化。</p></blockquote><p id="919d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">辍学</strong></p><p id="32ed" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><a class="ae nj" href="https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf" rel="noopener ugc nofollow" target="_blank"> Dropout </a>是一种神奇的正则化技术，只对神经网络有效(据我所知)。dropout的惊人想法是以概率p (p是超参数)随机地将输入张量的一些元素归零。</p><p id="bee1" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这背后的直觉很简单，当我们的模型太复杂时会出现过度拟合，那么我们如何简化模型呢？只是不要用一些神经元然后嘭！！实现了一个更简单的模型。</p><p id="5f0e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们发现辍学在实践中非常有效，并且易于实施。我绝对推荐试一试。</p><p id="c2d9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><strong class="kz ir">数据扩充</strong></p><p id="c6c7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">数据扩充是我们正规化的最终“方法”。数据扩充背后的想法非常简单，但极其优雅。</p><p id="2f64" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们知道过度拟合是由于在我们的最优函数的搜索空间中缺乏约束而引起的。我们如何添加更多约束？更多数据。<br/>但是为我们的问题收集更多的数据可能是一项耗时且艰巨的任务。这就是数据增强的用武之地。</p><p id="4b90" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">数据扩充的想法是从我们已经拥有的数据中创造更多的数据。方法是对我们的图像进行一些变换，改变图像，使同一图像有不同的多个版本。神奇的是，我们有了更多的数据。</p><p id="df58" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我最喜欢的深度学习库(<a class="ae nj" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fastai </a>)提供的数据增强列表可以在这里<a class="ae nj" href="https://docs.fast.ai/vision.augment" rel="noopener ugc nofollow" target="_blank">看到</a>。</p><h1 id="1b12" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论</h1><p id="2e8c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">检查你的模型是否过度拟合，使用上述正则化方法之一来避免过度拟合。始终使用数据增强！！鳍。</p></div></div>    
</body>
</html>