<html>
<head>
<title>Python Trading Toolbox: a gentle introduction to backtesting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python交易工具箱:回溯测试的温和介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-trading-toolbox-05-backtesting-84266edb1d59?source=collection_archive---------8-----------------------#2020-10-07">https://towardsdatascience.com/python-trading-toolbox-05-backtesting-84266edb1d59?source=collection_archive---------8-----------------------#2020-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2ef6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tag/trading-toolbox" rel="noopener" target="_blank">交易工具箱</a></h2><div class=""/><div class=""><h2 id="9849" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">从头开始测试交易策略</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/bd8b376fcab18c806cfcbc1c6274a2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yFZgCUU38UbOMj3S"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c4e7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们通过引入一些基于价格的指标开始了这个系列。我们的目标是使用指标、价格和交易量来做出投资决策:选择何时买入或卖出金融资产。在我们的投资决策过程中，我们可以用不同的方法来整合价格、交易量和指标。第一种，也是最传统的一种，是以任意的方式解释他们的模式，就像技术分析的追随者所做的那样。指标也可以在一个更量化的方法中使用，作为交易系统的组成部分，消除投资过程中的人为判断。<a class="ae lh" href="https://en.wikipedia.org/wiki/Algorithmic_trading" rel="noopener ugc nofollow" target="_blank">算法交易</a>尤其是一种基于交易策略的方法，这种方法在没有人工干预的情况下自行建立金融工具的头寸。我们还可以使用价格、交易量和指标作为更复杂的机器学习模型的一部分来进行投资决策。</p><blockquote class="me mf mg"><p id="6a9d" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">一个明显的免责声明:这个帖子的内容仅用于教育目的。这里的所有例子都是作为学习练习提出的，它们绝不应该作为投资建议。</p></blockquote><p id="edbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无论我们选择以何种方式使用我们的指标，我们都需要回答一个重要的问题:我们的指标或指标组合对我们的投资决策有多好？换句话说，使用任何指标会比根本不使用它们产生更好的结果吗？</p><p id="5c97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可以帮助我们回答这个问题的过程被称为<a class="ae lh" href="https://www.investopedia.com/terms/b/backtesting.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">回溯测试</strong> </a>。通过回溯测试，我们将交易或投资策略应用于历史数据，以生成假设的结果。然后，我们可以分析这些结果，以评估我们战略的盈利能力和风险。</p><p id="856f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个过程有其自身的缺陷:不能保证在历史数据上表现良好的策略在现实交易中也会表现良好。真实的交易涉及很多因素，这些因素无法用历史数据来模拟或测试。此外，由于金融市场持续快速发展，未来可能会出现历史数据中没有的模式。然而，如果一个策略不能在回溯测试中证明自己是有效的，它很可能永远不会在真实交易中发挥作用。回溯测试至少可以帮助我们剔除那些没有价值的策略。</p><p id="841d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">几个框架使得使用Python回溯测试交易策略变得很容易。两个流行的例子是<a class="ae lh" href="https://www.zipline.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd"/></a>和<a class="ae lh" href="https://www.backtrader.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> Backtrader </strong> </a>。像<em class="mh"> Zipline </em>和<em class="mh"> Backtrader </em>这样的框架包含了设计、测试和实现算法交易策略所需的所有工具。他们甚至可以自动将真实订单提交给执行经纪人。</p><p id="024c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我们采用了一种不同的方法:我们想研究如何使用Python、<em class="mh"> pandas、</em>和NumPy作为我们仅有的工具，从头开始构建和测试一个交易系统。我们为什么要这么做？首先，从头开始构建回溯测试是一个很好的练习，有助于详细理解策略是如何工作的。此外，我们可能会发现自己需要实现现有框架中没有的解决方案。或者，您可能想要开始创建自己的回溯测试框架的旅程！</p><h1 id="1cb9" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">回溯测试我们的第一个系统</h1><p id="cb25" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们可以使用Python和NumPy以及<em class="mh"> pandas </em>创建一个基本的回溯测试。举个例子，我们将使用在纽约证券交易所交易的金宝汤公司股票的价格。我从雅虎下载了五年的交易历史。财务:文件在<a class="ae lh" href="https://raw.githubusercontent.com/stebas101/TradingToolbox/master/data/CPB.csv" rel="noopener ugc nofollow" target="_blank">这里</a>有。</p><p id="8820" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们首先设置我们的环境，并将价格系列加载到数据框中:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="ac70" class="nn mm it nj b gy no np l nq nr">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>pd.plotting.register_matplotlib_converters()</span><span id="3d0d" class="nn mm it nj b gy ns np l nq nr"># This is needed if you're using Jupyter to visualize charts:<br/>%matplotlib inline</span><span id="7936" class="nn mm it nj b gy ns np l nq nr">datafile = 'data/CPB.csv'<br/>data = pd.read_csv(datafile, index_col = 'Date')<br/># Converting the dates from string to datetime format:<br/>data.index = pd.to_datetime(data.index)</span><span id="b601" class="nn mm it nj b gy ns np l nq nr">data</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3827331399ed7a35f70070c6ad6b6b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*NgxmmXE85wYIalsWAb0CWw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">原始数据帧</p></figure><h2 id="9174" class="nn mm it bd mn nu nv dn mr nw nx dp mv lr ny nz mx lv oa ob mz lz oc od nb iz bi translated">基本策略</h2><p id="bedf" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在我们的例子中，我们将测试一个基本的<strong class="lk jd">移动平均线交叉系统</strong>，该系统基于每日收盘价的20天指数移动平均线(EMA)和200天简单移动平均线(SMA)(在本例中使用<em class="mh">调整收盘价</em>)。只要20日均线从下方穿过200日均线，我们就会买入该股(持有<em class="mh">多头仓位</em>)。</p><p id="b863" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将带有移动平均线的列添加到数据框中:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="b129" class="nn mm it nj b gy no np l nq nr">df = data.copy()</span><span id="b2d8" class="nn mm it nj b gy ns np l nq nr">sma_span = 200<br/>ema_span = 20</span><span id="1781" class="nn mm it nj b gy ns np l nq nr">df['sma200'] = df['Adj Close'].rolling(sma_span).mean()<br/>df['ema20'] = df['Adj Close'].ewm(span=ema_span).mean()</span><span id="3c08" class="nn mm it nj b gy ns np l nq nr">df.round(3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5c967888701c97ff688474a3ad82462e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*u6vlFzWD_BfGBm3Wvicx6w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">增加了sma200和ema20</p></figure><p id="d43a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们所看到的，通过使用200天的SMA，我们在相应列的前199行中获得了<strong class="lk jd"> NaN </strong>值。这只是一个练习，我们可以删除这些行来执行回溯测试。在实际操作中，我们可以考虑使用不同的指标来避免丢失大量数据。清除<em class="mh"> NaN </em>值:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="e087" class="nn mm it nj b gy no np l nq nr">df.dropna(inplace=True)</span><span id="7a9e" class="nn mm it nj b gy ns np l nq nr">df.round(3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5362762f3738939023cac9b94cf4a76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*mZQvTG3P40Z011cQbmxHiQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">移除了NaN行</p></figure><p id="d92d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看图表中的数据:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="f4e2" class="nn mm it nj b gy no np l nq nr">plot_system1(df)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/4dfba673c1250cf6053e180505fda6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXU-O8Ctaf-282RpQGYGyw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">移动平均价格</p></figure><p id="58bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了跟踪我们在数据框中的头寸，我们添加了一列，每一行都包含有多头头寸时的数字<strong class="lk jd"> 1 </strong>和没有头寸时的数字<strong class="lk jd"> 0 </strong>:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="962d" class="nn mm it nj b gy no np l nq nr"># Our trading condition:<br/>long_positions = np.where(df['ema20'] &gt; df['sma200'], 1, 0)<br/>df['Position'] = long_positions</span><span id="0d39" class="nn mm it nj b gy ns np l nq nr">df.round(3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e6b062bec9cf7572e96dcd72392656f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*4GH9gVJuJ0hkIZJpPUcnOQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加了位置列</p></figure><p id="3f0c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无论我们试图实现什么规则，检查我们的信号<strong class="lk jd">是一个好主意</strong>以确保一切按预期工作。讨厌的错误喜欢隐藏在这种计算中:开始测试一个系统，然后发现我们没有正确地实现我们的规则，这太容易了。特别是，我们需要警惕引入任何形式的<strong class="lk jd">前瞻偏差</strong>:当我们在交易规则中包含在规则评估时实际不可用的数据时，就会出现这种情况。如果系统回溯测试产生的结果好得令人难以置信，那么前瞻偏差是最有可能的罪魁祸首。</p><p id="78dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以通过检查数据框中的数字变量并在图表上绘制信号来检查信号。</p><p id="de58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要选择触发交易信号的日期:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="deb5" class="nn mm it nj b gy no np l nq nr">buy_signals = (df['Position'] == 1) &amp; (df['Position'].shift(1) == 0)</span><span id="9e3e" class="nn mm it nj b gy ns np l nq nr">df.loc[buy_signals].round(3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4d7fadfd1b3c5bbb2d384f2ba81648b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*-35f25MMVNyP-BetodYcEg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">信号被触发时的行</p></figure><p id="65b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们只有三个信号。为了确保我们正确应用交叉交易规则，我们可以在选择中包括信号之前的日子:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="e528" class="nn mm it nj b gy no np l nq nr">buy_signals_prev = (df['Position'].shift(-1) == 1) &amp; (df['Position'] == 0)</span><span id="a472" class="nn mm it nj b gy ns np l nq nr">df.loc[buy_signals | buy_signals_prev].round(3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/fc4dbd4bc4732dc0720f092c5b2b964f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*5WKNcORaRUL0Vpv2hs942g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">包括信号触发前的几天</p></figure><p id="5bc3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，一切看起来都很好:在信号出现之前的日子里，<code class="fe oj ok ol nj b">ema20</code>在<code class="fe oj ok ol nj b">sma200</code>下方，在信号出现的日子里，它在上方交叉。我们可以对退出我们头寸的信号进行类似的检查:我把这个练习留给你。</p><p id="4ae0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在图表上标出信号的标记:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="b291" class="nn mm it nj b gy no np l nq nr">plot_system1_sig(df)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/652ba65f43e185fe852ce5ced4a53f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4y45YZWqO4Yc6GGvmWBDQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带信号标记的图表</p></figure><p id="1a36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从图表中，我们可以看到，买和卖的信号是不匹配的。第一个信号是卖出(没有买入),因为我们从系列开始时的多头头寸开始。最后一个信号是买入(没有卖出)，因为我们在系列结束时保持多头头寸。</p><h2 id="cc0e" class="nn mm it bd mn nu nv dn mr nw nx dp mv lr ny nz mx lv oa ob mz lz oc od nb iz bi translated">战略回报</h2><p id="5bdf" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们现在可以用初始投资的百分比来计算我们策略的回报，并将其与<em class="mh">买入并持有</em>策略的回报进行比较，后者只是在期初买入我们的股票，并一直持有到期末。</p><p id="ce91" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将用来计算回报的价格序列是<strong class="lk jd">调整收盘价格</strong>:通过使用调整后的价格，我们可以确保在我们的计算中考虑到股息、股票分割和其他<a class="ae lh" href="https://www.investopedia.com/articles/03/081303.asp" rel="noopener ugc nofollow" target="_blank">公司行为</a>对回报的影响。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="2421" class="nn mm it nj b gy no np l nq nr"># The returns of the Buy and Hold strategy:<br/>df['Hold'] = np.log(df['Adj Close'] / df['Adj Close'].shift(1))</span><span id="df94" class="nn mm it nj b gy ns np l nq nr"># The returns of the Moving Average strategy:<br/>df['Strategy'] = df['Position'].shift(1) * df['Hold']</span><span id="0600" class="nn mm it nj b gy ns np l nq nr"># We need to get rid of the NaN generated in the first row:<br/>df.dropna(inplace=True)</span><span id="0231" class="nn mm it nj b gy ns np l nq nr">df</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/9473da717aca2f5e8e65e227b5d9f02a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e91TkpmLpcjWi8LTEUWUYQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加了返回列</p></figure><p id="197f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">整个周期的回报只是每日对数回报的总和(我将在后面解释数学原理):</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="2cb5" class="nn mm it nj b gy no np l nq nr">returns = np.exp(df[['Hold', 'Strategy']].sum()) - 1</span><span id="49f6" class="nn mm it nj b gy ns np l nq nr">print(f"Buy and hold return: {round(returns['Hold']*100,2)}%")<br/>print(f"Strategy return: {round(returns['Strategy']*100,2)}%")</span></pre><p id="58c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a00e" class="nn mm it nj b gy no np l nq nr">Buy and hold return: -5.83%<br/>Strategy return: 10.3%</span></pre><p id="0d0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些回报涉及1060天的时间。如果我们想将它们与其他时期的回报进行比较，我们需要<strong class="lk jd">将它们按年计算</strong>:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="7cdb" class="nn mm it nj b gy no np l nq nr">n_days = len(df)</span><span id="c61a" class="nn mm it nj b gy ns np l nq nr"># Assuming 252 trading days in a year:<br/>ann_returns = 252 / n_days * returns</span><span id="2352" class="nn mm it nj b gy ns np l nq nr">print(f"Buy and hold annualized return: {round(ann_returns['Hold']*100,2)}%")</span><span id="cc09" class="nn mm it nj b gy ns np l nq nr">print(f"Strategy annualized return:{round(ann_returns['Strategy']*100,2)}%")</span></pre><p id="8bb6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="0820" class="nn mm it nj b gy no np l nq nr">Buy and hold annualized return: -1.39%<br/>Strategy annualized return: 2.45%</span></pre><p id="a74d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除非你熟悉对数回报，否则你可能想知道为什么以及如何在回报计算中使用<strong class="lk jd">对数</strong>。这里有一点数学来解释这一点，如果你听起来很陌生的话。否则，请随意跳到下一部分。</p><p id="f73d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在定量金融学中，使用对数来计算回报是很常见的:它们使得一些计算更容易处理。如果日收益率<em class="mh"> R_t </em>定义为:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/4f0f1977bdaa93c96f25a05b404d8560.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*TV4RM6RMU6-eIvreCrgDsA.png"/></div></figure><p id="d4d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中<em class="mh"> P_t </em>是𝑡日的价格，对数收益𝑟_𝑡定义为:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/635f99df5cc4c7d9b47a8396d72cc0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/1*kqFmi3j_WuXl2sMDQSC1qQ.png"/></div></figure><p id="4eca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过应用一些基本代数，可以将每日日志回报计算为:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/36f039948d1314a0a1521e0e25e75ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*v4wnLWvd8t2_WKC4PBOydA.png"/></div></figure><p id="4ea0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为什么对数回归如此方便？如果我们有一系列的日收益，我们需要计算整个周期的收益，用对数收益我们可以把它们加起来。相比之下，对于定期回报，我们需要一个乘法:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/96c4e688011e5b8a580da1915e34abf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVURI5KZB2DiZNFFO1nUBA.png"/></div></div></figure><p id="a58d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中<em class="mh"> T </em>是我们考虑的时间段的天数。计算年化回报率也变得更加容易。</p><h1 id="b7bd" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">更复杂的策略</h1><p id="803f" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们刚刚测试的策略只有两种可能的头寸:我们要么<em class="mh">多头</em>(持有股票)要么<em class="mh">空头</em>(仅持有现金)。尝试和测试一种增加空头头寸可能性的策略(卖出借入的股票，并在退出头寸时买回)会很有趣。为了建立这个策略的例子，我们包括两个简单的移动平均线，一个是日高点，一个是日低点。我们还添加了15天指数移动平均线。我们根据以下规则建立头寸:</p><ul class=""><li id="94dd" class="or os it lk b ll lm lo lp lr ot lv ou lz ov md ow ox oy oz bi translated">当均线高于较高的均线时(加上2%的偏移)，我们做多(买入)</li><li id="a8e3" class="or os it lk b ll pa lo pb lr pc lv pd lz pe md ow ox oy oz bi translated">当均线低于较低的均线时(减去2%的偏移)，我们做空(卖空)</li><li id="29c8" class="or os it lk b ll pa lo pb lr pc lv pd lz pe md ow ox oy oz bi translated">在所有其他情况下(均线和均线之间)，我们不参与市场</li></ul><p id="28a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将失调添加到SMAs中，以减少错误信号的数量。让我们准备一个新的数据框:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="1057" class="nn mm it nj b gy no np l nq nr">df2 = data.copy()</span><span id="bb9c" class="nn mm it nj b gy ns np l nq nr">sma_span = 40<br/>ema_span = 15</span><span id="7c46" class="nn mm it nj b gy ns np l nq nr">df2['H_sma'] = df2['High'].rolling(sma_span).mean()<br/>df2['L_sma'] = df2['Low'].rolling(sma_span).mean()<br/>df2['C_ema'] = df2['Close'].ewm(span=ema_span).mean()</span><span id="45d8" class="nn mm it nj b gy ns np l nq nr">df2.dropna(inplace=True)</span><span id="3cd0" class="nn mm it nj b gy ns np l nq nr">df2.round(3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/e3b9818ff5059dccb6caf028268e19e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*AZ2C1PUhDoaOKQhJtQLBYg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加移动平均线</p></figure><p id="cc1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，除了收盘价之外，我们还利用了最高价和最低价。为了在图表上绘制这些值，使用<a class="ae lh" rel="noopener" target="_blank" href="/trading-toolbox-03-ohlc-charts-95b48bb9d748"><strong class="lk jd"/>或<strong class="lk jd">烛台</strong> </a>是个好主意。为此，我们将使用<strong class="lk jd"> mplfinance </strong>库。如果您还没有这样做，您可以使用以下命令轻松安装<em class="mh"> mplfinance </em>:</p><p id="f9a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oj ok ol nj b">pip install --upgrade mplfinance</code></p><p id="9d8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了将烛台图表与我们现有的样式相结合，我将应用<a class="ae lh" href="https://github.com/matplotlib/mplfinance/blob/master/markdown/subplots.md#external-axes-method" rel="noopener ugc nofollow" target="_blank"> <em class="mh">外部轴方法</em> </a>的<em class="mh"> mplfinance </em>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="0a97" class="nn mm it nj b gy no np l nq nr">plot_system2(df2)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/8db4591ed0da52104a8172a910a85f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1gdeWQdBUju0THNIxf32A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带移动平均线的蜡烛图</p></figure><p id="f895" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以更详细地检查任何特定的日期范围:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="f03c" class="nn mm it nj b gy no np l nq nr">plot_system2(df2['2019-07-01':'2019-12-31'])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/a4f5c74e2f3834a3506ef18c46698a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNwiamP99h4V60z0S_7ukw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">日期范围详细信息</p></figure><p id="da74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们应用我们的交易规则并添加头寸列:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="6bfd" class="nn mm it nj b gy no np l nq nr">offset = 0.02<br/>long_positions = np.where(df2['C_ema'] &gt; df2['H_sma']*(1+offset), 1, 0)<br/>short_positions = np.where(df2['C_ema'] &lt; df2['L_sma']*(1-offset), -1, 0)<br/>df2['Position'] = long_positions + short_positions</span><span id="8020" class="nn mm it nj b gy ns np l nq nr">df2.round(3)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/02bb0ef18c3770edb8371c0bcd8abbbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*fmZmuVq7mNuUuaez1FzQeg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加了位置列</p></figure><p id="6fb9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在图表上标出我们的信号:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="of og l"/></div></figure><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="934f" class="nn mm it nj b gy no np l nq nr">plot_system2_sig(df2)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/1d917b9c3a4ba90749b59bfba70d052d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TyE9UpOWl4NyMda7XM7JUA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带信号标记的图表</p></figure><p id="9b84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个系统比前一个系统有更多的信号，图表看起来很拥挤。我们可以详细查看任何日期范围:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a547" class="nn mm it nj b gy no np l nq nr">plot_system2_sig(df2['2018-12-01':'2019-05-30'])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/d9114cbb04db7210be08887ecdc0dce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PAeKWC0QqSHP-xFDfOFt0A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">日期范围详细信息</p></figure><p id="429d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们应用与之前相同的计算来获得策略的回报:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="9f64" class="nn mm it nj b gy no np l nq nr"># The returns of the Buy and Hold strategy:<br/>df2['Hold'] = np.log(df2['Adj Close'] / df2['Adj Close'].shift(1))</span><span id="2418" class="nn mm it nj b gy ns np l nq nr"># The returns of the Moving Average strategy:<br/>df2['Strategy'] = df2['Position'].shift(1) * df2['Hold']</span><span id="8a82" class="nn mm it nj b gy ns np l nq nr"># We need to get rid again of the NaN generated in the first row:<br/>df2.dropna(inplace=True)</span><span id="f58b" class="nn mm it nj b gy ns np l nq nr">returns2 = np.exp(df2[['Hold', 'Strategy']].sum()) -1</span><span id="6431" class="nn mm it nj b gy ns np l nq nr">print(f"Buy and hold return: {round(returns2['Hold']*100,2)}%")<br/>print(f"Strategy return: {round(returns2['Strategy']*100,2)}%")</span></pre><p id="8025" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="b85f" class="nn mm it nj b gy no np l nq nr">Buy and hold return: 17.04%<br/>Strategy return: -5.25%</span></pre><p id="5629" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和以前一样，我们可以按年计算回报率:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="70b9" class="nn mm it nj b gy no np l nq nr">n_days2 = len(df2)</span><span id="537d" class="nn mm it nj b gy ns np l nq nr"># Assuming 252 trading days in a year:<br/>ann_returns2 = 252 / n_days2 * returns2</span><span id="e380" class="nn mm it nj b gy ns np l nq nr">print(f"Buy and hold annualized return: {round(ann_returns2['Hold']*100,2)}%")<br/>print(f"Strategy annualized return: {round(ann_returns2['Strategy']*100,2)}%")</span></pre><p id="a619" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="61ee" class="nn mm it nj b gy no np l nq nr">Buy and hold annualized return: 3.52%<br/>Strategy annualized return: -1.09%</span></pre><p id="3f33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们的策略实际上不如<em class="mh">买入并持有</em>策略。</p><p id="d13e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能已经注意到，我使用<strong class="lk jd">未调整的价格序列</strong>来评估信号，而我一直使用调整后的价格来计算回报。每当股息、拆分或其他公司行为造成价格缺口时，使用未经调整的价格评估信号有引入错误触发的风险。在这里，我只是用了一个价格系列，这个价格系列很常见，每个人都可以免费下载。如果我们只有未调整的价格，我们应该使用所有关于公司行为的信息来修正我们的回溯测试。</p><h1 id="5886" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="e83b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这就是我们执行回溯测试和选择可以依赖的策略所需要的吗？肯定不是:在我们的回溯测试中，我们做了(尽管是隐含的)一些假设和简化，这些假设和简化会极大地影响我们的结果。首先，我们假设一只股票可以在信号触发当天的收盘价买入。实际上，这是不能保证的:实际价格将在信号发生后一天的范围内。那么，<strong class="lk jd">交易成本</strong>就不得不包括在内了。例如:</p><ul class=""><li id="291c" class="or os it lk b ll lm lo lp lr ot lv ou lz ov md ow ox oy oz bi translated">支付经纪费是为了执行和清算我们的订单。</li><li id="02a3" class="or os it lk b ll pa lo pb lr pc lv pd lz pe md ow ox oy oz bi translated">买价和卖价之间的价差是成本的一部分。</li><li id="81c0" class="or os it lk b ll pa lo pb lr pc lv pd lz pe md ow ox oy oz bi translated">如果我们利用杠杆买入，我们需要支付利息。同样，如果我们借入股票卖空，我们需要支付贷款利息。</li></ul><p id="9d83" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中一些因素比其他因素更容易理解并包含在模型中。</p><p id="3095" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们想要评估一个系统的性能并将其与其他系统的性能进行比较时，给定期间的回报只是我们想要考虑的众多<strong class="lk jd">性能和风险指标</strong>中的一个。一些例子是:</p><ul class=""><li id="7c05" class="or os it lk b ll lm lo lp lr ot lv ou lz ov md ow ox oy oz bi translated"><em class="mh">成功交易与失败交易的百分比</em>。</li><li id="e244" class="or os it lk b ll pa lo pb lr pc lv pd lz pe md ow ox oy oz bi translated">最大<a class="ae lh" href="https://www.investopedia.com/terms/d/drawdown.asp" rel="noopener ugc nofollow" target="_blank">提款</a>:我们累积利润的最高点和最低点之间的差额。</li><li id="37d9" class="or os it lk b ll pa lo pb lr pc lv pd lz pe md ow ox oy oz bi translated">收益的<em class="mh">标准差</em>和<em class="mh">夏普比率</em>。</li><li id="70c1" class="or os it lk b ll pa lo pb lr pc lv pd lz pe md ow ox oy oz bi translated"><a class="ae lh" href="https://www.investopedia.com/terms/r/riskrewardratio.asp" rel="noopener ugc nofollow" target="_blank">风险/回报比</a>，这是我们每投资一美元，从一笔交易中可以获得的预期回报。</li></ul><p id="e624" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们刚刚介绍的准系统回溯测试为计算所有这些指标和构建更现实的系统提供了起点。</p><p id="d2ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">出于所有这些原因，除非我们想从零开始建立一个完整的系统，如果我们需要实际地回溯测试一个策略，最好的选择很可能是使用一个完整的解决方案，比如<em class="mh"> Zipline </em>或<em class="mh"> Backtrader </em>。然而，当我从头开始编写回溯测试时，我仍然不断地学习很多关于指标和策略的知识，这是我绝对推荐的练习。</p></div></div>    
</body>
</html>