<html>
<head>
<title>TFRecords Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TFRecords解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tfrecords-explained-24b8f2133282?source=collection_archive---------12-----------------------#2020-10-15">https://towardsdatascience.com/tfrecords-explained-24b8f2133282?source=collection_archive---------12-----------------------#2020-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a30e70c18e33c9b7b6648d35e7315ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kNincK9pgBm82HI1"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">迪莉娅·詹德妮在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="3b4e" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">使用TFRecords并介绍Protobufs</h2></div><p id="b6c4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我将讨论<strong class="kx jh"> Tensorflow记录</strong>。Tensorflow建议以tfRecords格式存储和读取数据。它在内部使用<strong class="kx jh">协议缓冲区</strong>来序列化/反序列化数据，并以字节存储它们，因为它占用更少的空间来保存和传输大量的数据。</p><p id="a1f2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与JSON和XML不同，Protobufs使用预定义的模式。tfRecords在Protofiles中已经提供了这样的模式，并且还提供了许多受支持语言的编译代码。在这篇文章中，我将把这些编译好的代码导入Python，并在我的数据中使用它们。</p><p id="274b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章需要对Protobufs有一个基本的了解，因为它们是TFRecords的组成部分。我之前也写过一篇关于使用<a class="ae jd" href="https://medium.com/@gshbehera/serialization-deserialization-with-protobufs-223d401f621d" rel="noopener"><strong class="kx jh"><em class="lr">Protobufs</em></strong></a>的帖子。在这篇文章中，我首先回顾了tfRecords的预定义原型，在Python中使用它们，并给出了一些注意事项。然后我有两个演示，我将从现有的数据集制作tfRecords。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="e924" class="lz ma jg bd mb mc md dn me mf mg dp mh le mi mj mk li ml mm mn lm mo mp mq mr bi translated">预定义的原型</h2><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b838" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是取自Tensorflow的feature.proto的代码片段。完整的文件可以在<a class="ae jd" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/example/feature.proto" rel="noopener ugc nofollow" target="_blank">这里</a>找到。它包含3种原始消息类型，<strong class="kx jh">字节列表</strong>、<strong class="kx jh">浮动列表</strong>和<strong class="kx jh">int 64列表</strong>。这些可以单独用来创建一个整数、浮点数或字节的列表，可以序列化为二进制。我将在下一节中对此进行更多的讨论。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7562" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一个代码片段列出了来自上述同一文件的另外3个原型。它有一个<strong class="kx jh">特性</strong>消息类型，其中使用了BytesList、FloatList和Int64List，因为它是字段之一。<strong class="kx jh">当您想一次只设置所有字段中的一个字段时，使用Oneof </strong>字段。一个中的字段共享一个公共内存。如果在一个of中设置了多个字段，则它会自动清除其他字段。更多关于这个的信息可以在<a class="ae jd" href="https://developers.google.com/protocol-buffers/docs/proto3#oneof" rel="noopener ugc nofollow" target="_blank">这里</a>找到。然后创建了一个<strong class="kx jh"> Features </strong>消息类型，这是上面创建的一个字符串和一个Feature类型的映射。然后最后一个是<strong class="kx jh">例子</strong>用Features作为它的字段。</p><p id="27cc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些原型编译后的代码会分别给出<strong class="kx jh"> tf.train.Int64List，tf.train.FloatList </strong>，<strong class="kx jh"> tf.train.BytesList </strong>，<strong class="kx jh"> tf.train.Feature </strong>，<strong class="kx jh"> tf.train.Features </strong>和<strong class="kx jh"> tf.train.Example </strong>。现在，让我们来看一些Python代码，其中我使用了这些原型的编译版本。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="9f2c" class="lz ma jg bd mb mc md dn me mf mg dp mh le mi mj mk li ml mm mn lm mo mp mq mr bi translated">在Python中使用编译后的原型</h2><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d79b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码展示了上面定义的基本原型的用法。我使用它们通过传递重复的值来创建tf.train.Int64List、tf.train.FloatList和tf.train.BytesList的实例。type命令显示是从tensor flow . core . example . feature _ Pb2文件导入的，该文件是<strong class="kx jh">协议</strong>编译后生成的文件。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f7ec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我通过传递上面创建的所有列表来创建tf.train.Feature的一个实例。但是当我们打印它的时候，它只显示了float列表，没有int列表或者bytes列表被打印出来。原因是tf.train.Feature将它们作为字段之一。所以只有放在最后的列表会在那里，其他的会被清除。</p><p id="6844" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这意味着Tensorflow说我们不应该在实例化一个tf.train.Feature时填充多个字段，在protofile中使用oneof正好符合要求。但即使知道了这一切，我还是逼着自己去做。那我该如何防止自己再犯同样的错误呢？</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="fde4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯，我会这么做。我将为它们创建一个包装器，并在其中调用tf.train.Feature，这只会填充其中一个字段。我需要调用这些包装方法来创建tf.train.Feature实例。这明确地阻止了我创建一个tf.train.Feature并一次填充所有这些文件。</p><p id="3be1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我在这里面临的另一个问题是，我如何创建一个带有元素列表的tf.train.Feature(代码中的第18行)。将元素列表传递给包装器会产生tf.train.Feature形式的TypeError，它只接受整数、浮点或字节列表，而不接受列表列表。如果我将一个列表传递给包装器方法本身，那么它将尝试创建一个tf.train.Feature元素，该元素的列表包含一个整数、浮点数或字节的列表。错误也是。如果我有另外一个方法，用一个列表代替一个元素，这就可以避免。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9210" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也是一个包装器，但是它接受一个列表并创建tf。具有元素列表的特征。这可以用前面所有的包装器方法重复。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ce75" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我把上面创建的tf.train.Feature实例放到一个tf.train.Features映射中，并从映射中创建一个tf.train.Example实例。这个tf.train.Example实例是我将序列化为二进制的实例。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="0540" class="lz ma jg bd mb mc md dn me mf mg dp mh le mi mj mk li ml mm mn lm mo mp mq mr bi translated">tf.train.Example中的tfRecord</h2><p id="f8ad" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">好了，所有的基本工作都完成了。现在我们知道如何从一组整数、浮点或字节元素中创建一个tf.train.Example。是时候做一个<strong class="kx jh"> TFRecord </strong>了。TFRecord是指将这类记录的序列序列化为二进制。与任何其他数据格式相比，二进制格式占用更少的存储空间。</p><p id="3edc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我现在要做的。我将把一个数据集的所有记录转换成TFRecords，TF records可以序列化成二进制，也可以写入一个文件。Tensorflow说，</p><ul class=""><li id="08b6" class="nd ne jg kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated">对于记录中的每个值，创建一个tf.train.Feature实例。</li><li id="3dcb" class="nd ne jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">将记录的每个tf.train.Feature实例作为值添加到映射中，以属性名(列名)作为键。它将为数据集的记录创建一个tf.train.Features地图</li><li id="0e51" class="nd ne jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">使用上面创建的tf.train.Features映射创建tf.train.Example的一个实例。通过此过程，创建的tf.train.Example实例数将与数据集中的记录数相同。</li></ul><p id="f625" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我有两个演示来展示这种方法。其中一个是csv文件，另一个是图像数据集。但在深入研究之前，还有一些事情需要澄清。</p><ol class=""><li id="0c9e" class="nd ne jg kx b ky kz lb lc le nf li ng lm nh lq nr nj nk nl bi translated">我需要一个方法来根据记录中值的类型创建适当的tf.train.Feature。所以我在这里写了一个可以用于两个例子的方法。</li></ol><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="2fcb" class="nd ne jg kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated">这里的方法从数据集中获取行，并将其列类型和列名作为列表。</li><li id="bd01" class="nd ne jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">然后，它迭代该行的值，检查类型，然后创建相应的tf.train.Feature元素。</li><li id="400f" class="nd ne jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">然后如上所述，将tf.train.Feature实例作为值添加到tf.train.Features映射中，将列名作为键。然后，该映射用于创建tf.train.Example的实例。</li></ul><p id="0cb3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.在读取序列化格式时，我需要另一种方法来解析tfrecords。每个列都有自己的基于类型的解析机制。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="2688" class="nd ne jg kx b ky kz lb lc le nf li ng lm nh lq ni nj nk nl bi translated">这显示了从tfrecord中读取时每个属性的解析机制。</li><li id="2268" class="nd ne jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">它将列名和列类型的映射作为键值对。</li><li id="6693" class="nd ne jg kx b ky nm lb nn le no li np lm nq lq ni nj nk nl bi translated">然后，它使用<strong class="kx jh"> tf.io.FixedLenFeature </strong>配置来解析固定长度的输入特征，以及相应类型的值。这将使用作为键的列名和作为值创建的解析器填充另一个映射。</li></ul><p id="80bf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些方法现在都没多大意义了。当我们在下面的例子中使用它们时，我们可以回到这些。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="7862" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">示例1: CSV数据集到tfrecords </strong></p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/0e43a6275f823a2bc0240420e8fe9c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxDaj2cU_Ss7q38rFTKOLA.png"/></div></div></figure><p id="330c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所获取的数据集是一个汽车的csv文件<a class="ae jd" href="https://perso.telecom-paristech.fr/eagan/class/igr204/data/cars.csv" rel="noopener ugc nofollow" target="_blank">这里</a>。它包含8列，第1列包含字符串，第3列和第8列包含整数，其他列包含浮点数。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="98b2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用列名及其类型分别作为键和值来创建映射。然后，所有的键和值都被转换为list，以将它们发送给上面定义的第一个和第二个方法。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3c7a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我遍历数据集的行，通过调用上面写的第一个方法获得每个行的tf.train.Example实例。然后我将它们序列化，并写入tfrecords文件。让我们看看下面的输出。序列化之前的输出只是键和值对的映射。序列化后，所有数据都是转换成字节的二进制格式，正如我所看到的，序列化后的输出很紧凑，与其他格式相比节省了很多空间。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="46d1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我需要取回数据时，我需要使用上面定义的第二种方法再次读取tfrecords文件。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ec5d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我读取tfrecords文件，将其映射到parse_example方法，在该方法中，它实际上使用第二个方法中定义的特性描述来解析tfrecords文件中的每条记录。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="74d5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">示例2:用于对象检测的图像到TFRecords】</strong></p><p id="acad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于对象检测，我有一堆图像，它们各自的边界框存储在磁盘上的xml文件中。</p><figure class="ms mt mu mv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/dec98b7e891e0cec7185faa4ba9892c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZA5t5uHXOpZQCATuU81vA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">左上和左下图像是健康的叶子。右上和右下的图像是患病的叶子。图像连同它们的边界框一起显示。labelImg用于手动创建这些边界框，并将其放入每个图像的XML文件中。</p></figure><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7a5d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我解析xml文件的方法。Python有一个xml库，它的ElementTree可以在这里用来提取边界框的文件名、xmin、xmax、ymin和ymax以及标签(健康或不健康)。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7f3d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和前面的例子一样，这里我再次创建了列名及其类型的映射，并为每个列创建了列表，将它发送给第一个方法。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b1d4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我正在打开一个图像，使用tf.image API对它进行解码，并从xml中获取它的边界框细节。然后，我将创建一行对象检测所需的所有输入，并通过将它们发送给第一个方法来创建一个tf.train.Example。然后，该示例实例被序列化并写入tfrecords文件。</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="247d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与前面的例子相似，为了读回图像和xml细节的记录，这里我调用前面定义的第二个方法。得到解析的记录后，我打印它们的文件名。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="97dd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这都是关于TFRecords，以及如何将它们用于不同类型的数据集。暂时就这样了。请随时留下评论或任何改进建议。</p><ol class=""><li id="4182" class="nd ne jg kx b ky kz lb lc le nf li ng lm nh lq nr nj nk nl bi translated">欲了解更多TFRecords信息，请访问<a class="ae jd" href="https://www.tensorflow.org/tutorials/load_data/tfrecord" rel="noopener ugc nofollow" target="_blank"> TFRecords </a>。</li><li id="7f31" class="nd ne jg kx b ky nm lb nn le no li np lm nq lq nr nj nk nl bi translated">要了解更多关于协议缓冲区的信息，请访问<a class="ae jd" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank"> Protobufs </a>。</li></ol></div></div>    
</body>
</html>