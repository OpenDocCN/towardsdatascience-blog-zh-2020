<html>
<head>
<title>An Illustrative Introduction to Dynamic Time Warping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态时间弯曲的说明性介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-illustrative-introduction-to-dynamic-time-warping-36aa98513b98?source=collection_archive---------1-----------------------#2020-10-11">https://towardsdatascience.com/an-illustrative-introduction-to-dynamic-time-warping-36aa98513b98?source=collection_archive---------1-----------------------#2020-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a34f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="8325" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">+背后的数学</h2></div><p id="8fab" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di"> D </span>动态时间扭曲(DTW)是一种比较两个不完全同步的时间序列的方法。它是一种计算两个序列之间最佳匹配的方法。DTW在许多领域都很有用，如语音识别、数据挖掘、金融市场等。测量两个时间序列之间的距离是数据挖掘中常用的方法。</p><p id="9bbb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这篇文章中，我们将回顾DTW背后的数学。然后，提供两个说明性的例子来更好地理解这个概念。如果你对背后的数学不感兴趣，请跳到例子。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f285" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">制定</h1><p id="e450" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">假设我们有如下两个序列:</p><p id="d6aa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="na"> 𝑋=𝑥[1]，𝑥[2]，…，x[i]，…，x[n] </em></p><p id="9bfa" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="na"> Y=y[1]，y[2]，…，y[j]，…，y[m] </em></p><p id="b91c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">序列𝑋和𝑌可以被排列以形成𝑛-by-𝑚网格，其中每个点(𝑖，j)是𝑥[𝑖]和𝑦[𝑗].之间的比对</p><p id="8074" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">扭曲路径𝑊映射𝑋和𝑌的元素，以最小化它们之间的距离。𝑊是一系列网格点(𝑖，𝑗).稍后我们将看到一个弯曲路径的例子。</p><h2 id="029a" class="nb me it bd mf nc nd dn mj ne nf dp mn la ng nh mp le ni nj mr li nk nl mt iz bi translated">弯曲路径和DTW距离</h2><p id="21b7" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">到(𝑗_𝑘𝑖_𝑘)的最佳路径可以通过下式计算:</p><figure class="nn no np nq gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nm"><img src="../Images/c142de924c4ea86ccd6ed87a12d8765c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hJEJWuxrccwCMuUG_aPbQ.png"/></div></div></figure><p id="3d52" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">其中𝑑是欧几里德距离。然后，总路径开销可以计算如下</p><figure class="nn no np nq gt nr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/dbf46ac5418c545c5037a519c204fd9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*2OGDOJ-a0zTO_9T1FIGejQ.png"/></div></figure><h1 id="6ae3" class="md me it bd mf mg nz mi mj mk oa mm mn ki ob kj mp kl oc km mr ko od kp mt mu bi translated">扭曲函数的限制</h1><p id="6fa8" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">使用动态编程方法来比对两个序列，从而找到扭曲路径。遍历所有可能的路径是“组合爆炸”[1]。因此，为了提高效率，限制可能的扭曲路径的数量很重要，因此列出了以下约束条件:</p><ul class=""><li id="91a6" class="oe of it kt b ku kv kx ky la og le oh li oi lm oj ok ol om bi translated"><strong class="kt jd">边界条件</strong>:该约束确保弯曲路径从两个信号的起点开始，到它们的终点结束。</li></ul><figure class="nn no np nq gt nr gh gi paragraph-image"><div class="gh gi on"><img src="../Images/7d0dfca3e4b9ec57c98346af09776318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*SHsmQu2TqpaDyIArn2snzg.png"/></div></figure><ul class=""><li id="2013" class="oe of it kt b ku kv kx ky la og le oh li oi lm oj ok ol om bi translated"><strong class="kt jd">单调性条件</strong>:该约束保持了点的时间顺序(不及时返回)。</li></ul><figure class="nn no np nq gt nr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/80d8f35138aa778bbb5a86bedf41f4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*RNg2VENGaWoyvGrvyeg61A.png"/></div></figure><ul class=""><li id="6f1d" class="oe of it kt b ku kv kx ky la og le oh li oi lm oj ok ol om bi translated"><strong class="kt jd">连续性(步长)条件</strong>:该约束将路径过渡限制到相邻的时间点(不是时间跳跃)。</li></ul><figure class="nn no np nq gt nr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/39ccfe7b3708269e44eb54d83de493ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*lU99pFyomdPeaHuR26bDyA.png"/></div></figure><p id="4fe8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">除了上述三个约束条件之外，对于允许的翘曲路径，还有其他不太常见的条件:</p><ul class=""><li id="0824" class="oe of it kt b ku kv kx ky la og le oh li oi lm oj ok ol om bi translated"><strong class="kt jd">扭曲窗口条件</strong>:允许的点可以被限制在宽度为𝜔(正整数)的给定扭曲窗口内。</li></ul><figure class="nn no np nq gt nr gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/33ed2f1e9e0b2a8f1e329db42f792bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*9apgwkXeU3gOHLudFsIosA.png"/></div></figure><ul class=""><li id="5859" class="oe of it kt b ku kv kx ky la og le oh li oi lm oj ok ol om bi translated"><strong class="kt jd">坡度条件</strong>:可通过限制坡度来约束翘曲路径，从而避免在一个方向上的极端移动。</li></ul><p id="978d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一个可接受的扭曲路径有以下<strong class="kt jd">棋王</strong>走法的组合:</p><ul class=""><li id="bed1" class="oe of it kt b ku kv kx ky la og le oh li oi lm oj ok ol om bi translated">水平移动:(𝑖，𝑗) → (𝑖，𝑗+1)</li><li id="1ca9" class="oe of it kt b ku or kx os la ot le ou li ov lm oj ok ol om bi translated">垂直移动:(𝑖，𝑗) → (𝑖+1，𝑗)</li><li id="00e5" class="oe of it kt b ku or kx os la ot le ou li ov lm oj ok ol om bi translated">对角线移动:(𝑖，𝑗) → (𝑖+1，𝑗+1)</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3821" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">履行</h1><p id="a749" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">让我们导入所有需要的python包。</p><pre class="nn no np nq gt ow ox oy oz aw pa bi"><span id="e604" class="nb me it ox b gy pb pc l pd pe">import pandas as pd<br/>import numpy as np</span><span id="6247" class="nb me it ox b gy pf pc l pd pe"># Plotting Packages<br/>import matplotlib.pyplot as plt<br/>import seaborn as sbn</span><span id="6258" class="nb me it ox b gy pf pc l pd pe"># Configuring Matplotlib<br/>import matplotlib as mpl<br/>mpl.rcParams['figure.dpi'] = 300<br/>savefig_options = dict(format="png", dpi=300, bbox_inches="tight")</span><span id="bda0" class="nb me it ox b gy pf pc l pd pe"># Computation packages<br/>from scipy.spatial.distance import euclidean<br/>from fastdtw import fastdtw</span></pre><p id="29c8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们定义一种方法来计算弯曲路径的累积成本矩阵<em class="na"> D </em>。成本矩阵使用欧几里德距离来计算每两点之间的距离。计算欧几里得距离矩阵和累积成本矩阵的方法定义如下:</p><figure class="nn no np nq gt nr"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="nn no np nq gt nr"><div class="bz fp l di"><div class="pg ph l"/></div></figure><h1 id="651d" class="md me it bd mf mg nz mi mj mk oa mm mn ki ob kj mp kl oc km mr ko od kp mt mu bi translated">示例1</h1><p id="5ad1" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">在这个例子中，我们有两个长度不同的序列<em class="na"> x </em>和<em class="na"> y </em>。</p><pre class="nn no np nq gt ow ox oy oz aw pa bi"><span id="5ab2" class="nb me it ox b gy pb pc l pd pe"># Create two sequences<br/>x = [3, 1, 2, 2, 1]<br/>y = [2, 0, 0, 3, 3, 1, 0]</span></pre><p id="fdd0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们无法计算出<em class="na"> x </em>和<em class="na"> y </em>之间的欧几里德距离，因为它们的长度不相等。</p><figure class="nn no np nq gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pi"><img src="../Images/3b0a1de38356aa1bc20b5e194884b44b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADzLGLGGq13onO72EO_ZpQ.png"/></div></div><p class="pj pk gj gh gi pl pm bd b be z dk translated">例1:<em class="pn">x</em>与y的欧氏距离(可能吗？🤔)(图片由作者提供)</p></figure><h1 id="06dc" class="md me it bd mf mg nz mi mj mk oa mm mn ki ob kj mp kl oc km mr ko od kp mt mu bi translated">计算DTW距离和扭曲路径</h1><p id="b4f9" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">许多Python包仅通过提供序列和距离类型(通常为欧几里得距离)来计算DTW。这里，我们使用DTW的一个流行的Python实现，即<a class="ae po" href="https://github.com/slaypni/fastdtw" rel="noopener ugc nofollow" target="_blank"> FastDTW </a>，它是一个近似的DTW算法，具有更低的时间和内存复杂度[2]。</p><pre class="nn no np nq gt ow ox oy oz aw pa bi"><span id="9421" class="nb me it ox b gy pb pc l pd pe">dtw_distance, warp_path = fastdtw(x, y, dist=euclidean)</span></pre><p id="32b4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意，我们使用的是我们之前导入的<a class="ae po" href="https://pypi.org/project/scipy/" rel="noopener ugc nofollow" target="_blank"> SciPy </a>的距离函数<em class="na"> Euclidean </em>。为了更好地理解扭曲路径，让我们首先计算累积成本矩阵，然后在网格上可视化路径。以下代码将绘制累计成本矩阵的热图。</p><pre class="nn no np nq gt ow ox oy oz aw pa bi"><span id="c87b" class="nb me it ox b gy pb pc l pd pe">cost_matrix = compute_accumulated_cost_matrix(x, y)</span></pre><figure class="nn no np nq gt nr"><div class="bz fp l di"><div class="pg ph l"/></div><p class="pj pk gj gh gi pl pm bd b be z dk translated">示例1:绘制(并保存)累计成本矩阵热图的Python代码</p></figure><figure class="nn no np nq gt nr gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/aaf98f8e9b2e414229716990f7ade106.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*PIKZAwsV15NBvqkh9N1KMg.png"/></div><p class="pj pk gj gh gi pl pm bd b be z dk translated">示例1:累积成本矩阵和扭曲路径(图片由作者提供)</p></figure><p id="9c40" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">颜色条显示网格中每个点的成本。可以看出，扭曲路径(蓝线)在网格上的成本最低。让我们通过打印这两个变量来看看DTW距离和弯曲路径。</p><pre class="nn no np nq gt ow ox oy oz aw pa bi"><span id="fc06" class="nb me it ox b gy pb pc l pd pe">&gt;&gt;&gt; DTW distance:  6.0<br/>&gt;&gt;&gt; Warp path: [(0, 0), (1, 1), (1, 2), (2, 3), (3, 4), (4, 5), (4, 6)]</span></pre><p id="ffbe" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">扭曲路径从点(0，0)开始，经过6次移动后在点(4，6)结束。让我们使用之前定义的函数来计算累积成本most，并将这些值与热图进行比较。</p><pre class="nn no np nq gt ow ox oy oz aw pa bi"><span id="e8e5" class="nb me it ox b gy pb pc l pd pe">cost_matrix = compute_accumulated_cost_matrix(x, y)<br/>print(np.flipud(cost_matrix)) # Flipping the cost matrix for easier comparison with heatmap values!</span><span id="8745" class="nb me it ox b gy pf pc l pd pe">&gt;&gt;&gt; [[32. 12. 10. 10.  6.]  <br/>     [23. 11.  6.  6.  5.]   <br/>     [19. 11.  5.  5.  9.]  <br/>     [19.  7.  4.  5.  8.]  <br/>     [19.  3.  6. 10.  4.]  <br/>     [10.  2.  6.  6.  3.]  <br/>     [ 1.  2.  2.  2.  3.]]</span></pre><p id="3a5c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">上面打印的成本矩阵具有与热图相似的值。</p><p id="47c1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们绘制两个序列，并连接映射点。绘制<em class="na"> x </em>和<em class="na"> y </em>之间的DTW距离的代码如下所示。</p><figure class="nn no np nq gt nr"><div class="bz fp l di"><div class="pg ph l"/></div><p class="pj pk gj gh gi pl pm bd b be z dk translated">示例1:绘制(并保存)x和y之间的DTW距离的Python代码</p></figure><figure class="nn no np nq gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pi"><img src="../Images/968f2996fa7b40d52916323152b1d939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bF9I-49iVW9b2MvDbRBZxA.png"/></div></div><p class="pj pk gj gh gi pl pm bd b be z dk translated">示例1:<em class="pn">x</em>和y之间的DTW距离(图片由作者提供)</p></figure><h1 id="0926" class="md me it bd mf mg nz mi mj mk oa mm mn ki ob kj mp kl oc km mr ko od kp mt mu bi translated">示例2</h1><p id="ff56" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">在本例中，我们将使用两个正弦信号，并通过计算它们之间的DTW距离来了解它们是如何匹配的。</p><figure class="nn no np nq gt nr"><div class="bz fp l di"><div class="pg ph l"/></div><p class="pj pk gj gh gi pl pm bd b be z dk translated">示例2:生成两个不同长度的正弦信号(x1和x2)</p></figure><p id="aae4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">与示例1一样，让我们使用FastDTW软件包计算<em class="na"> x1 </em>和<em class="na"> x2 </em>信号的DTW距离和弯曲路径。</p><pre class="nn no np nq gt ow ox oy oz aw pa bi"><span id="1ba4" class="nb me it ox b gy pb pc l pd pe">distance, warp_path = fastdtw(x1, x2, dist=euclidean)</span></pre><figure class="nn no np nq gt nr"><div class="bz fp l di"><div class="pg ph l"/></div><p class="pj pk gj gh gi pl pm bd b be z dk translated">示例2:绘制(并保存)x1和x2之间的DTW距离的Python代码</p></figure><figure class="nn no np nq gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pq"><img src="../Images/1350fcaf59d18949bfc936c1efa7494b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bzubc5uGFXd_-Sj7W_QFjg.png"/></div></div><p class="pj pk gj gh gi pl pm bd b be z dk translated">示例2:x1和x2之间的DTW距离(图片由作者提供)</p></figure><p id="df29" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从上图可以看出，当两个信号具有相似的模式时，这两个信号之间的DTW距离特别大。两个信号之间的极值(最大和最小点)被正确映射。此外，与欧几里德距离不同，当使用DTW距离时，我们可以看到多对一映射，特别是如果两个信号具有不同的长度。</p><p id="b68b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">您可能会从上图中发现动态时间扭曲的问题。你能猜出它是什么吗？</p><p id="46c1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">问题在于时间序列的首尾不匹配。这是因为DTW算法不能承受端点处的翘曲不变性。简而言之，其效果是序列终点的微小差异将倾向于对估计的相似性做出不成比例的贡献[3]。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8643" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">结论</h1><p id="3b33" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">DTW是一种寻找两个序列之间最佳比对的算法，也是我们工具箱中有用的距离度量。当我们处理两个非线性序列时，这种技术很有用，特别是当一个序列是另一个序列的非线性拉伸/收缩版本时。扭曲路径是“棋王”移动的组合，从两个序列的头部开始，以它们的尾部结束。</p><p id="d2eb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你可以在这里找到这篇博文的笔记本。感谢阅读！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a2a8" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">参考</h1><p id="9df2" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">[1] Donald J. Berndt和James Clifford，<a class="ae po" href="https://www.aaai.org/Papers/Workshops/1994/WS-94-03/WS94-03-031.pdf" rel="noopener ugc nofollow" target="_blank">利用动态时间弯曲发现时间序列中的模式</a>，第三届知识发现和数据挖掘国际会议</p><p id="37c4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[2] Salvador，S. and P. Chan，<a class="ae po" href="https://cs.fit.edu/~pkc/papers/tdm04.pdf" rel="noopener ugc nofollow" target="_blank"> FastDTW:走向线性时空中的精确动态时间弯曲</a> <em class="na"> </em> (2007)，智能数据分析</p><p id="b987" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[3]迭戈·费塔多·希尔瓦，<em class="na">等人，</em>，<a class="ae po" href="https://core.ac.uk/display/147806669" rel="noopener ugc nofollow" target="_blank">关于端点对动态时间扭曲的影响</a> (2016)，SIGKDD关于时间序列挖掘和学习的研讨会</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8672" class="md me it bd mf mg mh mi mj mk ml mm mn ki mo kj mp kl mq km mr ko ms kp mt mu bi translated">有用的链接</h1><p id="22ce" class="pw-post-body-paragraph kr ks it kt b ku mv kd kw kx mw kg kz la mx lc ld le my lg lh li mz lk ll lm im bi translated">[1]<a class="ae po" href="https://nipunbatra.github.io/blog/ml/2014/05/01/dtw.html" rel="noopener ugc nofollow" target="_blank">https://nipunbatra.github.io/blog/ml/2014/05/01/dtw.html</a></p><p id="8481" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[2]<a class="ae po" href="https://databricks.com/blog/2019/04/30/understanding-dynamic-time-warping.html" rel="noopener ugc nofollow" target="_blank">https://databricks . com/blog/2019/04/30/understanding-dynamic-time-warping . html</a></p></div></div>    
</body>
</html>