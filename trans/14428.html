<html>
<head>
<title>10 Data Engineering Practices to Ensure Data and Code Quality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">确保数据和代码质量的10个数据工程实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-data-engineering-practices-to-ensure-data-and-code-quality-6224d012d8fb?source=collection_archive---------7-----------------------#2020-10-05">https://towardsdatascience.com/10-data-engineering-practices-to-ensure-data-and-code-quality-6224d012d8fb?source=collection_archive---------7-----------------------#2020-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a137" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="d76d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我从不同公司的数据工作中学到了什么</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/74983f38d4b03d30a8908d7927cb2339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2DltdjuqxsWX582klaowQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自<a class="ae lh" href="https://www.pexels.com/photo/time-lapse-photography-of-cars-on-road-during-night-time-3881034/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae lh" href="https://www.pexels.com/@brotherkehn?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Kehn Hermano </a>摄影</p></figure><p id="bc6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据工程是本世纪发展最快的职业之一。自从我开始在这个领域工作以来，我遇到了各种确保跨组织的数据和代码质量的方法。尽管每个公司可能遵循不同的过程和标准，但有一些通用的原则可以帮助我们提高开发速度，改进代码维护，并使数据工作更容易。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="340f" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">1.函数式编程</h1><p id="7390" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我在学习期间学习的第一门编程语言是Java。尽管我理解面向对象编程在创建可重用的类和模块方面的好处，但我发现在处理数据时很难应用它。两年后，我遇到了R——一种函数式编程语言，当时我就爱上了它。能够使用<code class="fe ni nj nk nl b">dplyr</code>包并简单地通过管道传递函数来转换数据并快速看到结果，这改变了我的生活。</p><p id="71c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是最近，<strong class="lk jd"> Python </strong> <strong class="lk jd">允许我们将两个世界结合起来</strong>:编写面向对象的模块化脚本的能力，同时利用函数式编程，这种编程在与r。</p><p id="6513" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">函数式编程在处理数据方面如此出色的原因是，几乎任何数据工程任务都可以通过以下方式来完成:获取输入数据，对其应用一些函数(<em class="nm">即ETL中的T:转换、清理或丰富数据</em>)，然后将其输出加载到某个集中的存储库中，或者为报告或数据科学用例提供服务。</p><p id="e57d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">函数式编程范式在数据工程中非常常见，以至于许多博客文章都是关于它的。例如，下面链接的文章已经由Apache Airflow的创始人Maxime Beauchemin在2018年初发布:</p><div class="nn no gp gr np nq"><a href="https://medium.com/@maximebeauchemin/functional-data-engineering-a-modern-paradigm-for-batch-data-processing-2327ec32c42a" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd jd gy z fp nv fr fs nw fu fw jc bi translated">功能数据工程——批量数据处理的现代范例</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">批量数据处理——历史上称为ETL——极具挑战性。这很耗时，也很脆弱，而且经常…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe lb nq"/></div></div></a></div><p id="00b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，许多数据工程工具已经被创建来促进这个过程。函数式编程让我们可以创建代码，这些代码可以在许多数据工程任务中重用，并且可以在对大量生产数据运行ETL之前，通过向函数提供小块数据来轻松地进行测试。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="6b89" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">2.设计你的函数来做一件事</h1><p id="14e1" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">为了使函数可重用，以这样一种方式编写它们是一个很好的实践，即它们只做一件事。你总是可以有你的主要功能，可以把不同的部分联系在一起。总的来说，我发现通过将功能变小(<em class="nm">，即专注于做好一件事</em>，我倾向于更快地开发代码，因为单个元素的失败可以更容易地被识别和修复。</p><p id="9934" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更小的功能也更容易更换单个组件，并将其用作乐高积木，可以根据不同的使用情况组合在一起。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="932b" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">3.正确的命名约定至关重要</h1><p id="c9df" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">一个好的做法是给对象命名，这样一个看你代码的新人就能立即理解你的意图。如果有些缩写不是每个人都能理解的，最好避免使用它们，并写出全称。此外，我见过的大多数数据工程师倾向于使用以下约定:</p><ul class=""><li id="a038" class="of og it lk b ll lm lo lp lr oh lv oi lz oj md ok ol om on bi translated"><strong class="lk jd">作为功能名称的动词</strong>，例如。<code class="fe ni nj nk nl b">get_dataframe_from_google_ads()</code>可能比<code class="fe ni nj nk nl b">google_ads()</code>更容易理解——更长的版本不仅显示了源系统，还显示了函数执行的动作和它返回的对象类型(<em class="nm">一个数据帧</em>)。你可以认为它很罗嗦，但是通常，你只需要写两次:一次在你定义它的时候，一次在你调用它的时候。因此，在我看来，那些更长的名字是值得的。</li><li id="7ab8" class="of og it lk b ll oo lo op lr oq lv or lz os md ok ol om on bi translated"><strong class="lk jd">大写全局变量</strong> —我合作过的大多数数据工程师都将全局变量定义为大写，以区别于局部变量(例如主函数中的那些)</li><li id="015e" class="of og it lk b ll oo lo op lr oq lv or lz os md ok ol om on bi translated">许多人认为最好只在脚本的顶部定义<strong class="lk jd">imports</strong>——理论上，您可以在函数或类中导入库，但是如果所有的导入都在脚本的顶部，可能会更容易跟踪包的依赖关系。</li></ul><p id="903c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理想情况下，您的命名可以使您的代码自文档化，这也可以使您更快地编写代码。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="7f76" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">4.通过编写更少更好的代码，使您的代码易于维护</h1><p id="cadb" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">一般来说，我们读代码的频率要比写代码的频率高得多。因此，让我们的代码易读、易理解是有意义的。有了正确的命名和良好的结构，我们可以让未来的自己和其他使用我们代码的人更容易。</p><p id="d106" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简洁也是有帮助的:我们写的代码越少，我们需要维护的代码就越少。如果我们可以用更少的代码完成一些事情，这是一个潜在的胜利。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="7c2b" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">5.文档是关键，但前提是处理得当</h1><p id="9af8" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这听起来可能违背直觉，但是我们不应该记录我们的代码在做什么。相反，我们应该记录为什么我们的代码正在做它正在做的事情。我经常看到代码注释陈述显而易见的事情。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/c759eb15a409364fdbef5fde9e33b652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*CLsfCtbDml3nX050CiWfmg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来自Reddit上的节目幽默[1]</p></figure><p id="3943" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，我们的函数<code class="fe ni nj nk nl b">get_dataframe_from_google_ads()</code>不必说我们正在从谷歌广告下载数据，而是说这样做的原因。"下载广告支出数据，用于以后的营销成本归属."</p><p id="f91d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最重要的是，使用<strong class="lk jd"> docstrings </strong>或类型注释来记录函数的预期输入和输出非常有用！它会立即让你成为更好的数据工程师。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="73cf" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">6.避免硬编码值</h1><p id="30b2" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我见过许多与ETL相关的SQL查询使用了一些阈值，却没有解释使用它们的原因。例如，假设有一个脚本从某个表中提取数据，但只针对2020年9月30日之后发生的事件。而且绝对没有文件证明为什么有人选择了这个特定的日期！如果不解释原因，人们以后怎么会发现为什么这个值被硬编码了呢？这可能是因为，在那一天，公司过渡到一个新的源系统、数据提供商，或者他们可能改变了一些业务策略。</p><p id="6139" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我并不是说在代码中指定这样的业务逻辑是错误的。但是，如果没有记录为什么有人选择了这样一个任意的阈值，这个硬编码的值在未来几年对下一代数据工程师来说可能仍然是一个谜。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="1e09" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">7.避免保留僵尸代码</h1><p id="bb73" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我经常遇到的一个常见的反模式是，有人保留了已经被放弃但在脚本中被注释掉的代码。也许有人想测试一些新的行为，并保留旧的版本，以防新的不工作。或者这个人想保留历史。在这两种情况下，我认为最好避免这种情况，因为这可能会使后来的开发人员难以区分什么是真正正确的版本。</p><p id="d15d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，我经历过这样一种情况，被注释掉的代码片段比没有被注释掉的版本更有意义。可能在某个时候，有人会调换这两个版本，因为他或她会认为注释掉这个更符合逻辑的版本是错误的。因此，保留一个僵尸代码可能是危险的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a04a" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">8.模块化做得好:将你的业务逻辑与实用功能分开</h1><p id="6eaf" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">混合实用功能和业务逻辑是有意义的，但是将它们分开仍然是有益的。如果使用得当，公共功能可以被推到不同的包中，并在以后的许多项目中重用。这种分离需要更多的前期工作。通过为这样的包建立一个发布过程，但是可重用性和只定义一个功能一次的好处从长远来看是值得的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a60c" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">9.保持简单</h1><p id="29a2" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">根据Python的禅[2]:</p><blockquote class="ou"><p id="9187" class="ov ow it bd ox oy oz pa pb pc pd md dk translated">“简单比复杂好。”</p></blockquote><p id="e6e9" class="pw-post-body-paragraph li lj it lk b ll pe kd ln lo pf kg lq lr pg lt lu lv ph lx ly lz pi mb mc md im bi translated">许多数据工程师，尤其是那些有计算机科学背景的人，有时可以创建复杂但过于复杂的解决方案。例如，如果某个东西可以表示为一个简单的函数，该函数将一些数据作为输入，并返回一个转换后的版本作为输出，那么为这样的操作编写一个自定义类对象可能会被认为是一个过度设计的解决方案。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="143b" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">10.考虑长远</h1><p id="36a3" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">有时候，我们需要在正确做事和快速做事之间做出权衡。创建足够通用的解决方案，以便在不同的用例中重用，这将使我们的长期生活更轻松，需要更长的时间来开发。例如，为跨项目共享的模块建立一个发布过程和CI/CD管道可能会在前期花费大量时间，但是这种额外的努力通常会在后期得到回报。花时间创建持续验证和监控数据质量的脚本也是如此。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="4e00" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="09fc" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在本文中，我们讨论了数据工程的最佳实践，以确保高质量的数据和代码的可维护性。我们已经展示了大多数数据工程任务可以表示为函数，这些函数接受一些输入数据，并根据特定的业务需求对其进行转换。</p><p id="b838" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">理想情况下，这些函数应该被设计为做一件事，并被记录下来，这样任何阅读代码的人都知道什么是需要的输入，什么是函数生成的输出。</p><p id="1388" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还研究了有用的命名约定，以及构造、编写和记录代码的最佳方式，以使其长期有用。</p><p id="aa50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">感谢您的阅读！如果这篇文章对您有帮助，请</strong> <a class="ae lh" href="https://medium.com/@anna.anisienia" rel="noopener"> <strong class="lk jd">关注我的</strong> </a> <strong class="lk jd">来看我的下一篇文章。</strong></p><h2 id="337e" class="pj mm it bd mn pk pl dn mr pm pn dp mv lr po pp mx lv pq pr mz lz ps pt nb iz bi translated">资源:</h2><p id="bdee" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">[1] Reddit — <a class="ae lh" href="https://www.reddit.com/r/ProgrammerHumor/comments/8w54mx/code_comments_be_like/" rel="noopener ugc nofollow" target="_blank">猫咪图片</a></p><p id="583e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">【2】<a class="ae lh" href="https://www.python.org/dev/peps/pep-0020/" rel="noopener ugc nofollow" target="_blank">Python之禅</a></p></div></div>    
</body>
</html>