<html>
<head>
<title>Characteristic Based Similarity for New Products Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于特征的新产品预测相似度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/characteristic-based-similarity-for-new-products-forecasting-8ab919d570b3?source=collection_archive---------38-----------------------#2020-10-20">https://towardsdatascience.com/characteristic-based-similarity-for-new-products-forecasting-8ab919d570b3?source=collection_archive---------38-----------------------#2020-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1f6454102ad49cea5b94127eefbd8a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xhs480Z4GenCWD1w"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">安德烈·亨特在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="d6d1" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">这是解决零售商在组合中加入新产品时面临的最大问题之一的方法。</h2></div><p id="5112" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“我能卖多少钱？”是每个零售商在考虑为商店和电子商务添加新材料时都会想到的问题。</p><p id="1854" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通常有很多技术来帮助我们预测和预见，但当我们谈论新产品时，我们会面临一个大问题，即如果我们没有新产品的销售数据来用于回归或时间序列算法。</p><p id="93bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么…我们如何预测呢？</p><h1 id="dfe3" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">方法</h1><p id="b1c0" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">解决这种数据缺乏的一种方法是找到一种与新产品相似的产品，并复制其历史销售数据的一部分，有了它，您现在可以应用您喜欢的预测技术。</p><p id="ccd7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，你可以用几种不同的方法来比较产品，除此之外，每个企业都必须定义在这种分析中使用的理想特性。</p><p id="59e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义功能后，这是该过程中最困难也是最重要的一步，您将遵循一个简单的步骤来实现您的目标:</p><blockquote class="mr"><p id="20cf" class="ms mt jj bd mu mv mw mx my mz na lt dk translated">1.<!-- -->对分类数据应用一键编码</p></blockquote><p id="7929" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">应用一个热编码，我们从比较类别名称/文本之间的距离，到比较产品是否与旧产品在同一类别。</p><blockquote class="mr"><p id="9d5c" class="ms mt jj bd mu mv mw mx my mz na lt dk translated">2.将定标器技术应用于数值数据</p></blockquote><p id="bba9" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">当我们谈论距离时，它总是类似于A-B=C，但现在我们正在讨论几个特征的距离，结果听起来像是所有的cs之和减去所有的Bs。</p><p id="e794" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不会有任何问题，只要列中的值的范围都是相同的，我很确定这种情况非常非常少发生。</p><p id="412e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有3列，一列的值范围是从200到400，另一列是从15k到78k，第三列是从1到10。</p><p id="dcb1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将产生一个问题，因为范围之间的差异将导致不同的距离标度，在这种情况下，分别为100秒、10000秒和10秒，如果我们尝试应用距离度量而不应用标度，则第二列的重要程度将大于其他列。</p><p id="e167" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，别忘了涂。</p><blockquote class="mr"><p id="e433" class="ms mt jj bd mu mv mw mx my mz na lt dk translated">3.<!-- -->计算新产品和旧产品之间的距离</p></blockquote><p id="630e" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我想这是你最期待的部分，对吗？</p><p id="7d15" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果是的话，我希望不会让你失望，因为解决方案真的很简单。</p><p id="ecdb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，这里您必须做的第一件事是定义您想要使用哪种距离度量。请参见下面简单有用的距离列表:</p><ul class=""><li id="ce21" class="ng nh jj la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">欧几里得的</li><li id="566c" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">曼哈顿</li><li id="7e65" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">闵科夫斯基</li></ul><p id="2dd0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在继续之前，您必须选择最适合您的距离度量。</p><p id="12bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这个项目，我使用了欧几里德距离，所以我们只用两行代码就结束了整个项目:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="b83b" class="od lv jj nz b gy oe of l og oh">idx_closest = np.argmin(<br/>    [np.linalg.norm(new_obs_arr - np.array(x)) for x in df_old.values])<br/>df_aux = df_old.iloc[idx_closest]\<br/>    .to_frame()\<br/>    .transpose()\<br/>    .reset_index()</span></pre><p id="d58c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi oi translated">idx_closest是旧数据帧的参考资料的索引值，用它我们得到整个对应的行并存储在df_aux。</p><blockquote class="mr"><p id="268f" class="ms mt jj bd mu mv mw mx my mz na lt dk translated">4.反向独热编码</p></blockquote><p id="dea0" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">流程如何考虑物料注册的工厂代码我们必须至少为工厂代码列恢复一个热编码的流程。</p><p id="932e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要恢复它，我们应该:</p><ul class=""><li id="fa26" class="ng nh jj la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">定义由一个热编码过程创建的列。</li><li id="d9a2" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">仅选择包含“1”的列。</li><li id="18cb" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">将其名称转换为原来的名称。</li><li id="1759" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">在流程开始时删除由one hot编码创建的列。</li></ul><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="3306" class="od lv jj nz b gy oe of l og oh">def reverse_one_hot_encoder(df, col_nm):<br/>    """<br/>    Reverse the one hot encoding process<br/>    <br/>    Parameters<br/>    ----------<br/>    df : pandas.DataFrame<br/>        data frame object with the old products that are more similar the new products<br/>    col_nm : str<br/>        name of the original column<br/>        <br/>    Returns<br/>    -------<br/>        df_result : pandas.DataFrame<br/>        data frame object with the old products that are more similar the new products without the OHE procress<br/>    """<br/>    lst_stack = [x for x in df.columns if x.find(col_nm)&gt;=0]<br/>    df_aux = df[lst_stack]<br/>    df[col_nm] = df_aux[df_aux==1]\<br/>        .stack()\<br/>        .reset_index()\<br/>        .drop(0,1)['level_1']\<br/>        .apply(lambda x: int(x.replace(col_nm+'_','')))\<br/>        .to_list()<br/>    for col in lst_stack:<br/>        df = df.drop(col, axis=1)<br/>    return df</span></pre><blockquote class="mr"><p id="1271" class="ms mt jj bd mu mv oj ok ol om on lt dk translated">5.计算比例因子</p></blockquote><p id="a728" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">现在我们已经完成了比例因子步骤，也称为睡眠时间，因为我已经失去了思考它的时间。</p><p id="955e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧…好吧…我对这个家伙不公平，但我真的浪费了一些时间去思考这个问题，最终，导致了一些看起来太容易做到的事情，所以这可能只是我内心的愤怒试图在这里释放一点。</p><p id="45dc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么我在这上面浪费了这么多时间…</p><p id="0b5f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，记住距离步长的A-B=C，我们可以猜测“好了，现在我已经定义了新行和旧行。那么，我为什么不，定义比例因子，只是除以1，得到一个百分比结果呢？”</p><p id="19ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种思维方式很好，但它的应用不太好，因为我们现在不是比较两个数字，而是试图从两个完整数据帧行的数组中获得百分比，而且没有简单的方法来做到这一点。</p><p id="e498" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们选择的解决这个问题的方法是定义一个数学函数，它随着我们已经计算过的距离的增加而减少。</p><p id="db1c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们认为对长距离比短距离进行更多的处罚应该是一件好事，所以我们尝试了“e^(-distance”，如果你是一个细心的人，你会注意到我说了“尝试”，这意味着它没有很好地工作。</p><p id="b562" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题是我们认为每一个被选择为相似的参考材料都应该和新的材料很接近，对吗？但在某些情况下，我们没有那么多的材料可以比较，我们最终只能得到最好的，而不是完美的匹配。</p><p id="ddda" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为了避免距离增长过快，我们添加了结果组的平均距离值，以获得一个缓慢下降的比率。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="a415" class="od lv jj nz b gy oe of l og oh"># import Libs<br/>import matplotlib.pyplot as plt<br/>import statistics<br/>import numpy as np<br/># simulate distance increasing<br/>x = np.array(np.arange(0, 100, 0.001))<br/># get average value from distances<br/>avg = statistics.mean(x)<br/># plot lines<br/>plt.plot(x, np.exp(-(x**2)), 'b-')<br/>plt.plot(x, np.exp(-(x**2/avg**2)), 'r-')<br/>plt.legend(labels=['Original', 'Smothed'])<br/># add labels<br/>plt.xlabel("Distance")<br/>plt.ylabel("Saling Factor")<br/>plt.show()</span></pre><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/bad2034fd244b13fcf55376ed03d5a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*Wxd8ghLEOMuflFllSQrXPQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:作家</p></figure><p id="334c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个要点是看产品价格，因为如果新产品的价格低于参考价格，这意味着它有机会卖出更多，但如果价格高于参考价格，就有可能卖出更少。</p><p id="b6ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了将这种或多或少的销售机会与比例因子相加，我们决定计算旧产品的价格占新产品的多少。</p><p id="9c47" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们有了基于数学函数和价格比的比例因子，我们就可以将两者相乘得到最终的比例因子。</p><h1 id="ab41" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">结果</h1><p id="916c" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">该算法导出包含五列的. csv文件:</p><ul class=""><li id="b854" class="ng nh jj la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">位置</li><li id="cb09" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">产品</li><li id="0390" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">参考_位置_代码</li><li id="de72" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">参考_代码</li><li id="736f" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">比例因子</li></ul><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/01c700ea5f173c94ec11868c2f3975db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*RIJjzNZ_jwk1ktPTSub4oQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:作家</p></figure><p id="4d84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用它来模拟新产品的历史销售数据，然后对其应用任何预测算法！</p><h1 id="2673" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">最终提示</h1><ul class=""><li id="9c41" class="ng nh jj la b lb mm le mn lh oq ll or lp os lt nl nm nn no bi translated">安排一次会议，与您的主数据团队或任何在您的数据库中注册/创建新产品的团队进行交谈，因为他们可以很容易地告诉您新材料的初始特征。</li><li id="cab8" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">明智地选择可以作为新产品参考的材料。那些你已经停止工作，但仍然存在于你的数据库中的产品或新产品(自第一次销售后不到两三个月)可能不是最好的决定，因为它们可能没有良好的历史销售曲线。</li><li id="89a0" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">选择一个产品层次结构进行过滤，这样一旦减少比较样本，就可以加快合作时间，并且可能会比较更相似的产品，而不是在整个产品库中搜索。</li><li id="5692" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">不要忘记，一旦你的新产品开始销售，它将收到真正的销售数据，你应该开始使用它来预测，而不是你生成的数据。</li></ul><h1 id="b280" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">这就是了！</h1><p id="eb7c" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">嗯，有了这个，我想你现在可以通过找到一个类似的旧材料来改进你的新产品，并扩大它的销售，作为你预测工具的输入！</p><p id="4e49" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这篇文章对你有帮助！</p><p id="3e5c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里看到这个项目的代码:</p><div class="is it gp gr iu ot"><a href="https://github.com/rfpcordeiro/python-similarity-to-characteristic-based-forecast" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd jk gy z fp oy fr fs oz fu fw ji bi translated">rfpcordeiro/python-基于特征相似性的预测</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">算法来计算和定义数据库中与新产品最相似的产品，这样我们就可以使用…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ja ot"/></div></div></a></div><blockquote class="pi pj pk"><p id="3e88" class="ky kz pl la b lb lc kk ld le lf kn lg pm li lj lk pn lm ln lo po lq lr ls lt im bi translated"><em class="jj">特别感谢Pierre Palud，当我澄清了无数个关于定义比例因子的最佳方式的问题时，他一直耐心等待</em></p></blockquote></div></div>    
</body>
</html>