<html>
<head>
<title>Speeding up a sklearn model pipeline to serve single predictions with very low latency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速sklearn模型管道，以极低的延迟提供单一预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/speeding-up-a-sklearn-model-pipeline-to-serve-single-predictions-with-very-low-latency-a7fd89c36d4?source=collection_archive---------52-----------------------#2020-10-30">https://towardsdatascience.com/speeding-up-a-sklearn-model-pipeline-to-serve-single-predictions-with-very-low-latency-a7fd89c36d4?source=collection_archive---------52-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af8d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">编写你自己的sklearn函数，(现在是最终版本)第3部分</em></h2></div><p id="2c3f" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果你以前使用过sklearn，你肯定遇到过在使用数据帧或数组作为你的转换器和估算器的输入之间的挣扎。两者各有利弊。但是一旦你部署了你的模型，例如作为一项服务，在许多情况下它将服务于单一的预测。<a class="ae lc" href="https://maxhalford.github.io/blog/speeding-up-sklearn-single-predictions/" rel="noopener ugc nofollow" target="_blank"> Max Halford展示了一些很好的例子</a>关于如何改进各种sklearn变压器和估算器，以服务于单次预测，额外提升性能和低毫秒范围内的潜在响应！在这篇短文中，我们将推进这些技巧，开发一个完整的管道。</p><p id="38bf" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">几个月前<a class="ld le ep" href="https://medium.com/u/aff4365c3dba?source=post_page-----a7fd89c36d4--------------------------------" rel="noopener" target="_blank"> Max Halford </a>写了一篇<a class="ae lc" href="https://maxhalford.github.io/blog/speeding-up-sklearn-single-predictions/" rel="noopener ugc nofollow" target="_blank">很棒的博文</a>，他描述了我们如何修改sklearn转换器和估计器，以更高的速度处理单个数据点，本质上是使用一维数组。当您构建sklearn模型管道时，它们通常同时处理numpy数组和pandas数据帧。数组通常提供更好的性能，因为许多计算的numpy实现是高性能的，并且通常是矢量化的。但是使用列名来控制转换也变得更加棘手，而数组没有列名。如果您使用pandas dataframes，您可能会得到更差的性能，但是您的代码可能会更具可读性，并且列名(即特性名)与大多数转换器的数据保持一致。在数据探索和模型训练期间，您最感兴趣的是批量转换和预测，但是一旦您将训练好的模型管道部署为服务，您可能还会对单个预测感兴趣。在这两种情况下，服务用户将发送如下所示的有效载荷。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/6bf5fd9f18b4d9299340b7837274575c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U5TLkk8lgwYLEA9V.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">稍微有用的插图—作者使用<a class="ae lc" href="http://draw.io" rel="noopener ugc nofollow" target="_blank"> draw.io </a>制作的图像</p></figure><p id="85c1" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">假设有一个服务，我们根据一些尺寸度量来估计鱼的重量(参考后面介绍的鱼市场数据集)，那么一个请求可能如下所示:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="b15a" class="lw lx iq ls b gy ly lz l ma mb">{<br/>    "species": "Bream",<br/>    "length": 24.5,<br/>    "heigth": 12.3,<br/>    "width": 4.12,<br/>}</span></pre><p id="ef8a" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">或者可选地<code class="fe mc md me ls b">["Bream", 24.5, 12.3, 4.12]</code>，并且模型可以返回如下的权重估计:</p><p id="78da" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在他的博客中，Max Halford展示了如何将<code class="fe mc md me ls b">transform_single</code>和<code class="fe mc md me ls b">predict_single</code>方法添加到变压器和估算器中，以更高的性能执行单数据点处理。根据管道的复杂程度，节省的绝对时间可能并不多。但是更长的响应时间会增加服务基础设施的整体延迟，而短时间会给应用程序带来压力，特别是如果它在关键路径内。我们最终还将能够节省基础设施成本，因为我们可以在更小的硬件上运行您的服务，即更小、更少的pod。此外，避免数据帧强制将释放服务实例上的内存。最后但并非最不重要的是，我们节省了时间，我们可以在更复杂的转换和模型上花费时间——这让每个数据科学家都很高兴！</p><h2 id="fd73" class="lw lx iq bd mf mg mh dn mi mj mk dp ml kp mm mn mo kt mp mq mr kx ms mt mu mv bi translated">创建基本变形金刚</h2><p id="1d89" class="pw-post-body-paragraph kg kh iq ki b kj mw jr kl km mx ju ko kp my kr ks kt mz kv kw kx na kz la lb ij bi translated">但是缩短响应时间的代价是什么呢？我们可以通过看一个例子来探索这一点，这里没有广告类继承，而是作为如何工作的草图:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="4cfe" class="lw lx iq ls b gy ly lz l ma mb">barebones_transformer = BarebonesTransformer()</span><span id="5828" class="lw lx iq ls b gy nd lz l ma mb">barebones_transformer.fit(data)<br/>barebones_transformer.transform_single([1.0, 2.5])</span></pre><p id="b6a2" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一方面，我们有失去训练和推理/预测奇偶性的风险。这是什么意思？正如我们在上面看到的，我们的数据在转换过程中基本上有两种不同的代码路径:单个预测的代码路径将仅用于单个数据点的推断，而不是在训练期间，在训练期间，我们通常成批转换，即数据帧或数组。因此，我们需要付出额外的努力来确保两条转换路径导致相同的转换，从而导致相同的结果。例如，这可以通过添加一些额外的单元测试来实现。</p><p id="ebb0" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">另一方面，我们可能会丢失sklearn正在内部进行的一些验证，也就是说，当父方法<code class="fe mc md me ls b">transform</code>被调用时。因此，我们需要确保在将有效载荷传递给模型之前对其进行适当的验证，以防止模型意外崩溃。</p><p id="58b5" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">同样的想法也适用于估计器和<code class="fe mc md me ls b">predict</code>方法。最后，这就像通过卡车(加上保险)发送一封信，它是可行的，是一个安全的选择，但它可能是过度的，骑自行车的邮递员可能更合适、更快。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1cd2b1c373f931fdbdb9e1277dfb0846.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*v0grzLUpHRS4fKU3.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">不同有效载荷的不同运输类型——图片由作者使用<a class="ae lc" href="http://draw.io" rel="noopener ugc nofollow" target="_blank"> draw.io </a>完成</p></figure><p id="fb72" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果我们对这两个缺点都满意，那么如果我们花一些时间来操作单个数据点的现有转换器，我们可以为每个请求节省一些时间。</p><p id="3336" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在，既然我们已经看到了如何实现这一点，那么让我们使用一些toy day和sklearn的<code class="fe mc md me ls b">SimpleImputer</code>(一种用于估算缺失数据的转换器，例如使用平均值)来评估pandas和基于numpy的方法的性能。我们将使用非常健壮的<a class="ae lc" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.isna.html" rel="noopener ugc nofollow" target="_blank"> pd.isna </a>来检查1d数组中缺失的值:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="0150" class="lw lx iq ls b gy ly lz l ma mb">import pandas as pd<br/>import numpy as np</span><span id="daae" class="lw lx iq ls b gy nd lz l ma mb">np.random.seed(47723)</span><span id="7004" class="lw lx iq ls b gy nd lz l ma mb"># truncate decimals for better printing<br/>np.set_printoptions(precision=3, suppress=True)<br/>pd.set_option('precision', 3)</span><span id="c343" class="lw lx iq ls b gy nd lz l ma mb">n = 1000<br/>data = pd.DataFrame({<br/>    'num1': np.random.normal(0, 1, n),<br/>    'num2': np.random.normal(0, 1, n)<br/>})</span><span id="f8d5" class="lw lx iq ls b gy nd lz l ma mb"># remove 10% of the data<br/>data[np.random.rand(*data.shape) &gt; 0.9] = np.nan</span><span id="733e" class="lw lx iq ls b gy nd lz l ma mb">data.head()<br/>##     num1   num2<br/>## 0  0.897 -1.626<br/>## 1  1.370  0.279<br/>## 2    NaN -0.652<br/>## 3  1.379 -0.164<br/>## 4  0.450    NaN</span></pre><p id="3496" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe mc md me ls b">SimpleImputer</code>将拟合的插补值存储在<code class="fe mc md me ls b">self.statistics_</code>(按照<a class="ae lc" href="https://scikit-learn.org/stable/developers/develop.html#estimated-attributes" rel="noopener ugc nofollow" target="_blank">惯例</a>拟合值总是以下划线结尾):</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="592a" class="lw lx iq ls b gy ly lz l ma mb">from sklearn.impute import SimpleImputer</span><span id="695c" class="lw lx iq ls b gy nd lz l ma mb">simple_imputer = SimpleImputer(strategy='mean')<br/>simple_imputer.fit_transform(data)<br/>## array([[ 0.897, -1.626],<br/>##        [ 1.37 ,  0.279],<br/>##        [ 0.071, -0.652],<br/>##        ...,<br/>##        [-0.233,  0.741],<br/>##        [ 0.071, -0.627],<br/>##        [-1.056, -0.622]])<br/>simple_imputer.statistics_<br/>## array([0.071, 0.016])</span></pre><p id="ab24" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们可以用这些值在我们的<code class="fe mc md me ls b">transform_single</code>中填充缺失值:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="1acb" class="lw lx iq bd mf mg mh dn mi mj mk dp ml kp mm mn mo kt mp mq mr kx ms mt mu mv bi translated">为最小变压器计时</h2><p id="8221" class="pw-post-body-paragraph kg kh iq ki b kj mw jr kl km mx ju ko kp my kr ks kt mz kv kw kx na kz la lb ij bi translated">现在让我们评估一下性能改进。我们将利用<code class="fe mc md me ls b">timeit</code>和一些简单的辅助函数来测量毫秒计时:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="27b6" class="lw lx iq ls b gy ly lz l ma mb">from timeit import timeit</span><span id="e00b" class="lw lx iq ls b gy nd lz l ma mb">def time_func_call(call: str, n: int = 1000):<br/>  t = timeit(call, globals = globals(), number=n) / n<br/>  t_ms = np.round(t * 1000, 4)<br/>  return t_ms</span><span id="d24b" class="lw lx iq ls b gy nd lz l ma mb">time_func_call('barebones_simple_imputer.transform(data)')<br/>## 3.0503<br/>time_func_call('barebones_simple_imputer.transform_single([1.2, np.nan])')<br/>## 0.0701</span></pre><p id="38ca" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们将定义另一个助手函数，它比较并输出多个函数调用的时间:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="20e8" class="lw lx iq ls b gy ly lz l ma mb">from typing import List</span><span id="a942" class="lw lx iq ls b gy nd lz l ma mb">def time_func_calls(calls: List[str]):<br/>    max_width = np.max([len(call) for call in calls])<br/>    for call in calls:<br/>        t_ms = time_func_call(call)<br/>        print(f'{call:{max_width}}: {t_ms:.4f}ms')<br/>    return</span></pre><p id="6d13" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们现在可以将此应用于数据帧和数字数组形式的多个和单个数据点:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0d2c" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">因此单数据点转换优于其他实现。让我们快速检查一下<code class="fe mc md me ls b">OneHotEncoder</code>，另一个非常有用的转换器，它用虚拟变量对分类变量进行编码。我们还将再次定义一些玩具数据:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="e32a" class="lw lx iq ls b gy ly lz l ma mb">n = 3000</span><span id="4dc4" class="lw lx iq ls b gy nd lz l ma mb">data = pd.DataFrame({<br/>    'cat1': np.random.choice(['a', 'b', 'c'], n),<br/>    'cat2': np.random.choice(['x', 'y'], n)<br/>})</span><span id="49fd" class="lw lx iq ls b gy nd lz l ma mb">data.head()<br/>##   cat1 cat2<br/>## 0    a    x<br/>## 1    b    x<br/>## 2    b    y<br/>## 3    a    x<br/>## 4    b    y</span></pre><p id="5534" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe mc md me ls b">OneHotEncoder</code>将学习到的类别存储在<code class="fe mc md me ls b">self.categories_</code>中的一个列表中，我们可以从中提取并使用它来编码分类变量:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="360e" class="lw lx iq ls b gy ly lz l ma mb">barebones_one_hot_encoder = BarebonesOneHotEncoder(sparse=<strong class="ls ir">False</strong>, handle_unknown='ignore')<br/>barebones_one_hot_encoder.fit_transform(data)<br/><em class="nf">## array([[1., 0., 0., 1., 0.],</em><br/><em class="nf">##        [0., 1., 0., 1., 0.],</em><br/><em class="nf">##        [0., 1., 0., 0., 1.],</em><br/><em class="nf">##        ...,</em><br/><em class="nf">##        [0., 0., 1., 0., 1.],</em><br/><em class="nf">##        [1., 0., 0., 1., 0.],</em><br/><em class="nf">##        [0., 1., 0., 1., 0.]])</em></span><span id="8c5e" class="lw lx iq ls b gy nd lz l ma mb">barebones_one_hot_encoder.categories_<br/><em class="nf">## [array(['a', 'b', 'c'], dtype=object), array(['x', 'y'], dtype=object)]</em></span><span id="cf15" class="lw lx iq ls b gy nd lz l ma mb">barebones_one_hot_encoder.transform_single(['b', 'x'])<br/><em class="nf">## array([0, 1, 0, 1, 0])</em></span></pre><p id="26f7" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们再次评估不同案例的基准:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="225c" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">编码器现在只需要0.02毫秒，而不是0.5毫秒，提高了大约25倍。现在，让我们将这些放在一起，测量公共管道的整体性能改进。我们将获取一些名为<a class="ae lc" href="https://www.kaggle.com/aungpyaeap/fish-market" rel="noopener ugc nofollow" target="_blank">鱼市场数据集</a>的数据集，其中包含鱼的尺寸测量和分类，我们希望在其中预测它们的重量。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8701" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">数据如下所示:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="f37d" class="lw lx iq ls b gy ly lz l ma mb">x.head()<br/>##   species  length1  length2  length3  height  width<br/>## 0   Bream     23.2     25.4     30.0  11.520  4.020<br/>## 1     NaN     24.0     26.3     31.2  12.480  4.306<br/>## 2   Bream     23.9     26.5     31.1  12.378  4.696<br/>## 3   Bream     26.3     29.0     33.5  12.730  4.455<br/>## 4   Bream     26.5     29.0     34.0  12.444  5.134<br/>y.head()<br/>## 0    242.0<br/>## 1    290.0<br/>## 2    340.0<br/>## 3    363.0<br/>## 4    430.0<br/>## Name: weight, dtype: float64</span></pre><p id="d565" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果我们想对我们的数据进行插补和一次性编码，我们需要使用<code class="fe mc md me ls b">ColumnTransformers</code>将转换分派到正确的列。因此，我们需要对它做一些小的修改，以便能够使用<code class="fe mc md me ls b">transform_single</code>方法:</p><ul class=""><li id="a579" class="ng nh iq ki b kj kk km kn kp ni kt nj kx nk lb nl nm nn no bi translated">执行<code class="fe mc md me ls b">transform_single</code>类似于<code class="fe mc md me ls b">transform</code>，用于ex。使用<a class="ae lc" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/compose/_column_transformer.py#L235-L270" rel="noopener ugc nofollow" target="_blank">自我。_iter </a></li><li id="674e" class="ng nh iq ki b kj np km nq kp nr kt ns kx nt lb nl nm nn no bi translated">用<code class="fe mc md me ls b">transform_single</code>实现一个身份转换器，可以传递它来处理剩余的<a class="ae lc" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/compose/_column_transformer.py#L79-L91" rel="noopener ugc nofollow" target="_blank"/>，即剩余的列</li></ul><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="7dd5" class="lw lx iq bd mf mg mh dn mi mj mk dp ml kp mm mn mo kt mp mq mr kx ms mt mu mv bi translated">建立快速管道</h2><p id="22f0" class="pw-post-body-paragraph kg kh iq ki b kj mw jr kl km mx ju ko kp my kr ks kt mz kv kw kx na kz la lb ij bi translated">如果我们想在管道中使用基本的转换器和估算器，我们也必须修改管道本身，通过添加一个类似于<a class="ae lc" href="https://github.com/scikit-learn/scikit-learn/blob/0fb307bf39bbdacd6ed713c00724f8f871d60370/sklearn/pipeline.py#L382-L408" rel="noopener ugc nofollow" target="_blank">预测</a>的<code class="fe mc md me ls b">predict_single</code>，它使用转换器的<code class="fe mc md me ls b">transform_single</code>方法并调用模型的<code class="fe mc md me ls b">predict_single</code>，正如Max在他的帖子中所描述的。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7b0b" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们现在可以构建我们的管道。我们将用最常见的值估算分类变量，用平均值估算数值(这里不是最聪明的估算方法，因为两者之间存在很强的关系，条件平均值或最近邻法会更好)。然后，我们将对分类变量进行一次性编码，并根据数据训练一个线性模型。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2ad7" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在，让我们将管道应用于我们的数据，对单个预测的性能进行基准测试:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="69f4" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们最后评价一下，这两个预测是相同的。运行<code class="fe mc md me ls b">predict</code>仍然使用成熟的sklearn代码路径，与我们的轻量级<code class="fe mc md me ls b">{transform,predict}_single</code>方法相反:</p><pre class="lg lh li lj gt lr ls lt lu aw lv bi"><span id="300e" class="lw lx iq ls b gy ly lz l ma mb">batch_predictions = barebones_pipeline.predict(x)<br/>batch_predictions[0:5]<br/>## array([285.874, 418.604, 363.433, 417.214, 459.909])</span><span id="549c" class="lw lx iq ls b gy nd lz l ma mb">single_predictions = [barebones_pipeline.predict_single(x_i) for x_i in x.to_numpy()]<br/>single_predictions[0:5]<br/>## [285.873, 418.603, 363.433, 417.214, 459.909]</span><span id="7d6f" class="lw lx iq ls b gy nd lz l ma mb">np.all(np.isclose(batch_predictions, single_predictions, atol = 0.0001))<br/>## True</span></pre><h2 id="970d" class="lw lx iq bd mf mg mh dn mi mj mk dp ml kp mm mn mo kt mp mq mr kx ms mt mu mv bi translated">结论</h2><p id="4f1f" class="pw-post-body-paragraph kg kh iq ki b kj mw jr kl km mx ju ko kp my kr ks kt mz kv kw kx na kz la lb ij bi translated">我们发现，对于单次预测(2.4毫秒到0.1毫秒)，我们可以将流水线速度提高20到25倍。但是我们添加的转换越多，加速就越有价值，权衡也就越清晰。我们已经看到了如何使用定制的转换器或调整现有的转换器来加速单个数据点转换和预测，代价是在工程上花费了额外的时间(尤其是在转换更复杂的情况下)，以及在训练-推理奇偶校验、单元测试和数据验证上花费了额外的精力。</p><h2 id="38ef" class="lw lx iq bd mf mg mh dn mi mj mk dp ml kp mm mn mo kt mp mq mr kx ms mt mu mv bi translated">备注:分析变压器</h2><p id="b946" class="pw-post-body-paragraph kg kh iq ki b kj mw jr kl km mx ju ko kp my kr ks kt mz kv kw kx na kz la lb ij bi translated">如果你试图找到你的变压器的瓶颈，我推荐使用<a class="ae lc" href="https://nyu-cds.github.io/python-performance-tuning/03-line_profiler/" rel="noopener ugc nofollow" target="_blank">线路分析器</a>和<a class="ae lc" href="https://scikit-learn.org/stable/developers/performance.html#memory-usage-profiling" rel="noopener ugc nofollow" target="_blank">内存分析器</a>。它们可能在整个管道上都是不可监督的(您必须将所有单独的功能传递给它)，但是在单独的转换器上是可监督的。您可以通过以下方式神奇地使用分析器:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="dad1" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">或者没有魔法:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="181b" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">【https://blog.telsemeyer.com】最初发表于<a class="ae lc" href="https://blog.telsemeyer.com/2020/08/13/speeding-up-a-sklearn-model-pipeline-to-serve-single-predictions-with-very-low-latency/" rel="noopener ugc nofollow" target="_blank"><em class="nf"/></a><em class="nf">。</em></p></div></div>    
</body>
</html>