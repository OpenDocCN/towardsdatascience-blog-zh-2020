<html>
<head>
<title>15 ways to create a Pandas DataFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建熊猫数据框架的15种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/15-ways-to-create-a-pandas-dataframe-754ecc082c17?source=collection_archive---------0-----------------------#2020-10-28">https://towardsdatascience.com/15-ways-to-create-a-pandas-dataframe-754ecc082c17?source=collection_archive---------0-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eca5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">关于用熊猫创建</em>数据框的不同方法的学习参考</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/0340404c94b5f675e3f296030af534a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H31qxixVfSo9IpNANY8P_Q.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="b2ad" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">动机</h1><p id="d695" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在进行EDA(探索性数据分析)或开发/测试模型时，使用强大而优雅的pandas DataFrame来存储和操作数据是非常常见的。通常，它从“创建数据帧”开始。</p><p id="656e" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我在用pandas开始一些EDA或建模时，通常会遇到以下场景:</p><blockquote class="mw mx my"><p id="960b" class="lv lw mz lx b ly mr jr ma mb ms ju md na mt mg mh nb mu mk ml nc mv mo mp mq ij bi translated">我需要快速创建一些记录的数据帧来测试代码。</p><p id="067b" class="lv lw mz lx b ly mr jr ma mb ms ju md na mt mg mh nb mu mk ml nc mv mo mp mq ij bi translated">我需要将csv或json文件加载到数据帧中。</p><p id="a9c2" class="lv lw mz lx b ly mr jr ma mb ms ju md na mt mg mh nb mu mk ml nc mv mo mp mq ij bi translated">我需要从网页中读取一个HTML表格到数据帧中</p><p id="6bea" class="lv lw mz lx b ly mr jr ma mb ms ju md na mt mg mh nb mu mk ml nc mv mo mp mq ij bi translated">我需要在不创建json文件的情况下将类似json的记录加载到dataframe中</p><p id="3794" class="lv lw mz lx b ly mr jr ma mb ms ju md na mt mg mh nb mu mk ml nc mv mo mp mq ij bi translated">我需要在不创建csv文件的情况下将类似csv的记录加载到数据帧中</p><p id="a11c" class="lv lw mz lx b ly mr jr ma mb ms ju md na mt mg mh nb mu mk ml nc mv mo mp mq ij bi translated">我需要合并两个数据帧，垂直或水平</p><p id="cc8a" class="lv lw mz lx b ly mr jr ma mb ms ju md na mt mg mh nb mu mk ml nc mv mo mp mq ij bi translated">我必须将数据帧中的一列转换成一个热列</p></blockquote><p id="4ba3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">每一个场景都让我每次都用谷歌搜索语法或查找文档，直到我通过几个月或几年的练习慢慢记住它们。</p><p id="9c61" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">理解了查找的痛苦，我认为在pandas中创建数据帧的多种方法的快速查找表可以节省一些时间。这可能会帮助学习者，直到他们成为经验丰富的数据分析师或数据科学家。</p><p id="5013" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这里有几种方法可以创建一个数据框架。如果任何读到这里的人发现了其他优雅的方式或方法，请随时评论或给我发消息；我很乐意将它们添加到您的参考页面中。</p><h1 id="8df2" class="ld le iq bd lf lg nd li lj lk ne lm ln jw nf jx lp jz ng ka lr kc nh kd lt lu bi translated">使用DataFrame构造函数pd。数据帧()</h1><p id="1d71" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">pandas DataFrame()构造函数提供了许多不同的方法来创建和初始化DataFrame。</p><ul class=""><li id="4bba" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法0 </strong> —初始化空白数据帧，并不断添加记录。columns属性是成为数据帧的列的字符串列表。loc方法通过索引引用数据帧行(类似于列表)。例如，数据帧df中的第一条记录将被df.loc[0]引用，第二条记录将被df.loc[1]引用。通过设置df.loc[i] = &lt;记录属性为列表&gt;，可以直接在位置I增加一行</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="fe24" class="nw le iq ns b gy nx ny l nz oa"><em class="mz"># method 0</em></span><span id="061e" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># Initialize a blank dataframe and keep adding</em></span><span id="f865" class="nw le iq ns b gy ob ny l nz oa">df = pd.DataFrame(columns = ['year','make','model'])</span><span id="12e9" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># Add records to dataframe</em> <em class="mz">using the .loc function</em></span><span id="3fb3" class="nw le iq ns b gy ob ny l nz oa">df.loc[0] = [2014,"toyota","corolla"] <br/>df.loc[1] = [2018,"honda","civic"] </span><span id="b9a4" class="nw le iq ns b gy ob ny l nz oa">df</span></pre><ul class=""><li id="0f98" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法1 </strong> —在DataFrame构造函数中使用numpy数组。传递2D numpy数组—每个数组都是数据帧中的相应行</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="2c9c" class="nw le iq ns b gy nx ny l nz oa"><em class="mz"># Pass a 2D numpy array - each row is the corresponding row required in the dataframe</em><br/><br/>data = np.array([[2014,"toyota","corolla"], <br/>                 [2018,"honda","civic"], <br/>                 [2020,"hyndai","accent"], <br/>                 [2017,"nissan","sentra"]]) <br/><br/><em class="mz"># pass column names in the columns parameter </em><br/>df = pd.DataFrame(data, columns = ['year', 'make','model'])<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2cd399cfc8c39a9aedbbc6bc169f0b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*qu312ROYC-IHtuYO42Mb4w.png"/></div></figure><ul class=""><li id="3b00" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法2 </strong> —在DataFrame构造函数中使用字典。字典键成为数据帧中的列名。字典值成为列的值。列值根据指定的顺序组合在一行中</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="21b8" class="nw le iq ns b gy nx ny l nz oa">data = {'year': [2014, 2018,2020,2017], <br/>        'make': ["toyota", "honda","hyndai","nissan"],<br/>        'model':["corolla", "civic","accent","sentra"]<br/>       }<br/><br/><em class="mz"># pass column names in the columns parameter </em><br/>df = pd.DataFrame(data)<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2cd399cfc8c39a9aedbbc6bc169f0b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*qu312ROYC-IHtuYO42Mb4w.png"/></div></figure><ul class=""><li id="518d" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法3 </strong> —在DataFrame构造函数中使用字典列表。每本词典都是一个记录。字典键成为数据帧中的列名。字典值成为列的值</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="3f2c" class="nw le iq ns b gy nx ny l nz oa">data = [{'year': 2014, 'make': "toyota", 'model':"corolla"}, <br/>        {'year': 2018, 'make': "honda", 'model':"civic"}, <br/>        {'year': 2020, 'make': "hyndai", 'model':"nissan"}, <br/>        {'year': 2017, 'make': "nissan" ,'model':"sentra"}<br/>       ]<br/><em class="mz"># pass column names in the columns parameter </em><br/>df = pd.DataFrame(data)<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2cd399cfc8c39a9aedbbc6bc169f0b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*qu312ROYC-IHtuYO42Mb4w.png"/></div></figure><ul class=""><li id="1f00" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法4 </strong> —在from_dict方法中使用字典。字典键成为数据帧中的列名。字典值成为列的值。列值根据它们被指定的顺序组合在一行中<em class="mz">。</em></li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="a489" class="nw le iq ns b gy nx ny l nz oa">data = {'year': [2014, 2018,2020,2017], <br/>        'make': ["toyota", "honda","hyndai","nissan"],<br/>        'model':["corolla", "civic","accent","sentra"]<br/>       }<br/><br/><em class="mz"># pass column names in the columns parameter </em><br/>df = pd.DataFrame.from_dict(data)<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi od"><img src="../Images/772f34bd8f16a5d80f4a3d7da243bd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*YBDeAevVQSVGSELhrp0AAA.png"/></div></figure><p id="b2c9" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><strong class="lx ir">注意</strong> : <em class="mz">虽然方法2和方法4都是字典，但两者还是有区别的。使用from_dict，我们能够选择任何列作为数据帧的索引。如果我们上面使用的列名需要成为索引——比如早期数据的转置——会怎么样？为转置后生成的列指定orient = "index "并传递列名</em></p><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="7a36" class="nw le iq ns b gy nx ny l nz oa">df = pd.DataFrame.from_dict(data, orient='index',columns=['record1', 'record2', 'record3', 'record4'])<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/95f50ec3655895ce4cdd585dfaba4ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*SsEkEFGRy3DPiAgkoZZ0JQ.png"/></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="af98" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">使用pandas库函数— read_csv、read_json</h1><ul class=""><li id="c818" class="ni nj iq lx b ly lz mb mc me of mi og mm oh mq nn no np nq bi translated"><strong class="lx ir">方法5 </strong> —使用pandas库的read_csv方法从csv文件中获取。这是为EDA创建数据帧的最常见方式之一。csv文件中的分隔符(或分隔符)、标题和索引列的选择是可配置的。默认情况下，分隔符是逗号，标题是从第一行推断出来的(如果找到的话)，索引列不是从文件中提取的。该文件如下所示:</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f9116d9d04995e71339b39ad72a9947a.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*1YHzjnBxn1_pZHpOZXvNbQ.png"/></div></figure><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="e273" class="nw le iq ns b gy nx ny l nz oa">df = pd.read_csv('data.csv' , sep = ',', header = 'infer', index_col = None)<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi od"><img src="../Images/772f34bd8f16a5d80f4a3d7da243bd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*YBDeAevVQSVGSELhrp0AAA.png"/></div></figure><ul class=""><li id="3108" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法6 </strong> —使用熊猫库<em class="mz">的read_csv方法从一串csv记录中。</em>当我们不想创建文件但手头有记录结构时，这特别有用——我们所做的就是使用StringIO库函数将csv记录“字符串”转换为文件句柄。</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="b336" class="nw le iq ns b gy nx ny l nz oa">from io import StringIO</span><span id="61c5" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># f is a file handle created from a csv like string</em></span><span id="b615" class="nw le iq ns b gy ob ny l nz oa">f = StringIO('year,make,model\n2014,toyota,corolla\n2018,honda,civic\n2020,hyndai,accent\n2017,nissan,sentra')</span><span id="9b04" class="nw le iq ns b gy ob ny l nz oa">df = pd.read_csv(f)<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi od"><img src="../Images/772f34bd8f16a5d80f4a3d7da243bd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*YBDeAevVQSVGSELhrp0AAA.png"/></div></figure><ul class=""><li id="f4c2" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法7 </strong> —当json文件每行都有记录时，使用pandas库的read_json方法从json文件中获取。设置lines=True意味着每行将文件作为json对象读取。下面是json文件的样子:</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7410e83cd89391fbd2128770089bce73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*Jy5uptrvI16g16bbcjcnVw.png"/></div></figure><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="e076" class="nw le iq ns b gy nx ny l nz oa">df = pd.read_json('data.json',lines=True)<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi od"><img src="../Images/772f34bd8f16a5d80f4a3d7da243bd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*YBDeAevVQSVGSELhrp0AAA.png"/></div></figure><ul class=""><li id="c9ee" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法8 </strong> —使用pandas库的read_json方法从一串json记录中。当我们不想创建文件，但手头有json记录结构时，这特别有用。</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="f400" class="nw le iq ns b gy nx ny l nz oa">from io import StringIO</span><span id="9c49" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># f is a file handle created from json like string</em></span><span id="2657" class="nw le iq ns b gy ob ny l nz oa">f = StringIO('{"year": "2014", "make": "toyota", "model": "corolla"}\n{"year": "2018", "make": "honda", "model": "civic"}\n{"year": "2020", "make": "hyndai", "model": "accent"}\n{"year": "2017", "make": "nissan", "model": "sentra"}')</span><span id="cf41" class="nw le iq ns b gy ob ny l nz oa">df = pd.read_json(f,lines=True)<br/>df</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi od"><img src="../Images/772f34bd8f16a5d80f4a3d7da243bd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*YBDeAevVQSVGSELhrp0AAA.png"/></div></figure><ul class=""><li id="6802" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法9 </strong> — <em class="mz">最有趣的方法之一</em> —使用read_html中内置的pandas库从HTML页面中读取表格。这将生成一个数据帧列表；在后台，它抓取html页面中的任何&lt;表&gt;标签，并试图将该表捕获到一个数据帧中。即使页面中只有一个表，也会创建一个数据帧列表，因此需要使用列表下标来访问它。下面的例子展示了如何捕获一个HTML页面，然后加载表——这使用请求库来获取HTML内容。</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="9e9a" class="nw le iq ns b gy nx ny l nz oa">import requests<br/><br/>url = 'https://www.goodcarbadcar.net/2020-us-vehicle-sales-figures-by-brand'</span><span id="c2f4" class="nw le iq ns b gy ob ny l nz oa">r = requests.get(url)</span><span id="8c9c" class="nw le iq ns b gy ob ny l nz oa"><em class="mz">#if the response status is OK (200)</em><br/>if r.status_code == 200:</span><span id="628e" class="nw le iq ns b gy ob ny l nz oa">    <em class="mz"># from the response object, pass the response text <br/>    # to read_html and get list of tables as list of dataframes</em><br/>    <br/>     car_data_tables = pd.read_html(r.text)<br/><br/><em class="mz"># display the first table</em><br/>car_data_tables[0]</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ok"><img src="../Images/b43da7d1eba3da15cd2c648f60e76ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RU1tLLH31SCU76GS_8Cyw.png"/></div></div></figure><h1 id="98a0" class="ld le iq bd lf lg nd li lj lk ne lm ln jw nf jx lp jz ng ka lr kc nh kd lt lu bi translated">从其他数据帧</h1><ul class=""><li id="efff" class="ni nj iq lx b ly lz mb mc me of mi og mm oh mq nn no np nq bi translated"><strong class="lx ir">方法10 </strong> —作为另一个数据帧的副本<em class="mz">。</em></li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="43fa" class="nw le iq ns b gy nx ny l nz oa">df_copy = df.copy()   # copy into a new dataframe object<br/>df_copy = df          # make an alias of the dataframe(not creating <br/>                      # a new dataframe, just a pointer)</span></pre><p id="86ab" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><strong class="lx ir">注意</strong>:上面显示的两种方法是不同的——copy()函数创建一个全新的独立于原始数据帧的数据帧对象，而变量copy方法只是为原始数据帧创建一个别名变量——没有创建新的数据帧对象。如果原始数据帧有任何更改，也会反映在别名中，如下所示:</p><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="d28f" class="nw le iq ns b gy nx ny l nz oa"><em class="mz"># as a new object using .copy() method - new dataframe object created independent of old one</em></span><span id="3557" class="nw le iq ns b gy ob ny l nz oa">a = pd.DataFrame({'year': [2019],'make': ["Mercedes"],'model':["C-Class"]})</span><span id="6025" class="nw le iq ns b gy ob ny l nz oa">b = a.copy()</span><span id="9792" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># change old one</em><br/>a['year'] = 2020</span><span id="fd72" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># new copy does not reflect the change</em><br/>b</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/36e064e54da64b229c8555492da9dffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*jOfV7j4x_SAncbRyY1h67A.png"/></div></figure><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="0d8f" class="nw le iq ns b gy nx ny l nz oa"><em class="mz"># as variable copy - new variable is just an alias to the old one</em></span><span id="98e4" class="nw le iq ns b gy ob ny l nz oa">a = pd.DataFrame({'year': [2019],'make': ["Mercedes"],'model':["C-Class"]})</span><span id="684e" class="nw le iq ns b gy ob ny l nz oa">b = a</span><span id="0298" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># change old one</em><br/>a['year'] = 2020</span><span id="ff73" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># alias reflects the change</em><br/>b</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi om"><img src="../Images/65ab43ff1ddea4dad9c17dc4d3c66781.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*hKdLXM916QK5ohdJW9j2Ow.png"/></div></div></figure><ul class=""><li id="b40f" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法11 </strong> —垂直连接—一个在另一个之上</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="fdc5" class="nw le iq ns b gy nx ny l nz oa">data1 = [{'year': 2014, 'make': "toyota", 'model':"corolla"}, <br/>        {'year': 2018, 'make': "honda", 'model':"civic"}, <br/>        {'year': 2020, 'make': "hyndai", 'model':"nissan"}, <br/>        {'year': 2017, 'make': "nissan" ,'model':"sentra"}<br/>       ]</span><span id="157c" class="nw le iq ns b gy ob ny l nz oa">df1 = pd.DataFrame(data1)</span><span id="2908" class="nw le iq ns b gy ob ny l nz oa">data2 = [{'year': 2019, 'make': "bmw", 'model':"x5"}]</span><span id="339c" class="nw le iq ns b gy ob ny l nz oa">df2 = pd.DataFrame(data2)</span><span id="a127" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># concatenate vertically<br/># NOTE: axis = 'index' is same as axis = 0, and is the default <br/># The two statements below mean the same as the one above</em></span><span id="c2f6" class="nw le iq ns b gy ob ny l nz oa">df3 = pd.concat([df1,df2], axis = 'index') </span><span id="112c" class="nw le iq ns b gy ob ny l nz oa"><em class="mz">#OR</em></span><span id="6fa5" class="nw le iq ns b gy ob ny l nz oa">df3 = pd.concat([df1,df2], axis = 0)</span><span id="6a4e" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># OR</em></span><span id="ea0f" class="nw le iq ns b gy ob ny l nz oa">df3 = pd.concat([df1,df2])</span><span id="a027" class="nw le iq ns b gy ob ny l nz oa">df3</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi on"><img src="../Images/d5f49859afc61d89348e76425324734a.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*zgNNmVwKRD25OOMkr9RnLQ.png"/></div></figure><p id="db10" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在上面的例子中，第二个数据帧的索引保留在连接的数据帧中。要重置索引以匹配整个数据帧，请使用数据帧的reset_index()函数</p><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="3627" class="nw le iq ns b gy nx ny l nz oa">df3 = pd.concat([df1,df2]).reset_index()</span><span id="2393" class="nw le iq ns b gy ob ny l nz oa"><em class="mz">#OR</em></span><span id="f3a4" class="nw le iq ns b gy ob ny l nz oa">df3 = pd.concat([df1,df2], ignore_index = True)<br/>df3</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/53e04b8cb1a7cb610ded553191d1c563.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*OZhyjW_H4uWSt3AgRbUaTA.png"/></div></figure><ul class=""><li id="6e56" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法12 </strong> —水平连接—并排追加，不用任何键连接</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="f10a" class="nw le iq ns b gy nx ny l nz oa">data1 = [{'year': 2014, 'make': "toyota", 'model':"corolla"}, <br/>        {'year': 2018, 'make': "honda", 'model':"civic"}, <br/>        {'year': 2020, 'make': "hyndai", 'model':"nissan"}, <br/>        {'year': 2017, 'make': "nissan" ,'model':"sentra"}<br/>       ]</span><span id="4908" class="nw le iq ns b gy ob ny l nz oa">df1 = pd.DataFrame(data1)</span><span id="3d2a" class="nw le iq ns b gy ob ny l nz oa">data2 = [{'year': 2019, 'make': "bmw", 'model':"x5"}]</span><span id="7bc4" class="nw le iq ns b gy ob ny l nz oa">df2 = pd.DataFrame(data2)</span><span id="ddca" class="nw le iq ns b gy ob ny l nz oa">df3 = pd.concat([df1,df2], axis = 'columns')</span><span id="8bd2" class="nw le iq ns b gy ob ny l nz oa"><em class="mz">#OR</em></span><span id="ea70" class="nw le iq ns b gy ob ny l nz oa">df3 = pd.concat([df1,df2], axis = 1)</span><span id="15d8" class="nw le iq ns b gy ob ny l nz oa">df3</span></pre><p id="095c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><strong class="lx ir">注意:</strong>对于水平拼接，</p><ul class=""><li id="c330" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated">数据帧的行按照它们的位置(索引)顺序连接</li><li id="0599" class="ni nj iq lx b ly op mb oq me or mi os mm ot mq nn no np nq bi translated">如果其中一个数据帧中有任何记录丢失，则串接的数据帧中的相应记录将丢失。这与在索引上进行左外连接是一样的(参见下面的合并)</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/926d13cfe9a50b88677a160a8645f5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*ABZd4NwFFTKn59IPc_dLtQ.png"/></div></figure><ul class=""><li id="5692" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法13 </strong> —水平连接—相当于SQL连接。</li></ul><p id="60ed" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">内部连接</p><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="384e" class="nw le iq ns b gy nx ny l nz oa">data1 = [{'year': 2014, 'make': "toyota", 'model':"corolla"}, <br/>        {'year': 2018, 'make': "honda", 'model':"civic"}, <br/>        {'year': 2020, 'make': "hyndai", 'model':"nissan"}, <br/>        {'year': 2017, 'make': "nissan" ,'model':"sentra"}<br/>       ]</span><span id="5c14" class="nw le iq ns b gy ob ny l nz oa">df1 = pd.DataFrame(data1)</span><span id="7c97" class="nw le iq ns b gy ob ny l nz oa">data2 = [{'make': 'honda', 'Monthly Sales': 114117}, <br/>        {'make': 'toyota', 'Monthly Sales': 172370}, <br/>        {'make': 'hyndai', 'Monthly Sales': 54790}<br/>       ]</span><span id="72d0" class="nw le iq ns b gy ob ny l nz oa">df2 = pd.DataFrame(data2)</span><span id="e736" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># inner join on 'make'<br/># default is inner join</em></span><span id="02ca" class="nw le iq ns b gy ob ny l nz oa">df3 = pd.merge(df1,df2,how = 'inner',on = ['make'])<br/>df3 = pd.merge(df1,df2,on = ['make'])</span><span id="e7e5" class="nw le iq ns b gy ob ny l nz oa">df3</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/5ceee109d0becc6ae8b93815b400ba50.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*UVcU5HRXnltAshY85Mukwg.png"/></div></figure><p id="b5ab" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">左连接</p><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="bf0f" class="nw le iq ns b gy nx ny l nz oa"><em class="mz"># for a left join , use how = 'left'</em><br/>df3 = pd.merge(df1,df2,how = 'left',on = ['make'])</span><span id="30e8" class="nw le iq ns b gy ob ny l nz oa">df3</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/d1956bfe9d1b93a4b8b7221a62113495.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*oGZckrPOpI-EhDDW1Li8aA.png"/></div></figure><ul class=""><li id="3968" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法14 </strong> —作为另一个数据帧的转置</li></ul><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="7fc2" class="nw le iq ns b gy nx ny l nz oa"><em class="mz"># To transpose a dataframe - use .T method</em><br/>df4 = df3.T</span><span id="982d" class="nw le iq ns b gy ob ny l nz oa"><em class="mz"># To rename columns to anything else after the transpose</em><br/>df4.columns = (['column1','column2','column3','column4'])</span><span id="ea5c" class="nw le iq ns b gy ob ny l nz oa">df4</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/6157fcbe265d2ca911582975af1b20d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*bMoIRQKLdiYqjphDB_gwaw.png"/></div></figure><ul class=""><li id="b747" class="ni nj iq lx b ly mr mb ms me nk mi nl mm nm mq nn no np nq bi translated"><strong class="lx ir">方法15 </strong> —使用pandas get_dummies函数转换为一个热点列(用于学习算法建模)。</li></ul><p id="4c66" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">One-Hot基本上是将一个列值转换成一组派生列，就像二进制表示一样。one-hot列集合中的任何一个都是1，其余的是0。</p><p id="69b7" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果我们知道一辆汽车的车身类型=轿车、SUV、货车、卡车，那么车身= '轿车'的丰田卡罗拉将成为one-hot编码为</p><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="c00d" class="nw le iq ns b gy nx ny l nz oa">body_SEDAN   body_SUV    body_VAN   body_TRUCK<br/>1             0               0         0</span></pre><p id="71e8" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">每个热列的格式基本上都是<em class="mz"> &lt;原始_列名&gt; _ &lt;可能_值&gt; </em></p><p id="d91f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">下面是一个例子:</p><pre class="kh ki kj kk gt nr ns nt nu aw nv bi"><span id="94d2" class="nw le iq ns b gy nx ny l nz oa">data1 = [{ 'make': "toyota", 'model':"corolla", 'body':"sedan"}, <br/>        {'make': "honda", 'model':"crv", 'body':"suv"}, <br/>        {'make': "dodge", 'model':"caravan", 'body':"van"}, <br/>        {'make': "ford" ,'model':"f150", 'body':"truck"}<br/>       ]</span><span id="1d25" class="nw le iq ns b gy ob ny l nz oa">df1 = pd.DataFrame(data1) <br/><br/>df2 = pd.get_dummies(df1,columns = ['body'])<br/>df2</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/79c2eb0963a4e12493828351ee241dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*g6EEuoNd6qiZEbVHU_QlEQ.png"/></div></figure><p id="16c2" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我希望这个“备忘单”在学习EDA或建模的初始阶段有所帮助。当然，随着时间的推移和不断的练习，所有这些都会被记住。</p><p id="5f92" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">那么祝你一切顺利:)</p><p id="72a9" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果您有任何其他创建数据帧的好方法，或者有任何新的函数可以为某些特定目的创建数据帧，请分享您的宝贵意见。</p><p id="6ed0" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这个笔记本的git链接是这里的<a class="ae oz" href="https://github.com/jchowdhury82/Tutorials/blob/main/Notebooks/15_ways_to_create_DataFrame_Pandas.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>