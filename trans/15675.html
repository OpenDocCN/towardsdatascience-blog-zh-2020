<html>
<head>
<title>Advanced Morse Code Decoder in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的高级莫尔斯码解码器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-morse-code-decoder-in-python-16e93d0af3d8?source=collection_archive---------32-----------------------#2020-10-28">https://towardsdatascience.com/advanced-morse-code-decoder-in-python-16e93d0af3d8?source=collection_archive---------32-----------------------#2020-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1689feccf05ada980befcbca9e8fbb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i8xr66Apn8QCu6W8.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者Rhey t . Snodgrass&amp;Victor f . Camp，1922 — Image:Intcode.png和Image:国际莫尔斯code.png，公共领域，<a class="ae kf" href="https://commons.wikimedia.org/w/index.php?curid=3902977" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=3902977</a></p></figure><p id="d552" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我之前的一篇<a class="ae kf" rel="noopener" target="_blank" href="/simple-morse-code-decoder-in-python-39f6db635af2">帖子</a>中，我用Python设计了一个简单的莫尔斯码解码器，它能够接受用户输入，并以原始的字母数字形式输出。解码器的局限性之一是它不允许用户输入句子。请记住，我们选择用一系列“0”和“1”来表示每个字母或数字，其中<strong class="ki iu">“0”表示一个点</strong>，而<strong class="ki iu">“1”表示一个破折号</strong>。在我们的解码器中，每个字母或数字由一个“*”分隔，如下图所示。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/453e238ee975e5688898b73d79274c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dwxe25tXPPB13Mqy.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片作者——简单莫尔斯码解码器的Python输出</p></figure><p id="9b7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们将改进我们简单的莫尔斯电码解码器，使其也能破译句子。此外，我们可以在解码器中执行检查，以通知我们每个字母/数字、单词或句子类型被解码的频率。</p><h1 id="1e58" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">构建解码器类</h1><p id="0135" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">这个解码器和前一个解码器的一个主要区别是，我们将使用Python类来构建我们的解码器和相应的分析检查。关于Python类的一个简单解释是，它定义了一组<em class="mm">实例变量</em>(要为每个对象表示的数据值)和一组可以应用于对象的<em class="mm">方法</em>(操作)。</p><p id="b4e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将构建一个名为<strong class="ki iu"> Decoder </strong>的类，它将包含几个方法，第一个是<strong class="ki iu"> __init__(self) </strong>。这是创建对象的基本方法，它通常初始化每个对象的实例变量的值。请记住，我们选择使用字典结构来存储Python中的莫尔斯电码表示，其中每个字母或数字由一系列“0”和“1”表示。由于我们还添加了句子分析检查，我们还添加了三个标点符号“<strong class="ki iu"> <em class="mm">”。</em> </strong>、<strong class="ki iu">、、</strong>、<strong class="ki iu">、<em class="mm">？</em> </strong>”。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="886f" class="ms lk it mo b gy mt mu l mv mw">class Decoder:</span><span id="a7aa" class="ms lk it mo b gy mx mu l mv mw">    def __init__(self):<br/>        self.the_dict = dict(zip(('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9','.',',','?'),('01','1000','1010','100','0','0010','110','0000','00','0111','101','0100','11','10','111','0110','1101','010','000','1','001','0001','011','1001','1011','1100','11111','01111','00111','00011','00001','00000','10000','11000','11100','11110','010101','110011','001100')))<br/>        </span></pre><p id="5efd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建类的下一个基本方法是返回/打印输出。仅仅使用<strong class="ki iu"> __init__ </strong> <strong class="ki iu"> (self) </strong>方法，如果我们将一个变量赋给这个类，我们不能显示任何结果。我们将添加一个<strong class="ki iu"> __str__ </strong> <strong class="ki iu"> (self) </strong>方法，其工作方式与<strong class="ki iu">print(variable)</strong>相同，但允许我们自定义结果的显示方式。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="28df" class="ms lk it mo b gy mt mu l mv mw">def __str__ (self):<br/>        dict_str = ""<br/>        for key,value in self.the_dict.items():<br/>            dict_str += "Character: " + str(key) + " -&gt;" + " Code: " + str(value) + "\n"<br/>        return dict_str</span></pre><p id="7ee4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们定义了上面的两个方法，我们就可以通过给类分配一个变量名并打印结果来尝试显示我们之前定义的字典结构。注意<em class="mm"> my_dict </em>现在是类<em class="mm"> Decoder的一个对象。</em></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/92da484a153adae336d11d0261907ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*CIOvpcoAW-TUzz98bHBgQA.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">按作者分类的图像-解码器类的Python输出</p></figure><p id="8d1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在本课程中定义的最后一种方法是莫尔斯电码本身的解码，称为<strong class="ki iu"> decode (self，morse_code_sequence) </strong>。注意，在这个方法中，除了定义<strong class="ki iu"> self，</strong>我们增加了另一个<strong class="ki iu"> morse_code_sequence </strong>。这意味着要调用这个方法，我们必须通过这个方法传递一个变量(即莫尔斯电码序列)，这类似于调用一个函数并通过它传递一个值。我们还将在我们的<a class="ae kf" rel="noopener" target="_blank" href="/simple-morse-code-decoder-in-python-39f6db635af2">简单莫尔斯码解码器</a>中加入我们之前实现的错误检查，主要是:</p><ol class=""><li id="6426" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated">用户只能输入0、1和*</li><li id="d0ab" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">用户只能输入预先定义的莫尔斯电码表示法(例如0000000不是有效的表示法)</li><li id="f7fd" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">莫尔斯电码序列必须以标点符号结尾(如句号、逗号或问号)</li></ol><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="d61a" class="ms lk it mo b gy mt mu l mv mw">def decode (self,morse_code_sequence):<br/>        character = list(self.the_dict.keys())<br/>        code = list(self.the_dict.values())<br/>        reverse_dict = dict(zip(code,character))      <br/>        # Error check 1, checking for invalid characters (i.e. other than 0,1,*)<br/>        i=0<br/>        while i!=len(morse_code_sequence):<br/>            if morse_code_sequence[i]=="0" or morse_code_sequence[i]=="1" or morse_code_sequence[i]=="*":<br/>                i += 1<br/>            else:<br/>                return "Invalid characters in morse code sequence, it should only consists of 0, 1 and *"<br/>                break</span><span id="4817" class="ms lk it mo b gy mx mu l mv mw">        # Proceed for error check 2 once the morse_code_sequence does not contain invalid characters<br/>        if i == len(morse_code_sequence):<br/>            splitted_morse_code_sequence = morse_code_sequence.split("***") <br/>            morse_code_word = []<br/>            for j in range(0,len(splitted_morse_code_sequence)):<br/>                morse_code_word.append(splitted_morse_code_sequence[j].split("*")) #[['001','100','110'], ['90','9','9'], ['abc','17']] <br/>            morse_code_char=[]<br/>            # Initialise a result list as the format of morse_code_word<br/>            result = morse_code_word<br/>            # split into list containing all character's morse code<br/>            for k in range(0,len(morse_code_word)):<br/>                for l in range (0,len(morse_code_word[k])):<br/>                    morse_code_char.append(morse_code_word[k][l])<br/>            # Check 2, terminate with punctuation marks i.e 010101, 110011, 001100<br/>            if morse_code_char[len(morse_code_char)-1]=="010101" or morse_code_char[len(morse_code_char)-1]=="110011" or morse_code_char[len(morse_code_char)-1]=="001100" :</span><span id="1ad0" class="ms lk it mo b gy mx mu l mv mw">                # Check 3, check if character's morse code representation is valid as per the dictionary<br/>                for k in range(0,len(morse_code_word)):<br/>                    for l in range (0,len(morse_code_word[k])):<br/>                        if morse_code_word[k][l] in reverse_dict.keys():<br/>                            result[k][l]=reverse_dict[morse_code_word[k][l]]<br/>                        else:<br/>                            return "Invalid morse code representation"<br/>            else:<br/>                return "Invalid morse code sequence input, morse code sequence should end with punctuation characters"<br/>            <br/>            # Create an empty list to append result in and convert into readable string format output<br/>            printed_result = []<br/>            for i in range(0,len(result)):<br/>                for j in range(0,len(result[i])):<br/>                    printed_result.append(result[i][j]) <br/>                printed_result.append(" ")<br/>            <br/>            return ''.join(printed_result)</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/dcc35926d50138b7549619ce0a099501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8GNPZYaQgbgS_ULTvCnFA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片-输入莫尔斯码的解码器类的Python输出</p></figure><h1 id="509c" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">构建字符分析器类</h1><p id="4bc3" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">我们将构建的下一个类是字符分析器类，它将告诉用户每个字符(如字母或数字)被解码的频率。类似于我们的Decoder类，将定义两个基本方法<strong class="ki iu"> __init__(self) </strong>和<strong class="ki iu"> __str__(self) </strong>。</p><p id="5573" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将创建第三种方法<strong class="ki iu">analyze _ characters(self，decoded_sequence) </strong>来分析字符，解码后的序列通过该方法。我们将如何计算字符数，对于解码序列中的每个字符，我们将把它们添加到一个空字典中。循环遍历每个字符，我们将合计该字符的计数，并最终将它们显示为一个字典结构，这是我们在<strong class="ki iu"> __str__(self) </strong>方法中定义的。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="1ec3" class="ms lk it mo b gy mt mu l mv mw">class CharacterAnalyser:<br/>    def __init__ (self):<br/>        self.the_dict_char = {}<br/>      <br/>    def __str__ (self):<br/>        dict_char_str = ""<br/>        for key,value in self.the_dict_char.items():<br/>            dict_char_str += str(key) + " has been decoded " + str(value) + " time(s) " + "\n"<br/>        return dict_char_str<br/>    <br/>    def analyse_characters (self, decoded_sequence):<br/>        for each in decoded_sequence:<br/>            if each != "?" and each != "." and each != "," and each != " ":<br/>                if each not in self.the_dict_char.keys():<br/>                    self.the_dict_char[each] = 1<br/>                else:<br/>                    self.the_dict_char[each] += 1<br/>                    <br/>        return self.the_dict_char</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/5bfc631dfbdc4a22cc444bcd18c9e817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvrFnuuY4jj5BmSSSSj-Yg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">按作者分类的图像-字符分析器类的Python输出</p></figure><h1 id="e1af" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">构建单词分析器类</h1><p id="8d98" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">在我们的下一堂课中，我们将实现单词分析器，它将计算莫尔斯电码序列中某些单词被解码的次数。在定义了两个基本方法<strong class="ki iu"> __init__(self) </strong>和<strong class="ki iu"> __str__(self) </strong>之后，我们将定义第三个方法<strong class="ki iu">analyze _ words(self，decoded_sequence) </strong>，它将分析词频。这个概念类似于字符分析器类，我们将循环通过解码序列中的每个单词，并在字典中汇总计数。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="0a08" class="ms lk it mo b gy mt mu l mv mw">class WordAnalyser:<br/>    def __init__ (self):<br/>        self.the_dict_word = {}<br/>      <br/>    def __str__ (self):<br/>        dict_word_str = ""<br/>        for key,value in self.the_dict_word.items():<br/>            dict_word_str += str(key) + " has been decoded " + str(value) + " time(s) " +"\n"<br/>        return dict_word_str<br/>    <br/>    def analyse_words (self, decoded_sequence):<br/>        decoded_sequence_word=(decoded_sequence.strip()).split(" ")<br/>        for each in decoded_sequence_word:<br/>            if each != "?" and each != "." and each != ",":<br/>                if each not in self.the_dict_word.keys():<br/>                    self.the_dict_word[each] = 1<br/>                else:<br/>                    self.the_dict_word[each] += 1<br/>           <br/>        return self.the_dict_word</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/716a28c16ce75eb0912d7b7fb1907bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXiDbnVwilHOBA1Tqa7Qcw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">按作者分类的图像-文字分析器类的Python输出</p></figure><h1 id="3e43" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">构建句子分析器类</h1><p id="8c44" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">我们要构建的最后一个分析器类是句子分析器类。由于我们允许用户键入句号、逗号和问号这三个标点符号，因此我们可以按照以下方式分析每种句子类型被解码的次数:</p><p id="4d99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1.以'<strong class="ki iu">结尾的句子？</strong>'——<strong class="ki iu">问题</strong></p><p id="e609" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.以' T10 '结尾的句子。 ' — <strong class="ki iu">完成句子</strong></p><p id="90bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.以“<strong class="ki iu">、</strong>”—<strong class="ki iu">从句</strong>结尾的句子</p><p id="db50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在定义了基本的两个类<strong class="ki iu"> __init__(self) </strong>和<strong class="ki iu"> __str__(self) </strong>之后，我们将构建我们的第三个方法<strong class="ki iu">analyze _ sentences(self，decoded_sequence) </strong>的方式是，我们将序列分割成单独的单词/标点符号，并遍历它们中的每一个。如果发现问号，我们将对“问题”进行计数，以此类推。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="3a88" class="ms lk it mo b gy mt mu l mv mw">class SentenceAnalyser:<br/>    def __init__ (self):<br/>        self.the_dict_sentence = dict(zip(("Clauses","Complete Sentences","Questions"),(0,0,0)))<br/>      <br/>    def __str__ (self):<br/>        dict_sentence_str = ""<br/>        for key,value in self.the_dict_sentence.items():<br/>            dict_sentence_str += str(key) + " has been decoded " + str(value) + " times(s) " + "\n"<br/>        return dict_sentence_str<br/>    <br/>    def analyse_sentences (self, decoded_sequence):<br/>        decoded_sequence_sentence = decoded_sequence.split(" ")<br/>        for each in decoded_sequence_sentence:<br/>            if each == ",":<br/>                self.the_dict_sentence["Clauses"] += 1<br/>            elif each == ".":<br/>                self.the_dict_sentence["Complete Sentences"] += 1<br/>            elif each == "?":<br/>                self.the_dict_sentence["Questions"] += 1<br/>                <br/>        return self.the_dict_sentence</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/473bf4859c92654662e771e115a32837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t1YE8XI6-LbHbH1dL51MSQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片-句子分析器类的Python输出</p></figure><h1 id="d641" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">构建主程序</h1><p id="0843" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">在最后一节中，我们将把以上4个类放在一起，创建一个程序，让用户能够输入莫尔斯码序列，并选择他/她感兴趣的分析类型。我们把所有的类放在一起的方法是使用<strong class="ki iu"> main() </strong>方法，这是任何程序的起点。下面是完整的代码，我将带你们看一下。</p><pre class="lf lg lh li gt mn mo mp mq aw mr bi"><span id="f976" class="ms lk it mo b gy mt mu l mv mw"># import all the 4 classes<br/>from decoder_29442826 import Decoder<br/>from character_29442826 import CharacterAnalyser<br/>from word_29442826 import WordAnalyser<br/>from sentence_29442826 import SentenceAnalyser<br/>        <br/>def main():<br/>    # set 4 variables to each of the 4 classes<br/>    my_dict_1 = Decoder()<br/>    my_dict_2 = CharacterAnalyser()<br/>    my_dict_3 = WordAnalyser()<br/>    my_dict_4 = SentenceAnalyser()<br/>    # initialise empty list to store user input<br/>    user_input_list = []<br/>    # print the structure of morse code representation for user's reference<br/>    print(str(my_dict_1))<br/>    # asking user to input morse code sequences for decoding<br/>    while True:<br/>        user_input_morse = input ("Enter sequences of Morse Code to be decoded based on representation shown, leave blank to stop input: ")<br/>        # Proceed for error checking of user input if it's not empty<br/>        if len(user_input_morse)!=0:<br/>            # Error check 1, checking for invalid characters other than 0, 1, *<br/>            if my_dict_1.decode(user_input_morse)=="Invalid characters in morse code sequence, it should only consists of 0, 1 and *":<br/>                print ("Invalid characters in morse code sequence, it should only consists of 0, 1 and *" + "\n")<br/>            # Error check 2, checking for minimum requirement of one set of ***<br/>            elif "***" not in user_input_morse:<br/>                print ("Error input, the Morse Code sequence should have at least one set of ***" + "\n")<br/>            # Error check 3, checking for punctuation at the end of user input, i.e. 010101, 110011, 001100<br/>            elif my_dict_1.decode(user_input_morse)=="Invalid morse code sequence input, morse code sequence should end with punctuation characters":<br/>                print("Invalid morse code sequence input, morse code sequence should end with punctuation characters" + "\n")<br/>            # Error check 4, checking for invalid morse code representation as per the pre-defined morse code dictionary<br/>            elif my_dict_1.decode(user_input_morse)=="Invalid morse code representation":<br/>                print("Invalid morse code representation" + "\n")<br/>            # add user input into list for decoding if no errors found<br/>            else:<br/>                user_input_list.append(user_input_morse)<br/>        # Stop asking for input once user leaved blank<br/>        else:<br/>            print("You have chosen to stop inputting morse code sequences" + "\n")<br/>            break<br/>    <br/>    # empty string to store decoded sequences<br/>    overall_decoded_sequence=""<br/>    # decoding the morse code sequences in user_input_list<br/>    for each in user_input_list:<br/>        overall_decoded_sequence += my_dict_1.decode(each)<br/>    # character analysis of all the decoded morse code sequence   <br/>    my_dict_2.analyse_characters(overall_decoded_sequence)<br/>    # word analysis of all the decoded morse code sequence  <br/>    my_dict_3.analyse_words(overall_decoded_sequence)<br/>    # sentence analysis of all the decoded morse code sequence  <br/>    my_dict_4.analyse_sentences(overall_decoded_sequence)<br/>    <br/>    if len(overall_decoded_sequence)!=0:<br/>    # asking user to choose level of analysis from character, word, sentence or all<br/>        while True:<br/>            user_input_level = input ("Please choose the level of analysis from character, word, sentence or all, leave blank to quit:")<br/>            # if character analysis chosen, return result of character analysis only<br/>            if user_input_level == "character":<br/>                print("Decoded Morse Code Sequence(s):")<br/>                for each in user_input_list:<br/>                    print(str(each) + " has been decoded to: " + my_dict_1.decode(each))<br/>                print("\n" + "Characters Analysis:" + "\n" + str(my_dict_2))<br/>            # if word analysis chosen, return result of word analysis only<br/>            elif user_input_level == "word":<br/>                print("Decoded Morse Code Sequence(s):")<br/>                for each in user_input_list:<br/>                    print(str(each) + " has been decoded to: " + my_dict_1.decode(each))<br/>                print("\n" + "Words Analysis:" + "\n" + str(my_dict_3))<br/>            # if sentence analysis chosen, return result of sentence analysis only<br/>            elif user_input_level == "sentence":<br/>                print("Decoded Morse Code Sequence(s):")<br/>                for each in user_input_list:<br/>                    print(str(each) + " has been decoded to: " + my_dict_1.decode(each))<br/>                print("\n" + "Sentence Analysis:" + "\n" + str(my_dict_4))<br/>            # if all has been chose, return result of character, word and sentence analysis<br/>            elif user_input_level == "all":<br/>                print("Decoded Morse Code Sequence(s):")<br/>                for each in user_input_list:<br/>                    print(str(each) + " has been decoded to: " + my_dict_1.decode(each))<br/>                print("\n" + "Characters Analysis:" + "\n" + str(my_dict_2))<br/>                print("Words Analysis:" + "\n" + str(my_dict_3))<br/>                print("Sentence Analysis:" + "\n" + str(my_dict_4))<br/>            # if user leaved blank, terminate the whole program<br/>            elif user_input_level == "":<br/>                print("You have chosen to terminate the whole program")<br/>                break<br/>            # prompt the user for level of analysis again if invalid input has been found<br/>            else:<br/>                print("Invalid input, choose the level of analysis from character, word, sentence or all, leave blank to quit")<br/>    else:<br/>        print("No morse code sequences were entered")</span><span id="34f8" class="ms lk it mo b gy mx mu l mv mw">if __name__ == "__main__":<br/>    main()</span></pre><p id="0db1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的工作方式是，一旦用户运行这个程序，将首先显示莫尔斯电码表示(使用第一个<strong class="ki iu">解码器</strong>类)。用户将被提示输入莫尔斯电码序列，并可以继续输入解码，直到他们决定留下空白停止输入。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/4de5500f110c7b79b435114c8d132153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBLIsAgS8Vs2bgZMDn5E-Q.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者提供的图片-提示用户输入的主程序的Python输出</p></figure><p id="f4dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果用户选择退出输入莫尔斯电码序列，并且没有输入任何莫尔斯电码序列，或者输入的所有莫尔斯电码序列都是无效的，程序将终止，并显示消息“没有输入莫尔斯电码序列”。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/531007fa5c1891380200e50d5c2ef732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWoME7EiqZrOjnUuLOJmPw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">按作者分类的图像-没有输入的主程序的Python输出</p></figure><p id="7c8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦用户输入了一个莫尔斯电码序列或一系列序列，并键入一个空格以表示他/她想停止输入，程序将提示用户选择分析的级别(即字符、单词、句子或全部)。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/c8d641353350c645450d08ade467fcd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rs26eUTukkUVNaaNJyBXQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">按作者分类的图像-提示用户分析级别的主程序的Python输出</p></figure><p id="c0da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符分析将调用<strong class="ki iu"> character_analyser </strong>类，并返回在用户输入的序列中找到的字符及其解码频率。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/03952ac4a44960d630cab75f56a213d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUDDRgtqyXbb6pbhC6aT0Q.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片—主程序选择字符分析的Python输出</p></figure><p id="90e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单词分析将调用<strong class="ki iu"> word_analyser </strong>类，并返回在用户输入的序列中找到的单词及其解码频率。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/26032fae8b87bfc030cdf0ed714b1254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjO1D6FjYv2u7MZBNhsdOw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片—主程序选择单词分析的Python输出</p></figure><p id="58e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">句子分析将调用<strong class="ki iu">句子分析器</strong>，并根据“？”返回<em class="mm">问题、从句&amp;完成句子</em>的次数计数、'、'和' . '分别是。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/e3b42b1495333ba4432b726888c6d56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n83oaSKKIdMDRX1jRdbEBw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">图片由作者提供—主程序选择句子分析的Python输出</p></figure><p id="77c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户也可以选择“<strong class="ki iu"> all </strong>”，三个分析将同时显示。</p><p id="4c83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦用户完成分析，他/她可以通过输入空白输入来终止程序，程序将自行退出。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/3e008c3d8fe6e714ca54ff181e74b562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUf_yxqW6dIUgGJkBjutdg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">作者提供的图像-用户终止的主程序的Python输出</p></figure><h1 id="f0a4" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">摘要</h1><p id="295f" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">这篇文章描述了构建一个更先进的莫尔斯码解码器的过程，与之前的<a class="ae kf" rel="noopener" target="_blank" href="/simple-morse-code-decoder-in-python-39f6db635af2">相比，之前的</a>只能接受用户输入并以原始的字母数字形式输出。新的解码器允许用户解码句子，并获得被解码的字符/单词/句子的综合分析。我希望你们喜欢这篇文章，因为我们在这个解码器中定义了我们的Python类，所以这在编码熟练程度方面是更高级的。尽管如此，有乐趣提高你的莫尔斯电码解码器！</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><a href="https://www.buymeacoffee.com/tankahwang"><div class="gh gi ny"><img src="../Images/4bc5de35955c00939383a18fb66b41d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*9vg3-OY14aZN1UpKwIxxZg.png"/></div></a></figure></div></div>    
</body>
</html>