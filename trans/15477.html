<html>
<head>
<title>Apriori — Association Rule Mining In-depth Explanation and Python Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">apriori——关联规则挖掘的深层解释及Python实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apriori-association-rule-mining-explanation-and-python-implementation-290b42afdfc6?source=collection_archive---------2-----------------------#2020-10-25">https://towardsdatascience.com/apriori-association-rule-mining-explanation-and-python-implementation-290b42afdfc6?source=collection_archive---------2-----------------------#2020-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2886" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简明扼要地介绍入门级数据挖掘。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/97b60533e05f29a11b25afc6b81dbbdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XJYnGEGGB8ZDAzji"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弗兰基·查马基在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="bdab" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="a58e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">关于关联规则挖掘最著名的故事是<strong class="lq ir">《啤酒和尿布》</strong>。研究人员发现，购买尿布的顾客也倾向于购买啤酒。这个经典的例子表明，在我们的日常数据中可能隐藏着许多有趣的关联规则。</p><p id="6e82" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">关联规则挖掘是一种识别不同项目之间潜在关系的技术。有许多方法可以执行关联规则挖掘。我们将在本文中介绍的Apriori算法是最简单明了的方法。然而，因为它是基本方法，所以有许多不同的改进可以应用于它。</p><p id="c2a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们不会深入研究这些改进。相反，我将在这个故事中展示先验的主要缺点。并且在即将到来的帖子中，会介绍一个更高效的<strong class="lq ir"> FP增长</strong>算法。我们还会在下一篇文章中比较FP增长和Apriori的利弊。</p><div class="mp mq gp gr mr ms"><a rel="noopener follow" target="_blank" href="/fp-growth-frequent-pattern-generation-in-data-mining-with-python-implementation-244e561ab1c3"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">FP增长:用Python实现数据挖掘中的频繁模式生成</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">在本文中，我们将展示一种叫做FP增长算法的高级方法。我们将走过整个…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">towardsdatascience.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><h1 id="3dbd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">先验概念</h1><h2 id="71ec" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">支持</h2><blockquote class="nt nu nv"><p id="95c4" class="lo lp nw lq b lr mk jr lt lu ml ju lw nx mm lz ma ny mn md me nz mo mh mi mj ij bi translated">包含项集的事务的一部分。</p></blockquote><p id="aa7c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，第I项的支持度定义为包含I的事务数除以事务总数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/938d27c940bf0f350e71e1f5d6f94c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/0*pyOADkeaWyrVP2ft.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Chonyy提供</p></figure><h2 id="9fb3" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">信心</h2><blockquote class="nt nu nv"><p id="4151" class="lo lp nw lq b lr mk jr lt lu ml ju lw nx mm lz ma ny mn md me nz mo mh mi mj ij bi translated">测量Y中的项目在包含X的事务中出现的频率</p></blockquote><p id="0cb8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">置信度是如果购买了物品X，也购买了物品Y的可能性。它的计算方法是包含X和Y的事务数除以包含X的事务数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/c45667e8302a8a2a83639beb6cc2bb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50GI4dR58MnhwBP9dw6nFQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Chonyy提供</p></figure><h2 id="6b65" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">频繁项目集</h2><blockquote class="nt nu nv"><p id="c6f8" class="lo lp nw lq b lr mk jr lt lu ml ju lw nx mm lz ma ny mn md me nz mo mh mi mj ij bi translated">支持度大于或等于最小支持度阈值的项目集</p></blockquote><p id="c833" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">频繁项集也称为频繁模式，简单地说就是支持度满足最小支持度阈值的所有项集。</p><h1 id="42a7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Apriori算法</h1><p id="b0d2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">请随意查看评论良好的源代码。这真的有助于理解整个算法。</p><div class="mp mq gp gr mr ms"><a href="https://github.com/chonyy/apriori_python" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">chonyy/apriori_python</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">pip安装apriori_python，然后像使用git clone git clone一样使用它来获得此repo的副本…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="oc l nd ne nf nb ng kp ms"/></div></div></a></div><p id="c52f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">先验的主要思想是</p><blockquote class="od"><p id="61b0" class="oe of iq bd og oh oi oj ok ol om mj dk translated">频繁项集的所有非空子集也必须是频繁的。</p></blockquote><figure class="oo op oq or os kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/c65808e1e34ab4d7c4c6c9bd77d236dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_22UGOKJJ6C8B3Zhk_IAiQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Chonyy提供</p></figure><p id="b939" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是一种<strong class="lq ir">自下而上</strong>的方法。我们从项目集列表中的每一个项目开始。然后，通过自连接产生候选。我们一次扩展一个项目集的长度。子集测试在每个阶段执行，包含不频繁子集的项目集被删除。我们重复这个过程，直到不能从数据中获得更多成功的项目集。</p><h1 id="d59d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">算法概述</h1><p id="fa75" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是Apriori的官方伪代码</p><ul class=""><li id="5ff1" class="ot ou iq lq b lr mk lu ml lx ov mb ow mf ox mj oy oz pa pb bi translated"><strong class="lq ir"> Lk: </strong>频繁k项集，满足最小支持度</li><li id="6741" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated"><strong class="lq ir"> Ck: </strong>候选k项集，可能的频繁k项集</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/634c3cf1731a3353a5deb830af3ce146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyrLxlAywJC5wsPS-fszqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Chonyy提供</p></figure><p id="d49d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，修剪步骤已经包含在先验生成函数中。我个人觉得这个伪代码挺混乱的。所以，我整理成了自己的版本。这应该更容易理解。</p><pre class="kg kh ki kj gt pi pj pk pl aw pm bi"><span id="c426" class="nh kx iq pj b gy pn po l pp pq">L[1] = {frequent 1-itemsets};<br/>for (k=2; L[k-1] != 0; k ++) do begin<br/>    // perform self-joining<br/>    C[k] = getUnion(L[k-1])<br/>    // remove pruned supersets<br/>    C[k] = pruning(C[k])<br/>    // get itemsets that satisfy minSup<br/>    L[k] = getAboveMinSup(C[k], minSup)<br/>end<br/>Answer = Lk (union)</span></pre><p id="f8b6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">综上所述，Apriori的基本组成部分可以写成</p><ul class=""><li id="784c" class="ot ou iq lq b lr mk lu ml lx ov mb ow mf ox mj oy oz pa pb bi translated">使用k-1个项目集生成k个项目集</li><li id="bf73" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated">通过连接L[k-1]和L[k-1]得到C[k]</li><li id="807d" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated">用子集测试剪枝C[k]</li><li id="f0fb" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated">通过提取C[k]中满足minSup的项集生成L[k]</li></ul><p id="6544" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在头脑中模拟算法，并用下面的例子验证它。现在概念应该真的很清楚了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/f4350997562688de6e84838e0c64a153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PWiIck42-E8z0NbB.PNG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Chonyy提供</p></figure><h1 id="e8d9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Python实现</h1><h2 id="26a0" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">先验函数</h2><p id="0cc5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是这个Apriori Python实现的主要功能。这个功能最重要的部分是从<strong class="lq ir">第16行~第21行</strong>。它基本上遵循我上面写的修改后的伪代码。</p><ol class=""><li id="22d9" class="ot ou iq lq b lr mk lu ml lx ov mb ow mf ox mj ps oz pa pb bi translated">通过连接前一阶段的频繁项集来生成候选集。</li><li id="1a5d" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj ps oz pa pb bi translated">执行子集测试，如果包含不频繁的项目集，则修剪候选集。</li><li id="0e22" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj ps oz pa pb bi translated">通过获取满足最小支持度的频繁项集来计算最终的频繁项集。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pt pu l"/></div></figure><h2 id="63b0" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">候选生成</h2><p id="7ba7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于自连接，我们简单地通过蛮力得到所有的联合，并且只返回那些特定长度的联合。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pt pu l"/></div></figure><h2 id="5055" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">修剪</h2><p id="48f1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了执行子集测试，我们遍历项目集中所有可能的子集。如果该子集不在先前的频繁项集中，我们就对其进行剪枝。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pt pu l"/></div></figure><h2 id="533b" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated"><strong class="ak">从候选项中获取频繁项集</strong></h2><p id="22ed" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在最后一步，我们<strong class="lq ir">将候选集变成频繁项集</strong>。因为我们没有应用任何改进技术。我们可以采用的唯一方法是无脑地一遍又一遍地遍历项目和项目集来获得计数。最后，我们只保留支持度等于或高于最小支持度的项集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pt pu l"/></div></figure><h2 id="3b78" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">结果</h2><pre class="kg kh ki kj gt pi pj pk pl aw pm bi"><span id="a829" class="nh kx iq pj b gy pn po l pp pq">print(rules)  <br/># [[{'beer'}, {'rice'}, 0.666], [{'rice'}, {'beer'}, 1.000]]<br/># (rules[0] --&gt; rules[1]), confidence = rules[2]</span></pre><p id="2c10" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">更多用法和示例请查看<a class="ae kv" href="https://github.com/chonyy/apriori_python" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="nw">GitHub repo</em></strong></a>或<a class="ae kv" href="https://pypi.org/project/apriori-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nw"> PyPi包</em> </strong> </a>。</p><h1 id="b54d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">缺点</h1><p id="f0f1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Apriori算法有两个主要缺点</p><ul class=""><li id="80ef" class="ot ou iq lq b lr mk lu ml lx ov mb ow mf ox mj oy oz pa pb bi translated">候选生成项集的大小可能非常大</li><li id="7518" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated">因为我们必须一遍又一遍地扫描项目集数据库，所以在计算支持度上浪费了大量时间</li></ul><p id="ac7c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将在repo中使用data4.csv(从<a class="ae kv" href="https://sourceforge.net/projects/ibmquestdatagen/" rel="noopener ugc nofollow" target="_blank"> IBM generator </a>生成)来展示这些缺点，看看是否能得到一些有趣的观察结果。</p><h2 id="63d8" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">每个阶段的候选项集大小</h2><div class="kg kh ki kj gt ab cb"><figure class="pv kk pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/7293078f54db5354ca55be45c1ba8dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*p2xfDUML8GUg7lQ0tpF7ww.png"/></div></figure><figure class="pv kk pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/f36defe84064d7c3b6f3e8a8933b7b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*0ns9liIvLtEITZyXX_bFBA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk qb di qc qd translated">图片由Chonyy提供</p></figure></div><p id="386a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过对data4.csv运行Apriori，我们可以绘制出如上图所示的流程。我们上面提到的缺点可以在观察图表时发现。</p><p id="d33d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在右边，我们可以看到算法的三个主要过程之后的项集大小。从图表中可以发现两个关键点</p><ul class=""><li id="df14" class="ot ou iq lq b lr mk lu ml lx ov mb ow mf ox mj oy oz pa pb bi translated">项目集的大小在开始时迅速增加，随着迭代的进行逐渐减小</li><li id="dbd8" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated">修剪过程可能像阶段1和阶段2一样没有用。然而，在某些情况下，比如第三阶段，它会有很大的帮助。修剪了一半的项目集，这意味着计数时间可以减少一半！</li></ul><h2 id="cc61" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">每个阶段经过的时间</h2><div class="kg kh ki kj gt ab cb"><figure class="pv kk pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/1e91b814a8c2c0bfe25c082f653a4bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*BMD7M9Y-2PoavBDBOZQvRQ.png"/></div></figure><figure class="pv kk pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/3f1407ed01864783c1cf1365cb522766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*3hv0Zl9cIg5_AAhMZdeirg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk qb di qc qd translated">图片由Chonyy提供</p></figure></div><p id="b92b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从剧情可以看出，跑步大部分时间都花在了数支持上。与一遍又一遍地扫描原始项目集数据库相比，花在候选项生成和剪枝上的时间算不了什么。</p><p id="e870" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一个值得注意的观察是，我们在<strong class="lq ir">阶段2 </strong>得到一个成本峰值。有趣的是，这其实不是意外！当使用Apriori时，数据科学家经常在阶段2遇到瓶颈。由于在阶段1几乎没有候选项被删除，所以在阶段2生成的候选项基本上是所有1-频繁项集的所有可能组合。而计算如此庞大的项集的支持度导致了极高的成本。</p><h2 id="cc48" class="nh kx iq bd ky ni nj dn lc nk nl dp lg lx nm nn li mb no np lk mf nq nr lm ns bi translated">尝试不同的数据集(在repo中)</h2><p id="2d5a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><strong class="lq ir"> kaggle.csv </strong></p><div class="kg kh ki kj gt ab cb"><figure class="pv kk pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/2c73473806ad1d1cffa35b88a6a17523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*FKgppIr-62CxHVROosjD3Q.png"/></div></figure><figure class="pv kk pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/69d7337f2003ccb2aa770c7afcde045a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*srAhkvFZ96nw-2-9CcAWag.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk qb di qc qd translated">图片由Chonyy提供</p></figure></div><p id="8f1d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我们上面提到的，我们知道先验的瓶颈通常在阶段2。然而，正如在<a class="ae kv" href="https://www.kaggle.com/newshuntkannada/dataset-for-apriori-and-fp-growth-algorithm" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>数据集图上显示的那样，这种观察可能并不总是成立的。准确地说，这取决于数据集本身和我们想要的最小支持度。</p><p id="bd41" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> data7.csv </strong></p><div class="kg kh ki kj gt ab cb"><figure class="pv kk pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/62aec18f596007cf5b5d259b96a44d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*kdev64rWsicCTdQ3yCbFgw.png"/></div></figure><figure class="pv kk pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/8e6577862a12289e8fbbc33d40cdcbce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*TaSViBxG7hHXPnIheiLVGw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk qb di qc qd translated">图片由Chonyy提供</p></figure></div><p id="62db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我们所看到的，我们需要一分多钟来计算数据7与Apriori的关联规则。显然，这个运行时间是难以接受的。记得我说过先验只是一个根本方法吗？它的效率是它在数据科学领域没有得到广泛应用的原因。我们将把这个结果与FP增长的结果进行比较。</p><div class="mp mq gp gr mr ms"><a rel="noopener follow" target="_blank" href="/fp-growth-frequent-pattern-generation-in-data-mining-with-python-implementation-244e561ab1c3"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">FP增长:用Python实现数据挖掘中的频繁模式生成</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">在本文中，我们将展示一种叫做FP增长算法的高级方法。我们将走过整个…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">towardsdatascience.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><h1 id="836a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">丰富</h1><p id="7cd4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有许多额外的技术可以应用于Apriori来提高效率。下面列出了其中的一些。</p><ul class=""><li id="47f7" class="ot ou iq lq b lr mk lu ml lx ov mb ow mf ox mj oy oz pa pb bi translated"><strong class="lq ir">散列:</strong>减少数据库扫描</li><li id="b4ec" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated"><strong class="lq ir">事务减少:</strong>不再考虑不频繁的事务</li><li id="acd8" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated"><strong class="lq ir">分区:</strong>可能频繁一定是频繁中的一个分区</li><li id="17bc" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated"><strong class="lq ir">动态项目集计数:</strong>减少对数据的遍历次数</li><li id="c86d" class="ot ou iq lq b lr pc lu pd lx pe mb pf mf pg mj oy oz pa pb bi translated"><strong class="lq ir">抽样:</strong>随机抽取样本</li></ul><h1 id="e54a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">源代码</h1><div class="mp mq gp gr mr ms"><a href="https://github.com/chonyy/apriori_python" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">chonyy/apriori_python</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">pip安装apriori_python，然后像使用git clone git clone一样使用它来获得此repo的副本…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="qe l nd ne nf nb ng kp ms"/></div></div></a></div><h1 id="ba84" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">PyPi包</h1><div class="mp mq gp gr mr ms"><a href="https://pypi.org/project/apriori-python/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">先验python</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">pip安装apriori_python，然后像运行程序一样使用提供的数据集和minSupport的默认值…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">pypi.org</p></div></div><div class="nb l"><div class="qf l nd ne nf nb ng kp ms"/></div></div></a></div></div></div>    
</body>
</html>