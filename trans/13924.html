<html>
<head>
<title>ReactJS + Python Flask on Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Heroku上的ReactJS + Python烧瓶</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reactjs-python-flask-on-heroku-2a308272886a?source=collection_archive---------3-----------------------#2020-09-25">https://towardsdatascience.com/reactjs-python-flask-on-heroku-2a308272886a?source=collection_archive---------3-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d1a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为API开发和部署制定框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63d167ecdb8712fde17fe38e7741f6a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6ptNtrrfjTYPFeWx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我真的很喜欢做东西，但我真的讨厌部署。我有一堆想法，放在我的本地机器上，只是积满灰尘，因为我懒得部署它们让全世界看到。在过去，我一直试图从零开始建立自己的服务器。这包括安装所有的linux包，处理nginx配置和所有我不喜欢的服务器管理工作。在我的开发生涯中，出于某种原因，我从未听说过Heroku。Heroku是我所需要的完美人选。它基本上允许你连接一个git存储库，当你把它推到他们的远程时，它会自动计算出你在运行什么(检测flask或node.js等),并自己完成构建。实际上只是将代码推向生产，没有服务器端的麻烦。</p><p id="081a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了纪念我新发现的最好的朋友，我想展示如何构建一个简单的ReactJs + Flask框架，我将用它作为我今后开发API和Web应用程序的模板。这里的想法是让一些<strong class="lb iu"> <em class="lv">可重用</em> </strong>，这样我就可以克隆回购协议，开始做一些新的事情，而不需要重做任何步骤。</p><h1 id="f7e1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">建立Heroku</h1><p id="b83c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为此你所要做的就是去www.heroku.com注册一个账户。一旦一切就绪并登录，您应该会看到这样一个屏幕，显示您当前的应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/e82b49a481438b9979b671446231c7da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7ZhSFL6qDyfm16K_EusDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的Heroku仪表板</p></figure><p id="14b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你所要做的就是点击右上角的<strong class="lb iu">新建</strong>按钮，创建你自己的新应用！是的，确实是这样。</p><p id="1d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据我所知，它基本上在他们的服务器上为我们建立了一个git存储库，它与我们的用户帐户相关联。这意味着我们现在可以在heroku上向这个应用程序推送代码。问题是如何做到这一点？这是你必须下载Heroku CLI(命令行界面)的地方。这允许我们运行命令行命令来登录和推送代码等。CLI可在此下载:</p><div class="mu mv gp gr mw mx"><a href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">Heroku CLI</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">Heroku命令行界面(CLI)使得直接从终端创建和管理您的Heroku应用程序变得非常容易…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">devcenter.heroku.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><p id="6459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请确保为您的系统下载它。安装完成后，你可以打开一个终端并运行<strong class="lb iu"> heroku登录</strong>，这会打开一个网页浏览器让你登录你的账户。</p><h2 id="50c0" class="nm lx it bd ly nn no dn mc np nq dp mg li nr ns mi lm nt nu mk lq nv nw mm nx bi translated">其他软件</h2><p id="f844" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">你还需要一些其他的软件。我不打算详细说明如何安装它们，但我会在这里列出它们。</p><ul class=""><li id="4d07" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">Git:这是一个仓库管理系统</li><li id="c5c7" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">Python:这当然是Python。我会推荐3.7.x，因为这是我正在使用的！</li><li id="8b9e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">NodeJS/NPM:用于反应堆开发部分</li></ul><h1 id="91d7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">本地设置</h1><p id="9e57" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，所有的软件都已安装，我们将设置我们的目录，并开始制作我们的API和客户端前端接口。首先，我们要创建一个新目录(注意:我用<strong class="lb iu"> datastuffplus </strong>来命名我所有的东西):</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="1184" class="nm lx it on b gy or os l ot ou">mkdir datastuffplus<br/>cd datastuffplus<br/>git init <strong class="on iu">&lt;--- This makes the current folder into a repo</strong></span><span id="2315" class="nm lx it on b gy ov os l ot ou"><strong class="on iu"># Links the repo to our heroku project!</strong><br/>heroku git:remote -a datastuffplus</span></pre><p id="8875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们所做的就是创建一个链接到Heroku项目库的目录。这意味着当我们添加代码并提交/推送时，它会被Heroku和self部署。接下来，我们可以使用Flask构建一个简单的API。</p><h1 id="7809" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">构建Flask API和Web服务器</h1><p id="b6e5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的flask服务器将做两件主要的事情。第一个是服务的网页文件，使我们的最终网页(前端)。第二个是充当API服务，完成一些python特定的任务，并将结果发送回前端网站。</p><p id="1834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先为我们的python安装生成一个虚拟环境。这允许我们将这个环境从我们的系统中隔离出来。如果您需要在这个项目上安装某些版本的包，而在另一个项目上安装不同版本的包，这将非常有用。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="2281" class="nm lx it on b gy or os l ot ou">python -m venv venv/</span></pre><p id="87f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用这个环境，我们需要激活它。根据您的操作系统，它可能看起来有点不同，但在Windows上，我们运行:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="4e20" class="nm lx it on b gy or os l ot ou">cd ./venv/Scripts/<br/>activate.bat</span></pre><p id="50d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们安装python包，并为部署到Heroku做好准备。请注意，因为我们在活动的<strong class="lb iu"> venv </strong>中，所以软件包只安装在这个隔离目录中。太好了。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="ada6" class="nm lx it on b gy or os l ot ou">pip install flask flask-cors gunicorn boto3 matplotlib</span></pre><p id="9829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述python包适用于以下情况:</p><ul class=""><li id="541b" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><strong class="lb iu">烧瓶</strong>:主服务器功能</li><li id="6e07" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu"> flask-cors </strong>:用于跨原点请求。基本上允许您在不违反安全性的情况下从不同的系统调用端点</li><li id="023d" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">gunicorn :这是一个生产服务器包，Heroku使用它来为站点提供服务</li><li id="b58e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu"> boto3 </strong>:这个包用于访问Amazons S3存储桶(把它想象成一个基于云的目录来存储文件)<strong class="lb iu"> NB </strong>:由于Heroku不能保证文件在停止运行后的持久性，所以使用这种云存储是非常重要的</li><li id="0b9e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu"> matplotlib </strong>:用于制作地块的包。这很重要，因为我们的测试API将使用它来生成一个饼图</li></ul><p id="5314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们真正编写服务器代码之前，还有几个步骤。为了跟踪所有需要的包，Heroku需要一个<strong class="lb iu"><em class="lv">requirements . txt</em></strong>文件，它基本上列出了我们已经安装的所有python包。要做到这一点，我们只需运行:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="1f3e" class="nm lx it on b gy or os l ot ou">pip freeze &gt; requirements.txt</span></pre><h2 id="60e2" class="nm lx it bd ly nn no dn mc np nq dp mg li nr ns mi lm nt nu mk lq nv nw mm nx bi translated">饼图API</h2><p id="3a8f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">那么我们真正想要创造的是什么呢？我想要的一件事是一个漂亮的高分辨率饼图，用来展示我制作的一些图形。我通常使用python matplotlib来完成这项工作，但是如果我每次都需要实际运行python，这就有点烦人了。所以，让我们把它变成一项服务，让我的生活更轻松，也让其他人可以使用它！奖金！</p><p id="e7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是始终只定义完成工作的函数。下面我粘贴了制作饼状图并保存到本地的函数:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="221d" class="nm lx it on b gy or os l ot ou">def GeneratePie():<br/><strong class="on iu">    # Get the input data (Wedge is the distance between slices)<br/></strong>    data = [60,40]<br/>    colors = ['#003049','#ffcdb2']<br/>    wedge = 0.05</span><span id="0c57" class="nm lx it on b gy ov os l ot ou"><strong class="on iu">    # Make a matplotlib (high res) pie chart!<br/></strong>    fig1, ax1 = plt.subplots(figsize=(20,20))<br/>       patches, texts = ax1.pie(data,explode=[float(wedge) for w in<br/>       range(0,len(data))], colors = colors, startangle=90)</span><span id="1367" class="nm lx it on b gy ov os l ot ou"><strong class="on iu">    # Equal aspect ratio ensures that pie is drawn as a circle<br/></strong>    ax1.axis('equal')<br/>    plt.tight_layout()</span><span id="cb60" class="nm lx it on b gy ov os l ot ou"><strong class="on iu">    # Save the image temporary on the local machine<br/></strong>    plt.savefig(os.getcwd() + '/test.png');</span></pre><p id="562a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/fe1c54b4eea289468dd0c0a881a99c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58YmZxcCtTeWSL0Em6K2kw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">啊太好了！</p></figure><p id="4a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们现在有了我们想要的函数。下一步是将它包装在我们的flask服务器中。</p><p id="b7e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的工作目录中创建一个名为<strong class="lb iu"> app.py </strong>的新python文件。裸露的骨骼看起来是这样的(我们稍后会填充):</p><p id="98ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做的第一件事是导入我们需要运行的包</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="4754" class="nm lx it on b gy or os l ot ou">from flask import Flask,<br/>    render_template,send_from_directory,request, jsonify,<br/>    make_response<br/>from flask_cors import CORS, cross_origin<br/>import boto3<br/>import os</span></pre><p id="a1d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将定义flask app对象，并设置静态文件夹和URL:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="47e5" class="nm lx it on b gy or os l ot ou">app = Flask(__name__ <br/>    ,<strong class="on iu">static_folder</strong>='client/build',<strong class="on iu">static_url_path</strong>='')<br/>cors = CORS(app)</span></pre><p id="e34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，当我们还想为前端网站提供服务时，静态文件夹和url是很重要的。<strong class="lb iu"> static_folder </strong>将指向我们的ReactJS前端的构建版本，并且<strong class="lb iu"> static_url_path </strong>需要被设置，否则构建将引用所有错误的位置。即。CSS文件的路径将会是相对于位置的，如果你不指定它，它们将无法被找到！</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="2fa5" class="nm lx it on b gy or os l ot ou"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="on iu">@app</strong></a><strong class="on iu">.route('/api')</strong><br/><a class="ae ky" href="http://twitter.com/cross_origin" rel="noopener ugc nofollow" target="_blank">@cross_origin</a>()<br/>def Welcome():<br/>    return "Welcome to the API!!!"</span><span id="1c8d" class="nm lx it on b gy ov os l ot ou"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="on iu">@app</strong></a><strong class="on iu">.route('/api/justpie/')</strong><br/><a class="ae ky" href="http://twitter.com/cross_origin" rel="noopener ugc nofollow" target="_blank">@cross_origin</a>()<br/>def GeneratePie():<br/>    ....</span><span id="2610" class="nm lx it on b gy ov os l ot ou"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="on iu">@app</strong></a><strong class="on iu">.route('/')</strong><br/>def serve():<br/>    return send_from_directory(app.static_folder, 'index.html')</span><span id="ebfe" class="nm lx it on b gy ov os l ot ou">if __name__ == '__main__':<br/>    app.run(host='0.0.0.0')</span></pre><p id="69b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的框架代码中，我们看到了服务器的三条新路由。这些充当您可以通过web浏览器调用的端点。</p><ul class=""><li id="68b1" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">【T6<strong class="lb iu">@ app</strong><strong class="lb iu">。route('/api'): </strong>这是将作为api调用基础的路由。它现在所做的就是发回一个愉快的小信息！</li><li id="ad1d" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">T13】@ app</a>T16】。route('/api/justpie'): 这个端点完成了大部分工作。我们将在这里调用之前的饼图生成函数(做了一些修改，通过get请求接收用户输入，并将最终图像存储在S3桶中)</li><li id="4309" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">@ app</strong></a>T22】。route('/'): 这个根端点将指向ReactJS代码的构建版本，我们将在这里调用端点并在web浏览器中显示结果。</li></ul><p id="0afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然已经建立了框架，我们需要看看如何将独立的python函数修改成flask可调用函数。</p><h2 id="8e1b" class="nm lx it bd ly nn no dn mc np nq dp mg li nr ns mi lm nt nu mk lq nv nw mm nx bi translated">修改功能</h2><p id="f15f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">上面的GeneratePie()函数有两个主要的变化。</p><ol class=""><li id="05b3" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu ox oe of og bi translated">我们需要通过GET请求接收来自客户端的输入</li><li id="1a07" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu ox oe of og bi translated">将最终文件存储到亚马逊S3存储桶中，这样它可以在Heroku重启后继续存在</li></ol><p id="5d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行第一次修改，我们替换以下代码</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="e604" class="nm lx it on b gy or os l ot ou">data = [60,40]<br/>colors = ['#003049','#ffcdb2']<br/>wedge = 0.05</span></pre><p id="9b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="89f7" class="nm lx it on b gy or os l ot ou"><strong class="on iu"># Get the input data from the request</strong><br/>data = request.args.get('data')<br/>colors = request.args.get('colors')<br/>wedge = request.args.get('wedge')</span><span id="dce4" class="nm lx it on b gy ov os l ot ou"><strong class="on iu"># Turn it into a list</strong><br/>data = [float(i) for i in data.split(',')]<br/>colors = ['#'+i for i in colors.split(',')] <strong class="on iu">&lt;-- Adding # to string</strong></span></pre><p id="8ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据传递的方式是通过web URL。例如，为了模仿原始函数中的操作，您可以将API调用为:</p><blockquote class="oy"><p id="acdb" class="oz pa it bd pb pc pd pe pf pg ph lu dk translated">http://localhost:5000/API/just pie/？data=10，10，80&amp;colors=003049，ffcdb2，0fc9b2&amp;wedge=0.02</p></blockquote><p id="52a2" class="pw-post-body-paragraph kz la it lb b lc pi ju le lf pj jx lh li pk lk ll lm pl lo lp lq pm ls lt lu im bi translated">你可以看到我们是如何传递参数的。</p><blockquote class="pn po pp"><p id="f4f6" class="kz la lv lb b lc ld ju le lf lg jx lh pq lj lk ll pr ln lo lp ps lr ls lt lu im bi translated">注意:颜色没有使用标签，因为它是一个特殊的字符，所以我们只是在把它变成一个列表的时候加上这个标签</p></blockquote><p id="4c0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个变化是替换代码:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="eafe" class="nm lx it on b gy or os l ot ou"><strong class="on iu"># Save the image temporary on the local machine<br/></strong>plt.savefig(os.getcwd() + '/test.png');</span></pre><p id="3beb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="f31f" class="nm lx it on b gy or os l ot ou"><strong class="on iu"># Save the image temporary on the local machine</strong><br/>plt.savefig(os.getcwd() + '/test.png');</span><span id="60ed" class="nm lx it on b gy ov os l ot ou"><strong class="on iu"># Connect to the S3 bucket and just drop it on there</strong><br/>s3 = boto3.client('s3', aws_access_key_id=<strong class="on iu">ACCESS_KEY</strong>,<br/>    aws_secret_access_key=<strong class="on iu">SECRET_KEY</strong>)<br/>s3.upload_file(os.getcwd() +<br/>    '/test.png',bucket,'test.png',<strong class="on iu">ExtraArgs={'ACL':'public-read'}</strong>)</span><span id="cb75" class="nm lx it on b gy ov os l ot ou"><strong class="on iu"># The return will be a json where message contains the image path (URL)</strong><br/>status = {};<br/>status['status'] = 'DONE';<br/>status['message'] = '<a class="ae ky" href="https://'+bucket+'.s3.ca-central-1.amazonaws.com/test.png'" rel="noopener ugc nofollow" target="_blank">https://'+<strong class="on iu">bucket</strong>+'.s3.ca-central-1.amazonaws.com/test.png'</a></span><span id="57d6" class="nm lx it on b gy ov os l ot ou">return make_response(jsonify(status), 200)</span></pre><p id="c905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面有几样东西可以看看:</p><ol class=""><li id="5a10" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu ox oe of og bi translated">我们仍然在本地保存文件，但是我们随后连接到S3存储桶来上传文件</li><li id="ef9b" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu ox oe of og bi translated">ACCESS_KEY和SECRET_KEY来自你自己的亚马逊账户。我不会详细介绍如何设置它，因为有上百万篇文章，而且它非常无缝！extra args = { ' ACL ':' public-read ' }用于使文件公开。</li><li id="7636" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu ox oe of og bi translated">最后，你可以看到我们发回了一个json响应，给出了我们的公共S3桶的上传位置URL。这可以被前端用来向用户显示结果。</li></ol><p id="5577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在我们的API已经准备好了！现在我们所要做的就是得到一个前端网站来展示它！</p><h1 id="1bd1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">与CoreUI的反应前端</h1><p id="4bab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于前端，我使用ReactJS来制作一个简单的仪表板并与API交互。我不打算深入讨论仪表板样式本身的细节，但是会涉及它如何与API交互。我使用的模板来自</p><div class="mu mv gp gr mw mx"><a href="https://coreui.io/react/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">免费React.js管理模板CoreUI</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">时间是我们最宝贵的资产，因此我们希望通过创建简单、可定制、易于学习的工具来帮助您节约时间…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">coreui.io</p></div></div><div class="ng l"><div class="pt l ni nj nk ng nl ks mx"/></div></div></a></div><p id="784f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常棒的免费管理面板，可以在react和许多其他框架中使用。我刚刚下载了它并解压了zip文件。只要你已经安装了npm，你就可以运行安装程序来获得需要的包，然后用</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="311c" class="nm lx it on b gy or os l ot ou">mkdir client<br/>cd ./client/<br/>npm install<br/>npm start</span></pre><p id="3010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有我决定放在<strong class="lb iu"> app.py </strong>旁边的<strong class="lb iu">客户端/ </strong>子目录中的文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/57cd6caa4eeae4b20534a81c2c035f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*dQJ-V_tYwrVT-zxZ-mP4tg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我现在的目录结构的例子。请注意客户端子目录。</p></figure><p id="fede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际调用并显示结果的ReactJS web部分如下所示:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="ec9f" class="nm lx it on b gy or os l ot ou"><strong class="on iu"># Define the function (functional components not classes)</strong><br/>const JustPie = () =&gt; {</span><span id="c7ca" class="nm lx it on b gy ov os l ot ou">  <strong class="on iu"># Set up the state variables</strong><br/>  const [downloadLink, setDownloadLink] = useState(""); <strong class="on iu"># Image</strong></span><span id="fec4" class="nm lx it on b gy ov os l ot ou">  <strong class="on iu"># Default settings for our form</strong><br/>  const [data, setData] = useState("40,60");  <br/>  const [colors, setColors] = useState("003049,ffcdb2")<br/>  const [wedge, setWedge] = useState(0.05);</span><span id="759b" class="nm lx it on b gy ov os l ot ou">  <strong class="on iu"># NB: This URL will changed depending on your release!!!</strong><br/>  const api_base_url =<br/>     '<a class="ae ky" href="http://justpie.herokuapp.com/api/v1/'" rel="noopener ugc nofollow" target="_blank">http://datastuffplus.herokuapp.com/api/justpie/'</a></span><span id="8984" class="nm lx it on b gy ov os l ot ou">   <strong class="on iu"># Function to fetch the data from our API</strong><br/>  function fetchData(){</span><span id="2186" class="nm lx it on b gy ov os l ot ou"><strong class="on iu">     # Set the image to be empty<br/></strong>     setDownloadLink('');</span><span id="fb63" class="nm lx it on b gy ov os l ot ou">     <strong class="on iu"># Build up the endpoint to our API</strong><br/>     var url_req_string = api_base_url+ "?data=" + data + "&amp;colors="<br/>        + colors + "&amp;wedge=" + wedge;</span><span id="a731" class="nm lx it on b gy ov os l ot ou">     <strong class="on iu"># Fetch the URL and parse the JSON response  </strong>  <br/>     fetch(url_req_string)<br/>        .then(res =&gt; res.json())<br/>        .then(<br/>          (result) =&gt; {</span><span id="2c81" class="nm lx it on b gy ov os l ot ou">            <strong class="on iu"># Set the image to be the API return "message" </strong><br/>            setDownloadLink(result.message);<br/>          },</span><span id="c8d8" class="nm lx it on b gy ov os l ot ou">          (error) =&gt; {<br/>            console.log(error);</span><span id="7b19" class="nm lx it on b gy ov os l ot ou">          }<br/>        );<br/>    };</span><span id="6491" class="nm lx it on b gy ov os l ot ou"><strong class="on iu"># The rest of the code that runs the actual render</strong><br/>return (&lt;&gt; &lt;/&gt;)</span></pre><p id="d9a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面简单地调用了一个对我们的API的获取，并更新了下载链接的状态，这是S3桶图像URL。</p><p id="08cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了完整起见，页面呈现中出现的下一部分显示了状态变量如何连接到表单:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="d79d" class="nm lx it on b gy or os l ot ou"><strong class="on iu"># Update the data when the form changes</strong><br/>&lt;CInput type="text" id="hf-text" name="hf-text" placeholder="40,60" autoComplete=""   <br/><strong class="on iu">value={data}</strong><br/><strong class="on iu">onChange={(event)=&gt; setData(event.target.value)}</strong>/&gt;</span><span id="9a16" class="nm lx it on b gy ov os l ot ou"><strong class="on iu"># Call the API on a button press<br/></strong>&lt;CButton type="submit" size="sm" color="primary"<br/><strong class="on iu">onClick={() =&gt; fetchData()}</strong>&gt;</span></pre><p id="a346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！您可以通过运行以下命令来检查它的外观:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="cf89" class="nm lx it on b gy or os l ot ou">npm start</span></pre><p id="62af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的本地设置如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/40dedf83a381177174934eb29c2b8ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rThabf6K8nqEOuwUahl-iw.png"/></div></div></figure><p id="205b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，我们有输入表单以及输出结果部分！现在这一切都在本地运行，最后一步是将其部署到Heroku。</p><h1 id="4b50" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">部署到Heroku</h1><p id="d5d5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为部署做好准备还有最后几个步骤。我们需要为我们的服务器建立一个Procfile并构建React代码，这样我们的flask服务器就可以发送结果了。</p><h2 id="a589" class="nm lx it bd ly nn no dn mc np nq dp mg li nr ns mi lm nt nu mk lq nv nw mm nx bi translated">Procfile</h2><p id="4ca2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您所要做的就是创建一个名为<strong class="lb iu"> Procfile </strong>的新文件，并在其中填入:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="ff64" class="nm lx it on b gy or os l ot ou">web: gunicorn app:app</span></pre><h2 id="1953" class="nm lx it bd ly nn no dn mc np nq dp mg li nr ns mi lm nt nu mk lq nv nw mm nx bi translated">反应生成</h2><p id="2412" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">另一个简单的步骤是，一旦你进入<strong class="lb iu">/客户端/ </strong>目录，你可以运行:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="e87c" class="nm lx it on b gy or os l ot ou">npm run build</span></pre><p id="76e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将生成一个名为<strong class="lb iu"> /client/build/ </strong>的新目录，这是我们的Flask服务器在根路径上指向的位置。</p><blockquote class="pn po pp"><p id="984e" class="kz la lv lb b lc ld ju le lf lg jx lh pq lj lk ll pr ln lo lp ps lr ls lt lu im bi translated">注意:构建步骤可能需要一些时间，这取决于你的应用程序有多大</p></blockquote><p id="7db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以将所有文件添加到git存储库中，如下所示:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="00d1" class="nm lx it on b gy or os l ot ou">git add .<br/>git commit -am "All of teh codes"<br/>git push heroku master</span></pre><p id="188f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也要花很多时间，所以去喝杯咖啡吧。一旦推送完成，你会看到Heroku自动检测到你正在推送一个Flask应用程序，它会为你的安装所有的包和服务器！如果你曾经尝试过自己做，这是疯狂的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/d928a7105392b6a07331bb567a2e1a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*szlTPlZ8A6QBRoRRvHsiPA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">该版本在控制台中的外观</p></figure><p id="14db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有这些艰苦的工作之后，我们可以看到我们创造了什么，并且可以与大众分享。看看这个视频，看看它是如何工作的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/4c7cbf58cdeca6bc7db20db21e0aee87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*L3YoVYsaTrY4OGy6DyO9Cw.gif"/></div></div></figure><p id="a3ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后这里是你可以自己尝试的链接！</p><p id="bf67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://labs.datastuff.plus" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="lv">http://labs . datastuff . plus</em></strong></a></p><blockquote class="oy"><p id="737d" class="oz pa it bd pb pc pd pe pf pg ph lu dk translated">如果你有问题或需要有人就你的项目进行咨询，请给我发消息到kyleanthonypastor@gmail.com，如果你在instagram上，请关注我@ datastuffplus。</p></blockquote></div></div>    
</body>
</html>