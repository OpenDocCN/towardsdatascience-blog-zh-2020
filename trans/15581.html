<html>
<head>
<title>String Matching With FuzzyWuzzy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用FuzzyWuzzy进行字符串匹配</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/string-matching-with-fuzzywuzzy-e982c61f8a84?source=collection_archive---------1-----------------------#2020-10-27">https://towardsdatascience.com/string-matching-with-fuzzywuzzy-e982c61f8a84?source=collection_archive---------1-----------------------#2020-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4aab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用FuzzyWuzzy库匹配序列的教程</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ad0e4b1a8bc34a2c026a7e68fee83d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcoJgWEvYQagUXFJUNwBxA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@jhaland?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约尔根·哈兰</a>在<a class="ae le" href="https://unsplash.com/s/photos/twins?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="e3e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本教程将介绍如何通过相似性来匹配字符串。FuzzyWuzzy通过提供诸如Levenshtein距离计算等工具，可以在数据科学过程中为您节省大量时间。除了例子之外，我还将包括一些有用的提示来充分利用FuzzyWuzzy。</p><p id="2ae5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">字符串匹配在各种情况下都很有用，例如，当两个表中运动员姓名的拼写或标点不同时，可以将两个表连接起来。这就是FuzzyWuzzy来拯救世界的时候了！Fuzzywuzzy使用两个序列之间的某种相似性比率，并返回相似性百分比，而不是为了匹配而尝试格式化字符串。更详细的描述，请看一下<a class="ae le" href="https://pypi.org/project/fuzzywuzzy/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">文档</strong> </a>。让我们从导入必要的库开始，并查看一个简单的示例。虽然不是必需的，但是强烈推荐使用FuzzyWuzzy使用<a class="ae le" href="https://github.com/ztane/python-Levenshtein/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">python-Levenshtein</strong></a>。它使字符串匹配过程加快了4-10倍，但结果可能与<a class="ae le" href="https://docs.python.org/3/library/difflib.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> difflib </strong> </a>不同，difflib是一个提供用于比较序列的类和函数的模块。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="eb18" class="lk ll it lg b gy lm ln l lo lp"><strong class="lg iu">#Installing FuzzyWuzzy</strong><br/>pip install fuzzywuzzy</span><span id="6793" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Import<br/></strong>import fuzzywuzzy<br/>from fuzzywuzzy import fuzz<br/>from fuzzywuzzy import process</span><span id="b33b" class="lk ll it lg b gy lq ln l lo lp">Str_A = 'FuzzyWuzzy is a lifesaver!'<br/>Str_B = 'fuzzy wuzzy is a LIFE SAVER.' </span><span id="bcbc" class="lk ll it lg b gy lq ln l lo lp">ratio = fuzz.ratio(Str_A.lower(), Str_B.lower())<br/>print('Similarity score: {}'.format(ratio))</span><span id="9b4c" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Output<br/></strong>Similarity score: 93</span></pre><p id="0a16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用上面的<code class="fe lr ls lt lg b">ratio()</code>函数来计算两个字符串(序列)之间的Levenshtein距离相似性比率。这里的相似率百分比是93%。当两者都是小写时，我们可以说<code class="fe lr ls lt lg b">Str_B</code>和<code class="fe lr ls lt lg b">Str_A</code>有93%的相似度。</p><h2 id="f794" class="lk ll it bd lu lv lw dn lx ly lz dp ma kb mb mc md kf me mf mg kj mh mi mj mk bi translated">部分比率</h2><p id="2b9c" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">FuzzyWuzzy还有更强大的函数来帮助在更复杂的情况下匹配字符串。<code class="fe lr ls lt lg b">partial ratio()</code>函数允许我们执行子串匹配。这是通过获取最短的字符串并将其与所有长度相同的子字符串进行匹配来实现的。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="2342" class="lk ll it lg b gy lm ln l lo lp">Str_A = 'Chicago, Illinois' <br/>Str_B = 'Chicago'</span><span id="f497" class="lk ll it lg b gy lq ln l lo lp">ratio = fuzz.partial_ratio(Str_A.lower(), Str_B.lower())<br/>print('Similarity score: {}'.format(ratio))</span><span id="aef4" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Output<br/></strong>Similarity score: 100</span></pre><p id="6059" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用上面的<code class="fe lr ls lt lg b">partial ratio()</code>函数，我们得到的相似度为100。在<code class="fe lr ls lt lg b">Chicago</code>和<code class="fe lr ls lt lg b">Chicago, Illinois</code>的场景中，这很有帮助，因为两个字符串都指向同一个城市。这个函数在匹配姓名时也很有用。例如，如果一个序列是某人的名字和中间名，而您试图匹配的序列是此人的名字、中间名和姓氏。<code class="fe lr ls lt lg b">partial_ratio()</code>函数将返回100%匹配，因为这个人的名字和中间名是相同的。</p><h2 id="c554" class="lk ll it bd lu lv lw dn lx ly lz dp ma kb mb mc md kf me mf mg kj mh mi mj mk bi translated">令牌排序比率</h2><p id="cd38" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">FuzzyWuzzy还有一些标记函数，可以标记字符串，将大写字母改为小写字母，以及删除标点符号。<code class="fe lr ls lt lg b">token_sort_ratio()</code>函数按字母顺序对字符串进行排序，然后将它们连接在一起。然后，计算<code class="fe lr ls lt lg b">fuzz.ratio()</code>。当您比较的字符串拼写相同，但顺序不同时，这就很方便了。让我们用另一个名字的例子。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="d159" class="lk ll it lg b gy lm ln l lo lp">Str_A = 'Gunner William Kline' <br/>Str_B = 'Kline, Gunner William'</span><span id="49cb" class="lk ll it lg b gy lq ln l lo lp">ratio = fuzz.token_sort_ratio(Str_A, Str_B)<br/>print('Similarity score: {}'.format(ratio))</span><span id="a7e0" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Output<br/></strong>Similarity score: 100</span></pre><h2 id="b39b" class="lk ll it bd lu lv lw dn lx ly lz dp ma kb mb mc md kf me mf mg kj mh mi mj mk bi translated">令牌集比率</h2><p id="b48f" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated"><code class="fe lr ls lt lg b">token_set_ratio()</code>函数类似于上面的<code class="fe lr ls lt lg b">token_sort_ratio()</code>函数，除了它在计算新字符串之间的<code class="fe lr ls lt lg b">fuzz.ratio()</code>之前取出公共标记。当应用于一组长度差异很大的字符串时，这个函数是最有用的。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="f3a7" class="lk ll it lg b gy lm ln l lo lp">Str_A = 'The 3000 meter steeplechase winner, Soufiane El Bakkali' <br/>Str_B = 'Soufiane El Bakkali'</span><span id="6a36" class="lk ll it lg b gy lq ln l lo lp">ratio = fuzz.token_set_ratio(Str_A, Str_B)<br/>print('Similarity score: {}'.format(ratio))</span><span id="5f1b" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Output<br/></strong>Similarity score: 100</span></pre><h2 id="77f9" class="lk ll it bd lu lv lw dn lx ly lz dp ma kb mb mc md kf me mf mg kj mh mi mj mk bi translated">过程模块</h2><p id="86f4" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">FuzzyWuzzy还附带了一个方便的模块process，它返回字符串以及字符串向量的相似性得分。你所需要做的就是在进程之后调用<code class="fe lr ls lt lg b">extract()</code>函数。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="929e" class="lk ll it lg b gy lm ln l lo lp">choices = ["3000m Steeplechase", "Men's 3000 meter steeplechase",                    "3000m STEEPLECHASE MENS", "mens 3000 meter SteepleChase"]  </span><span id="53c5" class="lk ll it lg b gy lq ln l lo lp">process.extract("Men's 3000 Meter Steeplechase", choices, scorer=fuzz.token_sort_ratio)</span><span id="cdb6" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Output<br/></strong>[("Men's 3000 meter steeplechase", 100),<br/> ('mens 3000 meter SteepleChase', 95),<br/> ('3000m STEEPLECHASE MENS', 85),<br/> ('3000m Steeplechase', 77)]</span></pre><p id="8b43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似于<code class="fe lr ls lt lg b">extract</code>函数，您也可以通过调用<code class="fe lr ls lt lg b">extractOne()</code>函数，使用流程模块只提取一个具有最高相似性得分的字符串。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="e896" class="lk ll it lg b gy lm ln l lo lp">choices = ["3000m Steeplechase", "Men's 3000 meter steeplechase",                    "3000m STEEPLECHASE MENS", "mens 3000 meter SteepleChase"]</span><span id="5842" class="lk ll it lg b gy lq ln l lo lp">process.extractOne("Men's 3000 Meter Steeplechase", choices, scorer=fuzz.token_sort_ratio)</span><span id="5846" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Output<br/></strong>("Men's 3000 meter steeplechase", 100)</span></pre><h2 id="24d1" class="lk ll it bd lu lv lw dn lx ly lz dp ma kb mb mc md kf me mf mg kj mh mi mj mk bi translated">用FuzzyWuzzy替换字符串</h2><p id="f25a" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">看看下面的数据框，左边的<code class="fe lr ls lt lg b">df_1</code>和右边的<code class="fe lr ls lt lg b">df_2</code><code class="fe lr ls lt lg b">df_1</code>包含了参加夏季奥运会的运动员。这个数据帧有一个<code class="fe lr ls lt lg b">name</code>列，其中运动员的名字是字符串。如果我想得到这些运动员参加的项目的结果，我会把表格刮下来，放入数据框中。从那里，我可以将事件的结果与下面的数据框架(左)进行左连接。为此，我需要指定要连接值的列或索引级别。</p><div class="kp kq kr ks gt ab cb"><figure class="mq kt mr ms mt mu mv paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/d9205bee5e765ff9947e1304fb61ac43.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*WQ0crWLSbJCBm9qlodDM2A.png"/></div></figure><figure class="mq kt mw ms mt mu mv paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><img src="../Images/de5dedd45589dbb09b2d51a15c1c3930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*qKZIiQYD8Lzdv6IJRpouKA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk mx di my mz translated"><strong class="bd na">东风_1(左)|东风_2(右)(图片由作者提供)</strong></p></figure></div><p id="ad03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们遇到的问题是，第一个数据帧中的一些名称与第二个数据帧的格式不同。如果我尝试将第二个数据帧连接到name列的第一个数据帧，这些值将不会找到匹配，因此，这些值不会在我们需要的位置。在这里，我们可以将每个数据帧中的名称转换成一个列表，然后用FuzzyWuzzy创建一个函数来返回一个字典，其中包含我们需要替换的字符串，以便找到值的匹配。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="14bd" class="lk ll it lg b gy lm ln l lo lp"><strong class="lg iu">#Casting the name column of both dataframes into lists</strong></span><span id="16d8" class="lk ll it lg b gy lq ln l lo lp">df1_names = list(df_1.name.unique())<br/>df2_names = list(df_2.name.unique())<br/></span><span id="5ada" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Defining a function to return the match and similarity score of the fuzz.ratio() scorer. The function will take in a term(name), list of terms(list_names), and a minimum similarity score(min_score) to return the match. </strong></span><span id="8555" class="lk ll it lg b gy lq ln l lo lp">def match_names(name, list_names, min_score=0):<br/>    max_score = -1<br/>    max_name = ''<br/>    for x in list_names:<br/>        score = fuzz.ratio(name, x)<br/>        if (score &gt; min_score) &amp; (score &gt; max_score):<br/>            max_name = x<br/>            max_score = score<br/>    return (max_name, max_score)<br/></span><span id="8ea0" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#For loop to create a list of tuples with the first value being the name from the second dataframe (name to replace) and the second value from the first dataframe (string replacing the name value). Then, casting the list of tuples as a dictionary. </strong></span><span id="775a" class="lk ll it lg b gy lq ln l lo lp">names = []<br/>for x in doping_names:<br/>    match = match_names(x, athlete_names, 75)<br/>    if match[1] &gt;= 75:<br/>        name = ('(' + str(x), str(match[0]) + ')')<br/>        names.append(name)<br/>name_dict = dict(names)<br/>name_dict</span><span id="28c2" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Output</strong></span><span id="7b15" class="lk ll it lg b gy lq ln l lo lp">{'Abdelatif Chemlal': 'Abdelatif Chemlal',<br/> 'Abdelkader Hachlaf': 'Abdelkader Hachlaf',<br/> 'Abderrahim Goumri': 'Abderrahim Al-Goumri',<br/> 'Abraham Kiprotich': 'Abraham Kipchirchir Rotich',<br/> 'Abubaker Ali Kamal': 'Abubaker Ali Kamal',<br/> 'Adil Kaouch': 'Adil El-Kaouch',<br/> 'Adrián Annus': 'Adrin Zsolt Annus',<br/> 'Ahmad Hazer': 'Ahmad Hazer',<br/> 'Ahmed Faiz': 'Ahmed Ali',<br/> 'Ahmed Mohamed Dheeb': 'Mohammed Ahmed',<br/> 'Ak Hafiy Tajuddin Rositi': 'Ak Hafiy Tajuddin Rositi',<br/> 'Aleksandr Bulanov': 'Aleksandar Rakovi',<br/> 'Aleksey Lesnichiy': 'Aleksey Lesnichy',<br/> 'Alemayehu Bezabeh': 'Alemayehu Bezabeh Desta',<br/> 'Alemitu Bekele': 'Alemitu Bekele Degfa',<br/> 'Alex Schwazer': 'Alex Schwazer',<br/> 'Alicia Brown': 'Alicia Brown',<br/> 'Alissa Kallinikou': 'Alissa Kallinikou',<br/> 'Allison Randall': 'Allison Randall',<br/> 'Amaka Ogoegbunam': 'Amaka Ogoegbunam',<br/> 'Amantle Montsho': 'Amantle Montsho',<br/> 'Amina Aït Hammou': 'Amina "Mina" At Hammou',<br/> 'Amine Laâlou': 'Amine Lalou',<br/> 'Anastasios Gousis': 'Anastasios "Tasos" Gousis',<br/> 'Anastasiya Soprunova': 'Anastasiya Valeryevna Soprunova',<br/> 'Antonio David Jiménez': 'AntonioDavid Jimnez Pentinel',<br/> 'Anzhelika Shevchenko': 'Anzhelika Viktorivna Shevchenko}</span><span id="6226" class="lk ll it lg b gy lq ln l lo lp"><strong class="lg iu">#Using the dictionary to replace the keys with the values in the 'name' column for the second dataframe</strong></span><span id="ce24" class="lk ll it lg b gy lq ln l lo lp">df_2.name = df_2.name.replace(name_dict)</span></pre><p id="0981" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的输出可以看出，当将元组列表转换为字典时，我们可以很容易地用新的字符串替换原来的字符串。这样做时，当我将数据帧连接在一起时，这些值将位于匹配的<code class="fe lr ls lt lg b">name</code>上的正确位置。</p><pre class="kp kq kr ks gt lf lg lh li aw lj bi"><span id="d02d" class="lk ll it lg b gy lm ln l lo lp">combined_dataframe = pd.merge(df_1, df_2, how='left', on='name')</span></pre><h2 id="183b" class="lk ll it bd lu lv lw dn lx ly lz dp ma kb mb mc md kf me mf mg kj mh mi mj mk bi translated">结论</h2><p id="d7ee" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">这篇文章介绍了Python中用于字符串匹配的FuzzyWuzzy库。FuzzyWuzzy有许多不同的用例，在查找字符串匹配时，它肯定能节省您的时间。我建议花些时间尝试不同的函数和方法，找到解决问题的最佳方案。非常感谢你花时间来看我的博客！</p><h2 id="81c6" class="lk ll it bd lu lv lw dn lx ly lz dp ma kb mb mc md kf me mf mg kj mh mi mj mk bi translated">参考</h2><ul class=""><li id="1ca8" class="nb nc it js b jt ml jx mm kb nd kf ne kj nf kn ng nh ni nj bi translated"><em class="nk">阿里亚斯，F. (2019)。Python中的模糊字符串匹配。检索2020年10月27日，来自</em><a class="ae le" href="https://www.datacamp.com/community/tutorials/fuzzy-string-python?utm_source=adwords_ppc" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://www . data camp . com/community/tutorials/fuzzy-string-python？UTM _ source = AdWords _ PPC</em>T6】</a></li><li id="7b9d" class="nb nc it js b jt nl jx nm kb nn kf no kj np kn ng nh ni nj bi translated"><em class="nk"> Gitau，C. (2018年03月05日)。Python中的模糊字符串匹配。2020年10月27日检索，来自</em><a class="ae le" rel="noopener" target="_blank" href="/fuzzy-string-matching-in-python-68f240d910fe"><em class="nk">https://towardsdatascience . com/fuzzy-string-matching-in-python-68f 240d 910 Fe</em></a></li><li id="9d7b" class="nb nc it js b jt nl jx nm kb nn kf no kj np kn ng nh ni nj bi translated"><em class="nk"> Fuzzywuzzy。(未注明)。检索到2020年10月27日，来自</em><a class="ae le" href="https://pypi.org/project/fuzzywuzzy/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://pypi.org/project/fuzzywuzzy/</em></a></li><li id="f93b" class="nb nc it js b jt nl jx nm kb nn kf no kj np kn ng nh ni nj bi translated"><em class="nk"> Ztane。(未注明)。Ztane/python-Levenshtein。检索到2020年10月27日，来自</em>【https://github.com/ztane/python-Levenshtein/】<em class="nk"/></li><li id="2ed1" class="nb nc it js b jt nl jx nm kb nn kf no kj np kn ng nh ni nj bi translated"><em class="nk">diff lib——计算增量的助手。(未注明)。检索到2020年10月27日，转自</em><a class="ae le" href="https://docs.python.org/3/library/difflib.html" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://docs.python.org/3/library/difflib.html</em></a></li></ul></div></div>    
</body>
</html>