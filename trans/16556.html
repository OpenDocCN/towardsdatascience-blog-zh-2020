<html>
<head>
<title>Spotlighting Data in Simple Little Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在简单的小表格中突出数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-highlight-cells-in-matplotlib-tables-bd438cd4858a?source=collection_archive---------22-----------------------#2020-11-15">https://towardsdatascience.com/how-to-highlight-cells-in-matplotlib-tables-bd438cd4858a?source=collection_archive---------22-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2e7d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">驯服Matplotlib表的更多方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0ed896b7d027015ecb57d50f0b22f549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VWQW063d7BJgJbBzXarrQw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如何突出显示单元格(图片由作者提供)</p></figure><p id="514d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当显示表格数据时，我们通常希望关注某个特定的单元格。这种关注改善了我们希望从表中获得的视觉支持，并使观众不会被包含在整个值集中的数据的广度所淹没。尽管如此，我们还是希望在整个集合的上下文中呈现关键信息。有了表格，我们可以通过使单元格在大小、粗细、颜色、形状、间距或边框上与其他单元格不同来突出显示所需的单元格。</p><p id="906b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文对我之前的文章<a class="ae lr" rel="noopener" target="_blank" href="/simple-little-tables-with-matplotlib-9780ef5d0bc4">“使用Matplotlib的简单小表格”</a>进行了扩展，提供了一组我们可以用来突出Matplotlib表格中的单元格的技术。这些技术包括改变单元格的边框宽度、背景颜色、字体粗细和字体颜色的方法。我们还将看到如何淡化未突出显示的单元格。在这个过程中，我们将发现一些相关的样式技术，比如改变表格网格线的颜色和使用开源调色板。我将注释转换的每一步，以提供对<code class="fe ls lt lu lv b">pyplot.table</code>行为的洞察，我们可能会重用这些行为来完成其他任务，或者让您扩展我正在分享的发现。我会在文章的最后呈现完整的源代码，所以你不需要一行一行的拼凑。</p><h2 id="b247" class="lw lx iq bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">起点</h2><p id="bb47" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">起点是来自<a class="ae lr" rel="noopener" target="_blank" href="/simple-little-tables-with-matplotlib-9780ef5d0bc4">“使用Matplotlib的简单小表”</a>文章的最终代码。这些技术也应该适用于从<code class="fe ls lt lu lv b">pyplot.table</code>派生的任何可能需要调整的表。</p><h2 id="a91d" class="lw lx iq bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">更改调色板</h2><p id="41c5" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">我们要做的第一件事是从继承自<code class="fe ls lt lu lv b">pyplot.table</code>例子的色图中改变调色板。我使用了一个令人愉快的调色板，由colourlovers.com的TaraLynn1221命名为<a class="ae lr" href="https://www.colourlovers.com/palette/4751687/Outcomes" rel="noopener ugc nofollow" target="_blank">“Outcomes”</a>。使用来自艺术社区的开源调色板是我们设计困难的程序员可以将至少在某些情况下匹配的颜色放在一起的一种方式。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="eb3c" class="lw lx iq lv b gy my mz l na nb"># colors from "Outcomes" palette by TaraLynn1221<br/># https://www.colourlovers.com/palette/4751687/Outcomes<br/>cl_outcomes = {<br/>    'white':'#FFFFFF',<br/>    'gray': '#AAA9AD',<br/>    'black':'#313639',<br/>    'purple':'#AD688E',<br/>    'orange':'#D18F77',<br/>    'yellow':'#E8E190',<br/>    'ltgreen':'#CCD9C7',<br/>    'dkgreen':'#96ABA0',<br/>    }<br/><br/>...<br/><br/># Get some lists of color specs for row and column headers<br/>rcolors = np.full(len(row_headers), cl_outcomes['ltgreen'])<br/>ccolors = np.full(len(column_headers), cl_outcomes['ltgreen'])</span></pre><p id="5106" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还为我们将要创建的高亮单元格和绘图中的其他组件创建了一些颜色变量。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="cf29" class="lw lx iq lv b gy my mz l na nb">grid_color = cl_outcomes['dkgreen']<br/>fig_background_color = cl_outcomes['white']<br/>fig_border = cl_outcomes['dkgreen']<br/>label_text_color = cl_outcomes['black']<br/>highlight_text_color = cl_outcomes['yellow']<br/>faded_text_color = cl_outcomes['gray']<br/>highlight_color = cl_outcomes['purple']<br/>highlight_border = cl_outcomes['dkgreen']<br/>title_text_color = cl_outcomes['black']</span></pre><p id="0ba0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在此期间，我为文本元素更新并添加了一些变量。在本例中，我们将向图中添加文本注释和副标题。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="1245" class="lw lx iq lv b gy my mz l na nb">title_text = 'Loss by Disaster'<br/>subtitle_text = '(In millions of dollars)'<br/>annotation_text = 'The ten-year loss due to floods is $78.0M.'<br/>footer_text = 'July 28, 2020'</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/26a9eff1efde78d5c0381b21165e10fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pksBjNQ_mhSuadXMn9b3nQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">更改调色板(图片由作者提供)</p></figure><h2 id="a132" class="lw lx iq bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">突出显示单元格</h2><p id="91c3" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">突出显示是通过设置单元格的填充和边缘(边框)颜色实现的。如果需要，可以对几个单元格重复此过程。</p><p id="5138" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">表格对象由单元格对象组成。使用从表格左上角开始的<code class="fe ls lt lu lv b">(0,0)</code>索引来引用单元格。列标题在这个矩阵中，所以(0，0)指的是第一个列标题。行标题确实是这个矩阵的一部分，但是被索引为列<code class="fe ls lt lu lv b">-1</code>。</p><p id="9490" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的代码将突出显示第二行第三列中的单元格。记住，我们必须考虑第0行是列标题行。行标题的列索引为<code class="fe ls lt lu lv b">-1</code>。最上面一行的标题是<code class="fe ls lt lu lv b">(1,-1)</code>。</p><p id="2e9f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了突出显示，我们从表中检索单元格。然后，我们设置表面颜色，边缘颜色和线宽。为了控制字体样式，我们从单元格中获取文本对象。可以控制的文本属性是有限制的。例如，设置单个单元格的字体大小没有任何效果。数据网格中的所有单元格需要具有相同的字体大小，这是在表格级别控制的。</p><p id="9d15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们完成了所有想要的高亮样式的改变，我们就调用<code class="fe ls lt lu lv b">ax.add_patch()</code>来传递对单元格的引用。您可能认为简单地更改属性就足以设置样式，但这似乎并没有按z顺序重新定位单元格，相邻的单元格样式显示在突出显示的单元格的顶部。将单元格作为补丁添加到Axes对象可以解决这个问题。如果你找到了更优雅的方式，请在评论中告诉我们。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="fb42" class="lw lx iq lv b gy my mz l na nb"># Highlight the cell to draw attention to it<br/>the_cell = the_table[2,2]<br/>the_cell.set_facecolor(highlight_color)<br/>the_cell.set_edgecolor(highlight_border)<br/>the_cell.set_linewidth(2)<br/>the_text = the_cell.get_text()<br/>#the_text.set_weight('bold')<br/>the_text.set_fontstyle('italic')<br/>the_text.set_color(highlight_text_color)<br/>ax.add_patch(the_cell)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/5bedd8930769bae113fdf6b640b859cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbKREwr8mvFstzOxaCObmA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">突出显示单元格(作者图片)</p></figure><p id="8c7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Cell对象是Matplotib矩形的子类。矩形是面片的子类。这种继承意味着您可以引用Rectangle和Patches的属性和功能，从而对格式进行更多的控制。</p><h2 id="260e" class="lw lx iq bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">淡化未突出显示的单元格</h2><p id="5b49" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">为了将更多的注意力吸引到突出显示的单元格，我们可以淡化它们。我们将使用类似于高亮显示的技术将它们设置为较浅的颜色。我们可以调用<code class="fe ls lt lu lv b">get_children()</code>来获取单元格列表并遍历它们。表格只包含单元格，因此不需要对元素进行类型检查。对于每个单元格，我们得到它的文本对象。从过程中排除标题就像检查标题标签列表中的单元格文本一样简单。当然，如果您的单元格的值与标签相匹配，您就需要想出另一种方法。这种循环技术也是我们设置表格边框颜色的方式，所以我们在这里添加<code class="fe ls lt lu lv b">cell.set_edgecolor(grid_color)</code>。Table对象上没有设置该颜色的属性，所以我们用循环的方式来设置。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="ee44" class="lw lx iq lv b gy my mz l na nb"># Fade the cells<br/>for cell in the_table.get_children():<br/>    cell_text = cell.get_text().get_text()<br/>    cell.set_edgecolor(grid_color)<br/>    if cell_text not in row_headers\<br/>       and cell_text not in column_headers:<br/>        cell.get_text().set_color(faded_text_color)<br/>    else:<br/>        cell.get_text().set_weight('bold')<br/>        cell.get_text().set_color(label_text_color)</span></pre><p id="45c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以添加代码来排除突出显示的单元格。不过，更简单的方法是在突出显示之前全部淡入淡出。因此，让我们在流程的前面插入衰落代码例程。</p><p id="ea5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">get_children()</code>的替代物是<code class="fe ls lt lu lv b">get_celld()</code>。当<code class="fe ls lt lu lv b">get_children()</code>返回一个艺术家对象的列表，而这些对象恰好只是这里的单元格时，<code class="fe ls lt lu lv b">get_celld()</code>将返回一个单元格字典，这些单元格的关键字是行和列元组。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="9a06" class="lw lx iq lv b gy my mz l na nb">print(the_table.get_children())<br/>[&lt;matplotlib.table.CustomCell object at 0x7fb7b430f150&gt;, &lt;matplotlib.table.CustomCell object at 0x7fb7b6bf2890&gt;, &lt;matplotlib.table.CustomCell object at 0x7fb7b6bf26d0&gt;,...<br/><br/>print(the_table.get_celld())<br/>{(1, 0): &lt;matplotlib.table.CustomCell object at 0x7fb7b4313390&gt;, (1, 1): &lt;matplotlib.table.CustomCell object at 0x7fb7b4313e50&gt;, (1, 2): &lt;matplotlib.table.CustomCell object at 0x7fb7b4313150&gt;,...</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/2169f219264528f44c9ef32fc59edc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRjC4A1L4m5gIUyVPvlESQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">淡化未突出显示的单元格(图片由作者提供)</p></figure><p id="98a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">提示:</strong> <code class="fe ls lt lu lv b">get_celld()</code>可用于生成单元格文本的索引表，用于故障排除或按索引手动引用单元格。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="ab86" class="lw lx iq lv b gy my mz l na nb">for key, val in the_table.get_celld().items():<br/>	# call get_text() on Cell and again on returned Text<br/>    print(f'{key}\t{val.get_text().get_text()}')<br/>(1, 0)	66.4<br/>(1, 1)	174.3<br/>(1, 2)	75.1<br/>...</span></pre><h2 id="5120" class="lw lx iq bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">添加注释和副标题</h2><p id="e571" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">如果我们要在演示或报告中使用我们的表格图像，我们可能希望向它添加文本注释，以帮助读者理解我们为什么要调出单元格值。副标题也能帮助读者理解图表。在我们的例子中，我们没有让读者知道表中的度量单位是什么，这样信息就可以成为一个好的副标题。</p><p id="4770" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有几种方法可以在Matplotlib中创建注释。我们在表格周围有大量的空白，所以让我们在图表下面使用一行简单的图形文本。我们也会包括一些造型。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="a3d7" class="lw lx iq lv b gy my mz l na nb"># Add annotation<br/>plt.figtext(0.5, 0.2,<br/>            annotation_text,<br/>            horizontalalignment='center',<br/>            size=9, weight='light',<br/>            color=title_text_color<br/>           )</span></pre><p id="412c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Matplotlib没有给我们一个一流的字幕函数，所以我们也将使用图形文本。不幸的是，这意味着如果我们以后更改标题或整体图形结构，我们可能需要调整它的位置。我们可以使用heroics来计算字幕相对于图片和标题的位置，但是我们将保持简单，并根据实验对字幕位置进行硬编码。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="4d13" class="lw lx iq lv b gy my mz l na nb"># Add subtitle<br/>plt.figtext(0.5, 0.9,<br/>            subtitle_text,<br/>            horizontalalignment='center',<br/>            size=9, style='italic',<br/>            color=title_text_color<br/>           )</span></pre><p id="71a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>记住<code class="fe ls lt lu lv b">suptitle()</code>是在图上设置标题的功能，而不是<em class="ne"> sub </em>标题。不幸的命名。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/76f4e734dbbc4c92ff071edbc9b40375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06rnr8JLJ188l2sck8Q89g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">添加注释和副标题(图片由作者提供)</p></figure><h2 id="354c" class="lw lx iq bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">最终来源</h2><p id="485f" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">这是最终的源代码。我还在标题和页脚中添加了一些明确的样式。我有一个设计师朋友，他教我平面设计中最好的黑色不是纯黑，所以我们用<code class="fe ls lt lu lv b">#313639</code>代替<code class="fe ls lt lu lv b">#000000</code>。</p><p id="8b43" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是最终产品，你可以随心所欲地裁剪。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="2148" class="lw lx iq lv b gy my mz l na nb">import numpy as np<br/>import matplotlib.pyplot as plt<br/><br/><br/># colors from "Outcomes" palette by TaraLynn1221<br/># https://www.colourlovers.com/palette/4751687/Outcomes<br/>cl_outcomes = {<br/>    'white':'#FFFFFF',<br/>    'gray': '#AAA9AD',<br/>    'black':'#313639',<br/>    'purple':'#AD688E',<br/>    'orange':'#D18F77',<br/>    'yellow':'#E8E190',<br/>    'ltgreen':'#CCD9C7',<br/>    'dkgreen':'#96ABA0',<br/>    }<br/><br/>title_text = 'Loss by Disaster'<br/>subtitle_text = '(In millions of dollars)'<br/>annotation_text = 'The ten-year loss due to floods is $78.0M.'<br/>footer_text = 'July 28, 2020'<br/><br/>grid_color = cl_outcomes['dkgreen']<br/>fig_background_color = cl_outcomes['white']<br/>fig_border = cl_outcomes['dkgreen']<br/>label_text_color = cl_outcomes['black']<br/>highlight_text_color = cl_outcomes['yellow']<br/>faded_text_color = cl_outcomes['gray']<br/>highlight_color = cl_outcomes['purple']<br/>highlight_border = cl_outcomes['dkgreen']<br/>title_text_color = cl_outcomes['black']<br/><br/>data =  [<br/>            [         'Freeze', 'Wind', 'Flood', 'Quake', 'Hail'],<br/>            [ '5 year',  66386, 174296,   75131,  577908,  32015],<br/>            ['10 year',  58230, 381139,   78045,   99308, 160454],<br/>            ['20 year',  89135,  80552,  152558,  497981, 603535],<br/>            ['30 year',  78415,  81858,  150656,  193263,  69638],<br/>            ['40 year', 139361, 331509,  343164,  781380,  52269],<br/>        ]<br/><br/># Pop the headers from the data array<br/>column_headers = data.pop(0)<br/>row_headers = [x.pop(0) for x in data]<br/><br/># Table data needs to be non-numeric text. Format the data<br/># while I'm at it.<br/>cell_text = []<br/>for row in data:<br/>    cell_text.append([f'{x/1000:1.1f}' for x in row])<br/><br/># Get some lists of color specs for row and column headers<br/>rcolors = np.full(len(row_headers), cl_outcomes['ltgreen'])<br/>ccolors = np.full(len(column_headers), cl_outcomes['ltgreen'])<br/><br/># Create the figure. Setting a small pad on tight_layout<br/># seems to better regulate white space. Sometimes experimenting<br/># with an explicit figsize here can produce better outcome.<br/>plt.figure(linewidth=1,<br/>           edgecolor=fig_border,<br/>           facecolor=fig_background_color,<br/>           tight_layout={'pad':1},<br/>           #figsize=(5,3)<br/>          )<br/><br/># Add a table at the bottom of the axes<br/>the_table = plt.table(cellText=cell_text,<br/>                      rowLabels=row_headers,<br/>                      rowColours=rcolors,<br/>                      rowLoc='right',<br/>                      colColours=ccolors,<br/>                      colLabels=column_headers,<br/>                      loc='center')<br/><br/># Scaling is the only influence we have over top and bottom cell padding.<br/># Make the rows taller (i.e., make cell y scale larger).<br/>the_table.scale(1, 1.5)<br/><br/># Hide axes<br/>ax = plt.gca()<br/>ax.get_xaxis().set_visible(False)<br/>ax.get_yaxis().set_visible(False)<br/><br/># Hide axes border<br/>plt.box(on=None)<br/><br/># Add title<br/>plt.suptitle(title_text,<br/>             weight='bold',<br/>             size=14,<br/>             color=title_text_color)<br/><br/># Add subtitle<br/>plt.figtext(0.5, 0.9,<br/>            subtitle_text,<br/>            horizontalalignment='center',<br/>            size=9, style='italic',<br/>            color=title_text_color<br/>           )<br/><br/># Add footer<br/>plt.figtext(0.95, 0.05, footer_text,<br/>            horizontalalignment='right',<br/>            size=6,<br/>            weight='light',<br/>            color=title_text_color<br/>           )<br/><br/># Add annotation<br/>plt.figtext(0.5, 0.2,<br/>            annotation_text,<br/>            horizontalalignment='center',<br/>            size=9, weight='light',<br/>            color=title_text_color<br/>           )<br/><br/># Fade the cells<br/>for cell in the_table.get_children():<br/>    cell_text = cell.get_text().get_text()<br/>    cell.set_edgecolor(grid_color)<br/>    if cell_text not in row_headers\<br/>       and cell_text not in column_headers:<br/>        cell.get_text().set_color(faded_text_color)<br/>    else:<br/>        cell.get_text().set_weight('bold')<br/>        cell.get_text().set_color(label_text_color)<br/><br/># Highlight the cell to draw attention to it<br/>the_cell = the_table[2,2]<br/>the_cell.set_facecolor(highlight_color)<br/>the_cell.set_edgecolor(highlight_border)<br/>the_cell.set_linewidth(2)<br/>the_text = the_cell.get_text()<br/>#the_text.set_weight('bold')<br/>the_text.set_fontstyle('italic')<br/>the_text.set_color(highlight_text_color)<br/>ax.add_patch(the_cell)<br/><br/># Force the figure to update, so backends center objects correctly within the figure.<br/># Without plt.draw() here, the title will center on the axes and not the figure.<br/>plt.draw()<br/><br/># Create image. plt.savefig ignores figure edge and face colors, so map them.<br/>fig = plt.gcf()<br/>plt.savefig('pyplot-table-highlight.png',<br/>            bbox='tight',<br/>            edgecolor=fig.get_edgecolor(),<br/>            facecolor=fig.get_facecolor(),<br/>            dpi=300<br/>            )</span></pre><h2 id="df70" class="lw lx iq bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">结论</h2><p id="394b" class="pw-post-body-paragraph kv kw iq kx b ky mp jr la lb mq ju ld le mr lg lh li ms lk ll lm mt lo lp lq ij bi translated">我们已经有了第一个小表格，并在单元格中添加了一些突出显示，使它对我们的观众来说更加明显。我们学习了如何从开放的设计网站上获取调色板。我们看到了基于大小、颜色、相对褪色和边框的高亮技术。我们学习了添加注释和副标题的简单方法。Matplotlib表格是一个灵活而强大的工具，用于显示表格汇总数据。</p></div></div>    
</body>
</html>