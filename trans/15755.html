<html>
<head>
<title>FP Growth — Frequent Pattern Generation in Data Mining with Python Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FP增长——用Python实现数据挖掘中的频繁模式生成</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fp-growth-frequent-pattern-generation-in-data-mining-with-python-implementation-244e561ab1c3?source=collection_archive---------0-----------------------#2020-10-30">https://towardsdatascience.com/fp-growth-frequent-pattern-generation-in-data-mining-with-python-implementation-244e561ab1c3?source=collection_archive---------0-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a356" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在大项目集中挖掘关联规则的强大算法！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9ca8d7481546508d9c77e59a18d97b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3dLedvJFBh7iD7RZ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@fabioha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比奥</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="8d08" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="151f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在前一篇文章中，我们已经介绍了Apriori算法，并指出了它的主要缺点。在本文中，我们将展示一种叫做FP增长算法的高级方法。我们将介绍FP增长算法的整个过程，并解释为什么它比Apriori算法更好。</p><div class="mk ml gp gr mm mn"><a rel="noopener follow" target="_blank" href="/apriori-association-rule-mining-explanation-and-python-implementation-290b42afdfc6"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">Apriori:关联规则挖掘的深层解释及Python实现</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">关联规则挖掘是一种识别不同项目之间潜在关系的技术。方法有很多…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">towardsdatascience.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb kp mn"/></div></div></a></div><h1 id="1714" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么好？</h1><p id="944f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们回忆一下上一篇文章，Apriori算法的两个主要缺点是</p><ul class=""><li id="ca89" class="nc nd iq lq b lr ne lu nf lx ng mb nh mf ni mj nj nk nl nm bi translated">候选项目集的大小可能非常大</li><li id="27e2" class="nc nd iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">计数支持的高成本，因为我们必须一遍又一遍地扫描项目集数据库</li></ul><p id="b9d2" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">为了克服这些挑战，Fp增长的最大突破是</p><blockquote class="nv"><p id="e20b" class="nw nx iq bd ny nz oa ob oc od oe mj dk translated">不需要候选人生成！</p></blockquote><p id="9669" class="pw-post-body-paragraph lo lp iq lq b lr of jr lt lu og ju lw lx oh lz ma mb oi md me mf oj mh mi mj ij bi translated">Apriori的所有问题都可以通过利用<strong class="lq ir"> FP树</strong>来解决。更具体地说，项集大小将不再是一个问题，因为所有的数据将以一种更紧凑的方式存储。此外，没有必要一遍又一遍地扫描数据库。相反，遍历FP树可以更有效地完成同样的工作。</p><h1 id="c0e0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">FP树</h1><p id="31f5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">FP树是整个FP增长算法的核心概念。简单来说，FP树就是项目集数据库的<strong class="lq ir">压缩表示</strong>。树结构不仅在数据库中保留项目集，而且跟踪项目集之间的关联</p><p id="558a" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">该树是通过获取每个项目集并一次一个地将其映射到树中的路径来构建的。这个建筑背后的整个想法是</p><blockquote class="nv"><p id="dadf" class="nw nx iq bd ny nz oa ob oc od oe mj dk translated">更频繁出现的项目将有更好的机会共享项目</p></blockquote><p id="ca4c" class="pw-post-body-paragraph lo lp iq lq b lr of jr lt lu og ju lw lx oh lz ma mb oi md me mf oj mh mi mj ij bi translated">然后我们递归地挖掘树来得到频繁模式。模式增长，算法的名字，是通过连接从条件FP树生成的频繁模式来实现的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/0c0ededaa9ccac0be657b721f4925957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5CAJ1_b89rO09e6hFkWKA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">忽略树上的箭头。图片作者。</p></figure><h1 id="969b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">FP增长算法</h1><p id="4c0d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">请随意查看评论良好的源代码。这真的有助于理解整个算法。</p><div class="mk ml gp gr mm mn"><a href="https://github.com/chonyy/fpgrowth_py" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">chonyy/fpgrowth_py</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">pip安装fpgrowth_py，然后像使用git clone git clone一样使用它来获得此回购的副本…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="ol l my mz na mw nb kp mn"/></div></div></a></div><p id="6e04" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">FP增长如此高效的原因是这是一种<strong class="lq ir">分而治之</strong>的方法。我们知道，有效的算法必须利用某种数据结构和高级编程技术。它实现了树、链表和深度优先搜索的概念。这个过程可以分为两个主要阶段，每个阶段又可以进一步分为两步。</p><h2 id="43d3" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">阶段1: FP树构建</h2><blockquote class="oy oz pa"><p id="48bd" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">第一步:清洁和分类</p></blockquote><p id="dd56" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">对于每个事务，我们首先删除低于最低支持的项目。然后，我们按照频率支持<strong class="lq ir">降序</strong>对项目进行排序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/1a7277e21286f7abdf0f4fdb7c6ec23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6UXLjWJ29e87PifsTJ17A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><blockquote class="oy oz pa"><p id="893f" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">第二步:构建FP树，标题表包含已清理的项目集</p></blockquote><p id="e9f4" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">遍历清理后的项集，一次映射一个到树中。如果分支中已经存在任何项目，则它们共享同一个节点，并且计数递增。否则，该项将位于创建的新分支上。</p><p id="9c08" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">标题表也是在这个过程中构建的。交易中每个独特的项目都有一个链表。使用链表，我们可以在短时间内找到项目在树上的出现，而无需遍历树。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/978761f183e95fb447a6937aec20059d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/0*EFLKVZQPgHFrz_mp.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://www.researchgate.net/figure/An-FP-tree-and-its-header-table-15_fig1_280940829" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/figure/An-FP-tree-and-its-header-table-15 _ fig 1 _ 280940829</a></p></figure><h2 id="3956" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">阶段2:挖掘主树和条件FP树</h2><blockquote class="oy oz pa"><p id="99e5" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">步骤1:将主FP树分成条件FP树</p></blockquote><p id="ad7e" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">从每个频繁1-模式开始，我们用FP树中的前缀集<strong class="lq ir"> </strong>创建<strong class="lq ir">条件模式基</strong>。然后，我们使用这些模式库，以与阶段1完全相同的方法来构造条件FP树。</p><blockquote class="oy oz pa"><p id="034a" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">步骤2:递归挖掘每个条件树</p></blockquote><p id="44d7" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">频繁模式从<strong class="lq ir">条件FP树</strong>中生成。为一个频繁模式创建一个条件FP树。我们用来挖掘条件树的递归函数接近深度优先搜索。它确保在继续之前，没有更多的树可以用剩余的项目来构建。</p><p id="d9f0" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">让我们仔细看看下面的过程</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/5e68652ee546bfc5187e881b06bcea10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*7AEq-JSR5_uMs2bNbOd0LQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><p id="b424" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">同级别同颜色。算法工作流程如下所示</p><ol class=""><li id="ec5d" class="nc nd iq lq b lr ne lu nf lx ng mb nh mf ni mj pi nk nl nm bi translated">检查第一个1-频繁模式“a”</li><li id="2ab2" class="nc nd iq lq b lr nn lu no lx np mb nq mf nr mj pi nk nl nm bi translated">获取粉红色的“a”的条件FP树</li><li id="273a" class="nc nd iq lq b lr nn lu no lx np mb nq mf nr mj pi nk nl nm bi translated">挖掘粉红色的树，深入到第二层</li><li id="7814" class="nc nd iq lq b lr nn lu no lx np mb nq mf nr mj pi nk nl nm bi translated">检查粉色树上的“f ”,发现没有更多的树可以构建</li><li id="3df4" class="nc nd iq lq b lr nn lu no lx np mb nq mf nr mj pi nk nl nm bi translated">在粉红色的树上勾选c</li><li id="2a8b" class="nc nd iq lq b lr nn lu no lx np mb nq mf nr mj pi nk nl nm bi translated">开采黄树，深入到第3层</li></ol><h1 id="0b0c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Python实现</h1><h2 id="43a0" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">FP增长函数</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="4542" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">乍一看这个FP growth主函数，你可能会对它的两个部分产生疑问。</p><blockquote class="oy oz pa"><p id="c4e5" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">为什么要为项目集和频率使用单独的列表，而不是创建一个字典？</p></blockquote><p id="56df" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">原因是Python字典中的键必须是不可变的，所以我们不能把set()作为键。然而，不可变版本的set，<strong class="lq ir"> frozenset </strong>是可以接受的。不幸的是，由于这些项目的<strong class="lq ir">顺序</strong>在FP增长算法中至关重要，我们无法在转换到frozenset后保留顺序。对此的唯一解决方案是将其存储在单独的列表中。</p><blockquote class="oy oz pa"><p id="49f1" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">为什么在mineTree函数中不把FP树作为输入变量？</p></blockquote><p id="0954" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">这就是表头的威力。因为我们已经在标题表中存储了所有的事件，所以没有必要将根节点传递给函数。利用表上的链表，我们可以快速找到树上的项目。</p><h2 id="11c8" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">树形结构</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="8c57" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">对于itemset列表，我们首先创建一个半空的标题表，其中只包含项目及其频率。我们遍历每个项目集，按照频率<strong class="lq ir">降序</strong>对项目进行清理和排序。然后，我们通过从清理的项目集中逐个传递项目来更新树。</p><p id="08dc" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">如果项目已经存在于树中，我们只需增加计数。否则，我们用该项创建一个新的分支，并将其附加到父节点。这里要做的一个重要步骤是更新标题表，因为出现了新的条目。将新出现的链接到标题表中的链接列表。</p><h2 id="533b" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">树木开采</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pj pk l"/></div></figure><blockquote class="oy oz pa"><p id="8a3c" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">矿井树</p></blockquote><p id="81e8" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">从1-频繁模式出发，我们找到所有的前缀路径，并用它构造条件模式库。对于条件模式基，使用与上面完全相同的constructTree函数来构建树。如果这棵树能被成功构建，我们会更深入，开始研究这棵树。这是递归发生的地方。</p><p id="9f98" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">还记得我提到过为每个频繁模式构建一个条件树吗？你可以在<strong class="lq ir">线8 </strong>上看到图案生长。</p><blockquote class="oy oz pa"><p id="6c7c" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">查找前缀路径</p></blockquote><p id="20ee" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">获取该项在树上的第一个匹配项，它是表头链表的头节点。然后，遍历树直到根，以获得前缀路径。之后，我们转到链表中的下一个节点，重复遍历。</p><blockquote class="oy oz pa"><p id="8d32" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated">上升FP树</p></blockquote><p id="8b93" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">用自递归来提升树。继续追加项目并调用自身，直到它到达根。</p><h1 id="9492" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">比较</h1><h2 id="c752" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">FP增长与先验</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/01dcc45f85b4d5de5c338dda3861f2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYVTYn1NROTtmy6rrsiCmQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><p id="ecdd" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">我已经组织了两种算法的主要特征，并把它制作成上表。通过观察表格，我们可以知道，在大多数情况下，FP增长通常比先验增长好。这就是为什么Apriori只是一个基本方法，FP Growth是对它的改进。</p><blockquote class="oy oz pa"><p id="0bae" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated"><strong class="lq ir">具有不同最小支持的运行时</strong></p></blockquote><div class="kg kh ki kj gt ab cb"><figure class="pm kk pn po pp pq pr paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/4d66911f2b6ae4bc66cd10cf068fd039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*_AT40QU7LL2tOGuGLDMMCQ.png"/></div></figure><figure class="pm kk pn po pp pq pr paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/6b76c0374a8f5a5e5dce984011f59e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*FcXTl30ynhU83IHtxSt-sA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk ps di pt pu translated">图片作者。</p></figure></div><p id="4e5a" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">我们从<a class="ae kv" href="https://github.com/chonyy/fpgrowth_py" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="pb">源代码回购</em> </strong> </a> <strong class="lq ir"> <em class="pb"> </em> </strong>中取数据集，尝试一些实验。我们做的第一件事是检查最小支持如何推断运行时间。</p><p id="ba8a" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">从图中我们可以看出，FP的增长总是比Apriori快。原因已经在上面解释过了。一个有趣的观察是，在两个数据集上，apriori的运行时间在一个特定的最小值后开始快速增加。另一方面，FP增长的运行时间仅仅受到值的干扰。</p><blockquote class="oy oz pa"><p id="861f" class="lo lp pb lq b lr ne jr lt lu nf ju lw pc ns lz ma pd nt md me pe nu mh mi mj ij bi translated"><strong class="lq ir">运行时有不同数量的交易</strong></p></blockquote><div class="kg kh ki kj gt ab cb"><figure class="pm kk pn po pp pq pr paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/befe602ad7fb960af11cc9e3ef412d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*aEXRNu7yGxCBdFU_Ru2vIA.png"/></div></figure><figure class="pm kk pn po pp pq pr paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/81c5b34550f83db7c87e09715c00ff47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*3Qn99yZtbVvtb4NDvKmS5A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk ps di pt pu translated">图片作者。</p></figure></div><p id="ad96" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">两种算法的运行时间都随着项目集数量的增加而增加。然而，我们可以清楚地看到，先验增加的斜率要高得多。这意味着与Fp增长相比，Apriori算法对项集大小更敏感。</p><h2 id="d31c" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">升序与降序</h2><p id="e9eb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">您可能想知道为什么在使用它构建树之前，我们必须按照频率<strong class="lq ir">降序</strong>对项目进行排序。如果用升序试试会怎么样？从图中可以看出，降序排序总是更快。而且支撑越低速度的差别越明显。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/044d765eabcba9c8e016b2b166f14200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*EjAIVYOT6FWTvpKEpctCAQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><p id="8ed1" class="pw-post-body-paragraph lo lp iq lq b lr ne jr lt lu nf ju lw lx ns lz ma mb nt md me mf nu mh mi mj ij bi translated">但是为什么呢？我想给出一些我自己的假设。让我们回忆一下FP增长的核心概念</p><blockquote class="nv"><p id="20cb" class="nw nx iq bd ny nz oa ob oc od oe mj dk translated">更频繁出现的项目将有更好的机会共享项目</p></blockquote><p id="b905" class="pw-post-body-paragraph lo lp iq lq b lr of jr lt lu og ju lw lx oh lz ma mb oi md me mf oj mh mi mj ij bi translated">从支持度较高的物品开始，共享分支的可能性会较高。共享的分支越多，树的大小就越小。树越小，运行整个算法的成本就越低。因此，按降序对项目进行排序会使该方法运行得更快。</p><h1 id="838b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="61f5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我想分享一个有趣的故事。当我下班后写这篇文章时，一个全职工程师走过，他看到我正在写一些关于先验和Fp增长的东西。他说，“<strong class="lq ir">有趣，但不现实</strong>”他进一步解释说，这种算法不考虑称重。例如，有多个相同项目的交易怎么办？还有更微妙的条件没有包含在这个算法中。这就是为什么公司不会在他们的业务中实现这一点。</p><h1 id="4d28" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">源代码</h1><div class="mk ml gp gr mm mn"><a href="https://github.com/chonyy/fpgrowth_py" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">chonyy/fpgrowth_py</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">pip安装fpgrowth_py，然后像使用git clone git clone一样使用它来获得此回购的副本…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="pw l my mz na mw nb kp mn"/></div></div></a></div><h1 id="7c92" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">以前的帖子</h1><div class="mk ml gp gr mm mn"><a rel="noopener follow" target="_blank" href="/apriori-association-rule-mining-explanation-and-python-implementation-290b42afdfc6"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">Apriori:关联规则挖掘的深层解释及Python实现</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">关联规则挖掘是一种识别不同项目之间潜在关系的技术。方法有很多…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">towardsdatascience.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb kp mn"/></div></div></a></div><h1 id="3c48" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">PyPi包</h1><div class="mk ml gp gr mm mn"><a href="https://pypi.org/project/fpgrowth-py/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">fpgrowthfy</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">pip安装fpgrowth_py，然后像使用git clone git clone一样使用它来获得此回购的副本…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">pypi.org</p></div></div><div class="mw l"><div class="px l my mz na mw nb kp mn"/></div></div></a></div></div></div>    
</body>
</html>