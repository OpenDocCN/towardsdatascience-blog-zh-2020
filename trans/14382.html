<html>
<head>
<title>Time series analysis for predictive maintenance of turbofan engines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">涡轮风扇发动机预测维修的时间序列分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-analysis-for-predictive-maintenance-of-turbofan-engines-1b3864991da4?source=collection_archive---------7-----------------------#2020-10-04">https://towardsdatascience.com/time-series-analysis-for-predictive-maintenance-of-turbofan-engines-1b3864991da4?source=collection_archive---------7-----------------------#2020-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6ea22af429864cb189ae40d00bd8c8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bQ-ojy-xfzz7dQFF"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">艾萨克·史密斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="4244" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/exploring-nasa-turbofan" rel="noopener" target="_blank">探索美国宇航局的涡轮风扇数据集</a></h2><div class=""/><div class=""><h2 id="f492" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">使用分布滞后模型预测剩余使用寿命</h2></div><p id="87a7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="md"> &lt;免责声明:我的目的是展示模型开发过程中不同方法和选择的效果。这些影响经常使用测试集来显示，这被认为是(非常)不好的做法，但有助于教育目的。&gt; </em></p><p id="b931" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">欢迎来到“探索NASA的涡轮风扇数据集”系列的另一部分。这将是对FD001的第三次分析，在FD 001中，所有发动机在相同的操作条件下运行，并产生相同的故障。</p><p id="2637" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最初，我们假设发动机的剩余使用寿命(RUL)呈线性下降。在我的<a class="ae jg" rel="noopener" target="_blank" href="/the-importance-of-problem-framing-for-supervised-predictive-maintenance-solutions-cc8646826093?source=friends_link&amp;sk=ec51cbfa29f084ed94fe59d0daf51df0">上一篇文章</a>中，我们通过截取任何大于125的值来重新检验这个假设。剪切RUL将基线线性回归提高了31%(从31.95的RMSE到21.90的RMSE)。然后，我们切换到支持向量回归，并挤出另外6%的改善，总RMSE为20.54。</p><p id="e736" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">今天，我们将重点关注时间序列分析，以预测发动机何时需要保养。但是，在进入时间序列部分之前，我们首先必须回顾几个处理步骤。我们开始吧！</p><h1 id="1ca8" class="me mf jj bd mg mh mi mj mk ml mm mn mo ky mp kz mq lb mr lc ms le mt lf mu mv bi translated">加载数据</h1><p id="72f5" class="pw-post-body-paragraph lh li jj lj b lk mw kt lm ln mx kw lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">首先，我们将导入一些库并读取数据。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0cbf4944894aae0e92422412d588123b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*k2BzjECfoR7PSEhFlaqs4A.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">train.head()的结果</p></figure><p id="7e3a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">看起来不错。接下来，计算线性递减RUL(稍后添加裁剪)，并删除无信息列。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">RUL在击穿时可以认为是0，我们天真地假设RUL是一个线性函数。意味着在击穿前的10个周期时RUL是10，在击穿前的50个周期时是50，等等。</p></figure><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/159b4fffe4598dded3faae24347847ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*HSXK7dzPl2eL6FkeYkUj_g.png"/></div></figure><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="754a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很好，现在我们来讨论一下我们的方法。</p><h1 id="260e" class="me mf jj bd mg mh mi mj mk ml mm mn mo ky mp kz mq lb mr lc ms le mt lf mu mv bi translated">方法</h1><p id="cc0a" class="pw-post-body-paragraph lh li jj lj b lk mw kt lm ln mx kw lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">此数据集的时间序列分析和预测可以通过以下三种方法之一完成:</p><ol class=""><li id="92b4" class="nj nk jj lj b lk ll ln lo lq nl lu nm ly nn mc no np nq nr bi translated">预测传感器值并设置“报警”阈值。当预测传感器越过该阈值时，部件劣化到即将击穿的状态。对于当前数据集使用这种方法有一些注意事项。<br/> (a)每个传感器都必须单独建模，因此我们无法利用传感器之间的相互作用。<br/> (b)它需要大量的领域知识来设置适当的阈值，并且<br/> (c)它不直接通知我们关于我们的目标特性，剩余使用寿命(RUL)。</li><li id="04b7" class="nj nk jj lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">向量自回归(VAR)型模型。这些类型的模型可以处理多变量时间序列，但是模型最初会产生X和Y变量的滞后。通常，在时间序列中，Y的过去值在确定Y的未来值时起着很大的作用。但是，由于我们假设Y的值在训练集中保持不变或线性下降，因此将这些自定义目标纳入模型并使用它们进行预测会严重影响模型结果，并过分强调Yt-1对Yt的影响。您可以编写一些自定义代码，将滞后Y变量的权重系数设置为0，但在我看来，有一种更简单的方法。</li><li id="58be" class="nj nk jj lj b lk ns ln nt lq nu lu nv ly nw mc no np nq nr bi translated">分布式滞后模型。基本上，这是一个回归模型，您可以完全控制为每个变量添加多少滞后。</li></ol><p id="5230" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在创建分布式滞后模型时，我们可以使用时间序列和回归分析中的许多工具和测试。但是，我们将从小处着手，并根据需要增加复杂性。</p><p id="9ef2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们要实现的模型的基本形式如下:</p><p id="e1ac" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe nx ny nz oa b">Yt = a + B1*Xt + B2*Xt-1 + … + Bn*Xt-n</code></p><p id="ad27" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中<code class="fe nx ny nz oa b">a</code>是截距，<code class="fe nx ny nz oa b">B1</code>到<code class="fe nx ny nz oa b">Bn</code>是系数。<code class="fe nx ny nz oa b">Xt-1</code>和<code class="fe nx ny nz oa b">Xt-n</code>是<code class="fe nx ny nz oa b">Xt</code>的滞后变量，分别滞后1到n，<code class="fe nx ny nz oa b">Yt</code>是当前时刻<code class="fe nx ny nz oa b">t</code>的目标变量。<br/> <em class="md">注意:为了与之前的帖子保持一致，我们预测Yt的RUL，如果你想预测下一个time_cycle (Yt+1)的RUL，你可以简单地将目标移动一位，如下所述</em>。</p><h1 id="f690" class="me mf jj bd mg mh mi mj mk ml mm mn mo ky mp kz mq lb mr lc ms le mt lf mu mv bi translated">添加滞后变量</h1><p id="ef71" class="pw-post-body-paragraph lh li jj lj b lk mw kt lm ln mx kw lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">我们可以使用熊猫移动函数来添加滞后变量。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b30696f9e8423c8c98cacbaef08ddd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*AgKYzlPNGg3iVXMbqxemhQ.png"/></div></figure><p id="0bb8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可以看到滞后列包含以前时间戳的数据。例如，第2行附加了时间0和1的数据。这就是我们如何从一行中表示的多个时间实例中获取数据，这是供我们的模型使用的一种方便的表示。</p><p id="8f81" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在让我们将这个原则应用到我们的数据集。我们删除由于添加滞后变量而引入NaN值的行，并拟合新的回归模型。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="nb nc nd ne gt oc oa od oe aw of bi"><span id="4a16" class="og mf jj oa b gy oh oi l oj ok"># returns<br/># train set RMSE:39.367692351135005, Variance:0.6709929595362338<br/># test set RMSE:31.423109839706022, Variance:0.42820706786532714</span></pre><p id="1eab" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">太好了！增加一个滞后已经给了我们的基线模型一个小的改进，基线模型的RMSE是31.95。上面的例子展示了我们试图实现的基本目标。</p><blockquote class="ol om on"><p id="f5fb" class="lh li md lj b lk ll kt lm ln lo kw lp oo lr ls lt op lv lw lx oq lz ma mb mc im bi translated">更正:在上面的例子中，我忘记删除index_names。当这些被丢弃时，结果与基线相比没有改善。感谢<a class="or os ep" href="https://medium.com/u/69f7d21d394b?source=post_page-----1b3864991da4--------------------------------" rel="noopener" target="_blank">宣昂刘</a>指出这一点！幸运的是，这对整个流程几乎没有影响，添加更多的滞后将开始改善结果(正如您可以在下面进一步阅读)</p></blockquote><p id="adb1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们将这个功能封装在两个函数中以备后用，一个用于添加从1到n的滞后，另一个用于添加特定的滞后。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6d05" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在应用时间序列分析和回归时，需要考虑一些假设，现在让我们来看看这些假设。</p><h1 id="e751" class="me mf jj bd mg mh mi mj mk ml mm mn mo ky mp kz mq lb mr lc ms le mt lf mu mv bi translated">平稳性</h1><p id="cf7e" class="pw-post-body-paragraph lh li jj lj b lk mw kt lm ln mx kw lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">平稳性意味着时间序列的统计特性，如均值和方差不随时间变化，此外，协方差(时间序列的分布)不应依赖于时间(见下图1)。</p><p id="1181" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这些统计属性保持不变很重要，因为许多统计模型依赖这些属性进行预测。因此，如果均值、方差或协方差随时间变化，模型将无法准确预测下一个值[1]。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/dcd198b3b2d03f6857404c84fa4b8779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*lvr6swSa_UDKSkA3i-583w.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图一。展示平稳与非平稳数据</p></figure><p id="e5e1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">幸运的是，有测试来检查数据的平稳性，如果测试没有通过，也有方法使时间序列平稳。</p><p id="c611" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了测试平稳性，我们将使用扩展的Dickey-Fuller测试，您可以查看[1–5]了解更多信息。目前，adf检验统计量和p值是最重要的。测试统计越负，信号越稳定。当p值低于0.05时，可以假定时间序列是平稳的。让我们在一台发动机的立柱上进行这个测试。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="nb nc nd ne gt oc oa od oe aw of bi"><span id="d4f7" class="og mf jj oa b gy oh oi l oj ok"># returns<br/># single unit, single column test results<br/># adf: -2.276666927948019 <br/># pvalue: 0.17960380425358546<br/># Significant: False</span></pre><p id="08da" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">检验统计是负的，但不显著。我们可以对数据进行一次差分，以试图消除趋势并再次测试[6]。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="nb nc nd ne gt oc oa od oe aw of bi"><span id="db4b" class="og mf jj oa b gy oh oi l oj ok"># returns<br/># single unit, single column test results after differencing<br/># adf: -14.824168539718967 <br/># pvalue: 1.9431018596392618e-27<br/># Significant: True</span></pre><p id="2473" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">更好的是，p值现在是&lt; 0.05 allowing us to assume stationarity.</p><p id="331b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="md">注意:重要的是要考虑你如何实现你的测试，例如测试一个传感器列的平稳性有所有100个引擎的时间序列。所有引擎一起形成稳定的信号，但是单个引擎的信号不是稳定的！</em>(见图2)</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/3a96141e1b115725ec5e6e7e0f3e028f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*A6H5LNZTClKg-gWA9leLkQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图2:(上图)单一特征的所有引擎的数据被认为是固定的。(中间)同一特性的单个发动机的数据不被认为是稳定的。(底部)在对信号进行一次差分后，相同特征的单个引擎的数据被认为是稳定的。</p></figure><p id="cf96" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于我们事先不知道每个发动机的每个传感器的时间序列在达到稳定之前需要差分多少次，所以最好创建一些函数来为我们处理这些步骤。我们将使用p值作为假设平稳性的决定性因素。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="d45a" class="og mf jj bd mg ou ov dn mk ow ox dp mo lq oy oz mq lu pa pb ms ly pc pd mu jp bi translated">应用我们目前所拥有的</h2><p id="9e8e" class="pw-post-body-paragraph lh li jj lj b lk mw kt lm ln mx kw lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">我们应用这些函数来使我们的数据稳定。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/4a792b2e432cd42ebc5856faab9a3341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUkBtgLmei4YA7TqNdjGSQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">intermediate_df.head()的结果</p></figure><p id="3975" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们拟合一个新的线性回归来了解静态数据对模型性能的影响。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="nb nc nd ne gt oc oa od oe aw of bi"><span id="7e36" class="og mf jj oa b gy oh oi l oj ok"># returns<br/># train set RMSE:51.63375613791181, Variance:0.4340864011385228</span></pre><p id="c9b9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于使数据静止，训练RMSE变得相当糟糕。这可以解释为数据不再具有趋势，从而难以拟合回归线。当添加滞后变量时，性能将再次提高，因为这将告知模型传感器值随时间的变化之间的关系。</p><p id="e8c2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们可以开始搜索，以确定要添加多少滞后才能获得最佳模型结果。</p><h1 id="491b" class="me mf jj bd mg mh mi mj mk ml mm mn mo ky mp kz mq lb mr lc ms le mt lf mu mv bi translated">AIC:寻找正确的滞后数</h1><p id="bbad" class="pw-post-body-paragraph lh li jj lj b lk mw kt lm ln mx kw lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">赤池信息准则(AIC)是一种反映模型质量的度量，常用于时间序列分析。它同时考虑过拟合和欠拟合。当训练多个相似的模型时，可以比较AIC分数用于模型选择[7]。较低的分数通常会更好，但通常会在复杂性和模型质量改进之间进行权衡。让我们训练一些具有0到n个滞后的模型，并计算AIC来确定最高质量的模型。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/b9c8a2d74527435ae3696fbfa72b0a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*JAWuPWPLKjIt-2nU9cwX5A.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">具有0–30个滞后的回归模型的评估度量表</p></figure><p id="41ef" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们正在寻找AIC中的一个转折点，通过增加更多的滞后来表明模型改进的收益递减。然而，根据度量表，并不清楚要添加多少滞后，因为度量似乎在稳步提高。让我们尝试绘制AIC的任何视觉问题。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/70318fc0a575681e372b14a46f276885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvbV_Q_jUTtWYCcWbAyhnQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">AIC变化率与添加的滞后nr的关系图</p></figure><p id="8d55" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">根据图表，质量改进在14个滞后之后似乎停滞不前。对我来说，这表明模型复杂性和质量之间的平衡已经达到，因为增加更多的滞后(复杂性)不再能实质上提高模型质量。</p><p id="4f33" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">添加同一变量的多个滞后的一个问题是引入多重共线性的可能性，接下来让我们检查一下。</p><h1 id="8e30" class="me mf jj bd mg mh mi mj mk ml mm mn mo ky mp kz mq lb mr lc ms le mt lf mu mv bi translated">多重共线性</h1><p id="63bc" class="pw-post-body-paragraph lh li jj lj b lk mw kt lm ln mx kw lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">当多元回归模型中的独立变量高度相关时，就会出现多重共线性[8]。由于时间序列的性质，即上一个时间点的值与下一个时间点的值存在内在联系，因此添加滞后变量时引入多重共线性的可能性很大。多重共线性会影响模型的系数和稳定性，增加新数据出现错误结果的可能性。让我们通过计算方差膨胀因子(VIF)来测试我们模型的多重共线性，根据经验法则，低于5的vif值被认为是安全的[9]。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/6396a5c757d647431827fcfcefb2a7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*c_NCa7Rec5HAXMMmatI6PQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">计算的vif的前20个结果</p></figure><p id="b257" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的模型似乎深受vif值远大于5的多重共线性之苦。在寻找减少多重共线性的方法时，我发现statsmodels用于计算多重共线性的方法可能会受到缩放的严重影响[10]。这将是一个相当简单的修复，所以让我们实现一个缩放转换，并希望我们不必进一步寻找解决我们的问题。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/20dc9ee2613a7f4993405aaab08c9776.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*JJADbyb5F6tUQLTmGyPUaA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">缩放后计算的vif的前20个结果</p></figure><p id="1d0f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好多了！我们现在有所有组件来训练、预测和评估，以找到最佳模型。</p><h1 id="0896" class="me mf jj bd mg mh mi mj mk ml mm mn mo ky mp kz mq lb mr lc ms le mt lf mu mv bi translated">组合、预测和评估</h1><p id="6edf" class="pw-post-body-paragraph lh li jj lj b lk mw kt lm ln mx kw lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">我们首先重复确定要添加的滞后数量的过程。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/1c73f76c673110b6d90f14ac633b3b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFx7LOSd3h-mXRiaDAteeA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">AIC变化率与缩放特征后添加的滞后nr的关系图</p></figure><p id="6cb4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在增加缩放比例后，这个点有一点点移动，模型质量的提高现在停滞在9个滞后而不是14个。</p><p id="7f9e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们把我们的管道放在一起，用9个滞后来训练我们的模型，看看它的表现如何。从现在开始，我们还将加入剪辑后的RUL。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="nb nc nd ne gt oc oa od oe aw of bi"><span id="5ce0" class="og mf jj oa b gy oh oi l oj ok"># returns<br/># train set RMSE:20.80233928213837, Variance:0.7523208224684113<br/># test set RMSE:21.14895857012398, Variance:0.7409888687595052</span></pre><p id="22e6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">21.14的RMSE并不坏，但我认为我们可以再挤出一点。目前，我们的模型使用连续滞后变量。然而，相邻的lag不一定必须保存不同的信息。例如，在滞后6、7和8的传感器值的变化可能是最小的，因此对模型来说不是真正的信息。当增加滞后之间的时间步长时，传感器值的变化变得更加明显。例如，滞后5、10和20处的传感器值可能相差很大，足以提供信息。注意，通过增加更高的滞后变量，你也丢弃了更多的数据行，所以需要考虑一个折衷方案。</p><p id="7d1a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当发动机恶化并接近故障时，传感器中有明显的趋势，这在单个时间步长之间是可区分的。所以就我个人而言，在增加滞后之间的时间步长之前，我选择保持前几个滞后连续。让我们尝试一些变化，看看哪个得分最高。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="nb nc nd ne gt oc oa od oe aw of bi"><span id="9e3d" class="og mf jj oa b gy oh oi l oj ok"># Results of different lags and test RMSE<br/># RMSE = 21.76, lags = [1,2,3,4,5]<br/># RMSE = 21.14, lags = [1,2,3,4,5,6,7,8,9]<br/># RMSE = 21.06, lags = [1,2,3,4,5,10,20,30]<br/># RMSE = 20.85, lags = [1,2,3,4,5,10,20]</span></pre><p id="4ad4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当然还有更多的可能性，但通过最少的测试，并考虑到增加更多连续滞后带来的停滞不前的改善，滞后[1，2，3，4，5，10，20]在RMSE为20.85时表现最佳。这些结果非常接近我们上次的支持向量回归(RMSE = 20.54)。</p><p id="adce" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我觉得分布式滞后模型对于解决这个用例的可能方法是一个有价值的补充。它在模型开发过程中提供了很大的灵活性和控制力，同时也易于业务人员进行解释和说明。完整的笔记本你可以查看我的github页面<a class="ae jg" href="https://github.com/kpeters/exploring-nasas-turbofan-dataset" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="7631" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我要感谢Wisse Smit和Maikel Grobbe对我的文章的评论。下次我们将深入研究生存分析。你能找到表现更好的特定滞后(不完全连续)的组合吗？请在下面的评论中告诉我！</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><p id="c184" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">参考资料:<br/>【1】<a class="ae jg" href="https://medium.com/open-machine-learning-course/open-machine-learning-course-topic-9-time-series-analysis-in-python-a270cb05e0b3" rel="noopener">https://medium . com/open-machine-learning-course/open-machine-learning-course-topic-9-time-series-analysis-in-python-a 270 CB 05 E0 b 3</a><br/>【2】<a class="ae jg" href="https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Augmented _ Dickey % E2 % 80% 93 fuller _ test</a><br/>【3】<a class="ae jg" href="https://www.statsmodels.org/stable/generated/statsmodels.tsa.stattools.adfuller.html" rel="noopener ugc nofollow" target="_blank">https://www . stats models . org/stable/generated/stats models。</a></p></div></div>    
</body>
</html>