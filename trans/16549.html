<html>
<head>
<title>The Fundamentals of the Big-O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号的基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-fundamentals-of-the-big-o-notation-7fe14210b675?source=collection_archive---------15-----------------------#2020-11-15">https://towardsdatascience.com/the-fundamentals-of-the-big-o-notation-7fe14210b675?source=collection_archive---------15-----------------------#2020-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c8ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何利用Big-O符号来衡量算法的性能和可伸缩性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab739194055c092b4911cc06e94fb5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*veVf1FoznZEQK9n3Ypr2Tw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">纳丁·沙巴纳在<a class="ae ky" href="https://unsplash.com/s/photos/light?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="486d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个数据变得越来越大的时代，创建一个“有效”的算法来解决问题已经不够了。无论您的职业是什么，无论是软件开发人员、数据科学家还是机器学习工程师，创建高效且可扩展的算法的能力都是非常需要的技能。</p><p id="41fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建一个高效的算法，大多数时候我们需要跳出框框思考，想出一个如何优化代码性能的主意。当我们试图优化代码时，有时我们不知道如何衡量我们算法的效率——不管它是否得到了改进。</p><p id="98cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论如何利用Big-O符号来测量算法性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="04ab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">衡量算法性能的正确方法</h1><p id="d033" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们思考一下:我们如何知道我们的算法是好的或高效的？我们如何衡量算法的性能？或许，测量算法性能的最简单方法是测量它计算解决方案所需的持续时间。</p><p id="1964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，测量持续时间并不是评估算法性能的好方法，因为:</p><ul class=""><li id="7d7d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">我们使用的计算机将对算法的运行速度产生巨大影响。如果你使用的是旧的硬件，你会期望代码运行得比使用新的硬件慢。</li><li id="b7e1" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">如果您在运行该算法的同时，您的计算机中还打开了其他活动程序，则与您的计算机仅投入其所有资源来运行该算法相比，您的算法求解解决方案所需的时间将会更慢。</li><li id="283d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们在算法中使用的编译器和库也会影响它的运行时间。</li></ul><p id="2ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，应该有更好的方法来衡量算法的性能。</p><p id="02d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要更多地关注算法的可伸缩性或运行时复杂性，而不是关注运行算法的持续时间:当输入变大时，算法的性能如何变化？</p><p id="54e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要测量我们算法的运行时复杂性，请输入Big-O符号背后的概念。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5c4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">大O符号</h1><p id="73e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Big-O符号是计算机科学中谈论算法效率时经常听到的术语。但是，大O符号是什么意思呢？</p><blockquote class="nn"><p id="57dd" class="no np it bd nq nr ns nt nu nv nw lu dk translated">简而言之，Big-O符号描述了随着输入数据变大，算法的性能有多好。</p></blockquote><p id="7122" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">使用Big-O符号，我们能够测量我们算法的可伸缩性:当输入变大时，我们的算法还会表现得很好吗？</p><p id="f7d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论四种最常见的大O符号:<strong class="lb iu"> O(1) </strong>、<strong class="lb iu"> O(n) </strong>、<strong class="lb iu"> O(n ) </strong>和<strong class="lb iu"> O(log n) </strong>。</p><p id="a845" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些<strong class="lb iu"> <em class="oc"> Os </em> </strong>代表 的<strong class="lb iu"> <em class="oc">顺序，所以<strong class="lb iu"> O(n) </strong>表示n </em> </strong>的<strong class="lb iu"> <em class="oc">顺序，其中<strong class="lb iu"> <em class="oc"> n </em> </strong>是输入数据的大小。让我们一个一个地检查这些符号。</em></strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="bfa4" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">O(1) —恒定的运行时复杂性</h2><p id="db8c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">O(1) 符号意味着你的算法具有恒定的运行时复杂度，因为不管输入数据的大小，它都需要相同数量的运算。</p><p id="a812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更直观，我们来看看下面的代码片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="d15d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段是一个简单的算法示例，符号为<strong class="lb iu"> O(1) </strong>。该函数接受一个数组，并显示该数组的第一个元素。不管数组中有多少个元素，这个函数总是在一个常量运行时运行，因为它的工作只是显示数组的第一个元素。</p><p id="e897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看另一个算法，它有<strong class="lb iu"> O(1) </strong>的时间复杂度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="1d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，该函数接受一个数组，它的工作是将数组的第三个元素赋给一个名为<code class="fe or os ot ou b">third_index</code>的变量。同样，不管输入数组的大小有多大，该函数将总是在恒定的运行时运行，因为它唯一的工作是将数组的第三个元素值赋给一个变量。</p><p id="dcfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们用输入数据的大小用<strong class="lb iu"> O(1) </strong>符号来绘制算法的时间复杂度，我们得到下面的图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/7bf12c3700b693ca836830808b833a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*C--4xOJ1aDuUykTZ4z5UGg.png"/></div></figure><p id="4c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，随着输入数据变得越来越大，算法运行时复杂性保持不变。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1d94" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">O(n) —线性运行时间复杂度</h2><p id="c4fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu"> O(n) </strong>符号意味着算法的运行时复杂度与输入数据的大小成线性关系。如果输入数据的大小增加2，那么算法的运行时复杂度也会增加2。</p><p id="3e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的代码片段，让它更直观。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="64db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让一个循环遍历一个数组的元素并打印每个元素的值是一个算法的完美例子，这个算法有<strong class="lb iu"> O(n) </strong>符号。</p><p id="9bf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们算法的开销随着输入数组的大小而变化。如果输入数组只有2个元素，我们的算法只需要2次运算就可以运行。如果数组有100个元素，算法也需要运行100次运算。换句话说，我们算法的成本随着输入数组的大小线性增加。</p><p id="7cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们用输入数据的大小来绘制运行时复杂性，我们会得到下面的图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/469825394f011a02e2e3eecdd428ee90.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*X5JanH7K1HPOarB4fJpTTg.png"/></div></figure><p id="b5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们在运行时复杂性和输入数据大小之间有一个线性关系。输入数组中的元素越多，算法运行所需的操作就越多。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7ebc" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">O(n ) —二次运行时间复杂度</h2><p id="54b4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu"> O(n ) </strong>符号意味着算法的运行时复杂度与输入大小的平方成正比。假设你数组的输入大小是3，那么你算法的运行时复杂度会增加9。</p><p id="2a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的代码片段，作为具有<strong class="lb iu"> O(n ) </strong>复杂度的算法的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="d944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嵌套循环是使用<strong class="lb iu"> O(n ) </strong>符号的算法的完美例子。这是因为循环对数组的每个元素迭代了两次。内循环有<strong class="lb iu"> O(n) </strong>的复杂度，外循环也有<strong class="lb iu"> O(n) </strong>的复杂度。现在如果把内循环和外循环之间的复杂度结合起来，就得到了<strong class="lb iu"> O(n ) </strong>的复杂度。</p><p id="ac96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们的输入数组的大小是3。对于外部循环，总共需要3次运算来迭代数组的每个元素。对于这3个操作中的每一个，也需要3个操作来进行内部循环以迭代每个元素。这总共带来了9个操作。</p><p id="cfe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们绘制这个图，你会得到下面这个算法的可视化结果，复杂度为<strong class="lb iu"> O(n ) </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/1ca0d3fa6ed5927c9302301118d9dbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*GKAnOWbIA7CRV4OUB3STZw.png"/></div></figure><p id="c26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，随着输入数据量的增加，我们算法的成本会越来越高。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="139b" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">O(log n) —对数运行时间复杂度</h2><p id="5c8e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们应该知道的下一个运行时复杂度是<strong class="lb iu"> O(log n) </strong>。这种表示法意味着，当输入数据的大小加倍时，算法的运行时复杂度将增加一倍。</p><p id="36ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的代码片段作为例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="ac84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段是二分搜索法的算法，其运行时复杂度为<strong class="lb iu"> O(log n) </strong>。二分搜索法不会使用<em class="oc"> for </em>循环遍历数组的每个元素，而是总是递归地将输入数据的大小分成两半，以找到所需的值。</p><p id="1ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码所示，我们有一个输入大小为9的数组。假设数据是完美排序的，我们的目标是找出这个数组中是否存在值7。二分搜索法首先将输入数组一分为二，并检查数组中间的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/735ed9b3369c88479cc1885ea4190243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oM1WR0WzjNA8vzB7L2AE0w.png"/></div></div></figure><p id="147a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为数组中间的值是5，所以这个值将与我们正在寻找的值进行核对，在本例中是7。由于5小于7，因此算法将使用数组右侧的值，即6到9。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/0fe8745bcc8eaadba229a04bd6825f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7NXfh315QIJLVHFyHGVgew.png"/></div></div></figure><p id="395f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们数组的输入大小是4而不是10。然后，新数组将再次被一分为二，留给我们的是一个值为6和7的数组以及一个值为8和9的数组。</p><p id="52ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于值7在由6和7组成的数组中，因此算法将使用数组的这一部分，并忽略值为8和9的数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/0c809faacf73f24083335e6bba6c262e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLx-JlUFs8QTq4ztaCCWig.png"/></div></div></figure><p id="3d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到最后我们找到我们想要的值，也就是7。</p><p id="0580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用运行时复杂度<strong class="lb iu"> O(log n) </strong>画出算法的图，我们得到如下可视化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/b317aed2aaa0c5888b66164caa3e526b.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*UHTWeGAoDrJL1mhvtKkVGw.png"/></div></figure><p id="b1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，随着输入大小变得越来越大，具有<strong class="lb iu"> O(log n) </strong>符号的算法比<strong class="lb iu"> O(n) </strong>和<strong class="lb iu"> O(n ) </strong>更具可伸缩性。</p><p id="f973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们上面的例子中，如果我们使用<em class="oc"> for </em>循环，它有一个线性的<strong class="lb iu"> O(n) </strong>符号，我们的算法在得出一个解之前将需要7次运算(因为我们正在寻找值7)。与此同时，使用具有<strong class="lb iu"> O(log n) </strong>符号的二分搜索法算法，只需要4次运算就可以解决问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="872c" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">不同Big-O符号之间的复杂度比较</h2><p id="c061" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们回顾一下目前为止我们学到的不同的Big-O符号的可伸缩性。下面是这些Big-O符号的情节。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/d087e4e727e8a9a434bf12bb83f4d5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*Qy_Z4Og2L1Bxn0gNroflqw.png"/></div></figure><p id="ed49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，随着输入大小变得越来越大，采用<strong class="lb iu"> O(1) </strong>符号的算法具有最好的可伸缩性，而采用<strong class="lb iu"> O(n ) </strong>符号的算法具有最差的可伸缩性。</p><p id="97e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，下面是从最好到最差开始的Big-O符号的可伸缩性顺序:</p><pre class="kj kk kl km gt oy ou oz pa aw pb bi"><span id="dc9b" class="od md it ou b gy pc pd l pe pf"><strong class="ou iu">                  O(1) &lt; O(log n) &lt; O(n) &lt; O(n^2) </strong></span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ef3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">确定代码的Big-O符号</h1><p id="ab01" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们知道了不同种类的Big-O符号，让我们试着找出代码的运行时复杂性。当我们试图分析代码的运行时复杂性时，我们总是不得不面对两种不同的场景:最好的场景和最坏的场景。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="33d4" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">最好的情况和最坏的情况</h2><p id="61a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了让我们更容易理解最佳情况和最差情况之间的区别，让我们看一下下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="13bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们有一个算法用于线性搜索(用<em class="oc">迭代每个数组的元素用于</em>循环)和一个算法用于二分搜索法(递归分割数组)。假设我们有一个完美排序的数组，有9个元素，如上图所示。</p><ul class=""><li id="ea88" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">线性搜索的最佳情况是我们要搜索值1，这是数组的第一个元素。在这种情况下，我们有<strong class="lb iu"> O(1) </strong>复杂度。</li><li id="64e5" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">线性搜索的最坏情况是，如果我们想要搜索数组的最后一个元素9的值，或者如果我们想要搜索数组中不包含的值。这是因为算法需要遍历数组的每个元素。在这种情况下，我们有<strong class="lb iu"> O(n) </strong>复杂度。</li><li id="a0ea" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">对于二分搜索法来说，最好的情况是我们要搜索值5，这是数组中间元素的值。在这种情况下，我们有<strong class="lb iu"> O(1) </strong>复杂度。</li><li id="e8aa" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">对于二分搜索法来说，最糟糕的情况是，如果我们想要搜索1或10的值，它们是数组的第一个和最后一个元素，或者是不包含在数组中的值。这是因为使用二分搜索法时，算法需要递归地将数据分成两半，直到到达第一个和最后一个元素。在这种情况下，我们有<strong class="lb iu"> O(log n) </strong>的复杂度。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/65bf476a04e7aebca2155e084a1cecb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFS6q3ClcpHU05reRoCxXg.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="e0cb" class="od md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">估计代码的Big-O符号</h2><p id="f836" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当涉及到确定代码的Big-O符号时，我们需要总是着眼于最坏的情况。现在记住这个概念，让我们试着估计一个代码的Big-O符号。</p><p id="8fb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的代码片段，并检查它的复杂性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="48a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当评估一个代码的Big-O符号时，我们总是需要首先从最里面的循环中的操作开始。下面是我们应该如何调查上述代码的Big-O复杂性的分步说明:</p><ol class=""><li id="7e1c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ph nf ng nh bi translated">从最内层循环的操作开始，即<code class="fe or os ot ou b">value += array[i] + array[j] + array[k]</code>。该操作具有恒定的<strong class="lb iu"> O(1) </strong>复杂度。</li><li id="b171" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ph nf ng nh bi translated">接下来，我们看最里面的循环，也就是<code class="fe or os ot ou b">for k in range (len(array)/2)</code>。这个循环将总是迭代我们数组的一半大小，因此它有<strong class="lb iu"> O(n/2) </strong>的复杂度。</li><li id="c71f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ph nf ng nh bi translated">接下来，我们向上移动一级，这就是循环<code class="fe or os ot ou b">for j in range (len(array)-10)</code>。虽然这是一个<em class="oc"> for </em>循环，但它有一个恒定的运行时复杂度。这是因为不管输入数组有多大，这个循环总是只迭代最后10个元素。因此，它具有恒定的复杂度。</li><li id="f166" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ph nf ng nh bi translated">接下来，我们向上移动到外循环，即<code class="fe or os ot ou b">for i in range (len(array))</code>。这个<em class="oc"> for </em>循环将总是迭代输入数组的大小。因此，这个循环具有<strong class="lb iu"> O(n) </strong>复杂度。</li><li id="933d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ph nf ng nh bi translated">最后，我们转到循环外的操作，它们是<code class="fe or os ot ou b">value = 0</code>和<code class="fe or os ot ou b">return value</code>。这两个操作将总是在一个恒定的运行时间中运行，因此它们都具有<strong class="lb iu"> O(1) </strong>的复杂度。</li></ol><p id="7c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经分析了每个循环和操作的Big-O符号，接下来让我们分析整个代码的Big-O符号。要做到这一点，我们也总是需要从最内部的循环开始。</p><ol class=""><li id="3589" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ph nf ng nh bi translated">最内部的循环具有<strong class="lb iu"> O(n/2) </strong>复杂度，并且该循环中的操作具有<strong class="lb iu"> O(1) </strong>复杂度。这意味着这个最里面的循环有<code class="fe or os ot ou b">(n/2)*(1) = <strong class="lb iu">O(n/2)</strong></code>的复杂度。</li><li id="3bb2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ph nf ng nh bi translated">接下来，第二个内部循环具有<strong class="lb iu"> O(10) </strong>复杂度。这个循环的内循环，正如我们在1号点计算的，有<strong class="lb iu"> O(n/2) </strong>。这意味着第二个内部循环具有<code class="fe or os ot ou b">10*(n/2) = <strong class="lb iu">O(5n)</strong></code>复杂性。</li><li id="20f7" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ph nf ng nh bi translated">最后，外环具有<strong class="lb iu"> O(n) </strong>复杂度。正如我们在第二点中所计算的，这个外循环的内循环总共有<strong class="lb iu"> O(5n) </strong>复杂度。因此，它们总共有<code class="fe or os ot ou b">n*5n = <strong class="lb iu">O(5n^2)</strong></code>复杂度。</li><li id="6ff2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ph nf ng nh bi translated">如果我们把循环的复杂性和循环外的两个操作结合起来，我们得到<code class="fe or os ot ou b">1+1+5n^2 = <strong class="lb iu">O(2+5n^2)</strong></code>。可以看到，上面的代码总共有<strong class="lb iu"> O(2+5n ) </strong>的复杂度。</li></ol><p id="a47e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们估算一个代码的Big-O符号时，我们可以通过去掉所有的常数来简化它。因此，代替<strong class="lb iu"> O(2+5n ) </strong>，我们可以去掉所有的常数，剩下<strong class="lb iu"> O(n ) </strong>。因此，上面的代码具有<strong class="lb iu"> O(n ) </strong>的复杂性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="50a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">暂时就这样吧！</p><p id="807f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望现在你知道如何通过查看算法的Big-O符号来测量和评估算法的性能。随着输入数据每天变得越来越大，设计可伸缩的算法对于优化代码非常有益。</p></div></div>    
</body>
</html>