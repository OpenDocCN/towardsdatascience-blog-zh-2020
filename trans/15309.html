<html>
<head>
<title>Deploying a Text Classifier with TensorFlow Serving + Docker in 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在2.0中使用TensorFlow Serving + Docker部署文本分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-a-text-classifier-with-tensorflow-serving-docker-in-2-0-cba6851e46ed?source=collection_archive---------17-----------------------#2020-10-21">https://towardsdatascience.com/deploying-a-text-classifier-with-tensorflow-serving-docker-in-2-0-cba6851e46ed?source=collection_archive---------17-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4808" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本教程中，我们使用一个接受原始字符串进行推理的API端点来简化模型预测。我们还对模型签名进行了实验，以获得更加可定制的有效负载。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d9def44ded0a45bcf567d512c95f6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*by9sBsLmaZL4n98T"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="bd7b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">这里是</strong><a class="ae ky" href="https://github.com/happilyeverafter95/tensorflow-serving-2.0" rel="noopener ugc nofollow" target="_blank"><strong class="ak">GitHub repo</strong></a><strong class="ak">的全部代码。</strong></h2><p id="6aa2" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">大约一年前，我写了<a class="ae ky" rel="noopener" target="_blank" href="/deploying-kaggle-solution-with-tensorflow-serving-part-1-of-2-803391c9648"><em class="mo">Deploy a Keras Model for Text Classification使用tensor flow Serving</em></a><em class="mo"/>在TensorFlow 1.X中部署文本分类器。x更容易使用，我很难找到我需要的文档，特别是关于部署和迁移TensorFlow服务的已弃用的V1功能。</p><p id="b289" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我已经收集了我的知识，并将通过一个玩具示例演示模型部署。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="0d8a" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">如果这是你第一次用TensorFlow 2。x，我建议学习这个课程来构建、训练和部署模型。</p><div class="nb nc gp gr nd ne"><a href="https://click.linksynergy.com/link?id=J2RDo*Rlzkk&amp;offerid=759505.12488204614&amp;type=2&amp;murl=https%3A%2F%2Fwww.coursera.org%2Flearn%2Fintro-tensorflow" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">张量流简介</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">本课程的重点是利用TensorFlow 2.x和Keras的灵活性和“易用性”来构建、培训和…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">click.linksynergy.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><h2 id="6787" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在TF 1中，文本预处理是一场噩梦。X …</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/77ec5ab2c013bf7e1f78b2db9d1726eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lN_prwvPzaoOA5mJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Sebastian Herrmann 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e279" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">特别是2。x引入了几个新功能，使得使用文本模型变得更加容易。1的最大痛点之一。x是如何处理矢量化层。要求消费者应用程序为我的推理API提供向量输入并不总是可行的。</p><p id="b727" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">因此，创建了许多丑陋的变通方法来允许模型接受原始字符串。点击这里查看我的标记化/截断/填充回退<a class="ae ky" href="https://github.com/happilyeverafter95/toxic-comment-classifer/blob/master/profanity_detector/model.py#L52" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="51dd" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在许多情况下，预测端点必须包装在另一个端点中，以处理预处理步骤。这造成了一种令人讨厌的情况，即预处理逻辑位于两个不同的地方:用于训练模型的模块和将客户机的原始文本转换成向量的包装器。</p><p id="96f8" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">让我们看看如何在2.X中解决这个问题。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="3529" class="nu la it bd lb nv nw nx le ny nz oa lh jz ob ka ll kc oc kd lp kf od kg lt oe bi translated">目标:创建一个API端点，该端点以原始字符串的形式接受电影评论，并返回评论为正面的概率</h1><p id="c283" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这是一个标准的情绪分析任务。为了确保我们构建的解决方案是端到端的:</p><ul class=""><li id="2016" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn ok ol om on bi translated">服务端点将负责预处理原始字符串，并为模型对其进行矢量化</li><li id="3784" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated">除了TensorFlow服务，我们不会使用任何其他框架</li></ul><p id="0255" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">如果你想更进一步，有很多关于将TensorFlow模型部署到云平台(如GCP或AWS)的课程和资源。</p><div class="nb nc gp gr nd ne"><a href="https://click.linksynergy.com/link?id=J2RDo*Rlzkk&amp;offerid=759505.13223275109&amp;type=2&amp;murl=https%3A%2F%2Fwww.coursera.org%2Flearn%2Fend-to-end-ml-tensorflow-gcp" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">基于GCP tensor flow的端到端机器学习</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">由谷歌云提供。在本专业的第一门课程中，我们将回顾机器中涵盖的内容…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">click.linksynergy.com</p></div></div><div class="nn l"><div class="ot l np nq nr nn ns ks ne"/></div></div></a></div><h1 id="aa3f" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">属国</h1><p id="6bed" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我建议分叉或克隆我的<a class="ae ky" href="https://github.com/happilyeverafter95/tensorflow-serving-2.0" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>并从那里开始跟进。</p><p id="98c5" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">本文对每个步骤进行了更详细的解释。如果您只是想让一些东西启动并运行起来，那么可以按照我的README.md中的说明来做。README.md包括如何训练和服务模型的细节。</p><ul class=""><li id="591e" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn ok ol om on bi translated"><a class="ae ky" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">安装Docker </a></li><li id="d0b9" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated">转到<a class="ae ky" href="https://github.com/happilyeverafter95/tensorflow-serving-2.0" rel="noopener ugc nofollow" target="_blank">我的回购</a>并运行<code class="fe oz pa pb pc b">pip install -r requirements.txt</code></li><li id="2524" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated">我的代码是为Python 3.8编写和测试的</li></ul><h1 id="9747" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">数据集:IMDB电影评论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/41016f1c84e0b5a15eabcbe4a9b703fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NDr8qRyjd9d0bb22"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔恩·泰森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f874" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">该数据集包含25，000条用于训练的高度极性电影评论，以及另外25，000条用于测试的评论。每条影评都标注为0(负面情绪)或1(正面情绪)。关于数据集的更多信息可以在<a class="ae ky" href="https://www.tensorflow.org/datasets/catalog/imdb_reviews" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="a888" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我们将训练一个二元分类器来预测给定电影评论是正面的概率。</p><h1 id="c332" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">代码</h1><p id="d7a1" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我将在一个<code class="fe oz pa pb pc b">ModelTrainer</code>类中组织我的大部分代码，该类处理模型的端到端训练和部署。让我们一步一步来。</p><h1 id="9edf" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">依赖关系</h1><p id="4d45" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">首先，我们加载将要使用的库。我还定义了一个<code class="fe oz pa pb pc b">logger</code>来跟踪培训过程中的重要事件。在较大的项目中，日志记录通常比打印语句更受青睐，因为它更容易跟踪(更容易看到日志来自哪里)、可配置并且更容易存储。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><h1 id="c734" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">模特教练班</h1><p id="0d71" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我在这里将模型架构参数定义为属性。在一个更复杂的项目中，将它们移动到一个配置文件中可能更有意义。下面是每个属性所指内容的快速分类:</p><ul class=""><li id="f93d" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn ok ol om on bi translated"><code class="fe oz pa pb pc b">embed_size</code>:每个令牌嵌入的维度</li><li id="77a1" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><code class="fe oz pa pb pc b">max_features</code>:你词汇量的最大值</li><li id="f4af" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><code class="fe oz pa pb pc b">epochs</code>:训练集的迭代次数</li><li id="a538" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><code class="fe oz pa pb pc b">batch_size</code>:一次处理的观察次数</li><li id="0fc6" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><code class="fe oz pa pb pc b">max_len</code>:每次观察的令牌数；较短的长度将被填充，而较长的长度将被截断</li></ul><p id="9bf9" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">稍后我们将讨论<code class="fe oz pa pb pc b">tf_model_wrapper</code>属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><h1 id="ee04" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">获取数据</h1><p id="d94d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在这个类中，我定义了一个名为<code class="fe oz pa pb pc b">fetch_data</code>的方法，它将通过编程从<code class="fe oz pa pb pc b">tensorflow_datasets</code>下载训练和测试数据。这种下载数据集的方法效率很低。数据集不会保存在任何地方，每次执行脚本时都需要重新加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><h1 id="496b" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">矢量化图层</h1><p id="edf9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这是获取原始字符串并将其转换为与我们的模型架构兼容的矢量化输出的层。我们还在这一层中构建了预处理步骤，以便在矢量化之前对原始文本进行预处理。</p><p id="1cfa" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">预处理在<code class="fe oz pa pb pc b">custom_preprocessing</code>方法中定义。我们在这里做三件事:</p><ul class=""><li id="93c0" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn ok ol om on bi translated">将文本转换为小写</li><li id="e7e1" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated">在我们的影评中经常出现的脱衣<code class="fe oz pa pb pc b">&lt;br /&gt;</code></li><li id="40ae" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated">去除标点符号</li></ul><p id="4062" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在<code class="fe oz pa pb pc b">init_vectorize_layer</code>中返回的<code class="fe oz pa pb pc b">TextVectorization</code>对象将返回一个完全适合的层，该层适应于所提供的文本(这是来自我们的训练数据的电影评论)。除了自定义预处理功能，我们还定义了最大令牌数、输出序列长度和输出模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><h1 id="18fc" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">初始化模型</h1><p id="b041" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">首先，我们创建<code class="fe oz pa pb pc b">vectorize_layer</code>并定义输入类型(单个字符串)。我们通过矢量化层传递原始输入，然后将输出传递给模型架构的其余部分。</p><p id="ac8f" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我已经把一个简单的RNN和一个双向GRU层放在了一起。出于说明发球的目的，我没有花太多时间来完善这个模型。我敢肯定，找到一个针对该数据集实现更好结果的模型架构并不困难。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><h1 id="e84f" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">训练模型</h1><p id="a63f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们在<code class="fe oz pa pb pc b">train</code>方法中做的第一件事是使用<code class="fe oz pa pb pc b">fetch_data</code>加载训练数据。在这个玩具示例中，我们将不会加载测试数据，因为我们跳过了模型评估。<em class="mo">模型评估非常重要，在更实际的场景中不应该被忽略。</em></p><p id="d919" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我们使用<code class="fe oz pa pb pc b">init_model</code>方法初始化模型，并通过<code class="fe oz pa pb pc b">train_examples</code>来拟合我们的矢量化图层。接下来是在训练数据上拟合模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="0539" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在这个要点的第4行，我们最终通过创建一个新的<code class="fe oz pa pb pc b">TFModel</code>类的实例来定义我们的<code class="fe oz pa pb pc b">tf_model_wrapper</code>对象。该对象的目的是将<em class="mo">签名</em>合并到服务模型中。</p><p id="9233" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我将在这里绕道谈论模型签名，以及为什么您可能想要合并它们。</p><h1 id="9eee" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">模型签名</h1><p id="72d9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">TensorFlow文档上的这个<a class="ae ky" href="https://www.tensorflow.org/tfx/serving/signature_defs" rel="noopener ugc nofollow" target="_blank">页面解释了签名用于提供“识别函数输入和输出的一般支持，并且可以在构建</a><a class="ae ky" href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/saved_model/builder.py" rel="noopener ugc nofollow" target="_blank"> SavedModel </a>时指定”。</p><blockquote class="pg ph pi"><p id="f7d5" class="lv lw mo lx b ly mp ju ma mb mq jx md pj mr mf mg pk ms mi mj pl mt ml mm mn im bi translated">签名定义需要指定:</p><p id="7df6" class="lv lw mo lx b ly mp ju ma mb mq jx md pj mr mf mg pk ms mi mj pl mt ml mm mn im bi translated"><code class="fe oz pa pb pc b">inputs</code>作为字符串到TensorInfo的映射。</p><p id="0cf5" class="lv lw mo lx b ly mp ju ma mb mq jx md pj mr mf mg pk ms mi mj pl mt ml mm mn im bi translated"><code class="fe oz pa pb pc b">outputs</code>作为字符串到TensorInfo的映射。</p><p id="26e2" class="lv lw mo lx b ly mp ju ma mb mq jx md pj mr mf mg pk ms mi mj pl mt ml mm mn im bi translated"><code class="fe oz pa pb pc b">method_name</code>(对应加载工具/系统中支持的方法名)。</p></blockquote><p id="b30a" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">通过定制输入，我们可以在推理之前加入额外的预处理步骤。通过定制输出，我们可以定制来自服务模型的有效负载。</p><p id="1ad0" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在本例中，我们将创建一个签名，以便在预测中包含一些有用的元数据。</p><h1 id="baef" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">创建支持签名的包装器</h1><p id="9e6b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们将创建一个<code class="fe oz pa pb pc b">TFModel</code>作为模型的包装器。初始化时，<code class="fe oz pa pb pc b">TFModel</code>对象将接受一个<code class="fe oz pa pb pc b">tf.keras.Model</code>并将它保存为一个<code class="fe oz pa pb pc b">model</code>属性。这个初始化步骤非常灵活，可以用来传递额外的参数。</p><p id="184c" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我们使用<code class="fe oz pa pb pc b">@tf.function</code>装饰器定义了一个<code class="fe oz pa pb pc b">prediction</code>方法。这个装饰器将函数转换成可调用的张量流图。<code class="fe oz pa pb pc b">input_signature</code>参数指定将提供给签名的形状和数据类型。这个方法的输出成为我们服务模型时的输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="da01" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我们的服务模型有效载荷将有两个字段:一个包含模型输出的<code class="fe oz pa pb pc b">prediction</code>字段和一个硬编码的<code class="fe oz pa pb pc b">description</code>字段。</p><p id="8372" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">对于我们的用例，模型输出相当直观，不完全需要<code class="fe oz pa pb pc b">description</code>。然而，当类标签不清楚或者额外的元数据可能有帮助时，这就变成了一个有用的指示器。</p><h1 id="61e1" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">我们还想传递哪些元数据？</h1><p id="91a4" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">世界是你的！这里有一些想法可能会让你以后的生活更轻松。</p><h2 id="8e1f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">可听度和再现性</h2><p id="b938" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">考虑添加有助于调查和重现特定预测的元数据。</p><ul class=""><li id="fea1" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn ok ol om on bi translated">用于训练该模型的数据集是什么？</li><li id="a8b4" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated">如果我想在我的机器上重建这个模型，我可以在哪里找到模型资产？</li><li id="e673" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated">用于训练模型的代码在哪里？使用了什么版本的代码(即Git SHA/pull请求编号)来训练模型？</li></ul><h2 id="5fcc" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解释</h2><p id="2229" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">你的模型的最终消费者可能不是熟悉机器学习的人。在没有任何解释的情况下传递类别概率和相应标签的列表可能会令人困惑。考虑通过顶部预测和相关概率。</p><h2 id="415a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用</h2><p id="bb6b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">有时，输出反映您的预期用途可能会有所帮助。也许你有一个不同型号的标量输出的阈值？您可以使用元数据来明确您的预期用途。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="ce1c" class="nu la it bd lb nv nw nx le ny nz oa lh jz ob ka ll kc oc kd lp kf od kg lt oe bi translated">部署模型</h1><p id="1b29" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">部署步骤非常简单。我们将模型保存到本地目录，并将<code class="fe oz pa pb pc b">serving_default</code>签名定义为来自我们<code class="fe oz pa pb pc b">tf_model_wrapper.</code>的<code class="fe oz pa pb pc b">prediction</code>方法</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><h2 id="09dc" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实际上拯救了什么？</h2><p id="2811" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">该模型被序列化为SavedModel对象，可用于推理。在此过程中，整个TensorFlow会话被导出为包含在单个目录中的语言不可知格式。</p><p id="7a57" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">该目录具有以下结构:</p><pre class="kj kk kl km gt pm pc pn po aw pp bi"><span id="4257" class="kz la it pc b gy pq pr l ps pt">assets/<br/>assets.extra/<br/>variables/<br/>    variables.data-?????-of-?????<br/>    variables.index<br/>saved_model.pb</span></pre><ul class=""><li id="c52d" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn ok ol om on bi translated"><strong class="lx iu"> saved_model.pb </strong>定义数据流结构</li><li id="afeb" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><strong class="lx iu">资产</strong>是包含所有辅助模型文件的子目录</li><li id="6430" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><strong class="lx iu"> assets.extra </strong>是包含由其他库生成的资源的子目录</li><li id="453a" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><strong class="lx iu">变量</strong>是一个<strong class="lx iu"> </strong>子目录，包含用于恢复模型的权重</li></ul><h2 id="2fcb" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">指定模型版本</h2><p id="d256" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">默认情况下，TensorFlow服务将始终为您的模型提供最新版本。“最新”版本是从SavedModel目录名推断出来的。对于这个例子，我根据训练时的整数时间戳命名了SavedModel目录，因此总是提供最新的模型。</p><h1 id="84a5" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">为模型服务</h1><p id="b141" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">确保您在此步骤之前训练了模型。可以通过在克隆的repo的根目录下运行<code class="fe oz pa pb pc b">python -m classifier.train</code>来训练模型。这将运行上述代码。</p><p id="82cf" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">是时候为模特服务了！确保为这一步安装了Docker。</p><ol class=""><li id="9ded" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn pu ol om on bi translated">使用<code class="fe oz pa pb pc b">docker pull tensorflow/serving</code>获取TensorFlow服务图像的最新版本</li><li id="a27c" class="of og it lx b ly oo mb op li oq lm or lq os mn pu ol om on bi translated">在您克隆GitHub repo的根目录中，根据SavedModel文件的路径创建一个环境变量。如果你按照自述文件上的说明，这将是<code class="fe oz pa pb pc b">export ModelPath=”$(pwd)/classifier”</code></li><li id="8ff8" class="of og it lx b ly oo mb op li oq lm or lq os mn pu ol om on bi translated">启动服务器并为REST API端点公开端口8501:</li></ol><pre class="kj kk kl km gt pm pc pn po aw pp bi"><span id="4dea" class="kz la it pc b gy pq pr l ps pt">docker run -t --rm -p 8501:8501 \<br/>    -v "$ModelPath/saved_models:/models/sentiment_analysis" \<br/>    -e MODEL_NAME=sentiment_analysis \<br/>    tensorflow/serving</span></pre><p id="41bc" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">会出现一堆日志。每个日志中的第一个字符将指示进程的状态。</p><ul class=""><li id="6c04" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn ok ol om on bi translated"><strong class="lx iu"> E =错误</strong></li><li id="ba97" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><strong class="lx iu"> W =警告</strong></li><li id="0aa5" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><strong class="lx iu"> I =信息</strong></li></ul><p id="d166" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">下面是最初几行可能的样子。</p><pre class="kj kk kl km gt pm pc pn po aw pp bi"><span id="2b8c" class="kz la it pc b gy pq pr l ps pt">docker run -t --rm -p 8501:8501    -v "$ModelPath/:/models/<!-- -->sentiment_analysis<!-- -->"    -e MODEL_NAME=<!-- -->sentiment_analysis<!-- -->tensorflow/servingI tensorflow_serving/model_servers/server.cc:82] Building single TensorFlow model file config:  model_name: <!-- -->sentiment_analysis<!-- --> model_base_path: /models/<!-- -->sentiment_analysis<br/>I tensorflow_serving/model_servers/server_core.cc:461] Adding/updating models.</span></pre><p id="5494" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">如果每个日志都以<strong class="lx iu"> I、</strong>开头，那么恭喜您——该模型已经成功提供了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="cd73" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated"><strong class="lx iu">注意:</strong>让日志淹没你的终端可能有点烦人。使用分离模式，所以它不会这样做。下面命令的唯一区别是增加了一个<code class="fe oz pa pb pc b">-d</code>标志。</p><pre class="kj kk kl km gt pm pc pn po aw pp bi"><span id="4433" class="kz la it pc b gy pq pr l ps pt">docker run -t -d --rm -p 8501:8501 \<br/>    -v "$ModelPath/saved_models:/models/sentiment_analysis" \<br/>    -e MODEL_NAME=sentiment_analysis \<br/>    tensorflow/serving</span></pre><h1 id="61b5" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">有用的Docker命令</h1><p id="62bc" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这里有两个有用的Docker命令，在使用模型服务器时可能会派上用场:</p><ul class=""><li id="7ab1" class="of og it lx b ly mp mb mq li oh lm oi lq oj mn ok ol om on bi translated"><code class="fe oz pa pb pc b">docker ps</code> -显示哪些Docker容器正在运行；这对于获取容器id以便进一步操作非常有用</li><li id="74c7" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated"><code class="fe oz pa pb pc b">docker kill [container id]</code> -如果您构建了错误的模型，您可以终止当前容器来释放端口并重启服务器</li></ul><h1 id="2630" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">发布请求</h1><p id="f81e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">既然我们的模型服务器已经在本地机器上启动并运行，我们就可以发送一个示例POST请求了。POST请求可以通过<a class="ae ky" href="https://curl.haxx.se/docs/manpage.html" rel="noopener ugc nofollow" target="_blank"> curl </a>发送，这是一个用于在服务器之间传输数据的简单工具，也可以通过Python中的<code class="fe oz pa pb pc b">request</code>库发送。</p><p id="2ddf" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated"><strong class="lx iu">样本卷曲命令:</strong></p><p id="fb54" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我们通过了“史上最差电影”的评论。</p><pre class="kj kk kl km gt pm pc pn po aw pp bi"><span id="0659" class="kz la it pc b gy pq pr l ps pt">curl -d '{"inputs":{"review": ["worst movie EVER"]}}' \<br/>  -X POST http://localhost:8501/v1/models/sentiment_analysis:predict</span></pre><p id="06f9" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated"><strong class="lx iu">对应输出:</strong></p><p id="84b2" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">不出所料，“史上最差电影”被认为不太可能是正面评价。</p><pre class="kj kk kl km gt pm pc pn po aw pp bi"><span id="a117" class="kz la it pc b gy pq pr l ps pt">{ "outputs": { "prediction": [[ 0.091893291 ]], "description": "prediction ranges from 0 (negative) to 1 (positive)" } }</span></pre><p id="541b" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">这次到此为止。希望这篇文章对你有帮助！快乐大厦。</p><h1 id="3b37" class="nu la it bd lb nv ou nx le ny ov oa lh jz ow ka ll kc ox kd lp kf oy kg lt oe bi translated">参考</h1><ul class=""><li id="ecfd" class="of og it lx b ly lz mb mc li pv lm pw lq px mn ok ol om on bi translated"><a class="ae ky" href="https://keras.io/examples/nlp/text_classification_from_scratch/?fbclid=IwAR1_T5oLgYdLfGFllj79BHkZNTuOgJA8m3fQ4awjQkckY9jUQw1eyFDU_rU" rel="noopener ugc nofollow" target="_blank">https://keras . io/examples/NLP/text _ class ification _ from _ scratch/</a></li><li id="8dd6" class="of og it lx b ly oo mb op li oq lm or lq os mn ok ol om on bi translated">https://www.tensorflow.org/api_docs<a class="ae ky" href="https://www.tensorflow.org/api_docs" rel="noopener ugc nofollow" target="_blank"/></li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="bd4b" class="nu la it bd lb nv nw nx le ny nz oa lh jz ob ka ll kc oc kd lp kf od kg lt oe bi translated">感谢您的阅读！</h1><p id="23a3" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated"><a class="ae ky" href="https://medium.com/@mandygu" rel="noopener">通过Medium </a>关注我的最新动态。😃</p><p id="cf11" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">作为一个业余爱好项目，我还在<a class="ae ky" href="http://www.dscrashcourse.com/" rel="noopener ugc nofollow" target="_blank">www.dscrashcourse.com</a>建立了一套全面的<strong class="lx iu">免费</strong>数据科学课程和练习题。</p><p id="a158" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">再次感谢您的阅读！📕</p></div></div>    
</body>
</html>