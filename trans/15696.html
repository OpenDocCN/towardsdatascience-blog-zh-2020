<html>
<head>
<title>Writing your own sklearn transformer: feature scaling, DataFrames and column transformation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自己的sklearn转换器:功能缩放、数据框架和列转换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-your-own-sklearn-transformer-feature-scaling-dataframes-and-column-transformation-bc10cbe0bb86?source=collection_archive---------53-----------------------#2020-10-28">https://towardsdatascience.com/writing-your-own-sklearn-transformer-feature-scaling-dataframes-and-column-transformation-bc10cbe0bb86?source=collection_archive---------53-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0346" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写自己的sklearn函数，第2部分</h2></div><p id="ca41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从<code class="fe lb lc ld le b">scikit-learn</code>不久前给API增加了<code class="fe lb lc ld le b">DataFrame</code>支持，修改和编写你自己的变形金刚变得更加容易——并且<a class="ae lf" href="https://medium.com/dunder-data/from-pandas-to-scikit-learn-a-new-exciting-workflow-e88e2271ef62" rel="noopener">工作流程</a>也变得更加容易。</p><p id="db96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多<code class="fe lb lc ld le b">sklearns</code>的补救措施仍然在内部使用<code class="fe lb lc ld le b">numpy</code>数组或返回数组，这在谈到<a class="ae lf" href="https://penandpants.com/2014/09/05/performance-of-pandas-series-vs-numpy-arrays/" rel="noopener ugc nofollow" target="_blank">性能</a>时通常很有意义。性能在管道中尤其重要，因为如果一个转换器比其他转换器慢得多，它会很快引入瓶颈。当预测对时间要求很高时，这种情况尤其糟糕，例如，将模型用作实时预测的端点时。如果性能不重要或没有仔细评估，许多转换器可以调整和改进，以使用并返回<code class="fe lb lc ld le b">DataFrames</code>，这有一些优点:它们是数据科学工作流中非常自然的一部分，它们可以包含不同的数据类型并存储列名。</p><p id="6a6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个例子是特征标准化，如果你使用我们神经网络的线性模型，这可能是至关重要的:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="b9de" class="lo lp iq le b gy lq lr l ls lt">import pandas as pd<br/>import numpy as np</span><span id="c9e8" class="lo lp iq le b gy lu lr l ls lt">data = pd.DataFrame({<br/>  'num1': [1.0, 2.0, 10.0, 1.0, 3.0, 0.0],<br/>  'num2': [2.0, 3.0, 20.0, -3.0, 5.0, 0.5],<br/>})</span><span id="4cec" class="lo lp iq le b gy lu lr l ls lt">data<br/>##    num1  num2<br/>## 0   1.0   2.0<br/>## 1   2.0   3.0<br/>## 2  10.0  20.0<br/>## 3   1.0  -3.0<br/>## 4   3.0   5.0<br/>## 5   0.0   0.5</span></pre><p id="e83e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据<a class="ae lf" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">文档</a>的说明，<code class="fe lb lc ld le b">StandardScaler</code>可以“通过去除平均值并缩放至单位方差来标准化特征”。在<code class="fe lb lc ld le b">fit</code>期间，它学习训练数据的平均值和标准偏差，这可用于在<code class="fe lb lc ld le b">transform</code>期间标准化特征。默认情况下，转换器将转换后的数据强制转换为一个<code class="fe lb lc ld le b">numpy</code>数组，因此列名被删除:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="3e3a" class="lo lp iq le b gy lq lr l ls lt">from sklearn.preprocessing import StandardScaler</span><span id="96ba" class="lo lp iq le b gy lu lr l ls lt">standard_scaler = StandardScaler()<br/>standard_scaler.fit(data);<br/>standard_scaler.transform(data)<br/>## array([[-0.54931379, -0.35307151],<br/>##        [-0.24968808, -0.21639867],<br/>##        [ 2.14731753,  2.10703964],<br/>##        [-0.54931379, -1.03643571],<br/>##        [ 0.04993762,  0.05694702],<br/>##        [-0.84893949, -0.55808077]])</span></pre><p id="f6d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很容易地将转换器修改为返回<code class="fe lb lc ld le b">DataFrames</code>，要么继承现有的转换器，要么封装它:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="b983" class="lo lp iq le b gy lq lr l ls lt">another_standard_scaler = AnotherStandardScaler()<br/>another_standard_scaler.fit_transform(data)</span><span id="197d" class="lo lp iq le b gy lu lr l ls lt">##        num1      num2<br/>## 0 -0.549314 -0.353072<br/>## 1 -0.249688 -0.216399<br/>## 2  2.147318  2.107040<br/>## 3 -0.549314 -1.036436<br/>## 4  0.049938  0.056947<br/>## 5 -0.848939 -0.558081</span></pre><p id="4c7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以进一步修改它，接受一个<code class="fe lb lc ld le b">cols</code>参数，只针对特定的列:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="5ecc" class="lo lp iq le b gy lq lr l ls lt">column_standard_scaler = ColumnStandardScaler(cols=['num1'])<br/>column_standard_scaler.fit_transform(data)<br/>##        num1  num2<br/>## 0 -0.549314   2.0<br/>## 1 -0.249688   3.0<br/>## 2  2.147318  20.0<br/>## 3 -0.549314  -3.0<br/>## 4  0.049938   5.0<br/>## 5 -0.848939   0.5</span></pre><p id="e088" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">封装后的版本如下，我们仍然继承了<code class="fe lb lc ld le b">BaseEstimator</code>和<code class="fe lb lc ld le b">TransformerMixin</code>，因为<code class="fe lb lc ld le b">BaseEstimator</code>免费给了我们<code class="fe lb lc ld le b">get_params</code>和<code class="fe lb lc ld le b">set_params</code>，而<code class="fe lb lc ld le b">TransformerMixin</code>提供了<code class="fe lb lc ld le b">fit_transform</code>。原谅这个愚蠢的名字，即<code class="fe lb lc ld le b">AnotherColumnStandardScaler</code>:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="2101" class="lo lp iq le b gy lq lr l ls lt">another_column_standard_scaler = AnotherColumnStandardScaler(cols=['num1'])<br/>another_column_standard_scaler.fit_transform(data)<br/>##        num1  num2<br/>## 0 -0.549314   2.0<br/>## 1 -0.249688   3.0<br/>## 2  2.147318  20.0<br/>## 3 -0.549314  -3.0<br/>## 4  0.049938   5.0<br/>## 5 -0.848939   0.5</span></pre><p id="1c8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想开发自己的转换器，而不是修改或封装现有的转换器，我们可以如下创建它:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="lw lx l"/></div></figure><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="2c31" class="lo lp iq le b gy lq lr l ls lt">custom_standard_scaler = CustomStandardScaler(cols=['num1'])<br/>custom_standard_scaler.fit_transform(data)<br/>##        num1  num2<br/>## 0 -0.549314   2.0<br/>## 1 -0.249688   3.0<br/>## 2  2.147318  20.0<br/>## 3 -0.549314  -3.0<br/>## 4  0.049938   5.0<br/>## 5 -0.848939   0.5</span></pre><p id="4752" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果与普通sklearn缩放器相同:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="797f" class="lo lp iq le b gy lq lr l ls lt">custom_standard_scaler.transform(data)['num1'].values == standard_scaler.transform(data)[:,0]<br/>## array([ True,  True,  True,  True,  True,  True])</span></pre><p id="0491" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了编写我们自己的转换器，我们还可以使用<code class="fe lb lc ld le b">sklearns</code> <code class="fe lb lc ld le b">ColumnTransformer</code>将不同的转换器应用于不同的列(并通过传递<code class="fe lb lc ld le b">passthrough</code>保留其他的)。但是，这个函数将返回数组，因此会删除列名:</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="9e66" class="lo lp iq le b gy lq lr l ls lt">from sklearn.compose import ColumnTransformer</span><span id="72b7" class="lo lp iq le b gy lu lr l ls lt">column_transformer = ColumnTransformer(<br/>    transformers=[<br/>        ('scaler', AnotherStandardScaler(), ['num1']),<br/>    ],<br/>    remainder='passthrough')</span><span id="e849" class="lo lp iq le b gy lu lr l ls lt">column_transformer.fit_transform(data)<br/>## array([[-0.54931379,  2.        ],<br/>##        [-0.24968808,  3.        ],<br/>##        [ 2.14731753, 20.        ],<br/>##        [-0.54931379, -3.        ],<br/>##        [ 0.04993762,  5.        ],<br/>##        [-0.84893949,  0.5       ]])</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="1d48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mf">原载于</em><a class="ae lf" href="https://blog.telsemeyer.com/2019/12/15/writing-your-own-sklearn-transformer-dataframes-feature-scaling-columntransformer-writing-your-own-sklearn-functions-part-two/" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://blog.telsemeyer.com</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>