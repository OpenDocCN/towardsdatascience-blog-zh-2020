<html>
<head>
<title>Monte Carlo Tree Search: Implementing Reinforcement Learning in Real-Time Game Player | Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蒙特卡罗树搜索:在实时游戏玩家中实现强化学习|第3部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/monte-carlo-tree-search-implementing-reinforcement-learning-in-real-time-game-player-a9c412ebeff5?source=collection_archive---------16-----------------------#2020-10-23">https://towardsdatascience.com/monte-carlo-tree-search-implementing-reinforcement-learning-in-real-time-game-player-a9c412ebeff5?source=collection_archive---------16-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cb0d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分—MCTS算法的实现，该算法可以在有限的时间内处理实时游戏“HEX”中的决策。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/19ee7748cc94f7fd131b36281f4da544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ts_-oj-LeBFcDeCedBd3Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@ryoji__iwata?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">岩田良治</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="18ab" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="d9ef" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di">在</span>之前的文章中，我们学习了<a class="ae kv" rel="noopener" target="_blank" href="/monte-carlo-tree-search-a-case-study-along-with-implementation-part-1-ebc7753a5a3b">强化学习基础</a>和<a class="ae kv" rel="noopener" target="_blank" href="/monte-carlo-tree-search-implementing-reinforcement-learning-in-real-time-game-player-25b6f6ac3b43">蒙特卡罗树搜索</a>基础。我们介绍了MCTS如何搜索所有的状态动作空间，并根据对搜索空间进行采样后收集的统计数据得出一个好的动作。</p><p id="75e8" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">对于那些着急的人，这是该项目的完整代码:</p><div class="my mz gp gr na nb"><a href="https://github.com/masouduut94/MCTS-agent-python" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">马苏杜特94/MCTS-代理-python</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">蒙特卡罗树搜索(MCTS)是一种在给定领域通过随机抽样寻找最优决策的方法</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np kp nb"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/d9ab0d2ef71dae1271f03f105da3403d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VTVVEWPcc8hmSNe5_-EIog.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:游戏的演示。作者在<a class="ae kv" href="https://github.com/masouduut94/MCTS-agent-python" rel="noopener ugc nofollow" target="_blank"> Github </a>上的图片。</p></figure><p id="2e90" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这张gif展示了最终产品的演示。正如您在GUI中点击<em class="nr">生成按钮</em>所看到的，MCTS代理选择了最佳可能的移动。黑人和白人玩家之间的竞争欲望真的很有趣，因为对我们人类来说，游戏棋盘上的移动选择听起来很有战略意义。</p><p id="f940" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">我必须感谢肯尼·杨，他出色地实现了mopyhex，这对我的项目帮助很大。这篇文章主要包括解释他的代码。在接下来的文章中，我们将进一步为这个项目添加一些贡献，以便在状态-动作空间中进行更健壮的搜索，并使用<code class="fe ns nt nu nv b">cython</code>工具优化C级速度的代码。</p><h1 id="8ff2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">模块概述</h1><p id="bd13" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在接触代码之前，为了给出项目的概述，让我描述一下每个模块的功能。基本上，初始框架需要实现6个类:</p><ul class=""><li id="0832" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">GameState</code>:这个模块简单的提供了树的每个节点中关于游戏状态的每一个基本信息。</li><li id="e1b0" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">UnionFind</code>:该模块是帮助<code class="fe ns nt nu nv b">GameState</code>检查两侧是否连接的实用模块。换句话说，在这个模块的帮助下，我们可以在游戏的任何状态下检测出赢家，如果有的话。</li><li id="8289" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">Node</code>:这个实现了指示每个游戏状态的树的每个节点。每个节点都有一个基于UCT算法的评估函数。</li><li id="0761" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">UctMctsAgent</code>:这个处理蒙特卡罗树搜索算法的树结构。</li><li id="a0b4" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">Gui</code>:这个模块使用<code class="fe ns nt nu nv b">Tkinter</code>模块实现了一个简单的图形用户界面，使游戏中的人机交互成为可能。</li><li id="99bb" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">MCTSMeta</code>和<code class="fe ns nt nu nv b">GameMeta</code>:这些模块只是存储一些常量。</li></ul><p id="6781" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">我已经实现了一些算法，这些算法使用了快速动作评估的概念，并且在短期搜索中比UCT算法更强。让它变得更加强大。我将在后面讲述这些算法的概念。</p><h1 id="458b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">游戏状态模块:</h1><p id="f5ae" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在每个游戏状态树中，搜索代理需要知道三件事才能从一个状态转换到另一个状态:</p><ul class=""><li id="c6f4" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated">轮到哪个玩家了。</li><li id="8bd1" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">未被占用的棋盘单元格(可供选择的棋步)。</li><li id="065f" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">能够为黑人和白人玩家检测双方之间的连接。</li></ul><p id="8353" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">后一种实现起来相当棘手。因为要检测连接，我们必须跟踪不相交的细胞群。因此，我们必须利用数据结构，即不相交集(也称为联合查找)。但是HEX游戏板单元从6个侧面连接到它的邻居的事实，使得它更难实现。看看下面的图片:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/acf084768d4397eb2e88f78ab49b993a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*UScbZAKVPwdtiHga72piLA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:一个黑色单元从6个侧面连接到其相邻单元。作者图片</p></figure><p id="3453" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">那么我们如何处理这个难题呢？</p><p id="ae26" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">首先，我使用NumPy数组来保存游戏板的值。未被占用的像元值为0，相应地，白色像元和黑色像元值为1和2。此图以阵列形式展示了一个8X8游戏板:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/37f33798a68072842ec77ee1cfe41018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*to1SezKiIlmaPOkbe6I93Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:阵列状单元上的游戏棋盘表示。作者图片</p></figure><p id="21f7" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">每个单元有8个相邻单元。您在这里看到的值是在每个单元格上的坐标，这些单元格在<code class="fe ns nt nu nv b">GameMeta</code>中被定义为邻域，以将相邻单元格限制为6:</p><p id="d9d7" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><code class="fe ns nt nu nv b">NEIGHBOR_PATTERNS = ((-1, 0),(0, -1),(-1, 1),(0, 1),(1, 0),(1, -1))</code></p><p id="71e9" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">图2中单元的邻域现在可以表示如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/d937cf1ee27e0d082b4a1bc6cfa9a0c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HSczcWjNHb9l_HTQ_7WYQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:新的邻居小区被限制为6个(适用于六边形小区)。作者图片</p></figure><p id="8d87" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">最终在我们的游戏GUI中，它变成了类似图1的六边形。</p><h2 id="fc26" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">UnionFind类:</h2><p id="e160" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在是时候调整这个游戏的不相交集数据结构了。根据<a class="ae kv" href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="oy"><p id="05c4" class="oz pa iq bd pb pc pd pe pf pg ph mj dk translated">在计算机科学中，不相交集数据结构(也称为union-find)是一种跟踪被划分成几个不相交(非重叠)子集的一组元素的数据结构。</p></blockquote><figure class="pj pk pl pm pn kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/bc9638dbd3d8c33a60f4318bf05d33f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*2bo0ekHu3EYQxMfHe8KeGA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5:白色和黑色不相交的集合。作者图片</p></figure><p id="7c3c" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">上图显示了这些不相交的集合，它们是游戏环境的例子。如果你想知道更多关于不相交集合数据结构的概念，你可能想在这里检查这个链接<a class="ae kv" href="https://medium.com/better-programming/using-disjoint-set-union-find-to-build-a-maze-generator-7462ea3b8632" rel="noopener">。这是我想出的<code class="fe ns nt nu nv b">unionfind.py</code>的代码:</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="b1ec" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">方法:</p><ul class=""><li id="f5ad" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">join</code>:如果输入板单元格不在同一个组中，则将其加入到单元格组中。</li><li id="9e88" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">find</code>:查找给定单元的代表元素(可能是一个集合)。</li><li id="0c90" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">connected</code>:检查两个元素是否在同一组。该功能用于检查电路板的两侧是否连接，这意味着它有助于我们检测获胜者。看看图3。</li><li id="cef1" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">set_ignored_elements </code>:在不相交的集合中，必须忽略边缘。</li><li id="df67" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">get_groups</code>:返回游戏状态下的各组单元格。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/0259b0b8aeff45193ae76f1821834aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*zhMQ02juhGHC2UzTmmnRNg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6:白边连接。这个连接将被connected方法检测到。作者图片</p></figure><p id="3877" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">现在让我们定义游戏状态模块。这是<code class="fe ns nt nu nv b">GameState</code>类的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="4102" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这就是考虑属性的原因:</p><ul class=""><li id="4c6a" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">size</code>:表示板的尺寸(尺寸X尺寸)</li><li id="5424" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">to_play</code>:表示该轮是黑棋还是白棋。</li><li id="1c9f" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">board</code>:2d NumPy数组，保存板单元值(无论每个单元是黑、白还是空)。</li><li id="446b" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">White_played</code>和<code class="fe ns nt nu nv b">black_played</code>:游戏过程中每个玩家选择的移动次数。(这些值的用法将在本系列的下一集解释)。</li><li id="22d8" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">white_groups</code>和<code class="fe ns nt nu nv b">black_groups</code>:为了使用<code class="fe ns nt nu nv b">UnionFind</code>类，我们通过给模块分配这些变量来创建模块的实例。</li></ul><p id="9075" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">让我们来描述一下这些功能:</p><ul class=""><li id="d82a" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">play</code>:轮到的玩家拥有作为输入传递的单元格。</li><li id="b629" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">get_num_played</code>:返回每个玩家出招次数的字典。</li><li id="cf8f" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">get_white_groups </code>和get_black_groups:返回每个玩家组。</li><li id="02e1" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">place_white </code>和<code class="fe ns nt nu nv b">place_black</code>:将石头放在棋盘上，然后如果石头是边的邻居，它们通过‘union find . join’函数连接。那么与该小区具有相同值的所有相邻小区也加入该组。</li><li id="78e6" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">turn</code>:这是一个简单返回<code class="fe ns nt nu nv b">turn </code>属性的方法。</li><li id="4048" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">set_turn</code>:要改变转弯，我们使用此功能。</li><li id="1e69" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">winner</code>:这个属性检查两边之间是否有连接，如果有就返回胜者。否则不返回任何内容。</li><li id="a218" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">neighbors</code>:返回所有邻居单元格。</li><li id="9815" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">moves</code>:返回当前棋盘状态下所有可能走法的列表。</li></ul><p id="e55e" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这是<code class="fe ns nt nu nv b">meta.py</code>中的<code class="fe ns nt nu nv b">GameMeta</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><h1 id="e388" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">节点模块:</h1><p id="0a87" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们已经实现了游戏状态，是时候定义蒙特卡罗树搜索代理了。首先，我们必须为树的节点定义一个好的结构。这是定义<code class="fe ns nt nu nv b">Node </code>模块的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="d56b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">每个节点都具有以下属性:</p><ul class=""><li id="0bcb" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">move</code>:树中的每个节点表示棋盘中的单元格，我们将其定义为每个状态下的潜在动作。</li><li id="a5fb" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">parent</code>:指向父节点。</li><li id="fa51" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">N</code>:这是在选择阶段该节点被访问的次数。</li><li id="9060" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">Q</code>:这是从模拟中的失败次数中减去的成功次数。</li><li id="a8db" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">N_RAVE</code>和<code class="fe ns nt nu nv b">Q_RAVE</code>:这些项目属于RAVE(快速动作评估)算法，将在即将到来的未来文章中解释。</li><li id="36dd" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">children</code>:由此节点产生的下一个状态。</li><li id="c82b" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">如果节点是一片叶子，那么结果将显示获胜者。否则没有。</li></ul><h2 id="1e2f" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">方法</h2><ul class=""><li id="8dfb" class="nw nx iq lq b lr ls lu lv lx pr mb ps mf pt mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">add_children:</code>它得到一个移动字典，并把它们存储在<code class="fe ns nt nu nv b">children </code>属性中。</li><li id="a910" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">value</code>:该属性根据本节点的<code class="fe ns nt nu nv b">N</code>和<code class="fe ns nt nu nv b">Q</code>属性以及父属性<code class="fe ns nt nu nv b">N</code>计算UCT公式。UCT公式中使用的<code class="fe ns nt nu nv b">explore</code>常数是UCT的探索项，在<code class="fe ns nt nu nv b">MCTSMeta.EXPLORATION</code>中有定义。<br/>请注意，当某个节点没有<code class="fe ns nt nu nv b">N</code>时，我们必须将该节点的值设置为无穷大，因为必须首先选择该节点。并且下一次基于<code class="fe ns nt nu nv b">N</code>和<code class="fe ns nt nu nv b">Q</code>，代理可以将其与其兄弟进行比较。</li></ul><p id="e373" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">让我们一步一步地编写<code class="fe ns nt nu nv b">MCTSAgent</code>代码。首先，让我们开始上课:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="35f1" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">如果你熟悉树数据结构的概念，你就知道如果你有了<strong class="lq ir">树节点</strong>并且遍历到你想去的任何地方，树中的所有节点都是可达的。<br/>所以我们定义<code class="fe ns nt nu nv b">root</code>为树根节点，<code class="fe ns nt nu nv b">rootstate</code>为树的根状态。然后，当我们遇到每一步棋时，我们在<code class="fe ns nt nu nv b">rootstate</code>中进行游戏，然后将状态转换为新的状态(交替玩家回合，检查黑组和白组是否有任何联系，…).<br/>属性<code class="fe ns nt nu nv b">run_time</code>、<code class="fe ns nt nu nv b">node_count</code>和<code class="fe ns nt nu nv b">num_rollouts </code>仅用于跟踪一些统计数据。</p><h2 id="b413" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">选择和扩展阶段</h2><p id="1bc7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们定义选择和扩展阶段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="e9c1" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">正如代码所暗示的，以及我之前提到的关于树遍历，我们首先复制游戏的<code class="fe ns nt nu nv b">root </code>和<code class="fe ns nt nu nv b">root_state </code>(第6行和第7行)。然后，直到我们没有遇到任何叶子(这意味着游戏没有结束或者代理仍然没有探索树)，我们继续选择具有最大UCT值的节点(在第13行和第14行中计算)，然后通过进行实际移动来转换状态(第17行)。如果我们到达某个<code class="fe ns nt nu nv b">N</code>等于<code class="fe ns nt nu nv b">0</code>的节点，我们选择它。在我们返回<code class="fe ns nt nu nv b">node</code>和<code class="fe ns nt nu nv b">state</code>之前，我们必须确定节点是否可扩展。所以在<code class="fe ns nt nu nv b">expand</code>方法中，首先我们确定游戏没有赢家，如果没有，我们给展开的节点添加子节点。因此节点及其状态随后被返回。</p><h2 id="2302" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">模拟阶段</h2><p id="1c31" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于模拟部分，我们得到了以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="c95b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">代理简单地获得游戏的状态，它继续玩随机移动，这是默认策略(在下一篇文章中，我将包括更多令人敬畏的策略),并转换<code class="fe ns nt nu nv b">state</code>,直到我们到达一个终端状态，在该状态中检测到游戏获胜者。</p><h2 id="f2bc" class="om kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">反向传播</h2><p id="987a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是该步骤的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="c1b6" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在这段代码中，我们有三个输入:</p><ul class=""><li id="4057" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated">node:是我们从<code class="fe ns nt nu nv b">select_node</code>方法的输出中得到的节点。</li><li id="2e64" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">转弯:这表示玩家进入了<code class="fe ns nt nu nv b">select_node</code>方法的第二个输出状态。</li><li id="a250" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">结果:这是模拟阶段的输出，是模拟的赢家</li></ul><p id="9ead" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">我们在反向传播部分要做的是(如这里讨论的<a class="ae kv" rel="noopener" target="_blank" href="/monte-carlo-tree-search-implementing-reinforcement-learning-in-real-time-game-player-25b6f6ac3b43"/>，看一下图6)从<code class="fe ns nt nu nv b">node</code>开始，向后遍历选择的节点(第23行)并更新统计(第21行，第22行)，直到我们到达根节点(第20行，因为树节点没有父节点)。<br/>我们在输家玩家选择的节点和赢家玩家选择的节点之间交替，所以我们必须给赢家节点+1奖励，给输家节点0奖励(第24行)。<br/>另外，请注意，第18行表示，如果选择了该移动并到达<code class="fe ns nt nu nv b">node</code>状态的玩家获胜，我们必须给予他+1奖励。如果不是这样，玩家将被罚以<code class="fe ns nt nu nv b">0</code>奖励。</p><p id="ccc0" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">现在我们必须定义一个循环，在这个循环中，我们应该完成选择、扩展、模拟和反向传播的整个过程，这里提供了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="d4ec" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在我实现这段代码的时候，python 3.4是最新的版本。由于在第7行中，我使用了<code class="fe ns nt nu nv b">clock</code>函数，而在python 3.8中<code class="fe ns nt nu nv b">clock</code>函数在<code class="fe ns nt nu nv b">time</code>库中被弃用，所以我将<code class="fe ns nt nu nv b">from time import clock</code>修改为<code class="fe ns nt nu nv b">from time import time as clock</code>(很酷的把戏，对吧！？).</p><p id="0c4d" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在这段代码中，<code class="fe ns nt nu nv b">time_budget</code>(顾名思义)是我们可以进行尽可能多的MCTS模拟的时间(第11行)。选择和扩展在第12行完成，变量<code class="fe ns nt nu nv b">turn</code>保持当前玩家回合，然后相应地在第14行和第15行完成卷展和反向传播。</p><p id="7ee6" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在第18行，我们对树中的节点进行计数，并使用方法<code class="fe ns nt nu nv b">tree_size</code>将它们存储在变量<code class="fe ns nt nu nv b">node_count</code>中，我马上会添加这个方法。</p><p id="6314" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这是整个<code class="fe ns nt nu nv b">MCTSAgent </code>类的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="ef6b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">正如您在代码中看到的，有一些实用函数。<code class="fe ns nt nu nv b">best_move</code>方法(第140行)返回基于<code class="fe ns nt nu nv b">N </code>值的最佳移动(模拟次数最多的节点。模拟越多，其探索的路径越好)。</p><p id="5f1b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><code class="fe ns nt nu nv b">move</code>方法用于在实际的游戏环境中走棋。这样，我们必须更新树<code class="fe ns nt nu nv b">root</code>和<code class="fe ns nt nu nv b">rootstate</code>。新的根将是当前根的子根，带有<code class="fe ns nt nu nv b">root.children</code>字典的<code class="fe ns nt nu nv b">move</code>键。新的<code class="fe ns nt nu nv b">rootstate</code>将是游戏中已经使用过的<code class="fe ns nt nu nv b">move</code>转换而来的<code class="fe ns nt nu nv b">state</code>。</p><p id="3ef5" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">因此，当我们在游戏环境中转换到一个新状态时，我们必须移除到其父状态的连接(第165行)，我们还更改了<code class="fe ns nt nu nv b">rootstate</code>(第167行)。</p><p id="55e3" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">请注意，我插入第172行和第173行的原因是，在游戏GUI中，可以选择不考虑回合的移动(就像黑人玩家连续选择2个单元格，而不让白人玩家在其回合中选择移动)。因此，为了在代码中实现这种灵活性，我们必须重置整个树(丢弃当前树)并重新开始MCTS过程。</p><p id="9899" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">方法<code class="fe ns nt nu nv b">set_gamestate</code>给了我们重置游戏状态的能力。所以我们可以改变棋盘的大小，重新开始。方法<code class="fe ns nt nu nv b">tree_size</code>在<code class="fe ns nt nu nv b">Queue</code>库的帮助下对树节点进行计数。<br/>我们还需要在<code class="fe ns nt nu nv b">meta.py</code>中定义这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><h1 id="c3e1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Gui模块:</h1><p id="4ca9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最后，我们为框架设计图形用户界面。<code class="fe ns nt nu nv b">Gui</code>类是在<code class="fe ns nt nu nv b">tkinter </code>模块的帮助下开发的。这个模块很容易理解，所以我只解释一些重要的部分。这是500行代码！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="086e" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">重要方法:</p><ul class=""><li id="fe5f" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">top_left_hexagon</code>:该方法在该函数中返回环境中左上角六边形单元格的坐标。</li><li id="85c6" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">hexagon</code>:这个用<code class="fe ns nt nu nv b">tkinter.Canvas.create_polygon</code>画一个六边形并返回。</li><li id="850c" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">generate_row</code>:在这个方法中，根据它的颜色生成一行六边形:这个函数获取gameboard数组，绘制整个游戏板。</li><li id="ef61" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">generate_white_edge </code>和<code class="fe ns nt nu nv b">generate_black_edge</code>:这些函数生成板的边缘，在那里单元格都是黑色或白色的。</li><li id="2c24" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated">这个功能可以让玩家与游戏互动。当在GUI中单击一个单元格时，它会用指向MCTS代理的<code class="fe ns nt nu nv b">self.agent</code>播放。</li><li id="3f97" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">set_size</code>:该方法检测self.game_size按钮的事件，用新的尺寸重置整个棋盘。它还会重置代理树。</li><li id="f2d5" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">set_time</code>:通过此功能调整MCTS搜索的时间预算。</li><li id="2121" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">Set_agent</code>:在我解释了RAVE算法之后，这个函数将在UCT和RAVE代理之间切换。</li><li id="b9e7" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">click_to_bot_play</code>:这个设计是让代理玩家根据我们之前讨论的<code class="fe ns nt nu nv b">MCTSAgent.best_move</code>方法选择移动。</li></ul><p id="cc8f" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">现在我们必须定义一个循环，在这个循环中，我们应该完成选择、扩展、模拟和反向传播的整个过程，这里提供了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="4f8b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在我实现这段代码的时候，python 3.4是最新的版本。由于在第7行中，我使用了<code class="fe ns nt nu nv b">clock</code>函数，而在python 3.8中<code class="fe ns nt nu nv b">clock</code>函数在<code class="fe ns nt nu nv b">time</code>库中被弃用，所以我将<code class="fe ns nt nu nv b">from time import clock</code>修改为<code class="fe ns nt nu nv b">from time import time as clock</code>(很酷的把戏，对吧！？).</p><p id="202c" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在这段代码中，<code class="fe ns nt nu nv b">time_budget</code>(顾名思义)是我们可以尽可能多地进行MCTS模拟的时间(第11行)。选择和扩展在第12行完成，<code class="fe ns nt nu nv b">turn</code>变量保持当前玩家回合，然后相应地在第14行和第15行完成展示和反向传播。</p><p id="6059" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在第18行，我们对树中的节点进行计数，并使用<code class="fe ns nt nu nv b">tree_size</code>方法将其保存在<code class="fe ns nt nu nv b">node_count</code>变量中，我马上会添加这个方法。</p><p id="bfbc" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这是整个<code class="fe ns nt nu nv b">MCTSAgent </code>类的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="8c3e" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">正如您在代码中看到的，有一些实用函数。<code class="fe ns nt nu nv b">best_move</code>方法(第140行)返回基于<code class="fe ns nt nu nv b">N </code>值的最佳移动(模拟次数最多的节点。模拟越多，其探索的路径越好)。</p><p id="ed0f" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><code class="fe ns nt nu nv b">move</code>方法用于在实际游戏环境中进行移动。这样，我们必须更新树<code class="fe ns nt nu nv b">root</code>和<code class="fe ns nt nu nv b">rootstate</code>。新的根将是当前根的孩子，带有<code class="fe ns nt nu nv b">root.children</code>字典的<code class="fe ns nt nu nv b">move</code>键。新的<code class="fe ns nt nu nv b">rootstate</code>将会是游戏中已经使用过的<code class="fe ns nt nu nv b">move</code>转换后的<code class="fe ns nt nu nv b">state</code>。</p><p id="7be1" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">因此，当我们在游戏环境中转换到一个新状态时，我们必须移除与其父状态的连接(第165行)，我们还更改了<code class="fe ns nt nu nv b">rootstate</code>(第167行)。</p><p id="3990" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">请注意，我插入第172行和第173行的原因是，在游戏GUI中，可以选择不考虑回合的移动(就像黑人玩家连续选择2个单元格，而不让白人玩家在其回合中选择移动)。因此，为了在代码中实现这种灵活性，我们必须重置整个树(丢弃当前树)并重新开始MCTS过程。</p><p id="01be" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">方法<code class="fe ns nt nu nv b">set_gamestate</code>给了我们重置游戏状态的能力。所以我们可以改变棋盘的大小，重新开始。方法<code class="fe ns nt nu nv b">tree_size</code>在<code class="fe ns nt nu nv b">Queue</code>库的帮助下对树节点进行计数。<br/>我们还需要在<code class="fe ns nt nu nv b">meta.py</code>中定义这个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><h1 id="ab57" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Gui模块:</h1><p id="ffc3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最后，我们为框架设计图形用户界面。<code class="fe ns nt nu nv b">Gui</code>类是在<code class="fe ns nt nu nv b">tkinter </code>模块的帮助下开发的。这个模块很容易理解，所以我只解释一些重要的部分。这是500行代码！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="4ff2" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">重要方法:</p><ul class=""><li id="97be" class="nw nx iq lq b lr mt lu mu lx ny mb nz mf oa mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">top_left_hexagon</code>:该方法在该函数中返回环境中左上角六边形单元格的坐标。</li><li id="ec21" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">hexagon</code>:这个用<code class="fe ns nt nu nv b">tkinter.Canvas.create_polygon</code>画一个六边形并返回。</li><li id="2dec" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">generate_row</code>:在该方法中，根据颜色生成一行六边形</li><li id="767e" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">gameboard2hexagons</code>:该函数获取游戏板数组，绘制整个游戏板。</li><li id="73d7" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">generate_white_edge </code>和<code class="fe ns nt nu nv b">generate_black_edge</code>:这些函数生成板的边缘，其中的单元格全部为黑色或白色。</li><li id="5d14" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">click2play</code>:这个功能可以实现人与游戏的互动。当在游戏环境中选择一步棋时，它会用指向代理的<code class="fe ns nt nu nv b">self.agent</code>来玩。</li><li id="2b55" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">set_size</code>:该方法检测self.game_size按钮的事件，用新的尺寸重置整个棋盘。它还会重置代理树。</li><li id="e8e0" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">set_time</code>:mcts搜索的时间预算由该功能调整。</li><li id="a75a" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">Set_agent</code>:在我在下一篇文章中解释了RAVE算法之后，你会看到这个函数会在UCT和RAVE代理之间转换代理。</li><li id="8273" class="nw nx iq lq b lr of lu og lx oh mb oi mf oj mj ob oc od oe bi translated"><code class="fe ns nt nu nv b">click_to_bot_play</code>:这个设计是让代理玩家根据我们之前讨论的“MCTSAgent.best_move”方法选择移动。</li></ul><p id="062f" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">现在是运行代码的时候了:<br/>添加<code class="fe ns nt nu nv b">main.py</code>并将这段代码复制粘贴到那里:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po pp l"/></div></figure><h1 id="7d69" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">结论</strong></h1><p id="820e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们用纯python实现了一个蒙特卡罗树搜索算法，包含了尽可能少的外部库。该项目的完整代码可以在<a class="ae kv" href="https://github.com/masouduut94/MCTS-agent-python" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这个项目是一个简单的UCT<strong class="lq ir">算法的实现。<br/>虽然UCT算法是精确的<strong class="lq ir">，但是它需要大量的模拟来收敛到可用的最优解</strong>。为了提高算法性能，有很多选项，如RAVE，果断行动，最后一次良好的答复，和PoolRAVE，…算法。这些算法将在接下来的文章中进一步解释。</strong></p><p id="6a24" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">顺便说一下，如果你想找一个有经验的研究员加入你的团队，我完全可以。我在强化学习、计算机视觉和数据科学方面有一些经验。你可以在LinkedIn上找到我。</p></div></div>    
</body>
</html>