<html>
<head>
<title>Grid Search in Python from scratch— Hyperparameter tuning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的网格搜索—超参数调整</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/grid-search-in-python-from-scratch-hyperparameter-tuning-3cca8443727b?source=collection_archive---------7-----------------------#2020-11-08">https://towardsdatascience.com/grid-search-in-python-from-scratch-hyperparameter-tuning-3cca8443727b?source=collection_archive---------7-----------------------#2020-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06d644e0882d8e60128c466b207104c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vxv8y-C7YeFiy_PdJMTCJg.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由<a class="ae kc" href="https://linktr.ee/jpuckett_design" rel="noopener ugc nofollow" target="_blank"> JPuckett Design </a>在<a class="ae kc" href="https://www.instagram.com/jpuckett_design/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上提供。</p></figure><p id="b2c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">超参数调整对于机器学习(ML)模型的正确运行至关重要。网格搜索法是超参数优化的基本工具。</p><p id="8983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网格搜索方法考虑几个超参数组合，并选择返回较低错误分数的一个。当只有几个超参数需要优化时，这种方法特别有用，尽管当ML模型变得复杂时，这种方法优于其他加权随机搜索方法。</p><p id="1e5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文介绍了用<strong class="kf ir">网格搜索</strong>进行<strong class="kf ir">超参数调整</strong>的思想。您将学习网格搜索如何工作，以及如何实现它来优化您的机器学习方法的性能。</p><p id="7bf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提供代码片段有助于理解实现。完整的代码可以在这个<a class="ae kc" href="https://github.com/marcosdelcueto/Tutorial_Grid_Search" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><blockquote class="lb"><p id="bbfc" class="lc ld iq bd le lf lg lh li lj lk la dk translated">网格搜索提供了一种调整ML模型超参数的直观方法，对于低维空间非常有效。</p></blockquote></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="3172" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">网格搜索概述</h1><p id="7259" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">1-准备数据库。</p><p id="8744" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2-确定要优化的模型超参数，然后选择要测试的超参数值。</p><p id="535d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3-评估超参数网格中每个组合的误差分数。</p><p id="9d15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4-选择具有最佳误差度量的超参数组合。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="cb1e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">生成数据</h1><p id="6aef" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">一个数据库由一系列特征<strong class="kf ir"><em class="mv">x</em></strong>:{<strong class="kf ir"><em class="mv">x</em></strong><em class="mv"/><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂,…，</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">ₙ</em>}和一个或多个目标属性<strong class="kf ir">y</strong>:{<em class="mv">f₁(</em><strong class="kf ir"><strong class="kf ir"> f₂(<strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁、</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂,…、</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">ₙ)、…、fₙ(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁、</em> <strong class="kf ir"> <em class="mv"/></strong></strong></strong></p><p id="13e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们将使用一个简单的数据库，有两个描述符<strong class="kf ir"><em class="mv">x</em></strong>:{<strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁，</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂</em>}和一个目标属性<strong class="kf ir">y</strong>:{<em class="mv">f(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁，</em> <strong class="kf ir"> <em class="mv"> x</em></strong></p><p id="728d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个例子，我们将使用遵循二维函数<em class="mv">f(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁、</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂)=sin(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁)+cos(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂】</em>的数据，加上区间(-0)中的小的随机变化因此，我们的数据将遵循以下表达式:</p><p id="8e12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">f(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁，</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂)= sin(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁)+cos(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂)+rnn</em></p><p id="0a36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在区间<strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁</em>:10，10和<strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂</em>:10，10中生成一个21×21的网格。下图显示了数据库中441个点的可视化表示。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/29fbdfe0c3c5de1544641eecdb6d1184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93OHyDpPuXJHemU1lLJrLA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="a131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用来生成这个的函数(<strong class="kf ir"> <em class="mv"> x </em> </strong> <em class="mv"> ₁、</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂、</em>、<em class="mv">f(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁、</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">【₂))</em></p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="3ef7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">机器学习模型</h1><p id="b877" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">在这种情况下，我们将使用一个<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.kernel_ridge.KernelRidge.html" rel="noopener ugc nofollow" target="_blank">核岭回归</a> (KRR)模型，带有一个<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.gaussian_process.kernels.RBF.html" rel="noopener ugc nofollow" target="_blank">径向基函数</a>核。通过调整两个超参数来评估模型的准确性:正则化常数(α)和核方差(γ)。如果你想知道更多关于KRR如何运作的细节，我建议看看我最近写的关于这个话题的文章。</p><p id="1abf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上一节中，我们已经看到了如何生成一个(<strong class="kf ir"> <em class="mv"> x </em> </strong> <em class="mv"> ₁，</em> <strong class="kf ir"> <em class="mv"> x </em> </strong> <em class="mv"> ₂ </em>，<em class="mv">f(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">【₁】，</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₂))</em>数据集。为简单起见，我们将其转换为一个<em class="mv">(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">，</em><strong class="kf ir"><em class="mv">y</em></strong><em class="mv">)</em>数据集，其中<strong class="kf ir"> <em class="mv"> X </em> </strong>是一个2D NumPy数组，包含(<strong class="kf ir"><em class="mv">x</em></strong><em class="mv">【₁】，</em> <strong class="kf ir"> <em class="mv"> x </em> </strong></p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="89f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以构建一个函数<em class="mv">KRR _函数</em>。该函数读取<em class="mv">(</em><strong class="kf ir"><em class="mv">X</em></strong><em class="mv">，</em> <strong class="kf ir">，<em class="mv"> y </em> </strong> <em class="mv"> ) </em>，并使用10重交叉验证来计算模型的准确性。作为误差度量，我们在这里使用均方根误差(RMSE)，它测量实际的<em class="mv">f(</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">₁、</em><strong class="kf ir"><em class="mv">x</em></strong><em class="mv">【₂】</em>值和预测值之间的平均误差。如果你不熟悉交叉验证，我最近写了一篇<a class="ae kc" href="https://www.mdelcueto.com/blog/a-brief-guide-to-cross-validation/" rel="noopener ugc nofollow" target="_blank">文章</a>，你可能会感兴趣。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="f2ed" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">探索超参数空间</h1><p id="d45b" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们需要决定一组我们想要研究的超参数值，然后我们使用我们的ML模型来计算相应的RMSE。最后，我们可以选择最优(α，γ)组合作为最小化RMSE的组合。</p><p id="a58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图显示了相应的RMSE值。我们使用了可变的标记大小来更清楚地说明具有最佳RMSE的值。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/5cfe7bcbfa2123161c64c0b6ef571613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hd8S-Z62-ecTxVTdnfe4BA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="8b89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用下面的代码，我们探索这个可能的超参数值的10×10网格，并且我们获得最小值<em class="mv">RMSE = 0.3014</em>at(<em class="mv">α=10⁻·</em>，<em class="mv"> γ=2.0 </em>)。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，使用这些函数并获得最佳超参数的最终代码应该是:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="25ba" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="1c7c" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">在这个简短的教程中，我们看到了如何实现和使用网格搜索来调整ML模型的超参数。我们已经生成了一个简单的2D数据集，并看到了如何优化具有两个超参数的ML模型的误差度量。</p><p id="8d5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们有大量超参数时，网格搜索对于调整ML模型并不有效，然后应该转向其他方法。举个例子，我最近写了一篇关于如何使用<a class="ae kc" rel="noopener" target="_blank" href="/genetic-algorithm-to-optimize-machine-learning-hyperparameters-72bd6e2596fc">遗传算法</a>调优ML模型的文章。</p><p id="8291" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇教程是有用的，并且记住你可以在<a class="ae kc" href="https://github.com/marcosdelcueto/Tutorial_Grid_Search" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中访问这篇教程中使用的完整代码和图形。</p></div></div>    
</body>
</html>