<html>
<head>
<title>SQL Order-based Calculations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于SQL顺序的计算</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-order-based-calculations-b924e79401a0?source=collection_archive---------48-----------------------#2020-09-27">https://towardsdatascience.com/sql-order-based-calculations-b924e79401a0?source=collection_archive---------48-----------------------#2020-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e7cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SQL如何解决这种困难但常见的计算</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7452b68d8007004a5e19bb286c878cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Fgj4WWZ3WbR5v20ydU5K2g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><em class="ku">作者图片</em></p></figure><p id="870b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">SQL中字段值的联合很常见，比如firstname+lastname和year(生日)。无论一个表达式包含多少个字段，它们都来自同一行。我们称之为<strong class="kx iu">行内计算</strong>。</p><p id="20bf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">相应的，还有<strong class="kx iu">行间计算</strong>。例子包括获得冠军和亚军的结果之间的差异，以及计算从1月到当月的累计销售额。为了确定冠军和亚军，需要根据结果对数据进行排序。从某一点到另一点的累加和也要求数据是有序的。所以我们称它们为<strong class="kx iu">基于顺序的计算</strong>。行内计算处理单个记录中的值，而行间计算处理有序记录之间的差异。</p><h1 id="e496" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">引用上一条/下一条记录中的值</h1><p id="e2bb" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">最简单也是最常见的基于顺序的计算是，当记录已经按一定顺序排序时，引用上一条或下一条记录中的值。下面是三种情况:</p><p id="57af" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 1。计算一只股票每天的增长率(链接相对比率)</strong></p><p id="20ac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">按日期排序记录，并参考前一天的收盘价。</p><p id="adc0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 2。计算一只股票三天内的平均价格，这三天分别是前一天、当天和第二天(移动平均线)</strong></p><p id="cb61" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">按日期排序记录，并参考前一天和第二天的收盘价。</p><p id="b284" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 3。有多只股票。计算每个交易日每只股票的涨幅(集团内环比)</strong></p><p id="4c13" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">按股票分组记录，按日期对每组排序，参考前一天的收盘价。</p><p id="d946" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们看看SQL如何处理这种基于订单的计算。</p><h1 id="328c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">早期的SQL解决方案</h1><p id="c628" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">早期的SQL没有窗口函数。为了引用相邻记录中的值，该语言将两个记录合并成一个记录。</p><p id="4372" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是处理任务1的程序:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="b783" class="mt ls it mp b gy mu mv l mw mx">SELECT day, curr.price/pre.price rate<br/>FROM (<br/>  SELECT day, price, rownum row1<br/>  FROM tbl ORDER BY day ASC) curr<br/>LEFT JOIN (<br/>  SELECT day, price, rownum row2<br/>  FROM tbl ORDER BY day ASC) pre<br/>ON curr.row1=pre.row2+1</span></pre><p id="6997" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过当天和前一天对表执行自联接，将前一天的收盘价和当天的收盘价放入一条记录中，然后执行行内计算以获得增长率。您可以看到子查询用于一个简单的任务。</p><p id="0102" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">SQL也使用JOIN计算任务2中的移动平均值:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="0b99" class="mt ls it mp b gy mu mv l mw mx">SELECT day, (curr.price+pre.price+after.price)/3 movingAvg<br/>  FROM (<br/>    SELECT day, price, rownum row1<br/>    FROM tbl ORDER BY day ASC) curr<br/>  LEFT JOIN (<br/>    SELECT day, price, rownum row2<br/>    FROM tbl ORDER BY day ASC) pre<br/>  ON curr.row1=pre.row2+1<br/>  LEFT JOIN (<br/>    SELECT day, price, rownum row3<br/>    FROM tbl ORDER BY day ASC) after<br/>  ON curr.row1=after.row3-1</span></pre><p id="faca" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">又一个子查询将被连接一天。想象一下获取过去10天和未来10天的移动平均值的程序。写20个JOINs肯定会烦死你。</p><p id="c7b2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">任务3更复杂。由于有多只股票，SQL添加了一个代码列来区分不同的股票。因此，增长率是在一组库存记录中计算的:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="ed68" class="mt ls it mp b gy mu mv l mw mx">SELECT code, day ,currPrice/prePrice rate<br/>  FROM(<br/>    SELECT code, day, curr.price currPrice, pre.price prePrice<br/>    FROM (<br/>      SELECT code, day, price, rownum row1<br/>      FROM tbl ORDER BY code, day ASC) curr<br/>    LEFT JOIN (<br/>      SELECT code, day, price, rownum row2<br/>      FROM tbl ORDER BY code, day ASC) pre<br/>    ON curr.row1=pre.row2+1 AND curr.code=pre.code<br/>  )</span></pre><p id="a64f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有两点我想说一下。您必须使用“code，day”对表进行复合排序。代码走在前面，因为您需要首先将相同股票的记录放在一起，然后对它们进行排序。您还需要在连接条件中加入代码匹配，因为如果您不这样做，增长率将在不同股票的相邻记录之间进行计算。那会产生无用的脏数据。</p><h1 id="e130" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">具有窗口功能的解决方案</h1><p id="272d" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">SQL 2003引入了窗口函数来表达顺序的概念。在SQL中实现基于顺序的计算更容易。以上三项任务可以通过更简单的方式实现:</p><p id="9f17" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下程序计算任务1中的链路相对比率。为了更容易理解，我把窗口函数写成几个缩进:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="cbf4" class="mt ls it mp b gy mu mv l mw mx">SELECT day, price /<br/>    LAG(price,1)<br/>      OVER (<br/>        ORDER BY day ASC<br/>      ) rate<br/> FROM tbl</span></pre><p id="9bd2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">LAG函数实现对前一条记录的引用。它的两个参数找到了直接在它之前的记录的价格。OVER是LAG函数中的substatement。每个窗口函数都有一个OVER语句。它的作用是定义一个待分析的有序集。在这个例子中，要分析的数据集已经按日期排序。</p><p id="17ed" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面的程序在任务2中计算移动平均值。一种方法是用LAG函数获取前一个值，然后用LEAD函数获取下一个值。另一种方法是这个程序使用的AVG函数，这是更可取的。AVG函数可以一次得到指定范围内的平均值，例如覆盖前10条记录和后10条记录的平均值，而滞后/超前函数一次只能得到一个值。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="494c" class="mt ls it mp b gy mu mv l mw mx">SELECT price,<br/>    AVG(price) OVER (<br/>      ORDER BY day ASC<br/>      RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING<br/>    ) movingAvg<br/>FROM tbl;</span></pre><p id="fc58" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这样，通过覆盖前面的n条记录和后面的n条记录，更容易得到一个移动平均值。你只需要在t之间改变range定义的RANGE参数。</p><p id="9fad" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该程序执行任务3中要求的基于组内订单的计算。将同一只股票的所有收盘价记录放在一个组中，这可以通过window函数实现。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="30af" class="mt ls it mp b gy mu mv l mw mx">SELECT code, day, price /<br/>    LAG(price,1)<br/>      OVER (<br/>        PARTITION BY code<br/>        ORDER BY day ASC<br/>      ) rate<br/>FROM tbl</span></pre><p id="7050" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">OVER函数中的PARTITION BY substatement定义了记录分组的方式，并限制了组中的每个LAG操作。比之前的JOIN方法更直观。JOIN方法按多个字段对记录进行排序，这相当于PARTITION BY，但很难理解。</p><h1 id="f179" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">按序列号排列的位置</h1><p id="cab5" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">它是一个相对位置，用来获取有序集合中相邻记录的值。有时，我们需要找到记录的绝对位置，因为计算每天的发行价和收盘价之间的差异需要:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="1316" class="mt ls it mp b gy mu mv l mw mx">SELECT day, price-FIRST_VALUE(price) OVER (ORDER BY day ASC) FROM tbl</span></pre><p id="b1cf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">或者计算第10个交易日的最高收盘价与每天收盘价之间的差额，需要:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="f91e" class="mt ls it mp b gy mu mv l mw mx">SELECT day, price-NTH_VALUE(price,10)OVER (ORDER BY day ASC) FROM tbl</span></pre><p id="fe22" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">还有更复杂的情况，其中用于定位记录的序列号是未知的，并且需要从现有值中生成:</p><p id="8763" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 4。有按收盘价排序的股票记录，我们想找到中间位置的价格(中位数)</strong></p><p id="27ac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们从简单的一只股票开始。记录按价格排序后，我们还是不知道中间的地方在哪里。所以我们需要根据记录的数量来计算中间位置的序号:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="b45f" class="mt ls it mp b gy mu mv l mw mx">SELECT *<br/>  FROM<br/>    SELECT day, price, ROW_NUMBER()OVER (ORDER BY day ASC) seq FROM tbl<br/>  WHERE seq=(<br/>    SELECT TRUNC((COUNT(*)+1)/2) middleSeq FROM tbl)</span></pre><p id="1053" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">FROM语句中的子查询使用ROW_NUMBER()为每一行生成一个序列号。WHERE语句中的另一个子查询获取中间位置的序列号。这个SQL查询中有两点值得您注意。一个是不能直接在第一个子查询上执行筛选，因为WHERE子句不能使用同级SELECT子句的计算字段。这是由SQL执行顺序决定的。另一个是WHERE子句中的子查询的结果是一个一列一行的表，表中有一个值。它可以被视为要与Seq进行比较的单个值。</p><p id="9676" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是获取多只股票记录的中位数的SQL程序:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="6e6b" class="mt ls it mp b gy mu mv l mw mx">SELECT *<br/>  FROM<br/>    (SELECT code, day, price,<br/>      ROW_NUMBER() OVER (PARTITION BY code ORDER BY day ASC)seq  FROM tbl) t1<br/>    WHERE seq=(<br/>      SELECT TRUNC((COUNT(*)+1)/2) middleSeq<br/>      FROM tbl t2<br/>      WHERE t1.code=t2.code)</span></pre><p id="9111" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">除了在窗口函数中用嵌入<strong class="kx iu">分区外，在计算中间位置的序号时，要确保查询条件是为一只股票设置的。</strong></p><p id="4e03" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 5。计算最高收盘价当天与前一天相比的涨幅</strong></p><p id="a115" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">需要两个排序操作来定位收盘价最高的记录。让我们从一只股票开始:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="fade" class="mt ls it mp b gy mu mv l mw mx">SELECT day, price, seq, rate<br/>  FROM (<br/>    SELECT day, price, seq,<br/>      price/LAG(price,1) OVER (ORDER BY day ASC) rate<br/>    FROM (<br/>      SELECT day, price,<br/>        ROW_NUMBER ()OVER (ORDER BY price DESC) seq<br/>      FROM tbl)<br/>    )<br/>  WHERE seq=1</span></pre><p id="79df" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">连续的两级子查询将有用的新数据添加到原始表中。ROW_NUMBER按升序排列收盘价。滞后函数计算每天的增长率。最后，我们通过过滤操作得到收盘价最高的那一天(seq=1)。</p><p id="fcb6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">过滤操作应该在计算增长率之后进行，因为如果过滤掉收盘价最高的前一天，就无法计算增长率。</p><h1 id="3bcc" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">基于订单的分组</h1><p id="9585" class="pw-post-body-paragraph kv kw it kx b ky mj ju la lb mk jx ld le ml lg lh li mm lk ll lm mn lo lp lq im bi translated">该顺序在执行分组时也很有用。这里有一个例子:</p><p id="c496" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> 6。求一只股票连续上涨的最大交易日数。</strong></p><p id="a681" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有点复杂。逻辑是这样的:通过将连续上升的股票记录放入同一组，将按日期排序的股票记录分成若干组。也就是说，如果一个记录的收盘价高于前一个记录的收盘价，那么就把它们归入同一组；如果一个记录的收盘价比前一个低，那么把它放入一个新的组。所有记录分组后，对每组中的记录进行计数，得到最大计数，这就是我们想要的结果。</p><p id="2d79" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这种类型的分组是根据记录的顺序执行的。因为SQL只支持等分组，所以它需要将基于顺序的分组转换为等分组。它是这样做的:</p><p id="3ff0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">1)按日期对记录进行排序，并为每个日期获取前一个日期的收盘价；</p><p id="b20f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下面是完成这项工作的完整SQL程序:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="bb98" class="mt ls it mp b gy mu mv l mw mx">SELECT MAX(ContinuousDays)<br/>  FROM (<br/>    SELECT COUNT(*) ContinuousDays<br/>    FROM (<br/>      SELECT SUM(RisingFlag) OVER (ORDER BY day) NoRisingDays<br/>      FROM (<br/>        SELECT day, CASE WHEN price&gt;<br/>           LAG(price) OVER (ORDER BY day) THEN 0 ELSE 1 END RisingFlag<br/>      FROM tbl<br/>      )<br/>    ) GROUP BY NoRisingDays<br/>  )</span></pre><p id="cc58" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个SQL解决方案包括4级子查询。与Java和C语言不同，SQL是基于集合的。它提供了直接在集合上工作的方法，而不需要显式可控的循环操作和临时中间变量。与直观的思维方式不同，SQL实现采用迂回的方式，使用标准的集合操作来获得结果。然而，Java或C语言通过循环处理每个记录更接近我们的自然思维方式。生成新组或向现有组追加数据是很直观的。但是它们不支持集合运算。从这个角度来看，SQL和Java/C各有利弊。</p><p id="1bac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">真实世界的计算场景可能比您想象的更复杂:</p><p id="5214" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">7 .<strong class="kx iu">。找出连续上涨3天的股票。</strong></p><p id="c820" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个场景需要基于顺序的分组、对分组后子集的操作、标准分组和HAVING子句。首先，我们使用前面查询任务中的实现方法获得每只股票的所有上涨组，用一个分组操作将其括起来，以计算连续上涨的最大天数，然后通过HAVING子句找到连续上涨3天的股票:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="7886" class="mt ls it mp b gy mu mv l mw mx">SELECT code, MAX(ContinuousDays)<br/>  FROM (<br/>    SELECT code, NoRisingDays, COUNT(*) ContinuousDays<br/>    FROM (<br/>      SELECT code,<br/>      SUM(RisingFlag) OVER (PARTITION BY code ORDER BY day) NoRisingDays<br/>      FROM (<br/>        SELECT code, day,<br/>          CASE WHEN price&gt;<br/>            LAG(price) OVER (PARTITION BY code ORDER BY day)<br/>          THEN 0 ELSE 1 END RisingFlag<br/>        FROM tbl<br/>      )<br/>    ) GROUP BY NoRisingDays<br/>  )<br/>  GROUP BY code<br/>  HAVING MAX(ContinuousDays)&gt;=3</span></pre><p id="3c8e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">SQL程序几乎难以理解。</p><p id="0ec3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在引入窗口函数之前，SQL在处理基于顺序的计算时非常笨拙(即使现在一些数据库仍然不支持窗口函数)。理论上，它可以管理所有的场景，但实际上所有的都不算什么，因为实现太复杂了。窗口函数极大地改善了SQL的困境，尽管它在处理复杂场景时仍然迂回曲折。</p><p id="e3da" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">SQL的问题根源于它的理论基础——基于无序集的关系代数。窗口函数是有用的，但不能解决根本问题。</p><p id="a38c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">实际上，计算语言中的数组(集合)是自然有序的(它们有自然的序列号)。用Java和C++这样的高级语言很容易理解和实现这个特性。问题是他们处理集合运算的能力很弱。这意味着它们也会产生冗长的程序来处理基于订单的计算(尽管逻辑并不复杂)。</p><p id="3cf9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">埃斯普罗克·SPL就是这样一位出色的选手。esProc是一个专业的数据计算引擎。它以有序集合为基础，为执行集合运算提供全面的功能。它继承了Java和SQL的优点。在SPL进行基于订单的计算非常容易，例如，SPL有自己简单的解决方案:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="68ea" class="mt ls it mp b gy mu mv l mw mx">1． T.sort(day).derive(price/price[-1]:rate)</span><span id="f5e6" class="mt ls it mp b gy my mv l mw mx">2． T.sort(day).derive(avg(price[-1:1]):movingAvg)</span><span id="5fc7" class="mt ls it mp b gy my mv l mw mx">3． T.sort(day).group(code).(~.derive(price/price[-1]:rate)).conj()</span><span id="b205" class="mt ls it mp b gy my mv l mw mx">4． T.sort(price).group(code).(~((~.len()+1)\2))</span><span id="919a" class="mt ls it mp b gy my mv l mw mx">5． T.sort(day).group(code).((p=~.pmax(price),~.calc(p,price/price[-1])))</span><span id="2cf3" class="mt ls it mp b gy my mv l mw mx">6． T.sort(day).group@o(price &gt;price[-1]).max(~.len()))</span><span id="65fc" class="mt ls it mp b gy my mv l mw mx">7． T.sort(day).group(code).select(~.group@o(price&gt;price[-1]).max(~.len())&gt;3).(code)</span></pre><p id="adfd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">SPL提供了实现跨行引用的语法，并为上述所有计算提供了坚实的支持。它使程序员能够以直观、简单和优雅的方式表达逻辑。</p></div></div>    
</body>
</html>