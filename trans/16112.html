<html>
<head>
<title>Timestamp parsing for time-series data analysis with Pandas and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Pandas和Python进行时间序列数据分析的时间戳解析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/timestamp-parsing-with-python-ec185536bcfc?source=collection_archive---------11-----------------------#2020-11-06">https://towardsdatascience.com/timestamp-parsing-with-python-ec185536bcfc?source=collection_archive---------11-----------------------#2020-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2b0d" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/90fa784378ea72f649cb6c6e84ae9a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VhOVa1MSVCi5DSqj"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">由<a class="ae kl" href="https://unsplash.com/@lukechesser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢克·切瑟</a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="km kn ko"><p id="bf24" class="kp kq kr ks b kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ks ja">TL；Pandas为解析时间戳格式提供了很大的灵活性。但是<strong class="ks ja">灵活性是以性能为代价的</strong>。在处理标准格式的时间戳时，这仍然是一个很好的解决方案。然而，当时间戳格式不标准时，像记忆和带有预建查找表的映射这样的技术可以比Pandas快<strong class="ks ja">几个数量级。跳至<a class="ae kl" href="#3f08" rel="noopener ugc nofollow">总结部分</a>了解不同条件下使用方法的建议。</strong></strong></p></blockquote></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="35a3" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">我们今天生成的许多数据都是时间序列数据的形式。并且对该数据的分析通常依赖于在一种结构中表示数据的时间戳，该结构服从于基于时间的切片和切割。在标准Python和流行的数据分析库中，如Numpy和Pandas，有专门的数据类型来存储基于时间的信息。但是，传入的时间戳通常是不同格式的字符串。并且将这些字符串解析成基于时间的数据类型是一个耗时且有时乏味的过程。</p><figure class="lz ma mb mc gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi ly"><img src="../Images/622b10a0b4050c0236da255356071044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q2ZhLAiETYQt1nVu3SpcOw.png"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">Pandas中时间相关数据的数据类型。图片来自pandas.pydata.org。</p></figure><p id="4729" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">在标准Python中，解析具有已知格式的时间戳字符串的常见方式是<strong class="ks ja"> time </strong>模块的<strong class="ks ja"> strptime </strong>方法(类似于C的<em class="kr"> strptime </em>的接口)。</p><p id="9506" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">然而，由于大多数数据科学家不得不在数据集上做比解析时间戳字符串更多的事情，像Pandas这样强大的库变得非常受欢迎。在Pandas中，解析时间戳字符串最常见的方式是<strong class="ks ja"> to_datetime </strong>方法。这种方法提供了很大的灵活性，甚至可以自动推断格式。所以很多人几乎是盲目的使用。</p><p id="615e" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">在本文中，我们将研究不同时间戳解析方法在不同类型数据集上的性能和适用性。我们就看什么时候盲目用熊猫，什么时候用别的了。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="1a6f" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">常用方法</h1><p id="2a0c" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">在这个分析中，我们将比较六种解析时间戳字符串集合的常用方法。</p><h2 id="950a" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">1.time.strptime</h2><p id="2a52" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">对于具有已知格式的时间戳字符串，Python的时间模块提供了这个方法来将字符串转换为Python Datetime对象。</p><p id="d5f5" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">示例:</p><figure class="lz ma mb mc gt ka"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="4b28" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">2.Pandas.to_datetime无需推断</h2><p id="056c" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">Pandas库中的这个方法可以转换时间戳字符串的集合，即使没有预先知道的格式。</p><p id="6c1e" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">示例:</p><figure class="lz ma mb mc gt ka"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1d9d" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">请注意时间戳字符串列表<strong class="ks ja"> ts_str_list </strong>如何具有不同格式的时间戳。Pandas自动推断出每个时间戳字符串的格式，然后进行转换。</p><h2 id="bae1" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">3.带推断的Pandas.to_datetime</h2><p id="8950" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">同样的to_datetime <strong class="ks ja"> </strong>方法在Pandas中有几个可选的参数。其中一个参数是<strong class="ks ja">推断日期时间格式</strong>。默认设置为<strong class="ks ja">假</strong>。然而，通过将其设置为<strong class="ks ja"> True </strong>，该方法推断集合中第一个时间戳字符串的格式，然后尝试使用该格式解析其余的字符串。如果推断出的格式与集合中的任何后续字符串都不匹配，则该方法会采用infer_datetime_format = False的行为。</p><p id="cd81" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">这种方法的优点是在解析具有一致格式的字符串集合时节省了大量时间。</p><p id="b297" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">示例:</p><figure class="lz ma mb mc gt ka"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="4666" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">4.具有指定格式参数的Pandas.to_datetime</h2><p id="e571" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">to_datetime方法接受的另一个参数是<strong class="ks ja">格式</strong>。类似于time.strptime，这让我们可以显式地定义一种格式来解析时间戳字符串的集合。正如我们将在后面看到的，这种方法的优点是它比让Pandas自己推断日期时间要快得多。然而，先决条件是时间戳字符串的集合具有一致且预先知道的格式。</p><p id="a01e" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">示例:</p><figure class="lz ma mb mc gt ka"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="2ec6" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">5.time.strptime带记忆</h2><p id="473b" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated"><a class="ae kl" href="https://www.interviewcake.com/concept/java/memoization" rel="noopener ugc nofollow" target="_blank">记忆</a>是一种存储操作结果的技术，这样就不需要重复操作。使用memos for the time.strptime方法可以确保在具有重复时间戳的数据集中，我们不会浪费时间多次解析同一个字符串。当然，在没有任何重复的数据集中，这种方法不会比plain time.strptime方法有优势。</p><p id="d2ae" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">示例:</p><figure class="lz ma mb mc gt ka"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="2bca" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">6.预建的查找映射</h2><p id="9bda" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">另一种解析已知格式和已知时间范围的长时间戳列表的方法是创建字符串到日期时间对象的映射。然后，我们可以使用Python的<strong class="ks ja"> map </strong>方法来获得对应于每个时间戳字符串的Datetime对象的列表。</p><p id="367e" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">示例:</p><figure class="lz ma mb mc gt ka"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="ae52" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">具有唯一时间戳的实验</h1><h2 id="c76f" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">1.标准格式的时间戳列表</h2><p id="3fa9" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/ISO_8601" rel="noopener ugc nofollow" target="_blank"> ISO-8601 </a>是一个被广泛接受的时间相关信息交换国际标准。除了遵循ISO-8601标准的时间戳之外，就Pandas而言，其他一些时间戳也是一种“标准”格式。这意味着熊猫可以非常有效地解析一些时间戳格式。没有一个详尽的列表(据我所知)，但是一般来说，包含日期所有部分的时间戳格式和以年份开始的格式似乎都属于这一类。</p><p id="ee26" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">现在，让我们看看当给定已知标准格式的时间戳时，这些方法是如何执行的。时间戳的格式在每个数据集中是一致的。我们用不同大小的数据集测试了适用方法的性能。</p><figure class="lz ma mb mc gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi nt"><img src="../Images/74d3e95d20293096a29ac7c2db9e1911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UrQlKxdK_8MuHiA3mg2jw.png"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">时间戳为标准格式时比较不同的方法|作者图片</p></figure><p id="1173" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">结果显示，在这种情况下，<strong class="ks ja"> Pandas.to_datetime </strong>明显优于time.strptime。预构建的查找方法也略微优于time.strptime方法。然而，它仍然远远达不到熊猫提供的性能。</p><h2 id="4a5e" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">2.非标准格式的时间戳列表</h2><p id="2ccc" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">现在，如果我们对具有非标准时间戳格式(例如13–11–2000 04:50:32)的数据集运行相同的测试，我们会看到一些差异。</p><figure class="lz ma mb mc gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi nt"><img src="../Images/9eef169933d213cc446395cc2f1d6e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BuvIeO7Qse7hMqfXjVc0g.png"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">时间戳为非标准格式时比较不同的方法|作者图片</p></figure><p id="7cd6" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">我们在这里注意到，具有指定格式的Pandas.to_datetime执行得最好，而普通的time.strptime循环排在第二位。预构建的查找方法花费太多时间来构建地图，因此其性能受到影响。没有infer选项的Pandas.to_datetime也需要很长时间，因为每个时间戳字符串都需要重复的格式推断。</p><p id="3e61" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">在Pandas.to_datetime with infer的结果中，我们也看到了一些奇怪的行为。我们看到，在数据集规模接近20000之前，它的表现异常出色。然后它以与Pandas.to_datetime相同的方式执行，而不使用infer。这是怎么回事？！</p><p id="9dbc" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">这种行为恰好是这些实验中使用的数据集的副作用，但它说明了一个重要的问题。这些实验中使用的数据集是一个时间戳列表，从2000年1月1日上午12:00开始，以1秒的间隔持续进行。使用的时间戳格式为<strong class="ks ja"> dd-mm-yyyy hh:MM:ss </strong>。因此，当Pandas试图推断列表中的第一个时间戳时，格式存在模糊性。这是因为时间戳字符串01–01–2000 00:01:00的格式可以是<strong class="ks ja"> dd-mm-yyyy hh:MM:ss </strong>或<strong class="ks ja"> mm-dd-yyyy hh:MM:ss </strong>！</p><p id="19aa" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">因此，当我们有一个以模糊时间戳开始但在列表末尾有明确时间戳的数据集时，Pandas可能会在到达列表末尾时意识到其推断是不正确的。然后，它会退回到为每个时间戳字符串单独推断日期时间格式的行为。这将导致操作的性能类似于infer_datetime_format = False时的情况。</p><h1 id="e129" class="md me iq bd mf mg nu mi mj mk nv mm mn mo nw mq mr ms nx mu mv mw ny my mz na bi translated">重复数据集上的实验</h1><p id="dfd0" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">迄今为止使用的数据集没有重复的。然而，在现实世界中，我们经常处理具有重复时间戳的数据集或来自同一时间段的多个数据集。在工业智能领域(我目前在其中工作)，同时处理来自同一时间范围的大量数据集并不少见，因此，在所有这些数据集之间存在大量重复的时间戳字符串。</p><p id="27af" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">在下面的实验中，我们将看到我们对时间戳解析的选择会如何根据我们的数据集中有多少重复而改变。</p><p id="91c0" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">在接下来的实验中，所有数据集都包含一百万个时间戳字符串。在测试过程中，不同数量的副本被注入每个数据集，同时保持数据集大小固定。注入的最低重复数是0(都是唯一的)，最高重复数是100(数据集中的每个时间戳有99个其他副本)。</p><h2 id="1a89" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">尝试使用标准格式的时间戳字符串(并且在整个数据集中保持一致)</h2><figure class="lz ma mb mc gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi nt"><img src="../Images/bbbb002eab68a93b604e2fa7257ed3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcRkvVBaTUwZukYbGOA7LQ.png"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">当时间戳格式为标准|图片由作者提供时，无论有无重复，熊猫都表现良好</p></figure><p id="66db" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">我们在这里看到，在处理标准格式时，Pandas.to_datetime是一个简单的选择。正如所料，随着数据集中重复项数量的增加，内存化和预构建的查找映射会得到改善。</p><h2 id="ee80" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">尝试使用非标准格式的时间戳字符串(并且在整个数据集中保持一致)</h2><figure class="lz ma mb mc gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi nt"><img src="../Images/5e8743561e17cb6de9e7fea5654d1f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DLJYC1V-QloqDhKMoFqLQQ.png"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">当时间戳格式不标准时，记忆和预建查找的性能优于Pandas图片由作者提供</p></figure><p id="7589" class="pw-post-body-paragraph kp kq iq ks b kt ku kv kw kx ky kz la lv lc ld le lw lg lh li lx lk ll lm ln ij bi translated">但是当时间戳的格式不标准并且数据集中有一些重复时，记忆和预建的查找映射都表现得更好。事实上，我最近使用了预先构建的查找映射方法来解析大量时间戳字符串，这为我节省了8个多小时！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="3f08" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">摘要</h1><h2 id="2b37" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">对于没有太多重复的数据:</h2><ol class=""><li id="c368" class="nz oa iq ks b kt nb kx nc lv ob lw oc lx od ln oe of og oh bi translated"><strong class="ks ja">已知格式一致的时间戳<br/> </strong>使用熊猫并指定格式。</li><li id="eab3" class="nz oa iq ks b kt oi kx oj lv ok lw ol lx om ln oe of og oh bi translated"><strong class="ks ja">具有一致但未知格式的时间戳</strong> <br/>使用熊猫infer_datetime_format = True。</li><li id="b18d" class="nz oa iq ks b kt oi kx oj lv ok lw ol lx om ln oe of og oh bi translated"><strong class="ks ja">没有一致格式的时间戳<br/> </strong>使用Pandas with infer _ datetime _ format = False。</li></ol><h2 id="8348" class="ng me iq bd mf nh ni dn mj nj nk dp mn lv nl nm mr lw nn no mv lx np nq mz iw bi translated">对于有大量重复的数据:</h2><p id="45b5" class="pw-post-body-paragraph kp kq iq ks b kt nb kv kw kx nc kz la lv nd ld le lw ne lh li lx nf ll lm ln ij bi translated">对于有重复的数据，时间戳的格式很重要。因此，这里有一个方便的表格来帮助你选择。</p><figure class="lz ma mb mc gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi on"><img src="../Images/fd19993961f54d986c78cf9ebfa5807c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PgYB_3venEs9IgKte_-VQ.png"/></div></div><p class="kh ki gj gh gi kj kk bd b be z dk translated">在不同条件下解析时间戳字符串的推荐方法|作者图片</p></figure></div></div>    
</body>
</html>