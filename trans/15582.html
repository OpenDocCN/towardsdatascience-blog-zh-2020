<html>
<head>
<title>How to Make Inserts Into SQL Server 100x faster with Pyodbc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Pyodbc将SQL Server的插入速度提高100倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-made-inserts-into-sql-server-100x-faster-with-pyodbc-5a0b5afdba5?source=collection_archive---------2-----------------------#2020-10-27">https://towardsdatascience.com/how-i-made-inserts-into-sql-server-100x-faster-with-pyodbc-5a0b5afdba5?source=collection_archive---------2-----------------------#2020-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f525" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何修复向SQL Server加载数据时与“fast_executemany”相关的问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc313fedc9a29e90d944eff648d01c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0RgLCxncKWL84imKL_7wg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@nextvoyage?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Nextvoyage </a>从<a class="ae ky" href="https://www.pexels.com/photo/twisted-building-during-nighttime-1470405/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</p></figure><p id="74ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近一直在尝试用Python将大型数据集加载到SQL Server数据库中。通常，为了用<code class="fe lv lw lx ly b">pyodbc</code>加速插入，我倾向于使用显著加速插入的特性<code class="fe lv lw lx ly b">cursor.fast_executemany = True</code>。然而，今天我经历了一个奇怪的错误，并开始深入研究<code class="fe lv lw lx ly b">fast_executemany</code>到底是如何工作的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3e37" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我的数据框架和SQL Server表的架构</h1><p id="f840" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我试图将我的数据加载到SQL Server中时，我得到了错误:<em class="nd">“将数据类型varchar转换为numeric时出错。”</em></p><p id="40bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个错误让我非常困惑，因为我的Pandas数据帧的数据类型与SQL Server表中定义的数据类型完全匹配。特别是，我试图加载的数据是一个带有时间戳和度量列+一些元数据列的时间序列。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="abc9" class="ni mh it ly b gy nj nk l nl nm"><em class="nd">My dataframe schema:<br/>summertime     bool<br/>time           datetime64[ns]<br/>unique_id      object<br/>measurement    float64<br/>entered        datetime64[ns]<br/>updated        datetime64[ns]</em></span></pre><p id="89b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> SQL Server表</strong>有一个与此类似的模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/558d395fffb57623519476a8bca53841.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*1x6fNu3UnWV0P83vM37RqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SQL server表的架构</p></figure><p id="4906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看看数据类型，它们完全匹配。</p><h1 id="bbc9" class="mg mh it bd mi mj no ml mm mn np mp mq jz nq ka ms kc nr kd mu kf ns kg mw mx bi translated">"将数据类型varchar转换为数字时出错"</h1><p id="2f62" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了将这些数据快速加载到SQL Server数据库中，我使用<code class="fe lv lw lx ly b">df.values.tolist()</code>将Pandas数据帧转换为一个列表列表。为了将我的数据接收到数据库实例中，我创建了:</p><ul class=""><li id="85fd" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">SQL Server数据库实例的连接对象</li><li id="8f67" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">光标对象(<em class="nd">来自连接对象</em></li><li id="e779" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">和<code class="fe lv lw lx ly b">INSERT INTO</code>声明。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="026c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在第14行，我们使用了<code class="fe lv lw lx ly b">cursor.fast_executemany = True</code>特性。执行脚本时，我得到了以下错误(<em class="nd">带版本:</em> <code class="fe lv lw lx ly b"><em class="nd">pyodbc==4.0.23</em></code>):</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="4e5b" class="ni mh it ly b gy nj nk l nl nm">ProgrammingError: [Microsoft][ODBC Driver 17 for SQL Server][SQL Server] Error converting data type varchar to numeric. (SQLExecute)</span></pre><p id="28ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">为什么</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">pyodbc</strong></code> <strong class="lb iu">要把</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">varchar</strong></code> <strong class="lb iu">的东西转换成</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">numeric</strong></code> <strong class="lb iu">？！当我注释掉第14行以便在没有<code class="fe lv lw lx ly b">fast_executemany</code>特性的情况下使用<code class="fe lv lw lx ly b">cursor.executemany()</code>时，脚本运行得很好！我能够毫无问题地插入我的数据。</strong></p><p id="89eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的问题是没有<code class="fe lv lw lx ly b">fast_executemany</code>，很慢。</p><h1 id="da47" class="mg mh it bd mi mj no ml mm mn np mp mq jz nq ka ms kc nr kd mu kf ns kg mw mx bi translated"><code class="fe lv lw lx ly b">fast_executemany"</code>深入挖掘</h1><p id="cef9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">根据Pyodbc Wiki [1]:</p><blockquote class="oj ok ol"><p id="3bee" class="kz la nd lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fast_executemany</code>可以通过大大减少到服务器的往返次数来提高<code class="fe lv lw lx ly b">executemany</code>操作的性能。</p></blockquote><p id="1f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我想解决这个问题的主要原因。根据来自<code class="fe lv lw lx ly b">pyodbc</code>库[2]的Github问题，<code class="fe lv lw lx ly b">pyodbc</code>内部<strong class="lb iu">将所有十进制值作为字符串</strong>传递，因为一些<strong class="lb iu">差异和与各种数据库驱动程序</strong>使用的小数点相关的错误。这意味着当我的数据具有值<code class="fe lv lw lx ly b">0.021527</code>或<code class="fe lv lw lx ly b">0.02</code>时，这两个值可能都不被接受，因为我的SQL Server数据类型被指定为<code class="fe lv lw lx ly b">NUMERIC(18,3)</code>。另外，<code class="fe lv lw lx ly b">pyodbc</code>需要字符串而不是浮点，所以正确的值应该是<code class="fe lv lw lx ly b">'0.021'</code>，也就是说，字符串(<em class="nd">不是浮点！</em>)逗号后面正好有三个数字。</p><p id="e930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我的解决方案可以归结为增加这一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="82b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行只是将浮点数转换成字符串，用三个小数点表示数字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/77dc3d56d7cc48602cfbecacaabdb760.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*Mg9xyIGtRAEPQKVhABKqvA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对我来说，使用“fast_executemany”和floats是一个“奇怪”的解决方案</p></figure><h1 id="7598" class="mg mh it bd mi mj no ml mm mn np mp mq jz nq ka ms kc nr kd mu kf ns kg mw mx bi translated">修复“fast_executemany”的好处</h1><p id="f874" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在修复了这个问题之后，该脚本的运行速度比不使用第14行(<code class="fe lv lw lx ly b">cursor.fast_executemany = True</code>)时快了100倍。请注意，它之所以如此之快，是因为它在将数据加载到SQL Server之前将整个数据加载到内存中，所以如果您遇到内存不足错误，请考虑分块加载<em class="nd">。</em></p><h1 id="261a" class="mg mh it bd mi mj no ml mm mn np mp mq jz nq ka ms kc nr kd mu kf ns kg mw mx bi translated">结论</h1><p id="ea39" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">总之，通过将我的float列转换为与SQL Server表中定义的小数点数字完全相同的string，我能够修复<em class="nd">“将数据类型varchar转换为numeric”</em>的错误。令我颇感意外的是，<code class="fe lv lw lx ly b">pyodbc</code>并没有在引擎盖下处理这个问题(<em class="nd">，或者可能在最近的Pyodbc版本中已经解决了？</em>)。</p><p id="d7d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得有用，请关注我，不要错过我的下一篇文章。</p><p id="8ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">资源:</strong></p><p id="c495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]<a class="ae ky" href="https://github.com/mkleehammer/pyodbc/wiki/Features-beyond-the-DB-API" rel="noopener ugc nofollow" target="_blank">https://github . com/mkleehammer/pyo DBC/wiki/Features-beyond-the-d b-API</a></p><p id="2cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/mkleehammer/pyodbc/issues/388" rel="noopener ugc nofollow" target="_blank">https://github.com/mkleehammer/pyodbc/issues/388</a></p></div></div>    
</body>
</html>