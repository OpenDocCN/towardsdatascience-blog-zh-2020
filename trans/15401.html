<html>
<head>
<title>Getting Started with PyPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyPy入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-pypy-ef4ba5cb431c?source=collection_archive---------8-----------------------#2020-10-23">https://towardsdatascience.com/getting-started-with-pypy-ef4ba5cb431c?source=collection_archive---------8-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1188" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用PyPy启动并运行，PyPy是使用JIT编译的CPython的替代方案。</h2></div><p id="12ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python编程语言是一种可以用多种方式实现的接口。一些例子包括使用C语言的CPython，使用Java实现的Jython等等。</p><p id="3dfc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管是最流行的，CPython并不是最快的。PyPy是另一种Python实现，既兼容又快速。PyPy依赖于实时(JIT)编译，这大大减少了长时间运行操作的执行时间。</p><p id="e57d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，将为初学者介绍PyPy，以突出它与CPython的不同之处。我们还将讨论它的优点和局限性。然后我们将看看如何下载并使用PyPy来执行一个简单的Python脚本。PyPy支持数百个Python库，包括<a class="ae lb" href="https://blog.paperspace.com/numpy-optimization-vectorization-and-broadcasting/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>。</p><p id="ffba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具体来说，本教程涵盖以下内容:</p><ul class=""><li id="2de0" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">CPython的快速概述</li><li id="1af4" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">PyPy及其特性介绍</li><li id="f027" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">PyPy限制</li><li id="2857" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">在Ubuntu上运行PyPy</li><li id="cf42" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">PyPy与CPython的执行时间</li></ul><p id="ef96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始吧。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/29e38ebb9ed3867db261ccc102fba581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhR0GNM_wrfEawQ4HfU2ZQ.jpeg"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">由https://unsplash.com/photos/95YRwf6CNw8<a class="ae lb" href="https://unsplash.com/@clemhlrdt" rel="noopener ugc nofollow" target="_blank">克莱门特H </a> : <a class="ae lb" href="https://unsplash.com/photos/95YRwf6CNw8" rel="noopener ugc nofollow" target="_blank">改编自Unsplash</a></p></figure><h1 id="7a6f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">CPython的快速概述</h1><p id="6be9" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">在讨论PyPy之前，了解CPython的工作原理是很重要的。我上一篇名为<a class="ae lb" href="https://blog.paperspace.com/boosting-python-scripts-cython" rel="noopener ugc nofollow" target="_blank">用Cython </a>提升Python脚本的教程详细介绍了CPython的工作原理，但是在这里快速回顾一下要点也无妨。下面你可以看到一个使用CPython实现的Python脚本的执行管道的可视化。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nd"><img src="../Images/fcd47e50a4f60a3f28188d6ad335dda3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpX4R0POawYkM1Pt5fWg8A.png"/></div></div></figure><p id="3e33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定一个Python <code class="fe ne nf ng nh b">.py</code>脚本，首先使用CPython编译器将源代码编译成字节码。字节码被生成并保存在扩展名为<code class="fe ne nf ng nh b">.pyc</code>的文件中。然后在虚拟环境中使用CPython解释器执行字节码。</p><p id="014a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用编译器将源代码转换成字节码有很多好处。如果不使用编译器，那么解释器将通过逐行翻译成机器码来直接处理源代码。这样做的缺点是必须应用一些过程来将源代码的每一行翻译成机器代码，并且这些过程将对每一行重复。例如，语法分析将独立于其他行应用于每一行，因此解释器需要花费大量时间来翻译代码。编译器解决了这个问题，因为它能够一次处理所有代码，因此语法分析将只应用一次，而不是应用于每一行代码。因此，编译器生成的字节码很容易解释。注意，编译整个源代码在某些情况下可能没有帮助，我们将在讨论PyPy时看到一个明显的例子。</p><p id="612f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字节码生成后，由运行在虚拟机上的解释器执行。虚拟环境是有益的，因为它将CPython字节码与机器隔离开来，从而使Python跨平台。</p><p id="f45c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，仅仅使用编译器来生成字节码不足以加速CPython的执行。解释器的工作原理是每次执行代码时，将代码翻译成机器代码。因此，如果一个行<code class="fe ne nf ng nh b">L</code>需要<code class="fe ne nf ng nh b">X</code>秒来执行，那么执行它10次将会有<code class="fe ne nf ng nh b">X*10</code>秒的开销。对于长时间运行的操作，这在执行时间上代价太高。</p><p id="f17c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于CPython的弊端，我们现在来看看PyPy。</p><h1 id="f9cd" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">PyPy及其特性介绍</h1><p id="b55e" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">PyPy是一个类似于CPython的Python实现，既兼容又快速。“兼容”意味着PyPy与CPython兼容，因为您可以在PyPy中使用几乎所有的CPython语法。有一些兼容性的差异，如<a class="ae lb" href="https://pypy.org/compat.html" rel="noopener ugc nofollow" target="_blank">这里提到的</a>。PyPy最强大的优势就是速度。PyPy比CPython快很多；稍后我们将看到PyPy执行速度快7倍的测试。在某些情况下，它甚至可能比CPython快几十倍或几百倍。那么PyPy是如何实现它的速度的呢？</p><h1 id="db76" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">速度</h1><p id="2da7" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">PyPy使用实时(JIT)编译器，能够显著提高Python脚本的速度。CPython中使用的编译类型是超前的(AOT)，这意味着所有的代码在执行之前都会被转换成字节码。JIT只是在运行时翻译代码，只是在需要的时候。</p><p id="0d72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">源代码可能包含根本不执行的代码块，但这些代码块仍在使用AOT编译器进行翻译。这导致处理时间变慢。当源代码很大并且包含数千行时，使用JIT会有很大的不同。对AOT来说，整个源代码都需要翻译，因此需要很多时间。对于JIT，只执行代码中需要的部分，这样速度会快很多。</p><p id="6650" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyPy翻译了一部分代码后，就会被缓存。这意味着代码只被翻译一次，以后再使用。每次执行代码时，CPython解释器都要重复翻译，这也是它运行缓慢的另一个原因。</p><h1 id="003a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">容易的</h1><p id="061c" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">PyPy不是提升Python脚本性能的唯一方法，但却是最简单的方法。例如，Cython可以用来提高向变量分配C类型的速度。问题是Cython要求开发人员手动检查源代码并进行优化。这很烦人，而且随着代码大小的增加，复杂性也在增加。当使用PyPy时，您只需更快地运行常规Python代码，无需任何努力。</p><h1 id="68fe" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">无栈</h1><p id="fef2" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">标准Python使用C栈。这个堆栈存储相互调用的函数序列(递归)。因为堆栈的大小是有限的，所以函数调用的次数也是有限的。</p><p id="92a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyPy使用了<a class="ae lb" href="https://wiki.python.org/moin/StacklessPython" rel="noopener ugc nofollow" target="_blank">无栈Python </a>，这是一个<strong class="kh ir">不使用C栈</strong>的Python实现。相反，它将函数调用存储在对象旁边的堆中。堆的大小大于栈的大小，因此你可以做更多的函数调用。</p><p id="0151" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无栈Python也支持微线程，比普通的Python线程要好。在单个无堆栈Python线程中，您可以运行数千个任务，称为“小任务”，所有这些任务都在同一个线程上运行。</p><p id="44e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用微线程允许运行并发任务。并发意味着两个任务通过共享相同的资源同时工作。一个任务运行一段时间，然后停下来为第二个任务腾出空间。请注意，这与并行不同，并行涉及同时单独运行两个任务。</p><p id="3781" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用微线程减少了创建的线程数量，从而减少了操作系统管理所有这些线程的开销。因此，通过在两个线程之间交换来加速执行比在两个微线程之间交换更耗时。</p><p id="ce34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用无堆栈Python也为实现延续打开了大门。延续允许我们保存任务的状态，并在以后恢复它以继续它的工作。注意，无栈Python与标准Python没有什么不同；它只是增加了更多的功能。标准Python中可用的一切也将在无堆栈Python中可用。</p><p id="0fc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在讨论了PyPy的好处之后，我们在下一节讨论它的局限性。</p><h1 id="7740" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">PyPy限制</h1><p id="44e0" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">虽然您可以在任何机器和任何CPU架构上使用CPython，但是PyPy的支持相对有限。</p><p id="f1a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是PyPy ( <a class="ae lb" href="https://pypy.org/features.html" rel="noopener ugc nofollow" target="_blank">来源</a>)支持和维护的CPU架构:</p><ul class=""><li id="66ad" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">x86 (IA-32)和x86_64</li><li id="1af8" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">ARM平台(ARMv6或ARMv7，带VFPv3)</li><li id="6626" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">AArch64</li><li id="a0fd" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">PowerPC 64位，小端和大端</li><li id="ab30" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">系统Z (s390x)</li></ul><p id="1235" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyPy不能在所有的Linux发行版上工作，所以你必须小心使用一个受支持的版本。在不受支持的发行版上运行PyPy Linux二进制文件将会返回错误。PyPy只支持Python 2和Python 3的一个版本，分别是PyPy 2.7和PyPy 3.6。</p><p id="c6e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在PyPy中执行的代码是纯Python，那么PyPy提供的速度通常是显而易见的。但是如果代码包含C扩展，比如NumPy，那么PyPy实际上可能会增加时间。PyPy项目正在积极开发中，因此将来可能会为C扩展提供更好的支持。</p><p id="72bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多流行的Python框架都不支持PyPy，比如Kivy。Kivy允许CPython在所有平台上运行，包括Android和iOS。这意味着PyPy不能在移动设备上运行。</p><p id="06a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经看到了PyPy的优点和局限性，让我们来看看如何在Ubuntu上运行PyPy。</p><h1 id="653d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">在Ubuntu上运行PyPy</h1><p id="1b0f" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">您可以在Mac、Linux或Windows上运行PyPy，但是我们将讨论在Ubuntu上运行它。再次提及PyPy Linux二进制文件仅在特定的Linux发行版上受支持是非常重要的。您可以在<a class="ae lb" href="https://pypy.org/download.html" rel="noopener ugc nofollow" target="_blank">这个页面</a>上查看可用的PyPy二进制文件及其支持的发行版。例如，PyPy(Python 2.7或Python 3.6)仅支持Ubuntu的三个版本:18.04、16.04和14.04。如果你有最新版本的Ubuntu(19.10)，那么你不能在上面运行PyPy。尝试在不受支持的发行版上运行PyPy将返回以下错误:</p><p id="9439" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ne nf ng nh b">pypy: error while loading shared libraries ...</code></p><p id="24e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我只是简单的用一个虚拟机运行Ubuntu 18.04。</p><p id="e195" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyPy二进制文件以压缩文件的形式出现。你需要做的就是解压你下载的文件。在解压缩的目录中有一个名为<code class="fe ne nf ng nh b">bin</code>的文件夹，在其中可以找到PyPy可执行文件。我使用的是Python 3.6，因此这个文件被命名为<code class="fe ne nf ng nh b">pypy3</code>。对于Python 2.7，只是叫<code class="fe ne nf ng nh b">pypy</code>。</p><p id="59b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于CPython，如果想从终端运行Python 3，只需输入命令<code class="fe ne nf ng nh b">python3</code>。要运行PyPy，只需发出命令<code class="fe ne nf ng nh b">pypy3</code>。</p><p id="fa1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在终端中输入<code class="fe ne nf ng nh b">pypy3</code>命令可能会返回<code class="fe ne nf ng nh b">Command 'pypy3' not found</code>消息，如下图所示。原因是PyPy的路径没有添加到path环境变量中。实际运行的命令是<code class="fe ne nf ng nh b">./pypy3</code>，考虑到终端的当前路径在PyPy的<code class="fe ne nf ng nh b">bin</code>目录中。点<code class="fe ne nf ng nh b">.</code>表示当前目录，添加<code class="fe ne nf ng nh b">/</code>是为了访问当前目录中的内容。发出<code class="fe ne nf ng nh b">./pypy3</code>命令成功运行Python，如下所示。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ni"><img src="../Images/c5f8890e5afa5d01a4bf8da7200edf97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zvsstXfViirkuAjRHlt9w.png"/></div></div></figure><p id="cfcf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以像往常一样使用Python，充分利用PyPy的优势。例如，我们可以创建一个简单的Python脚本，对1，000个数字求和，并使用PyPy执行它。代码如下。</p><pre class="lr ls lt lu gt nj nh nk nl aw nm bi"><span id="3e65" class="nn mh iq nh b gy no np l nq nr">nums = range(1000) <br/>sum = 0 <br/>for k in nums:<br/>    sum = sum + k<br/>print("Sum of 1,000 numbers is : ", sum)</span></pre><p id="163d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这个脚本被命名为<code class="fe ne nf ng nh b">test.py</code>，那么您可以简单地使用下面的命令运行它(假设Python文件位于PyPy的<code class="fe ne nf ng nh b">bin</code>文件夹中，这与<code class="fe ne nf ng nh b">pypy3</code>命令的位置相同)。</p><pre class="lr ls lt lu gt nj nh nk nl aw nm bi"><span id="4310" class="nn mh iq nh b gy no np l nq nr">./pypy3 test.py</span></pre><p id="cdc2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图显示了执行前面代码的结果。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ns"><img src="../Images/5dcfaab6f7ff14840d46cde22f2008f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUGVamf7hz5YPwVxKxbDWQ.png"/></div></div></figure><h1 id="9a19" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">PyPy与CPython的执行时间</h1><p id="939d" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">为了比较PyPy和CPython对1，000个数字求和的运行时间，代码被更改为测量时间，如下所示。</p><pre class="lr ls lt lu gt nj nh nk nl aw nm bi"><span id="500a" class="nn mh iq nh b gy no np l nq nr">import time</span><span id="220d" class="nn mh iq nh b gy nt np l nq nr">t1 = time.time()<br/>nums = range(1000)<br/>sum = 0<br/>for k in nums:<br/>    sum = sum + k<br/>print("Sum of 1,000 numbers is : ", sum)<br/>t2 = time.time()<br/>t = t2 - t1<br/>print("Elapsed time is : ", t, " seconds")</span></pre><p id="11a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与CPython的<code class="fe ne nf ng nh b">0.0002</code>秒相比，PyPy的时间接近<code class="fe ne nf ng nh b">0.00045</code>秒(我在我的Core i7-6500U机器上运行代码@ 2.5GHz)。在这种情况下，与PyPy相比，CPython花费的时间更少，这是意料之中的，因为这个任务实际上不是一个长时间运行的任务。如果代码改为添加100万个数字，而不是1000个，那么PyPy将最终获胜。在这种情况下，Pypy需要<code class="fe ne nf ng nh b">0.00035</code>秒，CPython需要<code class="fe ne nf ng nh b">0.1</code>秒。PyPy的好处现在很明显。这应该让您了解CPython在执行长时间运行的任务时会慢多少。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="8234" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">本文原载于</strong> <a class="ae lb" href="https://blog.paperspace.com/getting-started-with-pypy" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> Paperspace博客</strong> </a> <strong class="kh ir">。你可以在渐变</strong>  <strong class="kh ir">上免费运行我的教程</strong> <a class="ae lb" href="https://gradient.paperspace.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">的代码。</strong></a></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="a566" class="mg mh iq bd mi mj ob ml mm mn oc mp mq jw od jx ms jz oe ka mu kc of kd mw mx bi translated">结论</h1><p id="3615" class="pw-post-body-paragraph kf kg iq kh b ki my jr kk kl mz ju kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">本教程介绍了PyPy，这是最快的Python实现。PyPy的主要优点是它的实时(JIT)编译，它提供了对编译后的机器码的缓存以避免再次执行。PyPy的局限性也得到了强调，主要的一点是它对于纯Python代码来说工作得很好，但是对于C扩展来说效率不高。</p><p id="2268" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还看到了如何在Ubuntu上运行PyPy，并比较了CPython和PyPy的运行时间，突出了PyPy对于长时间运行任务的效率。与此同时，对于短期运行的任务，CPython仍可能击败PyPy。在以后的文章中，我们将探索PyPy、CPython和Cython之间的更多比较。</p></div></div>    
</body>
</html>