<html>
<head>
<title>How To Prepare Your Data For Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为机器学习准备数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-prepare-your-data-for-machine-learning-307cc556af48?source=collection_archive---------31-----------------------#2020-10-01">https://towardsdatascience.com/how-to-prepare-your-data-for-machine-learning-307cc556af48?source=collection_archive---------31-----------------------#2020-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ff6f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">预测泰坦尼克号上的幸存者</h2></div><p id="8fe1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="le">TL；博士</em> </strong>:这篇文章涵盖了泰坦尼克号沉船数据集的完整准备。</p><p id="1d5e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本帖是本书的一部分:<a class="ae lf" href="https://www.pyqml.com/page?ref=medium_prepare&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">用Python动手做量子机器学习</strong> </a></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/e6dc3fdc46f9b8917c02787cb4a0c014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGPgchrYsgkPKACplsZiyQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">作者弗兰克·齐克特的图片</p></figure><p id="e1ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">泰坦尼克号的沉没是历史上最臭名昭著的海难之一。</p><p id="8d79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1912年4月15日，泰坦尼克号与冰山相撞后沉没。被认为是不沉的，没有足够的救生艇给船上的每个人。当晚2224名乘客和机组人员中有1502人死亡。</p><p id="6740" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，722名幸存者一定有一些运气。但是似乎某些人群比其他人群有更好的生存机会。</p><p id="ad81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，泰坦尼克号的沉没也成为任何对机器学习感兴趣的人的著名起点。</p><p id="811c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有一些机器学习的经验，你可能会知道Kaggle提供的传说中的泰坦尼克号ML比赛。</p><p id="5f26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你还不知道Kaggle，Kaggle是世界上最大的数据科学社区之一。它提供了许多有趣的数据集，因此，它是一个开始的好地方。</p><p id="a0ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要解决的问题很简单。使用机器学习创建一个模型，根据乘客数据，预测哪些乘客在泰坦尼克号沉船中幸存。</p><h1 id="f31c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">获取数据集</h1><p id="6957" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">为了获得数据集，你需要创建一个Kaggle帐户(它是免费的)并加入竞争。即使Kaggle完全是关于竞争的，你也不需要通过上传你的解决方案来积极参与其中。</p><p id="6781" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你参加比赛时，你需要接受并遵守规则，这些规则规定了你每天可以提交多少份作品，最大团队规模，以及其他比赛的具体细节。</p><p id="9836" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在竞赛页面顶部的<a class="ae lf" href="https://www.kaggle.com/c/titanic/data" rel="noopener ugc nofollow" target="_blank">数据选项卡</a>中找到竞赛数据。然后，向下滚动以找到文件列表。</p><p id="9ce3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据中有三个文件:</p><ul class=""><li id="eac6" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated"><code class="fe nc nd ne nf b">train.csv</code></li><li id="fe16" class="mt mu it kk b kl ng ko nh kr ni kv nj kz nk ld my mz na nb bi translated"><code class="fe nc nd ne nf b">test.csv</code></li><li id="4688" class="mt mu it kk b kl ng ko nh kr ni kv nj kz nk ld my mz na nb bi translated"><code class="fe nc nd ne nf b">gender_submission.csv</code></li></ul><p id="c8d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文件<code class="fe nc nd ne nf b">train.csv</code>包含泰坦尼克号乘客子集的数据。这个文件应该作为你的算法的基础，以了解一名乘客是否幸存。</p><p id="ce1d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文件<code class="fe nc nd ne nf b">test.csv</code>包含另一个乘客子集的数据。它决定了你的算法执行的有多好。</p><p id="858c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">gender_submission.csv</code>文件是一个例子，它展示了如果您打算将预测提交给Kaggle，您应该如何构建预测。因为我们在这里开始学习，还没有准备好竞争，我们将跳过这个文件。</p><p id="8684" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下载文件<code class="fe nc nd ne nf b">train.csv</code>和<code class="fe nc nd ne nf b">test.csv</code>。</p><h1 id="357b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">看数据</h1><p id="7512" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们需要做的第一件事是加载数据。我们用熊猫来表示。它在机器学习社区中以数据处理而闻名。它提供了各种有用的功能，比如加载<code class="fe nc nd ne nf b">.csv</code>-文件的功能:<code class="fe nc nd ne nf b">read_csv</code>。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">从csv文件加载数据</p></figure><p id="6c17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将数据加载到<code class="fe nc nd ne nf b">train</code>和<code class="fe nc nd ne nf b">test</code>中。这些是熊猫。</p><p id="c37c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">A <code class="fe nc nd ne nf b">DataFrame</code>将数据保存在带有标签的二维结构中。例如数据库表或电子表格。它提供了许多现成的有用属性和功能。</p><p id="1020" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，<code class="fe nc nd ne nf b">DataFrame</code>的属性<code class="fe nc nd ne nf b">shape</code>提供了一个由两个整数组成的元组，表示行数和列数。</p><p id="df50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">泰坦尼克号数据集的形状</p></figure><pre class="lh li lj lk gt nn nf no np aw nq bi"><span id="135d" class="nr lx it nf b gy ns nt l nu nv">train has 891 rows and 12 columns<br/>test has 418 rows and 11 columns</span></pre><p id="8eef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到我们有891个培训和418个测试条目。更有趣的是，<code class="fe nc nd ne nf b">train</code>数据集比<code class="fe nc nd ne nf b">test</code>数据集多一列。</p><p id="a536" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">DataFrame</code>的<code class="fe nc nd ne nf b">info()</code>方法显示了一些更详细的信息。看一下<code class="fe nc nd ne nf b">train</code>数据集。</p><pre class="lh li lj lk gt nn nf no np aw nq bi"><span id="6465" class="nr lx it nf b gy ns nt l nu nv">train.info()</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nw"><img src="../Images/4855a2a484f9802e8c5bf83388a353d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*auShnrewk9iumVSsJv8rsA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">训练数据集的结构</p></figure><p id="736f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">info</code>方法返回列的列表:它们的索引、名称、有多少条目有实际值(不是<code class="fe nc nd ne nf b">null</code>)以及值的类型。</p><p id="319e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们也来看看<code class="fe nc nd ne nf b">test</code>数据集。</p><pre class="lh li lj lk gt nn nf no np aw nq bi"><span id="0ecc" class="nr lx it nf b gy ns nt l nu nv">test.info()</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nw"><img src="../Images/a70777cc458e3575e6718514dccc8f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEyN4qHc7x_heqySusxY2w.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">测试数据集的结构</p></figure><p id="b67d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当比较这两个信息时，我们可以看到<code class="fe nc nd ne nf b">test</code>数据集遗漏了列<code class="fe nc nd ne nf b">Survived</code>，该列指示一名乘客是幸存还是死亡。</p><p id="2c93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如Kaggle指出的，他们使用<code class="fe nc nd ne nf b">test</code>数据集来评估提交的内容。如果他们提供了正确的答案，那就不再是什么竞赛了，不是吗？我们的任务是预测正确的标签。</p><p id="f3f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们不打算将我们的预测提交给Kaggle，以获得对我们算法执行情况的评估，<code class="fe nc nd ne nf b">test</code>数据集对我们来说毫无用处。</p><p id="08aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们专注于<code class="fe nc nd ne nf b">train</code>数据集。</p><p id="8c77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">info</code>输出非常抽象。能看到一些实际数据不是很好吗？没问题。这就是<code class="fe nc nd ne nf b">head</code>方法的用途。</p><p id="811f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">head</code>方法显示列标题和前五行。有了这个印象，我们再来过列。你也可以在Kaggle页面上看到解释。</p><pre class="lh li lj lk gt nn nf no np aw nq bi"><span id="dfca" class="nr lx it nf b gy ns nt l nu nv">train.head()</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nx"><img src="../Images/2388bba570bf26034874e0626d7b7c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdQStOfuCsaV_TxdQUQ9xA.png"/></div></div></figure><p id="0e86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每一列代表我们数据的一个特征。<code class="fe nc nd ne nf b">PassengerId</code>是识别每一行的连续数字。<code class="fe nc nd ne nf b">Survived</code>是乘客是否幸存的指示器(0 =否，1 =是)。<code class="fe nc nd ne nf b">Pclass</code>是票类(1 = 1号，2 = 2号，3 = 3号)。然后我们有不言自明的<code class="fe nc nd ne nf b">Name</code>、<code class="fe nc nd ne nf b">Sex</code>和<code class="fe nc nd ne nf b">Age</code>。</p><p id="1d2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">表示该乘客在泰坦尼克号上的兄弟姐妹或配偶的数量。<code class="fe nc nd ne nf b">Parch</code>表示泰坦尼克号上该乘客父母或子女的编号。</p><p id="b6aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后就是乘客付费的<code class="fe nc nd ne nf b">Fare</code>，号码<code class="fe nc nd ne nf b">Cabin</code>和登船港口(<code class="fe nc nd ne nf b">embarked</code> ) (C =瑟堡，Q =皇后镇，S =南安普顿)。</p><h1 id="eed2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">数据准备和清理</h1><p id="0c20" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们的数据有不同的类型。有数字数据，如<code class="fe nc nd ne nf b">Age</code>、<code class="fe nc nd ne nf b">SibSp</code>、<code class="fe nc nd ne nf b">Parch</code>、<code class="fe nc nd ne nf b">Fare</code>。有分类数据。一些类别由数字表示(<code class="fe nc nd ne nf b">Survived</code>、<code class="fe nc nd ne nf b">Pclass</code>)。有些用文字表示(<code class="fe nc nd ne nf b">Sex</code>、<code class="fe nc nd ne nf b">Embarked</code>)。还有文字资料(<code class="fe nc nd ne nf b">Name</code>、<code class="fe nc nd ne nf b">Ticket</code>、<code class="fe nc nd ne nf b">Cabin</code>)。</p><p id="1a11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这真是一团糟。为了一台电脑。此外，当再次查看<code class="fe nc nd ne nf b">train.info()</code>的结果时，您可以看到不同列的计数有所不同。虽然大多数列有891个值，但只有714个用于<code class="fe nc nd ne nf b">Age</code>，204个用于<code class="fe nc nd ne nf b">Cabin</code>，889个用于<code class="fe nc nd ne nf b">Embarked</code>。</p><p id="49c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们可以将数据输入任何机器学习算法之前，我们需要清理。</p><h1 id="1dd5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">缺少值</h1><p id="6b68" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">大多数机器学习算法在缺失值的情况下效果不佳。有三种方法可以解决这个问题:</p><ul class=""><li id="03d1" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated">去掉相应的行(不考虑乘客)</li><li id="05c1" class="mt mu it kk b kl ng ko nh kr ni kv nj kz nk ld my mz na nb bi translated">去除整个列(去除所有乘客的整个特征)</li><li id="5616" class="mt mu it kk b kl ng ko nh kr ni kv nj kz nk ld my mz na nb bi translated">填充缺失的值(例如，用零、平均值或中值)</li></ul><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">应对缺失值</p></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ny"><img src="../Images/cc12818a3fa5b8c7c067c40f3563f033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ik-6okl12aAVY9x4cqt8AA.png"/></div></div></figure><p id="29ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe nc nd ne nf b">DataFrame</code>的<code class="fe nc nd ne nf b">dropna()</code>、<code class="fe nc nd ne nf b">drop()</code>和<code class="fe nc nd ne nf b">fillna()</code>方法轻松完成这些事情。一般来说，没有一个最佳选择。但是你要仔细考虑具体的语境。</p><p id="5f45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有两个乘客的出发港口我们不知道。这些占我们数据不到1%。如果我们完全忽略这两个乘客，我们不会看到完全不同的结果。因此，我们用<code class="fe nc nd ne nf b">dropna</code>方法删除这些行(第3行)。</p><p id="bd80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">dropna</code>-方法将列(<code class="fe nc nd ne nf b">"Embarked"</code>)作为命名参数<code class="fe nc nd ne nf b">subset</code>。此参数指定确定是否删除行(乘客)的列。如果这些列中至少有一个值缺失，该行将被删除。</p><p id="9242" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于<code class="fe nc nd ne nf b">Cabin</code>，情况有所不同。我们只有991名乘客中204人的信息。这是否足以从中得到任何信息是值得怀疑的。我们不知道为什么这些值会丢失。即使我们发现<code class="fe nc nd ne nf b">Cabin</code>与乘客的生存高度相关，我们也不知道这种相关性是否可以推广到所有乘客，或者是否存在选择偏差，这意味着我们知道<code class="fe nc nd ne nf b">Cabin</code>的事实取决于一些其他方面。</p><p id="4532" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用方法<code class="fe nc nd ne nf b">drop</code>删除整个列。我们提供想要移除的列(<code class="fe nc nd ne nf b">Cabin</code>)作为定位参数。我们作为命名参数<code class="fe nc nd ne nf b">axis</code>提供的值<code class="fe nc nd ne nf b">1</code>指定我们想要移除整个列。</p><p id="2f7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我们知道714乘客的<code class="fe nc nd ne nf b">Age</code>。将我们不认识的所有乘客排除在考虑范围之外似乎不是一个选项，因为他们占了我们数据的大约22%，相当重要的一部分。移除整个列似乎也不是一个好的选择。首先，我们知道大多数乘客的<code class="fe nc nd ne nf b">Age</code>，直觉表明<code class="fe nc nd ne nf b">Age</code>可能对某人的生存机会很重要。</p><p id="95b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe nc nd ne nf b">fillna</code>方法填充缺失的值(第13行)。因为我们只想填充<code class="fe nc nd ne nf b">Age</code>列中缺失的值，所以我们在该列上调用这个函数，而不是整个<code class="fe nc nd ne nf b">DataFrame</code>。我们提供想要设置的值作为参数。这是我们之前计算的所有乘客的平均年龄(第12行)。</p><p id="d047" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了。我们现在有889行，10列，不再有丢失的数据。</p><h1 id="7c36" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">标识符</h1><p id="141f" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">机器学习的目标是创建一个能够预测数据的算法。或者，就像我们之前说的:给一个东西贴上标签。虽然我们在构建算法时使用了已经标记的数据，但我们的目标是预测我们还不知道的标签。</p><p id="67e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们没有告诉我们的算法它如何决定选择哪个标签。而是我们告诉算法，“这是数据，你自己算出来”。也就是说，一个精明的算法可能能够记住你提供给它的所有数据。这被称为过度拟合。结果是算法在已知数据上表现良好，但在未知数据上表现不佳。</p><p id="a92e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的目标是只预测我们已经知道的标签，我们能做的最好的事情就是记住所有的乘客以及他们是否幸存。但是，如果我们想要创建一个即使在未知数据上也能表现良好的算法，我们需要防止记忆。</p><p id="a95f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们甚至还没有开始构建我们的算法。然而，我们为算法提供的基本功能会影响算法是否能够记忆数据。因为我们的数据中有潜在的标识符。</p><p id="837e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当查看数据集的前五个条目时，有三列看起来可疑:第<code class="fe nc nd ne nf b">PassengerId</code>、<code class="fe nc nd ne nf b">Name</code>和<code class="fe nc nd ne nf b">Ticket</code>。</p><p id="50d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">PassengerId</code>是一个后续数字。数字有多大和有没有乘客生还应该没有联系。</p><p id="700b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">乘客的名字或车票上的号码也不应该成为生存的决定性因素。相反，这些是识别单个乘客的数据。让我们验证这个假设。</p><p id="147c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看这些列中有多少唯一值。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">列中的唯一值</p></figure><pre class="lh li lj lk gt nn nf no np aw nq bi"><span id="b093" class="nr lx it nf b gy ns nt l nu nv">There are 889 different (unique) PassengerIds in the data<br/>There are 889 different (unique) names in the data<br/>There are 680 different (unique) ticket numbers in the data</span></pre><p id="9470" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">Name</code>和<code class="fe nc nd ne nf b">PassengerId</code>是完美的标识符。在我们的数据集中，889行中的每一行都有一个唯一的值。</p><p id="acc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且有680个不同的<code class="fe nc nd ne nf b">Ticket</code>号。<code class="fe nc nd ne nf b">Ticket</code>不是完美标识符的一个可能解释是家庭票。然而，基于这一数据的预测似乎支持记忆，而不是学习可转移的洞察力。</p><p id="a788" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们移除这些柱子。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">删除识别数据</p></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ny"><img src="../Images/7fbb0531b42fc89c7a8c43adbc218926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11z95d2Q8AjOrkzME0Tu2Q.png"/></div></div></figure><h1 id="aa6f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">处理文本和分类属性</h1><p id="b206" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">正如我们将在本书中看到的，所有的算法，包括经典算法和量子算法，都与数字有关。除了数字什么都没有。如果我们想使用文本数据，我们需要把它转换成数字。</p><p id="0505" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Scikit-Learn为此任务提供了一个名为<code class="fe nc nd ne nf b">LabelEncoder</code>的转换器。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">将文本数据转换为数字</p></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nz"><img src="../Images/a5a18ed589d24e1c4a3ad7d76c83fdff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_3W886q0P3c5FxKQK34nw.png"/></div></div></figure><p id="1663" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们导入<code class="fe nc nd ne nf b">LabelEncoder</code>(第1行)并初始化一个实例(第2行)。我们用文本数据(<code class="fe nc nd ne nf b">Sex</code>和<code class="fe nc nd ne nf b">Embarked</code>)遍历列(第4行)。对于每一列，我们需要<code class="fe nc nd ne nf b">fit</code>将列中的数据(第5行)编码，然后才能转换值(第6行)。</p><p id="8598" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们再看看我们的<code class="fe nc nd ne nf b">DataFrame</code>。可以看到，<code class="fe nc nd ne nf b">Sex</code>和<code class="fe nc nd ne nf b">Embarked</code>现在都是数字(<code class="fe nc nd ne nf b">int64</code>)。在我们的例子中，<code class="fe nc nd ne nf b">0</code>表示男性，<code class="fe nc nd ne nf b">1</code>表示女性乘客。但是当您再次运行转换时，您可能会产生不同的赋值。</p><h1 id="fd9b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">特征缩放</h1><p id="4c46" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">机器学习算法只对数字起作用。此外，他们通常使用相同比例的数字。如果数字具有不同的标度，算法可能会认为标度越高的数字越重要。</p><p id="bdf4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管我们所有的数据都是数字，但还没有统一的比例。大多数列的值在<code class="fe nc nd ne nf b">0</code>和<code class="fe nc nd ne nf b">3</code>之间。但是<code class="fe nc nd ne nf b">Age</code>和<code class="fe nc nd ne nf b">Fare</code>的规模要大得多。</p><p id="6add" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">max</code>方法返回一列中的最大值。我们可以看到，年龄最大的乘客80岁，最高票价约512。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">最大值</p></figure><pre class="lh li lj lk gt nn nf no np aw nq bi"><span id="a7f4" class="nr lx it nf b gy ns nt l nu nv">The maximum age is 80.0<br/>The maximum fare is 512.3292</span></pre><p id="e94c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">处理不同比例数据的一种常用方法是最小-最大比例(也称为归一化)。这个过程会移动和重新调整值，使它们最终的范围从<code class="fe nc nd ne nf b">0</code>到<code class="fe nc nd ne nf b">1</code>。它从每个值中减去最小值，然后除以最大值减去最小值。</p><p id="280e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">Scikit-Learn</code>为我们提供了<code class="fe nc nd ne nf b">MinMaxScaler</code>转换器来完成这项工作。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">数据的标准化</p></figure><pre class="lh li lj lk gt nn nf no np aw nq bi"><span id="5efd" class="nr lx it nf b gy ns nt l nu nv">The minimum value is 0.0 and the maximum value is 1.0</span></pre><p id="3d14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们首先导入转换器(第1行)并初始化它(第3行)。然后，我们<code class="fe nc nd ne nf b">fit</code>转换我们的数据(第4行)并转换它(第5行)。</p><p id="2245" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们数据集中的所有数据都在<code class="fe nc nd ne nf b">0.0</code>和<code class="fe nc nd ne nf b">1.0</code>之间。</p><blockquote class="oa ob oc"><p id="5c59" class="ki kj le kk b kl km ju kn ko kp jx kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">scaler返回一个Numpy数组，而不是Pandas数据帧</p></blockquote><h1 id="fff2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">培训和测试</h1><p id="fabe" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们已经提到了构建一个算法的目标，该算法不仅对已知数据表现良好，而且还能预测未知数据的标签。</p><p id="7a11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么将数据分为训练集和测试集非常重要。我们使用训练集来构建我们的算法。我们使用测试集来验证它的性能。</p><p id="e770" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管Kaggle提供了一个测试集，但我们跳过了它，因为它没有包含<code class="fe nc nd ne nf b">Survived</code>列。每次我们想验证它的时候，我们都需要问Kaggle。为了保持简单，并且能够自己进行验证，我们宁愿从Kaggle训练集中抽出一些行来进行测试。</p><p id="7b2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分离一个<code class="fe nc nd ne nf b">test</code>集合相当简单。Scikit-learn也为此提供了一个有用的方法。这是<code class="fe nc nd ne nf b">train_test_split</code>。</p><p id="6a29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们需要将输入数据与我们想要预测的结果标签分离开来。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">将输入从标签中分离出来，将训练从测试集中分离出来</p></figure><pre class="lh li lj lk gt nn nf no np aw nq bi"><span id="7896" class="nr lx it nf b gy ns nt l nu nv">We have 711 training and 178 testing rows There are 7 input columns</span></pre><p id="7160" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用Python数组索引将输入列与标签分开(第3–4行)。第一列(位置<code class="fe nc nd ne nf b">0</code>)包含我们想要预测的<code class="fe nc nd ne nf b">Survived</code>标志。其他列包含我们用作输入的数据。</p><p id="f4d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">train_test_split</code>将训练与测试数据集分开。参数<code class="fe nc nd ne nf b">test_size = 0.2</code> (= 20%)指定了我们希望测试集拥有的部分。</p><p id="502c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到我们的训练数据集包含711个条目。因此，我们的测试集由178个条目组成。我们有7列输入和一列输出。</p><p id="e3cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们保存我们准备好的数据，这样我们就可以在将来使用它，而不需要重复所有这些步骤。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">将数据保存到文件系统</p></figure><p id="b582" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本帖是本书的一部分:<a class="ae lf" href="https://www.pyqml.com/page?ref=medium_prepare&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">用Python动手做量子机器学习。</strong>T12】</a></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c619638a1887080f768a33a2b3701b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*i9dsCzZEz502JFqL.png"/></div></figure><p id="0e1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里免费获得前三章<a class="ae lf" href="https://www.pyqml.com/page?ref=medium_prepare&amp;dest=/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>