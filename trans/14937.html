<html>
<head>
<title>Portfolio Optimization With NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于NumPy的投资组合优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/portfolio-optimization-with-numpy-93e1428525a5?source=collection_archive---------15-----------------------#2020-10-14">https://towardsdatascience.com/portfolio-optimization-with-numpy-93e1428525a5?source=collection_archive---------15-----------------------#2020-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7b0f766f2c8158ef782abdc4955d2feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6b56ju6_e7rGZ2nf"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jg" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="7713" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">你所需要的只是一些矩阵代数来做出最优投资组合</h2></div><p id="5d0f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">来自《走向数据科学》编辑的提示:</em> </strong> <em class="lu">虽然我们允许独立作者根据我们的</em> <a class="ae jg" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="lu">规则和指导方针</em> </a> <em class="lu">发表文章，但我们并不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae jg" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="lu">读者术语</em> </a> <em class="lu">。</em></p><p id="09e9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">如果你想看我的代码，</em> <a class="ae jg" href="https://github.com/yiuhyuk/portfolio_optimization" rel="noopener ugc nofollow" target="_blank"> <em class="lu">你可以在我的GitHub这里找到</em> </a> <em class="lu">。</em></p><p id="c2de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上次我们讨论了投资组合优化的工作方式和原因:</p><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/understanding-portfolio-optimization-795668cef596"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">了解投资组合优化</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">从概念上理解优化投资组合意味着什么</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ja lv"/></div></div></a></div><p id="e2c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，我们将深入实际优化投资组合的技术细节。关于投资组合优化的冷静思考是，它可以完全用矩阵代数来完成，不需要优化软件。</p><p id="594e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始之前，让我们重温一下我们的目标。引用我之前的帖子:</p><blockquote class="mk ml mm"><p id="4e3e" class="ky kz lu la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">我们希望(尽可能)确定的是，对于特定的风险水平，我们投资的投资组合能够最大化我们获得正回报的机会。做到这一点的投资组合，也称为最优投资组合，是具有最高预期回报的<strong class="la jk">(或者用统计学术语来说，是具有最高Z值的投资组合)。</strong></p></blockquote><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="48b9" class="mz na jj mv b gy nb nc l nd ne">For a given level of risk, solve for the weights, W, that:</span><span id="ad8a" class="mz na jj mv b gy nf nc l nd ne"><strong class="mv jk">Maximize W.T @ E</strong></span><span id="7edd" class="mz na jj mv b gy nf nc l nd ne"><strong class="mv jk">Subject to:<br/>  W.T @ Cov @ W = (target risk)^2 <br/>  and sum(W) = 1</strong></span><span id="2d96" class="mz na jj mv b gy nf nc l nd ne">Where <strong class="mv jk">W</strong> is a vector representing the weights of the asset in our portfolio.<br/><strong class="mv jk">E</strong> is a vector representing the expected returns of the asset.<br/><strong class="mv jk">Cov</strong> is the covariance matrix of the asset's returns.<br/><strong class="mv jk">@</strong> denotes matrix multiplication.<br/><strong class="mv jk">.T</strong> denotes the transpose operation.</span></pre><ol class=""><li id="01b5" class="ng nh jj la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">W @ E是投资组合的预期收益。</li><li id="28d0" class="ng nh jj la b lb np le nq lh nr ll ns lp nt lt nl nm nn no bi translated">投资组合的方差计算为W.T @ Cov @ W)。方差是投资组合标准差的平方(也称为风险)。在我们的目标函数中，我们希望投资组合的方差等于目标方差(目标风险水平的平方)。</li></ol></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="86ce" class="ob na jj bd oc od oe of og oh oi oj ok kp ol kq om ks on kt oo kv op kw oq or bi translated">翻转问题</h1><p id="9465" class="pw-post-body-paragraph ky kz jj la b lb os kk ld le ot kn lg lh ou lj lk ll ov ln lo lp ow lr ls lt im bi translated">最小化问题通常比最大化问题更容易解决，所以让我们把问题反过来:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1158" class="mz na jj mv b gy nb nc l nd ne">For a given level of risk, solve for the weights, W, that:</span><span id="f8c9" class="mz na jj mv b gy nf nc l nd ne"><strong class="mv jk">Minimize W.T @ Cov @ W</strong></span><span id="7e93" class="mz na jj mv b gy nf nc l nd ne"><strong class="mv jk">Subject to:<br/>  W.T @ E = target return = mu<br/>  and sum(W) = 1</strong></span><span id="1307" class="mz na jj mv b gy nf nc l nd ne">Where <strong class="mv jk">W</strong> is a vector representing the weights of the asset in our portfolio.<br/><strong class="mv jk">E</strong> is a vector representing the expected returns of the asset.<br/><strong class="mv jk">Cov</strong> is the covariance matrix of the asset's returns.<br/><strong class="mv jk">@</strong> denotes matrix multiplication.<br/><strong class="mv jk">.T</strong> denotes the transpose operation.</span></pre><p id="ec5a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们不是最大化给定方差水平的收益(也就是风险的平方)，而是最小化给定收益水平的方差。</p><p id="df6e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解析地解决这个问题，我们可以利用<a class="ae jg" href="https://en.wikipedia.org/wiki/Lagrange_multiplier" rel="noopener ugc nofollow" target="_blank">拉格朗日乘数</a>并将我们的问题改写如下:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2a54" class="mz na jj mv b gy nb nc l nd ne"><strong class="mv jk">L(W,h1,h2) <br/>= W.T@Cov@W + h1*(W.T@E - mu) + h1*(W.T@ones - 1)</strong></span><span id="ab9f" class="mz na jj mv b gy nf nc l nd ne"><strong class="mv jk">ones</strong> denotes a vector of ones with the same length as W</span></pre><p id="34e8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们现在有一个等式，其中包括我们想要最小化的东西(<strong class="la jk"> W.T@Cov@W </strong>)以及我们的两个约束条件——投资组合的预期回报必须等于目标回报(<strong class="la jk"> W@E — mu </strong>)，投资组合权重总和必须为1 ( <strong class="la jk"> W@ones — 1 </strong>)。</p><p id="bbe7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过解决以下问题来解决这个问题:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e026" class="mz na jj mv b gy nb nc l nd ne"><strong class="mv jk">gradient{L(W,h1,h2)} = 0</strong></span></pre><p id="a8b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这基本上是梯度下降，我们想找到关于每个变量的偏导数(也叫斜率)为零的点。当我们到达那一点时，我们知道我们是最小的。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="a5a3" class="ob na jj bd oc od oe of og oh oi oj ok kp ol kq om ks on kt oo kv op kw oq or bi translated">一些矩阵代数</h1><p id="ddf5" class="pw-post-body-paragraph ky kz jj la b lb os kk ld le ot kn lg lh ou lj lk ll ov ln lo lp ow lr ls lt im bi translated">我们可以用矩阵代数来解前面的方程。首先让我们写出每个偏导数:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5a40" class="mz na jj mv b gy nb nc l nd ne">gradient L with respect to W  = 2*Cov@W + h1*mu + h2*ones = 0<br/>gradient L with respect to h1 = W.T@E - mu = 0<br/>gradient L with respect to h2 = W.T@ones - 1 = 0</span></pre><p id="a21d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将方程组改写为:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3cc5" class="mz na jj mv b gy nb nc l nd ne">2*Cov@W + h1*mu + h2*ones = 0<br/>W.T@E                     = mu<br/>W.T@ones                  = 1</span></pre><p id="a8b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">矩阵的好处在于，它让我们可以很容易地表示像这样的方程组(并且很容易求解)。在Python矩阵表示法中，前面的三个等式是:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ad7c" class="mz na jj mv b gy nb nc l nd ne">[[2*Cov  h1 h2],     [[W ],       [[0 ],<br/> [E.T.   0  0 ],  @   [h1],   =    [mu],<br/> [ones.T 0. 0 ]]      [h2]]        [1 ]]</span><span id="ec41" class="mz na jj mv b gy nf nc l nd ne">       <strong class="mv jk">A          @    X      =     b</strong></span></pre><p id="25ba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们可以用三个矩阵A、X和b，用矩阵方程A@X=b，来解决整个问题。</p><p id="6cc5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们需要做的就是解出X，我们可以很容易地将b乘以A的倒数:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3b80" class="mz na jj mv b gy nb nc l nd ne"><strong class="mv jk">X = inverse(A)@b</strong></span><span id="575f" class="mz na jj mv b gy nf nc l nd ne">The first <strong class="mv jk">n</strong> elements of X are the optimal weights where <strong class="mv jk">n</strong> is the number of different assets whose weights we are optimizing for.</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="3098" class="ob na jj bd oc od oe of og oh oi oj ok kp ol kq om ks on kt oo kv op kw oq or bi translated">用Python把它们放在一起</h1><p id="2e4b" class="pw-post-body-paragraph ky kz jj la b lb os kk ld le ot kn lg lh ou lj lk ll ov ln lo lp ow lr ls lt im bi translated">首先我们从一些回报开始。我通过QUANDL API从Shardar下载了我的。我的返回数据存储在名为<strong class="la jk"> final </strong>的数据帧中，如下所示:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a551" class="mz na jj mv b gy nb nc l nd ne">             S&amp;P 500  Treasury Bonds      TIPS      Gold<br/>date                                                    <br/>2020-10-07  0.017407       -0.007293 -0.000080 -0.000451<br/>2020-10-08  0.008863        0.005400  0.003977  0.003555<br/>2020-10-09  0.008930       -0.000187  0.000317  0.018161<br/>2020-10-12  0.016088        0.003186  0.000634 -0.002872<br/>2020-10-13 -0.006526        0.007161  0.000000 -0.01572</span></pre><p id="5ac1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有四种资产，我有每种资产几年的日收益。我们可以使用以下代码计算优化所需的输入:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="fa86" class="mz na jj mv b gy nb nc l nd ne"># final is a dataframe of daily returns for the assets</span><span id="6d62" class="mz na jj mv b gy nf nc l nd ne"># I use the historical mean return for my expected return<br/>E = np.array(final.mean(axis=0)).reshape(-1,1)</span><span id="6c7a" class="mz na jj mv b gy nf nc l nd ne"># Calculate the covariance matrix of the asset's returns<br/>cov_matrix = np.array(final.cov())</span><span id="e57c" class="mz na jj mv b gy nf nc l nd ne"># Ones vector<br/>ones = np.ones((E.shape[0],1))</span><span id="0a60" class="mz na jj mv b gy nf nc l nd ne">zeros = np.zeros((2,2))</span></pre><p id="6b76" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们根据等式(A@X=b)创建矩阵:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1f2d" class="mz na jj mv b gy nb nc l nd ne"># Put together the A matrix<br/>A = 2*cov_matrix<br/>A = np.append(A, E.T, axis=0)<br/>A = np.append(A, ones.T, axis=0)<br/>temp = np.append(E, ones, axis=1)<br/>temp = np.append(temp, zeros, axis=0)<br/>A = np.append(A, temp, axis=1)</span><span id="19e3" class="mz na jj mv b gy nf nc l nd ne"># Put together the b vector<br/>b = np.array([[0],<br/>              [0],<br/>              [0],<br/>              [0],<br/>              E[0],  # I set the target return to be<br/>              [1]])  # the expected return of stocks</span><span id="b131" class="mz na jj mv b gy nf nc l nd ne"># So in essense, I am looking for an optimal portfolio<br/># that is expected to give the same return as I get from<br/># investing in stocks (but with lower risk)</span></pre><p id="8265" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是他们每个人的样子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c767" class="mz na jj mv b gy nb nc l nd ne">A = <br/>  0.000237 -0.000096 -0.000015  0.000004  0.000555  1.0<br/> -0.000096  0.000170  0.000046  0.000038  0.000371  1.0<br/> -0.000015  0.000046  0.000024  0.000022  0.000154  1.0<br/>  0.000004  0.000038  0.000022  0.000200  0.000228  1.0<br/>  0.000555  0.000371  0.000154  0.000228  0.000000  0.0<br/>  1.000000  1.000000  1.000000  1.000000  0.000000  0.0</span><span id="5307" class="mz na jj mv b gy nf nc l nd ne">b = <br/>  0.000000<br/>  0.000000<br/>  0.000000<br/>  0.000000<br/>  0.000555<br/>  1.000000</span><span id="1616" class="mz na jj mv b gy nf nc l nd ne"># The 0.000555 number in b is the historical daily mean return of <br/># the S&amp;P 500</span></pre><p id="f89d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们可以通过对矩阵A求逆并将其乘以矩阵b来计算最佳权重:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c246" class="mz na jj mv b gy nb nc l nd ne"># Optimize using matrix algebra</span><span id="d184" class="mz na jj mv b gy nf nc l nd ne">from numpy.linalg import inv</span><span id="8e9b" class="mz na jj mv b gy nf nc l nd ne">results = inv(A)<a class="ae jg" href="http://twitter.com/b" rel="noopener ugc nofollow" target="_blank">@b</a></span><span id="0977" class="mz na jj mv b gy nf nc l nd ne"># Grab first 4 elements of results because those are the weights<br/># Recall that we optimize across 4 assets so there are 4 weights<br/>opt_W = results[:final.shape[1]]</span></pre><p id="e451" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看我们的最佳体重。最佳投资组合主要包括股票和债券，做空TIPS，少量配置黄金。解析解只能产生无约束权重(意味着允许短重)。如果我们只想要正的权重，我们将不得不使用梯度下降。</p><p id="da4e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">这些权重是使用非常天真的假设和纯粹的历史数据计算出来的。这些绝对不应该作为投资建议！</em>T13】</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9eb3" class="mz na jj mv b gy nb nc l nd ne">                Optimal Weights<br/>S&amp;P 500                0.602329<br/>Treasury Bonds         0.726293<br/>TIPS                  -0.357301<br/>Gold                   0.028680</span></pre><p id="988a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，让我们看看我们所谓的最优投资组合实际上是否是最优的。我们应该期望我们的最优投资组合的回报与股票(标准普尔500)相似，但波动性更小。我们可以看到，我们的最优投资组合的回报(紫色线)比股票的回报(蓝色线)更高，波动性更小。</p><p id="a72d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，这个简单的分析是非常偏颇的。目的是向您展示如何用矩阵代数进行投资组合优化。<strong class="la jk">我优化了投资组合，并在相同的时间框架内对其进行了回溯测试</strong>(没有训练测试分割)，因此投资组合当然会看起来非常好。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/f47391e76e406f7d63de93e817eaa381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*EyexAc1iz3vrC4hSrQqg5g.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">最优投资组合与组成资产类别(来源:Sharadar，图形由作者创建)</p></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="627a" class="ob na jj bd oc od oe of og oh oi oj ok kp ol kq om ks on kt oo kv op kw oq or bi translated">结论</h1><p id="c998" class="pw-post-body-paragraph ky kz jj la b lb os kk ld le ot kn lg lh ou lj lk ll ov ln lo lp ow lr ls lt im bi translated">一旦你计算完最佳权重，还有更多工作要做。众所周知，投资组合优化过程对输入(尤其是预期回报)的微小变化非常敏感。</p><p id="16c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，震撼优化输入(通过重采样或甚至添加一些人工噪声)来查看权重如何变化是一个好主意。</p><p id="518c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，思考一下最优投资组合真正代表的是什么是有好处的。这是一个旨在长期持有(几年)的投资组合。这是因为我们用来估计投入的数据(回报的时间序列)需要覆盖尽可能多的时间，最好是多个商业周期。</p><p id="b49b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是一个旨在帮助你在短期内把握市场时机的过程。短期内估计的预期收益和协方差矩阵会带来估计错误的巨大风险——记住，垃圾进垃圾出。干杯！</p></div></div>    
</body>
</html>