<html>
<head>
<title>How To Use Modules In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Julia中使用模块</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-modules-in-julia-a27e31974b9c?source=collection_archive---------30-----------------------#2020-10-23">https://towardsdatascience.com/how-to-use-modules-in-julia-a27e31974b9c?source=collection_archive---------30-----------------------#2020-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fc64" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">朱莉娅综合教程</h2><div class=""/><div class=""><h2 id="262a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">关于Julia语言中模块和导入如何工作的快速课程</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/225a476158b73972bcbc7f6da1be9122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHfsTS6f9hwDDrZ14pjXyQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="lh"><p id="a730" class="li lj it bd lk ll lm ln lo lp lq lr dk translated">本文视频:</p></blockquote><figure class="ls lt lu lv lw kw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><blockquote class="lh"><p id="e2f4" class="li lj it bd lk ll lm ln lo lp lq lr dk translated">Github:</p></blockquote><div class="ls lt lu lv lw lz"><a href="https://github.com/emmettgb/JuliaLessons/tree/master/6" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd jd gy z fp me fr fs mf fu fw jc bi translated">emmettgb/JuliaLessons</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn lb lz"/></div></div></a></div><h1 id="45f6" class="mo mp it bd mq mr ms mt mu mv mw mx my ki mz kj na kl nb km nc ko nd kp ne nf bi translated">介绍</h1><p id="b3ee" class="pw-post-body-paragraph ng nh it ni b nj nk kd nl nm nn kg no np nq nr ns nt nu nv nw nx ny nz oa lr im bi translated">而我们在过去的朱莉娅教程中已经讲过的东西；函数、构造函数和类型当然是有价值的，一个程序员不可能从零开始构建一个完整的生态系统。也就是说，程序员经常使用包来执行他们的包不一定针对但需要的算法。包是代码的储存库，可以作为其他包迭代和构建的依赖项重用。</p><p id="801f" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">我们已经对Pkg以及如何使用它来安装Julia编程语言的包进行了概述。今天我们将使用一个名为Compose.jl的模块来练习用Julia编程。我选择这个库是因为它是一个函数式的声明性库，遵循我们在这些教程中介绍的相同的编程方法和原则。此外，作为一个图形包意味着人们可以在非常直观的输出中看到他们代码的直接结果——这对一个新的程序员来说很方便。如果您想了解更多关于该模块的信息，您可以访问Juliahub:</p><div class="og oh gp gr oi lz"><a href="https://juliahub.com/ui/Packages/Compose/sbiEw/0.9.1" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd jd gy z fp me fr fs mf fu fw jc bi translated">JuliaHub</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">编辑描述</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">juliahub.com</p></div></div></div></a></div></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="d24e" class="mo mp it bd mq mr oq mt mu mv or mx my ki os kj na kl ot km nc ko ou kp ne nf bi translated">包装——基础</h1><p id="3c93" class="pw-post-body-paragraph ng nh it ni b nj nk kd nl nm nn kg no np nq nr ns nt nu nv nw nx ny nz oa lr im bi translated">为了在Julia中添加一个包，我们将使用Pkg。您可以通过使用将Pkg导入到Julia中，或者只使用Pkg REPL，可以通过在Julia REPL中按]来访问它。添加相对简单，可以使用Pkg.add()方法或Pkg REPL中的add命令来完成。当然，今天我们将使用Compose.jl，所以您可能想继续添加它:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="f023" class="pa mp it ow b gy pb pc l pd pe">julia&gt; ]<br/>pkg&gt; add Compose</span></pre><p id="4e53" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">这将把Compose添加到我们的全局包环境中。一些Julia开发者强烈反对这样做，但是我不同意——我认为在你的机器上有依赖是完全没问题的，只要它们是经常使用的依赖。此外，用户总是可以使用rm命令删除他们的包。</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="262b" class="pa mp it ow b gy pb pc l pd pe">julia&gt; ]<br/>pkg&gt; rm Compose</span></pre><p id="8f46" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">如果你想了解更多关于Pkg酷的原因，你可以看看我不久前写的一篇文章！：</p><div class="og oh gp gr oi lz"><a rel="noopener follow" target="_blank" href="/julias-package-manager-is-awesome-23b9c02e3a0b"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd jd gy z fp me fr fs mf fu fw jc bi translated">朱莉娅的包装经理棒极了</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">为什么Julia的Pkg是我用过的最好的软件包管理器。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="pf l mk ml mm mi mn lb lz"/></div></div></a></div><p id="f356" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">为了让一个模块进入我们的Julia运行时环境，我们有一系列不同的选项来导入它。首要的是使用。使用just意味着该包将被预编译并从运行时内部调用，并且不会在运行时内部发生变化。我们可以使用Compose包</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="e545" class="pa mp it ow b gy pb pc l pd pe">using Compose</span></pre><p id="9bc8" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">在Julia语言中，使用导出的函数和结构是很常见的。这意味着这些函数不需要通过它们的父类来调用，而是可以在导入模块时直接调用。我们可以通过直接导入我们想要在Julia中使用的类型或函数来避免使用导出:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="4c2b" class="pa mp it ow b gy pb pc l pd pe">using Compose: compose</span></pre><p id="ba81" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">直接导入将加载我们的目标代码，而不包括包内的所有其他成分。直接导入也可以节省编译时间，在注册的软件中，对于只有一两个不同类型或函数要在你的软件中使用的依赖项，这是绝对推荐的。</p><p id="c1b6" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">除了使用之外，在Julia语言中，我们还可以访问import关键字。导入代码与使用代码正好相反，并且允许扩展包。通常情况下，除非需要扩展，否则不需要显式导入。</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="85b8" class="pa mp it ow b gy pb pc l pd pe">import Compose<br/># Direct explicit import:<br/>import Compose: compose</span></pre></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="8695" class="mo mp it bd mq mr oq mt mu mv or mx my ki os kj na kl ot km nc ko ou kp ne nf bi translated">作曲！</h1><p id="28ca" class="pw-post-body-paragraph ng nh it ni b nj nk kd nl nm nn kg no np nq nr ns nt nu nv nw nx ny nz oa lr im bi translated">了解了使用Julia中模块的基础知识后，我们现在可以看看我们今天要学习的模块:</p><blockquote class="lh"><p id="2e15" class="li lj it bd lk ll pg ph pi pj pk lr dk translated">Compose.jl</p></blockquote><p id="d9f7" class="pw-post-body-paragraph ng nh it ni b nj pl kd nl nm pm kg no np pn nr ns nt po nv nw nx pp nz oa lr im bi translated">Compose是一个用pure Julia编写的声明性矢量图形库，它使得只使用几个参数和节点就可以非常容易地绘制图形。您可以在此处查看Juliahub上的撰写文档:</p><div class="og oh gp gr oi lz"><a href="https://juliahub.com/docs/Compose/sbiEw/0.9.1/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd jd gy z fp me fr fs mf fu fw jc bi translated">Home Compose.jl</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">Compose是一个用Julia编写的声明性矢量图形系统。它旨在简化复杂的创建…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">juliahub.com</p></div></div></div></a></div><p id="77d4" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">说到这里，如果你是Julia的新手，并且正在使用Julia模块，那么看看JuliaHub肯定是值得的。JuliaHub是Julia程序员的一体化软件包目的地，其中的文档很容易包含并自动集成到网站中。如果你想了解更多，我有一整篇关于它有多酷的文章！：</p><div class="og oh gp gr oi lz"><a rel="noopener follow" target="_blank" href="/juliahub-the-greatest-approach-to-putting-together-packages-and-documentation-707688a472d2"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd jd gy z fp me fr fs mf fu fw jc bi translated">JuliaHub:将包和文档放在一起的最好方法</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">JuliaHub如何自动化所有程序员讨厌做的事情。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="pq l mk ml mm mi mn lb lz"/></div></div></a></div><p id="00d1" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">直接从Compose文档中提取，我们的第一个例子很简单，但是可以理解要点:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="bf60" class="pa mp it ow b gy pb pc l pd pe">composition = compose(context(), rectangle(), fill("tomato"))</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/658a893b97348e54cc6992e554930c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hqe7VIxuoEAr0ht5T1FqSw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><p id="62fb" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">更深入地研究这个语句，compose()方法负责返回一个组合并接受参数。这些参数是称为组合表单和节点的类型。在方法调用内部，我们看到的参数是context()、rectangle()和fill()。Context是根节点，所以在这个特定的实例中，它基本上可以被忽略。接下来的参数是矩形。这当然是在渲染图像中显示的类型。最后一个参数是fill()，它接受一个字符串，表示整个上下文所需颜色的标题()。</p><p id="7f0d" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">幸运的是，我们可以使用？()方法，以了解有关这些参数的更多信息。让我们创建更多的矩形！我们将从查看在创建类型时可以提供什么类型的数据开始:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ps"><img src="../Images/131ed6d14b2b40fd0dd9634e27722956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jF0CI-p7yk2E5nO4WoOtaQ.png"/></div></div></figure><p id="e845" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">矩形既可以接受0个参数，也可以接受4个参数。这方面的四个参数是位置参数，窗体的x位置，窗体的y位置，然后是宽度和高度。有了这个新发现的信息，让我们修改我们的旧代码来改变矩形的大小:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="0ba4" class="pa mp it ow b gy pb pc l pd pe">composition = compose(context(), rectangle(.5, .5, 5px, 5px), fill("tomato"))</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/800f50cd6f2f9edf54944f4e9d9a0fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOSfuBS4esknZ0RDkFnAOw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure><p id="c678" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">并添加更多的矩形:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="9ac5" class="pa mp it ow b gy pb pc l pd pe">composition = compose(context(), rectangle(.5, .5, 20px, 20px),<br/>    rectangle(.5, .2, 20px, 20px),<br/>    rectangle(.5, .8, 20px, 20px),<br/>    fill("tomato")<br/>)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/ef1031a50dd809a8c2a8b3d1f4640214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2d3kDi0OsFEpcdwuCJGzQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="f77b" class="mo mp it bd mq mr oq mt mu mv or mx my ki os kj na kl ot km nc ko ou kp ne nf bi translated">使用与导入</h1><p id="3674" class="pw-post-body-paragraph ng nh it ni b nj nk kd nl nm nn kg no np nq nr ns nt nu nv nw nx ny nz oa lr im bi translated">一个可能令人混淆的概念是使用import和使用将模块导入Julia。这是可以理解的，因为许多语言通常不包含这个特性；并且大多数使用using将类和函数从名称空间中取出。也就是说，普通的Julia程序员可以感觉到的使用和导入之间最明显的区别是扩展模块的能力。这在本文前面已经提到过，但是用代码详细说明一下，分派一个矩形只接受两个位置参数而不是一个或两个是不可能的，如下所示:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="f6fc" class="pa mp it ow b gy pb pc l pd pe">using Compose: rectangle<br/>rectangle(x::Float64, y::Float64) = rectangle(x, y, 30px, 30px)</span></pre><p id="6baf" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">但是，如果我们使用import而不是使用:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="be57" class="pa mp it ow b gy pb pc l pd pe">import Compose: rectangle<br/>rectangle(x::Float64, y::Float64) = rectangle(x, y, 30px, 30px)</span></pre></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><h1 id="dd3a" class="mo mp it bd mq mr oq mt mu mv or mx my ki os kj na kl ot km nc ko ou kp ne nf bi translated">结论</h1><p id="a9dc" class="pw-post-body-paragraph ng nh it ni b nj nk kd nl nm nn kg no np nq nr ns nt nu nv nw nx ny nz oa lr im bi translated">没有一个程序员能够写出整个世界的软件，幸运的是他们不需要这么做。这是因为数以百万计的开源开发者正在开发每个程序员都可以使用的奇妙模块。在Julia中，我们可以使用Pkg添加一些这样的包。从今天开始，关于模块最重要的事情是:</p><ul class=""><li id="c577" class="pv pw it ni b nj ob nm oc np px nt py nx pz lr qa qb qc qd bi translated">那个？()方法</li><li id="335f" class="pv pw it ni b nj qe nm qf np qg nt qh nx qi lr qa qb qc qd bi translated">JuliaHub文档</li><li id="6efd" class="pv pw it ni b nj qe nm qf np qg nt qh nx qi lr qa qb qc qd bi translated">添加包</li><li id="d723" class="pv pw it ni b nj qe nm qf np qg nt qh nx qi lr qa qb qc qd bi translated">导入和使用的区别</li></ul><p id="02be" class="pw-post-body-paragraph ng nh it ni b nj ob kd nl nm oc kg no np od nr ns nt oe nv nw nx of nz oa lr im bi translated">掌握这些概念会让你成为一个真正的茱莉亚语言大师，你已经在路上了！</p></div></div>    
</body>
</html>