<html>
<head>
<title>You Don’t Need To Be A Mathematician To Master Quantum Computing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握量子计算不需要成为数学家</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/you-dont-need-to-be-a-mathematician-to-master-quantum-computing-161026af8878?source=collection_archive---------10-----------------------#2020-10-07">https://towardsdatascience.com/you-dont-need-to-be-a-mathematician-to-master-quantum-computing-161026af8878?source=collection_archive---------10-----------------------#2020-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">作为程序员，你会做得很好</h2></div><p id="c20b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文是本书的一部分:<a class="ae le" href="https://www.pyqml.com/page?ref=medium_math&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">用Python实践量子机器学习</strong> </a></p><p id="73b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于量子计算的科学论文和教科书充满了数学公式。甚至关于量子计算的博客帖子也充斥着数学术语。它从你遇到的第一个概念开始。量子叠加:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/164cf4d557ad622662c53307de34f6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_il-ZLWYKggDLLln55jOJw.png"/></div></div></figure><p id="bcdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个非数学家，这个公式可能已经太多了。如果你不熟悉使用的<em class="lr">狄拉克</em>-符号(|ψ⟩)，或者如果你不习惯使用向量，那么这样一个公式就像埃及象形文字一样好:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ls"><img src="../Images/7013dccc0c58ac4dd8769b0163aafb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwSzR6Tz6O4z08vqf9lefg.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者弗兰克·齐克特的图片</p></figure><p id="0917" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要误解我。数学是描述技术概念的好方法。数学是一种简洁而精确的语言。相比之下，我们的自然语言，比如英语，既冗长又不精确。解释一小群数学公式需要一整本书的自然语言。</p><p id="65f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们大多数人理解自然语言的能力远远强于数学。我们从小就学习母语，并且每天都在练习。我们甚至用我们的自然语言做梦。不过，我不知道有些人是否会做数学梦。对我们大多数人来说，数学充其量是一门外语。</p><p id="c300" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们要学习新的东西时，如果我们使用母语，会更容易。理解这个新概念的含义已经够难的了。如果我们用外语学习，那就更难了。如果不是不可能的话。</p><p id="f450" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，数学是量子力学和量子计算的母语，如果你愿意的话。但是为什么我们要只用量子计算自己的语言来教它呢？难道我们不应该试着用一种学习者更容易理解的方式来解释它吗？我会说“<strong class="kk iu">绝对</strong>”！</p><p id="5a0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用学习者的语言教学并不意味着我们不应该看数学。我们应该！但是，当数学的精确性有助于我们解释事物如何运作时，我们就使用数学。</p><p id="9aaa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事实上，数学并不是我们唯一的精确语言。我们有像数学公式一样精确的语言。如今，这些语言对许多人来说几乎是自然而然的了。这些语言是编程语言。</p><p id="1ca2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不是指特定编程语言的语法。相反，我指的是几乎所有编程语言共有的一种思维方式。从Python到Java，从Javascript到Ruby，甚至从C到Cobol。所有这些语言都建立在布尔逻辑的基础上。不管使用什么编程语言，程序员都会大量使用布尔逻辑。</p><p id="a1b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最突出的是布尔逻辑出现在条件语句:<code class="fe lx ly lz ma b">if then else</code>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mb mc l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">如果在Python中是else</p></figure><p id="58e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">条件语句的<code class="fe lx ly lz ma b">if</code>部分是纯布尔逻辑。通常，它包含基本的布尔操作符<code class="fe lx ly lz ma b">not</code>、<code class="fe lx ly lz ma b">and</code>和<code class="fe lx ly lz ma b">or</code>。</p><p id="63ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果某个陈述是<code class="fe lx ly lz ma b">True</code>，那么它的否定就是<code class="fe lx ly lz ma b">False</code>。反之，如果一个语句是<code class="fe lx ly lz ma b">False</code>，那么它的否定就是<code class="fe lx ly lz ma b">True</code>。如果一个语句由两部分<code class="fe lx ly lz ma b">P</code>和<code class="fe lx ly lz ma b">Q</code>组成，那么如果<code class="fe lx ly lz ma b">P</code>是<code class="fe lx ly lz ma b">True</code>而<code class="fe lx ly lz ma b">Q</code>是<code class="fe lx ly lz ma b">True</code>，那么<code class="fe lx ly lz ma b">P and Q</code>只是<code class="fe lx ly lz ma b">True</code>。但是如果<code class="fe lx ly lz ma b">P</code>或<code class="fe lx ly lz ma b">Q</code>是<code class="fe lx ly lz ma b">True</code>则<code class="fe lx ly lz ma b">P or Q</code>是<code class="fe lx ly lz ma b">True</code>。</p><p id="65db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是Python中布尔逻辑的三个例子。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mb mc l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">Python中的布尔逻辑</p></figure><pre class="lg lh li lj gt md ma me mf aw mg bi"><span id="3c31" class="mh mi it ma b gy mj mk l ml mm">not P is False<br/>P and Q is False<br/>P or Q is True<br/>P and not Q is True</span></pre><p id="8869" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然Python使用这些确切的关键字，但在数学中，符号代表这些运算符:</p><ul class=""><li id="fc4a" class="mn mo it kk b kl km ko kp kr mp kv mq kz mr ld ms mt mu mv bi translated">是指<code class="fe lx ly lz ma b">not</code></li><li id="d25f" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated">∧表示<code class="fe lx ly lz ma b">and</code></li><li id="78df" class="mn mo it kk b kl mw ko mx kr my kv mz kz na ld ms mt mu mv bi translated">∨表示<code class="fe lx ly lz ma b">or</code></li></ul><p id="b1a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不是数学家，这些符号和你在量子机器学习过程中遇到的所有其他符号可能看起来很神秘。但是，虽然用Python或math描述概念时，概念的表示可能不同，但概念本身是相同的。</p><p id="5160" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解布尔逻辑不需要成为数学家。实际上，你也不需要成为一名程序员，因为我们甚至可以通过真值表来描述布尔逻辑。</p><p id="74c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有两个变量，<code class="fe lx ly lz ma b">P</code>和<code class="fe lx ly lz ma b">Q</code>。每个变量要么为真(<code class="fe lx ly lz ma b">T</code>)，要么为假(<code class="fe lx ly lz ma b">F</code>)。根据它们的值的组合，我们可以推导出任何布尔语句的值。下图描述了<code class="fe lx ly lz ma b">P</code>、<code class="fe lx ly lz ma b">Q</code>、<code class="fe lx ly lz ma b">not P</code>、<code class="fe lx ly lz ma b">not Q</code>、<code class="fe lx ly lz ma b">not P and not Q</code>、<code class="fe lx ly lz ma b">not (not P and not Q)</code>和<code class="fe lx ly lz ma b">P or Q</code>的真值表。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ls"><img src="../Images/13db93a6711cb971e61c9cc12ba5eacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Utt_FJ2Umlc2MNrS0Miysg.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者弗兰克·齐克特的图片</p></figure><p id="2f78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个真值表揭示了<code class="fe lx ly lz ma b">P or Q</code>等同于<code class="fe lx ly lz ma b">not (not P and not Q)</code>。这种逻辑等价告诉我们，我们甚至不需要运算符<code class="fe lx ly lz ma b">or</code>。我们可以用<code class="fe lx ly lz ma b">not (not P and not Q)</code>来代替它。</p><p id="e688" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是<code class="fe lx ly lz ma b">P or Q</code>简明易懂。</p><p id="0120" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lr">“如果我们的编程语言中没有</em> <code class="fe lx ly lz ma b"><em class="lr">or</em></code> <em class="lr">运算符会怎样？</em></p><p id="a9d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">精明的程序员会编写自己的操作符。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mb mc l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">或的重新实现</p></figure><pre class="lg lh li lj gt md ma me mf aw mg bi"><span id="3d25" class="mh mi it ma b gy mj mk l ml mm">P | Q | P or Q<br/>--------------<br/>T | T | True<br/>T | F | True<br/>F | T | True<br/>F | F | False</span></pre><p id="b0ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是编程的意义所在。程序员编写产生某种行为的函数。他们使用并组合这些函数来创建更多的函数，表现出更复杂的行为。他们编写的整个程序可以归结为一组巧妙组合的函数。程序员用他们的编译器(或解释器)将高级函数翻译成非常基本的布尔逻辑。并且这种基本的布尔逻辑可以使用电气开关来执行。开关和它们的组合被称为门。当我们连接门时，它们形成一个电路。</p><p id="745b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在不连续的时间间隔内，计算机通过电路发送一个电脉冲。如果我们在适当的时间接收到一个电脉冲，我们将其解释为<code class="fe lx ly lz ma b">1</code>(真)。如果我们没有接收到脉冲，我们将其解释为<code class="fe lx ly lz ma b">0</code>(假)。</p><p id="11cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管有这个名字，电路并不是循环的。它们是线性的，从左向右读取。让我们来看一个例子，它对应于我们之前看到的布尔函数</p><p id="0da0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图描绘了<code class="fe lx ly lz ma b">not (not P and not Q)</code>的电路图。该电路从左侧接收输入，并将其输出到右侧。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ls"><img src="../Images/d9f024daf796020001be6dbcb8fd66a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNDr3EVq2sNIVDZrlk3x7w.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者弗兰克·齐克特的图片</p></figure><p id="9f8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种门和电路是任何现代计算机的组成部分。这包括量子计算机。虽然量子力学的世界不同，但量子计算的世界惊人地相似。</p><p id="8eb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要让你自己被所有的数学公式弄得眼花缭乱。它们是概念的代表。不多也不少。</p><p id="7048" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回到我们的介绍性公式:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/164cf4d557ad622662c53307de34f6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_il-ZLWYKggDLLln55jOJw.png"/></div></div></figure><p id="fb0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是量子态|ψ⟩(“psi”)的数学符号。虽然经典比特的状态是布尔型的(或者<code class="fe lx ly lz ma b">0</code>表示假，或者<code class="fe lx ly lz ma b">1</code>表示真)，但是量子比特(量子比特)的状态是由α和β加权的量子态|0⟩和|1⟩的叠加。</p><p id="2621" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种叠加态下，量子系统既不是<code class="fe lx ly lz ma b">0</code>也不是<code class="fe lx ly lz ma b">1</code>，除非你去测量。只有当你测量量子位时，状态才会坍缩到<code class="fe lx ly lz ma b">0</code>或<code class="fe lx ly lz ma b">1</code>。两个权重(α^2)和(β^2)的平方表示测量<code class="fe lx ly lz ma b">0</code>或<code class="fe lx ly lz ma b">1</code>的概率。α越大，测量到<code class="fe lx ly lz ma b">0</code>的概率越高。相应地，β越大，测量到<code class="fe lx ly lz ma b">1</code>的概率越高。</p><p id="554a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个公式说明了更多的东西。它说量子态是两个重量[α β]的矢量。</p><p id="b1af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">矢量是一个有大小和方向的地理对象。如果在坐标系中绘制，向量从中心开始，到向量中数字指定的点结束。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ls"><img src="../Images/a34b3fee6629616b5f33e8dc33177c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgdDMeYZHyj2QezDhh7Bkw.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者弗兰克·齐克特的图片</p></figure><p id="21fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，向量是一个数组。因此，一个量子位的状态就是数组<code class="fe lx ly lz ma b">[alpha, beta]</code>。并且，<code class="fe lx ly lz ma b">alpha</code>和<code class="fe lx ly lz ma b">beta</code>是数值变量。量子态是两个数的数组。</p><p id="6ac6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是由两个数字组成的数组是比布尔值更复杂的数据类型。布尔值为<code class="fe lx ly lz ma b">True</code>或<code class="fe lx ly lz ma b">False</code>。您可以用简单的运算符转换布尔值，例如<code class="fe lx ly lz ma b">not</code>、<code class="fe lx ly lz ma b">and</code>和<code class="fe lx ly lz ma b">or</code>。您可以推理真值表中布尔值的转换。</p><p id="43d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是你如何转换两个数字的数组呢？你如何解释这种转变？</p><p id="56c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显而易见的答案是数学。但这不是唯一可能的答案。让我们用Python来做吧。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mb mc l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">反转量子位状态</p></figure><pre class="lg lh li lj gt md ma me mf aw mg bi"><span id="3287" class="mh mi it ma b gy mj mk l ml mm">----------- Reversed states: ----------<br/>psi: [0.50, 0.87]  result: [0.87, 0.50]<br/>|0&gt;: [1.00, 0.00]  result: [0.00, 1.00]<br/>|1&gt;: [0.00, 1.00]  result: [1.00, 0.00]</span></pre><p id="1b94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从三个状态的初始化开始。每个状态都是由两个数字组成的数组。状态<code class="fe lx ly lz ma b">psi</code>的值为1/2和√3/2(第4行)。在这种状态下测量<code class="fe lx ly lz ma b">0</code>的概率是(1/2)^2=1/4=0.25.测量的概率<code class="fe lx ly lz ma b">1</code>是(√3/2)^2=3/4=0.75.</p><p id="1c05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">状态<code class="fe lx ly lz ma b">always_0</code>具有值<code class="fe lx ly lz ma b">1</code>和<code class="fe lx ly lz ma b">0</code>。在这种状态下测量<code class="fe lx ly lz ma b">0</code>的概率是1^2=1(第5行)。测量的概率<code class="fe lx ly lz ma b">1</code>是0^2=0.当我们在这种状态下测量一个量子比特时，我们总是测量为<code class="fe lx ly lz ma b">0</code>。状态<code class="fe lx ly lz ma b">always_1</code>是各自的对立面。我们一直测量为<code class="fe lx ly lz ma b">1</code>(第6行)。</p><p id="6f37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们创建一个便利函数<code class="fe lx ly lz ma b">transform</code>(第8-9行)。我告诉过你编写函数使事情变得简单是编程的全部内容吗？这是一个例子。该函数采用量子态的名称(要显示的任意字符串)、<code class="fe lx ly lz ma b">state</code>和函数<code class="fe lx ly lz ma b">f</code>。<code class="fe lx ly lz ma b">transform</code>将初始状态和应用<code class="fe lx ly lz ma b">f</code>功能后的状态打印到控制台。</p><p id="2b9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们创建一个函数<code class="fe lx ly lz ma b">reverse_state</code>，我们可以将它输入到<code class="fe lx ly lz ma b">transform</code>(第11-12行)。<code class="fe lx ly lz ma b">reverse_state</code>调用Python默认的<code class="fe lx ly lz ma b">reversed</code>函数，以相反的顺序返回相同长度的数组。</p><p id="f6ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在输出中，我们可以看到状态数组中的数字交换了位置。这样，测量<code class="fe lx ly lz ma b">0</code>或<code class="fe lx ly lz ma b">1</code>的概率分别切换。反转的<code class="fe lx ly lz ma b">psi</code>有<code class="fe lx ly lz ma b">0.75</code>机会测量<code class="fe lx ly lz ma b">0</code>和<code class="fe lx ly lz ma b">0.25</code>机会测量<code class="fe lx ly lz ma b">1</code>。反转后的<code class="fe lx ly lz ma b">always_0</code>与原来的<code class="fe lx ly lz ma b">always_1</code>相似。</p><p id="f8ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是三种可能的状态。在一种真值表中列出所有可能的状态是不可能的。但是我认为<code class="fe lx ly lz ma b">reverse_state</code>函数的行为非常清楚。这是量子计算中X门的行为。这是量子态的基本变换之一。</p><p id="3859" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在实践中看看这个门。我们用的是IBM的量子计算SDK <em class="lr"> Qiskit </em>。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mb mc l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">测量的量子位</p></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ls"><img src="../Images/3702f7536218176b7ea4320d699aab3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOTJsGW1CyQ7nnwdc79jVg.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者弗兰克·齐克特的图片</p></figure><p id="ce07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lr"> Qiskit </em>的基本单元是量子电路。量子电路是量子计算的模型。这个项目，如果你愿意的话。我们的电路由一个量子位组成(第5行)。</p><p id="c077" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用状态<code class="fe lx ly lz ma b">psi</code>(第8行)初始化我们的量子位，并对其应用X-gate(第11行)。</p><p id="a69d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lr"> Qiskit </em>提供了<code class="fe lx ly lz ma b">Aer</code>包(我们在第1行导入的包)。它为模拟量子电路提供了不同的后端。最常见的后端是<code class="fe lx ly lz ma b">statevector_simulator</code>(第14行)。</p><p id="542b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lx ly lz ma b">execute</code>-函数(也是我们在第1行导入的)以指定的<code class="fe lx ly lz ma b">backend</code>运行我们的量子电路(<code class="fe lx ly lz ma b">qc</code>)。它返回一个<code class="fe lx ly lz ma b">job</code>-对象，该对象有一个有用的方法<code class="fe lx ly lz ma b">job.result()</code>(第17行)。一旦我们的程序完成它，就会返回<code class="fe lx ly lz ma b">result</code>对象。</p><p id="0ab6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Qiskit使用Matplotlib来提供有用的可视化。简单的直方图就可以了。<code class="fe lx ly lz ma b">result</code>对象提供了<code class="fe lx ly lz ma b">get_counts</code>方法来获取被执行电路的直方图数据(第18行)。</p><p id="e0d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法<code class="fe lx ly lz ma b">plot_histogram</code>返回一个Jupyter自动绘制的<em class="lr"> Matplotlib </em>图形(第19行)。</p><p id="bf03" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到我们有75%的机会观察到值<code class="fe lx ly lz ma b">0</code>，有25%的机会观察到值<code class="fe lx ly lz ma b">1</code>。与初始状态完全相反。</p><p id="629f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以用不同的初始状态运行电路来更好的感受这个门。</p><p id="3a3d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，量子电路与经典电路并无不同。我们可以用图表来表示它们。<em class="lr"> Qiskit </em>的<code class="fe lx ly lz ma b">QuantumCircuit</code>类为我们提供了完成这项工作的<code class="fe lx ly lz ma b">draw</code>方法。</p><pre class="lg lh li lj gt md ma me mf aw mg bi"><span id="5c9f" class="mh mi it ma b gy mj mk l ml mm">qc.draw('mpl')</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ls"><img src="../Images/6400ba25e94c758feebae529a486c0b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwCizAH2mbr4hLReNPNzlw.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者弗兰克·齐克特的图片</p></figure><p id="e5ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到我们唯一的量子位(<code class="fe lx ly lz ma b">q</code>)，它与数组<code class="fe lx ly lz ma b">[0.5, 0.866]</code>的初始化，以及应用的X门。</p><p id="0874" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使不是数学家，你也已经完成了掌握量子计算的第一步。从概念上理解量子门是经典电路门的量子对等物并不依赖于数学。简单英语和一点点Python的结合非常合适。对许多人来说，这种结合更容易实现。</p><p id="0125" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，数学仍然是量子计算的重中之重。如果你想对概念有更深的理解，你迟早会遇到数学公式。正如我所说，数学是描述技术概念的一个很好的方式。</p><p id="d726" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看X-gate的底层数学。别担心，我不指望你成为数学家。尽管如此，对代数(即对数学符号和操作它们的规则的研究)的一点喜爱并没有坏处。</p><p id="ffad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们使用的是Python的内置函数<code class="fe lx ly lz ma b">reversed</code>。虽然这很方便，但我们看不出它在内部是如何工作的。让我们使用另一个函数。一个自制函数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mb mc l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">自制反向功能</p></figure><pre class="lg lh li lj gt md ma me mf aw mg bi"><span id="aba0" class="mh mi it ma b gy mj mk l ml mm">reversed psi: [0.87, 0.50]</span></pre><p id="b284" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们定义一个函数<code class="fe lx ly lz ma b">adjust_weight</code>(第1行)。它需要一个量子<code class="fe lx ly lz ma b">state</code>和<code class="fe lx ly lz ma b">weights</code>。两者都是包含两项的数组。它将位置<code class="fe lx ly lz ma b">0</code>处的值和位置<code class="fe lx ly lz ma b">1</code>处的值相乘。它返回这两个乘积的和(第2行)。</p><p id="eeea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用这个功能来反转<code class="fe lx ly lz ma b">psi</code>。对于返回单个数字的<code class="fe lx ly lz ma b">adjust_weight</code>,我们调用它两次来获得两个项目的数组(第5行和第6行)。在本例中，我们没有显式创建数组，而是直接将这些值打印到控制台(第4行)。</p><p id="b873" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这两个调用中，我们提供原始的<code class="fe lx ly lz ma b">psi</code>作为<code class="fe lx ly lz ma b">state</code>参数。在第一次调用中，其结果是反向psi的第一个数字，我们提供<code class="fe lx ly lz ma b">[0,1]</code>作为<code class="fe lx ly lz ma b">weights</code>。这意味着，我们得到了<code class="fe lx ly lz ma b">0</code>乘以第一个数字<code class="fe lx ly lz ma b">psi</code>和<code class="fe lx ly lz ma b">1</code>乘以第二个数字<code class="fe lx ly lz ma b">psi</code>的和。这个和是原<code class="fe lx ly lz ma b">psi</code>的第二个数。</p><p id="4cf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二个调用中，其结果是反向psi的第二个数字，我们提供<code class="fe lx ly lz ma b">[1,0]</code>作为<code class="fe lx ly lz ma b">weights</code>。这是第一个数字<code class="fe lx ly lz ma b">psi</code>的<code class="fe lx ly lz ma b">1</code>倍和第二个数字<code class="fe lx ly lz ma b">psi</code>的<code class="fe lx ly lz ma b">0</code>倍。这等于原<code class="fe lx ly lz ma b">psi</code>的第一个数字。</p><p id="4f35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些权重，我们有效地交换了<code class="fe lx ly lz ma b">psi</code>的数字位置。</p><p id="4739" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在数学中，这是一个矩阵乘法。矩阵<em class="lr"> M </em>和向量<em class="lr"> υ </em>相乘的一般公式为:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nb"><img src="../Images/c4d7b24581db91a680f75bbb1809a695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ce4WBT6bCUud5nMzccHjRg.png"/></div></div></figure><p id="716d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lr"> a </em>和<em class="lr"> b </em>是我们用来计算结果向量第一个数的权重。<em class="lr"> c </em>和<em class="lr"> d </em>分别是第二个数字的权重。</p><p id="43c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学上，X门量子算符是矩阵:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nc"><img src="../Images/9187e60da1d9be27b5260f0a66a74266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4nVWaM7e3uc1Bis14Ho-Q.png"/></div></div></figure><p id="0e47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将该操作符应用于我们的三个示例性状态:</p><p id="41f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逆转|0⟩在|1⟩:的结果</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nd"><img src="../Images/08987ce2136087697f8c736ec2e7b4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2OuK8nXCJvC0FhYAxPcgg.png"/></div></div></figure><p id="1b07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逆转|1⟩在|0⟩:的结果</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ne"><img src="../Images/e514c946fc1e19db88123cba3557fde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5agA3fcVlXiA68NdNqHjA.png"/></div></div></figure><p id="c7e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且，在|ψ⟩应用矩阵也会导致它的反转:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nf"><img src="../Images/2ab6fa46c56af7af50919cb7a82eaeef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWajPlvJH6JOfgBXVO9JlA.png"/></div></div></figure><p id="fd10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在经典计算中，我们有一小组布尔运算符，它们的行为可以很容易地用真值表来表示。但是在量子计算中，矩阵表示称为门的操作符。我们可以应用无数种可能的矩阵。数学是描述这些运算符的简洁而精确的方法。但是你不需要成为数学家来使用这些运算。</p><p id="ee58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，在应用时，最好能理解门的基本数学原理。但更重要的是，你需要了解大门是做什么的。如果你知道X-gate是做什么的，你就不需要一直应付数学。</p><p id="5936" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本帖是本书的一部分:<a class="ae le" href="https://www.pyqml.com/page?ref=medium_math&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">用Python动手做量子机器学习</strong> </a> <strong class="kk iu">。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c619638a1887080f768a33a2b3701b5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*i9dsCzZEz502JFqL.png"/></div></figure><p id="0e1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里免费获得前三章<a class="ae le" href="https://www.pyqml.com/page?ref=medium_math&amp;dest=/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>