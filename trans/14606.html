<html>
<head>
<title>How to control the game board of 2048</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何控制2048的游戏板</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-control-the-game-board-of-2048-ec2793db3fa9?source=collection_archive---------33-----------------------#2020-10-08">https://towardsdatascience.com/how-to-control-the-game-board-of-2048-ec2793db3fa9?source=collection_archive---------33-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="bacc" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/playing-2048-with-minimax" rel="noopener" target="_blank">用极大极小算法玩2048</a></h2><div class=""/><div class=""><h2 id="a00b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">…并完成最小最大算法的实现</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a2e9a6ec60c356b0be29de9ecb7257ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kCj6c25AUzOdTlzwlvQXww.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="4b27" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我们将完成玩2048游戏的minimax算法的实现，然后我们将使用这个实现来自动玩这个游戏的web版本，这个版本可以在Github页面上找到。</p><p id="2d45" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里是之前关于这个主题的文章，我在其中展示了如何表现2048年的游戏状态。如果您错过了，请查看:</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/how-to-represent-the-game-state-of-2048-a1518c9775eb"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">如何表现2048年的游戏状态</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">…以及如何以面向对象的方式做到这一点</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div><p id="070a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们将首先创建<code class="fe mw mx my mz b">GameDriver</code>类，它将作为我们的minimax实现和网页上的游戏之间的中间人。<code class="fe mw mx my mz b">GameDriver</code>类负责与游戏交互。我们需要处理两个操作:获取游戏当前状态的数据，并做出一个动作:上、下、左、右。这两种操作通过以下方法实现:</p><ul class=""><li id="b73b" class="na nb it lj b lk ll ln lo lq nc lu nd ly ne mc nf ng nh ni bi translated"><code class="fe mw mx my mz b">.getGrid()</code> —这将获取游戏状态数据，并将其作为<code class="fe mw mx my mz b">Grid</code>对象返回。</li><li id="7e8c" class="na nb it lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated"><code class="fe mw mx my mz b">.move()</code> —这将把移动方向代码作为参数，并模拟适当箭头键的按键。</li></ul><p id="6d50" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在实施中选择的移动方向代码是:</p><ul class=""><li id="61b2" class="na nb it lj b lk ll ln lo lq nc lu nd ly ne mc nf ng nh ni bi translated">0 =向上</li><li id="fca4" class="na nb it lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">1 =向下</li><li id="0a89" class="na nb it lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">2 =左</li><li id="a63c" class="na nb it lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">3 =右</li></ul><p id="177d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于这个<code class="fe mw mx my mz b">GameDriver</code>类的实现，我们将使用Selenium，它是做这种事情的一个好库:与web浏览器交互。如果你不知道，看看这篇文章。</p><p id="c390" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们开始导入一些东西。从Selenium库中，我们需要webdriver和Keys，它们将用于为您想要的web浏览器创建一个驱动程序实例，分别用于使用箭头键。我们还将int类型的最大大小作为<code class="fe mw mx my mz b">MAX_INT</code>和<code class="fe mw mx my mz b">time</code>包导入；过一段时间我们就会知道我们需要什么了。</p><pre class="ks kt ku kv gt no mz np nq aw nr bi"><span id="de1a" class="ns nt it mz b gy nu nv l nw nx">from selenium import webdriver</span><span id="8b68" class="ns nt it mz b gy ny nv l nw nx">from selenium.webdriver.common.keys import Keys</span><span id="38af" class="ns nt it mz b gy ny nv l nw nx">from sys import maxsize as MAX_INT</span><span id="838c" class="ns nt it mz b gy ny nv l nw nx">import time</span></pre><p id="d076" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们为<code class="fe mw mx my mz b">GameDriver</code>类创建实例化方法。我们存储游戏页面的URL，创建Chrome驱动程序的实例，并打开游戏URL。然后，我们需要存储对页面主体元素的引用，以便稍后能够发送箭头键命令。我们还存储了一个字典，将移动方向代码映射到相应的箭头键。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4c3f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe mw mx my mz b">.getGrid()</code>方法提取关于游戏状态的数据并返回一个<code class="fe mw mx my mz b">Grid</code>对象。我们将数据存储为一个矩阵，并在返回时将其传递给<code class="fe mw mx my mz b">Grid</code>的构造函数。首先，用0初始化矩阵，然后当我们在页面上找到瓦片时更新它。</p><p id="d462" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">稍微考察了一下，Chrome开发者工具里的游戏页面(CTRL+SHIFT+I)，我的结论是:</p><ul class=""><li id="aa37" class="na nb it lj b lk ll ln lo lq nc lu nd ly ne mc nf ng nh ni bi translated">图块可以通过“图块”类名来识别。</li><li id="5fa5" class="na nb it lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">网格上每个图块的位置(行号和列号)可以从每个图块的类属性中的“图块-位置- <strong class="lj jd">列</strong> - <strong class="lj jd">行</strong>”形式的类名中提取。</li><li id="88b7" class="na nb it lj b lk nj ln nk lq nl lu nm ly nn mc nf ng nh ni bi translated">图块编号是可以从“tile- <strong class="lj jd"> num </strong>”形式的类名中提取的最大值，它位于每个图块的类属性中。</li></ul><p id="7db4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是实现上述想法的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="16f3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面的<code class="fe mw mx my mz b">.move()</code>方法向body元素发送适当的箭头键信号，以便按照它所采用的参数指示的方向移动。然后，我们使用<code class="fe mw mx my mz b">time.sleep(0.1)</code>在移动信号发出后暂停0.1秒，以便页面有时间更新自己。</p><pre class="ks kt ku kv gt no mz np nq aw nr bi"><span id="dd6e" class="ns nt it mz b gy nu nv l nw nx">def move(self, moveCode):</span><span id="1cce" class="ns nt it mz b gy ny nv l nw nx">    self.body.send_keys(self.moves[moveCode])</span><span id="3ea3" class="ns nt it mz b gy ny nv l nw nx">    time.sleep(0.1)</span></pre><p id="3ea8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是<code class="fe mw mx my mz b">GameDriver</code>类的完整代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a4d3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在是实现minimax算法的时候了，它由3个函数组成:<code class="fe mw mx my mz b">maximize()</code>、<code class="fe mw mx my mz b">minimize()</code>和<code class="fe mw mx my mz b">getBestMove()</code>。如果你不熟悉极大极小算法，你可以查看这篇文章，以确保你理解这里发生了什么。</p><p id="c1bf" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe mw mx my mz b">maximize()</code>函数取参数:<code class="fe mw mx my mz b">state</code>为网格对象，<code class="fe mw mx my mz b">a</code>和<code class="fe mw mx my mz b">b</code>为来自α-β剪枝的α和β，<code class="fe mw mx my mz b">d</code>为最大允许深度。该函数返回一个形式为<code class="fe mw mx my mz b">(maxChild, maxUtility)</code>的元组，其中<code class="fe mw mx my mz b">maxChild</code>是使效用最大化的当前状态对象(在minimax算法树中)的子对象，<code class="fe mw mx my mz b">maxUtility</code>是<code class="fe mw mx my mz b">maxChild</code>游戏状态的效用值。</p><p id="645b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe mw mx my mz b">maxUtility</code>变量将保存到目前为止遇到的节点的最大效用。在函数开始时，我们不知道任何效用值，所以我们认为最大值比任何效用值都小。我选择了-1。</p><p id="174e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们检查当前状态是否是一个终端节点，或者我们是否达到了最大深度。如果是，我们返回None作为<code class="fe mw mx my mz b">maxChild</code>并评估当前状态的效用，否则，我们继续迭代当前状态的所有子节点。在每一次迭代中，我们复制当前的游戏状态，并在一个可用的移动中移动；for循环中的<code class="fe mw mx my mz b">child</code>变量是一个移动方向代码，用于进行该移动。</p><p id="1fc0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后我们让Min通过<code class="fe mw mx my mz b">minimize()</code>函数完成他的移动，并从这个函数中获得当前迭代的子状态的效用。如果我们选择移动到循环中的当前子节点，这就是我们将得到的工具。如果这个效用大于我们之前的<code class="fe mw mx my mz b">maxUtility</code>，那么我们相应地更新<code class="fe mw mx my mz b">maxChild</code>和<code class="fe mw mx my mz b">maxUtility</code>。在这之后，我们根据α-β剪枝算法再做2次检查，这样我们就跳过了博弈树中那些我们事先知道它们不会给出最佳走法的路径。</p><p id="4e71" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe mw mx my mz b">minimize()</code>函数类似于<code class="fe mw mx my mz b">maximize()</code>，但现在我们处于最小玩家的位置，我们试图选择效用最小化的移动。</p><p id="ecf3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe mw mx my mz b">getBestMove()</code>函数调用<code class="fe mw mx my mz b">maximize()</code>并返回我们必须采取的行动的代码，以最大化我们的分数/效用。</p><p id="bee8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是我们的minimax实现的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5d50" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，是时候创建一个游戏循环了，在这个循环中，我们重复以下三件事，直到游戏结束:获取游戏数据，使用极大极小法来确定什么是最好的走法，并实际执行这个走法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="44f4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当我们运行这个游戏循环时，我们的屏幕上应该会出现一个2048年的游戏，它会像页面顶部的GIF那样自动播放。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="5885" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可以在<a class="ae md" href="https://github.com/lazuxd/playing-2048-with-minimax" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到这个项目的完整代码。</p><p id="647d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="oi">我希望您对这些信息感兴趣，感谢您的阅读！</em></p><p id="f078" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这篇文章也贴在我自己的网站<a class="ae md" href="https://www.nablasquared.com/how-to-control-the-game-board-of-2048/" rel="noopener ugc nofollow" target="_blank">这里</a>。随便看看吧！</p></div></div>    
</body>
</html>