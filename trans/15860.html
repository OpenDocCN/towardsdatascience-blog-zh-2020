<html>
<head>
<title>Exploratory Data Analysis with Well Log Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用测井数据进行探索性数据分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploratory-data-analysis-with-well-log-data-98ad084c4e7?source=collection_archive---------18-----------------------#2020-11-01">https://towardsdatascience.com/exploratory-data-analysis-with-well-log-data-98ad084c4e7?source=collection_archive---------18-----------------------#2020-11-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3ac46d7b03bf74758d4e7bb5a7d84aa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*81WhKeRGEXJPimr3"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">卢卡斯·布拉塞克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="52c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦数据经过整理和分类，数据科学过程的下一步就是进行探索性数据分析(EDA)。这一步使我们能够识别数据中的模式，了解特征(测井记录)之间的关系，并识别数据集中可能存在的异常值。在这一阶段，我们了解数据，并检查是否需要进一步处理或是否需要清理。</p><p id="e02a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为岩石物理学家/地球科学家，我们通常使用测井图、直方图和交会图(散点图)来分析和探索测井数据。Python提供了一个很好的工具集，可以快速简单地从不同的角度可视化数据。</p><p id="1da1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将使用由<a class="ae kf" href="https://xeek.ai/challenges/force-well-logs/overview" rel="noopener ugc nofollow" target="_blank"> Xeek </a>和<a class="ae kf" href="https://www.npd.no/en/force/events/" rel="noopener ugc nofollow" target="_blank"> FORCE </a>发布的数据集子集，作为从测井曲线预测相的竞赛的一部分。我们将混合使用<a class="ae kf" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>、<a class="ae kf" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>和<a class="ae kf" href="https://github.com/ResidentMario/missingno" rel="noopener ugc nofollow" target="_blank"> missingno </a>数据可视化库来可视化数据。</p><p id="ac5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将涵盖的观想将允许我们:</p><ul class=""><li id="de59" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">确定我们哪里有或没有数据</li><li id="c1f7" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">了解数据分布</li><li id="9d38" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">可视化受恶劣井眼条件影响的数据</li></ul><p id="3f03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章的笔记本可以在我的Python和Petrophysics Github系列中找到，可以通过下面的链接访问:</p><p id="9307" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://github.com/andymcdgeo/Petrophysics-Python-Series" rel="noopener ugc nofollow" target="_blank">https://github.com/andymcdgeo/Petrophysics-Python-Series</a></p><h1 id="b849" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">加载数据和库</h1><p id="e473" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">任何项目的第一步都是加载所需的库和数据。</p><p id="786a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这项工作，我们将调用一些绘图库:seaborn、matplotlib和missingno以及math、pandas和numpy。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3ee8" class="ne lt it na b gy nf ng l nh ni">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import math<br/>import missingno as msno<br/>import numpy as np</span></pre><p id="12ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们正在使用的数据集是Xeek和FORCE(<a class="ae kf" href="https://xeek.ai/challenges/force-well-logs/overview" rel="noopener ugc nofollow" target="_blank">https://xeek.ai/challenges/force-well-logs/overview</a>)举办的机器学习竞赛的一部分。竞赛的目的是从由98口训练井组成的数据集中预测岩性，每口井的测井完整性程度不同。目的是根据测井测量预测岩相。</p><p id="d907" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使本文中的图和数据易于管理，我使用了来自训练数据的12口井的子集。数据已经整理成一个单一的csv文件，无需担心曲线记忆。为了加载数据子集，我们可以调用<code class="fe nj nk nl na b">pd.read_csv.</code></p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6a7d" class="ne lt it na b gy nf ng l nh ni">data = pd.read_csv('Data/xeek_train_subset.csv')</span></pre><p id="7fb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加载数据后，我们可以使用以下命令确认井的数量和名称:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0558" class="ne lt it na b gy nf ng l nh ni"># Counts the number of unique values in the WELL column<br/>data['WELL'].nunique()</span></pre><p id="53f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将返回预期的12。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f4bd" class="ne lt it na b gy nf ng l nh ni"># Gets the unique names from the WELL column<br/>data['WELL'].unique()</span></pre><p id="08e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将返回一个带有井名的数组对象。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="05ef" class="ne lt it na b gy nf ng l nh ni">array(['15/9-13', '15/9-15', '15/9-17', '16/1-2', '16/1-6 A', '16/10-1', '16/10-2', '16/10-3', '16/10-5', '16/11-1 ST3', '16/2-11 A', '16/2-16'], dtype=object)</span></pre><h1 id="df23" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">找出差距</h1><p id="43b9" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">测井中的数据缺失可能是由多种原因造成的，包括:</p><ul class=""><li id="bc84" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">工具故障和问题</li><li id="4729" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">选择遗漏(即由于预算限制，工具没有运行)</li><li id="4ca9" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">人为误差</li><li id="71af" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">复古数据集</li><li id="bb62" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">钻孔环境产生的问题</li></ul><p id="8d10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用多种方法来确定哪里有数据，哪里没有。我们将看两种方法来可视化丢失的数据。</p><h2 id="6c0a" class="ne lt it bd lu nm nn dn ly no np dp mc kr nq nr mg kv ns nt mk kz nu nv mo nw bi translated">缺少图书馆</h2><p id="9fdf" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们要看的第一种方法是使用missingno库，它提供了一个很好的小工具箱，由Aleksy Bilgour创建，作为一种可视化和理解数据完整性的方法。更多关于图书馆的细节可以在https://github.com/ResidentMario/missingno<a class="ae kf" href="https://github.com/ResidentMario/missingno" rel="noopener ugc nofollow" target="_blank">找到。如果您没有这个库，您可以使用<code class="fe nj nk nl na b">pip install missingno</code>将它快速安装到您的终端中。</a></p><p id="785f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">missingno工具箱包含许多不同的可视化，但是对于本文，我们将重点关注矩阵图和条形图。矩阵图可通过以下方式调用:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cb10" class="ne lt it na b gy nf ng l nh ni">msno.matrix(data)</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/7c9166b85360d82a925ad4f763f16446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGPlyAzKCxAQ3XXMdbYXjA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">将matplotlib.pyplot作为plt导入</p></figure><p id="966d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这向我们展示了所有特征的数据密度(对数曲线)。在图的右边是迷你图，它显示了数据中最大或最小的零值。</p><p id="b323" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从可视化我们可以看到，只有少数几个列是完整的井，深度_MD，GR，组，岩相_岩性和岩相_置信度。</p><p id="a3a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他国家有接近完整的数据值，如DTC、CALI和ROP，而一些国家的数据覆盖范围很小，如RMIC、SGR和ROPA。</p><p id="c212" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以调用<code class="fe nj nk nl na b">msno.bar(data)</code>来生成一个条形图，显示每一列中非空数据值的数量(对数曲线)。沿着图表的顶部，我们得到了非空数据值的总数。</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/637c7061b184bf0262d21469ab52ccca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXC4n3L_ImUFpgASq9uQ5Q.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">msno.bar(数据)中缺少数值计数。</p></figure><p id="c3dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速浏览一下矩阵图和条形图，就可以知道数据集中缺少什么数据，尤其是在数据集中有大量列的情况下。</p><h2 id="238c" class="ne lt it bd lu nm nn dn ly no np dp mc kr nq nr mg kv ns nt mk kz nu nv mo nw bi translated">使用Matplotlib可视化缺失数据</h2><p id="5b67" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在我的上一篇文章:<a class="ae kf" rel="noopener" target="_blank" href="/visualising-well-data-coverage-using-matplotlib-f30591c89754">使用Matplotlib可视化油井数据覆盖范围</a>中，我介绍了一种逐井查看数据覆盖范围的方法。这使您可以看到关键曲线中的缺口。</p><p id="a843" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想为每口井的所有曲线生成一个图，我们可以将每条曲线保存为一个文件，或者将数据显示在一个单独的列中。在这个例子中，我只选择了岩石物理学家可能在解释中使用的普通曲线。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ff3e" class="ne lt it na b gy nf ng l nh ni">data_nan = data[['WELL','DEPTH_MD','CALI', 'BS', 'GR', 'NPHI', 'RHOB', 'PEF', 'RDEP', 'RMED', 'DTC', 'DTS']].copy()<br/>for num, col in enumerate(data_nan.columns[2:]):<br/>    data_nan[col] = data_nan[col].notnull() * (num + 1)<br/>    data_nan[col].replace(0, num, inplace=True)<br/>    print(col, num) #Print out the col name and number to verify it works<br/>grouped = data_nan.groupby('WELL')</span><span id="8777" class="ne lt it na b gy nz ng l nh ni">#Setup the labels we want to display on the x-axis<br/>labels = ['CALI', 'BS', 'GR', 'NPHI', 'RHOB', 'PEF', 'RDEP', 'RMED', 'DTC', 'DTS']</span><span id="6cd7" class="ne lt it na b gy nz ng l nh ni">#Setup the figure and the subplots<br/>fig, axs = plt.subplots(4, 3, figsize=(20,20))</span><span id="9c2a" class="ne lt it na b gy nz ng l nh ni">#Loop through each well and column in the grouped dataframe<br/>for (name, df), ax in zip(grouped, axs.flat):<br/>    ax.set_xlim(0,9)<br/>    <br/>    #Setup the depth range<br/>    ax.set_ylim(5000, 0)<br/>    <br/>    #Create multiple fill betweens for each curve# This is between<br/>    # the number representing null values and the number representing<br/>    # actual values<br/>    <br/>    ax.fill_betweenx(df.DEPTH_MD, 0, df.CALI, facecolor='grey')<br/>    ax.fill_betweenx(df.DEPTH_MD, 1, df.BS, facecolor='lightgrey')<br/>    ax.fill_betweenx(df.DEPTH_MD, 2, df.GR, facecolor='mediumseagreen')<br/>    ax.fill_betweenx(df.DEPTH_MD, 3, df.NPHI, facecolor='lightblue')<br/>    ax.fill_betweenx(df.DEPTH_MD, 4, df.RHOB, facecolor='lightcoral')<br/>    ax.fill_betweenx(df.DEPTH_MD, 5, df.PEF, facecolor='violet')<br/>    ax.fill_betweenx(df.DEPTH_MD, 6, df.RDEP, facecolor='darksalmon')<br/>    ax.fill_betweenx(df.DEPTH_MD, 7, df.RMED, facecolor='wheat')<br/>    ax.fill_betweenx(df.DEPTH_MD, 8, df.DTC, facecolor='thistle')<br/>    ax.fill_betweenx(df.DEPTH_MD, 9, df.DTS, facecolor='tan')<br/>    <br/>    #Setup the grid, axis labels and ticks<br/>    ax.grid(axis='x', alpha=0.5, color='black')<br/>    ax.set_ylabel('DEPTH (m)', fontsize=14, fontweight='bold')<br/>    <br/>    #Position vertical lines at the boundaries between the bars<br/>    ax.set_xticks([1,2,3,4,5,6,7,8,9,10], minor=False)<br/>    <br/>    #Position the curve names in the centre of each column<br/>    ax.set_xticks([0.5, 1.5 ,2.5 ,3.5 ,4.5 ,5.5 ,6.5 , 7.5, 8.5, 9.5], minor=True)<br/>    <br/>    #Setup the x-axis tick labels<br/>    ax.set_xticklabels(labels,  rotation='vertical', minor=True, verticalalignment='bottom')<br/>    ax.set_xticklabels('', minor=False)<br/>    ax.tick_params(axis='x', which='minor', pad=-10)<br/>    <br/>    #Assign the well name as the title to each subplot<br/>    ax.set_title(name, fontsize=16, fontweight='bold')</span><span id="dfb0" class="ne lt it na b gy nz ng l nh ni">plt.savefig('missingdata.png')<br/>plt.tight_layout()<br/>plt.subplots_adjust(hspace=0.15, wspace=0.25)<br/>plt.show()</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/d731e8929de225e75e237e58e2b8f975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFuf60EPHEZMqaPUeHdhBg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">多孔图，显示数据集中每孔的数据覆盖率。</p></figure><p id="fd0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从生成的图像中，我们可以确定主曲线中的缺口在哪里。从这个图中，我们可以确定哪些井对机器学习建模或进一步研究有用。</p><h1 id="f881" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">熟悉数据</h1><p id="8f70" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在本节中，我们将研究一些可视化技术，这些技术可用于深入了解我们的数据，以及这些数据与岩相和地质地层学的关系。</p><p id="883f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python世界有多个绘图和数据可视化库。其中之一是<a class="ae kf" href="https://seaborn.pydata.org" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>，这是一个建立在<a class="ae kf" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>之上的数据可视化库，并与<a class="ae kf" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>密切合作。它提供了一种简单且更直观的方式来显示和浏览您的数据。</p><p id="a92c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下示例说明了一些不同的绘图，可用于混合使用FacetGrid和matplotlib来快速了解数据。</p><h2 id="4b38" class="ne lt it bd lu nm nn dn ly no np dp mc kr nq nr mg kv ns nt mk kz nu nv mo nw bi translated">密度——岩性的中子分布</h2><p id="22e2" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">与matplotlib相比，FacetGrid提供了一种使用少量代码在网格中绘制多个子情节的更简单、更流畅的方法。</p><p id="9e1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用我们的数据之前，我们首先必须将数字岩性数据转换成实际的描述性标签。这可以通过使用一个简单的字典来实现:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2027" class="ne lt it na b gy nf ng l nh ni">lithology_numbers = {30000: 'Sandstone',<br/>                 65030: 'Sandstone/Shale',<br/>                 65000: 'Shale',<br/>                 80000: 'Marl',<br/>                 74000: 'Dolomite',<br/>                 70000: 'Limestone',<br/>                 70032: 'Chalk',<br/>                 88000: 'Halite',<br/>                 86000: 'Anhydrite',<br/>                 99000: 'Tuff',<br/>                 90000: 'Coal',<br/>                 93000: 'Basement'}</span></pre><p id="47b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的数据框架中，我们创建了一个名为LITH的新列，并使用map函数快速获得描述性标签，如下所示:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c6cd" class="ne lt it na b gy nf ng l nh ni">data['LITH'] = data['FORCE_2020_LITHOFACIES_LITHOLOGY'].map(lithology_numbers)</span></pre><p id="c795" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第一个FacetGrid，我们将按地层查看密度-中子数据。当我们这样做时，我们只需要指定几行代码，而不是多行或使用for循环，就像上面的例子中看到的丢失数据一样。我们可以用密度中子数据初始化FacetGrid，并将LITH列传入<code class="fe nj nk nl na b">col</code>参数。此外，我们可以使用<code class="fe nj nk nl na b">col_wrap</code>参数来指定网格中需要多少列。</p><p id="ccb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，由于我们熟悉使用特定比例在交会图上处理密度-中子数据，我们需要相应地设置<code class="fe nj nk nl na b">xlim</code>和<code class="fe nj nk nl na b">ylim</code>，否则它将自动缩放。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1ab9" class="ne lt it na b gy nf ng l nh ni">g = sns.FacetGrid(data, col='LITH', col_wrap=4)<br/>g.map(sns.scatterplot, 'NPHI', 'RHOB', alpha=0.5)<br/>g.set(xlim=(-0.15, 1))<br/>g.set(ylim=(3, 1))</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/6848874e361a1bfa69d49ccf7d1fa92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xcVh1H8_wf1PHUCTP78rA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">根据岩性划分密度-中子数据面网格。</p></figure><p id="d00b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将生成一系列按岩性划分的密度-中子数据的微型散点图/交会图。你可以从上面的代码中看到，我们必须指定的只是绘图的类型、轴和设置轴限制，这样我们就有了一个可以立即使用的好绘图。</p><h2 id="5b19" class="ne lt it bd lu nm nn dn ly no np dp mc kr nq nr mg kv ns nt mk kz nu nv mo nw bi translated">密度——岩性和井的中子分布</h2><p id="0fd9" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">通过查看多口井的岩性分布，我们可以进一步增强密度中子数据。使用转换后的岩性数据列，我们可以通过向<code class="fe nj nk nl na b">hue</code>参数提供岩性来为不同的岩性类型创建阴影。然后，我们可以将数据框中的井列输入到<code class="fe nj nk nl na b">col</code>参数中。</p><p id="06c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以通过向标记和大小参数提供值来更改标记。这将有助于清理绘图，以便我们可以看到更多的数据。</p><p id="7320" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，由于我们使用的是色调，我们可以使用<code class="fe nj nk nl na b">add_legend().</code>自动生成图例</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6cc3" class="ne lt it na b gy nf ng l nh ni">g = sns.FacetGrid(data, col='WELL', hue='LITH', col_wrap=4)<br/>g.map(sns.scatterplot, 'NPHI', 'RHOB', linewidth=1, size=0.1, marker='+')<br/>g.set(xlim=(-0.15, 1))<br/>g.set(ylim=(3, 1))<br/>g.add_legend()</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/9a9779705fc84d4f72beeeef10b27f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhIiscG1fJfxed5OhV6O3g.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">FacetGrid密度-中子数据按井划分，并按岩性着色。</p></figure><h2 id="f101" class="ne lt it bd lu nm nn dn ly no np dp mc kr nq nr mg kv ns nt mk kz nu nv mo nw bi translated">密度——按岩性和地质组的中子分布</h2><p id="6b28" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们可以很容易地将地质组列的分组选项换成按组查看岩性变化。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="441b" class="ne lt it na b gy nf ng l nh ni">g = sns.FacetGrid(data, col='GROUP', hue='LITH', col_wrap=4)<br/>g.map(sns.scatterplot, 'NPHI', 'RHOB', linewidth=1, size=0.1, marker='+')<br/>g.set(xlim=(-0.15, 1))<br/>g.set(ylim=(3, 1))<br/>g.add_legend()</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/93f46edc815d885b89c4363fb6968529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilv7KNYjWNxPKLDHVW8New.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">按地质组划分密度-中子数据网格，并按岩性着色</p></figure><p id="a63a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从该图中，我们可以很快看出Rotliegendes Gp主要是砂岩，而Nordaland Gp是页岩和砂岩/页岩岩性的混合物。</p><h2 id="6084" class="ne lt it bd lu nm nn dn ly no np dp mc kr nq nr mg kv ns nt mk kz nu nv mo nw bi translated">Seaborn配对图</h2><p id="816a" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">Seaborn库还有一个非常强大的可视化功能，称为pairplot，可以通过一行代码调用。这允许我们在一个网格上比较多个列/测量值。matplotlib中的等效代码会扩展几行。</p><p id="5a85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在显示配对图之前，我们需要修改我们正在使用的数据。首先，我们将使用由一些常用测井记录组成的数据子集。如果我们使用本文示例中的所有列，我们将无法查看详细信息。其次，我们需要删除任何丢失的数据值，否则在绘图时会出现问题。</p><p id="5c0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建我们想要的曲线列表:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="677a" class="ne lt it na b gy nf ng l nh ni">key_logs = ['CALI', 'GR', 'NPHI', 'RHOB', 'PEF', 'RDEP', 'RMED', 'DTC', 'DTS']</span></pre><p id="fae0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以提取数据的一个子集:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="c5cc" class="ne lt it na b gy nf ng l nh ni">subset = data[key_logs]<br/>subset = subset.dropna()</span></pre><p id="77d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们有了关键曲线的列表，我们可以将它传递给pair图中的<code class="fe nj nk nl na b">vars </code>参数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7262" class="ne lt it na b gy nf ng l nh ni">sns.pairplot(subset, vars=key_logs, diag_kind='hist', plot_kws={'alpha':0.6, 'edgecolor':'k'})</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/556168af39fbdc9e9081e3c84d999619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MPcjELmeaQqAf-XZOpzzQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">我们的油井数据对绘图。直方图沿着每条对数曲线分布的对角线。</p></figure><p id="40f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将生成多个散点图，每条曲线沿对角线有一个直方图。如您所见，这使我们能够快速了解不同测井曲线之间的数据分布和关联。很厉害的剧情！</p><h1 id="d3f3" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">识别不良井眼数据</h1><p id="2781" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在本节中，我们将简要介绍一种方法，该方法可以直观地显示因井眼扩大而产生的井眼数据。井眼壁的劣化可能因多种原因而发生，包括欠压实岩石和作用在这些岩石上的应力变化，如泥浆比重的变化。</p><p id="d98a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如缺失数据部分所述，我们只有10口井有钻头尺寸曲线。因此，将不对2口井进行绘图。我们可以使用bitsize曲线和caliper曲线来创建一个不同的caliper。负数表示井眼尺寸缩小(例如页岩膨胀)，正数表示井眼尺寸增大。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6806" class="ne lt it na b gy nf ng l nh ni">data['DIF_CAL'] = data['CALI'] - data['BS']</span></pre><p id="5251" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们将使用matplotlib绘制这些图，我们首先需要按井对数据帧进行分组:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bf3d" class="ne lt it na b gy nf ng l nh ni">grouped = data.groupby('WELL')</span></pre><p id="f41d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后计算我们绘图所需的行数:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2902" class="ne lt it na b gy nf ng l nh ni">nrows = int(math.ceil(len(grouped)/3.))</span></pre><p id="5a03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以使用一个小的for循环来遍历每个井，并在我们的图中添加一个密度与中子的子图。<code class="fe nj nk nl na b">df.plot</code>中的<code class="fe nj nk nl na b">c</code>参数允许我们在数据帧中指定一列来给数据着色。在这种情况下，我们将使用我们计算的DIF _卡尔数据。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7518" class="ne lt it na b gy nf ng l nh ni">fig, axs = plt.subplots(nrows, 3, figsize=(20,20))<br/>for (name, df), ax in zip(grouped, axs.flat):<br/>    df.plot(kind='scatter', x='NPHI', y='RHOB', ax=ax, c='DIF_CAL', cmap='jet', vmin=-1, vmax=10)<br/>    ax.set_xlim(-0.15,1)<br/>    ax.set_ylim(3,1)<br/>    ax.set_title(name)<br/>plt.tight_layout()</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/27ddff078eec39f1a29c799daf6915a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3sSSSxrSGEEerlD__AcWNQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">密度-中子测井数据的多井图，用计算的差分井径曲线着色。</p></figure><p id="7d3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速浏览一下，我们可以看到我们可能对两口井的数据有问题:15/9–15和16/1–2。这些应该进一步调查。</p><p id="59cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以把同样的想法应用到我们的岩性上。如果我们发现某个岩性受到了不良井眼条件的严重影响，那么在尝试使用机器学习算法预测该岩性时，可能会出现潜在的后果。</p><p id="ac12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们通过LITH对数据进行分组，并使用与上面相同的绘图逻辑。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8a63" class="ne lt it na b gy nf ng l nh ni"># Determine number of rows<br/>nrows = int(math.ceil(len(grouped)/3.))</span><span id="2519" class="ne lt it na b gy nz ng l nh ni"># Group our data<br/>grouped_lith = data.groupby('LITH')</span><span id="caac" class="ne lt it na b gy nz ng l nh ni"># Plot our data<br/>fig, axs = plt.subplots(nrows, 3, figsize=(20,20))<br/>for (name, df), ax in zip(grouped_lith, axs.flat):<br/>    df.plot(kind='scatter', x='NPHI', y='RHOB', c='DIF_CAL', cmap='jet', ax=ax, vmin=-1, vmax=10)<br/>    ax.set_xlim(-0.05,1)<br/>    ax.set_ylim(3,0)<br/>    ax.set_title(name)<br/>plt.tight_layout()</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/1c54740233712626026255aa9cdd9a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5MDyPTqE2W5Fc4ZqmilhA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">密度-中子测井数据的多井图，按岩性划分，用计算的井径差曲线着色。</p></figure><p id="db5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从图中我们可以看出，所有岩性都有很大程度的“好”数据。</p><h1 id="3cf2" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="53d4" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在本文中，我们介绍了使用常见Python库探索和可视化测井数据的三种方法。我们已经看到了如何使用Seaborn在单个图形上快速绘制多个数据集，并按井和岩性分割数据。我们还看到了如何快速识别缺失数据和受井眼条件影响的数据。</p><p id="5834" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">探索数据是熟悉和理解数据的一个很好的方式，尤其是在进行机器学习或进一步解释之前。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="1d08" class="ls lt it bd lu lv on lx ly lz oo mb mc md op mf mg mh oq mj mk ml or mn mo mp bi translated">参考</h1><p id="9c47" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">鲍曼，奥桑德，迪里布，迪辛顿，曼拉尔，2020。2020原力机器学习大赛。<a class="ae kf" href="https://github.com/bolgebrygg/Force-2020-Machine-Learning-competition" rel="noopener ugc nofollow" target="_blank">https://github . com/bolgebrygg/Force-2020-机器学习-竞赛</a></p><p id="4555" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">力:机器预测的岩性:【https://xeek.ai/challenges/force-well-logs/overview T2】</p></div></div>    
</body>
</html>