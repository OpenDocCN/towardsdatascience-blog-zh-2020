<html>
<head>
<title>Object-Oriented Programming: A Practical Introduction (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程:实用介绍(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-oriented-programming-a-practical-introduction-part-2-f376bc25f839?source=collection_archive---------53-----------------------#2020-10-09">https://towardsdatascience.com/object-oriented-programming-a-practical-introduction-part-2-f376bc25f839?source=collection_archive---------53-----------------------#2020-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/37e0c3303893e990001746a6a6a5b671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AhPhmEE5tB77pCjU"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">凯利·麦克林托克</p></figure><p id="8502" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本系列的第1部分中，您看到了一些如何使用面向对象编程(OOP)来帮助您解决一些代码设计问题的实际例子。如果你错过了，就在这里:</p><div class="lb lc gp gr ld le"><a rel="noopener follow" target="_blank" href="/object-oriented-programming-a-practical-introduction-part-1-a6755b9cee72"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">面向对象编程:实用介绍(第一部分)</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">面向对象编程是现代软件工程工具箱中的一个主要部分。这篇文章给出了一个温柔的…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">towardsdatascience.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><p id="218c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，我们开始吧。</p><h1 id="0459" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">变得技术化</h1><p id="50a9" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">面向对象的语言看起来令人生畏。您已经在第1部分的示例中看到了一些这种语言，但是让我们把它变得更具体一些。首先，让我们从最基本的问题开始:一个<code class="fe mw mx my mz b">class</code>和一个<code class="fe mw mx my mz b">object</code>之间有什么区别？</p><ul class=""><li id="8292" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated"><strong class="kf ir">类</strong> —给定结构可用的数据和程序的<em class="nj">定义</em>。换句话说，一个类定义了它引用什么数据，以及什么过程(方法)可以用在这些数据上。</li><li id="ea90" class="na nb iq kf b kg nk kk nl ko nm ks nn kw no la nf ng nh ni bi translated"><strong class="kf ir">对象</strong> —类的具体<em class="nj">实例</em>。例如，在上面的例子中，你<em class="nj">定义了</em>类<code class="fe mw mx my mz b">Rectangle</code>，并实例化了这个类以产生一个<code class="fe mw mx my mz b">Rectangle</code>对象(例如<code class="fe mw mx my mz b">Rectangle(10, 5)</code>)。</li></ul><p id="c692" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my mz b">class</code>方法和变量与<code class="fe mw mx my mz b">instance</code>方法和变量之间也有一些重要的区别，它们会对代码的行为产生影响:</p><ul class=""><li id="942a" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated"><strong class="kf ir">实例变量— </strong>这些是“属于”一个类的每个实例的数据元素(即对象，例如<code class="fe mw mx my mz b">Rectangle</code>类上的<code class="fe mw mx my mz b">length</code>和<code class="fe mw mx my mz b">width</code>变量)。</li><li id="4cae" class="na nb iq kf b kg nk kk nl ko nm ks nn kw no la nf ng nh ni bi translated"><strong class="kf ir">类变量</strong>——这些是“属于”一个类的所有实例的数据元素——该类的所有<em class="nj">实例都有一个副本。</em></li></ul><p id="345d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了澄清这一点，我们来看看两者之间的区别:</p><pre class="np nq nr ns gt nt mz nu nv aw nw bi"><span id="d18f" class="nx lu iq mz b gy ny nz l oa ob">class NewCircle(Shape): <br/>    pi = math.pi </span><span id="d369" class="nx lu iq mz b gy oc nz l oa ob">    def __init__(self, radius: float) -&gt; None: <br/>        self.radius = radius </span><span id="34ea" class="nx lu iq mz b gy oc nz l oa ob">    def area(self) -&gt; float: <br/>        return self.pi * self.radius ** 2</span></pre><p id="7380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，<code class="fe mw mx my mz b">pi</code>是一个<em class="nj">类变量</em>，而<code class="fe mw mx my mz b">radius</code>是一个<em class="nj">实例</em>变量。实际上，<code class="fe mw mx my mz b">pi</code>是由所有类共享的，所以如果你这样做:</p><pre class="np nq nr ns gt nt mz nu nv aw nw bi"><span id="c75c" class="nx lu iq mz b gy ny nz l oa ob">a, b = NewCircle(1), NewCircle(1) <br/>print(a.area(), b.area()) # 3.141592653589793 3.141592653589793 NewCircle.pi = 3.14 # this changes `pi` on both `a` and `b`. print(a.area(), b.area()) # 3.14 3.14</span></pre><p id="16f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会看到用<code class="fe mw mx my mz b">NewCircle.pi</code>更新类变量改变了<em class="nj">和</em>两个圆的面积，而:</p><pre class="np nq nr ns gt nt mz nu nv aw nw bi"><span id="6c21" class="nx lu iq mz b gy ny nz l oa ob">a, b = NewCircle(1), NewCircle(1) <br/>print(a.area(), b.area()) # 3.141592653589793 3.141592653589793 <br/>a.pi = 3 # update only the copy of `pi` on the instance `a`. print(a.area(), b.area()) # 3 3.141592653589793</span></pre><p id="04ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nj">只会在属于这个类的<code class="fe mw mx my mz b">a</code>实例的<code class="fe mw mx my mz b">pi</code>的副本上</em>修改<code class="fe mw mx my mz b">pi</code>。</p><p id="f46c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对数据操作<em class="nj">的<em class="nj">方法— </em>事物<em class="nj"/>怎么样？正如你在<a class="ae kc" href="https://mark.douthwaite.io/object-oriented-programming-a-whistlestop-tour/" rel="noopener ugc nofollow" target="_blank">第1部分</a>中看到的，方法可以被认为是一个类的成员(即“属于”)的函数。有两个特别重要的例子反映了上面的变量定义:</em></p><ul class=""><li id="f8fa" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated"><strong class="kf ir">实例方法</strong> —很像<em class="nj">实例变量</em>，实例<em class="nj">方法</em>‘属于’个别对象。这些方法可以访问<em class="nj">封装的数据和方法</em>成为对象，包括其他方法、实例变量和类变量。</li><li id="e3b5" class="na nb iq kf b kg nk kk nl ko nm ks nn kw no la nf ng nh ni bi translated"><strong class="kf ir">类方法— </strong>相比之下，类<em class="nj">方法</em>是对一个类的所有实例都可用的方法，但是只能访问该类的其他类方法和类实例。</li></ul><p id="6bd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python支持类方法(以及一些其他种类的方法)，但是理解它们在Python中的使用需要对一些中级Python语言特性(包括<a class="ae kc" href="https://www.python.org/dev/peps/pep-0318/" rel="noopener ugc nofollow" target="_blank"> <em class="nj">装饰器</em> </a>)有扎实的理解，所以关于这些的示例和讨论将留到以后的文章中。</p><p id="e026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在正式介绍OOP的一些更大的概念。</p><h1 id="d19f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">包装</h1><p id="8d3f" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在第1部分的例子中，你看到了<code class="fe mw mx my mz b">Rectangle</code>类的定义。概括来说，您有:</p><pre class="np nq nr ns gt nt mz nu nv aw nw bi"><span id="232c" class="nx lu iq mz b gy ny nz l oa ob">class Rectangle(Shape): <br/>    def __init__(self, length: float, width: float) -&gt; None: <br/>        self.length = length <br/>        self.width = width </span><span id="d2ae" class="nx lu iq mz b gy oc nz l oa ob">    def area(self) -&gt; float: <br/>        return self.length * self.width </span><span id="2174" class="nx lu iq mz b gy oc nz l oa ob">    def perimeter(self) -&gt; float: <br/>        return (self.length + self.width) * 2.0</span></pre><p id="78e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在OOP中，<em class="nj">封装</em>指的是将数据和函数(方法)捆绑成一个单一的结构(一个类)。实际上，封装用于隐藏对象的状态。这种信息隐藏的一部分包括定义如何访问特定的变量和方法，以限制误用并确保稳定性。这就是某些语言中使用的<em class="nj">公共</em>、<em class="nj">受保护</em>和<em class="nj">私有</em>‘访问修饰符’概念的由来。让我们来看看这意味着什么。</p><p id="fa9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里的例子中，<code class="fe mw mx my mz b">Rectangle</code>中的所有实例变量和方法都可以描述为<em class="nj"> public - </em>它们对于与任何<code class="fe mw mx my mz b">Rectangle</code>实例交互的任何代码都是“可见的”(可访问的)。然而，如果您决定不希望您的用户在实例化了一个<code class="fe mw mx my mz b">Rectangle</code>之后干扰<code class="fe mw mx my mz b">length</code>和<code class="fe mw mx my mz b">width</code>实例变量<em class="nj">，会发生什么呢？一种方法是将你的变量和方法<em class="nj">保护起来</em>或者<em class="nj">私有</em>。这将防止(或者在Python中某些情况下<em class="nj">阻止</em>直接使用<code class="fe mw mx my mz b">Rectangle</code>的人访问<code class="fe mw mx my mz b">length</code>和<code class="fe mw mx my mz b">width</code>。具体地说，您可以将一个类的成员定义为具有三种访问级别之一:</em></p><ul class=""><li id="c23c" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated"><strong class="kf ir"> Public </strong> —对任何使用该类的代码可见。</li><li id="01e0" class="na nb iq kf b kg nk kk nl ko nm ks nn kw no la nf ng nh ni bi translated"><strong class="kf ir"> Protected </strong> —仅对定义该成员的类以及该类的所有子类可见。</li><li id="b331" class="na nb iq kf b kg nk kk nl ko nm ks nn kw no la nf ng nh ni bi translated"><strong class="kf ir">私有— </strong>仅对定义成员的类可见。</li></ul><p id="63c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，其他语言也可以有额外的访问(<a class="ae kc" href="https://www.w3schools.com/java/java_modifiers.asp" rel="noopener ugc nofollow" target="_blank">或非访问</a>)修饰符。这在Python 中是如何工作的？下面是上述<code class="fe mw mx my mz b">Rectangle</code>片段的修改版本:</p><pre class="np nq nr ns gt nt mz nu nv aw nw bi"><span id="ecf3" class="nx lu iq mz b gy ny nz l oa ob">class Rectangle(Shape): <br/>    def __init__(self, length: float, width: float) -&gt; None: <br/>         self._length = length <br/>         self.__width = width </span><span id="e356" class="nx lu iq mz b gy oc nz l oa ob">    def area(self) -&gt; float: <br/>         return self._length * self.__width <br/> <br/>    def perimeter(self) -&gt; float: <br/>         return (self._length + self.__width) * 2.0</span></pre><p id="38ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个代码片段<a class="ae kc" href="https://www.python.org/dev/peps/pep-0008/#designing-for-inheritance" rel="noopener ugc nofollow" target="_blank">遵循Python约定</a>，现在表明<code class="fe mw mx my mz b">_length</code>实例变量是一个受保护的成员(即可以被子类访问)并且<code class="fe mw mx my mz b">__width</code>是一个<em class="nj">私有</em>成员(即只能被<code class="fe mw mx my mz b">Rectangle</code>访问)。这表明如果您要创建<code class="fe mw mx my mz b">class Square(Rectangle)</code>，这个新类根本不能使用<code class="fe mw mx my mz b">width</code>变量。</p><p id="db04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，你不应该在<code class="fe mw mx my mz b">Rectangle</code>的实例上访问变量<code class="fe mw mx my mz b">_length</code>(例如<code class="fe mw mx my mz b">Rectangle(10, 5)._length</code>)。如果你正在使用棉绒，你会注意到如果你试图违反这些规则，它会给你警告。此外，虽然Python不以传统方式强制<em class="nj">保护的</em>或<em class="nj">私有的</em>成员，但是许多语言都这样做，并且控制对所述成员的访问的能力(即使在Python的更有限的方法中)可能是一个有用的设计特性。</p><p id="6d74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，将计算中的中间步骤分解成不同的<em class="nj">受保护的</em>方法是有用的，但是只公开一个<em class="nj">公共</em>方法供用户使用。换句话说:<em class="nj">隐藏终端用户不应该访问的</em>实现细节，只暴露那些他们<em class="nj">应该</em>访问的细节。</p><p id="462e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，只让方法<em class="nj">的最小子集成为公共方法</em>通常是个好主意(或者相反，你应该默认让变量和方法<em class="nj">成为受保护的</em>，除非你有特定的理由让它们成为公共的)。这有助于保持用户与类交互的方式尽可能的窄，这反过来减少了您向他们展示的API的“表面区域”,这通常会减少支持和维护该API所需的开发工作。</p><h1 id="91d1" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">多态性</h1><p id="4e20" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">让我们再一次回顾第1部分中重构的<code class="fe mw mx my mz b">Shape</code>示例:</p><pre class="np nq nr ns gt nt mz nu nv aw nw bi"><span id="a2fe" class="nx lu iq mz b gy ny nz l oa ob">class Shape: <br/>    def area(self) -&gt; float: ... <br/></span><span id="ebb9" class="nx lu iq mz b gy oc nz l oa ob">class Rectangle(Shape): <br/>    def __init__(self, length: float, width: float) -&gt; None: ... </span><span id="7295" class="nx lu iq mz b gy oc nz l oa ob">    def area(self) -&gt; float: ... <br/></span><span id="728c" class="nx lu iq mz b gy oc nz l oa ob">class Triangle(Shape): <br/>    def __init__(self, base: float, height: float) -&gt; None: ... </span><span id="c696" class="nx lu iq mz b gy oc nz l oa ob">    def area(self) -&gt; float: ... </span><span id="892e" class="nx lu iq mz b gy oc nz l oa ob">shapes = [Rectangle(5, 10), Triangle(1, 2)] </span><span id="ceaa" class="nx lu iq mz b gy oc nz l oa ob">area = 0 </span><span id="5b84" class="nx lu iq mz b gy oc nz l oa ob">for shape in shapes: <br/>    area += shape.area()</span></pre><p id="3f5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个片段捕获了与<em class="nj">多态性</em>概念相关的一些关键思想。技术上，多态是指不同<em class="nj">类型</em>的对象可以公开一个<em class="nj">单个</em>接口的概念。在这里的示例代码中，<code class="fe mw mx my mz b">Rectangle</code>和<code class="fe mw mx my mz b">Triangle</code>都公开了相同的方法，因此调用这些方法的代码<em class="nj">可以与它所操作的对象的<em class="nj">类型</em>无关。换句话说，你在列表<code class="fe mw mx my mz b">shapes</code>上的循环只需要保证它所操作的对象实现了<code class="fe mw mx my mz b">Shape</code>接口，如果它们实现了，那么它总是工作得很好。</em></p><p id="fdfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个非常强大的概念。如果使用得当，它允许您构建干净的、可扩展的API，这些API易于使用且易于调试。这个特定的概念被用作许多流行框架的基础:公开的接口捕获一个领域或问题的模型，然后您可以与它交互或扩展它。</p><p id="4235" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具体来说，以一个流行的机器学习(ML)库为例，比如<a class="ae kc" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>。如果你曾经使用过这个库，你无疑会熟悉描述库中模型特征的经典<code class="fe mw mx my mz b">fit</code>和<code class="fe mw mx my mz b">predict</code>方法(以及其他方法)。这个接口简单明了——如果有时有限制(通过定义什么东西<em class="nj">是</em>，你也最终定义了什么东西<em class="nj">不是</em>),并且允许用户构建利用它的ML管道，而不用担心管道使用的特定模型变量(事实上，这正是<a class="ae kc" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn Pipelines </a>所做的！).</p><blockquote class="od oe of"><p id="c2a4" class="kd ke nj kf b kg kh ki kj kk kl km kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated"><em class="iq"> …通过定义什么东西</em> <strong class="kf ir">是</strong> <em class="iq">，你也经常最终定义什么东西</em> <strong class="kf ir">不是</strong>，毕竟<em class="iq">。</em></p></blockquote><p id="1f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，其他提供者可以实现他们自己的符合该接口的模型版本，这些版本又可以立即用于任何使用Scikit-Learn模型的管道设置中。您可能还记得其他流行的库，如<a class="ae kc" href="https://lightgbm.readthedocs.io/en/latest/Python-API.html#scikit-learn-api" rel="noopener ugc nofollow" target="_blank"> LightGBM </a>、<a class="ae kc" href="https://xgboost.readthedocs.io/en/latest/python/python_api.html#module-xgboost.sklearn" rel="noopener ugc nofollow" target="_blank"> XGBoost </a>和<a class="ae kc" href="https://www.tensorflow.org/api_docs/python/tf/keras/wrappers/scikit_learn" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>提供了Scikit-Learn兼容的接口。这是为什么存在如此活跃的Scikit-Learn兼容工具生态系统的部分原因，也是为什么从工程角度来看这个事实如此有用(和重要):它帮助您将您实际使用 a模型所做的事情的逻辑与特定模型变体的实现细节分开。这(部分)是通过多态性实现的。</p><p id="5d56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对更正式地理解各种形式的多态性背后的思想感兴趣，你可能会发现阅读与<a class="ae kc" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-088-introduction-to-c-memory-management-and-c-object-oriented-programming-january-iap-2010/lecture-notes/MIT6_088IAP10_lec05.pdf" rel="noopener ugc nofollow" target="_blank">相关的思想</a>，包括<a class="ae kc" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-088-introduction-to-c-memory-management-and-c-object-oriented-programming-january-iap-2010/lecture-notes/MIT6_088IAP10_lec06.pdf" rel="noopener ugc nofollow" target="_blank">利斯科夫替代原理</a>，会很有帮助。此外，多态性有时会被误认为是OOP本身的一个特定方面。相反，它是一个更通用的编程概念，并且可以在各种形式的许多不同范例中找到变体，包括函数式编程(另一个杰出的编程范例)。</p><h1 id="05c0" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">遗产</h1><p id="a288" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">OOP的第三个主要特征是<em class="nj">继承。</em>这里的关键思想是继承允许你表达类之间的“是一种类型”的关系。例如，在<a class="ae kc" href="https://mark.douthwaite.io/object-oriented-programming-a-whistlestop-tour/" rel="noopener ugc nofollow" target="_blank">第1部分</a>中看到的<code class="fe mw mx my mz b">Shape</code>示例中，您可以将关系<code class="fe mw mx my mz b">class Triangle(Shape)</code>表达为:<code class="fe mw mx my mz b">Triangle</code> <em class="nj">是</em> <code class="fe mw mx my mz b">Shape</code>的一种类型。同样，你可以把<code class="fe mw mx my mz b">class RightTriangle(Triangle)</code>表达为:<code class="fe mw mx my mz b">RightTriangle</code> <em class="nj">是</em> <code class="fe mw mx my mz b">Triangle</code>的一种。然后，您可能会开始看到您正在构建一个类的层次结构。在这个简单的例子中，您会看到这样的内容:</p><figure class="np nq nr ns gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/982d4955b83d25f38bb7b9dce8f7b8aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*iR03MctPRaowmulgtZOKDQ.png"/></div></figure><p id="6611" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种层次结构中的“根节点”(即本例中的<code class="fe mw mx my mz b">Shape</code>)通常被称为<em class="nj">基类</em>。这些类是抽象的<em class="nj"/>也是很常见的:它们不指定自己的实现，而是定义一个接口(也许是部分实现)。抽象类不是设计来直接实例化的:<em class="nj">它是设计来子类化的</em>。许多语言积极地强调这一事实，并阻止你试图直接实例化一个抽象类。<a class="ae kc" href="https://docs.python.org/3/library/abc.html" rel="noopener ugc nofollow" target="_blank">这种行为也可以在Python中实现</a>。在这些类上定义的不提供实现的方法(如示例中的<code class="fe mw mx my mz b">area</code>)被称为<em class="nj">抽象方法</em>(或者在某些语言/上下文中等同于<em class="nj">虚拟方法</em>)。</p><p id="c7ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更具体一点，抽象类可以定义为:</p><ul class=""><li id="da71" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated"><strong class="kf ir">抽象类</strong> —具有一个或多个抽象方法的类。</li></ul><p id="1b30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么为什么<em class="nj">这个</em>有用呢？继承(理论上)使您能够轻松地扩展和修改类，从而可以更容易地向代码中添加特性和功能。以上面的例子为例:你看到了<code class="fe mw mx my mz b">Triangle</code>类是如何被扩展的，在两种新类型的<code class="fe mw mx my mz b">Triangle</code>上快速方便地实现一个新方法<code class="fe mw mx my mz b">perimeter</code>，而不需要“接触”父<code class="fe mw mx my mz b">Triangle</code>类。</p><p id="da52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会看到如何在业务环境中使用它:您可以选择捕获不同类型的客户、交易或其他业务实体作为一个类层次结构，然后使用您在多态中看到的思想创建一些好的通用业务逻辑来操作这些不同类型的对象。你当然应该探索这个想法，但要谨慎行事。</p><h1 id="6d70" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">深入挖掘</h1><p id="2ef5" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">这篇文章实际上只是触及了OOP的皮毛:它是一个很大的领域，有大量的工具、思想和实现来支撑它在现代软件项目中的使用。如果你选择深入OOP的世界，你会发现某些血统的语言(例如C++，Java)之间有很多相似之处，也有一些区别。一些语言和工具有意采用了这里讨论的特性的特定子集，而其他语言和工具也实现了更复杂的版本。如果你花时间学习这些思想——特别是跨语言的<em class="nj">来帮助你比较和对比思想和方法——你会发现OOP是你编程工具箱中的一个无价工具。然而…</em></p><h2 id="2a10" class="nx lu iq bd lv ok ol dn lz om on dp md ko oo op mh ks oq or ml kw os ot mp ou bi translated">一句警告</h2><p id="f5e6" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">到目前为止，你已经看到了OOP如何被用来<em class="nj">帮助</em>你构建和解决问题。在有经验的人看来，这是一个强有力的工具。然而，当不加选择地使用时，OOP可能会成为<em class="nj">的问题</em>。不恰当/过度地使用OOP概念和能力很容易对你不利。正如在学习新知识和新技能时的情况一样，对于不熟悉OOP概念的人来说，落入“锤子定律”设置的陷阱是很常见的:当你有一把锤子时，一切看起来都像钉子。</p><blockquote class="od oe of"><p id="90b1" class="kd ke nj kf b kg kh ki kj kk kl km kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated"><em class="iq"> …对于不熟悉OOP概念的人来说，落入“锤子定律”的陷阱是很常见的:当你有一把锤子时，一切看起来都像钉子。</em></p></blockquote><p id="8d24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，你在上面看到的封装、多态和继承的完全相同的特性会<em class="nj">增加</em>复杂性，并且<em class="nj">阻碍</em>你的代码的调试、性能和维护，如果你不小心和没有预先考虑就使用它们的话。例如，过度复杂和/或设计不良的类层次结构是开发团队最终陷入困境的常见方式——他们的类层次结构可能会变成难以推理和技术上难以扩展的大型复杂结构。</p><p id="508a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与任何技能一样，理解何时以及如何应用OOP概念来自实践，坦率地说，来自偶尔的失败。您将使一些代码变得不必要的复杂和笨拙。你很可能会打碎东西。最终，你需要将OOP的思想应用到你自己的问题中几次，然后你才能感觉到什么可行，什么不可行。此外，对概念的“纯粹”技术理解是不够的:当你开始一个新项目(或加入一个现有项目)时，你需要记住后退一步，思考更大的图景，以及如何最好地使用可用的工具。</p><h1 id="ab74" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">结束语</h1><p id="3bde" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">正如您所看到的，OOP提供的概念和OO语言特性的具体实现可以帮助您设计和实现代码，以非常优雅的方式运行。然而，从某种意义上来说，它们并没有增加任何“新”东西:你可以编写代码来解决你可能面临的任何问题，而不需要<em class="nj">去使用OOP提供的工具。也就是说，<em class="nj">明智地</em>使用面向对象的思想可能会让你成为一个更加<em class="nj">高效的</em>程序员，并且可能会让别人更容易<em class="nj">采用</em>和<em class="nj">重用</em>你的代码。此外，很好地掌握OOP还将帮助你更好地理解和推理许多流行软件框架的行为和设计。</em></p><blockquote class="od oe of"><p id="3216" class="kd ke nj kf b kg kh ki kj kk kl km kn og kp kq kr oh kt ku kv oi kx ky kz la ij bi translated">很好地掌握OOP也将帮助你更好地理解和推理许多流行软件框架的行为和设计。</p></blockquote><p id="24c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和往常一样，知道何时使用特定的工具(并准备好工具等待使用)是一项需要培养的宝贵技能。重要的是，你要尝试和思考如何以及在哪里将面向对象的思想应用到你自己的工作中。例如，如果您确定您正在编写一个一次性问题的解决方案，那么创建一个复杂的类层次结构很可能会过度设计您的解决方案<em class="nj">和</em>，产生比它解决的问题更多的问题。然而，如果你开始一个你知道会被广泛使用和扩展的项目，它可能<em class="nj">真的</em>会有回报。</p><h1 id="4c4f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">进一步阅读</h1><div class="lb lc gp gr ld le"><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">电气工程和计算机科学</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">麻省理工学院的电子工程和计算机科学系的毕业生工作在不同的行业和进行…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">ocw.mit.edu</p></div></div><div class="ln l"><div class="ov l lp lq lr ln ls jw le"/></div></div></a></div><div class="lb lc gp gr ld le"><a href="https://www.python.org/dev/peps/pep-0008/#designing-for-inheritance" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">PEP 8风格的Python代码指南</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">Python编程语言的官方主页</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">www.python.org</p></div></div><div class="ln l"><div class="ow l lp lq lr ln ls jw le"/></div></div></a></div></div><div class="ab cl ox oy hu oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="ij ik il im in"><p id="ca31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nj">原载于2020年10月9日</em><a class="ae kc" href="https://mark.douthwaite.io/object-oriented-programming-a-brief-practical-tour-part-2/" rel="noopener ugc nofollow" target="_blank"><em class="nj">https://mark . douthwaite . io</em></a><em class="nj">。</em></p></div></div>    
</body>
</html>