<html>
<head>
<title>Fire up your Centrality Metric engines: Neo4j vs NetworkX — a drag race, of sorts…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启动你的中心性度量引擎:Neo4j vs NetworkX——一场各种各样的拉力赛…</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fire-up-your-centrality-metric-engines-neo4j-vs-networkx-a-drag-race-of-sorts-18857f25be35?source=collection_archive---------25-----------------------#2020-11-06">https://towardsdatascience.com/fire-up-your-centrality-metric-engines-neo4j-vs-networkx-a-drag-race-of-sorts-18857f25be35?source=collection_archive---------25-----------------------#2020-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/393a1e8e432d659347f5dfff3624284b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fHNIPZ7c_uCPgbmmhc-0Q.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">埃洛伊·卡拉斯科在<a class="ae kc" href="https://unsplash.com/s/photos/drag-race?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f477" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我和Mark Needham在Python NetworkX包和<a class="ae kc" href="https://neo4j.com/developer/graph-data-science/" rel="noopener ugc nofollow" target="_blank"> Neo4j图形数据科学库</a>之间进行了一场赛跑。在这场比赛中，我们让他们比赛，看谁在计算无向图的介数和调和中心度方面最快。我们还将使用<a class="ae kc" href="https://neo4j.com/developer/python/" rel="noopener ugc nofollow" target="_blank"> Neo4j Python驱动程序</a>，这样我们甚至不需要离开Python IDE的舒适环境。</p><p id="986d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">为什么选择NetworkX？</strong></p><p id="44bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NetworkX 包是最老的产品，早在2008年就发布了(…那时候Neo4j还在早餐喝热巧克力…)。从很多方面来看，它仍然是最流行的网络分析Python包，事实上，根据我们的统计，至少有四本关于网络分析的书籍使用NetworkX包作为他们的主力。</p><p id="ee22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">哪种中心性指标？</strong> <br/>如前所述，我们关注两个重要的网络中心性度量:中间性<a class="ae kc" href="https://en.wikipedia.org/wiki/Betweenness_centrality" rel="noopener ugc nofollow" target="_blank">和调和中心性</a><a class="ae kc" href="https://en.wikipedia.org/wiki/Harmonic" rel="noopener ugc nofollow" target="_blank">度量。介数度量基于通过它的最短路径的分数来测量节点的重要性，因此它也经常被视为它捕获了多少“信息流”。如下图所示:如果Alice离开，许多节点将会孤立。</a></p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/6b907440d1fd9e013a7ae659abc2110b.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*sJUH9ycMAJrcXMOtWfujkA.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://neo4j.com/docs/graph-algorithms/current/labs-algorithms/betweenness-centrality/" rel="noopener ugc nofollow" target="_blank"> Neo4j图像</a></p></figure><p id="64f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调和中心性度量是对接近度度量的改进，因此也是“基于距离”的度量，其中高分意味着该特定节点平均来说可以以更少的跳数到达其他节点。正如我们在前一篇文章中所讨论的；根据<a class="ae kc" href="https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686" rel="noopener ugc nofollow" target="_blank"> Boldi &amp; Vigna </a>的说法，这是一种“黄金标准”。</p><p id="addf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将本文分为两个主要部分:首先探索Neo4j数据库和Python驱动程序以及NetworkX算法的设置，在第二部分，我们对竞争对手的实际性能进行实验和评论。</p><h2 id="73f2" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">为比赛做准备…</h2><p id="c868" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">关于如何在Neo4j中创建数据库以及Python驱动程序的一个很棒的帖子是由<a class="ae kc" rel="noopener" target="_blank" href="/neo4j-cypher-python-7a919a372be7">杨</a>发表的。然而，我们要做的改变是让Neo4j Python驱动程序从数据库的“导入”目录中读取文件(与亦舒文章中的URL相反)。当我们想要对多个不同的文件执行网络分析时，这是很方便的，我们稍后将回到这一点。最后一步，我们通过“pip install neo4j”在我们的环境中安装Neo4j Python驱动程序，或者通过在PyCharm中将驱动程序作为一个包加载来更容易地安装。</p><h2 id="b67a" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">使用Neo4j Python驱动程序构建数据库。</h2><p id="7ac4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从下面的代码可以看出；只需几行简单的代码就可以访问Neo4j丰富的工具和功能。我们首先实例化驱动程序，其中参数是bolt连接器，我们可以在Neo4j浏览器中找到，然后是用户和密码的验证，这是我们在创建项目时建立的。</p><p id="f397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们定义希望驱动程序执行的Neo4j查询，这些查询需要用<a class="ae kc" href="https://neo4j.com/developer/cypher/" rel="noopener ugc nofollow" target="_blank">密码</a>语言编写。两个主要语句中的第一个将在图的节点上创建一个约束，以确保它是唯一的。该约束还将在Node(id)属性上创建一个索引，这将显著提高运行时间。第二个查询是创建数据库的标准Cypher语句，就像我们在Neo4j环境中使用的一样，我们还确保文件路径在文件名前引用了一个<strong class="kf ir"> file:/// </strong>前缀。</p><p id="0b9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在准备运行驱动程序会话，我们分两步执行。第一次运行使用“创建或替换数据库”语句，该语句针对系统数据库执行，并允许“动态”创建数据库。第二次运行执行约束创建语句和数据库导入语句。作为一项安全检查，我们还将节点算作一个查询。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="8166" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">在Neo4j中计算中心性度量</h2><p id="0645" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">插入数据后，我们可以使用Neo4j图形数据库(GDS)计算中心性指标。使用Cypher调用GDS过程没有什么特别之处，如下面的代码所示，当检索到相应的指标时，我们需要进行一些格式化，以便测量Neo4j和NetworkX输出之间的准确性。我们通过使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient" rel="noopener ugc nofollow" target="_blank"> Kendall Tau </a>度量，调用“scipy”库来实现这一点，该库要求两个列表在一个“numpy”数组中。为此，我们调用了我们的Pandas朋友，在那里我们对结果进行降序排序，然后需要格式化成一个numpy数组，以便在我们的准确性测试中使用。</p><p id="7d42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为安全措施，我们再次将数据保存到csv文件中。当然，这并不是绝对必要的，但是因为我们希望从一个脚本中运行所有的东西，其原因将在稍后变得清楚，当事情出错时，它将被证明是有价值的。</p><p id="e2c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们进入NetworkX引擎之前，先简单介绍一下我们使用的真实网络。从斯坦福的快照数据库中，我们选择了http://snap.stanford.edu/data/gemsec-Deezer.html<a class="ae kc" href="http://snap.stanford.edu/data/gemsec-Deezer.html" rel="noopener ugc nofollow" target="_blank">的Deezer RO设置。这是一个友谊网络，无向，来自音乐流媒体服务Deezer，由41，773个节点和125，826条边组成。</a></p><h2 id="ca36" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">准备好我们的NetworkX引擎</h2><p id="d132" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们现在可以漫步到NextworkX pitlane。Deezer RO网络有一个简单的边列表，我们使用NetworkX函数来加载图形:</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="5b8c" class="lg lh iq mh b gy ml mm l mn mo">G = nx.read_edgelist(RW_network, nodetype=int, comments='#',<br/>                     delimiter=',', create_using=nx.Graph(), encoding='utf-8')</span></pre><p id="4fe3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NetworkX centrality函数同样简单明了:</p><pre class="lc ld le lf gt mg mh mi mj aw mk bi"><span id="f072" class="lg lh iq mh b gy ml mm l mn mo">HC_nx = nx.harmonic_centrality(G)<br/>BC_nx = nx.betweenness_centrality(G)</span></pre><p id="9d93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们再一次要求我们的熊猫朋友带来一些结构，但是我们也需要使值正常化。这里我们应用与Neo4j算法相同的方法，简单地除以节点数— 1。</p><p id="af57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个引擎都准备好了，我们可以将它们滚动到起始网格上，在下面的Python脚本中，我们对每个函数调用进行了计时:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="55fc" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">让游戏开始吧！</h2><p id="5442" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当按下绿色的“Run”按钮时，我们看到NetworkX首先在几秒钟内构建了图形，而Neo4j使用Python驱动程序花费了9.7秒。然而，对于NetworkX来说，这已经是最好的了。对于调和中心性，Neo4j GDS仅用了14秒就返回了41，773个中心性值…网络花了3，997秒穿过终点线…(即1小时6分钟)。当计算Kendall Tau时，两个列表完全匹配，得分为1.00。计算介数中心性变得有些尴尬——Neo4j在10秒内返回一点点值。NetworkX在15，284秒内爬完这条线，大约4小时15分钟。Kendall Tau的中间值为0.986，这只是略微偏离，可能是由于一些平局或浮点差异(使用的硬件:macOS，3.1 GHz双核英特尔酷睿i5，8GB内存)。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/d731d3b4442be0658d8b1e0f2eaf9a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1RAjQ0oEhUby7_8Eqyz1Jg.png"/></div></div></figure><h2 id="aa0a" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">对速度的需求</h2><p id="f28e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Neo4j GDS算法的神奇之处是双重的。对于谐波中心性，Neo4j GDS算法利用多源广度优先搜索方法，这是一种允许在单个CPU内核上对同一图形运行多个并发BFS的算法。运行介数中心性时，NetworkX算法在单线程上执行。相比之下，Neo4j GDS平均划分节点空间，然后对每个分区中的每个节点运行Brandes算法，因此它应用了多线程方法。</p><h2 id="ec4b" class="lg lh iq bd li lj lk dn ll lm ln dp lo ko lp lq lr ks ls lt lu kw lv lw lx ly bi translated">结论</h2><p id="2585" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">众所周知，NetworkX是一个相当慢的包，但这个练习表明，对于中型到大型无向图，Neo4j GDS成为首选引擎。此外，使用我们之前提到的更改Neo4j设置的便利技巧，可以完全使用Neo4j Python驱动程序来完成图表分析，因此它允许使用简单的Python循环对存储在“import”目录中的一组不同图表进行分析。使用NetworkX需要几天时间来分析的一组50-100k节点的图表，比如说20个，现在可以在几个小时内完成。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="3634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">王高·a·哈格伯格、丹尼尔·a·舒尔特和彼得·j·斯沃特，<a class="ae kc" href="http://conference.scipy.org/proceedings/SciPy2008/paper_2/" rel="noopener ugc nofollow" target="_blank">“使用NetworkX探索网络结构、动力学和功能”</a>，载于<a class="ae kc" href="http://conference.scipy.org/proceedings/SciPy2008/index.html" rel="noopener ugc nofollow" target="_blank">第七届Python科学会议论文集(SciPy2008) </a>，格尔·瓦洛夸、特拉维斯·沃特和贾罗德·米尔曼(编辑)，(美国加利福尼亚州帕萨迪纳)，第11–15页，2008年8月</p><p id="aaa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，Manuel等人《越多越好:高效多源图遍历》<em class="mx">VLDB基金会会议录</em>8.4(2014):449–460。</p></div></div>    
</body>
</html>