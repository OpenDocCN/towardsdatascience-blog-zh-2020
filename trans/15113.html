<html>
<head>
<title>Seminal Papers in Data Science: A Relational Model for Large Shared Data Banks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学的开创性论文:大型共享数据库的关系模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/seminal-papers-in-data-science-a-relational-model-for-large-shared-data-banks-892fccf97fd1?source=collection_archive---------34-----------------------#2020-10-17">https://towardsdatascience.com/seminal-papers-in-data-science-a-relational-model-for-large-shared-data-banks-892fccf97fd1?source=collection_archive---------34-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="27de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">50年后，回顾了e . f . Codd 1970年论文中的一些主要概念，这些概念为关系数据库和SQL奠定了基础</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1c2ba7ceab71f7c8d10342fd8904e195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wocp5jqIzoO_fKHB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弗兰基·查马基在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ab5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使NoSQL<a class="ae kv" href="https://scalegrid.io/blog/2019-database-trends-sql-vs-nosql-top-databases-single-vs-multiple-database-use/" rel="noopener ugc nofollow" target="_blank">越来越受欢迎，大多数公司仍然在使用某种形式的基于SQL的关系数据库管理系统</a>。虽然SQL(当时叫做SEQUEL)是由IBM的Donald D. Chamberlain和Raymond F. Boyce在1974年首次引入的，但是他们的工作是建立在Edgar F. Codd的思想之上的。Codd是另一位IBM计算机科学家，他在1970年提出了数据库管理的关系模型。在这篇文章中，我讨论了Codd有影响力的论文中的一些主要观点，以及他的观点如何与我们现代使用SQL相关联。</p><h2 id="156e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">关系</h2><p id="dab4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Codd使用术语<em class="mq">关系</em>来描述他的模型的基石。该关系正式描述如下:</p><blockquote class="mr ms mt"><p id="bbc0" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">给定集合S1，S2，…，Sn(不一定不同)，R是这n个集合上的一个关系，如果它是一个n元组的集合，每个元组的第一个元素来自S1，第二个元素来自S2，等等。我们将Sj称为R的第j个域。如上所述，R的阶数为n。阶数为1的关系通常称为一元关系、阶数为2的关系、阶数为3的关系和阶数为n的关系。</p><p id="2490" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">-Codd (1970年)</p></blockquote><p id="40cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个定义可能看起来完全陌生，但是如果您熟悉SQL，那么Codd实际上是指一些非常熟悉的东西。Codd建议可以基于以下条件将关系表示为数组:</p><blockquote class="mr ms mt"><p id="eadd" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">代表n元关系R的数组具有以下属性:</p><p id="09e1" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">(1)每行代表r的一个n元组。</p><p id="05b1" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">(2)行的顺序并不重要。</p><p id="b9a3" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">(3)所有行都是不同的。</p><p id="583d" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">(4)列的排序是重要的——它对应于定义R的定义域的S1，S2，…，Sn的排序(然而，参见下面关于定义域有序和定义域无序关系的注释)。</p><p id="358e" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">(5)通过用相应域的名称对其进行标记，来部分传达每个列的意义。"</p><p id="b4c2" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">-Codd (1970年)</p></blockquote><p id="b1d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Codd还展示了下面图1 中关系<em class="mq"> </em>的数组表示示例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/5df6056201494804ac7ca16aad4f268a.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*5Edp_X069wB7EuYmUz6m9A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Codd (1970年)</p></figure><p id="dbb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，Codd的关系数组表示与现代SQL表有许多相似之处。例如，上面的4度关系(或者，与四个域的关系)看起来类似于我们在SQL中称之为具有四列的表。这个表将被命名为<em class="mq"> supply </em>，Codd的域将对应于SQL列。SQL表也类似于Codd的关系，因为行的顺序并不重要，行是不同的，每一列都有标签。</p><p id="8a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，Codd的关系和SQL表之间有一个显著的区别:Codd规定列的排序是重要的，而在SQL中肯定不是这样。这与Codd的断言是一致的，即<em class="mq"> </em>关系的每一行都是一个<em class="mq">n</em>-元组——在SQL中，由于表的列顺序通常是不相关的，所以SQL表的每一行不需要都是元组。</p><p id="a62b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，为什么Codd会提出在关系中需要列排序呢？他用论文中的图2 给出了一个例子(见下文)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/033151a6c1a8c7ec63dfa7e92e742ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*MSrKK_u3pb_0o-SI9JrSJQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Codd (1970年)</p></figure><p id="9cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<strong class="ky ir">图2 </strong>中的组件关系中，Codd呈现了两个域(列)同名的情况——<em class="mq">part</em>。为了跟踪这两个<em class="mq">零件</em>列，为这些列分配一个固定的顺序是有意义的。虽然Codd在1970年的论文中认为这是一个合理的问题，但现在情况不同了，因为现代SQL数据库不允许同一个表中的两列具有相同的名称。</p><h2 id="5b27" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">规范化集合</h2><p id="0d8f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Codd将规范化称为从关系中消除非简单域。但是Codd所说的非简单域是什么意思呢？</p><blockquote class="mr ms mt"><p id="eedf" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">“非原子值可以在关系框架内讨论。因此，一些域可能具有作为元素的关系。反过来，这些关系可以在非简单域上定义，等等。”</p><p id="f5ac" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">-Codd (1970年)</p></blockquote><p id="0e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的<strong class="ky ir">图3(a) </strong>中，Codd通过绘制一组非规范化关系的树形图示例进一步阐述。<em class="mq">员工</em>关系由简单域<em class="mq">男号</em>、<em class="mq">姓名</em>、<em class="mq">生日</em>和非简单域<em class="mq">工作历史</em>和<em class="mq">子女</em>组成。这些非简单域本身可以被认为是关系，包含它们自己的简单和非简单域。</p><p id="e33f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Codd注意到，这种非规范化的关系集不能用一个二维数组来表示。但归一化后，这组关系可以表示为<strong class="ky ir">四个</strong>二维数组(见<strong class="ky ir">图3(b) </strong>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d338ca4a71c8a4e5835cb7796b33c31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*uqCaqU0yfq3QT0Sz-nNZ4g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Codd (1970年)</p></figure><p id="3c65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，究竟应该如何执行这种规范化呢？Codd阐述了:</p><blockquote class="mr ms mt"><p id="956a" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">从树顶部的关系开始，取其主键，并通过插入该主键域或域组合来展开每个直接的从属关系。每个扩展关系的主键由扩展前的主键和从父关系复制下来的主键组成。现在，从父关系中删除所有非简单域，删除树的顶部节点，并对每个剩余的子树重复相同的操作序列。”</p><p id="31bd" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">-Codd (1970年)</p></blockquote><p id="27a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，<strong class="ky ir">图3(a) </strong>中基于树的关系被转换为<strong class="ky ir">图3(b) </strong>中的规范化形式，去掉了非简单域，并且定义了一个主键来唯一标识每个关系中的行。主键可以是单个域(对于<em class="mq">雇员</em>关系为<em class="mq">人员# </em>)，也可以是多个域(对于<em class="mq">工作历史</em>关系为<em class="mq">人员#、工作日期</em>)。此外，每个关系可以使用<em class="mq"> man# </em>域相互交叉引用。这几乎类似于现代SQL模式中的一个基本概念——一个表的主键可以作为另一个表的外键，因此，当表保持独立的二维数组时，可以保留表之间的关系。</p><h2 id="2973" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">连接</h2><p id="16f4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Codd概述了许多可以在关系(表)上执行的操作，其中之一是连接。</p><blockquote class="mr ms mt"><p id="0f00" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">“假设我们有两个二元关系，它们有一些共同的领域。在什么情况下，我们可以将这些关系组合起来，形成一个三元关系，保留给定关系中的所有信息？”</p><p id="72d0" class="kw kx mq ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">-Codd (1970年)</p></blockquote><p id="7dd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Codd提供了两个关系<em class="mq"> R </em>和<em class="mq"> S </em>如何使用各自的<em class="mq"> part </em>域连接的示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5053c562db85a8587d877f22869d4cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*QNXs62naCzvbJZ2yhud0Tg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Codd (1970年)</p></figure><p id="27d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于每个关系的<em class="mq">零件</em>域具有不唯一的值，由于相同的<em class="mq">零件</em>值可能导致<em class="mq">供应商</em>和<em class="mq">项目</em>的多个组合，因此<em class="mq"> R </em>和<em class="mq"> S </em>的“自然连接”包含的行(5)比两个表(3)中的任何一个都多。</p><p id="e154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们假设<strong class="ky ir"> <em class="mq"> r </em> </strong>和<strong class="ky ir"> <em class="mq"> s </em> </strong> <em class="mq"> </em>是SQL数据库中的表，下面的SELECT语句将产生与Codd的“自然连接”相同的结果:</p><p id="025f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">从s.part = r.part上的r JOIN s中选择供应商、r.part、项目；</strong></p><p id="ec3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> SELECT * FROM r自然联接s；</strong></p><p id="f46c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在SQL中，自然联接默认执行与内部联接相同的任务，但是每个表中同名的列只会出现一次。</p><h2 id="697b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">关闭</h2><p id="3a31" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Codd 1970年的论文中还有很多我没有讨论的概念，但在这篇文章中我将把它们留在这里。如果您有兴趣进一步了解关系数据库和SQL的基础是如何形成的，请查阅下面参考资料中的文章。</p><h2 id="2bc5" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">参考</h2><div class="nb nc gp gr nd ne"><a href="https://scalegrid.io/blog/2019-database-trends-sql-vs-nosql-top-databases-single-vs-multiple-database-use/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">2019年数据库趋势- SQL与NoSQL、顶级数据库、单数据库与多数据库使用</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">想知道哪些数据库是2019年的趋势？我们询问了数百名开发人员、工程师、软件架构师、开发人员…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">scalegrid.io</p></div></div><div class="nn l"><div class="no l np nq nr nn ns kp ne"/></div></div></a></div><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div></div>    
</body>
</html>