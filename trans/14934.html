<html>
<head>
<title>How NOT to write pandas code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何不写熊猫代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-not-to-write-pandas-code-2cbda8b3816c?source=collection_archive---------12-----------------------#2020-10-14">https://towardsdatascience.com/how-not-to-write-pandas-code-2cbda8b3816c?source=collection_archive---------12-----------------------#2020-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="75b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">大部分“如何不”用熊猫编码的想法来自于我的开始。每一次失败后，我都会向熊猫展示一个正确的“方法”。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/19b4702202a11795a558d521fe306ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*F0TZSOZMcaLjehYP.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自<a class="ae ku" href="https://giphy.com/gifs/natgeowild-panda-nat-geo-wild-mission-critical-l3vRbgCJxtSXS9jFe" rel="noopener ugc nofollow" target="_blank"> Giphy </a>的《国家地理坠落的熊猫》</p></figure><p id="15f0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在过去的3年里，我一直用熊猫作为我数据分析的主要工具。我必须承认,“如何不用熊猫编码”的大部分内容都来自于我的开端。在进行代码评审时，我仍然看到许多经验丰富的程序员的“禁忌”。</p><p id="d239" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这篇文章中，我首先展示了一个“如何不”的例子，然后展示了一个正确的“如何”用熊猫计算统计数据的方法。</p><p id="34ad" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">改进的理由是简洁、更可读的代码和更快的执行速度。报告的时间格式为:<code class="fe lr ls lt lu b">831 ms ± 25.7 ms per loop</code>，表示平均831毫秒，标准偏差为25.7毫秒。每个代码样本执行多次，以计算准确的执行时间。</p><p id="9cee" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">这里有几个你可能会感兴趣的链接:</strong></p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="36b0" class="lz ma it lu b gy mb mc l md me">- <a class="ae ku" href="https://dataanalysis.substack.com/p/how-to-create-date-series-in-sql" rel="noopener ugc nofollow" target="_blank">How To Create Date Series in SQL</a> [Article]</span><span id="4cac" class="lz ma it lu b gy mf mc l md me">- <a class="ae ku" href="https://imp.i115008.net/c/2402645/880006/11298" rel="noopener ugc nofollow" target="_blank">Data Science for Business Leaders</a> [Course]</span><span id="dff9" class="lz ma it lu b gy mf mc l md me">- <a class="ae ku" href="https://imp.i115008.net/c/2402645/788201/11298" rel="noopener ugc nofollow" target="_blank">Intro to Machine Learning with PyTorch</a> [Course]</span><span id="2a1c" class="lz ma it lu b gy mf mc l md me">- <a class="ae ku" href="https://imp.i115008.net/c/2402645/803127/11298" rel="noopener ugc nofollow" target="_blank">Become a Growth Product Manager</a> [Course]</span><span id="eaad" class="lz ma it lu b gy mf mc l md me">- <a class="ae ku" href="https://aigents.co/skills" rel="noopener ugc nofollow" target="_blank">Free skill tests for Data Scientists &amp; Machine Learning Engineers</a></span></pre><p id="3897" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="mg">上面的一些链接是附属链接，如果你通过它们购买，我会赚取佣金。请记住，我链接课程是因为它们的质量，而不是因为我从你的购买中获得的佣金。</em></p><p id="4605" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要升级您的熊猫游戏，请参见:</p><div class="mh mi gp gr mj mk"><a href="https://medium.com/@romanorac/pandas-data-analysis-series-b8cec5b38b22" rel="noopener follow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">熊猫数据分析系列</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">从提示和技巧，如何不指南到与大数据分析相关的提示，熊猫文章的精选列表。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ko mk"/></div></div></a></div><h1 id="8d7d" class="mz ma it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">样本数据集</h1><p id="a5d6" class="pw-post-body-paragraph kv kw it kx b ky nq ju la lb nr jx ld le ns lg lh li nt lk ll lm nu lo lp lq im bi translated">示例数据集包含各个城市的预订信息。它是随机的，它的唯一目的是显示例子。</p><p id="c39e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据集有3列:</p><ul class=""><li id="f829" class="nv nw it kx b ky kz lb lc le nx li ny lm nz lq oa ob oc od bi translated"><strong class="kx iu"> id </strong>是唯一id，</li><li id="6e3f" class="nv nw it kx b ky oe lb of le og li oh lm oi lq oa ob oc od bi translated"><strong class="kx iu">城市</strong>是预订的城市，</li><li id="88f2" class="nv nw it kx b ky oe lb of le og li oh lm oi lq oa ob oc od bi translated"><strong class="kx iu"> booked_perc </strong>是某个时间的预订百分比。</li></ul><p id="c5c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">数据集具有10K条目，以使速度提高更加明显。如果以正确的方式编写代码，Pandas可以在数百万行的数据帧上计算统计数据。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="6289" class="lz ma it lu b gy mb mc l md me">import pandas as pd<br/>import numpy as np</span><span id="9dce" class="lz ma it lu b gy mf mc l md me">size <strong class="lu iu">=</strong> 10000</span><span id="7246" class="lz ma it lu b gy mf mc l md me">cities <strong class="lu iu">=</strong> ["paris", "barcelona", "berlin", "new york"]</span><span id="6487" class="lz ma it lu b gy mf mc l md me">df <strong class="lu iu">=</strong> pd<strong class="lu iu">.</strong>DataFrame(<br/>    {"city": np<strong class="lu iu">.</strong>random<strong class="lu iu">.</strong>choice(cities, size<strong class="lu iu">=</strong>size), "booked_perc": np<strong class="lu iu">.</strong>random<strong class="lu iu">.</strong>rand(size)}<br/>)<br/>df["id"] <strong class="lu iu">=</strong> df<strong class="lu iu">.</strong>index<strong class="lu iu">.</strong>map(str) <strong class="lu iu">+</strong> "-" <strong class="lu iu">+</strong> df<strong class="lu iu">.</strong>city<br/>df <strong class="lu iu">=</strong> df[["id", "city", "booked_perc"]]<br/>df<strong class="lu iu">.</strong>head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi oj"><img src="../Images/7132b5cb2cebe983cec79f49f462aacf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_mtqnKe8vM04YIjr0pHDg.png"/></div></div></figure><h1 id="fe53" class="mz ma it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">1.如何不对数据求和</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/723f70f562423c7b12b91de2a5303cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/0*T66oYadH43OlhGJ4.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自<a class="ae ku" href="https://www.reddit.com/r/gifs/comments/4invm5/rolling_panda/" rel="noopener ugc nofollow" target="_blank"> Reddit </a>的滚动熊猫</p></figure><p id="522e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我来自Java世界，我把“多行中的for循环”带到了Python。</p><p id="3e77" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们计算booked_perc列的总和—我知道对百分比求和没有意义，但我们还是要这样做:)</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="4967" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="e25e" class="lz ma it lu b gy mf mc l md me">suma <strong class="lu iu">=</strong> 0<br/><strong class="lu iu">for</strong> _, row <strong class="lu iu">in</strong> df<strong class="lu iu">.</strong>iterrows():<br/>    suma <strong class="lu iu">+=</strong> row<strong class="lu iu">.</strong>booked_perc</span><span id="e4d0" class="lz ma it lu b gy mf mc l md me">766 ms ± 20.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="d117" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对一列的值求和的更巧妙的方法是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="f2bd" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="698a" class="lz ma it lu b gy mf mc l md me">sum(booked_perc <strong class="lu iu">for</strong> booked_perc <strong class="lu iu">in</strong> df<strong class="lu iu">.</strong>booked_perc)</span><span id="9d1e" class="lz ma it lu b gy mf mc l md me">989 µs ± 18.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span><span id="06b9" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="825d" class="lz ma it lu b gy mf mc l md me">df<strong class="lu iu">.</strong>booked_perc<strong class="lu iu">.</strong>sum()</span><span id="1e78" class="lz ma it lu b gy mf mc l md me">92 µs ± 2.21 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</span></pre><p id="6e85" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如所料，第一个例子是最慢的——对10k个条目求和几乎需要1秒钟。第二个例子的速度之快让我吃惊。用pandas对数据求和的正确方法(或对列使用任何其他操作)是第三个例子，也是最快的！</p><h1 id="c3d9" class="mz ma it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">2.如何不过滤数据</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5e13121c96932f89cbda794cd10af515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*O_LeVtolA2ZvYI9M.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自<a class="ae ku" href="https://giphy.com/gifs/panda-playing-QoCoLo2opwUW4" rel="noopener ugc nofollow" target="_blank">吉菲</a>的熊猫游戏</p></figure><p id="d9c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">尽管在开始使用pandas之前，我对numpy很有经验，但我是在for循环中过滤数据。您可以在计算总和时观察性能损失。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="8860" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="87b2" class="lz ma it lu b gy mf mc l md me">suma <strong class="lu iu">=</strong> 0<br/><strong class="lu iu">for</strong> _, row <strong class="lu iu">in</strong> df<strong class="lu iu">.</strong>iterrows():<br/>    <strong class="lu iu">if</strong> row<strong class="lu iu">.</strong>booked_perc <strong class="lu iu">&lt;=</strong> 0.5:<br/>        suma <strong class="lu iu">+=</strong> row<strong class="lu iu">.</strong>booked_perc</span><span id="b702" class="lz ma it lu b gy mf mc l md me">831 ms ± 25.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span><span id="5204" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="0792" class="lz ma it lu b gy mf mc l md me">df[df<strong class="lu iu">.</strong>booked_perc <strong class="lu iu">&lt;=</strong> 0.5]<strong class="lu iu">.</strong>booked_perc<strong class="lu iu">.</strong>sum()</span><span id="87aa" class="lz ma it lu b gy mf mc l md me">724 µs ± 18.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></pre><p id="8015" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如所料，第二个例子比第一个快几个数量级。</p><p id="aa64" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">多加几个滤镜呢？我们简单地将它们括在括号中:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="b9c3" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="dced" class="lz ma it lu b gy mf mc l md me">df[(df<strong class="lu iu">.</strong>booked_perc <strong class="lu iu">&lt;=</strong> 0.5) <strong class="lu iu">&amp;</strong> (df<strong class="lu iu">.</strong>city <strong class="lu iu">==</strong> 'new york')]<strong class="lu iu">.</strong>booked_perc<strong class="lu iu">.</strong>sum()</span><span id="1acf" class="lz ma it lu b gy mf mc l md me">1.55 ms ± 10.7 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></pre><h1 id="f2fa" class="mz ma it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">3.如何不访问以前的值</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/cb1853f625d9b470fe14b5fd3b8a33fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/0*cuWq2kQx3eWwe9Nh.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自<a class="ae ku" href="https://giphy.com/gifs/pandas-12L6wFC7gHKQ92" rel="noopener ugc nofollow" target="_blank"> Giphy </a>的熊猫翻滚</p></figure><p id="a4f8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您可能会说:好吧，但是当我需要访问前一列的值时怎么办？那么我需要一个for循环。不对！</p><p id="7014" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们计算在有和没有for循环的情况下从一行到另一行的百分比变化。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="d318" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="859e" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">for</strong> i <strong class="lu iu">in</strong> range(1, len(df)):<br/>    df<strong class="lu iu">.</strong>loc[i, "perc_change"] <strong class="lu iu">=</strong>  (df<strong class="lu iu">.</strong>loc[i]<strong class="lu iu">.</strong>booked_perc <strong class="lu iu">-</strong> df<strong class="lu iu">.</strong>loc[i <strong class="lu iu">-</strong> 1]<strong class="lu iu">.</strong>booked_perc) <strong class="lu iu">/</strong> df<strong class="lu iu">.</strong>loc[i <strong class="lu iu">-</strong> 1]<strong class="lu iu">.</strong>booked_perc</span><span id="c55e" class="lz ma it lu b gy mf mc l md me">7.02 s ± 24.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span><span id="421f" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="262b" class="lz ma it lu b gy mf mc l md me">df["perc_change"] <strong class="lu iu">=</strong> df<strong class="lu iu">.</strong>booked_perc<strong class="lu iu">.</strong>pct_change()</span><span id="220b" class="lz ma it lu b gy mf mc l md me">586 µs ± 17.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></pre><p id="fb84" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同样，第二个例子比第一个for循环快得多。</p><p id="c185" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Pandas有许多函数可以基于以前的值计算统计数据(例如，<code class="fe lr ls lt lu b">shift</code>函数延迟一个值)。这些函数采用<code class="fe lr ls lt lu b">periods</code>参数，该参数定义了要包含在计算中的先前值的数量。</p><h1 id="e7bb" class="mz ma it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">4.如何不应用复杂函数</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/88aaf8ac9164873ac41c5238c02fcbef.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*Yqhwzdj4DEubQPso.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自<a class="ae ku" href="https://giphy.com/gifs/panda-working-pole-9rYAlBv4PnP44" rel="noopener ugc nofollow" target="_blank"> Giphy </a>的熊猫工作杆</p></figure><p id="48d8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有时，我们需要对一个数据帧应用一个复杂的函数(一个有多个变量的函数)。假设我们想将纽约的booking_perc乘以2，将其他值设为0，并将列命名为sales_factor。</p><p id="5dc2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我想到的第一种方法是使用带有iterrows的for循环。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="9577" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="5ff3" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">for</strong> i, row <strong class="lu iu">in</strong> df<strong class="lu iu">.</strong>iterrows():<br/>    <strong class="lu iu">if</strong> row<strong class="lu iu">.</strong>city <strong class="lu iu">==</strong> 'new york':<br/>        df<strong class="lu iu">.</strong>loc[i, 'sales_factor'] <strong class="lu iu">=</strong> row<strong class="lu iu">.</strong>booked_perc <strong class="lu iu">*</strong> 2<br/>    <strong class="lu iu">else</strong>:<br/>        df<strong class="lu iu">.</strong>loc[i, 'sales_factor'] <strong class="lu iu">=</strong> 0</span><span id="4ff6" class="lz ma it lu b gy mf mc l md me">3.58 s ± 48.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="1919" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">稍微好一点的方法是直接在数据帧上使用apply函数。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="2e0e" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="d1aa" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">def</strong> <strong class="lu iu">calculate_sales_factor</strong>(row):<br/>    <strong class="lu iu">if</strong> row<strong class="lu iu">.</strong>city <strong class="lu iu">==</strong> 'new york':<br/>        <strong class="lu iu">return</strong> row<strong class="lu iu">.</strong>booked_perc <strong class="lu iu">*</strong> 2<br/>    <strong class="lu iu">return</strong> 0</span><span id="a9eb" class="lz ma it lu b gy mf mc l md me">df['sales_factor'] <strong class="lu iu">=</strong> df<strong class="lu iu">.</strong>apply(calculate_sales_factor, axis<strong class="lu iu">=</strong>1)</span><span id="d0a3" class="lz ma it lu b gy mf mc l md me">165 ms ± 2.48 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="7d38" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最快的方法是使用熊猫滤镜，直接计算函数值。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7139" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="88ae" class="lz ma it lu b gy mf mc l md me">df<strong class="lu iu">.</strong>loc[df<strong class="lu iu">.</strong>city <strong class="lu iu">==</strong> 'new york', 'sales_factor'] <strong class="lu iu">=</strong> df[df<strong class="lu iu">.</strong>city <strong class="lu iu">==</strong> 'new york']<strong class="lu iu">.</strong>booked_perc <strong class="lu iu">*</strong> 2<br/>df<strong class="lu iu">.</strong>sales_factor<strong class="lu iu">.</strong>fillna(0, inplace<strong class="lu iu">=</strong>True)</span><span id="bb5c" class="lz ma it lu b gy mf mc l md me">3.03 ms ± 85.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="4c0b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以观察到从第一个例子到最后一个例子的加速。</p><p id="85b7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当我们处理3个或更多变量的函数时，我们可以把它分解成多个熊猫表达式。这将比使用应用功能更快。</p><p id="1aa9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">f(x, a, b) = (a + b) * x</code></p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="8a63" class="lz ma it lu b gy mb mc l md me">df['a_plus_b'] = df['a'] + df['b']<br/>df['f'] = df['a_plus_b'] * df['x']</span></pre><h1 id="ca4a" class="mz ma it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">5.如何不对数据进行分组</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c02327a88abef8aa5c19fe59187cb3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*KpQBdGJQZRWdXFc8.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自<a class="ae ku" href="https://giphy.com/gifs/natgeowild-panda-nat-geo-wild-mission-critical-l3vQWz6kFbX5RWgaQ" rel="noopener ugc nofollow" target="_blank"> Giphy </a>的熊猫</p></figure><p id="1c45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如你现在看到的，当我开始使用pandas时，我非常依赖for循环。通过对数据进行分组，您可以在使用pandas时最大限度地减少代码行数。</p><p id="8164" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设我们想计算:</p><ul class=""><li id="5636" class="nv nw it kx b ky kz lb lc le nx li ny lm nz lq oa ob oc od bi translated">城市的平均销售系数</li><li id="47cd" class="nv nw it kx b ky oe lb of le og li oh lm oi lq oa ob oc od bi translated">以及城市的第一个预订id。</li></ul><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="495d" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="83ca" class="lz ma it lu b gy mf mc l md me">avg_by_city <strong class="lu iu">=</strong> {}<br/>count_by_city <strong class="lu iu">=</strong> {}<br/>first_booking_by_city <strong class="lu iu">=</strong> {}</span><span id="6559" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">for</strong> i, row <strong class="lu iu">in</strong> df<strong class="lu iu">.</strong>iterrows():<br/>    city <strong class="lu iu">=</strong> row<strong class="lu iu">.</strong>city<br/>    <strong class="lu iu">if</strong> city <strong class="lu iu">in</strong> avg_by_city:<br/>        avg_by_city[city] <strong class="lu iu">+=</strong> row<strong class="lu iu">.</strong>sales_factor<br/>        count_by_city[city] <strong class="lu iu">+=</strong> 1<br/>    <strong class="lu iu">else</strong>:<br/>        avg_by_city[city] <strong class="lu iu">=</strong> row<strong class="lu iu">.</strong>sales_factor<br/>        count_by_city[city] <strong class="lu iu">=</strong> 1<br/>        first_booking_by_city[city] <strong class="lu iu">=</strong> row['id']</span><span id="c0dd" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">for</strong> city, _ <strong class="lu iu">in</strong> avg_by_city<strong class="lu iu">.</strong>items():<br/>    avg_by_city[city] <strong class="lu iu">/=</strong> count_by_city[city]</span><span id="3781" class="lz ma it lu b gy mf mc l md me">878 ms ± 21.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="c77c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Pandas有一个group by操作，所以不需要迭代数据帧。pandas中的group by与SQL中的GROUP BY语句做同样的事情。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7e19" class="lz ma it lu b gy mb mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="3bc8" class="lz ma it lu b gy mf mc l md me">df<strong class="lu iu">.</strong>groupby('city')<strong class="lu iu">.</strong>sales_factor<strong class="lu iu">.</strong>mean()<br/>df<strong class="lu iu">.</strong>groupby('city')<strong class="lu iu">.</strong>sales_factor<strong class="lu iu">.</strong>count()<br/>df<strong class="lu iu">.</strong>groupby('city')<strong class="lu iu">.</strong>id<strong class="lu iu">.</strong>first()</span><span id="dca7" class="lz ma it lu b gy mf mc l md me">3.05 ms ± 65.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span><span id="2f90" class="lz ma it lu b gy mf mc l md me"><strong class="lu iu">%%</strong>timeit</span><span id="73bc" class="lz ma it lu b gy mf mc l md me">df<strong class="lu iu">.</strong>groupby("city")<strong class="lu iu">.</strong>agg({"sales_factor": ["mean", "count"], "id": "first"})</span><span id="e0e7" class="lz ma it lu b gy mf mc l md me">4.5 ms ± 131 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="b597" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">令人惊讶的是，第三个例子并不是最快的，但它比第二个例子更简洁。当你需要加速你的代码时，我建议你使用第二种方法。</p><h1 id="69c0" class="mz ma it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/19c63f1cba291ab8a4395288ccba0e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*Qk7bhRskVMuPh8xS.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自<a class="ae ku" href="https://giphy.com/gifs/z6xE1olZ5YP4I" rel="noopener ugc nofollow" target="_blank"> Giphy </a>的快乐熊猫</p></figure><p id="3af4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我的建议是:</p><blockquote class="ot"><p id="3485" class="ou ov it bd ow ox oy oz pa pb pc lq dk translated">如果你对熊猫使用for循环，可能有一个更好的方法来写它。</p></blockquote><p id="7828" class="pw-post-body-paragraph kv kw it kx b ky pd ju la lb pe jx ld le pf lg lh li pg lk ll lm ph lo lp lq im bi translated">存在计算开销很大的函数，即使上面的优化也无济于事。然后，我们需要使用最后的手段:Cython和Numba，我将在接下来的几周中介绍这两个地方。</p><p id="e353" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你喜欢这个职位吗？学到了新东西？请在下面的评论中告诉我。</p><h1 id="b6e0" class="mz ma it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">在你走之前</h1><p id="8853" class="pw-post-body-paragraph kv kw it kx b ky nq ju la lb nr jx ld le ns lg lh li nt lk ll lm nu lo lp lq im bi translated">像往常一样，你可以下载这个<a class="ae ku" href="https://romanorac.github.io/assets/notebooks/2019-12-09-how-not-to-write-python-code.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>在你的机器上尝试例子。</p><p id="dea3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在<a class="ae ku" href="https://twitter.com/romanorac" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，在那里我定期<a class="ae ku" href="https://twitter.com/romanorac/status/1328952374447267843" rel="noopener ugc nofollow" target="_blank">发关于数据科学和机器学习的</a>推特。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ok ol di om bf on"><div class="gh gi pi"><img src="../Images/b5d426b68cc5a21b1a35d0a157ebc4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*69rP1pwjJi9mLSFE"/></div></div></figure></div></div>    
</body>
</html>