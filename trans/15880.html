<html>
<head>
<title>All about Pythonic Class: The Birth and Style</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Pythonic类的一切:诞生和风格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-about-pythonic-class-the-birth-and-style-36002e28d035?source=collection_archive---------38-----------------------#2020-11-01">https://towardsdatascience.com/all-about-pythonic-class-the-birth-and-style-36002e28d035?source=collection_archive---------38-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="5df5" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Python数据模型</h2><div class=""/><div class=""><h2 id="214b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Python数据模型—第2部分[a]</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d49863ec01a8fba63b9ca64b4b1bce50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQmLrSSPLoKp8uAKVW-HkQ.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片:<a class="ae le" href="https://www.pxfuel.com/en/free-photo-ernyb" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="8e46" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您错过了本系列的第一部分，您可以在这里阅读<a class="ae le" rel="noopener" target="_blank" href="/python-data-model-part-1-objects-types-and-values-cb9316f57e8">对象、类型和值；Python数据模型—第1部分</a>。</p><p id="1a19" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将这个“关于Pythonic类的一切”的标题分成两部分。<br/> —关于python类的一切:诞生和风格<br/> — <a class="ae le" href="https://farhadnaeem.medium.com/all-about-pythonic-class-the-life-cycle-5d2deae1ad8d" rel="noopener">关于python类的一切:生命周期</a></p><p id="e408" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些章节的标题最终可能不会明确地反映读者刚刚描绘到她/他脑海中的想法。我们将试图用一个简单的叙述来涵盖Python类如何形成和析构的基本概念。Python类(更具体地说是Python 3.x类)的创建和销毁不可避免地会涉及许多看似不相关的主题。</p><p id="868b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">更重要的是，读者至少需要适度了解Python数据模型、特殊方法、元编程以及解释器如何在幕后工作。此外，有些重复、循环讨论和过度简化是不可避免的——例如，我们必须坚持用对象来解释一个类的行为。</p><h1 id="7a7c" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated"><strong class="ak"> 1。如何写一个基础类</strong></h1><p id="136f" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">让我们为Foo小姐阁下<strong class="lh ja"><em class="my"/></strong>写一个基础类，她是我们当地一位著名的后摇滚吉他练习者，她要求我们写一个程序来跟踪她的学生的<strong class="lh ja"> <em class="my">姓名</em></strong><strong class="lh ja"><em class="my">金钱</em> </strong>，他们将支付给她并分配一个带有她的域名的<strong class="lh ja"> <em class="my">电子邮件</em> </strong>地址。她自己是一名开发人员，但是每天的日程安排很紧，她向像我们这样懒惰的程序员寻求帮助。然而，她将把这个蓝图或类用到自己的脚本中。现实生活中代码重用的例子，哈！让我们帮助她。</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="8085" class="ne mc iq na b gy nf ng l nh ni">&gt;&gt;&gt; class Student():     # ...[1]<br/>       pass</span><span id="a2ae" class="ne mc iq na b gy nj ng l nh ni">&gt;&gt;&gt; student_1 = Student() # ... [2]<br/>&gt;&gt;&gt; student_2 = Student() # ... [3]</span><span id="da84" class="ne mc iq na b gy nj ng l nh ni">&gt;&gt;&gt; student_1, student_2 # ... [4]<br/>(&lt;__main__.Student object at 0x7fec1b6387b8&gt;, &lt;__main__.Student object at 0x7fec1b638780&gt;)</span><span id="013e" class="ne mc iq na b gy nj ng l nh ni">&gt;&gt;&gt; print(id(student_1), id(student_2)) # ... [5]<br/>140652048517048 140652048516992</span><span id="729b" class="ne mc iq na b gy nj ng l nh ni">&gt;&gt;&gt; type(student_1)  <!-- --># .......... [6]<br/>&lt;class '__main__.Student'&gt;</span></pre><p id="c71d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们刚刚编写了一个框架类<code class="fe nk nl nm na b">Student</code>并给解释器传递了一个<code class="fe nk nl nm na b">pass</code>语句，告诉她在我们给它赋值之前保持它的完整性。我们还在语句<code class="fe nk nl nm na b">[2]</code>和<code class="fe nk nl nm na b">[3]</code>中创建了两个<code class="fe nk nl nm na b">Student</code>类实体。这里需要注意的最重要的两点是，尽管来自同一个类<code class="fe nk nl nm na b">Student</code> , <code class="fe nk nl nm na b">student_1</code>和<code class="fe nk nl nm na b">student_2</code>在RAM语句<code class="fe nk nl nm na b">[5]</code>和<code class="fe nk nl nm na b">[4]</code>中具有不同的身份和位置。</p><p id="c05e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一个星期天的早上，安德鲁·汤普森被她的班级录取了。<strong class="lh ja"> <em class="my">傅小姐</em> </strong>每个月会收他<strong class="lh ja"> <em class="my">五千</em> </strong>块钱。让我们加上他的名字</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="64be" class="ne mc iq na b gy nf ng l nh ni">&gt;&gt;&gt; student_1.firstname = "Andrew"<br/>&gt;&gt;&gt; student_1.lastname = "Thompson"<br/>&gt;&gt;&gt; student_1.pays = 5000<br/>&gt;&gt;&gt; student_1.mail = student_1.firstname.lower()+'_'+student_1.lastname.lower()+"@msfooguitar.edu"<br/>&gt;&gt;&gt; student_1.mail<br/>'andrew_thompson@msfooguitar.edu'</span></pre><p id="6b38" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一个星期五的早上，安德鲁的朋友马克·伯德报名参加了这个班。因为他是个初学者，所以傅小姐需要对他付出更多的努力和关注。马克每月将支付<strong class="lh ja"> <em class="my"> 6000 </em> </strong>美元。让我们把他的名字登记在登记簿上。</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="bbe6" class="ne mc iq na b gy nf ng l nh ni">&gt;&gt;&gt; student_2.firstname = "Marc"<br/>&gt;&gt;&gt; student_2.lastname = "Byrd"<br/>&gt;&gt;&gt; student_2.pays = 6000<br/>&gt;&gt;&gt; student_2.mail = student_2.firstname.lower()+'_'+student_2.lastname.lower()+"@msfooguitar.edu"<br/>&gt;&gt;&gt; student_2.mail<br/>'marc_byrd@msfooguitar.edu'</span></pre><p id="85c5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，我们在上述示例中采用的方法符合我们的目的，但使进一步的工作变得复杂。</p><ul class=""><li id="fd46" class="nn no iq lh b li lj ll lm lo np ls nq lw nr ma ns nt nu nv bi translated">我们重复地给每个对象分配实例。当类将产生更多的对象时，这将进一步增加复杂性。</li><li id="ba67" class="nn no iq lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated">我们将需要在需要的时候定义类。当前的例子对我们没有帮助。</li></ul><p id="fd52" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以通过避免重复和确保代码的可重用性来使情况变得更加灵活，具体方法是编写一个蓝图，描述<code class="fe nk nl nm na b">Student</code>类及其对象将获得什么属性。</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="da6a" class="ne mc iq na b gy nf ng l nh ni">class Student():<br/>   def __init__(self, fname, lname, pays): # ... [1] an initialiser.<br/>      self.fname = fname<br/>      self.lname = lname<br/>      self.pays = pays<br/>      self.mail = f"{self.fname.lower()}@msfooguitar.edu"<br/> <br/>student_1 = Student("Andrew", "Thompson", 5000)<br/>student_2 = Student("Marc", "Byrd", 6000)</span></pre><p id="0e2d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们所拥有的是，</p><ul class=""><li id="ae34" class="nn no iq lh b li lj ll lm lo np ls nq lw nr ma ns nt nu nv bi translated">类<code class="fe nk nl nm na b">Student</code>现在的行为就像一个表单，有三个必填字段——名、姓、支付的金额以及一个额外的电子邮件地址——由每个新学生或对象在注册课程时填写。这样编码器可以避免重复。</li><li id="83c8" class="nn no iq lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated"><code class="fe nk nl nm na b">__init__</code>魔法方法(将在几分钟内讨论)初始化每个新的<code class="fe nk nl nm na b">Student</code>对象/实例将获得的变量、字段或属性。在创建类的每个新对象时调用此方法。记住<code class="fe nk nl nm na b">__init__</code>不是<em class="my">构造器</em>。在Python中，<code class="fe nk nl nm na b">__new__</code>是构造函数</li><li id="6998" class="nn no iq lh b li nw ll nx lo ny ls nz lw oa ma ns nt nu nv bi translated">你有没有注意到初始值设定项中传递了<code class="fe nk nl nm na b">self</code>参数？当从一个类中创建一个对象时，解释器将首先把对象本身传递给<code class="fe nk nl nm na b">__init__</code>方法，这个方法通常用<code class="fe nk nl nm na b">self</code>参数表示。我们可以使用除了<code class="fe nk nl nm na b">self</code>之外的任何参数名。</li></ul><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="aa2d" class="ne mc iq na b gy nf ng l nh ni">class Student():<br/>  def __init__(self, fname, lname, pays): # ... [1] an initialiser.<br/>    self.fname = fname<br/>    self.lname = lname<br/>    self.pays = pays<br/>    self.mail = f"{self.fname.lower()}@msfooguitar.edu"<br/> <br/>  def details(self):<br/>    print(f"name: {self.fname} {self.lname} pays: {self.pays} mail:\<br/>     {self.mail}")<br/> <br/> <br/>student_1 = Student("Andrew", "Thompson", 5000)# ... [2]<br/>student_2 = Student("Marc", "Byrd", 6000)</span><span id="16cb" class="ne mc iq na b gy nj ng l nh ni">print(student_1.details(), student_2.details())</span><span id="f794" class="ne mc iq na b gy nj ng l nh ni"><br/># Output<br/>'''<br/>name: Andrew Thompson pays: 5000 mail: andrew_thompson@msfooguitar.edu<br/>name: Marc Byrd pays: 6000 mail: marc_byrd@msfooguitar.edu<br/>'''</span></pre><p id="ad68" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">语句<code class="fe nk nl nm na b">[2]</code>可以重写为Class.objectMethod(object)。在我们这里相当于<code class="fe nk nl nm na b">Student.details(student_1)</code>。</p><p id="d464" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">有趣的是，我们可以像动态变量一样覆盖实例方法。比如，我们可以把<code class="fe nk nl nm na b">details()</code>这个可调用的函数改成一个新的字符串。</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="03a1" class="ne mc iq na b gy nf ng l nh ni">student_1.details = "A new string."<br/>print(student_1.__dict__)<br/> <br/># Output<br/>'''<br/>{'fname': 'Andrew',<br/>'lname': 'Thompson',<br/>'pays': 5000,<br/>'mail': 'andrew_thompson@msfooguitar.edu',<br/>'details': 'A new string.'}<br/>'''</span></pre><p id="33b3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意<code class="fe nk nl nm na b">details</code>现在已经变成了一个不可调用的字符串对象。__dict__是一个字典，包含了对象拥有的变量。</p><p id="53f2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意<code class="fe nk nl nm na b">details</code>现在已经变成了一个不可调用的字符串对象。</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="2445" class="ne mc iq na b gy nf ng l nh ni">print(student_1.details())<br/># Output<br/>'''<br/>Traceback (most recent call last)<br/>...<br/>---&gt; 19 print(student_1.details())<br/>TypeError: 'str' object is not callable<br/>'''</span></pre><h1 id="26ce" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">2.<strong class="ak">类和对象:硬币的两面</strong></h1><p id="c1a7" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">继续本系列的第一部分，关于Python数据模型的讨论，我们会经常遇到“陈词滥调”和重复的概念<strong class="lh ja"> <em class="my">“在Python中，一切都是对象。”</em> </strong></p><blockquote class="ob oc od"><p id="ad7c" class="lf lg my lh b li lj ka lk ll lm kd ln oe lp lq lr of lt lu lv og lx ly lz ma ij bi translated">它们或者是原型或者是<em class="iq">类型</em>的<em class="iq">元类</em>或者是一些其他类的对象</p></blockquote><p id="bbee" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这可能与我们刚刚开始我们的<strong class="lh ja"> <em class="my"> *nix </em> </strong>之旅的时候相比，我们被告知至少数百次，从文本文件到键盘<strong class="lh ja"> <em class="my">的一切都是文件。</em> </strong> <br/>在Python 3.x中，类也是对象。也就是说，我们可以把一个类当作一个对象。我们可以像前面提到的例子一样动态地操作和修改一个类:</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="7cf1" class="ne mc iq na b gy nf ng l nh ni">&gt;&gt;&gt; class ObjClass(): pass<br/>...<br/>&gt;&gt;&gt; ObjClass.sentence = "A class is an Object" # ...[1]<br/>&gt;&gt;&gt; ObjClass.sentence <br/>'A class is an Object'</span><span id="0c66" class="ne mc iq na b gy nj ng l nh ni">&gt;&gt;&gt; type(ObjClass) # ... [2]<br/>&lt;class 'type'&gt;</span><span id="6b37" class="ne mc iq na b gy nj ng l nh ni">&gt;&gt;&gt; print(ObjClass)<br/>&lt;class '__main__.ObjClass'&gt;<br/>&gt;&gt;&gt; ObjClass = "I'm a string now" # ... [3]</span><span id="d1c2" class="ne mc iq na b gy nj ng l nh ni">&gt;&gt;&gt; type(ObjClass)<br/>&lt;class 'str'&gt;</span></pre><p id="cfb8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过把类本身当作一个对象来对待，<strong class="lh ja">我们可以改变它的类型</strong> <code class="fe nk nl nm na b">[3]</code>为什么这是可能的？<br/>准确地说，我们可以运行一个循环来查看我们的常规数据类型，甚至<code class="fe nk nl nm na b">type</code>本身也是从<code class="fe nk nl nm na b">type</code> <em class="my">元类</em>中派生出来的。我们将有一章深入讨论<em class="my">元类。目前，<em class="my">元类</em>从其他类获取属性，生成一个具有附加功能的新类。</em></p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="e69a" class="ne mc iq na b gy nf ng l nh ni">class MyClass():<br/>    pass<br/> <br/>myObj = MyClass()<br/> <br/>for x in str, int, float, type, True, bool, myObj, MyClass:<br/>    print(f'{x} : {type(x)}')</span><span id="d13c" class="ne mc iq na b gy nj ng l nh ni"><br/># Output<br/>'''<br/>&lt;class 'str'&gt; : &lt;class 'type'&gt;<br/>&lt;class 'int'&gt; : &lt;class 'type'&gt;<br/>&lt;class 'float'&gt; : &lt;class 'type'&gt;<br/>&lt;class 'type'&gt; : &lt;class 'type'&gt;<br/>True : &lt;class 'bool'&gt; # ...<br/>&lt;class 'bool'&gt; : &lt;class 'type'&gt; # ... [2]<br/>&lt;__main__.MyClass object at 0x7f70d8380550&gt; : &lt;class '__main__.MyClass'&gt;<br/>&lt;class '__main__.MyClass'&gt; : &lt;class 'type'&gt;<br/>'''</span></pre><p id="32f5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以，从上面的例子可以清楚地看出，Python中的类和对象在本质上是一样的。它们或者是原型或者是<em class="my">类型</em>的<em class="my">元类</em>或者是一些其他类的对象</p><h1 id="ed89" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">3.旧式班级和新式班级的区别</h1><p id="4a1a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">一个旧样式的类曾经被声明为<code class="fe nk nl nm na b">class A()</code>，而一个新样式是<code class="fe nk nl nm na b">class A(object)</code>，它“从<em class="my">对象</em>继承，或者从另一个新样式的类继承。”根据<a class="ae le" href="https://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="ob oc od"><p id="5495" class="lf lg my lh b li lj ka lk ll lm kd ln oe lp lq lr of lt lu lv og lx ly lz ma ij bi translated">“在Python 2.1之前，旧式类是用户可以使用的唯一风格。(旧式)类的概念与类型的概念无关:如果x是旧式类的实例，那么<code class="fe nk nl nm na b">x.__class__</code>指定x的类，但是<code class="fe nk nl nm na b">type(x)</code>总是<code class="fe nk nl nm na b">&lt;type 'instance'&gt;</code>。<br/>...这反映了这样一个事实:所有旧式的实例，不管它们的类是什么，都是用一个内置类型实现的，这个内置类型叫做instance。<br/>...引入新型类的主要动机是提供一个具有完整元模型的统一对象模型。</p></blockquote><p id="59ad" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们来看一个例子</p><ol class=""><li id="f8b8" class="nn no iq lh b li lj ll lm lo np ls nq lw nr ma oh nt nu nv bi translated">旧式班级:</li></ol><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="2e6e" class="ne mc iq na b gy nf ng l nh ni">#python 2.1<br/>class Student():</span><span id="ee85" class="ne mc iq na b gy nj ng l nh ni">  _names_cache = {}<br/>  def __init__(self, fname):<br/>    self.fname = fname<br/> <br/>  def __new__(cls,fname):<br/>    return cls._names_cache<br/>    .setdefault(name,object.__new__(cls,fname))</span><span id="eedc" class="ne mc iq na b gy nj ng l nh ni"> <br/> <br/>student_1 = Student("Andrew")<br/>student_2 = Student("Andrew")<br/>print student_1 is student_2<br/>print student_1<br/>print student_2<br/><br/><br/>&gt;&gt;&gt; False<br/>&lt;__main__.Student instance at 0xb74acf8c&gt;<br/>&lt;__main__.Student instance at 0xb74ac6cc&gt;<br/>&gt;&gt;&gt;</span></pre><p id="4955" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">2.新型类:</p><pre class="kp kq kr ks gt mz na nb nc aw nd bi"><span id="5a91" class="ne mc iq na b gy nf ng l nh ni">#python 2.7<br/>class Student():</span><span id="fb94" class="ne mc iq na b gy nj ng l nh ni">  _names_cache = {}<br/>  def __init__(self, fname):<br/>    self.fname = fname</span><span id="32f7" class="ne mc iq na b gy nj ng l nh ni">  def __new__(cls,fname):<br/>    return cls._names_cache<br/>    .setdefault(fname,object.__new__(cls,fname))</span><span id="381d" class="ne mc iq na b gy nj ng l nh ni">student_1 = Student("Andrew")<br/>student_2 = Student("Andrew")<br/>print student_1 is student_2<br/>print student_1<br/>print student_2<br/><br/><br/>&gt;&gt;&gt; True<br/>&lt;__main__.Student instance at 0xb74acf8c&gt;<br/>&lt;__main__.Student instance at 0xb74ac6cc&gt;<br/>&gt;&gt;&gt;</span></pre><p id="cae9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Python 3只有一个新样式的类。即使你写的是‘旧式类’，也是从<code class="fe nk nl nm na b">object</code>隐式派生的。新式职业有一些老式职业所缺乏的高级特征，比如<code class="fe nk nl nm na b">super</code>，新的<a class="ae le" href="http://en.wikipedia.org/wiki/C3_linearization" rel="noopener ugc nofollow" target="_blank"> C3 mro </a>，一些神奇的方法等等。请记住，我们在整篇文章中都使用Python 3.x。</p><p id="2952" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><a class="ae le" href="https://gvanrossum.github.io/" rel="noopener ugc nofollow" target="_blank"> Guido </a>已经写了<a class="ae le" href="http://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html" rel="noopener ugc nofollow" target="_blank"> <em class="my">关于新型类的内幕</em> </a>，这是一篇关于Python中新型和旧式类的非常棒的文章。</p><p id="76d9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在<a class="ae le" rel="noopener" target="_blank" href="/all-about-pythonic-class-the-life-cycle-5d2deae1ad8d">的下一部分</a>，我们将讨论类的生命周期</p><h1 id="0718" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">参考资料:</h1><ol class=""><li id="8579" class="nn no iq lh b li mt ll mu lo oi ls oj lw ok ma oh nt nu nv bi translated"><a class="ae le" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/reference/datamodel.html</a></li><li id="c118" class="nn no iq lh b li nw ll nx lo ny ls nz lw oa ma oh nt nu nv bi translated">卢西亚诺·拉马尔霍的流畅Python。这是每一个python爱好者都应该读的书，以提高他们的python技能。</li></ol></div></div>    
</body>
</html>