<html>
<head>
<title>Data preprocessing with Python Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python Pandas进行数据预处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-preprocessing-with-python-pandas-part-1-missing-data-45e76b781993?source=collection_archive---------3-----------------------#2020-11-12">https://towardsdatascience.com/data-preprocessing-with-python-pandas-part-1-missing-data-45e76b781993?source=collection_archive---------3-----------------------#2020-11-12</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><div class=""/><div class=""><h2 id="76a1" class="pw-subtitle-paragraph jt iv iw bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">第1部分—缺失数据</h2></div><figure class="km kn ko kp gu kq gi gj paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gi gj kl"><img src="../Images/4a6167485a448b14e3c82189d2708943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcEH3WJF7gq7IkFgtmrWTA.jpeg"/></div></div><p class="kx ky gk gi gj kz la bd b be z dk translated">来自<a class="ae lb" href="https://pixabay.com/it/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1433427" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae lb" href="https://pixabay.com/it/users/photomix-company-1546875/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1433427" rel="noopener ugc nofollow" target="_blank">照片混合</a>照片</p></figure><p id="d45a" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">本教程解释了如何使用pandas库预处理数据。预处理是对数据进行预分析的过程，目的是将数据转换成标准和规范化的格式。</p><p id="208a" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">预处理包括以下几个方面:</p><ul class=""><li id="2349" class="ly lz iw le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated">缺少值</li><li id="c5aa" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">数据标准化</li><li id="223d" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">数据标准化</li><li id="f3ed" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">宁滨数据</li></ul><p id="b5fc" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">在本教程中，我们只处理缺失值。</p><p id="443f" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">你可以从我的<a class="ae lb" href="https://github.com/alod83/data-science/tree/master/Preprocessing/MissingValues" rel="noopener ugc nofollow" target="_blank"> Github数据科学库</a>下载本教程的源代码作为Jupyter笔记本。</p><h1 id="fa34" class="mm mn iw bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">输入数据</h1><p id="db61" class="pw-post-body-paragraph lc ld iw le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ip bi translated">在本教程中，我们将使用与肝炎相关的数据集，可以从<a class="ae lb" href="https://datahub.io/machine-learning/hepatitis#pandas" rel="noopener ugc nofollow" target="_blank">此链接</a>下载。</p><p id="951b" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">首先，使用pandas库导入数据，并将它们转换成dataframe。通过<code class="fe nj nk nl nm b">head(10)</code>方法，我们只打印数据集的前10行</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="3ca3" class="nr mn iw nm b gz ns nt l nu nv"><strong class="nm ix">import</strong> pandas <strong class="nm ix">as</strong> pd<br/>df <strong class="nm ix">=</strong> pd.read_csv('hepatitis.csv')<br/>df.head(10)</span></pre><figure class="km kn ko kp gu kq gi gj paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gi gj nw"><img src="../Images/29d664f03c9442ef3ffcb8050495330e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dJG24Hqd3GBVoWtV8Dnog.png"/></div></div></figure><h1 id="4c76" class="mm mn iw bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">识别缺失值</h1><p id="c9e8" class="pw-post-body-paragraph lc ld iw le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ip bi translated">我们注意到数据集存在一些问题。例如,“电子邮件”列并不适用于所有行。在某些情况下，它会显示<code class="fe nj nk nl nm b">NaN</code>值，这意味着该值缺失。</p><p id="4939" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">为了检查我们的数据集是否包含缺失值，我们可以使用函数<code class="fe nj nk nl nm b">isna()</code>，该函数返回数据集的单元格是否为<code class="fe nj nk nl nm b">NaN</code>。然后我们可以计算每一列有多少个缺失值。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="dabb" class="nr mn iw nm b gz ns nt l nu nv">df.isna().sum()</span></pre><p id="efb0" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">它给出了以下输出:</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="9cbd" class="nr mn iw nm b gz ns nt l nu nv">age                 0<br/>sex                 0<br/>steroid             1<br/>antivirals          0<br/>fatigue             1<br/>malaise             1<br/>anorexia            1<br/>liver_big          10<br/>liver_firm         11<br/>spleen_palpable     5<br/>spiders             5<br/>ascites             5<br/>varices             5<br/>bilirubin           6<br/>alk_phosphate      29<br/>sgot                4<br/>albumin            16<br/>protime            67<br/>histology           0<br/>class               0<br/>dtype: int64</span></pre><p id="25d7" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在我们可以计算每列缺失值的百分比，只需将之前的结果除以数据集的长度(<code class="fe nj nk nl nm b">len(df)</code>)并乘以100。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="bc2f" class="nr mn iw nm b gz ns nt l nu nv">df.isna().sum()<strong class="nm ix">/</strong>len(df)<strong class="nm ix">*</strong>100</span></pre><p id="a9fe" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">它给出了以下输出:</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="7692" class="nr mn iw nm b gz ns nt l nu nv">age                 0.000000<br/>sex                 0.000000<br/>steroid             0.645161<br/>antivirals          0.000000<br/>fatigue             0.645161<br/>malaise             0.645161<br/>anorexia            0.645161<br/>liver_big           6.451613<br/>liver_firm          7.096774<br/>spleen_palpable     3.225806<br/>spiders             3.225806<br/>ascites             3.225806<br/>varices             3.225806<br/>bilirubin           3.870968<br/>alk_phosphate      18.709677<br/>sgot                2.580645<br/>albumin            10.322581<br/>protime            43.225806<br/>histology           0.000000<br/>class               0.000000<br/>dtype: float64</span></pre><p id="5fe7" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">处理缺失值时，可以采用不同的替代方法:</p><ul class=""><li id="59d7" class="ly lz iw le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated">检查数据源，例如通过联系数据源来更正缺少的值</li><li id="6772" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">删除缺少的值</li><li id="8fe9" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">用一个值替换缺少的值</li><li id="dd47" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">保留缺少的值不变。</li></ul><h1 id="8ed9" class="mm mn iw bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">删除缺少的值</h1><p id="91d1" class="pw-post-body-paragraph lc ld iw le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ip bi translated">删除缺少的值可以是以下方法之一:</p><ul class=""><li id="cb7c" class="ly lz iw le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated">删除缺少值的行</li><li id="a4b5" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">删除包含缺失值的整列，我们可以通过指定要考虑的<code class="fe nj nk nl nm b">axis</code>来使用<code class="fe nj nk nl nm b">dropna()</code>。如果我们设置了<code class="fe nj nk nl nm b">axis = 0</code>，我们将删除整个行；如果我们设置了<code class="fe nj nk nl nm b">axis = 1</code>，我们将删除整个列。如果我们应用函数<code class="fe nj nk nl nm b">df.dropna(axis=0)</code>，数据集的80行仍然存在。如果我们应用函数<code class="fe nj nk nl nm b">df.dropna(axis=1)</code>，只有年龄、性别、抗病毒药物、组织学和类别这几列保留下来。但是，移除的值不会应用于原始数据帧，而只会应用于结果。我们可以使用参数<code class="fe nj nk nl nm b">inplace=True</code>来存储原始数据帧<code class="fe nj nk nl nm b">df</code> ( <code class="fe nj nk nl nm b">df.dropna(axis=1,inplace=True)</code>)中的更改。</li></ul><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="da07" class="nr mn iw nm b gz ns nt l nu nv">df.dropna(axis<strong class="nm ix">=</strong>1)</span></pre><figure class="km kn ko kp gu kq gi gj paragraph-image"><div class="gi gj nx"><img src="../Images/f9d7bccd9053e221a61115aa8911eb1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*5MZPfuHY4lZ8I5bCby9HNg.png"/></div></figure><p id="8ae6" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">或者，我们可以只指定必须对其应用删除操作的列。在下面的示例中，只考虑与列<code class="fe nj nk nl nm b">liver_big</code>相关的缺失行。这可以通过<code class="fe nj nk nl nm b">subset</code>参数来实现，该参数允许指定应用删除操作的列子集。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="5be8" class="nr mn iw nm b gz ns nt l nu nv">df.dropna(subset<strong class="nm ix">=</strong>['liver_big'],axis<strong class="nm ix">=</strong>0,inplace<strong class="nm ix">=True</strong>)</span></pre><p id="3932" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在我们可以检查列<code class="fe nj nk nl nm b">indirizzo</code>是否还有缺失的值。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="38df" class="nr mn iw nm b gz ns nt l nu nv">df.isna().sum()/len(df)*100</span></pre><p id="8de1" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">另一种方法是删除有一定百分比的非空值的列。这可以通过<code class="fe nj nk nl nm b">thresh</code>参数来实现。在下面的例子中，我们只保留至少有80%的非空值的列。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="7b91" class="nr mn iw nm b gz ns nt l nu nv">df.dropna(thresh<strong class="nm ix">=</strong>0.8<strong class="nm ix">*</strong>len(df),axis<strong class="nm ix">=</strong>1,inplace<strong class="nm ix">=True</strong>)</span></pre><h1 id="c457" class="mm mn iw bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">替换丢失的值</h1><p id="0ab9" class="pw-post-body-paragraph lc ld iw le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ip bi translated">处理缺失值的一个好策略是用另一个值替换它们。通常采用以下策略:</p><ul class=""><li id="262f" class="ly lz iw le b lf lg li lj ll ma lp mb lt mc lx md me mf mg bi translated">对于数值，用列的平均值替换缺少的值</li><li id="0b35" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">对于类别值，用该列中最常见的值替换缺失的值</li><li id="4001" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx md me mf mg bi translated">使用其他功能</li></ul><p id="0b36" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">为了替换丢失的值，可以使用三个函数:<code class="fe nj nk nl nm b">fillna()</code>、<code class="fe nj nk nl nm b">replace()</code>和<code class="fe nj nk nl nm b">interpolate()</code>。<code class="fe nj nk nl nm b">fillna()</code>函数用作为参数传递的值替换所有NaN值。例如，对于数值，数值列中的所有NaN值都可以替换为平均值。为了列出列的类型，我们可以使用属性<code class="fe nj nk nl nm b">dtypes</code>如下:</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="8606" class="nr mn iw nm b gz ns nt l nu nv">df.dtypes</span></pre><p id="baf8" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">它给出了以下输出:</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="2672" class="nr mn iw nm b gz ns nt l nu nv">age                  int64<br/>sex                 object<br/>steroid             object<br/>antivirals            bool<br/>fatigue             object<br/>malaise             object<br/>anorexia            object<br/>liver_big           object<br/>liver_firm          object<br/>spleen_palpable     object<br/>spiders             object<br/>ascites             object<br/>varices             object<br/>bilirubin          float64<br/>alk_phosphate      float64<br/>sgot               float64<br/>albumin            float64<br/>histology             bool<br/>class               object<br/>dtype: object</span></pre><h1 id="7eac" class="mm mn iw bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">数字列</h1><p id="aa69" class="pw-post-body-paragraph lc ld iw le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ip bi translated">首先，我们选择数字列。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="d5da" class="nr mn iw nm b gz ns nt l nu nv"><strong class="nm ix">import</strong> numpy <strong class="nm ix">as</strong> np<br/>numeric <strong class="nm ix">=</strong> df.select_dtypes(include<strong class="nm ix">=</strong>np.number)<br/>numeric_columns <strong class="nm ix">=</strong> numeric.columns</span></pre><p id="57ab" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">然后，我们用平均值填充数值列的NaN值，平均值由<code class="fe nj nk nl nm b">df.mean()</code>函数给出。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="7713" class="nr mn iw nm b gz ns nt l nu nv">df[numeric_columns] <strong class="nm ix">=</strong> df[numeric_columns].fillna(df.mean())</span></pre><p id="a851" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在，我们可以检查数字列中的NaN值是否已被删除。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="0656" class="nr mn iw nm b gz ns nt l nu nv">df.isna().sum()<strong class="nm ix">/</strong>len(df)<strong class="nm ix">*</strong>100</span></pre><p id="fca2" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">它给出了以下输出:</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="e4b8" class="nr mn iw nm b gz ns nt l nu nv">age                0.000000<br/>sex                0.000000<br/>steroid            0.689655<br/>antivirals         0.000000<br/>fatigue            0.000000<br/>malaise            0.000000<br/>anorexia           0.000000<br/>liver_big          0.000000<br/>liver_firm         0.689655<br/>spleen_palpable    0.689655<br/>spiders            0.689655<br/>ascites            0.689655<br/>varices            0.689655<br/>bilirubin          0.000000<br/>alk_phosphate      0.000000<br/>sgot               0.000000<br/>albumin            0.000000<br/>histology          0.000000<br/>class              0.000000<br/>dtype: float64</span></pre><h1 id="31ec" class="mm mn iw bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">类别列</h1><p id="e960" class="pw-post-body-paragraph lc ld iw le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ip bi translated">我们注意到在<code class="fe nj nk nl nm b">dtypes</code>中，类别列被描述为对象。因此我们可以选择<code class="fe nj nk nl nm b">object</code>列。我们只想考虑布尔列。然而，<code class="fe nj nk nl nm b">object</code>类型也包括列<code class="fe nj nk nl nm b">class</code>，它是一个字符串。我们选择所有的对象列，然后从它们中移除列<code class="fe nj nk nl nm b">class</code>。然后我们可以将结果的类型转换为<code class="fe nj nk nl nm b">bool</code>。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="fae5" class="nr mn iw nm b gz ns nt l nu nv">boolean_columns <strong class="nm ix">=</strong> df.select_dtypes(include<strong class="nm ix">=</strong>np.object).columns.tolist()<br/>boolean_columns.remove('class')<br/>df[boolean_columns] <strong class="nm ix">=</strong> df[boolean_columns].astype('bool')</span></pre><p id="ae08" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在，我们可以用最频繁的值替换所有缺少的值。我们可以使用<code class="fe nj nk nl nm b">mode()</code>函数来计算最频繁的值。我们使用<code class="fe nj nk nl nm b">fillna()</code>函数来替换丢失的值，但是我们也可以使用<code class="fe nj nk nl nm b">replace(old_value,new_value)</code>函数。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="148c" class="nr mn iw nm b gz ns nt l nu nv">df[boolean_columns].fillna(df.mode())</span></pre><p id="166e" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在我们的数据集不包含任何缺失值。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="86cf" class="nr mn iw nm b gz ns nt l nu nv">df.isna().sum()<strong class="nm ix">/</strong>len(df)<strong class="nm ix">*</strong>100</span></pre><p id="ee2e" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">它给出了以下输出:</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="65bb" class="nr mn iw nm b gz ns nt l nu nv">age                0.0<br/>sex                0.0<br/>steroid            0.0<br/>antivirals         0.0<br/>fatigue            0.0<br/>malaise            0.0<br/>anorexia           0.0<br/>liver_big          0.0<br/>liver_firm         0.0<br/>spleen_palpable    0.0<br/>spiders            0.0<br/>ascites            0.0<br/>varices            0.0<br/>bilirubin          0.0<br/>alk_phosphate      0.0<br/>sgot               0.0<br/>albumin            0.0<br/>histology          0.0<br/>class              0.0<br/>dtype: float64</span></pre><h1 id="1c1f" class="mm mn iw bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">插入文字</h1><p id="2932" class="pw-post-body-paragraph lc ld iw le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ip bi translated">替换缺失值的另一种解决方案包括使用其他函数，例如线性插值。例如，在这种情况下，我们可以用上一列和下一列之间的插值来替换一个缺失的值。这可以通过使用<code class="fe nj nk nl nm b">interpolate()</code>功能来实现。</p><p id="8376" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">因为我们已经管理了所有丢失的值，所以我们重新加载数据集。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="3527" class="nr mn iw nm b gz ns nt l nu nv">df <strong class="nm ix">=</strong> pd.read_csv('hepatitis.csv')<br/>df.isna().sum()<strong class="nm ix">/</strong>len(df)<strong class="nm ix">*</strong>100</span></pre><p id="dcf2" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们只选择数字列。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="f70e" class="nr mn iw nm b gz ns nt l nu nv">numeric <strong class="nm ix">=</strong> df.select_dtypes(include<strong class="nm ix">=</strong>np.number)<br/>numeric_columns <strong class="nm ix">=</strong> numeric.columns<br/>df.head(10)</span></pre><figure class="km kn ko kp gu kq gi gj paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gi gj ny"><img src="../Images/ba0233bfe81faa42544901b4a24faf98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ijy46k2-2t8fPMnvfSsL9g.png"/></div></div></figure><p id="803b" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在我们可以将<code class="fe nj nk nl nm b">interpolate()</code>函数应用于数字列，方法是将限制方向也设置为<code class="fe nj nk nl nm b">forward</code>。这意味着从第一行开始应用线性插值，直到最后一行。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="acb1" class="nr mn iw nm b gz ns nt l nu nv">df[numeric_columns] <strong class="nm ix">=</strong> df[numeric_columns].interpolate(method <strong class="nm ix">=</strong>'linear', limit_direction <strong class="nm ix">=</strong>'forward')</span></pre><p id="3734" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">例如，在第6行中，在插值之前为NaN的列<code class="fe nj nk nl nm b">bilirubin</code>现在假定值为0.95，这是0.90(第4行)和1.00(第6行)之间的插值。</p><pre class="km kn ko kp gu nn nm no np aw nq bi"><span id="915a" class="nr mn iw nm b gz ns nt l nu nv">df.head(10)</span></pre><figure class="km kn ko kp gu kq gi gj paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gi gj nz"><img src="../Images/6e37f91751714139002e33da351fd885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjTXAR6muwppFoQG8iPqgw.png"/></div></div></figure><h1 id="ac2f" class="mm mn iw bd mo mp mq mr ms mt mu mv mw kc mx kd my kf mz kg na ki nb kj nc nd bi translated">摘要</h1><p id="51d7" class="pw-post-body-paragraph lc ld iw le b lf ne jx lh li nf ka lk ll ng ln lo lp nh lr ls lt ni lv lw lx ip bi translated">在本教程中，我们已经看到了数据预处理的一个方面，即处理缺失数据。缺失数据会改变数据分析过程，因此必须对其进行管理。</p><p id="286c" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">可以使用三种策略来处理缺失数据:</p><ol class=""><li id="4bdd" class="ly lz iw le b lf lg li lj ll ma lp mb lt mc lx oa me mf mg bi translated">丢弃丢失的数据:当数据集有少量丢失的数据时，可以这样做</li><li id="b7c0" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx oa me mf mg bi translated">用其他值替换缺失的数据，例如平均值或最频繁出现的值</li><li id="1905" class="ly lz iw le b lf mh li mi ll mj lp mk lt ml lx oa me mf mg bi translated">让丢失的数据保持原样。</li></ol><p id="8e84" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">如果您想了解数据预处理的其他方面，如数据标准化和数据规范化，请继续关注…</p><p id="7f19" class="pw-post-body-paragraph lc ld iw le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">如果你想了解我的研究和其他活动的最新情况，你可以在<a class="ae lb" href="https://twitter.com/alod83" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae lb" href="https://www.youtube.com/channel/UC4O8-FtQqGIsgDW_ytXIWOg?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> Youtube </a>和<a class="ae lb" href="https://github.com/alod83" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我。</p></div></div>    
</body>
</html>