<html>
<head>
<title>The Learning Rate Finder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习率查找器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-learning-rate-finder-6618dfcb2025?source=collection_archive---------23-----------------------#2020-10-11">https://towardsdatascience.com/the-learning-rate-finder-6618dfcb2025?source=collection_archive---------23-----------------------#2020-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="fa16" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="bafe" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">无需昂贵的搜索即可快速到达最佳值的邻域。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5ee422c0c980f7aa409fe31f9371a8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q0YLL-JhAJrXiNPWgA9rzw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://pixabay.com/users/wokandapix-614097/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1820039" rel="noopener ugc nofollow" target="_blank"> Wokandapix </a>来自<a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1820039" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="0e77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">学习率可以说是神经网络中最重要的超参数。不幸的是，这也是最难调准的。但是不要绝望，因为学习率搜索器会让你很快得到相当不错的值！我们来看看它是如何工作的，如何在TensorFlow中实现。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/7de407b3b6a39716dc97e45e95e1e1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XhFCE0Y-JKRHMsM8.png"/></div></div></figure><h2 id="0476" class="mf mg it bd mh mi mj dn mk ml mm dp mn lr mo mp mq lv mr ms mt lz mu mv mw iz bi translated">为什么重要？</h2><p id="da1f" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">要回答这个问题，让我们从定义学习率开始。当你训练一个神经网络时，一个优化算法(通常是某种梯度下降)遍历损失函数的表面，寻求沿着损失正在减少的斜坡向下走。学习率基本上就是它所走的一步的大小。这个步长不能太小也不能太大，这非常重要。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nc"><img src="../Images/014ff87a65c425d64301973f54d00622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*vDtWuAvSKc3Jvdn77ac7XA.png"/></div></div></figure><p id="f1d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果学习率太小，该算法将需要很长时间才能达到最小值，如上图左侧面板所示。更糟糕的是，如果损失曲面中存在局部极小值，优化器可能会陷入其中，无法仅通过小的步骤摆脱出来。</p><p id="362c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，如果学习率太大，优化算法可能会超过最小值，并在最小值附近反弹，永远不会收敛，在最糟糕的情况下，它甚至会完全发散，就像上图右侧的面板一样。因此，让你的学习速度恰到好处是非常重要的！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/d071c5a67d13304ed9497db9abab23b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u4JSS93qL2dB2JMo.png"/></div></div></figure><h2 id="1687" class="mf mg it bd mh mi mj dn mk ml mm dp mn lr mo mp mq lv mr ms mt lz mu mv mw iz bi translated">为什么很难？</h2><p id="aafb" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">学习率是一个很难调整的超参数，原因有很多:</p><ul class=""><li id="241f" class="nd ne it lk b ll lm lo lp lr nf lv ng lz nh md ni nj nk nl bi translated">在大多数情况下，领域知识或以前的研究帮助不大，因为对一个问题有效的学习率可能连另一个问题的一半都不到，即使是一个密切相关的问题。</li><li id="0dca" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">通过网格搜索或随机搜索来调整学习率通常在时间和计算能力方面都很昂贵，尤其是对于大型网络。</li><li id="5cc2" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">最优学习率与其他超参数紧密耦合。因此，每次你改变正则化的数量或网络的结构，你应该重新调整学习率。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/b44a560caa35a9713163a909e473c21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9pidII2bFjwroSyF.png"/></div></div></figure><h2 id="5dc2" class="mf mg it bd mh mi mj dn mk ml mm dp mn lr mo mp mq lv mr ms mt lz mu mv mw iz bi translated">进入学习率查找器</h2><p id="dfbe" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">寻找最佳收视率在某种程度上一直是一个随机射击的游戏，直到<a class="ae lh" href="https://arxiv.org/abs/1506.01186" rel="noopener ugc nofollow" target="_blank"> Smith (2017) </a>提出了一个聪明而简单的方法。</p><p id="9de4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他注意到，通过在训练早期监测损失，可以获得足够的信息来调整学习速度。其思想是仅针对一个时期训练网络，从非常低的学习速率开始，每次迭代都增加学习速率，直到非常大的值(使得每个新的小批量都使用比前一个小批量更高的学习速率来训练)。然后，我们可以为每次迭代绘制损失与学习率(对数标度)的关系图。通常情况下，我们会得到一个类似于下图的图:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/dfb8f646f4f04be3cbfc29ab4b65bb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*S23q3qwmsia4eygAvSSPxw.png"/></div></figure><p id="a4c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为什么是这样的形状？在训练开始时，在网络的权重被随机初始化后，很容易取得进展(减少损失)。这种进步最初是缓慢的，因为我们是一小步一小步地前进，但是随着我们学习速度的提高，损失开始越来越快地减少。然而，在某一点上，学习率变得太大，损失发散。</p><p id="bc98" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基于这个情节，可以挑出一个好的学习率。然后，我们简单地用选择的值重新开始训练。你可能会问，这个最优值是多少？令人惊讶的是，这并不是损失最小的值！最佳学习率略小于或低于损失最小化值。为什么？这有两个原因。</p><ul class=""><li id="05f6" class="nd ne it lk b ll lm lo lp lr nf lv ng lz nh md ni nj nk nl bi translated">首先，至少，学习率已经太大，因为损失处于爆炸的边缘。少一点不会有太大的区别，但多一点会把一切都炸飞，所以最好还是保险一点。</li><li id="d3c5" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">其次，如果您使用一个具有动量的优化器(比如流行的Adam)，那么每次迭代的损失实际上是当前小批量损失和过去损失的移动平均值。因此，当学习率开始变得太大时，损失图不会立即爆炸，因为平均值会被过去的小损失拉低。当我们看到损失曲线飙升时，这意味着学习率已经过大一段时间了。</li></ul><p id="a15b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，对于上面的示例图，我们将选择10^-3的最优学习速率，它比最小值小大约一个数量级。</p><p id="ebd7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法可能不会选择学习率的单一最优值，但它选择的值应该非常接近最优值。然而，它最大的吸引力在于它的速度。你只需要训练一个网络一次，只有一个纪元-没有昂贵的随机搜索！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/48e2ca82b20e73f1586527714c9ec1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5Fsx1se-mOOLUslX.png"/></div></div></figure><h2 id="7a59" class="mf mg it bd mh mi mj dn mk ml mm dp mn lr mo mp mq lv mr ms mt lz mu mv mw iz bi translated">在TensorFlow中实现学习率查找器</h2><p id="5ffb" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在TensorFlow中实现这种方法非常容易。我们只需要四个组件:</p><ol class=""><li id="8a90" class="nd ne it lk b ll lm lo lp lr nf lv ng lz nh md ns nj nk nl bi translated">在每次迭代中增加学习速度的东西。</li><li id="8776" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ns nj nk nl bi translated">记录学习率和每次迭代损失的东西。</li><li id="f55c" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ns nj nk nl bi translated">在记录损失和学习率的同时训练一个时期的模型的代码。</li><li id="f165" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ns nj nk nl bi translated">密谋策划人。</li></ol><p id="4402" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">前两个可以组合在一起，作为自定义回调来实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="65f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在处理每个批处理的末尾，它会将当前的丢失率和学习率附加到为存储这些值而建立的两个相应的列表中，然后它会将学习率乘以一个因子，作为参数传递。</p><p id="8967" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们应该传递什么因子？这取决于我们想要开始的学习率的初始小值、我们最终想要在时期结束时达到的大值以及每个时期的迭代次数。</p><p id="f48e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想以0.000001的学习率开始，并在1000次迭代中指数增加，最终达到10，那么适当的乘法因子由<code class="fe nv nw nx ny b">np.exp(np.log(10 / 10**-6) / 1000)</code>给出。我们可以很容易地验证这一点:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/9dca695ee464d6a44c920be327c458d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9pu5MuTOQ5ZosCGpCtVBw.png"/></div></div></figure><p id="333d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了左边的图以对数刻度显示垂直轴(学习率)之外，这两个图是相同的。如你所见，我们确实在1000步中从0.000001到10。对数学习率线性增加，因此学习率呈指数增加。这样，我们可以比大值更详细地研究小值。</p><p id="fb93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后要避免的是我们在一个历元训练中的迭代次数——它不会总是1000。它只是训练数据中的示例数除以我们想要使用的批量大小。</p><p id="4b86" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用一个简洁的函数把它们打包在一起。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="037b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的函数将编译的TensorFlow模型作为输入，同时输入训练数据和批量大小。它首先计算我们刚刚讨论过的学习率乘法因子。为了得到一个整数，我们在计算迭代次数时使用了除法运算符(<code class="fe nv nw nx ny b">//</code>)。然后，它将模型的学习速率设置为我们开始时的最小值，并使用我们之前定义的自定义回调对其进行一个时期的训练。最后，它从回调中提取损失和学习率，并绘制它们，产生我们已经看到的图。</p><p id="94a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们在臭名昭著的时尚MNIST数据集上尝试一下。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/dfb8f646f4f04be3cbfc29ab4b65bb82.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*S23q3qwmsia4eygAvSSPxw.png"/></div></figure><p id="9ebd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如所讨论的，根据情节判断，我们宣布10^-3为最佳学习率，重新编译模型，并准备好以调整后的学习率进行训练！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/48e2ca82b20e73f1586527714c9ec1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5Fsx1se-mOOLUslX.png"/></div></div></figure><h2 id="1838" class="mf mg it bd mh mi mj dn mk ml mm dp mn lr mo mp mq lv mr ms mt lz mu mv mw iz bi translated">结论</h2><p id="76bd" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在神经网络中，学习速率是一个很难调整的超参数。但是，有一个简单的解决方案:</p><ul class=""><li id="e15b" class="nd ne it lk b ll lm lo lp lr nf lv ng lz nh md ni nj nk nl bi translated">仅在一个时期内训练网络，提高每次迭代的学习率(从非常小的值开始，到非常大的值结束)。</li><li id="ba9c" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">每次迭代后，绘制损失与对数学习率的关系图。随着学习率的增加，损失曲线可能开始以增加的速度向下倾斜，然后它将达到最小值，然后向上爆发。</li><li id="d1b0" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">最佳学习率比使图中损失最小的学习率小一个数量级。</li><li id="dda4" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated">这种调整学习率的方法可以使用自定义回调在TensorFlow中轻松实现。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/c7b94de1de307feac4f31bd26d6010f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aat6HfhxQSZGNRRD.png"/></div></div></figure><h2 id="522a" class="mf mg it bd mh mi mj dn mk ml mm dp mn lr mo mp mq lv mr ms mt lz mu mv mw iz bi translated">来源</h2><ul class=""><li id="d82b" class="nd ne it lk b ll mx lo my lr oa lv ob lz oc md ni nj nk nl bi translated">Smith (2017)，训练神经网络的循环学习率。在计算机视觉应用(WACV)，2017年IEEE冬季会议。IEEE，第464–472页。</li><li id="2394" class="nd ne it lk b ll nm lo nn lr no lv np lz nq md ni nj nk nl bi translated"><a class="ae lh" href="https://github.com/ageron/handson-ml2/blob/master/11_training_deep_neural_networks.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/ageron/hands on-ml2/blob/master/11 _ training _ deep _ neural _ networks . ipynb</a></li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/e03d6a43949d3e42c778312fd7cf5190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aastdZ4s6wDJKidm.png"/></div></div></figure><p id="649a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p><p id="4d86" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你喜欢这篇文章，为什么不在我的新文章上<a class="ae lh" href="https://michaloleszak.medium.com/subscribe" rel="noopener"> <strong class="lk jd">订阅电子邮件更新</strong> </a>？而通过<a class="ae lh" href="https://michaloleszak.medium.com/membership" rel="noopener"> <strong class="lk jd">成为媒介会员</strong> </a>，就可以支持我的写作，获得其他作者和我自己的所有故事的无限访问权。</p><p id="5b7f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要咨询？你可以问我任何事情，也可以在这里 为我预约1:1 <a class="ae lh" href="http://hiretheauthor.com/michal" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">。</strong></a></p><p id="0f9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也可以试试<a class="ae lh" href="https://michaloleszak.github.io/blog/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">我的其他文章</strong> </a>中的一篇。不能选择？从这些中选择一个:</p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/monte-carlo-dropout-7fd52f8b6571"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">蒙特卡洛辍学</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">用一个小技巧免费改善你的神经网络，获得模型不确定性估计作为奖励。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou lb og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/svm-kernels-what-do-they-actually-do-56ce36f4f7b8"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">SVM内核:他们实际上做什么？</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">直观的视觉解释</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou lb og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/calibrating-classifiers-559abc30711a"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">校准分类器</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">你确定你的模型返回概率吗？🎲</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ow l or os ot op ou lb og"/></div></div></a></div></div></div>    
</body>
</html>