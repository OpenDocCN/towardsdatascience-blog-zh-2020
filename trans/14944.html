<html>
<head>
<title>Abstract base classes and how to use them in your data science project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象基类以及如何在您的数据科学项目中使用它们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/abstract-base-classes-and-how-to-use-them-in-your-data-science-project-2503c13704f4?source=collection_archive---------22-----------------------#2020-10-14">https://towardsdatascience.com/abstract-base-classes-and-how-to-use-them-in-your-data-science-project-2503c13704f4?source=collection_archive---------22-----------------------#2020-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/256e8a2fa57a492b164bc63b5520a164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIbJiSTxZ6gdfwJLhwr2RQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">公共许可证</p></figure><div class=""/><div class=""><h2 id="eb7b" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">通过使用这种面向对象的编程构建块，编写更干净、更安全的python代码</h2></div><figure class="ku kv kw kx gt is"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="f2f6" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您是否曾经遇到过这样的代码，并且想知道这些类和方法有什么如此抽象？好吧，我要让你看看！</p><p id="3925" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果你能坚持足够长的时间，我还会分享一个小技巧，你可以用它在你的类中<strong class="lc jg">自动化单元测试</strong>。</p><h1 id="3392" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated">遗产</h1><p id="aae7" class="pw-post-body-paragraph la lb jf lc b ld mo kg lf lg mp kj li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">面向对象编程(OOP)的一个关键概念是继承。继承意味着我们将一个(子)类建立在另一个(父)类的基础上。因此，子类从其父类继承某些属性，同时实现新的属性。</p><p id="f142" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们看一个例子。假设你想写一个关于动物世界的软件库。你可能会从定义一个类<em class="mt">动物</em>开始:</p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="9a60" class="mz lx jf mv b gy na nb l nc nd">class Animal:</span><span id="a6c5" class="mz lx jf mv b gy ne nb l nc nd">    def __init__(self, height, weight):<br/>        self.height = height<br/>        self.weight = weight</span></pre><p id="065e" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">动物是一个非常笼统的术语，这就是为什么您想要创建更具体的类:</p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="90d1" class="mz lx jf mv b gy na nb l nc nd">class Dog(Animal):<br/>     <br/>    def make_sound(self):<br/>        print('woof!')</span><span id="cf83" class="mz lx jf mv b gy ne nb l nc nd">class Cat(Animal):<br/>     <br/>    def make_sound(self):<br/>        print('meow!')<br/>    <br/>    def pounce(self):<br/>        print('Pouncing at prey!')</span></pre><p id="4ebd" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在括号中写<em class="mt">动物</em>表示<em class="mt">狗</em>和<em class="mt">猫</em> <strong class="lc jg">从<em class="mt">动物</em>类继承</strong>。这意味着，不用写出来，两个动物都会自动实现<em class="mt"> __init__ </em>方法。此外，两个子类都实现了自己的方法:“make_sound”和“猛扑”。根据经验，如果你的两个类符合“A <strong class="lc jg">是a </strong> B】:“狗<strong class="lc jg">是一种</strong>动物”这句话，那么继承是有意义的。</p><p id="6568" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">假设您想要实现一个lion类。狮子是猫，所以我们希望这个类继承自猫。这样一来，<em class="mt">猫</em>从<em class="mt">动物</em>那里继承的方法也同样适用于<em class="mt">狮</em></p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="30d3" class="mz lx jf mv b gy na nb l nc nd">class Lion(Cat):<br/>     <br/>    def make_sound(self):<br/>        print('roar!')</span></pre><p id="87b5" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="mt">狮子</em>这个类现在有三个方法:<em class="mt"> __init__ </em>、<em class="mt">猛扑</em>和<em class="mt"> make_sound </em>。通过在<em class="mt"> Lion </em>类中重新定义<em class="mt"> make_sound </em>，我们已经覆盖了从<em class="mt"> Cat </em>继承的版本。</p><h1 id="d2d4" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated">抽象基类</h1><p id="70fd" class="pw-post-body-paragraph la lb jf lc b ld mo kg lf lg mp kj li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">抽象基类(ABC)提供了一种方法来管理这种继承，同时构造您的代码。一个ABC可以被看作是<strong class="lc jg">脚手架</strong>或者模板(不要和实际的模板混淆，想想:C++！)用于从它继承的所有类。</p><p id="bf25" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在Python中，可以通过继承abc来定义ABC。ABC:</p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="7cce" class="mz lx jf mv b gy na nb l nc nd">import abc <br/>class Animal(abc.ABC):</span></pre><p id="fb54" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一个ABC<strong class="lc jg">并不意味着被实例化</strong>，也就是说，一个人不应该(在某些情况下不能)创建一个ABC的对象。</p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="a157" class="mz lx jf mv b gy na nb l nc nd">my_animal = Animal(height=100, weight=80) #Don't do this!</span></pre><p id="610a" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">那么，为什么还要使用抽象基类呢？因为，就像我之前说的，他们把<strong class="lc jg">结构和安全</strong>加到你的项目里。ABC“Animal”告诉未来开发您的代码的开发人员(或未来的您)从Animal继承的任何类应该如何操作。要做到这一点，ABC有一个工具可供使用:</p><blockquote class="nf ng nh"><p id="810f" class="la lb mt lc b ld le kg lf lg lh kj li ni lk ll lm nj lo lp lq nk ls lt lu lv ij bi translated"><strong class="lc jg">抽象方法</strong></p><p id="8bd6" class="la lb mt lc b ld le kg lf lg lh kj li ni lk ll lm nj lo lp lq nk ls lt lu lv ij bi translated">抽象方法是<strong class="lc jg">必须由任何从ABC继承的类实现</strong>的方法。</p></blockquote><p id="c5ed" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">例如，我们可以决定代码中的每种动物都必须能够发出某种声音。然后我们可以定义:</p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="9536" class="mz lx jf mv b gy na nb l nc nd">from abc import ABC, <strong class="mv jg">abstractmethod</strong></span><span id="16c7" class="mz lx jf mv b gy ne nb l nc nd">class Animal(ABC):</span><span id="b3cb" class="mz lx jf mv b gy ne nb l nc nd">    def __init__(self, height, weight):<br/>        self.height = height<br/>        self.weight = weight</span><span id="c7d1" class="mz lx jf mv b gy ne nb l nc nd">    <strong class="mv jg">@abstractmethod</strong><br/>    def make_sound(self):<br/>        pass</span><span id="5c8c" class="mz lx jf mv b gy ne nb l nc nd">class Bird(Animal):</span><span id="1a39" class="mz lx jf mv b gy ne nb l nc nd">    def fly(self):<br/>        print('I am flying')</span></pre><p id="8e02" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果我们试图实例化任何没有实现抽象方法的子类，我们会得到以下错误:</p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="0e77" class="mz lx jf mv b gy na nb l nc nd">tweetie = Bird(height=5, weight=1)</span><span id="2e45" class="mz lx jf mv b gy ne nb l nc nd">&gt;&gt;&gt; TypeError: Can't instantiate abstract class Bird with abstract methods make_sound</span></pre><blockquote class="nl"><p id="e6e0" class="nm nn jf bd no np nq nr ns nt nu lv dk translated">在一个新项目的开始，开发人员应该暂停一下，考虑哪些方法对于一个类的正常运行是绝对必要的。这些方法应该被声明为<strong class="ak">抽象方法</strong>，以避免将来出现意外的运行时错误。</p></blockquote><p id="f656" class="pw-post-body-paragraph la lb jf lc b ld nv kg lf lg nw kj li lj nx ll lm ln ny lp lq lr nz lt lu lv ij bi translated">在我看来，这在Python这样的非编译语言中尤其重要，这种语言在这些错误面前非常脆弱。</p><h1 id="f974" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated"><strong class="ak">现实生活中的例子</strong></h1><p id="52b8" class="pw-post-body-paragraph la lb jf lc b ld mo kg lf lg mp kj li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">许多流行的数据科学和机器学习库使用抽象基类。其中一个库是scikit-learn。本文开头的代码片段包含scikit-learn对一个“内核”基类的实现。核用于支持向量机、核脊和高斯过程方法等。它们可以被视为两个向量之间的距离度量。您可能熟悉径向基函数(RBF)或平方指数核</p><figure class="ku kv kw kx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/40b3f94ac60dff88ebd88bc4d90ba677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uK7CZytWPthjeXz8NuUBcw.png"/></div></div></figure><p id="42fc" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是还有许多其他的存在并在scikit-learn中实现。</p><p id="bc86" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">所有这些内核的共同点是(在scikit-learn中)它们继承自<em class="mt">内核</em> ABC:</p><figure class="ku kv kw kx gt is"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="31df" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过使用<em class="mt"> __call__ </em>和<em class="mt"> is_stationary </em>抽象方法，scikit-learn确保每个新内核都将实现这些方法。至少在<em class="mt"> __call__(self，X，Y) </em>的情况下，这是非常合理的，作为在两个输入矩阵上评估内核的函数是绝对必要的。没有它，内核就没有多大用处。</p><h1 id="b662" class="lw lx jf bd ly lz ma mb mc md me mf mg kl mh km mi ko mj kp mk kr ml ks mm mn bi translated">注册和单元测试</h1><p id="28b3" class="pw-post-body-paragraph la lb jf lc b ld mo kg lf lg mp kj li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">为内核类的每个新的子类自动生成单元测试不是很好吗？</p><p id="115c" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">谢天谢地，有！</p><h2 id="8eac" class="mz lx jf bd ly ob oc dn mc od oe dp mg lj of og mi ln oh oi mk lr oj ok mm ol bi translated">注册</h2><p id="5ab8" class="pw-post-body-paragraph la lb jf lc b ld mo kg lf lg mp kj li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">通过创建一个所谓的<strong class="lc jg">注册表</strong>，我们只需要实现一个单元测试一次，就可以在我们的类中应用它(人们可以用注册表做其他有趣的事情，但是我不会在这里详细讨论)。</p><p id="4a0c" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">注册表只是记录你创建的所有类。为了用Python实现注册中心，我们需要使用<strong class="lc jg">元类</strong>。</p><p id="742c" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">什么是元类？</p><p id="56bd" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">看待它的一种方式如下:</p><blockquote class="nf ng nh"><p id="66c9" class="la lb mt lc b ld le kg lf lg lh kj li ni lk ll lm nj lo lp lq nk ls lt lu lv ij bi translated">类告诉Python类的实例如何行为，而元类定义了类本身的行为。[1]</p></blockquote><p id="8c8b" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">因此，通过使用元类，我们可以告诉Python:“每当实现一个新类时，在注册表中创建一个新条目”</p><p id="a9cf" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果这一切听起来非常混乱，您也可以将以下代码复制粘贴到您的项目中:</p><figure class="ku kv kw kx gt is"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="cda7" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="mt">(注意，原则上注册中心不必继承ABCMeta，但是将两者结合起来通常是有意义的。)</em></p><p id="42cc" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们回到我们的内核例子。我们现在写的不是从ABC继承的</p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="12e7" class="mz lx jf mv b gy na nb l nc nd">class Kernel(<strong class="mv jg">metaclass=ABCRegistry</strong>):   <br/>    <strong class="mv jg">_registry_name = 'kernel'</strong><br/>    ...</span><span id="fda7" class="mz lx jf mv b gy ne nb l nc nd">class RBF(Kernel):<br/>    <strong class="mv jg">_registry_name = 'rbf'</strong><br/>    ...</span><span id="2d7b" class="mz lx jf mv b gy ne nb l nc nd">class DotProduct(Kernel):<br/>    <strong class="mv jg">_registry_name = 'dotproduct'</strong><br/>    ...</span></pre><p id="f695" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过创建attribute _registry_name，我们告诉我们的注册表如何调用这些类。访问注册表将产生以下输出:</p><pre class="ku kv kw kx gt mu mv mw mx aw my bi"><span id="baec" class="mz lx jf mv b gy na nb l nc nd">Kernel.get_registry()<br/>&gt;&gt;&gt; {'kernel': Kernel, 'rbf': RBF, 'dot': Dot}</span></pre><h2 id="e7ea" class="mz lx jf bd ly ob oc dn mc od oe dp mg lj of og mi ln oh oi mk lr oj ok mm ol bi translated">单元测试</h2><p id="2520" class="pw-post-body-paragraph la lb jf lc b ld mo kg lf lg mp kj li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">假设我们想要测试我们实现的内核是否是对称的:</p><blockquote class="nf ng nh"><p id="2dca" class="la lb mt lc b ld le kg lf lg lh kj li ni lk ll lm nj lo lp lq nk ls lt lu lv ij bi translated"><strong class="lc jg"> K(X，Y) = K(Y，X) </strong></p></blockquote><p id="7010" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">每个有效的内核都必须遵守这个条件，所以测试它是很有意义的。</p><p id="1826" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">使用<strong class="lc jg"> pytest </strong>及其<em class="mt">参数化</em>功能，我们现在可以自动将测试应用到从“内核”继承的每个类:</p><figure class="ku kv kw kx gt is"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="3400" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当然，人们总是可以显式地循环所有相关的类。使用注册表的好处是，添加新类的贡献者也不需要担心向适当的测试添加条目。</p><p id="e804" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="mt">如果你喜欢这篇文章，请随时关注我，在</em><a class="ae om" href="https://twitter.com/semodi92" rel="noopener ugc nofollow" target="_blank"><em class="mt">Twitter</em></a><em class="mt">或在</em><a class="ae om" href="https://www.linkedin.com/in/sebastianmdick/" rel="noopener ugc nofollow" target="_blank"><em class="mt">LinkedIn</em></a><em class="mt">上联系。</em></p><p id="ee9b" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc jg">参考文献</strong></p><p id="2b65" class="pw-post-body-paragraph la lb jf lc b ld le kg lf lg lh kj li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">[1]大致基于托马斯·伍特斯对斯塔克伟福的解释。</p></div></div>    
</body>
</html>