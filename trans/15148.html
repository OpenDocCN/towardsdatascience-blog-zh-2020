<html>
<head>
<title>Outlier Detection with RNN Autoencoders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用RNN自动编码器检测异常值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/outlier-detection-with-rnn-autoencoders-b82e2c230ed9?source=collection_archive---------27-----------------------#2020-10-18">https://towardsdatascience.com/outlier-detection-with-rnn-autoencoders-b82e2c230ed9?source=collection_archive---------27-----------------------#2020-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="371d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用重构自动编码器模型检测时间序列数据中的异常。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c9081d4baa8327e6cd1f34177648c6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yfc79GWdxtnBvdAMIoWiIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="1aed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="lr">注来自《走向数据科学》的编辑:</em> </strong> <em class="lr">虽然我们允许独立作者根据我们的</em> <a class="ae ls" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="lr">规则和指导方针</em> </a> <em class="lr">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae ls" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="lr">读者术语</em> </a> <em class="lr">。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="967f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">TL DR:</em><a class="ae ls" href="https://github.com/David-Woroniuk/Historic_Crypto" rel="noopener ugc nofollow" target="_blank"><em class="lr">Historic-Crypto Package</em></a><em class="lr"/><a class="ae ls" href="https://github.com/David-Woroniuk/Medium-Articles/blob/master/RNN_Time_Series_Outlier_Detection.ipynb" rel="noopener ugc nofollow" target="_blank"><em class="lr">Code</em></a><em class="lr">。</em></p><h1 id="b93e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">什么是异常？</strong></h1><p id="c238" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">异常值，通常被称为离群值，是指不符合数据序列总体行为的数据点、数据序列或数据模式。因此，异常检测的任务是检测与更广泛的数据中存在的模式不一致的数据点或序列。</p><p id="feec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">异常数据的有效检测和删除可以为许多业务功能提供非常有用的洞察力，例如检测网站中嵌入的断开链接、互联网流量峰值或股票价格的剧烈变化。将这些现象标记为异常值，或制定预先计划的响应可以节省企业的时间和金钱。</p><h1 id="dbc5" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">异常的类型？</strong></h1><p id="6709" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">异常数据通常可以分为三个不同的类别，<strong class="kx ir"><em class="lr"/></strong><strong class="kx ir"><em class="lr">时间变化</em> </strong>或<strong class="kx ir"> <em class="lr">电平移动</em> </strong>。</p><p id="dd46" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="lr">加性异常值</em> </strong>表现为数值的突然大幅增加或减少，可由外源或内源因素驱动。附加异常值的例子可能是由于在电视上出现而导致的网站流量的大幅增加(外生)，或者由于强劲的季度表现而导致的股票交易量的短期增加(内生)。</p><p id="a4b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="lr">时间变化</em> </strong>的特点是序列较短，不符合数据中更广泛的趋势。例如，如果网站服务器崩溃，对于一系列数据点，网站流量将降至零，直到服务器重启，此时正常流量将恢复。</p><p id="1d60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="lr">电平转换</em> </strong>是大宗商品市场的常见现象，因为对电力的高需求与恶劣的天气条件有着内在联系。因此，由于天气驱动的需求曲线和可再生能源发电曲线的变化，可以观察到夏季和冬季电价之间的“水平变化”。</p><h1 id="928e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">什么是自动编码器？</strong></h1><p id="2d71" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">自动编码器是设计用来学习给定输入的低维表示的神经网络。自动编码器通常由两个组件组成:一个<strong class="kx ir"> <em class="lr">编码器</em> </strong>，它学习将输入数据映射到更低维度的表示；一个<strong class="kx ir"> <em class="lr">解码器</em> </strong>，它学习将表示映射回输入数据。</p><p id="656d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于这种架构，编码器网络迭代地学习有效的数据压缩函数，该函数将数据映射到较低维度的表示。在训练之后，解码器能够成功地重建原始输入数据，因为重建误差(<em class="lr">输入和由解码器</em>产生的重建输出之间的差)是整个训练过程的目标函数。</p><h1 id="08c7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">实施</strong></h1><p id="62f7" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">现在我们已经理解了自动编码器模型的底层架构，我们可以开始实现这个模型了。</p><p id="cfbf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一步是安装我们将使用的库、包和模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ffc7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其次，我们需要获得一些数据进行分析。本文使用<a class="ae ls" href="https://github.com/David-Woroniuk/Historic_Crypto" rel="noopener ugc nofollow" target="_blank"> Historic-Crypto </a>包获取从<code class="fe mz na nb nc b">‘2013–06–06’</code>到现在的历史比特币<code class="fe mz na nb nc b">(‘BTC’)</code>数据。下面的代码还生成每日比特币回报和当天价格波动，然后删除任何丢失的数据行并返回数据帧的前5行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f6ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经获得了一些数据，我们应该直观地扫描每个序列，寻找潜在的异常值。下面的<code class="fe mz na nb nc b">plot_dates_values</code>函数支持数据框中包含的每个系列的迭代绘图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ff11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以迭代调用上述函数，为比特币的交易量、收盘价、开盘价、波动率和回报率生成Plotly图表。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="06f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，2020年交易量出现了大量峰值，调查这些峰值是异常的还是更广泛系列的指示可能是有用的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="c559" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2018年收盘价存在明显的飙升，随后暴跌至技术支持水平。然而，积极的趋势广泛存在于所有数据中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="6bf8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每日开盘价遵循与上述收盘价相似的模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="5ede" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">价格波动在2018年和2020年都出现了一些明显的峰值。因此，我们可以调查这些波动峰值是否被自动编码器模型视为异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="18bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于回报序列的随机性质，我们选择测试比特币每日交易量中的异常值，如<code class="fe mz na nb nc b">Volume</code>所示。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="2b28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们可以开始自动编码器模型的数据预处理。数据预处理的第一步是确定训练数据和测试数据之间的适当拆分。下面概述的<code class="fe mz na nb nc b">generate_train_test_split</code>功能支持按日期拆分培训和测试数据。在调用下面的函数时，生成两个数据帧，即<code class="fe mz na nb nc b">training_data</code>和<code class="fe mz na nb nc b">testing_data</code>作为全局变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="36b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了提高模型的准确性，我们可以“标准化”或缩放数据。该函数缩放上面生成的<code class="fe mz na nb nc b">training_data</code>数据帧，保存<code class="fe mz na nb nc b">training_mean</code>和<code class="fe mz na nb nc b">training_std</code>用于以后标准化测试数据。</p><p id="e68f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> <em class="lr">注:</em> </strong> <em class="lr">使用相同的尺度对训练和测试数据进行尺度转换是很重要的，否则尺度的差异会产生可解释性问题和模型不一致。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7e50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们在上面调用的<code class="fe mz na nb nc b">normalise_training_values</code>函数，我们现在有一个包含标准化训练数据的numpy数组，称为<code class="fe mz na nb nc b">training_values</code>，我们已经将<code class="fe mz na nb nc b">training_mean</code>和<code class="fe mz na nb nc b">training_std</code>存储为用于标准化测试集的全局变量。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="8506" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以开始生成一系列可用于训练自动编码器模型的序列。我们定义该模型将被提供30个先前的观察值，提供形状的3D训练数据(2004，30，1):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ac48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经完成了训练数据处理，我们可以定义自动编码器模型，然后根据训练数据拟合该模型。<code class="fe mz na nb nc b">define_model</code>函数利用训练数据形状来定义适当的模型，返回自动编码器模型和自动编码器模型的摘要。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="790f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随后，<code class="fe mz na nb nc b">model_fit</code>函数在内部调用<code class="fe mz na nb nc b">define_model</code>函数，然后向模型提供<code class="fe mz na nb nc b">epochs</code>、<code class="fe mz na nb nc b">batch_size</code>和<code class="fe mz na nb nc b">validation_loss</code>参数。然后调用这个函数，开始模型训练过程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f296" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦对模型进行了训练，绘制训练和验证损失曲线以了解模型是否存在偏差(欠拟合)或方差(过拟合)是很重要的。这可以通过调用下面的<code class="fe mz na nb nc b">plot_training_validation_loss</code>函数来观察。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="0d4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，训练和验证损失曲线在整个图表中趋于一致，验证损失仍然略大于训练损失。给定形状和相对误差，我们可以确定自动编码器模型没有欠拟合或过拟合。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="b4e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们可以定义重建误差，这是自动编码器模型的核心原则之一。重建误差表示为<code class="fe mz na nb nc b">train_mae_loss</code>，重建误差阈值确定为<code class="fe mz na nb nc b">train_mae_loss</code>的最大值。因此，当计算测试误差时，任何大于最大值<code class="fe mz na nb nc b">train_mae_loss</code>的值都可以被认为是异常值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="ac80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面，我们将<code class="fe mz na nb nc b">training_mean</code>和<code class="fe mz na nb nc b">training_std</code>保存为全局变量，以便使用它们来缩放测试数据。我们现在定义<code class="fe mz na nb nc b">normalise_testing_values</code>函数来缩放测试数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="fa10" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随后，在<code class="fe mz na nb nc b">testing_data</code>的<code class="fe mz na nb nc b">Volume</code>列调用该函数。因此，<code class="fe mz na nb nc b">test_value</code>被具体化为一个numpy数组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8c62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，定义<code class="fe mz na nb nc b">generate_testing_loss</code>函数，计算重建数据和测试数据之间的差异。如果任何值大于<code class="fe mz na nb nc b">train_mae_loss</code>的最大值，它们被存储在全局异常列表中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cb56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，还介绍了试验MAE损失的分布，以便与训练MAE损失进行直接比较。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="cf44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，异常值如下图所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e76d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由自动编码器模型表征的异常数据用橙色表示，而符合的数据用蓝色表示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd my l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由作者生成的图像。</p></figure><p id="930c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到，2020年很大一部分比特币交易量数据被认为是异常的——可能是由于新冠肺炎推动的零售交易活动增加？</p><p id="00c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尝试Autoencoder参数和数据集——看看你能否在比特币收盘价中找到任何异常——或者使用<a class="ae ls" href="https://github.com/David-Woroniuk/Historic_Crypto" rel="noopener ugc nofollow" target="_blank">historical-Crypto</a>库下载不同的加密货币！</p><p id="7562" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编码快乐！</p></div></div>    
</body>
</html>