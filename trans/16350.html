<html>
<head>
<title>Don’t Make These 5 Mistakes with SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要在SQL上犯这5个错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-repeat-these-5-mistakes-with-sql-9f61d6f5324f?source=collection_archive---------12-----------------------#2020-11-11">https://towardsdatascience.com/dont-repeat-these-5-mistakes-with-sql-9f61d6f5324f?source=collection_archive---------12-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b261" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用SQL进行数据分析非常简单……但事实并非如此！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/432ebed9d752e5a10168fdb2b8699111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z3Jlcx6Ebvkx9yZ0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@krakenimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> krakenimages </a>拍摄的照片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="kz la l"/></div></figure><p id="e146" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">SQL和机器学习有一些共同点。从一个开始很容易，因为它不需要很多编码。此外，代码很少崩溃。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx la l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我关于SQL和机器学习的推文。</p></figure><p id="2705" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我认为SQL查询不会崩溃的事实使得数据分析更加困难。我从数据库中提取了多少数据集，结果发现有错误或丢失的数据？很多！</p><p id="272c" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果代码只是崩溃，我知道我搞砸了。数据科学家需要在数据验证上花费相当多的时间，因为SQL查询总是会返回一些东西。</p><blockquote class="ly"><p id="b41d" class="lz ma it bd mb mc md me mf mg mh lw dk translated">这是你在编写SQL查询时应该避免的5个错误。</p></blockquote><p id="3b57" class="pw-post-body-paragraph lb lc it ld b le mi ju lg lh mj jx lj lk mk lm ln lo ml lq lr ls mm lu lv lw im bi translated"><strong class="ld iu">这里有几个你可能会感兴趣的链接:</strong></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="a134" class="ms mt it mo b gy mu mv l mw mx">- <a class="ae ky" href="https://trymito.io/" rel="noopener ugc nofollow" target="_blank">Complete your Python analyses 10x faster with Mito</a> [Product]</span><span id="fb91" class="ms mt it mo b gy my mv l mw mx">- <a class="ae ky" href="https://aigents.co/skills" rel="noopener ugc nofollow" target="_blank">Free skill tests for Data Scientists &amp; ML Engineers</a> [Test]</span><span id="1e41" class="ms mt it mo b gy my mv l mw mx">- <a class="ae ky" href="https://imp.i115008.net/c/2402645/1116216/11298" rel="noopener ugc nofollow" target="_blank">All New Self-Driving Car Engineer Nanodegree</a><strong class="mo iu"> </strong>[Course]</span></pre><p id="3897" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">您愿意阅读更多这样的文章吗？如果是这样，你可以点击上面的任何链接来支持我。其中一些是附属链接，但你不需要购买任何东西。</p><h1 id="753a" class="na mt it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">1.不知道查询执行的顺序</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/d5da1732c7be7e8f2ff24e28ace0700c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfNibhiCNhOl7LVJlyjmcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SQL查询执行顺序</p></figure><p id="1867" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">SQL进入门槛低。您开始编写查询——到处使用连接，进行一些分组，您已经是专家了(至少有些人是这样认为的)。</p><p id="7bd0" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><strong class="ld iu">但是所谓的专家甚至不知道SQL查询以什么顺序执行吗？</strong></p><p id="1400" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">SQL查询不是以SELECT开头的——当我们编写它们时，它们在编辑器中，但是数据库不是以SELECT开头的。</p><p id="4afb" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">数据库开始使用FROM和JOIN执行查询。这就是为什么我们可以在WHERE中使用连接表中的字段。</p><p id="1958" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为什么在WHERE中不能过滤GROUP BY的结果？因为GROUP BY在WHERE之后执行。因此我们有理由。</p><p id="7f60" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">最后，我们来选择。它选择要包含的列，并定义要计算的聚合。此外，窗口函数在这里执行。</p><p id="3368" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这就解释了为什么我们在WHERE中尝试使用窗口函数的输出进行过滤时会出现错误。</p><p id="39b1" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">注意，数据库使用查询优化器来优化查询的执行。优化器可能会更改某些操作的顺序，以便查询运行得更快。此图是幕后发生的事情的高级概述。</p><h1 id="7c2a" class="na mt it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated"><strong class="ak"> 2。窗口函数实际上是做什么的？</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/e6ebb46eb3bbd526a4bd5102c00b8c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etJUrIF9vuDSevuujGIksw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用求和窗口函数的变换示例</p></figure><p id="0a09" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当我第一次遇到窗口函数时，我觉得它们很神秘。为什么使用窗口函数作为分组依据可以聚集数据？</p><p id="e090" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在设计查询时，窗口函数(WF)简化了许多操作:</p><ul class=""><li id="9bce" class="nt nu it ld b le lf lh li lk nv lo nw ls nx lw ny nz oa ob bi translated">WF允许访问当前记录之前和之后的记录。请参见超前和滞后函数。</li><li id="2c15" class="nt nu it ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated">WF可以使用GROUP BY对已经聚合的数据执行额外的聚合。请看上图中的例子，我用WF计算销售额。</li><li id="5995" class="nt nu it ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated">ROW_NUMBER WF枚举行。我们还可以用它来删除重复的记录。或者随机抽取样本。</li><li id="75e2" class="nt nu it ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated">顾名思义，WF可以计算给定窗口的统计数据:</li></ul><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8cdc" class="ms mt it mo b gy mu mv l mw mx">sum(sales) OVER (PARTITION BY CustomerID BY ts ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as cumulative_sum</span></pre><p id="af1f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">上面的WF将计算从第一条记录到当前记录的累积和。</p><p id="d270" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我在哪里做错了窗口函数？</p><p id="7d84" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我没有花时间去读一个教程来解释窗口函数的基础和功能。因此，我避免使用它们，查询变得过于复杂。然后虫子爬进来。</p><p id="685f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><strong class="ld iu">运行上面的例子</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/ce64c68ce0e0b6a3c565e30902661629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q92t-iD5jvUhSHltYleMAQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行SQL中的例子<a class="ae ky" href="http://SQL Fiddle" rel="noopener ugc nofollow" target="_blank">瞎搞</a></p></figure><p id="989d" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我收到了许多读者的请求，他们想玩上面的例子。现在，您可以在<a class="ae ky" href="http://sqlfiddle.com/#!15/9eecb7db59d16c80417c72d1e1f4fbf1/35342" rel="noopener ugc nofollow" target="_blank"> SQL Fiddle </a>中在线运行该示例。</p><p id="4cfe" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果您想在本地数据库中尝试一下，下面是代码(它应该可以与PostgreSQL 9.3一起使用):</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7dc5" class="ms mt it mo b gy mu mv l mw mx">DROP TABLE IF EXISTS sales_table;<br/>CREATE TEMPORARY TABLE sales_table<br/>(<br/>    key       varchar(6),<br/>    customerID  varchar(10),<br/>    productID   varchar(10),<br/>    price     float<br/>);</span><span id="70e4" class="ms mt it mo b gy my mv l mw mx">INSERT INTO sales_table<br/>VALUES ('1', 'Customer1', 'Product1', 100),<br/>       ('2', 'Customer1', 'Product1', 200),<br/>       ('3', 'Customer1', 'Product2', 100),<br/>       ('4', 'Customer2', 'Product2', 200),<br/>       ('5', 'Customer2', 'Product3', 100);</span><span id="4894" class="ms mt it mo b gy my mv l mw mx">SELECT customerID,<br/>       productID,<br/>       SUM(price) AS sales,<br/>       SUM(SUM(price)) OVER (PARTITION BY customerID) AS sales_all<br/>FROM sales_table<br/>GROUP BY customerID, productID<br/>ORDER BY customerID, productID</span></pre><h1 id="3d92" class="na mt it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">3.在下列情况下计算平均值</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/32741db3634ce6433fe83579cc9ab09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cr1K1J5h_p8moCSiIPXyig.png"/></div></div></figure><p id="0488" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">CASE WHEN类似于编程语言中的IF语句。当我们需要计算某个数据子集的统计数据时，这很有用。</p><p id="7021" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在上图中，我计算了在美国销售的产品的平均价格。我不小心碰到了其他的东西。</p><p id="8e28" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在第一个例子中，我对所有非美国产品使用0，这降低了整体平均价格。如果有许多非美国产品，平均价格可能会接近0。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6f3b" class="ms mt it mo b gy mu mv l mw mx">SELECT product, AVG(CASE WHEN country = 'US' then price else 0 end) AS avg_price<br/>FROM sales<br/>GROUP BY product</span></pre><p id="f547" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在第二个例子中，我只计算在美国销售的产品的平均价格，这通常是我们想要的。<br/>注意，使用CASE WHEN时不需要包含ELSE，因为它默认为NULL。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="3b40" class="ms mt it mo b gy mu mv l mw mx">SELECT product, AVG(CASE WHEN country = 'US' then price else null end) AS avg_price<br/>FROM sales<br/>GROUP BY product</span></pre><p id="a504" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">关键的要点是，在使用CASE WHEN时，应该小心使用“else 0”。它对SUM没有任何影响，但对AVG有巨大的影响。</p><h1 id="280b" class="na mt it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">4.对缺少值的列进行联接</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/9c995be8bc8ceba26fd8ec5ce461ddfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49kG78f7H1dY8BS1wuK5zw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个字符串字段的简单内部连接</p></figure><p id="8aa5" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">SQL中有4种不同的连接:内连接、外连接、左连接和右连接。当我们在查询中使用JOIN时，它默认为内部连接。</p><p id="cacb" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">幸运的是，我花时间阅读了一些关于连接的教程。但我还是犯了一个菜鸟的错误。</p><p id="7433" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我编写了一个类似于上图中查询的核心查询。当我执行数据验证时，许多记录丢失了。这怎么可能呢？这是一个如此简单的连接！</p><p id="aafd" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">结果是，表1和表2中的许多条目的string_field列为空值。我以为JOIN会保留空值的记录，因为NULL等于NULL，不是吗？</p><p id="0d05" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">然后我试着:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="495d" class="ms mt it mo b gy mu mv l mw mx">SELECT NULL = NULL</span></pre><p id="f887" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">它返回NULL。</p><p id="478a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">获取所有条目的解决方案是在COALESCE中包装string_field，将NULL转换为空字符串。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2ff7" class="ms mt it mo b gy mu mv l mw mx">SELECT t1.*, <br/>       t2.price<br/>FROM table1 AS t1<br/>JOIN table2 AS t2<br/>ON COALESCE(t1.string_field, '') = COALESCE(t2.string_field, '')</span></pre><p id="be92" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><strong class="ld iu">但是要小心，因为这会将表1中带有空字符串的每个条目与表2中带有空字符串的每个条目连接起来。</strong></p><p id="497a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">消除这些重复的一种方法是使用ROW_NUMBER()窗口函数:</p><ul class=""><li id="4409" class="nt nu it ld b le lf lh li lk nv lo nw ls nx lw ny nz oa ob bi translated">我假设每行都有一个惟一的标识符“some_id”和一个时间戳字段。</li><li id="cdea" class="nt nu it ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated">只需包装查询，并获取每个唯一标识符的第一行以删除重复项。</li></ul><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="0600" class="ms mt it mo b gy mu mv l mw mx">SELECT *<br/>FROM (<br/>SELECT t1.*, <br/>       t2.price,<br/>       <!-- -->ROW_NUMBER() OVER(PARTITION by some_id ORDER BY timestamp_field) as row_count<br/>FROM table1 AS t1<br/>JOIN table2 AS t2<br/>ON COALESCE(t1.string_field, '') = COALESCE(t2.string_field, '')<br/>)<br/>WHERE <!-- -->row_count = 1</span></pre><h1 id="9846" class="na mt it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">5.复杂查询不使用临时表</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/1e334a1fb6b4c85a4e2d456bfdf44b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H97_fQxNW5TRJDlFFcL5Eg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在临时表中包装查询</p></figure><p id="705f" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果我们能调试查询，SQL就太好了。如果我告诉你可以调试它们呢！</p><p id="54a8" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">您可以分解一个复杂的查询并创建多个临时表。然后，您可以对这些表运行“健全性检查”查询，以确保它们包含正确的条目。在设计新的重要查询或报告时，我强烈推荐这种方法。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="8e54" class="ms mt it mo b gy mu mv l mw mx">DROP TABLE IF EXISTS trainset;<br/>CREATE TEMPORARY TABLE trainset AS (<br/>  SELECT *<br/>  FROM table_1<br/>  WHERE field = 1<br/>);</span></pre><p id="64ed" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">临时表的唯一缺点是数据库中的查询优化器不能优化查询。</p><p id="ae31" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当需要性能时，我将使用临时表定义的查询重写为使用with语句定义的查询。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="cb74" class="ms mt it mo b gy mu mv l mw mx">WITH helper_table1 AS (<br/>  SELECT *<br/>  FROM table_1<br/>  WHERE field = 1<br/>),</span><span id="c654" class="ms mt it mo b gy my mv l mw mx">helper_table2 AS (<br/>  SELECT *<br/>  FROM table_2<br/>  WHERE field = 1<br/>),</span><span id="5e1d" class="ms mt it mo b gy my mv l mw mx">helper_table3 AS (<br/>  SELECT *<br/>  FROM helper_table1 as ht1<br/>  JOIN helper_table2 as ht2<br/>  ON ht1.field = ht2.field<br/>)</span><span id="678e" class="ms mt it mo b gy my mv l mw mx">SELECT * FROM helper_table3;</span></pre><h1 id="0a73" class="na mt it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">在你走之前</h1><p id="cf78" class="pw-post-body-paragraph lb lc it ld b le ok ju lg lh ol jx lj lk om lm ln lo on lq lr ls oo lu lv lw im bi translated">在<a class="ae ky" href="https://twitter.com/romanorac" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，在那里我定期<a class="ae ky" href="https://twitter.com/romanorac/status/1328952374447267843" rel="noopener ugc nofollow" target="_blank">发关于数据科学和机器学习的推特</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c8a6809e5d29174e15e724b68a0dc16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*APR38Zjs4jrKxEr4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cmhedger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Courtney hedge</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div></div>    
</body>
</html>