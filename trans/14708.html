<html>
<head>
<title>New Java 15 Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 15的新特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/new-java-15-features-47dac2333aa8?source=collection_archive---------28-----------------------#2020-10-10">https://towardsdatascience.com/new-java-15-features-47dac2333aa8?source=collection_archive---------28-----------------------#2020-10-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="82f7" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">本地记录和密封类在Java 15中找到了自己的路</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/bed5a24b741a25ba582bc3989cd4715c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rDzTqBf3NpWFFzmW"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@oriento?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">五玄土 ORIENTO</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="286c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">保持六个月周期的传统，在2020年3月17日发布了<a class="ae kz" href="https://medium.com/better-programming/whats-new-java-14-features-6b5856c94aa4" rel="noopener"> Java 14 </a>之后，我们现在有了Java 15，下一个非LTS版本将于2020年9月15日推出。</p><p id="6a5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面快速浏览一下Java 15的一些特性:</p><ul class=""><li id="ac21" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">密封类(预览)— JEP 360</li><li id="a041" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe mk ml mm mn b">instanceof</code>(第二次预览)— JEP 375的模式匹配</li><li id="b7e7" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">记录(第二次预览)— JEP 359</li><li id="4e09" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">文本块(标准)— JEP 378</li><li id="3de1" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">隐藏类— JEP 371</li><li id="a5df" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">移除Nashorn JavaScript引擎— JEP 372</li><li id="645a" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">重新实现传统DatagramSocket API — JEP 373</li><li id="ee6c" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">禁用和反对偏向锁定— JEP 374</li><li id="cbc2" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">谢南多厄:一个低停顿时间的垃圾收集器——JEP 379</li><li id="98e1" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">删除Solaris和SPARC端口— JEP 381</li><li id="f830" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">外部存储器访问API(第二个孵化器)— JEP 383</li><li id="e4d9" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">不赞成激活RMI进行删除— JEP 385</li></ul></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="6260" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">Mac OS上的Java 15安装设置</h1><ul class=""><li id="1cbc" class="lw lx iu lc b ld nn lg no lj np ln nq lr nr lv mb mc md me bi translated">要开始使用Java 15，请从这里的<a class="ae kz" href="http://jdk.java.net/15/" rel="noopener ugc nofollow" target="_blank">下载JDK。</a></li><li id="d79a" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">复制并提取<code class="fe mk ml mm mn b">/Library/Java/JavaVirtualMachines</code>中的tar文件，如下图所示:</li></ul><pre class="kk kl km kn gu ns mn nt nu aw nv bi"><span id="49c4" class="nw mw iu mn b gz nx ny l nz oa">$ cd /Library/Java/JavaVirtualMachines <br/>$ sudo cp ~/Downloads/openjdk-15_osx-x64_bin.tar.gz /Library/Java/JavaVirtualMachines</span><span id="a10b" class="nw mw iu mn b gz ob ny l nz oa">$ sudo tar xzf openjdk-15_osx-x64_bin.tar.gz <br/>$ sudo rm openjdk-15_osx-x64_bin.tar.gz</span></pre><p id="cd82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦完成，使用任何文本编辑器打开<code class="fe mk ml mm mn b">bash_profile</code>。我用的是<code class="fe mk ml mm mn b">vim ~/.bash_profile</code>。将Java15的路径设置为JAVA_HOME，保存更改并执行<code class="fe mk ml mm mn b">source ~/.bash_profile</code>以反映更改。</p><pre class="kk kl km kn gu ns mn nt nu aw nv bi"><span id="fa1a" class="nw mw iu mn b gz nx ny l nz oa">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-15.jdk/Contents/Home</span></pre><p id="a86b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，您已经准备好使用Java 15编译和运行程序了。我们将使用JShell，一个交互式REPL命令行工具，用于快速测试Java 15的新特性。</p><p id="3e3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值得注意的是，Java 15中发布的许多特性都在预览版中。这意味着尽管他们现在正在全力工作，但将来可能会有所改变。有些可能会成为标准，或者在下一个发布周期中被删除。为了测试预览功能，您需要在运行JShell或Java程序时显式设置<code class="fe mk ml mm mn b">--enable-preview</code>，如下所示:</p><pre class="kk kl km kn gu ns mn nt nu aw nv bi"><span id="087b" class="nw mw iu mn b gz nx ny l nz oa">jshell --enable-preview javac --release 15 --enable-preview Author.java</span></pre><p id="d5ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，让我们讨论Java 15中的重大语言变化。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="905f" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">1.密封类(预览)</h1><p id="618b" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">Kotlin中的密封类已经存在一段时间了，Java 15最终引入了这个特性，以便更好地控制继承。</p><p id="e797" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">顾名思义，密封类允许您将类层次结构限制或允许给某些类型。</p><p id="f57b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这对于模式匹配非常有用，因为您有特定数量的类要在它们之间进行<code class="fe mk ml mm mn b">switch</code>。</p><p id="c577" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下语法在Java 15中定义了一个密封类:</p><pre class="kk kl km kn gu ns mn nt nu aw nv bi"><span id="101a" class="nw mw iu mn b gz nx ny l nz oa">public sealed class Vehicle permits Car, Bike, Truck { ... }</span></pre><p id="9636" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，上面的代码意味着，只有在关键字<code class="fe mk ml mm mn b">permits</code>之后定义的类才被允许扩展<code class="fe mk ml mm mn b">Vehicle</code> <code class="fe mk ml mm mn b">sealed</code>类。</p><p id="2faa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您已经在与<code class="fe mk ml mm mn b">Vehicle</code>相同的文件中定义了类<code class="fe mk ml mm mn b">Car</code>、<code class="fe mk ml mm mn b">Bike</code>和<code class="fe mk ml mm mn b">Truck</code>，您可以省略关键字permissions，编译器将隐式处理它，如下所示:</p><pre class="kk kl km kn gu ns mn nt nu aw nv bi"><span id="6bfb" class="nw mw iu mn b gz nx ny l nz oa">sealed class Vehicle {...}</span><span id="95fa" class="nw mw iu mn b gz ob ny l nz oa">final class Car extends Vehicle {...} <br/>final class Bike extends Vehicle {...} <br/>final class Truck extends Vehicle {...}</span></pre><p id="f245" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如你在上面看到的，我们已经定义了每个类的最终修饰符。现在，你需要记住密封类的一个重要规则:每个允许的类都必须设置一个显式修饰符。可以是<code class="fe mk ml mm mn b">final</code>也可以是<code class="fe mk ml mm mn b">sealed</code>或者<code class="fe mk ml mm mn b">non-sealed</code>。</p><p id="8120" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是每个修改器如何影响继承:</p><ul class=""><li id="7c26" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">声明为<code class="fe mk ml mm mn b">final</code>的允许子类不能进一步扩展。</li><li id="ee5e" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">声明为<code class="fe mk ml mm mn b">sealed</code>的允许子类可以进一步扩展，但是只能由该子类允许的类来扩展。</li><li id="73c9" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">一个被允许的子类可以被声明<code class="fe mk ml mm mn b">non-sealed</code>可以被任何类进一步扩展。超类不能进一步限制这个类层次结构中的子类。</li></ul><p id="3db5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在Java 15之前，开发者只能使用<code class="fe mk ml mm mn b">final</code>关键字或范围修饰符来控制继承。因此，在定义类层次结构时，密封类为Java开发人员带来了额外的灵活性。</p><p id="07f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Java的反射API还获得了两种处理密封类的新方法:</p><pre class="kk kl km kn gu ns mn nt nu aw nv bi"><span id="edf6" class="nw mw iu mn b gz nx ny l nz oa">java.lang.constant.ClassDesc[] getPermittedSubclasses();</span><span id="85a0" class="nw mw iu mn b gz ob ny l nz oa">boolean isSealed()</span></pre></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="1da3" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">2.记录(第二次预览)</h1><p id="06a6" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">记录是作为Java 14中的预览特性引入的，目的是在编写基于POJO的数据载体类时减少样板代码。这在Kotlin中以数据类的形式存在了很长时间。</p><p id="04e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，有了Java 15，记录得到了第二次预览。虽然没有任何重大变化(只是一些小的增加)，但仍然有一些您应该知道的主要说明和限制:</p><ul class=""><li id="0700" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">在Java 15之前，人们可以在记录中声明原生方法(尽管这不是一个好主意)。现在，JEP明确禁止在记录中声明本机方法。可以理解的是，定义一个<code class="fe mk ml mm mn b">native</code>方法通过引入外部状态依赖偷走了USP记录。</li><li id="e762" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">对应于记录类的记录组件的隐式声明字段是<code class="fe mk ml mm mn b">final</code>，现在不应该通过反射修改，因为它将抛出<code class="fe mk ml mm mn b">IllegalAccessException</code>。</li></ul><p id="777d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">记录意味着数据载体类，您应该完全避免在其中定义本机方法。</p><h2 id="8967" class="nw mw iu bd mx of og dn nb oh oi dp nf lj oj ok nh ln ol om nj lr on oo nl op bi translated">密封类型的记录</h2><p id="3cff" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">我们知道记录是最终的，不能延长。令人高兴的是，记录可以实现接口。</p><p id="aff1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，您可以定义一个密封的接口，并通过以下方式在您的记录中实现它们:</p><pre class="kk kl km kn gu ns mn nt nu aw nv bi"><span id="fc0f" class="nw mw iu mn b gz nx ny l nz oa">sealed interface Car permits BMW, Audi { ... } <br/>record BMW(int price) implements Car { ... } <br/>record Audi(int price, String model) implements Car { ... }</span></pre><h2 id="f56b" class="nw mw iu bd mx of og dn nb oh oi dp nf lj oj ok nh ln ol om nj lr on oo nl op bi translated">地方志</h2><p id="98a6" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">也可以在方法中定义记录来存储中间值。与本地类不同，本地记录是隐式静态的。这意味着它们不能访问变量和封闭方法的实例成员，这实际上很好，因为它防止了记录捕获值。</p><p id="01d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本地记录对于以前必须创建助手记录的Java开发人员来说是一大福音。</p><p id="c06c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用以下方法，了解本地记录的引入如何帮助在流API中执行值的计算:</p><pre class="kk kl km kn gu ns mn nt nu aw nv bi"><span id="c109" class="nw mw iu mn b gz nx ny l nz oa">List&lt;Merchant&gt; findTopMerchants(List&lt;Merchant&gt; merchants, int<!-- --> <!-- -->month){<br/>// Local record<br/>record MerchantSales(Merchant merchant, double<!-- --> <!-- -->sales) {}</span><span id="2cad" class="nw mw iu mn b gz ob ny l nz oa">return<!-- --> <!-- -->merchants.stream()</span><span id="ea17" class="nw mw iu mn b gz ob ny l nz oa">.map(merchant -&gt; new<!-- --> <!-- -->MerchantSales(merchant, computeSales(merchant, month)))<br/>.sorted((m1, m2) -&gt; Double.compare(m2.sales(), m1.sales()))<br/>.map(MerchantSales::merchant)<br/>.collect(toList());</span><span id="00ab" class="nw mw iu mn b gz ob ny l nz oa">}</span></pre><h1 id="f5af" class="mv mw iu bd mx my oq na nb nc or ne nf ka os kb nh kd ot ke nj kg ou kh nl nm bi translated">结论</h1><p id="83f3" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">虽然上面两个是Java 15中的两个主要语言特性，但我们在第二个预览版中也有模式匹配以获得用户反馈，文本块现在是一个标准特性，最重要的是一个新的隐藏类特性。</p><p id="fadb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">隐藏类是与框架开发者相关的JVM特性。它允许通过使用<code class="fe mk ml mm mn b">Lookup::defineHiddenClass</code>定义类实现来使它们不可被发现。这样做的话，既不能使用<code class="fe mk ml mm mn b">Class.forName</code>找到这样的类，也不能在字节码中引用它们。</p><p id="5b62" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些是Java 15中引入的主要变化。</p></div></div>    
</body>
</html>