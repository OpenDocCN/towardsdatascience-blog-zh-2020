<html>
<head>
<title>Kaggle’s Titanic Competition in 10 Minutes | Part-III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟后卡格尔的泰坦尼克号比赛|第三部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kaggles-titanic-competition-in-10-minutes-part-iii-a492a1a1604f?source=collection_archive---------30-----------------------#2020-11-02">https://towardsdatascience.com/kaggles-titanic-competition-in-10-minutes-part-iii-a492a1a1604f?source=collection_archive---------30-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e05a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="/kaggles-titanic-competition-in-10-minutes-part-i-e6d18e59dbce"> ←第一部分</a> | <a class="ae ep" rel="noopener" target="_blank" href="/kaggles-titanic-competition-in-10-minutes-part-ii-3ae626bc6519"> ←第二部分</a> |机器学习教程</h2><div class=""/><div class=""><h2 id="9400" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在Kaggle的泰坦尼克号竞赛|机器学习教程中使用自然语言处理(NLP)、深度学习和GridSearchCV</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f8f0b326293e7694820fc3132d15e4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcdixThbzPICzQQyAf-kxQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图一。正在<a class="ae lh" href="https://bit.ly/2wdF0N9" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上建造的泰坦尼克号</p></figure><p id="b779" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你关注了我关于Kaggle的泰坦尼克号比赛(Part-I和Part-II)的教程系列，或者已经参加了比赛，你就对整个故事很熟悉了。如果你不熟悉，既然这是后续教程，强烈推荐你去看看这个教程系列的<a class="ae lh" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank">比赛页面</a>或者<a class="ae lh" rel="noopener" target="_blank" href="/kaggles-titanic-competition-in-10-minutes-part-i-e6d18e59dbce"> Part-I </a>和<a class="ae lh" rel="noopener" target="_blank" href="/kaggles-titanic-competition-in-10-minutes-part-ii-3ae626bc6519"> Part-II </a>。在该系列的第三部分(最终版)中，(I)我们将使用自然语言处理(<a class="ae lh" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank"> NLP </a>)技术来获取乘客的头衔，(II)创建一个人工神经网络(ANN或RegularNet)来训练模型，以及(III)使用<a class="ae lh" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank">网格搜索交叉验证</a>来调整ANN，以便我们获得最佳结果。</p><blockquote class="me mf mg"><p id="28d8" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated">开始吧！</p></blockquote><h1 id="b0ba" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">背景</h1><h2 id="a294" class="nd mm it bd mn ne nf dn mr ng nh dp mv lr ni nj mx lv nk nl mz lz nm nn nb iz bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/complete-your-first-kaggle-competition-a-k-a-d5ca937a6451">教程第一部分</a></h2><p id="93ad" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">在这个系列教程中，我们试图保持事情简单，慢慢地清晰地发展故事。在本教程的第1部分，我们学习了用不到20行代码编写一个python程序来参加Kaggle的竞赛。事情尽可能保持简单。我们清理了非数字部分，处理了空值，使用train.csv文件训练了我们的模型，在test.csv文件中预测了乘客的存活情况，并将其保存为csv文件以供提交。</p><div class="nt nu gp gr nv nw"><a rel="noopener follow" target="_blank" href="/kaggles-titanic-competition-in-10-minutes-part-i-e6d18e59dbce"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd jd gy z fp ob fr fs oc fu fw jc bi translated">10分钟后卡格尔的泰坦尼克号比赛|第一部分</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">使用决策树分类器|机器学习，用不到20行代码完成您的第一次Kaggle竞赛…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">towardsdatascience.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok lb nw"/></div></div></a></div><h2 id="5375" class="nd mm it bd mn ne nf dn mr ng nh dp mv lr ni nj mx lv nk nl mz lz nm nn nb iz bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/improving-our-code-to-obtain-a-better-model-for-kaggles-titanic-competition-c5ba66aed16b">教程第二部分</a></h2><p id="a526" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">由于我们在第一部分中没有适当地研究数据集，所以我们在第二部分中使用Matplotlib和Seaborn重点研究数据研究。我们通过使用聚合函数来估算空值而不是丢弃它们，更好地清理数据，并最终从分类变量中生成哑变量。然后，我们使用RandomForestClassifier模型代替LogisticRegression，这也提高了精度。与第一部分中的模型相比，我们实现了大约20%的精度提升。</p><div class="nt nu gp gr nv nw"><a rel="noopener follow" target="_blank" href="/kaggles-titanic-competition-in-10-minutes-part-ii-3ae626bc6519"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd jd gy z fp ob fr fs oc fu fw jc bi translated">10分钟后卡格尔的泰坦尼克号比赛|第二部分</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">改进我们的代码，以获得更好的结果，为Kaggle的大赛与数据分析和可视化和…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">towardsdatascience.com</p></div></div><div class="of l"><div class="ol l oh oi oj of ok lb nw"/></div></div></a></div><h2 id="5728" class="nd mm it bd mn ne nf dn mr ng nh dp mv lr ni nj mx lv nk nl mz lz nm nn nb iz bi translated">教程的第三部分</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/27f5d74b1c7a3e8fbae48266bcb86e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3Dw7KBoO_ydS13RU8xUgQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图二。具有一个隐藏层的人工神经网络图(由作者提供)</p></figure><p id="07d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在将使用Name列来导出乘客的头衔，这在他们的生存机会中扮演了重要的角色。我们还将使用<a class="ae lh" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>创建一个人工神经网络(ANN或RegularNets)来获得更好的结果。最后，为了调整ANN模型，我们将使用GridSearchCV来检测最佳参数。最后，我们将生成一个新的CSV文件进行提交。</p><h1 id="6f6a" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">准备数据集</h1><p id="19e6" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">就像我们在第一部分和第二部分中所做的那样，我将开始清理数据并输入空值。这一次，我们将采用一种不同的方法，并结合两个数据集进行清理和输入。我们已经讨论了为什么我们用第二部分的方法估算空值；因此，我们会直接给你代码。如果你觉得有些操作没有意义，你可以参考第二部分或者下面的评论。<a class="ae lh" href="https://cdn-images-1.medium.com/max/800/1*Niln8qOPuuFfEovHCkU_TA.png" rel="noopener">然而，由于我们在第二部分中看到18岁以下的人有更大的生存机会</a>，我们应该增加一个新的特征来衡量这种影响。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据清理和空值插补</p></figure><h1 id="8341" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">使用NLP导出乘客标题</h1><p id="ca6b" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">我们将删除不必要的列，并从上面的分类变量中生成虚拟变量。但是首先，我们需要从“名称”列中提取标题。为了理解我们在做什么，我们将从运行下面的代码来获取前10行Name列值开始。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">命名前10行的列值</p></figure><p id="2df0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们得到的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/4d8cc81bd11a3411b709d67890d21973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*agL-4e6R41FwuSMSM_Kuxg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图3。前10行的名称列值(按作者排序)</p></figure><p id="6c5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">名称列值的结构如下:</p><blockquote class="me mf mg"><p id="e217" class="li lj mh lk b ll lm kd ln lo lp kg lq mi ls lt lu mj lw lx ly mk ma mb mc md im bi translated"><last-name>，<title>。<first-name/></title></last-name></p></blockquote><p id="0344" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们需要根据点和逗号分割这些字符串，并提取标题。我们可以通过下面的代码来实现这一点:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">拆分名称值以提取标题</p></figure><p id="41d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦我们运行这段代码，我们将有一个标题列，其中包含标题。为了能够看到我们有什么样的标题，我们将运行:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">对标题进行分组并获得计数</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/09567b6024d53467b76749e5e499dff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMRkUok5jQF7ZtJ8kumkdA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图4。唯一书目数量(按作者分列)</p></figure><p id="93e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">似乎我们有四大群体:'<em class="mh"/>先生，'<em class="mh"/>夫人，'<em class="mh"/>小姐，'<em class="mh">老爷</em>'，以及其他。然而，在将所有其他标题归类为其他标题之前，我们需要注意法语标题。我们需要用下面的代码将它们转换成相应的英文标题:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">法语到英语标题转换器</p></figure><p id="e030" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们只有军官和皇家头衔。把他们组合成其他人是有意义的。我们可以通过下面的代码实现这一点:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">将所有非主要头衔合并为其他头衔(包括军官和皇家头衔)</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/63a79a9f0254015af65c97216d3bfe53.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*vVT8dhY5_DHmRNAujc5KLg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图5。最终唯一书目数量(按作者统计)</p></figure><h1 id="6a2d" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">数据准备的最后一笔</h1><p id="d0aa" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">现在我们的标题更易于管理，我们可以用下面的代码创建虚拟列并删除不必要的列:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据准备的最后一笔</p></figure><h1 id="f743" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">创建用于训练的人工神经网络</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/95efe6566ceda49b566cc42848ecd374.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*jYc7Hq9dU4kHXqm_Yd6vmw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图6。具有两个隐藏层的人工神经网络图(由作者提供)</p></figure><h2 id="8963" class="nd mm it bd mn ne nf dn mr ng nh dp mv lr ni nj mx lv nk nl mz lz nm nn nb iz bi translated">使用标准定标器标准化我们的数据</h2><p id="7101" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">为了得到好的结果，我们必须使用Scikit Learn的标准定标器来定标我们的数据。标准缩放器通过移除平均值并缩放至单位方差(即标准化)来标准化要素，这与最小最大缩放器不同。标准化和规格化之间的数学差异如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/65ae20fbaa6428acf75a0326353f328e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5bExrqs2ORmdiynrHhlBg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图7。标准化与规范化(作者提供的图表)</p></figure><p id="72df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将选择StandardScaler()来缩放数据集，并运行以下代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">扩展训练和测试数据集</p></figure><h2 id="6364" class="nd mm it bd mn ne nf dn mr ng nh dp mv lr ni nj mx lv nk nl mz lz nm nn nb iz bi translated">建立人工神经网络模型</h2><p id="101e" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">将我们的数据标准化后，我们可以开始构建我们的人工神经网络。我们将创建一个输入层(密集)，一个输出层(密集)，和一个隐藏层(密集)。在每一层之后，直到输出层，我们将应用0.2的正则化下降来对抗过拟合。最后，我们将使用Keras分类器建立模型，将GridSearchCV应用到这个神经网络上。因为我们有14个解释变量，所以我们的input_dimension必须等于14。由于我们将进行二进制分类，因此我们的最终输出图层必须为幸存或未幸存分类输出单个值。中间的其他单元是“<em class="mh">试一试</em>值，我们选择了128个神经元。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用Keras分类器构建人工神经网络</p></figure><h1 id="53e4" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">网格搜索交叉验证</h1><p id="fbec" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">在构建人工神经网络之后，我们将使用scikit-learn GridSearchCV来找到最佳参数，并调整我们的人工神经网络以获得最佳结果。我们将使用下面的代码尝试不同的优化器、时期和batch _ sizes。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">基于Keras分类器的网格搜索</p></figure><p id="b689" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行这段代码并打印出最佳参数后，我们得到以下输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/80720100d85680219c8bf261b527ed21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*wgc9Oa7a_WlLlZwQeKxjUA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图8。最佳参数和精确度</p></figure><p id="372f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，我们没有在GridSearchCV中激活交叉验证。如果您想在GridSearchCV中添加交叉验证功能，请在GridSearch中选择一个CV值(<em class="mh">例如，cv=5 </em>)。</p><h1 id="29e7" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">用最佳参数拟合模型</h1><p id="2ae1" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">既然我们找到了最佳参数，我们可以用最佳参数值重新创建分类器，并用以下代码拟合我们的训练数据集:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">用最佳参数拟合</p></figure><p id="c36b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">既然我们获得了预测，我们就可以进行最后的操作来准备提交。需要注意的一点是，我们的人工神经网络给出了生存概率，这是一个连续的数字变量。然而，我们需要一个二元分类变量。因此，我们还使用下面的lambda函数进行必要的操作，将连续值转换为二进制值(0或1 ),并将结果写入CSV文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="on oo l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">创建提交文件</p></figure><h1 id="55ea" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">恭喜</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/40ae5a676f0fed43bdb504b0a4adfcbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vG1DgxjlGQlabdoVSy5vHA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图9。深度学习与旧算法(作者图)</p></figure><p id="ce66" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你创造了一个人工神经网络来分类泰坦尼克号乘客的幸存者。只要有大量数据，神经网络就被证明优于所有其他机器学习算法。由于我们的数据集仅由1309行组成，一些机器学习算法如梯度提升树或具有良好调谐的随机森林可能优于神经网络。但是，对于具有大量数据的数据集，情况并非如此，如下图所示:</p><p id="e5c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我会说，泰坦尼克号数据集可能位于旧算法优于深度学习算法的交叉点的左侧。然而，我们仍将达到高于80%的准确率，大约在自然的准确率水平。</p><h1 id="75a3" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">订阅时事通讯获取完整代码</h1><p id="4e11" class="pw-post-body-paragraph li lj it lk b ll no kd ln lo np kg lq lr nq lt lu lv nr lx ly lz ns mb mc md im bi translated">既然你正在阅读这篇文章，我相信我们有着相似的兴趣，并且现在/将来会从事相似的行业。那么我们就通过 <a class="ae lh" href="https://linkedin.com/in/orhangaziyalcin/" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> Linkedin </em> </a> <em class="mh">来连线吧！请不要犹豫发送联系请求！</em><a class="ae lh" href="https://linkedin.com/in/orhangaziyalcin/" rel="noopener ugc nofollow" target="_blank"><em class="mh">Orhan g . yaln—Linkedin</em></a></p><p id="23e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想获得Google Colab上的教程代码和我的最新内容，可以考虑订阅我的<em class="mh"> GDPR兼容</em> <a class="ae lh" href="http://eepurl.com/hd6Xfv" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">时事通讯</strong> </a> <strong class="lk jd">！✉️ </strong></p><blockquote class="ow"><p id="9707" class="ox oy it bd oz pa pb pc pd pe pf md dk translated"><a class="ae lh" href="http://eepurl.com/hd6Xfv" rel="noopener ugc nofollow" target="_blank">现在就订阅</a></p></blockquote></div></div>    
</body>
</html>