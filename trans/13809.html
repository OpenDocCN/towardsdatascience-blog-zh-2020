<html>
<head>
<title>How to Organize Machine Learning Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何组织机器学习项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-organize-machine-learning-projects-babd04f7a679?source=collection_archive---------29-----------------------#2020-09-22">https://towardsdatascience.com/how-to-organize-machine-learning-projects-babd04f7a679?source=collection_archive---------29-----------------------#2020-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ba7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python，Git，Anaconda，Code，没有Jupyter笔记本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/60d54edd96554b466ca1cbcaba9f072b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7nWRZ8xiWBGNkP5--9oAQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。子图片都是由作者或允许(见个人链接后)。</p></figure><p id="86f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章描述了组织机器学习项目的最佳实践，我在攻读机器学习博士学位期间发现这些实践非常有效。</p><h1 id="0b26" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak"> Python </strong></h1><p id="2fc4" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Python是一种很棒的机器学习语言。Python包含了一系列对ML非常有用的库:</p><ul class=""><li id="2e7f" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated"><a class="ae na" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> numpy </a> : n维数组和数值计算。对数据处理有用。</li><li id="cec3" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated"><a class="ae na" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>:数据分析库。pandas数据帧本质上是用描述性字符串作为行和列标签的numpy数组。它们可以被排序、过滤、分组、连接等。对数据处理有用。</li><li id="0c76" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">PyTorch :构建神经网络。包括许多预训练的模型和干净的计算机视觉数据集。PyTorch是我最喜欢的神经网络库，因为它鼓励使用面向对象的编程(模型是一个类，数据集是一个类，等等。)，用PyTorch写代码很快，PyTorch默认支持急切执行，所以可以和Python调试器一起使用。</li><li id="de67" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated"><a class="ae na" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank">tensor flow</a>:py torch的替代品，在业界更受欢迎。几年前，我使用TensorFlow，但在改用PyTorch后，我再也没有回头。我发现PyTorch更适合做研究。如果你想使用TensorFlow，并且你想要一个更高级别的接口，你可以使用<a class="ae na" href="https://keras.io/" rel="noopener ugc nofollow" target="_blank"> Keras </a>。</li><li id="d83d" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">这是一个很好的库，用于回归、支持向量机、k近邻、随机森林、计算接收器工作特性下的面积、计算混淆矩阵等。</li><li id="3bfe" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">matplotlib 和<a class="ae na" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>:制作可爱的可视化效果！我将在后面的章节中介绍这些库。</li></ul><h1 id="0f33" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak"> Git </strong></h1><p id="5d9b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Git版本控制对于保持机器学习项目的有序非常有用。</p><p id="1408" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Git是一个工具，可以用来跟踪您对代码所做的所有更改。Git“存储库”是包含代码文件的目录。Git使用节省空间的技术，因此它不会存储代码的多个副本，而是存储旧文件和新文件之间的相对变化。Git有助于保持您的代码文件目录整洁有序，因为只有最新版本“明显”存在(尽管您可以随时轻松访问任何版本的代码)。您可以选择何时标记已经发生的更改，使用“提交”将特定的代码更改与您提供的书面描述捆绑在一起。Git存储库也使得代码共享和协作变得容易。总的来说，与在“myscript_v1.py”、“dataprocessing_v56.py”、“utils_73.py”等下保存一百万个不同版本的代码相比，Git是保留旧代码功能的更好的解决方案。</p><p id="ad93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Git版本控制可以通过GitHub、GitLab和Bitbucket获得。我最常使用GitHub。一旦你设置好GitHub并习惯了使用它，建立一个新的资源库大约需要2分钟。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/da20883ccd7e320f2ab91476ea10340f.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/0*vpi6mPa6nD6cwdJ3"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Octocat，允许在博客帖子中使用<a class="ae na" href="https://github.com/logos" rel="noopener ugc nofollow" target="_blank"> GitHub徽标和用法</a></p></figure><p id="6397" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是在您的机器上安装GitHub的步骤:</p><ol class=""><li id="7190" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt nh mx my mz bi translated">安装Git:【https://git-scm.com/downloads】T2</li><li id="807f" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">制作GitHub账号【www.github.com T4】</li><li id="c81b" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">通过SSH密钥将您的GitHub帐户与您的机器连接起来。这一步使您能够将代码从您的机器推送到GitHub的云存储中。参见<a class="ae na" href="https://docs.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" rel="noopener ugc nofollow" target="_blank">生成新的SSH密钥</a>，<a class="ae na" href="https://docs.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account" rel="noopener ugc nofollow" target="_blank">向您的GitHub帐户添加新的SSH密钥</a></li><li id="3d98" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">在GitHub上创建一个新的资源库，方法是在您的个人资料的“资源库”部分点击绿色的“新建”按钮。</li><li id="99bd" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">使您的计算机能够推送至该存储库(请注意，在您创建存储库之后，GitHub会立即为您提供这些说明以及存储库的正确URL以下命令只是一个示例):</li></ol><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="10f8" class="nn lv it nj b gy no np l nq nr">echo "# pytorch-computer-vision" &gt;&gt; README.md <br/>git init <br/>git add README.md <br/>git commit -m "first commit" <br/>git branch -M master <br/>git remote add origin https://github.com/rachellea/pytorch-computer-vision.git <br/>git push -u origin master</span></pre><p id="aa93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您现在已经更改了myeditedscript.py .中的一些代码，以“提交”到存储库(即记录该更改):</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="78d3" class="nn lv it nj b gy no np l nq nr">git add myeditedscript.py <br/>git commit -m 'added super useful functionality' <br/>git push origin master</span></pre><h1 id="1212" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">蟒蛇</strong></h1><p id="05ec" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Anaconda是一个包管理器。它允许创建不同的计算环境，这些计算环境可能包含不同的Python版本和/或不同的包和/或不同的包版本。当您处理多个具有冲突依赖关系的项目时，Anaconda尤其有用。</p><p id="6b89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Anaconda很容易使用。步骤:</p><p id="62db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，安装Anaconda:<a class="ae na" href="https://docs.anaconda.com/anaconda/install/" rel="noopener ugc nofollow" target="_blank">https://docs.anaconda.com/anaconda/install/</a></p><p id="3628" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，创造一个环境。我发现以项目命名环境很有用。例如，如果项目是关于<a class="ae na" href="https://glassboxmedicine.com/2019/05/11/automated-chest-x-ray-interpretation/" rel="noopener ugc nofollow" target="_blank">胸部x光分类</a>使用神经网络，环境可以被称为chestxraynn:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6ada" class="nn lv it nj b gy no np l nq nr">conda create --name chestxraynn python=3.5</span></pre><p id="8efd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，您不希望在环境名称两边加上引号，否则引号字符本身将成为环境名称的一部分。此外，您可以选择任何想要的Python版本。它不一定是Python 3.5。</p><p id="6f55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦创建了环境，就该激活环境了。“激活”仅仅意味着你将被“放入环境中”,这样你就可以使用安装在环境中的所有软件。</p><p id="5f55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在Windows上激活环境，请运行以下命令:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="190b" class="nn lv it nj b gy no np l nq nr">activate chestxraynn</span></pre><p id="bfc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Linux或macOS上，</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8a32" class="nn lv it nj b gy no np l nq nr">source activate chestxraynn</span></pre><p id="6703" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用“conda install”命令在环境内部安装软件包。</p><p id="d0b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，安装matplotlib的conda命令是:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="f5f9" class="nn lv it nj b gy no np l nq nr">conda install -c conda-forge matplotlib</span></pre><p id="89f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以谷歌“conda install packagename”来找到告诉你运行什么conda命令来安装该软件包的页面。从技术上讲，在conda环境中，你也可以使用pip安装包，但是<a class="ae na" href="https://www.anaconda.com/blog/using-pip-in-a-conda-environment" rel="noopener ugc nofollow" target="_blank">这会导致问题</a>，所以如果可能的话应该避免。</p><p id="0299" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Anaconda将负责确保环境中所有内容的版本都是兼容的。更多命令见<a class="ae na" href="https://docs.conda.io/projects/conda/en/4.6.0/_downloads/52a95608c49671267e40c689e0bc00ca/conda-cheatsheet.pdf" rel="noopener ugc nofollow" target="_blank"> Conda备忘单</a>。</p><p id="f284" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也可以从别人放在一起的文件中创建一个conda环境。在GitHub库<a class="ae na" href="https://github.com/rachellea/pytorch-computer-vision" rel="noopener ugc nofollow" target="_blank">https://github.com/rachellea/pytorch-computer-vision</a>中，有一个名为tutorial_environment.yml的文件，这个文件指定了运行教程代码所需的依赖关系。要基于该文件创建conda环境，您只需在Anaconda提示符下运行以下命令:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="28c1" class="nn lv it nj b gy no np l nq nr">conda env create -f tutorial_environment.yml</span></pre><h1 id="9190" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">组织你的代码:类和函数</strong></h1><p id="44f4" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">代码组织非常重要。在过去的不同时期，我遇到过研究代码被数千行代码塞进一个模块，没有文档，重复的代码块到处复制粘贴，一些代码块没有解释就被注释掉，还有奇怪的变量名。代码不会运行，即使运行了，也可能是不正确的。</p><p id="1162" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我也遇到了许多优秀的代码——例如，我在PyTorch实现中看到的所有代码都是有组织的，并且有良好的文档记录。</p><p id="3f06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从长远来看，如果你为自己的项目编写高质量的代码，将会节省你很多时间。高质量代码的一个方面是它在模块中的组织。</p><p id="9b32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">建议:</p><ul class=""><li id="b3dd" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">使用面向对象的编程。我强烈推荐PyTorch作为机器学习框架，因为它有助于在任何事情上使用面向对象编程。模型就是一个类。数据集是一个类。等等。</li><li id="bb6b" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">使用函数。如果你写的东西不能很好地作为一个类，那么就把代码组织成函数。功能是可重用的。全局命名空间中的代码块是不可重用的。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f5ea31ded6a13f2dd0e94a0509061e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/0*5Bt9w2B7MMaMj8gX"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有组织代码的示意图。图片作者。</p></figure><h1 id="72ea" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">组织你的代码:目录</strong></h1><p id="53a0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使用多个模块来组织代码，并将这些模块组织到目录中。</p><p id="ff7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢的一个简单的示例组织展示在我为这篇文章和其他相关文章整理的GitHub库中:【https://github.com/rachellea/pytorch-computer-vision<a class="ae na" href="https://github.com/rachellea/pytorch-computer-vision" rel="noopener ugc nofollow" target="_blank"/></p><p id="c5f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整体组织如下:</p><ul class=""><li id="4498" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">一个用于训练/评估/测试循环的模块(src/run_experiment.py)</li><li id="7bc5" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">一个用于计算绩效指标的模块(src/evaluate.py)</li><li id="8e2a" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">一个(或多个)数据处理模块:(load_dataset/custom_pascal.py和load_dataset/custom_tiny.py)</li><li id="512b" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">模型的一个(或多个)模块:models/custom_models_base.py</li></ul><p id="09af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是存储库的整体组织结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/b5cb1baa7bbf538b4203708fec138e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3OAwbmru_PqlYjvp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">组织<a class="ae na" href="https://github.com/rachellea/pytorch-computer-vision" rel="noopener ugc nofollow" target="_blank">py torch-计算机视觉</a>。图片作者。</p></figure><p id="860b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，虽然这个存储库中存储了一个数据集(这些png位于“train”、“val”和“test”目录中)，但一般来说，将数据集放入存储库并不是一个好主意。这个存储库中有一个数据集的唯一原因是因为它是一个很小的假数据集，是为了举例而创建的。除非您的数据非常小，否则不应该放在存储库中。</p><h1 id="ed4e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">导入</strong></h1><p id="940d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">请注意，您需要一个名为__init__的空文件。py，以便模块可以从这些目录中导入文件。</p><p id="8339" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是如何让一个名为awesomecode.py的模块导入一个名为helpercode.py的模块，这是基于它们相对于彼此所处的目录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/62abdfa02f87a788397a6cf4b6885e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YHgK8MiiSUX0X3wN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="ea0e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">文档</strong></h1><p id="3ba1" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">写很多文档是有好处的。评论一切。用docstrings记录所有的函数、方法和类。有时候，在编写函数之前对它进行文档化是很有帮助的。如果文档有时比代码长也没关系。“过于清晰”总比不够清晰好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/35bc3c1c3b4185e23bef16c02ce6cd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/0*KIXAbjjWDgsgGgVX"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1289" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上图是一个简单的函数rand_rotate()，它随机旋转一个代表CT体积的3D numpy数组。可以通过指定<ctvol>是一个3D numpy数组来改进docstring。这些注释很有帮助，因为它们解释了为什么指示所执行旋转的向量使用(k-1)-这是因为chosen _ k是1、2或3，但Python是零索引的。像这样简单的注释可以防止以后混淆。</ctvol></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0cbbbea496d39eb7f560cad5d04a08f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/0*7dVqLyMf_Vw4YvW0"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5b6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上图显示了我的<a class="ae na" href="https://glassboxmedicine.com/2019/06/01/everything-you-need-to-know-about-preparing-tabular-data-for-machine-learning-code-included/" rel="noopener ugc nofollow" target="_blank">数据处理教程</a> <a class="ae na" href="https://github.com/rachellea/glassboxmedicine" rel="noopener ugc nofollow" target="_blank">代码</a>中的一些文档。</p><p id="f713" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">文档将确保当你回顾旧代码时，你能很快记住它做了什么。当你看到一些看起来很奇怪的东西并本能地改变它时，文档将防止你意外地破坏你自己的代码——如果它旁边有一个注释解释为什么奇怪的东西是必要的，你就不去管它。文档也能让其他人使用你的代码。</p><h1 id="ab43" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">命名变量</strong></h1><p id="492f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">总是使用描述性的变量名。“volumetric_attn_gr_truth”是比“truth”更好的变量名(什么truth？)，而且比“gt”或“g”好得多。如果你的变量有很长的名字也没关系。他们不应该有单字母的名字。</p><p id="8bdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使你正在对行和列进行迭代，也要使用“row”和“col”作为你的变量名，而不是“I”和“j”。我曾经花了一整天的时间寻找一个非常奇怪的bug，结果发现它是由于错误地迭代了一个2D数组引起的，因为我在数百行代码中的一行代码中调换了“I”和“j”。那是我最后一次使用单字母变量名。</p><h1 id="5062" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">单元测试</strong></h1><p id="2173" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">很多人声称他们没有时间为他们的代码编写测试，因为“这只是为了研究。”我认为测试研究代码甚至更重要，因为研究的全部意义在于你不知道什么是“正确的答案”——如果你不知道你的代码产生的答案是否正确，你怎么知道你是否得到了正确的答案？</p><p id="4680" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次我花一天时间为我的代码编写单元测试时，我都会发现错误——有些很小，有些更严重。如果你写单元测试，你<em class="nx">将</em>捕捉你代码中的错误。如果你为别人的代码编写单元测试，你也会在他们的代码中发现错误。</p><p id="a5e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了促进代码的正确性，单元测试还有助于执行良好的代码组织，通过阻止你编写一次做太多事情的“神函数”。God函数通常是测试的噩梦，应该被分解成更小、更易管理的函数。</p><p id="7c87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至少，对代码中最关键的部分进行单元测试是个好主意，比如复杂的数据处理或者模型中奇怪的张量重排。确保你的代码是正确的从来都不是浪费时间。</p><p id="cbbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里看到一个非常简单的单元测试的例子<a class="ae na" href="https://github.com/rachellea/pytorch-computer-vision/blob/master/src/unit_tests.py" rel="noopener ugc nofollow" target="_blank"/>。这些单元测试包括出于演示目的对一些内置PyTorch函数的测试。</p><h1 id="b6d1" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">用可视化检查代码</strong></h1><p id="1c8e" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">特别是在计算机视觉中，使用可视化来执行健全性检查是非常有用的。</p><p id="28f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">matplotlib 非常适合查看图像、分割图、带边框的图像等。以下是通过将matplotlib的imshow()函数应用于输入图像而生成的可视化示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/055883971c18313ed8371923ceca3c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/0*IYzuU0XHe4Wu-oAX"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">matplotlib imshow生成的示例图像，来自<a class="ae na" href="https://matplotlib.org/3.1.0/gallery/images_contours_and_fields/image_demo.html" rel="noopener ugc nofollow" target="_blank">图像演示</a>。Matplotlib使用一个<a class="ae na" href="https://matplotlib.org/users/license.html#:~:text=Matplotlib%20only%20uses%20BSD%20compatible,are%20acceptable%20in%20matplotlib%20toolkits." rel="noopener ugc nofollow" target="_blank"> BSD许可证</a>，这是一个许可的自由软件许可证。</p></figure><p id="71d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae na" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> seaborn </a>专为统计数据可视化而设计。它非常适合制作热图和制作复杂的性能指标可视化。以下是一些在seaborn中用大约一行代码就可以绘制出的图形示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/11b35356d81df942a6495509d010774b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8CABOj6NcHmM2m5j"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分别由<a class="ae na" href="https://seaborn.pydata.org/examples/grouped_violinplots.html" rel="noopener ugc nofollow" target="_blank">seaborn group violin plots</a>、<a class="ae na" href="https://seaborn.pydata.org/examples/grouped_boxplot.html" rel="noopener ugc nofollow" target="_blank">seaborn group box plots</a>和<a class="ae na" href="https://seaborn.pydata.org/generated/seaborn.heatmap.html" rel="noopener ugc nofollow" target="_blank"> seaborn heatmap </a>制作的示例图像。seaborn使用一个<a class="ae na" href="https://github.com/mwaskom/seaborn/blob/master/LICENSE" rel="noopener ugc nofollow" target="_blank"> BSD许可证</a>，这是一个许可的自由软件许可证。</p></figure><p id="027c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">matplotlib和seaborn都可以用于创建可视化效果，即时显示输入数据是否合理，基础事实是否合理，数据处理是否没有意外出错，模型的输出是否有意义，等等。</p><h1 id="4608" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">演示0:单元测试和可视化</strong></h1><p id="9835" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在<a class="ae na" href="https://github.com/rachellea/pytorch-computer-vision" rel="noopener ugc nofollow" target="_blank">教程存储库</a>中，<a class="ae na" href="https://github.com/rachellea/pytorch-computer-vision/blob/master/Demo-0-Unit-Tests-and-Visualization.py" rel="noopener ugc nofollow" target="_blank">Demo-0-Unit-Tests-and-visualization . py</a>将运行<a class="ae na" href="https://github.com/rachellea/pytorch-computer-vision/tree/master/src" rel="noopener ugc nofollow" target="_blank"> src/unit_tests.py </a>中的单元测试，然后将运行PASCAL VOC 2012数据集图像和分段基础事实的可视化。</p><p id="bcbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了运行演示的可视化部分，将Demo-0-Unit-Tests-and-visualization . py中的路径更改为您的计算机上的路径，您可以在该路径中存储PASCAL VOC 2012数据集，并取消注释路径下的行以下载数据集。一旦数据集被下载，您就可以运行可视化。进行可视化的代码在<a class="ae na" href="https://github.com/rachellea/pytorch-computer-vision/blob/master/load_dataset/custom_pascal.py" rel="noopener ugc nofollow" target="_blank">load _ dataset/custom _ Pascal . py</a>中。此刻，在演示文件中，images_to_visualize的总数被设置为3；如果您想要可视化更多的图像，您可以进一步增加该数字，例如增加到100。</p><p id="9aff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是可视化效果的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/2a33c77ee3deb69d5e66aa412e57923a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/0*vqKJjukpH_7lW-fI"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。原帕斯卡VOC 2012年飞机验证集图像。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d4fae24986f28740a58a1e0a3a2ff86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*0QNDeC41fAJFoUTO"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。PASCAL VOC 2012验证集已重新采样为320 x 320像素的飞机图像。图像重采样使用torch . nn . functional . interpolate(mode = ' bicubic ')，而分割基本事实重采样使用PIL调整大小(重采样=PIL。Image.NEAREST)即最近邻重采样。</p></figure><p id="4da6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这些图像中，我们可以推断出一些有用的东西:</p><ul class=""><li id="95c1" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt mw mx my mz bi translated">输入图像和地面实况分割之间的映射是正确的。</li><li id="75ae" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">用于定义逐像素分割基础事实的整数和标签描述字符串之间的映射是正确的。例如，1正确映射到“飞机”</li><li id="e201" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">重采样步骤不会“破坏”输入图像或分割基础事实，也不会导致它们严重错位。</li></ul><h1 id="fa12" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">终端中的可视化</strong></h1><p id="946d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果您处于“非交互式环境”(即没有图形用户界面的终端)，那么您需要关闭交互式绘图并保存您的图形，以便您可以在其他地方打开它们:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="3028" class="nn lv it nj b gy no np l nq nr">import seaborn <br/>import matplotlib <br/>matplotlib.use('agg') <br/>import matplotlib.pyplot as plt <br/>plt.ioff() </span><span id="38fa" class="nn lv it nj b gy oc np l nq nr">#seaborn figure: <br/>heatmap = seaborn.heatmap(some_dataframe, cmap = 'Blues', square=True, center=0)<br/>heatmap.get_figure().savefig('Descriptive_Figure_Name.png',bbox_inches='tight') <br/>plt.close() </span><span id="3e62" class="nn lv it nj b gy oc np l nq nr">#matplotlib figure: <br/>plt.imshow(chest_x_ray,cmap='gray')<br/>plt.savefig('Other_Descriptive_Figure_Name.png') <br/>plt.close()</span></pre><h1 id="41a8" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">Python调试器</strong></h1><p id="fbcc" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><a class="ae na" href="https://docs.python.org/3/library/pdb.html" rel="noopener ugc nofollow" target="_blank"> Python调试器</a>是一个非常有用的工具，因为它允许你在程序崩溃的地方检查状态中的一切，并在程序崩溃的地方运行代码片段，这样你就可以尝试可能的解决方案。使用Python调试器比使用print语句进行调试要高效得多，它将为您节省大量时间。Python调试器也可以与PyTorch一起使用；您可以检查张量、梯度、测井数据帧等。</p><p id="875e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用Python调试器在终端中交互式运行脚本，请使用以下命令:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8dc0" class="nn lv it nj b gy no np l nq nr">python -m pdb myscript.py</span></pre><p id="5592" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将看到一个(Pdb)提示符出现。键入“c”继续。(这只是一个单独的小写字母c，表示继续)。</p><p id="4ae5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要退出Python调试器，请使用‘q’(这是一个单独的小写字母q，表示退出)。您可能需要使用q两次才能完全退出。</p><p id="ab22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想在程序的某个特定点停止，那么你可以在相关模块中<a class="ae na" href="https://realpython.com/python-debugging-pdb/" rel="noopener ugc nofollow" target="_blank">导入pdb，然后在你想停止的特定点放置“pdb . set _ trace()”</a>。或者，如果你不想麻烦导入pdb，你可以只在你想停止的地方写“assert False ”,这将保证程序在你想它死的地方死亡(尽管这不是使用Python调试器的正式方式)。</p><h1 id="9982" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">不要用Jupyter笔记本</strong></h1><p id="e0ad" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">鉴于前面的所有章节，我现在必须推荐<em class="nx">永远不要</em>使用jupyter笔记本进行机器学习项目，或者实际上进行任何需要花费你几天以上时间的编码项目。</p><p id="6ab7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么？</p><ol class=""><li id="51e8" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt nh mx my mz bi translated">笔记本鼓励你在全局名称空间中保存所有的东西，这产生了一个巨大的模块，它做所有的事情，没有函数，没有类，也没有任何结构。</li><li id="75bf" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">笔记本使得重用你的代码更加困难。功能可重复使用；“单元格5、10和13中的代码”不可重复使用。</li><li id="733d" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">笔记本使单元测试变得困难。函数和方法可以进行单元测试。“单元格5、10和13中的代码”不能进行单元测试。</li><li id="547b" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">你的代码越有组织(比如，越细分成类和函数)，笔记本的交互性就越差——而交互性是人们喜欢笔记本的主要原因。笔记本吸引人的交互性本质上与高度结构化、组织良好的代码相反。</li><li id="adc7" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">笔记本很难正确使用Git版本控制。笔记本只是大量的JSON文件，所以正确地合并它们或者用它们做拉请求基本上是不可能的。</li><li id="7ca0" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">笔记本使与其他人合作变得困难。您必须“轮流”在笔记本上工作(而不是像“常规代码”那样从同一个回购中推/拉)。</li><li id="61db" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">笔记本有一个非线性的工作流程，这与可复制的研究完全相反。你不必“以特定的顺序运行单元格”来复制别人的工作。</li></ol><p id="df05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">笔记本有什么用？一些可能可接受的用例是初始数据可视化、家庭作业、“演示风格”软件和交互式演示。(然而，我认为所有这些都可以不使用jupyter笔记本来完成。)</p><p id="b8a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不是现存的唯一一个认为机器学习项目最好避免使用jupyter笔记本的人。如需进一步阅读/参考，请参见Daoud Clarke的<a class="ae na" href="https://datapastry.com/blog/why-i-dont-use-jupyter-notebooks-and-you-shouldnt-either/" rel="noopener ugc nofollow" target="_blank">为什么我不用Jupyter笔记本，你也不应该用</a>；【jupyter笔记本烂的5个理由亚历山大穆勒著；克里斯蒂娜·杨的《T4》和《笔记本反模式》。</p><h1 id="3e20" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">目标</strong></h1><p id="8ba1" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">两个有用的目标是:</p><ol class=""><li id="5796" class="mr ms it la b lb lc le lf lh mt ll mu lp mv lt nh mx my mz bi translated">编写正确易懂的代码。如果你的代码是正确的，你的模型更有可能产生好的结果，你的研究结论将是正确的，并且你将创造一些实际有用的东西。</li><li id="524b" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt nh mx my mz bi translated">确保任何人都可以通过在终端中运行一个命令(例如“python main.py”)来复制您所做的一切，例如您的模型、结果、图形。这将有助于他人建立在你的工作之上，也将有助于“未来的你”建立在你自己的工作之上。</li></ol><h1 id="b9d2" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">总结</strong></h1><ul class=""><li id="95a3" class="mr ms it la b lb mm le mn lh od ll oe lp of lt mw mx my mz bi translated">Python是一种优秀的机器学习语言</li><li id="9e0f" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">Git版本控制有助于跟踪不同版本的代码。它可以通过GitHub获得。</li><li id="0ccf" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">Anaconda是一个包管理器，可以创建不同的环境，其中可能包含不同的Python版本和/或包。当处理多个具有冲突依赖关系的项目时，这很有用。</li><li id="4bd3" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">将代码组织成模块中的类和函数。在Git存储库中以分层目录结构组织模块。</li><li id="7f97" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">用注释和文档字符串记录您的代码</li><li id="636f" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">使用描述性的变量名。不要使用单字母的变量名。</li><li id="d161" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">编写单元测试，尤其是对于数据处理和模型中最复杂或最关键的部分。</li><li id="f98f" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">使用matplotlib和seaborn可视化工具可视化您的数据集、模型输出和模型性能</li><li id="1a7a" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">使用Python调试器进行快速、高效的调试</li><li id="15bb" class="mr ms it la b lb nb le nc lh nd ll ne lp nf lt mw mx my mz bi translated">不要将jupyter笔记本用于机器学习项目</li></ul><p id="fa81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">机器学习快乐！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1e9ac6a1b0828492bf125f59dcb1ac4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/0*uCsG6cgBuh6SPMpo"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">维基百科的微笑猫，知识共享许可</p></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="5300" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nx">原载于2020年9月22日</em><a class="ae na" href="https://glassboxmedicine.com/2020/09/22/how-to-organize-machine-learning-projects-python-git-anaconda-code-and-no-jupyter-notebooks/" rel="noopener ugc nofollow" target="_blank"><em class="nx">【http://glassboxmedicine.com】</em></a><em class="nx">。</em></p></div></div>    
</body>
</html>