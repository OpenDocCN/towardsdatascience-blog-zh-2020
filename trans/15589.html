<html>
<head>
<title>How to make your own Instagram filter with facial recognition using python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用python制作自己的带面部识别的Instagram滤镜</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-your-own-instagram-filter-with-facial-recognition-from-scratch-using-python-d3a42029e65b?source=collection_archive---------9-----------------------#2020-10-27">https://towardsdatascience.com/how-to-make-your-own-instagram-filter-with-facial-recognition-from-scratch-using-python-d3a42029e65b?source=collection_archive---------9-----------------------#2020-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="78ec" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><figure class="gl gn ka kb kc kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi jz"><img src="../Images/405a8b346df1be1dc83b065010769eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9WADlsrxHtORqXATsb39Q.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated"><a class="ae ko" href="https://pixabay.com/illustrations/flat-recognition-facial-face-woman-3252983/" rel="noopener ugc nofollow" target="_blank">图片由teguhjati pras拍摄；通过Pixabay获得知识共享许可</a></p></figure><p id="5d89" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在过去的10年里，面部识别技术发展迅速，并迅速开发出多种用途。从实用的(解锁手机)，到好玩的(Instagram滤镜)，再到有争议的(安全、监控和警务)，我们的脸可以在许多方面被技术使用。好奇如何自己创造一些面部识别技术吗？脸书提供了<a class="ae ko" href="https://sparkar.facebook.com/ar-studio/" rel="noopener ugc nofollow" target="_blank"> SparkAR平台</a>，为脸书和Instagram创建面部识别过滤器。<strong class="kr jd"> <em class="ln">然而</em> </strong>，我们可以很容易地使用python中的OpenCV包自己创建一个，因此我们可以在任何地方使用面部识别。</p><h2 id="1053" class="lo lp it bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf iz bi translated">背景信息:计算机是如何“看见”的？</h2><p id="50f1" class="pw-post-body-paragraph kp kq it kr b ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">对计算机来说，图像只是一系列指示像素位置的数字。计算机程序员可以创建算法，教会计算机如何识别图像中的独特特征。有趣的是，计算机“看”到了类似于人类如何解决拼图游戏。考虑下图:</p><figure class="mm mn mo mp gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ml"><img src="../Images/03a4f9d7976f06aa958a89c930a57f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imyMXg8yFbDlEyWuhBsEug.jpeg"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated"><a class="ae ko" href="https://www.flickr.com/photos/billselak/3299520132" rel="noopener ugc nofollow" target="_blank">图片由比尔·塞拉克拍摄；通过Flickr获得知识共享许可</a></p></figure><p id="fe14" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">三叶草的拼图块很容易放置，因为它们有不同的形状，逻辑上只能放在一个地方。边缘件还具有明显的扁平特征，限制了它可能到达的位置，只有沿着边缘的一组可能性。剩下的碎片可能真的在任何地方。这个过程被称为特征图像提取，其中用户识别图像的特征以帮助他们构建整体图像。计算机可以通过像素数据的趋势来模仿这种思路。数据科学家使用机器学习算法来教计算机如何识别这些日益复杂的趋势。对于面部识别，首先识别眼睛(面部最显著的特征之一)，然后使用模板绘制面部的其余特征。</p><h2 id="28a8" class="lo lp it bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf iz bi translated">第一步:在照片中寻找面孔</h2><p id="f916" class="pw-post-body-paragraph kp kq it kr b ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">现在我们知道了计算机视觉的基本原理，我们可以开始构建过滤器了。首先，让我们在静态图片中找到人脸和眼睛。首先在您的计算机上安装，然后将<a class="ae ko" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_setup/py_table_of_contents_setup/py_table_of_contents_setup.html" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>(一个用于图像处理的开源python包)导入到py文件中。OpenCV中的所有图像结构都可以与NumPy数组相互转换，因此导入NumPy也很有用。一旦你安装了OpenCV，你应该可以访问。包含面部识别和其他图像处理算法的xml文件。在本教程中，我们将使用一种叫做<a class="ae ko" href="http://www.willberger.org/cascade-haar-explained/" rel="noopener ugc nofollow" target="_blank">哈尔级联</a>的算法来处理人脸和眼睛。如果你找不到这些文件所在的目录。xml文件是，我建议快速文件搜索“haarcascade”。一旦找到存储Haar级联的目录的路径，调用CascadeClassifier并通过它传递路径:</p><figure class="mm mn mo mp gt kd"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="15fb" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">太好了，现在我们设置好了，我们可以加载图像并寻找人脸。请注意，哈尔级联和许多面部识别算法要求图像是灰度的。所以，在加载图像后，将其转换为灰度，然后使用face_cascade来检测人脸。得到脸部后，在它周围画一个矩形，在脸部区域搜索眼睛。然后在每只眼睛周围画矩形。</p><figure class="mm mn mo mp gt kd"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="ccf0" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过程序输出传递来自<a class="ae ko" href="https://unsplash.com/s/photos/family?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的库存图像:</p><figure class="mm mn mo mp gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi ms"><img src="../Images/cc100911f69b503a7d508f4a568e6f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipTh73vPN9r0K2qgq0mWhw.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@gustavoalvesl12?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Gustavo Alves </a>在<a class="ae ko" href="https://unsplash.com/s/photos/family?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄；由作者修改</p></figure><p id="39e5" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">酷！效果很好！请注意，有时Haar Cascade无法正确识别人脸和眼睛，特别是如果有人没有完全面对相机，有时它会认为嘴角和鼻子是眼睛。如果发生这种情况，对于本教程，我建议使用另一张照片。否则，您将需要自己创建一个完整的其他算法，而不是使用OpenCV的Haar Cascade。</p><h2 id="0070" class="lo lp it bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf iz bi translated">步骤2:创建你的图像过滤器</h2><p id="95e0" class="pw-post-body-paragraph kp kq it kr b ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">对于我的过滤器示例，我将使用女巫帽，因为本周末是万圣节。编辑上面的代码，我们可以在图片中读取一个女巫的帽子和我们的库存照片。因为我们要把帽子放在库存照片的上面，所以我们必须得到放置帽子的坐标。我们还必须弄清楚我们实际上想要使用女巫图像的哪些部分。我们可以通过使用cv2.threshold()和cv2.bitwise_not()方法来确定我们希望保留女巫图像的哪一部分，不保留哪一部分(这称为遮罩)。</p><figure class="mm mn mo mp gt kd"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="02f9" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后，对于每一张脸，我们必须把女巫的帽子放在哪里。使用面部的高度和宽度确定面部区域边界的坐标。然后调整女巫图像(或您选择的任何滤镜)的大小以适合面部区域，并选择适当的坐标来放置它。你可能不得不摆弄这些坐标，以获得你选择的图像降落在正确的地点。在我的女巫示例中，我必须上移过滤器/女巫图像，如下面的witch_y1所示，因为帽子的边缘应该落在人的前额上。如果我没有这样做，帽子图像将被准确地放置在脸部区域。一定要检查你的滤镜图像是否超出了主图像的框架。最后，使用遮罩来雕刻出放置滤镜的地方。</p><figure class="mm mn mo mp gt kd"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4fdf" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在我们的股票图像上运行这个新脚本:</p><figure class="mm mn mo mp gt kd gh gi paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="gh gi mt"><img src="../Images/b42748dd84d3682977f1a6cfae5e9072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agaowzal6tEMCzIo1JwAUQ.png"/></div></div><p class="kk kl gj gh gi km kn bd b be z dk translated">古斯塔沃·阿尔维斯在<a class="ae ko" href="https://unsplash.com/s/photos/family?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片；由作者修改</p></figure><p id="e6fb" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们已经成功构建了静态图像的面部识别过滤器！</p><h2 id="41f2" class="lo lp it bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf iz bi translated">步骤3:应用到实时视频源</h2><p id="c011" class="pw-post-body-paragraph kp kq it kr b ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">到目前为止，我们已经识别了静态照片中的人脸，并在它们上面放置了过滤图像。最后，我们需要用活动图像来做这件事。代码和以前一样，但是这次我们让OpenCV访问我们计算机的摄像头，而不是静态图像。我们还需要在while循环中包装我们在前面两步中使用的faces循环，以保持它在我们提供的每一帧直播视频中查找人脸。用户可以按字母“q”退出程序。</p><figure class="mm mn mo mp gt kd"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="d162" class="lo lp it bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf iz bi translated">步骤4:屏幕截图或屏幕录制</h2><p id="d866" class="pw-post-body-paragraph kp kq it kr b ks mg ku kv kw mh ky kz la mi lc ld le mj lg lh li mk lk ll lm im bi translated">在这一点上，最简单的方法就是使用我们电脑内置的屏幕捕捉或屏幕记录来保存我们摄像头过滤后的视频。</p><figure class="mm mn mo mp gt kd gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/b4b1b93c4577fb2e7e32fc62037272dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Tm8kJcxkcfL1EXkoZmeFgA.gif"/></div><p class="kk kl gj gh gi km kn bd b be z dk translated">Mitchell Krieger创建的GIF</p></figure><p id="4f0a" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">或者，如果你想用代码做任何事情，或者对捕获或记录有更多的控制，你可以使用<a class="ae ko" href="https://pillow.readthedocs.io/en/3.1.x/reference/ImageGrab.html" rel="noopener ugc nofollow" target="_blank"> PIL </a>或<a class="ae ko" href="https://pyautogui.readthedocs.io/en/latest/screenshot.html" rel="noopener ugc nofollow" target="_blank"> PyAutoGUI </a>通过代码捕获你的屏幕。</p><p id="22e7" class="pw-post-body-paragraph kp kq it kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">对我的原创剧本好奇吗？签出</em> <a class="ae ko" href="https://github.com/mitkrieg/live-image-face-filter-blog" rel="noopener ugc nofollow" target="_blank"> <em class="ln">这个GitHub库</em> </a></p></div></div>    
</body>
</html>