<html>
<head>
<title>Objects, Types and Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对象、类型和值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-data-model-part-1-objects-types-and-values-cb9316f57e8?source=collection_archive---------13-----------------------#2020-09-18">https://towardsdatascience.com/python-data-model-part-1-objects-types-and-values-cb9316f57e8?source=collection_archive---------13-----------------------#2020-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="8398" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Python数据模型</h2><div class=""/><div class=""><h2 id="4862" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Python数据模型—第1部分</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c57de6c8a08113329cb90e3a87273927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-X1tTvaaaUrP2CwH"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">克里斯里德在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="lf"><p id="3546" class="lg lh iq bd li lj lk ll lm ln lo lp dk translated"><strong class="ak"/>Python最好的品质之一就是它的一致性。在使用Python一段时间后，您能够开始对新特性做出明智、正确的猜测<strong class="ak">。</strong></p><p id="247b" class="lg lh iq bd li lj lq lr ls lt lu lp dk translated">“Python数据模型，它描述了API，您可以使用该API使您自己的对象与最惯用的语言特性配合良好。<strong class="ak"/>—流畅的Python，卢西亚诺·拉马尔霍</p></blockquote><p id="4d84" class="pw-post-body-paragraph lv lw iq lx b ly lz ka ma mb mc kd md me mf mg mh mi mj mk ml mm mn mo mp lp ij bi translated"><em class="mq"> Python数据模型</em>可以定义为<em class="mq">“Python框架”</em>或<em class="mq">“Python设计哲学”</em>。这种语言的开发者已经开发了相当大的文档，乍一看可能有点模糊、吓人或者含糊不清。</p><p id="224a" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">然而，简单地说，术语<em class="mq">数据模型</em>是不言自明的——它处理Python如何在内部组织一切以处理和处理数据，以及其核心设计和哲学的一些高级概念。它讨论了语言本身的基本构造块、构造块的设计/结构以及与它们相关的基本代码块。</p><p id="063f" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">在本章中，我们将讨论<strong class="lx ja">对象</strong>、<strong class="lx ja">类型和值</strong></p><blockquote class="mw mx my"><p id="5b04" class="lv lw mq lx b ly mr ka ma mb ms kd md mz mt mg mh na mu mk ml nb mv mo mp lp ij bi translated">在Python中——一切都是对象。每个对象都有一个身份、类型和值</p></blockquote><p id="4896" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">在Python中——一切都是对象。每个对象都有一个<strong class="lx ja">标识</strong>，一个<strong class="lx ja">类型</strong>，一个<strong class="lx ja">值</strong>。那么，<strong class="lx ja">身份</strong>、<strong class="lx ja">类型、</strong>和<strong class="lx ja">值有什么大惊小怪的？我们将编写一些简单的代码—</strong></p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="cbb2" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; player_1 = "Maradona"<br/>&gt;&gt;&gt; id(player_1)<br/>139780790567600<br/>&gt;&gt;&gt; age = 53<br/>&gt;&gt;&gt; id(age)<br/>9753824</span></pre><blockquote class="mw mx my"><p id="496e" class="lv lw mq lx b ly mr ka ma mb ms kd md mz mt mg mh na mu mk ml nb mv mo mp lp ij bi translated">我们可以认为身份是一个对象在内存中的地址</p></blockquote><p id="1e7b" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">在这里，<strong class="lx ja"> id() </strong>给出了我们正在谈论的<strong class="lx ja">标识</strong>，它是一个惟一的整数，在一个对象的生命周期中不会改变。我们可以认为身份是一个对象在内存中的地址。我们可以用<strong class="lx ja">操作符</strong>检查两个对象是否相同。</p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="bb8c" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; player_2 = "Pele"<br/>&gt;&gt;&gt; player_1 is player_2     #They are not referring the same object<br/>False </span><span id="ca30" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; player_copy = player_1<br/>&gt;&gt;&gt; player_1 is player_copy   #They are referring the same object<br/>True</span><span id="6c27" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; id(player_2)<br/>139780790567984<br/>&gt;&gt;&gt; id(player_copy)<br/>139780790567600</span></pre><p id="9b9e" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">现在，如果我们想检查这些对象的<strong class="lx ja">类型</strong>，我们可以使用<strong class="lx ja"> type() </strong>。</p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="3cfb" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; type(age)<br/>&lt;class ‘int’&gt;<br/>&gt;&gt;&gt; type(player_1)<br/>&lt;class 'str'&gt;</span></pre><blockquote class="mw mx my"><p id="8de7" class="lv lw mq lx b ly mr ka ma mb ms kd md mz mt mg mh na mu mk ml nb mv mo mp lp ij bi translated"><strong class="lx ja">物体的类型不能改变</strong></p></blockquote><p id="efa8" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">对象的<strong class="lx ja">类型</strong>不能改变</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="f677" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated"><em class="mq">在某些情况下，在某些受控条件下，可以改变对象的类型。但这通常不是一个好主意，因为如果处理不当，它会导致一些非常奇怪的行为。</em></p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="37de" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated"><strong class="lx ja">类型</strong>指定了两件事:<br/>–允许哪些操作<br/>–对象可以保存的一组值</p><blockquote class="mw mx my"><p id="dc85" class="lv lw mq lx b ly mr ka ma mb ms kd md mz mt mg mh na mu mk ml nb mv mo mp lp ij bi translated"><strong class="lx ja">如果对象是<em class="iq">可变的</em>对象的值可以改变，如果对象是<em class="iq">不可变的</em>对象的值不能改变。</strong></p></blockquote><p id="38a3" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">并且，一个对象的<strong class="lx ja">值</strong>是该对象在其中保存的内容。这里<code class="fe nv nw nx nd b">53</code>是<code class="fe nv nw nx nd b">age</code>的值，<code class="fe nv nw nx nd b">Maradona</code>是<code class="fe nv nw nx nd b">player_1</code>的值。如果对象是<strong class="lx ja"> <em class="mq">可变</em> </strong>对象的<strong class="lx ja">值</strong>可以改变，如果对象是<strong class="lx ja"> <em class="mq">不可变</em> </strong>对象的值不能改变。</p><blockquote class="mw mx my"><p id="a165" class="lv lw mq lx b ly mr ka ma mb ms kd md mz mt mg mh na mu mk ml nb mv mo mp lp ij bi translated"><code class="fe nv nw nx nd b"><strong class="lx ja">age = 53</strong></code> <strong class="lx ja">是一个值为53的整型对象，id为9753824 </strong></p></blockquote><p id="ec90" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">这意味着<code class="fe nv nw nx nd b">age = 53</code>是一个整数<strong class="lx ja">类型的</strong>对象，值为<strong class="lx ja">53，id为<strong class="lx ja">9753824，如果我们现在将<code class="fe nv nw nx nd b">age</code>改为<code class="fe nv nw nx nd b">54</code>，它将引用一个不同的对象</strong></strong></p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="3b8e" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; age = 54 # here, age is referring to a different object<br/>&gt;&gt;&gt; id(age)  # showing different <strong class="nd ja">identity</strong> than the previous one <br/>9753856</span></pre><p id="6182" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">因此，如果我们想改变<code class="fe nv nw nx nd b">player_1</code>的值，那么对象<code class="fe nv nw nx nd b">player_copy</code>和<code class="fe nv nw nx nd b">player_1</code>将不会显示相同的<strong class="lx ja">标识</strong></p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="b8a0" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; player_1 = "Messi" # assigning new value to <br/>&gt;&gt;&gt; player_copy<br/>'Maradona'<br/>&gt;&gt;&gt; player_1 is player_copy<br/>False</span></pre><p id="641c" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">因此，<code class="fe nv nw nx nd b">player_1</code>又名<em class="mq">字符串</em>和<code class="fe nv nw nx nd b">age</code>又名<em class="mq">整数</em>都是<strong class="lx ja">不可变</strong>类型。还有其他不可变类型。如— <em class="mq">整数、浮点数、字符串、元组</em>。另一方面，<strong class="lx ja">可变</strong>类型是<em class="mq">列表</em>、<em class="mq">字典</em>和<em class="mq">集合。</em>现在，看看<strong class="lx ja">可变</strong>类型</p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="2a02" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; players = ["Messi", "Maradona", "Pele"]<br/>&gt;&gt;&gt; players_copy = players     # Coping the reference to the list<br/>                                object,not the list object itself.</span><span id="baa2" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; players is players_copy<br/>True</span><span id="a051" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; players[0]="Ronaldo"          # Changing the first element<br/>&gt;&gt;&gt; players<br/>['Ronaldo', 'Maradona', 'Pele']<br/>&gt;&gt;&gt; players_copy<br/>['Ronaldo', 'Maradona', 'Pele']   # They refer to same list object.</span><span id="7fa4" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; players.append("Pirlo")       # Appending a new element<br/>&gt;&gt;&gt; players<br/>['Ronaldo', 'Maradona', 'Pele', 'Pirlo']<br/>&gt;&gt;&gt; players_copy<br/>['Ronaldo', 'Maradona', 'Pele', 'Pirlo']</span><span id="f755" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; players_copy.append("Cruyf")<br/>&gt;&gt;&gt; players_copy<br/>['Ronaldo', 'Maradona', 'Pele', 'Pirlo', 'Cruyf']<br/>&gt;&gt;&gt; players<br/>['Ronaldo', 'Maradona', 'Pele', 'Pirlo', 'Cruyf']</span></pre><blockquote class="mw mx my"><p id="024b" class="lv lw mq lx b ly mr ka ma mb ms kd md mz mt mg mh na mu mk ml nb mv mo mp lp ij bi translated"><strong class="lx ja">由于</strong> <code class="fe nv nw nx nd b"><strong class="lx ja">players</strong></code> <strong class="lx ja">和</strong> <code class="fe nv nw nx nd b"><strong class="lx ja">players_copy</strong></code> <strong class="lx ja">引用同一个<em class="iq">列表</em>对象，一个<em class="iq">列表</em>的变化会影响另一个变量。</strong></p></blockquote><p id="79c6" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">在上面的例子中，我们通过改变第一个值并使用<code class="fe nv nw nx nd b">append()</code>方法来变异<code class="fe nv nw nx nd b">players</code> <em class="mq">列表</em>。由于<code class="fe nv nw nx nd b">players</code>和<code class="fe nv nw nx nd b">players_copy</code>引用同一个<em class="mq">列表</em>对象，一个<em class="mq">列表</em>的变化会影响另一个变量。</p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="de9a" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; id(players)<br/>139780790567040<br/>&gt;&gt;&gt; id(players_copy)<br/>139780790567040</span></pre><p id="4c2e" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">注意，如果我们改变一个变量所引用的<em class="mq">列表</em>，它将创建一个新的<em class="mq">列表</em>对象。我们不应该混淆突变和改变变量。</p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="e4d4" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; players = ["Messi", "Maradona", "Pele"]<br/>&gt;&gt;&gt; id(players)<br/>139780790567040</span><span id="bc49" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; players = ["Messi", "Maradona", "Pele", 'Pirlo', 'Cruyf']<br/>&gt;&gt;&gt; id(players) <br/>139780790568064</span></pre><p id="4d61" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">在这里，这一行<code class="fe nv nw nx nd b">players = [“Messi”, “Maradona”, “Pele”, ‘Pirlo’, ‘Cruyf’]</code>创建了一个新的列表并将<code class="fe nv nw nx nd b">players</code>变量引用到其中。我们可以通过检查两个身份证来判断。</p><p id="7a2e" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">为了更清楚地理解<strong class="lx ja">可变性</strong>和<strong class="lx ja">不变性，</strong>让我们把<em class="mq">元组</em>带到射击区。我们前面说过，<em class="mq">元组</em>是<strong class="lx ja">不可变的，</strong>突变<em class="mq">元组</em> <strong class="lx ja">类型</strong>应该不可能。</p><pre class="kp kq kr ks gt nc nd ne nf aw ng bi"><span id="46d6" class="nh ni iq nd b gy nj nk l nl nm">&gt;&gt;&gt; players_tuple = ("Kaka", "Buffon")<br/>&gt;&gt;&gt; players_tuple<br/>('Kaka', 'Buffon')<br/>&gt;&gt;&gt; type(players_tuple)<br/>&lt;class 'tuple'&gt;<br/>&gt;&gt;&gt; id(players_tuple)<br/>139780790517248</span><span id="3528" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; players_tuple[0]<br/>'Kaka'<br/>&gt;&gt;&gt; players_tuple[0]="De Bruyne"     # can't mutate in tuples<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'tuple' object does not support item assignment</span><span id="04b5" class="nh ni iq nd b gy nn nk l nl nm">&gt;&gt;&gt; players_tuple= players_tuple +("De Bruyne",) # adding a new data<br/>&gt;&gt;&gt; players_tuple<br/>('Kaka', 'Buffon', 'De Bruyne')<br/>&gt;&gt;&gt; id(players_tuple)                # it's creating a new tuple<br/>139780766363584</span></pre><p id="0ec8" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">在这一部分，我们试图清楚地理解一个对象如何在pythonic世界中保持其本质，以及<strong class="lx ja">可变性</strong>和<strong class="lx ja">不变性</strong>之间的区别。在后面的章节中，我们将更深入地研究python数据模型。</p><p id="aa22" class="pw-post-body-paragraph lv lw iq lx b ly mr ka ma mb ms kd md me mt mg mh mi mu mk ml mm mv mo mp lp ij bi translated">参考文献:<br/> 1。<a class="ae le" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/reference/datamodel.html</a>T37】2。卢西亚诺·拉马尔霍的流畅Python。这是每一个python爱好者都应该读的书，以提高他们的python技能。</p></div></div>    
</body>
</html>