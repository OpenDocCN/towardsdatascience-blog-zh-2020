<html>
<head>
<title>Python Decorators with Data Science: Random Sampling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python装饰者与数据科学:随机抽样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-decorators-with-data-science-random-sampling-177962cae80c?source=collection_archive---------56-----------------------#2020-10-12">https://towardsdatascience.com/python-decorators-with-data-science-random-sampling-177962cae80c?source=collection_archive---------56-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/4e7cd61c3c700414a5729e235a959bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*D-QsItg5T2cDgT_ZbkDYlQ.png"/></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">来源:https://en.wikipedia.org/wiki/Inverse_transform_sampling</p></figure><div class=""/><div class=""><h2 id="c2c3" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">使用python decorator进行随机采样</h2></div><p id="e08e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章在一起学习一些概念方面更有教育意义。我想知道如何将python decorators与特定的数据科学概念结合使用，于是就有了写这篇文章的想法。让我们先看看随机抽样是如何做到的。</p><h1 id="3d98" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">随意采样</h1><p id="6c5c" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">逆变换是从一些众所周知的分布中生成随机样本的方法之一。逆变换取0和1之间的均匀样本<em class="mn"> u </em>，并从分布P(X)返回最大数<em class="mn"> x </em>，使得X低于<em class="mn"> x </em>的概率小于等于u</p><blockquote class="mo mp mq"><p id="daa2" class="ku kv mn kw b kx ky kg kz la lb kj lc mr le lf lg ms li lj lk mt lm ln lo lp im bi translated"><a class="ae jc" href="https://en.wikipedia.org/wiki/Probability_integral_transform" rel="noopener ugc nofollow" target="_blank">概率积分变换</a>陈述了如果x是一个<a class="ae jc" href="https://en.wikipedia.org/wiki/Continuous_random_variable" rel="noopener ugc nofollow" target="_blank">连续随机变量</a>具有<a class="ae jc" href="https://en.wikipedia.org/wiki/Cumulative_distribution_function" rel="noopener ugc nofollow" target="_blank">累积分布函数</a> Fₓ，那么随机变量Y=Fₓ(X在【0，1】上具有<a class="ae jc" href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)" rel="noopener ugc nofollow" target="_blank">均匀分布</a>。逆概率积分变换正好与此相反:具体来说，如果y在[0，1]上具有均匀分布，并且如果x具有累积分布Fₓ，则随机变量Fₓ⁻ (Y)具有与x相同的分布</p><p id="0ca3" class="ku kv mn kw b kx ky kg kz la lb kj lc mr le lf lg ms li lj lk mt lm ln lo lp im bi translated">来源:<a class="ae jc" href="https://en.wikipedia.org/wiki/Inverse_transform_sampling" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Inverse_transform_sampling</a></p></blockquote><p id="9286" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">维基百科关于<a class="ae jc" href="https://en.wikipedia.org/wiki/Inverse_transform_sampling" rel="noopener ugc nofollow" target="_blank">逆变换采样</a>的文章对此有更详细的解释。在这篇文章中，我不会深入讨论这个问题，只是使用逆变换来计算一些分布的随机样本。</p><p id="96b1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据这篇文章，逆变换采样方法的工作原理如下:</p><ol class=""><li id="a916" class="mu mv jf kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated">从区间[0，1]中的标准均匀分布生成一个随机数u</li><li id="2797" class="mu mv jf kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">求所需CDF的倒数，例如Fₓ⁻ (X)</li><li id="e198" class="mu mv jf kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated">计算Fₓ⁻(美国)</li></ol><p id="2d14" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我将逐一介绍这些步骤，并介绍我们如何使用python decorators。</p><h2 id="2a76" class="ni lr jf bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated">随机数发生器</h2><p id="31b0" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Python随机模块提供了一种生成随机数的好方法。</p><blockquote class="mo mp mq"><p id="e436" class="ku kv mn kw b kx ky kg kz la lb kj lc mr le lf lg ms li lj lk mt lm ln lo lp im bi translated">随机. random()</p><p id="e75b" class="ku kv mn kw b kx ky kg kz la lb kj lc mr le lf lg ms li lj lk mt lm ln lo lp im bi translated">返回[0.0，1.0]范围内的下一个随机浮点数。</p></blockquote><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="04c8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们定义一个函数<em class="mn"> random_sample </em>，它返回一个给定长度<em class="mn">大小</em>的随机数列表。那很容易！</p><h2 id="6791" class="ni lr jf bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated">逆累积分布函数</h2><p id="15f5" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在这个练习中，让我们以伯努利分布为例。它是一个离散的概率分布，其中随机变量<em class="mn"> x </em>以概率<em class="mn"> p </em>取值1，以概率1 - <em class="mn"> p </em>取值0。</p><p id="b0ce" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<em class="mn"> x </em> = 0时，P(X = X)= 1-<em class="mn">P .</em>F(<em class="mn">X</em>)在这种情况下也是1-<em class="mn">P</em>。F的倒数可以理解为，当来自均匀分布的随机样本小于等于1- <em class="mn"> p </em>时，则<em class="mn"> x </em>为0。由此我们还可以得出，当随机样本大于1- <em class="mn"> p </em>时，则<em class="mn"> x </em>为1。</p><h2 id="cb61" class="ni lr jf bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated">计算逆CDF</h2><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ac78" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，如果随机生成的数字小于等于1- <em class="mn"> p </em>，则该方法返回0，否则返回1。很高兴看到概率为0.5(甚至概率为0或1)的伯努利样本有一半是0，另一半是1。类似地，对于0.8的概率，10个样本中有8个是1。需要注意的是，在不同的机器和不同的运行中，结果可能会有所不同。</p><h2 id="8039" class="ni lr jf bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated">Python装饰者</h2><p id="f4db" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们可以用<em class="mn"> bernoulli_sample来修饰函数<em class="mn"> random_sample </em>。</em>这将使所有的random_sample都来自伯努利分布。让我们看看如何做到这一点。</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f683" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样的结局和以前一样。我看到10个样本中有8个样本的概率为0.8。同样，需要注意的是，在您的机器上和不同的运行中，结果可能会有所不同。</p><h2 id="7c4f" class="ni lr jf bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated">问题</h2><ol class=""><li id="bf2a" class="mu mv jf kw b kx mi la mj ld oa lh ob ll oc lp mz na nb nc bi translated"><strong class="kw jg">输入参数</strong>:如果你仔细看<em class="mn"> random_sample </em>函数的定义，它已经变了。现在不是以大小作为输入，而是以概率和大小两个输入。</li><li id="a476" class="mu mv jf kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated"><strong class="kw jg">函数名</strong>:另一个问题是函数名<em class="mn"> random_sample </em>暗示了它的随机样本，而不是来自伯努利分布的样本列表。</li></ol><p id="a5a9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们解决以上两个问题。</p><h2 id="19dc" class="ni lr jf bd ls nj nk dn lw nl nm dp ma ld nn no mc lh np nq me ll nr ns mg nt bi translated">一般化</h2><p id="7868" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">kwargs是python中传递关键字参数的一种方式。我将用它来概括实现。此外，我将交换<em class="mn">伯努利</em>和<em class="mn">随机样本</em>函数的顺序。所以与其说是<em class="mn">伯努利</em>装饰<em class="mn"> random_sample </em>，不如说是反过来。这将为我们提供描述分布名称的函数名。</p><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2e75" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我们所做的更改列表:</p><ol class=""><li id="53df" class="mu mv jf kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><strong class="kw jg">装饰者</strong>:现在<em class="mn"> random_sample </em>方法是装饰者，装饰任何方法<em class="mn">分配</em>。</li><li id="08b9" class="mu mv jf kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated"><strong class="kw jg">关键字参数</strong> s:用随机的<em class="mn">样本更新参数字典，</em>因此任何分配方法都可以通过，而不管它的参数。</li><li id="6fbb" class="mu mv jf kw b kx nd la ne ld nf lh ng ll nh lp mz na nb nc bi translated"><strong class="kw jg">包装</strong>:使用<em class="mn">包装</em>允许将docstring更新为包装的分发函数。help(bernoulli)显示了更具描述性的内容。</li></ol><blockquote class="mo mp mq"><p id="6b9f" class="ku kv mn kw b kx ky kg kz la lb kj lc mr le lf lg ms li lj lk mt lm ln lo lp im bi translated">模块__main__中关于伯努利函数的帮助:</p><p id="0d3c" class="ku kv mn kw b kx ky kg kz la lb kj lc mr le lf lg ms li lj lk mt lm ln lo lp im bi translated">伯努利(**kwargs) <br/>样本来自给定概率p和大小的伯努利分布。<br/> :param p:事件发生的概率<br/> :param size:随机样本数<br/> :return:给定大小的样本列表</p></blockquote><h1 id="9e59" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated"><strong class="ak">指数分布</strong></h1><p id="bee4" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们把我们在伯努利方程中学到的知识应用到指数分布中。指数分布的累积分布函数如下:</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/270403c3780ec9145e23514238cef4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*RW_2xucEOfFfw6jaxFzmTg.png"/></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">资料来源:https://en.wikipedia.org/wiki/Exponential_distribution</p></figure><p id="c3df" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">指数分布的CDF的倒数为:</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/a651096df0aa75d10471b82e3e566d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*VhAaHs7UhNzsD86OcWiNtw.png"/></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">来源:<a class="ae jc" href="https://en.wikipedia.org/wiki/Inverse_transform_sampling" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Inverse_transform_sampling</a></p></figure><figure class="nu nv nw nx gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2e30" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面是使用<em class="mn">random _ sample</em>decorator从指数分布中获取样本的代码。下面是获得的样品的直方图。</p><figure class="nu nv nw nx gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a29240ebb02a59ab09fc095790ae8ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*XiWkEvqZ7mw7Hp3oXtF9tg.png"/></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">指数分布:概率分布函数</p></figure><h1 id="9e09" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">结论</h1><p id="592c" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在这篇文章中，我想探索如何将Python和数据科学这两个概念结合起来。希望你对如何用<em class="mn"> random_sample </em>来装饰逆变换实现可以产生目标分布的样本感兴趣。</p><p id="fecb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在LinkedIn上与我联系或在Medium上关注我。如果你喜欢这个故事，你可能会喜欢我关于python decorators的其他故事:</p><div class="is it gp gr iu og"><a href="https://medium.com/better-programming/decorator-pattern-and-python-decorators-b0b573f4c1ce" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jg gy z fp ol fr fs om fu fw je bi translated">装饰模式和Python装饰器</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">为什么它们不一样？</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou iw og"/></div></div></a></div><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/python-decorators-from-simple-decorators-to-nesting-multiple-33bbab8c5a45"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jg gy z fp ol fr fs om fu fw je bi translated">Python装饰器:从简单装饰器到嵌套多重</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">如何用多个参数化的decorators修改一个函数？</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou iw og"/></div></div></a></div></div></div>    
</body>
</html>