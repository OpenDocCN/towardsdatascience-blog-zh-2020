<html>
<head>
<title>Graph Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-programming-d1c52fea5ce9?source=collection_archive---------29-----------------------#2020-09-26">https://towardsdatascience.com/graph-programming-d1c52fea5ce9?source=collection_archive---------29-----------------------#2020-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6d92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">命令式编程的特点是迭代嵌套。一个函数嵌入了对其他函数的调用。我所说的嵌入是指这些调用在函数体中，因此函数和它的组成部分之间有紧密的耦合。这有许多缺点，通常通过函数组合来解决。</p><p id="5e3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构图就像把两个东西连在一起。没有一个事物是在另一个事物之上的、嵌入的或优越的，它们只是相互补充。因此，所涉及的功能彼此之间是不相干的，这很好，因为你可以混合和匹配，分别测试和调试它们。</p><p id="b5f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数组合实用程序或库会生成一个新的函数或对象，表示其组成部分的组合，但不再可能引用这些组成部分。你得到了一个新的不可穿透的盒子(再次嵌套)。</p><p id="88b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在典型的构图中，你可以继续在这个盒子里或盒子外构图，只要构图是在边上完成的，而不是单个的成分。然而，如果你有非一元函数，你需要开始使用currying，事情可能会变得复杂。</p><p id="c5fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为人类，我们不会这样思考或说话，我们可以任意引用概念，以非一元的方式自由写作。</p><p id="4e04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这项工作提出了图编程的概念，这是一种通过以非封闭方式连接函数对来构建函数图的编程方法，旨在取代典型的函数组合。</p><h2 id="0b84" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">先决条件</h2><p id="0df4" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">我将使用python来说明我的例子。我也将使用函数式编程风格。</p><p id="f914" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你应该熟悉<code class="fe lm ln lo lp b">compose_left</code>、<code class="fe lm ln lo lp b">pipe</code>和<code class="fe lm ln lo lp b">curry</code>才能跟上。</p><p id="1153" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不是，下面是前两者的可行实现:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="f542" class="ko kp it lp b gy ly lz l ma mb">def compose_left(*funcs):<br/>    def composition(input):<br/>        for f in funcs:<br/>            input = f(input)<br/>        return input<br/><br/>    return composition</span><span id="5e60" class="ko kp it lp b gy mc lz l ma mb">def pipe(input, funcs*):<br/>    return compose_left(*funcs)(input)</span></pre><p id="7327" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至于<code class="fe lm ln lo lp b">curry</code>,由于它的实现有点复杂，您可以使用这个使用示例来了解它的功能:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="33e6" class="ko kp it lp b gy ly lz l ma mb">@curry<br/>def add(x, y):<br/>    return x + y</span><span id="441d" class="ko kp it lp b gy mc lz l ma mb"># I can give a single argument, getting back a function that<br/># expects the remaining argument.<br/>add_5 = add(5)<br/>add_5(7)  # Will give 12.</span></pre><h2 id="c791" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">非线性程序</h2><p id="d5d5" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">考虑以下情况，其中您有以下管道:</p><p id="43ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">foo = compose_left(x_1, x_2, ..., x_n)</code></p><p id="1345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">foo</code>是一些函数的组合。太好了。</p><p id="7a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在想象一下<code class="fe lm ln lo lp b">x_n</code>得到两个参数而不是一个的情况。所以我们不能再单独使用这个组合，我们需要使用currying和一个额外的<code class="fe lm ln lo lp b">def</code>,就像这样:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="4381" class="ko kp it lp b gy ly lz l ma mb">@curry<br/>def x_n(arg1, arg2):<br/>    ...</span><span id="6287" class="ko kp it lp b gy mc lz l ma mb">def make_foo(head_input, side_input):<br/>    return pipe(<br/>        head_input,<br/>        x_1,<br/>        x_2,<br/>        ...,<br/>        x_n(side_input)<br/>    )</span></pre><p id="d4e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Currying很棒，因为我们不需要复杂的<code class="fe lm ln lo lp b">x_n</code>来表达它将在代码中的两个不同位置获得它的两个依赖项。<code class="fe lm ln lo lp b">side_input</code>将作为<code class="fe lm ln lo lp b">arg2</code>进入<code class="fe lm ln lo lp b">x_n</code>。</p><p id="8a54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里仍然有一些渗漏。我们不必要地将剩余的合成代码暴露给<code class="fe lm ln lo lp b">side_input</code>。如果我有很多依赖项，并且我想在不同的时间给它们，这会变得非常混乱。</p><p id="1e33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑这样的情况，其中<code class="fe lm ln lo lp b">x_n</code>是两个独立管道的成员，每个管道给它不同的输入。</p><p id="c47b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以试着这样编程(这显然是行不通的):</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="5134" class="ko kp it lp b gy ly lz l ma mb">def baz(arg1, arg2):<br/>    ...</span><span id="11a1" class="ko kp it lp b gy mc lz l ma mb"># incoming argument on position 2<br/>foo = compose_left(x_1, x_2, ..., <!-- -->baz)</span><span id="1b0b" class="ko kp it lp b gy mc lz l ma mb"># incoming argument on position 2<br/>bar = compose_left(y_1, y_2, ..., <!-- -->baz<!-- -->)</span></pre><p id="75bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调用<code class="fe lm ln lo lp b">foo</code>或<code class="fe lm ln lo lp b">bar</code>会给我们一个熟悉的例外，即<code class="fe lm ln lo lp b">baz</code>期望两个参数，但只得到一个。</p><p id="ad5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用一些命令式的风格来克服这个问题:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="dba3" class="ko kp it lp b gy ly lz l ma mb">def everything(head_arg1, head_arg2):<br/>    return baz(<br/>        pipe(head_arg1, ...),<br/>        pipe(head_arg2, ...),<br/>    )</span></pre><p id="b692" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这适用于简单的情况，但不适用于一般情况。如果我在不同的阶段连接了几个函数，那么我将不得不放弃组合符号，并以命令式风格结束，或者简单地拥有一个大函数，其中所有的东西都暴露给所有的东西。</p><figure class="lq lr ls lt gt me gh gi paragraph-image"><div class="gh gi md"><img src="../Images/2d725ca7da34c3c1029714425fdcc190.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*RSJfv82KKXKi7ph3yCeAiw.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">复杂的依赖结构(<em class="ml">作者图片</em>)</p></figure><p id="9c72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一下，必须编写单个签名来支持上述结构。那就必须是<code class="fe lm ln lo lp b">d3</code>、<code class="fe lm ln lo lp b">d1</code>、<code class="fe lm ln lo lp b">p1</code>、<code class="fe lm ln lo lp b">d2</code>的结合。函数体本身会全局暴露变量，理解依赖结构会非常困难。</p><p id="516f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为人类，如何表达是很明显的。我们只是画出来。让我们回到上面这个简单的例子。</p><figure class="lq lr ls lt gt me gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/bca370485ce8c1863f27bd577df55dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*l_T2T23XeEDkYxd0zwsUOQ.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">当你能画的时候不需要涂抹(<em class="ml">作者的图片</em></p></figure><p id="7c2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以“编码”它，例如这是我用来生成上面图像的代码:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="7e74" class="ko kp it lp b gy ly lz l ma mb">digraph G {<br/>  x_1 -&gt; x_2 -&gt; baz<br/>  y_1 -&gt; y_z -&gt; baz<br/>}</span></pre><p id="a86f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我编程的时候应该也能做到。</p><h2 id="ec0a" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">编写者</h2><p id="dcf7" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">“图”这个词本身就来源于素描或绘画，这才是真正正确的意义。我们希望能够画出程序，因为我们对它们的心理模型是非线性结构。</p><p id="b760" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">*编程这个词本身来自更早的希腊语“prographein”。我们其实都只是程序员。</p><p id="3a40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mn" href="https://github.com/hyroai/computation-graph" rel="noopener ugc nofollow" target="_blank">https://github.com/hyroai/computation-graph</a>用python实现了第一个图形编程框架。</p><p id="bf8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它允许使用用普通python编写的纯函数，并显式声明它们的依赖关系，而不需要它们知道彼此。这类似于任何功能组合框架。除此之外，cg还有其他一些技巧。</p><h2 id="7fea" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">非线性合成</h2><p id="f9fe" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">第一个技巧是将合成推广到非一元函数，将管道推广到有向无环图(Dag)。依赖不仅仅是“线”，所以我们应该能够，例如，将两条线连接成一个二元函数。我只需要说出我正在编写的关键字就可以完成这个例子。</p><p id="f96e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个例子:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="093c" class="ko kp it lp b gy ly lz l ma mb">everything = to_callable([<br/>    *compose_left(x1, ..., x_n-1),<br/>    *compose_left(x_n-1, baz, keyword="arg1"),<br/>    *compose_left(y1, ..., y_n-1),<br/>    *compose_left(y_n-1, baz, keyword="arg2"),<br/>])</span><span id="e8de" class="ko kp it lp b gy mc lz l ma mb">...<br/># usage:<br/>everything(input_to_x_chain, input_to_y_chain)</span></pre><p id="b824" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个组合本质上都是边的集合，带有一些语法糖，允许您轻松地创建子结构。</p><h2 id="fe56" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">记忆</h2><p id="35a4" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">纯函数和组合很容易处理。它们易于测试和推理，并且不会暴露在令人讨厌的状态中。但是现实仍然需要有记忆的程序，或者运行几次并保留一些上下文的程序，所以我们需要在纯函数中引入状态或记忆。流行的UI框架React已经使用钩子解决了这个问题(例如<code class="fe lm ln lo lp b">useState</code>)。我们希望对我们使用的函数的纯度有更严格的要求，不要在函数中引入任何神奇的调用。换句话说，我们希望在函数的参数中完整地描述输入，并将输出完整地定义为函数的输出。</p><p id="3232" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先实现了一种特殊的节点，称为缩减器。reducer返回两个元素，一个输出和它的内存，计算图框架将在下一次“转向”时在一个名为<code class="fe lm ln lo lp b">state</code>(类似于python中的<code class="fe lm ln lo lp b">self</code>)的特殊参数中为函数提供内存。</p><p id="fed2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们意识到，这种模式可以用更简单的方式实现，不需要任何特殊的关键字参数或构造。我们意识到记忆是对未来的依赖。这里的未来指的是下一次运行计算图。因此，我们改变了实现，使之具有我们称之为“未来边缘”的东西。未来边缘描述时间轴上的函数组合。所以一个函数可以被组合(即有一个边)到它自己或者其他函数上(甚至是它应该依赖的函数！)，而没有真正产生循环。这是因为当前回合所需的值来自前一回合。</p><p id="ce36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们引入这个概念时，我们讨论的不再是Dag，而是一般的图，这些图可能有“圈”(只要这个圈至少有一条未来的边可以打破它)。</p><p id="f063" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，当我们引入内存时，整个计算图的签名变成了两个元素，其中一个是输出，另一个是状态，当我们再次运行它时，我们确保给它前一轮的状态。因此当缩小时，整个计算图具有缩减函数的特征。</p><h2 id="a196" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">记录</h2><p id="2917" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">日志记录是编程中的一个经典问题。我们写一些代码来做一些事情，然后我们想观察它并记录它在做什么。作为例子，考虑流水线<code class="fe lm ln lo lp b">compose_left(x, y, z_1, ..., z_n)</code>。</p><p id="9bb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且说我们想看<code class="fe lm ln lo lp b">y</code>的输出。所以我们可能会这样做:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="be29" class="ko kp it lp b gy ly lz l ma mb">def y(some_input):<br/>    ...<br/>    return output, log</span></pre><p id="7617" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是唉，<code class="fe lm ln lo lp b">z_1</code>期望得到<code class="fe lm ln lo lp b">y</code>的输出。这意味着我们将不得不复杂化<code class="fe lm ln lo lp b">z_i</code>来处理一对元素。我们想要避免它。对于图形编程来说，这很容易做到。简单地将<code class="fe lm ln lo lp b">y</code>连接成两个面:</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="c814" class="ko kp it lp b gy ly lz l ma mb">(<br/>    *compose_left(x, y, z_1, ..., z_n),<br/>    *compose_left(y, logger),<br/>    *compose_left(logger, final_output, key="log"),<br/>    *compose_left(z_n, final_output, key="real_output"),<br/>)</span></pre><h2 id="8d53" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">异步编程</h2><p id="8940" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">python中的Async真的很难搞对。同步函数不能调用异步函数，所以至少可以说混合使用这两种函数是很重要的。此外，你必须仔细选择何时在两行中使用<code class="fe lm ln lo lp b">await</code>，以及何时使用类似<code class="fe lm ln lo lp b">asyncio.gather</code>的东西。但是这个信息，什么需要首先发生，已经在你的程序中了。比如下面这个例子效率不高。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="ed02" class="ko kp it lp b gy ly lz l ma mb">async def my_async_program():<br/>    x = await async_f()<br/>    y = await async_g()<br/>    return sync_h(x=x, y=y)</span></pre><p id="15f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为我们可以将<code class="fe lm ln lo lp b">x</code>上的<code class="fe lm ln lo lp b">await</code>与<code class="fe lm ln lo lp b">y</code>并行。但是为什么我们作为人类应该注意到它，而不是去推断它呢？</p><p id="366b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们画出来，就很明显了。</p><figure class="lq lr ls lt gt me gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/6515ff99a2ebc0c3e58e35d757cdd7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*JVqq7u4D9fmZZC5LWPgyQg.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">(<em class="ml">作者图片</em>)</p></figure><p id="019c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，计算图形库允许您混合异步和同步功能，甚至使用拓扑排序为您推断哪些功能可以并行运行。这将被写成如下。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="4637" class="ko kp it lp b gy ly lz l ma mb">(<br/>    *compose_left(async_f, sync_h, key="x"),<br/>    *compose_left(async_g, sync_h, key="y"),<br/>)</span></pre><h2 id="5462" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">含糊</h2><p id="2e3a" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">另一个很酷的特性是，你实际上可以在一个函数中组合多个选项，使得图形有点像一个不确定的模型。这意味着输入可以来自任一边。为了使结果可预测，这些边具有优先级，因此计算图将首先尝试优先级更高的边，并且只有当计算路径不成功(即引发特定异常)时，图运行器才会尝试不同的路径。</p><pre class="lq lr ls lt gt lu lp lv lw aw lx bi"><span id="2db6" class="ko kp it lp b gy ly lz l ma mb">(<br/>    make_edge(f1, g, key="some_kwarg", priority=0),<br/>    make_edge(f2, g, key="some_kwarg", priority=1),<br/>)</span></pre><p id="e920" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，<code class="fe lm ln lo lp b">g</code>可能从<code class="fe lm ln lo lp b">f1</code>获得输入，或者如果不成功，从<code class="fe lm ln lo lp b">f2</code>获得输入。注意，我们在这里使用较低级别的API，但这与<code class="fe lm ln lo lp b">compose_left</code>非常相似。</p><h2 id="f08a" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">TODO:循环</h2><p id="3d1a" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">计算图尚不支持循环。当需要时，它们也可能被实现为一个特殊的边缘。这仍处于早期规划阶段，欢迎对此(或PRs)提出意见。</p><h2 id="4771" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">小注意:计算图和单子</h2><p id="859a" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">上面讨论的一些问题传统上是由函数式编程语言中的单子解决的。因为我自己没有使用单子的经验，所以我选择让读者来决定图形编程和单子之间的关系，以后可能会再次讨论这一部分。</p></div></div>    
</body>
</html>