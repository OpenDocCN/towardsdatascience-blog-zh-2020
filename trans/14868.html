<html>
<head>
<title>Running a Data Replication Pipeline on Kubernetes with Argo and Singer.io</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Argo和Singer.io在Kubernetes上运行数据复制管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/running-a-data-replication-pipeline-on-kubernetes-with-argo-and-singer-io-2fab5b0bad?source=collection_archive---------21-----------------------#2020-10-13">https://towardsdatascience.com/running-a-data-replication-pipeline-on-kubernetes-with-argo-and-singer-io-2fab5b0bad?source=collection_archive---------21-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">近年来，数百个数据团队已经迁移到ELT模式，利用Stitch或FiveTran等SaaS工具将数据可靠地加载到他们的基础设施中。根据我的经验，这些SaaS产品非常出色，可以显著加快您的生产时间。然而，许多人没有预算，或者没有需要适应的定制应用程序，或者只是喜欢使用自己的工具。</p><p id="34a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这些情况下，一个解决方案是部署<code class="fe kl km kn ko b">singer.io</code>tap和targets——可以在任意源和目的地之间执行数据复制的Python脚本。Singer规范是流行的<a class="ae kp" href="http://www.stitchdata.com" rel="noopener ugc nofollow" target="_blank"> Stitch SaaS </a>的基础，它也被许多独立顾问和数据项目所利用。</p><p id="efd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Singer管道是高度模块化的。您可以通过管道将任何分支连接到任何目标，以构建符合您需求的数据管道。尽管这使得它们非常适合Docker化管道，但我发现很难找到通过Kubernetes或Docker部署Singer管道的例子。最终，我们利用Argo工作流和容器化的歌手抽头和目标建立了一个管道。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/a51bc833d2d36d7f3ce9bdd8705993d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZy-G84d2gtzwieQ4ZSuHw.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">没有Argo和Kubernetes的容器编排。图片来自<a class="ae kp" href="https://unsplash.com/photos/kyCNGGKCvyw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的<a class="lg lh ep" href="https://medium.com/u/a86c1db73ac?source=post_page-----2fab5b0bad--------------------------------" rel="noopener" target="_blank"> CHUTTERSNAP </a>。</p></figure><p id="03b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文从较高的层面介绍了工作流，并提供了一些示例代码来启动和运行一些共享模板。我假设你对<a class="ae kp" href="https://docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>、<a class="ae kp" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae kp" href="https://singer.io" rel="noopener ugc nofollow" target="_blank"> Singer </a>规范有些熟悉。即使你是这些技术的新手，我也会试着指出一些有用的资源，为你指明正确的方向。</p><h1 id="5f18" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">为什么要自己卷？</h1><p id="d9b4" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">ETL不是任何人进入数据科学或工程的原因。几乎没有创造力，大量的维护，直到出了问题才得到认可。幸运的是，像<a class="ae kp" href="http://www.stitchdata.com" rel="noopener ugc nofollow" target="_blank"> Stitch </a>和<a class="ae kp" href="http://www.fivetran.com" rel="noopener ugc nofollow" target="_blank"> FiveTran </a>这样的SaaS工具已经将数据复制变成了小团队可以利用的商品。</p><p id="4dd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据复制的“已解决”性质使数据科学家更容易拥有端到端的项目，从而使数据工程师能够考虑“平台”而不是单点解决方案。StitchFix在这方面有一个很棒的帖子。)这个市场的参与者认识到，真正与众不同的是“围绕”集成脚本的东西:例如，GitLab的<a class="ae kp" href="https://meltano.com" rel="noopener ugc nofollow" target="_blank"> Meltano </a>项目已经找到了一个合适的位置，成为<a class="ae kp" href="https://www.dataengineeringpodcast.com/meltano-data-integration-episode-141/" rel="noopener ugc nofollow" target="_blank">集成过程</a>的“跑步者”，而不是数据复制服务的逻辑。</p><h2 id="5ed0" class="ml lj iq bd lk mm mn dn lo mo mp dp ls jy mq mr lw kc ms mt ma kg mu mv me mw bi translated"><strong class="ak">歌手轻拍目标</strong></h2><p id="ba71" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">当不存在受支持的连接器时——比方说，对于内部应用程序——第三方服务不会为您做太多事情。这时候<a class="ae kp" href="https://singer.io" rel="noopener ugc nofollow" target="_blank"> Singer.io </a>规范就派上用场了。Singer管道有两个组成部分:</p><ul class=""><li id="3dae" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated"><strong class="jp ir"> tap </strong>连接到服务，提取数据，然后使用JSON发出标准化的模式和记录流</li><li id="dd3b" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated"><strong class="jp ir">目标</strong>读取tap的记录流并将其加载到仓库中</li></ul><p id="d9fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种tap和target的分离分离了“提取”步骤和“加载”步骤。因此，一个拥有10个数据源和1个数据仓库的组织需要管理10个从tap到target的管道。但是，如果他们迁移这个数据库，他们只需要“换出”目标；他们不会对任何水龙头做任何改动。</p><h2 id="a4ad" class="ml lj iq bd lk mm mn dn lo mo mp dp ls jy mq mr lw kc ms mt ma kg mu mv me mw bi translated"><strong class="ak"> Kubernetes和Argo工作流程</strong></h2><p id="8fbe" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">然而，如果没有编排层，这些管道一文不值。我们致力于在Kubernetes上运行管道，这使我们来到了Argo，一个用于编排并行“工作流”的开源引擎。它是其他编排工具(如Airflow或Prefect)的替代工具，一个关键的区别在于它对容器的固有关注。这个数据委员会的演讲提供了一个与Airflow的很好的比较，特别是:<a class="ae kp" href="https://www.datacouncil.ai/talks/kubernetes-native-workflow-orchestration-with-argo" rel="noopener ugc nofollow" target="_blank">Kubernetes——Argo的本地工作流编排</a>。</p><p id="babb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们对我们的解决方案非常满意，但它并不适合所有人。调试Kubernetes作业可能比在专用EC2实例上调试Python脚本更具挑战性。然而，这种方法的回报是三重的:</p><ol class=""><li id="c16e" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nl nd ne nf bi translated">部署的简易性和可移植性</li><li id="68fa" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">容器内脚本/环境的标准化</li><li id="3870" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">其他数据基础设施也可以很容易地进行容器化和部署</li></ol><p id="2adb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到这里，让我们试一试吧！</p><h1 id="471a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">教程</strong></h1><p id="8a3d" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">在本教程中，我们将首先使用Argo和MinIO存储为工件和配置文件设置一个本地Kubernetes集群，然后我们将部署一个Singer tap-to-target工作流。最后，我们将讨论增强和扩展。</p><p id="958e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以深入讨论这些领域中的任何一个，但是我会尽量让它变得浅显易懂，把对“生产”考虑的进一步讨论留到最后。本教程有以下先决条件:</p><ol class=""><li id="34d8" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nl nd ne nf bi translated">Docker桌面。安装在本地，并打开Kubernetes功能。(如果您有另一个集群，也应该没问题。)</li><li id="490a" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">掌舵。我们将安装Argo和MinIO来运行本教程。</li></ol><p id="ec6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将使用两个最简单的singer.io包——<code class="fe kl km kn ko b">tap-exchangeratesapi </code>和<code class="fe kl km kn ko b">target-csv</code>——来演示这是如何工作的。下面的图片会让你对我们的发展方向有所了解:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nm"><img src="../Images/440bc972f33cd6e8fb8b4649bca071c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXNKTbhaPGaPF2sWjSO6jQ.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">完整的工作流模板。图片作者。</p></figure><h2 id="e227" class="ml lj iq bd lk mm mn dn lo mo mp dp ls jy mq mr lw kc ms mt ma kg mu mv me mw bi translated"><strong class="ak">设置Kubernetes、Argo和MinIO </strong></h2><p id="acbd" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">在第一部分中，我们需要设置一个Kubernetes集群、Argo工作流、一个工件存储库和几个存储桶。最简单的方法是使用Docker for Desktop，它是多平台的，可以在其中部署一个Kubernetes集群。这也使本地开发变得更加容易，因为您可以构建容器并部署到本地集群，而无需推到外部容器存储库。</p><p id="a17c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安装Docker桌面并启用Kubernetes </strong></p><p id="5283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你需要有一个Kubernetes集群，你有管理权限，可以用<code class="fe kl km kn ko b">kubectl</code>部署资源。如果你已经有了，那么你可以跳过这一节。如果你没有，最简单的方法就是使用Docker for Desktop。你会想要遵循Docker网站上的文档。</p><ol class=""><li id="fdf8" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nl nd ne nf bi translated">为桌面安装Docker。[ <a class="ae kp" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> Mac </a></li><li id="66b9" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">启用Kubernetes。[ <a class="ae kp" href="https://docs.docker.com/docker-for-mac/kubernetes/" rel="noopener ugc nofollow" target="_blank"> Mac </a></li><li id="1f37" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">将Docker的资源分配提升到至少12 GB，以确保MinIO部署有足够的空间。(见附近图片。)</li><li id="6173" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">测试<code class="fe kl km kn ko b">kubectl</code>命令。[ <a class="ae kp" href="https://docs.docker.com/docker-for-mac/kubernetes/#use-the-kubectl-command" rel="noopener ugc nofollow" target="_blank"> Mac </a></li><li id="1252" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">安装最新的Argo CLI。[ <a class="ae kp" href="https://github.com/argoproj/argo/releases" rel="noopener ugc nofollow" target="_blank"> Mac </a></li></ol><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nn"><img src="../Images/bcab0953fc0c7061edfe3759c4029a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fIa2Set84d7NhpkSgSkxg.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">您可能需要增加默认资源来容纳MinIO。图片作者。</p></figure><p id="b4e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安装Argo工作流程</strong></p><p id="541d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要安装Argo，您可以遵循他们的[ <a class="ae kp" href="https://argoproj.github.io/argo/quick-start/" rel="noopener ugc nofollow" target="_blank">快速入门指南</a> ]，或者简单地使用下面的命令在您的集群中创建一个<code class="fe kl km kn ko b">argo</code>名称空间并部署“快速入门”资源。</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="9ee5" class="ml lj iq ko b gy ns nt l nu nv">kubectl create ns argo</span><span id="41c9" class="ml lj iq ko b gy nw nt l nu nv">kubectl apply \<br/>   -n argo    \<br/>   -f https://raw.githubusercontent.com/argoproj/argo/stable/manifests/quick-start-postgres.yaml</span></pre><p id="5e41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在应该有一个Argo服务器和一些Argo使用的新Kubernetes资源类型，包括“Workflow”和“CronWorkflow”。要查看Argo Workflows UI，您可以将Kubernetes端口转发到您的本地主机，并在浏览器中查看它。</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="775b" class="ml lj iq ko b gy ns nt l nu nv">kubectl -n argo port-forward deployment/argo-server 2746:2746</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nx"><img src="../Images/0a4f597832facc2d13a9890b5eb52fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2M5lVEl7AJzgJEm8Yo1BQ.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">Argo工作流为检查作业提供了一个有用的用户界面。图片作者。</p></figure><p id="78fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">设置MinIO存储器</strong></p><p id="13f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Argo工作流可以通过使用“工件”将文件传入或传出容器。对于本地部署，配置工件传递的一个简单方法是通过Kubernetes部署<a class="ae kp" href="https://min.io/" rel="noopener ugc nofollow" target="_blank"> MinIO </a>。Argo有很多关于如何与亚马逊S3等其他服务建立这种关系的指南，但是你可以跟随下面的内容快速部署MinIO。</p><p id="693f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，您需要安装<code class="fe kl km kn ko b">helm</code>(本质上是一个Kubernetes包管理器)。在Mac上，你可以使用Homebrew命令:<code class="fe kl km kn ko b">brew install helm</code>。然后，运行以下命令来添加MinIO helm图表:</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="86d0" class="ml lj iq ko b gy ns nt l nu nv">helm repo add minio <a class="ae kp" href="https://helm.min.io/" rel="noopener ugc nofollow" target="_blank">https://helm.min.io/</a></span><span id="3966" class="ml lj iq ko b gy nw nt l nu nv">helm repo update</span></pre><p id="efb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，您需要将MinIO部署到Argo名称空间中。这可能需要一两分钟，请耐心等待。</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="3e54" class="ml lj iq ko b gy ns nt l nu nv">helm install argo-artifacts minio/minio \<br/>    -n argo                             \<br/>    —-set service.type=LoadBalancer     \<br/>    --set defaultBucket.enabled=true    \<br/>    --set defaultBucket.name=artifacts  \<br/>    --set persistence.enabled=false     \<br/>    --set fullnameOverride=argo-artifacts</span></pre><p id="8c19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您现在应该有一个工件服务器在运行，但是它是空的！我们必须创建一个工件桶，以及一个用于singer配置和输出的桶。要使用下面的命令，您需要MinIO CLI工具，您可以使用:<code class="fe kl km kn ko b">brew install minio/stable/mc</code>安装该工具。</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="ea67" class="ml lj iq ko b gy ns nt l nu nv">mc config host add argo-artifacts-local <a class="ae kp" href="http://localhost:9000" rel="noopener ugc nofollow" target="_blank">http://localhost:9000</a> YOURACCESSKEY YOURSECRETKEY</span><span id="e206" class="ml lj iq ko b gy nw nt l nu nv">mc mb argo-artifacts-local/artifacts<br/>mc mb argo-artifacts-local/singer<br/>mc mb argo-artifacts-local/outputs</span></pre><p id="cfd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您喜欢通过UI创建bucket，那么您可以转到端口9000 — <code class="fe kl km kn ko b">kubectl -n argo port-forward service/argo-artifacts 9000:9000</code> —然后创建一个<code class="fe kl km kn ko b">artifacts</code>和<code class="fe kl km kn ko b">singer</code> bucket。(请注意，默认凭据是YOURACCESSKEY和YOURSECRETKEY。)</p><p id="0743" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">将Argo和MinIO一起映射</strong></p><p id="d36a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要告诉Argo默认的工件存储库在哪里，这样它就知道工件映射到哪个存储桶，并有适当的秘密进行认证。你可以遵循其他地方的说明<a class="ae kp" href="https://sourcegraph.com/github.com/argoproj/argo@095d67f8d0f1d309529c8a400cb16d0a0e2765b9/-/blob/demo.md#5-install-an-artifact-repository" rel="noopener ugc nofollow" target="_blank"/>但是为了简单起见，我建议将这个“补丁”应用到我整理的资源中。</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="7a51" class="ml lj iq ko b gy ns nt l nu nv">wget -o patch.yml <a class="ae kp" href="https://raw.githubusercontent.com/stkbailey/data-replication-on-kubernetes/master/argo/argo-artifact-patch.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/stkbailey/data-replication-on-kubernetes/master/argo/argo-artifact-patch.yml</a></span><span id="4415" class="ml lj iq ko b gy nw nt l nu nv">kubectl patch configmap workflow-controller-configmap \<br/>    -n argo \<br/>    --patch “$(cat patch.yml)”</span></pre><p id="b639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保第一部分中的所有内容都能正常工作，请尝试运行Argo示例库中的“工件传递”示例。</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="4e21" class="ml lj iq ko b gy ns nt l nu nv">argo submit -n argo <a class="ae kp" href="https://raw.githubusercontent.com/argoproj/argo/master/examples/artifact-passing.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/argoproj/argo/master/examples/artifact-passing.yaml</a> --watch</span></pre><h2 id="bc0d" class="ml lj iq bd lk mm mn dn lo mo mp dp ls jy mq mr lw kc ms mt ma kg mu mv me mw bi translated"><strong class="ak">蓉城工作流程</strong></h2><p id="609b" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">你已经得到了库贝内特斯，你已经得到了阿尔戈:让我们不要再等了！运行以下命令:</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="94cc" class="ml lj iq ko b gy ns nt l nu nv">argo submit \<br/>    -n argo \<br/>    --watch \<br/>    <a class="ae kp" href="https://raw.githubusercontent.com/stkbailey/data-replication-on-kubernetes/master/argo/tap-exchange-rate-workflow.yml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/stkbailey/data-replication-on-kubernetes/master/argo/tap-exchange-rate-workflow.yml</a></span></pre><p id="b2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会在终端中看到一个工作流启动。(或者，您可以转到该链接，复制文本并将其粘贴到Argo Workflows的“新工作流”UI中。)如果您收到类似于<code class="fe kl km kn ko b">failed to save outputs: timed out waiting for condition</code>的错误消息，请尝试再次运行该工作流程——可能是MinIO设置未完成。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ny"><img src="../Images/7f5f5f6895872dc1b3408df763307a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xiL7oeqY_e7Moxm98OTOiQ.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">寻找那些漂亮的绿色对勾。图片作者。</p></figure><p id="7ecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该看到一个两步工作流创建和完成。现在，检查“输出”存储桶，看看有什么可用。</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="89f9" class="ml lj iq ko b gy ns nt l nu nv">mc ls argo-artifacts-local/singer/outputs/tap-exchange-rates/</span></pre><p id="673c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在大多数Singer工作流中，管道的输出实际上是加载到数据库中的数据——但是在这里，我们将tap输出导出到一个文件中，该文件由目标压缩并输出到MinIO中。</p><p id="69ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">剖析工作流程</strong></p><p id="ca40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们从头开始，看看Argo工作流刚刚发生了什么。</p><ol class=""><li id="0dd3" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nl nd ne nf bi translated">它启动了一个<code class="fe kl km kn ko b">tap-to-target</code>多步骤工作流，由两个子步骤组成:<code class="fe kl km kn ko b">tap</code>和<code class="fe kl km kn ko b">target</code>步骤。</li><li id="9a4a" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">它启动了<code class="fe kl km kn ko b">tap</code>子步骤，并传入一些配置文件，这些文件被映射到<code class="fe kl km kn ko b">/tmp/config.json</code>。当tap步骤完成时，<code class="fe kl km kn ko b">/tmp/tap_output.txt</code>处的输出文件存储在默认的MinIO工件库中。</li><li id="6b55" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">然后启动<code class="fe kl km kn ko b">target</code>子步骤，将配置和tap输出映射到容器文件系统中。当目标运行时，输出(来自CSV目标)被映射到<code class="fe kl km kn ko b">outputs</code> MinIO桶。</li></ol><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nz"><img src="../Images/cfdd151e20a199984dd6ca4152f8ebde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BX_j3XMDVa_ZY8Dgv803oA.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">模板逻辑。虽然“target-csv”目标会输出一个表，但大多数目标会将数据加载到数据库中。图片作者。</p></figure><p id="534d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会深入到<a class="ae kp" href="https://raw.githubusercontent.com/stkbailey/data-replication-on-kubernetes/master/argo/tap-exchange-rate-workflow.yml" rel="noopener ugc nofollow" target="_blank">工作流文件本身</a>，因为Argo上有很多很棒的文档。关于数据复制，有趣的是，这个过程是高度标准化的——无论您的tap或目标是什么，您基本上都是交换配置文件或容器地址。</p><p id="a1ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">码头歌手</strong></p><p id="bff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Argo级别模板化工作流也需要在容器级别模板化Singer taps。让我们暂时把Kubernetes放在一边，专注于一个典型的歌手管道。这是一个线性过程:</p><ol class=""><li id="0512" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nl nd ne nf bi translated">点击输入:点击配置文件、目录文件、状态文件</li><li id="40d5" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">点击输出:提取数据的文本输出(Singer格式)</li><li id="b539" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">目标输入:目标配置文件，tap的文本输出</li><li id="8c72" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">目标输出:加载或导出的数据(例如，到数据库或CSV文件)和一个“状态”文件，其中包含有关上次提取的元数据</li></ol><p id="dc21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将容器本身视为黑盒，只要我们知道如何输入适当的输入和输出。为了使本教程简单，我预先创建了<code class="fe kl km kn ko b">tap</code>和<code class="fe kl km kn ko b">target</code>容器供我们使用。要进行测试，请运行以下命令:</p><pre class="kr ks kt ku gt no ko np nq aw nr bi"><span id="c7e7" class="ml lj iq ko b gy ns nt l nu nv">docker run -e START_DATE=2020-08-01 stkbailey/tap-exchange-rates</span></pre><p id="4fc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不涉及太多细节，我们将singer <code class="fe kl km kn ko b">tap-abc</code>或<code class="fe kl km kn ko b">target-xyz</code>命令封装在一个Runner对象中，该对象定义了在哪里查找必要的文件。(它可以在Github的<a class="ae kp" href="https://github.com/immuta/singer-container-utils" rel="noopener ugc nofollow" target="_blank"> singer-container-utils </a>获得。)剥那只猫皮的方法有很多种，但重要的是要让它在多次轻拍中容易重现。</p><p id="7b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不会深究细节，但是每个Docker容器在初始化时都在运行一个Python <code class="fe kl km kn ko b">entrypoint.py</code>脚本。入口点脚本的要点是:</p><ol class=""><li id="515b" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nl nd ne nf bi translated">确定适当的输入文件所在的路径。</li><li id="7b74" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">基于文件可用性构建可执行命令。</li><li id="6aa5" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nl nd ne nf bi translated">运行命令并将输出写入文件。</li></ol><p id="3531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它<em class="oa">比直接运行tap的开销更大，但是当你有多个容器要运行时，这种抽象会让生活变得更容易。</em></p><p id="264e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">模板化工作流程</strong></p><p id="c25d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之:这种方法有价值的原因是因为您可以轻松地将“工作流”模板化，这样任何可以输出Singer格式数据的容器都可以替换为一行模板代码(以及一个配置文件)，这样您就有了一个新的工作流。</p><p id="5e19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望不难看出，通过一些额外的调整和一些保护良好的S3桶，这可以变成一个相当健壮的架构。一旦设置完成，您只需更改图像位置来添加新的tap容器。有一个很好的UI来检查日志和重新启动作业，并且很容易用Slack通知和附加作业来扩展模板。</p><p id="1447" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在附带的<a class="ae kp" href="https://github.com/stkbailey/data-replication-on-kubernetes" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中创建了几个例子，包括带有<code class="fe kl km kn ko b">tap-covid-19</code> Singer tap的例子、<code class="fe kl km kn ko b">WorkflowTemplate</code>例子和可以每小时或每天运行的<code class="fe kl km kn ko b">CronWorkflow</code>规范。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ob"><img src="../Images/ba8bccf7270a05efd99dca1dc5a4acee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIeqtN3cerj2WEDr7zaXGA.png"/></div></div><p class="lc ld gj gh gi le lf bd b be z dk translated">只需对模板进行最少的编辑，即可同时运行多个拍子和目标。图片作者。</p></figure><h1 id="ba6d" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">讨论</strong></h1><p id="9981" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">尽管建立这种架构对我来说很愉快，但它需要对基础设施、容器和Singer规范本身非常熟悉。你可能会发现<a class="ae kp" href="https://transferwise.github.io/pipelinewise/#:~:text=PipelineWise%20is%20a%20collection%20of,environment%20without%20the%20extra%20hassle." rel="noopener ugc nofollow" target="_blank"> Pipelinewise </a>或<a class="ae kp" href="https://meltano.com/" rel="noopener ugc nofollow" target="_blank"> Meltano </a>可以用更少的开销和更多的附加功能为你做同样的工作。或者，您可能会发现您可以利用Argo和这些工具来管理数据复制。</p><p id="7668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名数据科学家，有很多考虑因素。这些问题包括:</p><ul class=""><li id="9902" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">我是否有足够的预算来支付这笔费用(Stitch / Fivetran)？这些工具能满足我所有的数据复制需求吗？</li><li id="1826" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">更简单的(单节点)架构是否可行，比如Meltano？我有其他需要管弦乐队的工作吗？</li><li id="64a9" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">Kubernetes架构是否适合公司基础设施的其他部分？</li><li id="ee45" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">为什么不用气流或者提督？</li><li id="063d" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">我是否拥有(或可以借用)设置和管理Kubernetes集群的基础设施专业知识？</li></ul><p id="85dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的团队选择构建这种架构是因为:</p><ul class=""><li id="b896" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">我们(还)没有企业服务的预算，但发现我们需要运行定制的tap。</li><li id="603f" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">我们已经习惯了容器化的应用程序。</li><li id="3d64" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">我们公司基础设施的其余部分在Kubernetes上运行，并利用其他Argo产品，使协作更加容易。</li><li id="2b13" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">我们有其他项目，如数据质量工作，我们需要一个平台来运行，我们以前没有与气流或完美的专业知识。</li></ul><p id="4c06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。乐于在<a class="ae kp" href="https://www.linkedin.com/in/stkbailey/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae kp" href="https://singer-slackin.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">歌手Slack频道</a>与他人联系。</p><h1 id="eada" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">其他资源</strong></h1><ul class=""><li id="a712" class="mx my iq jp b jq mg ju mh jy oc kc od kg oe kk nc nd ne nf bi translated">歌手入门[ <a class="ae kp" href="https://github.com/singer-io/getting-started" rel="noopener ugc nofollow" target="_blank">博客</a></li><li id="e17c" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">打造歌手Tap —信息图[ <a class="ae kp" href="https://www.stitchdata.com/blog/how-to-build-a-singer-tap-infographic/" rel="noopener ugc nofollow" target="_blank">博客</a> ]</li><li id="8c67" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">记录歌手抽头的参考脚本[ <a class="ae kp" href="https://github.com/immuta/singer-container-utils" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li></ul></div></div>    
</body>
</html>