<html>
<head>
<title>Python tips for someone transiting from Excel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Excel过渡到Python的技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tips-for-someone-transiting-from-excel-ce16c5f9cbac?source=collection_archive---------40-----------------------#2020-10-20">https://towardsdatascience.com/python-tips-for-someone-transiting-from-excel-ce16c5f9cbac?source=collection_archive---------40-----------------------#2020-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="25b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于提高生产率的最佳做法的讨论</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/188e54a69d2943052f459671005b40e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTwZq7ceSHClNuAconBNig.jpeg"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">米卡·鲍梅斯特在<a class="ae lb" href="https://unsplash.com/s/photos/excel-automation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Excel是最常用的数据分析应用程序之一。然而，由于其明显的局限性(即性能、行和列的限制)，它可能不足以应付现代的需求。Python狂热者经常推荐使用pandas库作为Excel的替代品来自动化/加速数据分析。然而，如果不熟悉这个库和一些最佳实践，它不一定能节省时间。本文旨在强调使用Excel进行数据分析的一些挑战，以及使用python(和pandas库，以及一些附加库)和采用最佳实践如何有助于提高整体效率。假设有一些python和熊猫的基础知识。</p><p id="f1b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">典型的数据分析师可能夹在业务职能部门和应用程序所有者之间。这种职责分离的结果是，可能没有一个人会理解数据的所有用例。热心的数据分析师有责任对数据进行切片和切块，形成基于输入的假设，并寻找反例来反驳假设。这种递归过程需要数据分析师手动重复过滤、排序、分组、连接、透视、vlookup、拆分Excel上的数据。这些步骤可能会导致人工错误，特别是当操作没有<a class="ae lb" href="https://en.wikipedia.org/wiki/Commutative_property" rel="noopener ugc nofollow" target="_blank">往返</a>时(即结果取决于操作的顺序)。解决这个问题的关键是从根本上改变方法:<strong class="jp ir">不要机械地操纵数据来准备输出，而应该进行战略性的思考，并准备一个生成输出的程序/脚本。对我来说，这是使用python的最大动机，因为重复一系列动作的纯手工和令人麻木的任务不适合我，基于Excel的宏太慢了。</strong></p><p id="4dbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文档/文章涵盖了一些有用的想法，通过使用python，特别是pandas库，人们也许可以利用这些想法来节省一些时间并潜在地避免重复工作。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="7576" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">一些警告</h2><p id="1708" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">在以下情况下，使用pandas几乎没有什么价值:<br/> (a)数据量相当小(少于50000行)，<br/> (b)涉及的文件非常少(少于10个)，<br/> (c)为将来使用而准备的输出数据不太可能频繁重复或手动重复。</p><p id="9baa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这些情况下，Excel将是首选工具，这取决于您对python和pandas的熟悉程度。</p><p id="22a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Python和pandas的图形用户界面非常有限，因此大多数人可能会发现，与Excel相比，它的使用不够直观。例如，重新排序列和查找值是否存在这样的琐碎操作在Excel中是微不足道的，但是这些操作需要python上的几行代码，并且对于第一次接触python和pandas的初学者来说不那么直观。</p><h2 id="159a" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">在ide上，文本编辑器…</h2><p id="d562" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">虽然有一些不错的工具(PyCharm和Jupyter笔记本)可用，但是在我参与的项目中，这些工具是不可用的或者不可行的(工具是可用的，但是没有足够的RAM来使用它)。因此，我经常只使用命令提示符或Powershell来运行代码。任何带语法高亮的文本编辑器都可以，我用的是Notepad++。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="355c" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">1.一次读文件，泡菜，以后读泡菜。</h2><p id="af9f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">虽然这听起来微不足道，但数据分析师的首要任务是打开并读取数据文件。pandas将Excel文件作为数据帧读取所花费的时间比Excel打开相同的Excel文件所花费的时间要长。当文件很大(尤其是Excel文件)时，将数据文件作为数据帧读取可能需要几分钟时间。如果每次执行脚本时都需要读取数据集，那么执行和编辑脚本的重复过程将大大降低效率。克服瓶颈的方法是读取数据并将其作为pickle写入(即<code class="fe mh mi mj mk b">.pkl</code>)。读泡菜快100倍左右。通过获取数据样本(例如大约10，000行)并将其作为pickle写入，可以进一步提高效率。还应注意，读取平面文件(<code class="fe mh mi mj mk b">.csv</code>和带分隔符的文本文件)比读取excel文件快得多，因此，如果可能，应检索/请求此类平面文件格式的文件，假设这些数据文件不打算由用户在Excel中打开。</p><h2 id="5c0c" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">2.规划好功能和代码结构</h2><p id="db6b" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">每个开发人员在开始一个全新的项目时都会说:“这一次，我会把事情做好。”。</p><p id="d006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每个项目的开始，自然倾向于编写硬编码脚本来快速生成必要的报告。在这个阶段，可能会有一个单独的<code class="fe mh mi mj mk b">.py</code>文件，它有一个巨大的功能，可以创建一个单独的报告。抵制匆忙生成输出报告的冲动，因为长函数很难维护，而且技术债务积累得非常快。</p><p id="b24c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为可读性很重要，所以每个函数在逻辑上应该代表一个预期的操作。下面的示例显示了读取、清理、修改数据以及将两列相乘以在另一列中给出结果的推荐方法。</p><p id="2f47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例1.1(推荐):</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="1844" class="lj lk iq mk b gy mq mr l ms mt">def read_trade_data():<br/>   return pd.read_excel('data.xlsx')</span><span id="bf68" class="lj lk iq mk b gy mu mr l ms mt">def clean_trade_data(df):<br/>    # PRICE turns out to be text with comma as decimals point.<br/>    df['PRICE'] = df['PRICE'].str.replace({",", "."})<br/>                             .astype('float64')<br/>    return df</span><span id="db37" class="lj lk iq mk b gy mu mr l ms mt">def add_col_total(df):<br/>    df['TOTAL'] = df['QTY']*df['PRICE']<br/>    return df</span><span id="a4af" class="lj lk iq mk b gy mu mr l ms mt">def df_output():<br/>    df = read_trade_data()<br/>    df1 = clean_trade_data(df)<br/>    df2 = add_col_total(df1)<br/>    return df2</span></pre><p id="3167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例1.2</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="4ab4" class="lj lk iq mk b gy mq mr l ms mt">def df_output():<br/>    df = pd.read_excel('data.xlsx')<br/>    df['PRICE'] = df['PRICE'].str.replace({",","."})<br/>                             .astype('float64')<br/>    df['TOTAL'] = df['QTY']*df['PRICE']<br/>    return df</span></pre><p id="b389" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然示例1.1看起来更冗长，但有几个好处。由于这种分离，<code class="fe mh mi mj mk b">df_output</code>在1.1中可读性更好，因为在读取修改数据的代码之前，不必通读所有代码来清理数据。此外，如果期望其他数据帧具有类似的十进制格式，可以重用1.1中的<code class="fe mh mi mj mk b">clean_trade_data</code>函数。另一方面，在1.2中，人们可能会求助于复制和粘贴代码。此外，如果在<code class="fe mh mi mj mk b">df_output</code>上发生错误，在python shell中调试1.1的小函数会更容易。</p><p id="8644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应使用可选参数和关键字参数为数据分析师提供灵活性；应该避免执行类似操作的小函数。</p><p id="0514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果预期只有一个版本的<code class="fe mh mi mj mk b">data.xlsx</code>，这就足够了:</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="de3f" class="lj lk iq mk b gy mq mr l ms mt">def read_trade_data():<br/>    return pd.read_excel('data.xlsx')</span></pre><p id="2a09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果有多个版本的<code class="fe mh mi mj mk b">data.xlsx</code>可能需要单独分析，那么编写一个函数来从命令行快速读取这些文件而不是重新编译代码是有意义的。</p><p id="a5d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例2.1(反例):</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="7d68" class="lj lk iq mk b gy mq mr l ms mt">def read_trade_data1():<br/>    return pd.read_excel('data1.xlsx')</span></pre><p id="3f3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将会有许多这样的函数，每个映射到不同的文件(例如<code class="fe mh mi mj mk b">data2.xlsx</code>、<code class="fe mh mi mj mk b">data3.xlsx</code>、…)，随着时间的推移，它会变得非常混乱。</p><p id="2b1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例2.2(推荐):</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="245b" class="lj lk iq mk b gy mq mr l ms mt">def read_trade_data(file=None):<br/>    d_file = {1: 'data.xlsx',<br/>              2: 'data1.xlsx'}<br/>    file = file if file else d_file[max(d_files.keys())]<br/>    return pd.read_excel(file)</span></pre><p id="d7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例2.2有几个优点:<br/> (a)所有文件都在同一个字典里(可读性很重要！)，<br/> (b)如果没有任何东西作为文件参数传递，它读取最新的<code class="fe mh mi mj mk b">dataN.xlsx</code>，<br/> (c)如果文件没有被添加到<code class="fe mh mi mj mk b">files</code>字典，它允许用户显式地传递文件的路径。</p><p id="ec55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多编码教程都包含类似于示例2.1的代码，因为教程的上下文可能不支持使用推荐的最佳实践。</p><p id="363d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些功能中的一些可以被做得足够通用，以至于它可以被应用于其他项目。例如，输出数据摘要(即每列唯一值的数量)并打印一小份数据样本通常非常有用。这样的函数应该作为dataframe类的方法编写(这样它就可以作为方法df.summarize()而不是mymodule.summarize(df)被调用)。此外，如果这样的函数一般适用于任何数据集，那么应该将它重构到一个单独的python文件中，并导入到主项目文件的名称空间中。</p><p id="b6ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我的工具箱中的一个函数(<code class="fe mh mi mj mk b">pypo.py</code>)。</p><p id="2846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时在Excel中查看和执行分析会更快。但是导航到文件然后双击它会很麻烦。该功能通过在Excel文件被写入后打开该文件来升级<code class="fe mh mi mj mk b">to_excel()</code>方法。</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="d882" class="lj lk iq mk b gy mq mr l ms mt">#pypo.py</span><span id="85d9" class="lj lk iq mk b gy mu mr l ms mt">from pandas.core.base import PandasObject</span><span id="b859" class="lj lk iq mk b gy mu mr l ms mt">def to_excelp(df, *arg, **kw):<br/>    <br/>    def xlopen(path):<br/>        import win32com.client as w32<br/>        from pywintypes import com_error<br/>        import os</span><span id="aef5" class="lj lk iq mk b gy mu mr l ms mt">        #Opens the file (.csv, .xls, .xlsx) in Excel<br/>        xl = w32.Dispatch('Excel.Application')</span><span id="a311" class="lj lk iq mk b gy mu mr l ms mt">        try:<br/>            wb = xl.Workbooks.Open(path)<br/>        except com_error:<br/>            print('Check if file exists in current working directory…', end='')<br/>            if path in os.listdir():<br/>                print('found!')<br/>                path = '{}\{}'.format(os.getcwd(), path)<br/>                wb = xl.Workbooks.Open(path)<br/>            else:<br/>                print('not found! Please check file path!')<br/>        else:<br/>            pass<br/>        finally:<br/>            xl.Visible = True<br/>        return path, xl, wb<br/><br/>    df.to_excel(*arg, **kw)<br/>    path, xl, wb = xlopen(arg[0])<br/>    return path, xl, wb</span><span id="72d6" class="lj lk iq mk b gy mu mr l ms mt">PandasObject.to_excelp = to_excelp</span></pre><p id="d3f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将它添加到主工作文件的名称空间中:</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="9c81" class="lj lk iq mk b gy mq mr l ms mt">#main.py</span><span id="060b" class="lj lk iq mk b gy mu mr l ms mt">sys.path.insert(1, 'C:/Documents/pyprojects/pypo.py')<br/>import pypo</span></pre><p id="ee6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在命令行界面中编写脚本时，可以简单地键入<code class="fe mh mi mj mk b">df.to_excelp('test.xlsx')</code>来将数据帧写成Excel文件，该文件将在编写后打开。该函数还返回Excel应用程序<code class="fe mh mi mj mk b">xl</code>和工作簿<code class="fe mh mi mj mk b">wb</code>对象，可以在以后使用(也许是为了在MsExcel中自动格式化和创建表格？).</p><p id="4694" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">评估器可用于扩展python，虽然这些可以简化<code class="fe mh mi mj mk b">pypo.py</code>中的代码，但会导致主文件中的语法稍微冗长一些(例如<code class="fe mh mi mj mk b">df.myfunc.to_excel()</code>)。回想一下“平的比嵌套的好”。</p><h2 id="e63f" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">3.过滤和选择数据</h2><p id="d6c5" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">直观的方法是编写在过滤和/或选择相关行或列后返回数据帧的函数。然而，追加或连接这些数据帧是缓慢的。目前发现的最佳实践是编写返回布尔掩码的函数。组合其他掩码可以使用二进制操作完成，获得行数将成为simpler⁴，尽管不太直观。</p><p id="b0bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例3.1:返回数据帧</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="e2e0" class="lj lk iq mk b gy mq mr l ms mt"># Returns a dataframe<br/>def apples(df):<br/>    return df[df['Fruits']=='Apples']</span><span id="b713" class="lj lk iq mk b gy mu mr l ms mt">df_apples = apples(df)</span></pre><p id="3266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不需要进一步的转换(如合并、排序、过滤)，直观的方法会更快。</p><p id="1918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例3.2:返回布尔掩码</p><pre class="km kn ko kp gt mm mk mn mo aw mp bi"><span id="dbca" class="lj lk iq mk b gy mq mr l ms mt">def select_apples(df)<br/>    return df['Fruits']=='Apples'</span><span id="b584" class="lj lk iq mk b gy mu mr l ms mt">mask_apples = select_apples(df)</span></pre><p id="7751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取苹果的行数:<code class="fe mh mi mj mk b">sum(mask_apples)</code> <br/>获取包含苹果的数据帧:<code class="fe mh mi mj mk b">df[mask_apples]</code></p><p id="bc1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法避免了数据帧的设置成本，直到它真正需要时。使用布尔掩码的操作比数据帧上的操作快得多。</p><h2 id="ef0c" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">4.使最佳化</h2><p id="fe30" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">尽可能避免在数据帧的行或列中显式循环；这就是熊猫的全部意义。在大多数情况下，<code class="fe mh mi mj mk b">np.where</code>、<code class="fe mh mi mj mk b">np.select</code>、<code class="fe mh mi mj mk b">np.cut</code>、<code class="fe mh mi mj mk b">np.vectorize</code>和<code class="fe mh mi mj mk b">df.apply</code>应该可以做到。其中一些方法本质上仍然是循环，但通常比显式循环快。</p><h2 id="4af7" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">5.避免在Excel中使用vlookups，而是合并表格</h2><p id="6561" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">Excel的<em class="ml"> vlookup </em>函数从来不是用来合并两个表格的。Quoting <a class="ae lb" href="https://docs.microsoft.com/en-us/office/vba/api/excel.worksheetfunction.vlookup" rel="noopener ugc nofollow" target="_blank"> docs.microsoft </a>，<em class="ml"> vlookup </em>“在<strong class="jp ir">第一列</strong>中搜索<strong class="jp ir">值</strong>，并从表数组中的另一列返回同一行中的值”。当表数组的第一列包含多个查找值时，将使用找到的第一个值的行号。与查找值匹配的后续值将被忽略。因此，使用<code class="fe mh mi mj mk b">pandas.merge</code>来代替，并处理重复条目(如果有的话)。如果首选<em class="ml"> vlookup </em>，确保查找值是唯一的。</p><p id="43d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vlookup看表的右边；“向左看”需要结合使用<em class="ml"> choose() </em>和数组公式，如果不熟悉数组公式的行为，这很容易出错。有些人可能会通过插入一个辅助(重复)列来避免“向左看”,这会引入某种形式的冗余。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="06d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ml">这篇文章的动机是整合作者在各种项目中的学习，以便读者在工作中处理大量数据时不必经历类似的痛苦。在撰写本文时，互联网上有大量关于数据科学、大数据等方面的信息。然而，在实现用于数据分析的开源框架时，几乎没有关于最佳项目实践的指导。</em></p><p id="866b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]在某种程度上，这不是一个公平的比较，因为Excel文件被设计为在MsExcel中打开，pandas在幕后做了很多神奇的事情，将数据准备为dataframe。</p><p id="97a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]从12个excel文件中读取1张需要30分钟。总共170万行。读取泡菜当量需要15秒。</p><p id="3b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3]如果你对此一笑置之，是因为你理解或看到了这样的恐怖，那很好。如果你想知道这有什么问题，请继续阅读。</p><p id="36dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[4] <code class="fe mh mi mj mk b">sum(mask)</code>，因为<code class="fe mh mi mj mk b">True</code>值在python中被求值为1。</p></div></div>    
</body>
</html>