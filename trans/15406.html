<html>
<head>
<title>Visualizing regularization and the L1 and L2 norms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化正则化与L1和L2规范</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualizing-regularization-and-the-l1-and-l2-norms-d962aa769932?source=collection_archive---------13-----------------------#2020-10-23">https://towardsdatascience.com/visualizing-regularization-and-the-l1-and-l2-norms-d962aa769932?source=collection_archive---------13-----------------------#2020-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么最小化规范会导致正则化？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2df8b3790698ff03dc4005ee9b1d4337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bM2txQ6caL4AKiN19oH5bQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2a8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你上过机器学习的入门课，你肯定遇到过过度拟合的问题，并了解过正则化和规范的概念。我经常看到纯粹通过查看公式来讨论这个问题，所以我想我会尝试使用一些直观的例子来更好地了解为什么最小化范数会导致正则化，以及L1和L2之间的差异。</p><h2 id="453b" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">必备知识</h2><ul class=""><li id="369e" class="mn mo it la b lb mp le mq lh mr ll ms lp mt lt mu mv mw mx bi translated">线性回归</li><li id="1a50" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">梯度下降</li><li id="9200" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">对过拟合和正则化的一些理解</li></ul><h2 id="c709" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">涵盖的主题</h2><ul class=""><li id="449a" class="mn mo it la b lb mp le mq lh mr ll ms lp mt lt mu mv mw mx bi translated">为什么最小化范数会诱导正则化？</li><li id="fd81" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">L1标准和L2标准有什么区别？</li></ul><h1 id="6251" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated">正规化概述</h1><p id="e84a" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">使用线性回归的例子，我们的损失由均方误差(MSE)给出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/9f377f8b6bd66b8ccb131db9c52caadd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHgubqifadr4wLLR75MJTA.png"/></div></div></figure><p id="365e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的目标是尽量减少这种损失:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/6d494d4370003b0a09319b6228a6e400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSrJTpuAM03GH43AtFvOdw.png"/></div></div></figure><p id="9065" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了防止过度拟合，我们想要添加一个<strong class="la iu"> </strong>偏向不太复杂的函数。<strong class="la iu"> </strong>也就是<strong class="la iu">给定两个可以合理拟合我们数据的函数，我们更喜欢简单的一个</strong>。为此，我们添加了一个正则项，通常是L1范数或平方L2范数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/5f503a37a465c207dcc81e72005abd1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eA2X4W3l1dYsYLEJw_eehQ.png"/></div></div></figure><p id="0365" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，例如，通过将平方L2范数添加到损失和最小化，我们获得岭回归:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a81073884bef1a81067a8f1fb1136a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbOdQP-6DhucNAVlRhPoTw.png"/></div></div></figure><p id="1971" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中λ是正则化系数，它决定了我们需要多少正则化。</p><h1 id="d8e0" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated">为什么最小化范数会诱导正则化？</h1><p id="77f5" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated"><strong class="la iu">最小化范数有助于降低函数的“复杂性”。</strong>从数学上讲，我们可以看到L1和L2范数都是权重大小的度量:L1范数的绝对值之和，L2范数的平方值之和。所以更大的权重给出了更大的范数。这意味着，简单地说，<strong class="la iu">最小化范数鼓励权重变小，这反过来给出了“更简单”的函数</strong>。</p><p id="d1d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个例子来形象化这一点。让我们假设我们得到一些类似这样的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/c45ddf63a95f64c25321732d8462f436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-fsK9RkqL3rogo2SnZPCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="dad7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该选择什么函数来拟合这些数据呢？有许多选择，这里有三个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/c70b554ceae2063d4c803df882a223b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88nMp1kB4MtxcebBh1XRaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b958" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们有一个2次多项式拟合和两个不同的8次多项式，由以下等式给出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/0a3e23dba0543894082feb8a86f8204c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UolRlKXikCz7SFsPfSZrYQ.png"/></div></div></figure><p id="f052" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前两个(是“更简单”的函数)最有可能更好地概括新数据，而第三个(更复杂的函数)显然过度拟合了训练数据。这种复杂性是如何体现在规范中的？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/839d4f5b1cf1b290b850362507233fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVFYChNDMNlS_7CVq2PhSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="add5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，线[c]的均方误差为0，但其范数相当高。相反，线[a]和[b]具有稍高的MSE，但是它们的规范低得多:</p><ul class=""><li id="f0d4" class="mn mo it la b lb lc le lf lh nx ll ny lp nz lt mu mv mw mx bi translated">线[a]具有较低的范数，因为与[c]相比，它具有明显较少的参数</li><li id="f284" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">线[b]具有较低的范数，因为尽管有相同数量的参数，它们都比[c]小得多</li></ul><p id="747a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由此我们可以得出结论，通过将L1或L2范数添加到我们的最小化目标，我们可以鼓励具有较低权重的更简单的函数，这将具有正则化效果，并帮助我们的模型更好地推广新数据。</p><h1 id="67f2" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated">L1标准和L2标准有什么区别？</h1><p id="9748" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">我们已经看到，为了降低函数的复杂性，我们可以完全去掉一些权重(将它们设置为零)，或者使所有权重尽可能小，这就是L1和L2之间的区别。</p><p id="f9e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解它们如何不同地操作，让我们看一看它们如何根据权重的值而变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/3ae1d82508fc1c5d8cd23e975a045b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*etUdoAT3P51qjMiadDRHhQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0011" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">左边是给定重量w的L1和L2范数图，右边是相应的范数斜率图。正如我们所看到的，L1和L2都随着w值的增加而增加。然而，当L1范数以恒定速率增加时，L2范数以指数形式增加。</p><p id="7036" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很重要，因为正如我们所知，当进行梯度下降时，我们将基于损失函数的导数来更新我们的权重。因此，如果我们在损失函数中包含一个范数，范数的<strong class="la iu">导数将决定权重如何更新</strong>。</p><p id="8653" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，<strong class="la iu"> L2范数</strong>随着w变小，范数的斜率也变小，这意味着更新也将变得越来越小。当权重接近0时，更新会变得非常小，几乎可以忽略不计，所以权重不太可能变成0。</p><p id="559b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，用<strong class="la iu"> L1范数</strong>斜率是常数。这意味着随着w变小，更新不会改变，所以我们会因为权重变小而得到相同的“奖励”。因此，L1规范更有可能将一些权重降低到0。</p><h2 id="c3eb" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">概括一下:</h2><ul class=""><li id="966c" class="mn mo it la b lb mp le mq lh mr ll ms lp mt lt mu mv mw mx bi translated"><strong class="la iu"> L1范数将一些权重驱动到0 </strong>，导致权重稀疏。这对于<strong class="la iu">内存效率</strong>或者当需要<strong class="la iu">特征选择</strong>时是有益的(即我们只想选择某些权重)。</li><li id="fe3f" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">相反，<strong class="la iu"> L2规范</strong>将<strong class="la iu">减少所有权重，但不会一直减少到0 </strong>。这不太节省内存，但如果我们想要/需要保留所有参数，这可能是有用的。</li></ul></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="c899" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oi">觉得这个故事有帮助？考虑</em> <a class="ae oj" href="https://chiaracampagnola.medium.com/membership" rel="noopener"> <em class="oi">订阅</em> </a> <em class="oi">到媒体支持作家！</em></p></div></div>    
</body>
</html>