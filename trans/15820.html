<html>
<head>
<title>Gotcha! global variable with recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抓住你了。递归全局变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/gotcha-when-using-global-variable-with-recursion-ea92e16a8799?source=collection_archive---------12-----------------------#2020-10-31">https://towardsdatascience.com/gotcha-when-using-global-variable-with-recursion-ea92e16a8799?source=collection_archive---------12-----------------------#2020-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a8a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">注意参数顺序和返回值</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d28146891cd8feb67be9ef2b3f0ec8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LziskmFlw685Qdii"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安德里亚·费拉里奥在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="db0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用回溯法解决了这个leetcode问题<a class="ae ky" href="https://leetcode.com/contest/weekly-contest-212/problems/path-with-minimum-effort/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/contest/weekly-contest-212/problems/path-with-minimum-effort/</a>，花了一些时间调试奇怪的输出。本文讨论了对全局变量使用递归时的一些陷阱，如何处理它们，以及如何将代码从全局改为局部。</p><p id="8ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">免责声明:回溯只通过15/75的测试用例，其余的超过了时间限制，本文的目的是强调全局变量的可能问题，而不是给出最佳解决方案。更多使用二分搜索法、迪克斯特拉和克鲁斯卡尔的美丽解决方案，请观看亚历克斯在https://www.youtube.com/watch?v=AM__3Zx1XNw的演练(从7:26开始)</p><h1 id="5c56" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/0c8c7185816e4b0ab85c94a50ac86ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HmR6X0juiGCsEPxfSOeCQ.jpeg"/></div></div></figure><p id="b7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是从左上走到右下，每走一步允许上、下、左、右四个方向，然后用最小的努力找到路径。<code class="fe mo mp mq mr b">effort</code>定义为任意两个连续方块之间数值的最大绝对差值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8c1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包含具有<strong class="lb iu">全局</strong>与<strong class="lb iu">非全局</strong>变量的实现的笔记本:<a class="ae ky" href="https://gist.github.com/gitgithan/a818d336c2309852a21d99efd619238d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/git Han/a 818d 336 c 2309852 a 21d 99 EFD 619238d</a></p><h1 id="8343" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">回溯概述</h1><p id="2ef0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我的回溯解决方案是使用一个<code class="fe mo mp mq mr b">visited</code> 2D数组来跟踪访问。<br/>从左上角的单元开始，如果在矩形边界内并且之前没有被访问过，我们尝试以向下、向右、向上、向左的顺序移动(该顺序比其他一些顺序更快地到达目的地，因此全局最小值可以更早地被更新，并且用于限制/加速未来路径的探索)。在移动(递归)之前，访问被标记，因此对于<code class="fe mo mp mq mr b">if valid()</code>，将来的访问尝试将返回False。</p><p id="415b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此过程中，使用我们要访问的单元和当前单元之间的abs差来更新路径的努力(初始化为0)。如果我们到达基本情况(右下角的单元格)，返回努力。</p><p id="e196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦一个方向的递归完成，我们就更新全局最小值<code class="fe mo mp mq mr b">min_effort</code>(初始化为<code class="fe mo mp mq mr b">math.inf</code>)并取消该方向的单元格标记。</p><p id="f416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦当前单元格的所有4个方向都完成，我们返回<code class="fe mo mp mq mr b">math.inf</code>备份调用堆栈，这样它就不会错误地影响调用者的min()。</p><h1 id="359a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">病菌</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/f9a152b211ae7b4ed1ad1ad81b6e3aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*CaKSRxLCt2iW6j8LMyLzzw.png"/></div></figure><p id="7bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个5 ^ 2，后面跟着2个inf的输出令人难以置信。看起来像是全局变量<code class="fe mo mp mq mr b">min_effort</code>在第一个解(1，下到3，下到5，右到3，右到5)回到inf后从inf更新到2！最终答案(路径1，2，3，4，5)也被错误地推断，而不是1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/7be15433a8d530354d81acb839ab59a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*t6YjQHIUlEW8IrFl0VxdkQ.png"/></div></figure><p id="5870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这五个2对应于从目的地5回溯到4，3，2，8，3，5的算法，因为所有这些都具有所有4个已访问或出界的方向，所以下一个要尝试的路径是从1，0向右到1，1 (3到8)。</p><h1 id="6ae0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">全局变量如何回到未更新的状态？</h1><p id="2df5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">问题出在第<code class="fe mo mp mq mr b">min_effort = min(min_effort,find_path(...))</code> <br/>行，因为python从左到右计算参数，在进入递归之前已经计算了全局变量<code class="fe mo mp mq mr b">min_effort</code>，所以递归中发生的任何事情(包括对全局变量的更新)对<code class="fe mo mp mq mr b">min_effort</code>都没有影响。</p><p id="2433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在网格底部中间的3的范围内，算法还没有找到成功的路径(第一条路径是1，3，5，3，5)，所以此时<code class="fe mo mp mq mr b">min_effort</code>还是<code class="fe mo mp mq mr b">math.inf</code>，而<code class="fe mo mp mq mr b">min(math.inf,math.inf)</code>变成了inf。</p><h1 id="3536" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3个修复</h1><ol class=""><li id="ea8f" class="nb nc it lb b lc mu lf mv li nd lm ne lq nf lu ng nh ni nj bi translated"><strong class="lb iu">交换参数</strong></li></ol><p id="c604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种解决方法是简单地将参数的顺序换成<code class="fe mo mp mq mr b">min_effort = min(find_path(...), min_effort)</code>。这使得递归有机会在比较之前先更新全局变量。</p><p id="dca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu">先存成变量</strong></p><p id="82ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您仍然希望优先保持旧的顺序，可以先计算递归并保存到变量中。</p><pre class="kj kk kl km gt nk mr nl nm aw nn bi"><span id="476a" class="no lw it mr b gy np nq l nr ns">recursion_res = find_path(...)<br/>min_effort = min(min_effort, recursion_res)</span></pre><p id="01ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<strong class="lb iu">完全删除全局变量</strong></p><p id="165a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是由于Leetcode在运行所有测试用例时给出了错误的测试结果，但是作为定制输入单独运行失败的用例给出了正确的结果。如果您坚持在leetcode上使用全局变量，那么复制结果，清除全局变量，并返回复制的结果，以便清除的全局变量为下一个测试用例做好准备。</p><p id="536e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个变化:<br/> 1。将之前的全局变量添加到递归函数签名中<code class="fe mo mp mq mr b">find_path(...,min_effort)</code></p><p id="8e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.返回<code class="fe mo mp mq mr b">min_effort</code>而不是<code class="fe mo mp mq mr b">math.inf</code></p><p id="322f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将确保最小努力路径总是通过递归调用传播。如果你问为什么在使用全局变量时不返回<code class="fe mo mp mq mr b">min_effort</code>,这也是可行的，但是没有必要，因为如果你避免了上面提到的问题，在<code class="fe mo mp mq mr b">min(min_effort,find_path(...))</code>比较之前，<code class="fe mo mp mq mr b">min_effort</code>将被更新为非inf值，所以即使第二个参数返回math.inf，一旦任何路径首先到达目的地，第一个参数将总是被更新为正确的值。另外，<code class="fe mo mp mq mr b">math.inf</code>更能代表“无解/不好的价值”。</p><p id="6f3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，支持<code class="fe mo mp mq mr b">return min_effort</code>而不是<code class="fe mo mp mq mr b">return math.inf</code>的理由是它更准确地代表了最新的程序状态。此外，我们可以完全避免gotcha处理(前面描述的两个修复),直接使用<code class="fe mo mp mq mr b">min(min_effort,find_path(...))</code>,因为有了<code class="fe mo mp mq mr b">return min_effort</code>,第二个参数将总是被更新，所以在第一个参数中包含其初始化的<code class="fe mo mp mq mr b">math.inf</code>的“预递归求值”<code class="fe mo mp mq mr b">min_effort</code>不会造成任何伤害。(与上一段完全相反的情况)。</p><h1 id="4dfd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">改进解决方案</h1><p id="331c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为我们正在寻找全局最小值，所以任何路径都可能受到任何其他路径的结果的影响。这为当前最佳结果提供了一个机会，一旦发现它们比当前<code class="fe mo mp mq mr b">min_effort</code>具有更长的努力，就短路未来路径。这可以通过用额外的检查<code class="fe mo mp mq mr b">if updated_effort &lt; min_effort:</code>包装回溯部分(visit，recurse，unvisit)来实现，以大大减少探索步骤，使用“小于”,因为尝试不会减少当前最佳结果的东西是没有意义的。</p><pre class="kj kk kl km gt nk mr nl nm aw nn bi"><span id="84c3" class="no lw it mr b gy np nq l nr ns">if updated_effort &lt; min_effort:<br/>                visited[row,col] = 1<br/>                min_effort = min(min_effort,find_path(heights_arr,visited,row,col,updated_effort,max_row,max_col))<br/>                visited[row,col] = 0</span></pre><h1 id="1e64" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">全球与本地比较</h1><p id="7930" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><strong class="lb iu">全球优势:</strong></p><ol class=""><li id="6963" class="nb nc it lb b lc ld lf lg li nt lm nu lq nv lu ng nh ni nj bi translated">允许的宽松返回值(<code class="fe mo mp mq mr b">math.inf</code>或<code class="fe mo mp mq mr b">min_effort</code>)</li><li id="7a5c" class="nb nc it lb b lc nw lf nx li ny lm nz lq oa lu ng nh ni nj bi translated">方便的编码(更少的参数传递和更简单的递归函数)</li></ol><p id="de04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">全局不利因素:</strong></p><ol class=""><li id="e2ec" class="nb nc it lb b lc ld lf lg li nt lm nu lq nv lu ng nh ni nj bi translated">不要使用在线编码平台(对工作面试自动编码评估有风险)</li><li id="a51d" class="nb nc it lb b lc nw lf nx li ny lm nz lq oa lu ng nh ni nj bi translated">必须时刻注意不在当前堆栈中的副作用和变量</li><li id="d89e" class="nb nc it lb b lc nw lf nx li ny lm nz lq oa lu ng nh ni nj bi translated">对函数参数排序敏感(所有这些问题的根源)</li></ol><p id="8f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">本地优点:</strong></p><ol class=""><li id="9a82" class="nb nc it lb b lc ld lf lg li nt lm nu lq nv lu ng nh ni nj bi translated">专注于局部问题空间的更容易的调试/跟踪</li><li id="2997" class="nb nc it lb b lc nw lf nx li ny lm nz lq oa lu ng nh ni nj bi translated">副作用更少</li></ol><p id="a35a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当地不利因素:</p><ol class=""><li id="a510" class="nb nc it lb b lc ld lf lg li nt lm nu lq nv lu ng nh ni nj bi translated">更详细的函数签名(要跟踪的项目越多，意味着签名越长)</li><li id="7b5b" class="nb nc it lb b lc nw lf nx li ny lm nz lq oa lu ng nh ni nj bi translated">失去返回<code class="fe mo mp mq mr b">math.inf</code>的能力，必须返回<code class="fe mo mp mq mr b">min_effort</code>以将更新的结果传播回程序的其余部分</li></ol><h1 id="b79b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">做错比做对更有价值</h1><p id="e81c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用全局变量时，如果我最初使用上面的fix 2返回了<code class="fe mo mp mq mr b">min_effort</code>或正确编码，我根本不会看到这个问题。塞翁失马，焉知非福，返回最直观的正确值和对(可能)无关变量赋值的懒惰让我加强了对python求值顺序和调试技巧的理解。</p></div></div>    
</body>
</html>