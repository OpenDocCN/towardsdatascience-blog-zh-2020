<html>
<head>
<title>The Maw of Chaos</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混乱的深渊</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-maw-of-chaos-a7b42cbc30cf?source=collection_archive---------52-----------------------#2020-10-09">https://towardsdatascience.com/the-maw-of-chaos-a7b42cbc30cf?source=collection_archive---------52-----------------------#2020-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c191" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么时间预测如此具有挑战性？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ca3bb75d5f282b6f57b54c2fd8def07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Xx0dt_LV2YbfKxLjZiOHQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你知道，如果开始下大雨，事情会变得很糟糕。古巴，2015。图片由作者提供。</p></figure><h1 id="189d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="1b4e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我对自己发誓不写新冠肺炎。</p><p id="fa7e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然而，由于我最近倾向于回归基本面，重新审视数学中一些更有趣的话题，我认为解释为什么<strong class="ls iu">预测时间序列</strong>(例如疾病进展)如此具有挑战性将是有趣和有用的。更准确地说，我想通过展示事物在基本层面上是如何工作的，来解释为什么做这样的模拟有时真的很难。</p><p id="2674" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们将从一些基本方程开始，讨论与<strong class="ls iu">数据</strong>和构建<strong class="ls iu">模型</strong>相关的主要挑战。然后，我们将转向一个更复杂的数学现象，称为<em class="mr">混沌</em>。就像在<a class="ae ms" href="https://www.eurogamer.net/articles/2018-11-18-thief-the-dark-project-is-20-years-old-and-you-should-play-it-today" rel="noopener ugc nofollow" target="_blank">小偷:黑暗计划</a>(我以前最喜欢的一个)中一样，我们会逐渐进入其中，但这一次，我们将配备python。；)</p><h1 id="b506" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">最简单的模型</h1><h2 id="d789" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">指数生长</h2><p id="f8f6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">不失一般性，让我们联系在一个给定的时间步骤感染疾病的人数。确定进展的最简单模型是以下更新规则:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/268401b3d21c275f67109afd3707c82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*UzN9aDBwuGipFP2HR1Feqg.png"/></div></figure><p id="463d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这是一个简单的<em class="mr">递归</em>公式，它在每次应用时都将值加倍。这里2只是一个比例常数，它告诉扩散发生的<em class="mr">速率</em>。</p><p id="479f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">由于时间是连续的，因此将<em class="mr"> x </em>视为时间相关值<em class="mr"> x(t) </em>是有意义的。此外，将它解释为人口的一部分而不是一个绝对数量也是有意义的。这样，我们可以将问题重新表述为一个简单的一阶微分方程(ODE):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/56eb817a6e951e68f81fe0c08710e94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*RMtJHoNasYLz5TcZeVcKsA.png"/></div></figure><p id="8983" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">用<em class="mr">一个&gt; 0个</em>。</p><p id="c7c0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个方程的解用经典的<em class="mr">指数</em>函数表示</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/938c1e7b60be132bddb5789f29ea897e.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*cgZzOgKMZ2VD6WuqmQ181w.png"/></div></figure><p id="dc0b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其中<em class="mr"> x0 = x(t = 0) </em>就是所谓的<em class="mr">初始条件</em>。</p><p id="43ba" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它的形式正是戏剧性增长背后的原因。然而，当<em class="mr"> x </em>开始变得过大时，这个函数就是一个糟糕的模型。毕竟，正如我们同意用来描述人口的<em class="mr">分数</em>一样，它不能超过1。在某种程度上，它必须放慢速度，因为如果一个被感染的人只与被感染的人接触，就不会再有新的感染发生。</p><h2 id="0545" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">逻辑增长</h2><p id="c27a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在定义我们的模型时，考虑这种“停顿”机制似乎是一个自然的步骤。下面这款怎么样？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/de156015319a87cdcc554bd2af5c13d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Yu0QHPMsW4fNkjWp2lxjUA.png"/></div></figure><p id="1291" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个公式定义了<em class="mr">逻辑增长</em>。我们来考虑一下它的性质。最初，当<em class="mr"> x </em>较小时，<em class="mr"> a(1 - x) </em> ≈ <em class="mr"> a </em>和，增长是指数型的。然而，一旦<em class="mr"> x </em>接近0.5，<em class="mr"> (1 - x) </em>开始抑制增长，使其在<em class="mr"> x = 1 </em>时完全停止。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/bdc8c73e9da8f166ba88830128066e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pzs8b6OiALUDRwYVVoMm4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。指数增长和逻辑增长的比较。观察它们对于作者的小x. Image是多么的相似。</p></figure><h1 id="f755" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">事情变得复杂…</h1><p id="af2e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">逻辑增长看起来可以接受。我们喜欢它，因为它很容易理解，抓住了一些现实，给了我们希望，只要我们接近“临界点”(在这个例子中是<em class="mr"> x = 0.5 </em>)，我们就可以阻止指数增长，并逐渐减缓整个事情。也许我们只需要参数化这里和那里的逻辑更新规则，它肯定会帮我们一个忙。我们知道这至少可以为我们赢得宝贵的时间。</p><p id="edae" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">不幸的是，这就是事情变得困难的地方。</p><h2 id="7eb6" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">与数据相关的问题</h2><p id="fa18" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">此类模拟(如<a class="ae ms" href="https://www.sciencedirect.com/science/article/pii/S0960077920306378" rel="noopener ugc nofollow" target="_blank">此处</a>或<a class="ae ms" href="https://reader.elsevier.com/reader/sd/pii/S0048969720323512?token=9EED6EB763A840ED01BAAF6B40C20E7EE7980D09DBF798D4B3AFC14C0A763726388F3C80DD73D96CE7380ED6B3D8A0CE" rel="noopener ugc nofollow" target="_blank">此处</a>)的共同出发点是首先修改逻辑增长方程以捕捉更多现实情况，找到数据(如某个国家每天发生的病例数)，最后将数据拟合到分析解中(如果存在)或使用数据对其进行数字整合以进行微调。如果一个解决方案<em class="mr"> x(t) </em>很好地捕捉到了数据，我们就可以做出预测或者进行进一步的“假设”分析。</p><p id="0f44" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这听起来很简单，但坏消息是大多数参数很难估计。例如，让我们稍微修改一下等式，通过添加<em class="mr"> x(∞) = x(t → ∞) </em>系数(就像这里的<a class="ae ms" href="https://www.sciencedirect.com/science/article/pii/S1201971220303039" rel="noopener ugc nofollow" target="_blank">中的</a>一样)来说明也许不是每个人都会感染这种疾病。该等式将变成如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/22b18ff73a2fcceef38b398290d2189c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*-bww1l9WW82rMtqBod98uQ.png"/></div></figure><p id="9136" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">该系数本身表示最终会被感染的人口比例。虽然这是一个未知数，但人们可以通过比较参数化逻辑曲线与指数曲线的偏差来估计它。图二。显示了该参数的影响。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/038e0488095990d853f02e9ae8965673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCNuRPs9mTZS5UHNUFyZLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。系数对逻辑增长级数的影响。图片由作者提供。</p></figure><p id="964a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">由于大多数数据都有噪声，噪声很容易转化为对某些系数的错误估计。在微分方程的情况下，这些微小的变化可能会进一步放大，从而导致大胆的“错误估计”(稍后将详细介绍)。</p><p id="ad91" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">尽管如此，数据上的噪声只是更大图景的一部分…</p><h2 id="55a0" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">模型相关问题</h2><p id="65ea" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">添加<em class="mr"> x(∞) </em>该参数表明朝着正确的方向迈出了一步，以捕捉更多的现实。然而，它并没有抓住全部。人们搬家，生病，有些人康复，有些人再次生病，有些人死亡，有些人出生。有的也是因为完全不相关的原因而死。</p><p id="b921" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">整个人口是一个动态的实体，这应该转化为一个新的方程。当然，并不是所有的过程都需要考虑在内，决定哪些过程重要，哪些不重要，以及如何考虑它们，这本身就是一个更大的挑战。</p><p id="a8d9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们看看下面的例子:<a class="ae ms" href="https://en.wikipedia.org/wiki/Template:COVID-19_pandemic_data/Poland_medical_cases" rel="noopener ugc nofollow" target="_blank">波兰</a>的数据。考虑到第一个100天，似乎很明显，疾病进展确实可以用修正的逻辑生长方程的解来表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/f50abb9fcbdcae90b9c529d5ac52b532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6j5GBuiHbnPNsb8njWZvw.png"/></div></div></figure><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="bde5" class="mt kz it nn b gy nr ns l nt nu">import pandas as pd<br/>import numpy as np<br/>from scipy.optimize import curve_fit<br/><br/><br/>df = pd.read_csv('./poldata.csv').set_index('day')<br/>ddf = df.head(100)<br/><br/>t = np.linspace(0.0, 10.0, num=101)<br/><br/>def logistic(t, a, x0, xi):<br/>    return x0 * xi * np.exp(a * t) / (xi + x0 * (np.exp(a * t) - 1))<br/>    <br/>    <br/>(*params,) = curve_fit(logistic, t[1:], ddf['cases'].to_numpy())[0]<br/>solution = logistic(t, *params)</span></pre><p id="834d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">图3。显示结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/a74887b54f84bcea3f5cb45e99734f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49d8LGbkfdKMIyZpO9tNlw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。将逻辑增长函数拟合到前100天收集的数据中(上图)。226天后的进展显示出不同的趋势(下图)。图片由作者提供。</p></figure><p id="b09c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">事实是，在第一个100天之后，人们似乎彻底改变了他们的态度。说到数学，不仅我们的等式没有捕捉到几个可能重要的影响因素(例如，人们康复或再次感染)，而且常数(例如，<em class="mr"> a </em>)也不是真正的常数。</p><p id="48d3" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因此，由于数据似乎反映了某种趋势(不同于逻辑，但仍然是一种趋势)，指责模型过于简单是有道理的。</p><p id="6528" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">没错。像这样的情况可能，的确，给我们希望，用正确的成分，应该有可能建立必要的方程，一旦解决，可以用于预测。</p><p id="eaf8" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">不幸的是，还有最后一个问题似乎是数学本身。</p><h1 id="5db0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">混乱</h1><p id="bce5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">一片混乱。如果没有随机性、嘈杂的数据或“错误校准”的方程，混沌可能会让所有的预测完全变成废话。这是一个纯粹的数学现象，它起源于数字。</p><p id="8c22" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为简单起见，让我们回到纯逻辑增长更新规则<em class="mr"> ax(1 - x)。</em>让我们也编写递归应用这条规则的代码。以后会更容易形象化。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2d6d" class="mt kz it nn b gy nr ns l nt nu">from functools import lru_cache<br/><br/>def logistic_growth(x, a=2.0):<br/>    return a * x * (1 - x)<br/><br/><br/>@lru_cache(100)<br/>def update(x_init, i, rule=logistic_growth):<br/>    x = rule(x_init)<br/>    i -= 1<br/>    if i == 0:<br/>        return x<br/>    else:<br/>        return update(x, i, rule=rule)</span></pre><h2 id="518a" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">蛛网图</h2><p id="f872" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">有了这段代码，我们可以使用所谓的<em class="mr">蛛网</em>图来调查初始化解决方案的结果。通过绘制更新规则和一条对角线<em class="mr"> x = t </em>来构建该图。然后，通过用某个数字初始化<em class="mr"> x(0) </em>，我们通过随后应用规则并把输出反馈给输入来跟踪它。从视觉上看，这相当于将点从曲线上弹开(图4。).</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="b01b" class="mt kz it nn b gy nr ns l nt nu">from functools import partial<br/><br/>def cobweb_plot(ax, x0_init, a, rule=logistic_growth, max_iter=10, <br/>    xlim=(0, 1), ylim=(0, 1)):<br/>    <br/>    x = np.linspace(xlim[0], xlim[1], num=101)<br/>    update_rule = partial(rule, a=a)<br/>    <br/>    ax.plot(x, update_rule(x), 'b')<br/>    ax.plot(x, x, color='k')<br/><br/>    x0, x1 = x0_init, update(x0_init, 1, rule=update_rule)<br/>    y0, y1 = 0.0, update(x0_init, 1, rule=update_rule)<br/><br/>    ax.plot((x0, x0), (0, y1), 'r', lw=0.5)<br/>    <br/>    x0, x1 = x0_init, update(x0_init, 1, rule=update_rule)<br/>    y0, y1 = 0.0, update(x0_init, 1, rule=update_rule)<br/>   <br/>    for i in range(1, max_iter):<br/>        y1 = update(x0_init, i, rule=update_rule)<br/>        ax.plot((x0, x1), (x1, x1), 'g', lw=0.5)<br/>        ax.plot((x1, x1), (x1, y1), 'g', lw=0.5)<br/>        x0, x1 = x1, y1<br/>        <br/>    ax.set_xlabel('x')<br/>    ax.set_ylabel(f'{a} x(1 - x)')<br/>    ax.set_title(f'Logistic growth progression, x0={x0_init}')<br/>    ax.set_xlim(xlim)<br/>    ax.set_ylim(ylim)<br/><br/><br/>fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=100)<br/>for ax, x_init in zip(axs.flatten(), (0.11, 0.25, 0.66, 0.88)):<br/>    cobweb_plot(ax, x_init, 2.0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/4f58951a9bc2ba622376d15d99070bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*splBsgs_FHQVsK-PW1nf4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4。使用四种不同的初始条件为“a = 2”准备的蛛网图。不管“x0”如何，观察解如何收敛到0.5。图片由作者提供。</p></figure><p id="fef0" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="mr"> x(t) = t </em>的点称为<em class="mr">不动点</em>。它们很重要，因为它们包含了整个系统的信息。这里(图4。)，显然<em class="mr"> x = 0.5 </em>是一个特定的不动点，它倾向于<em class="mr">吸引</em>解。更正式的说法是叫一个<em class="mr">稳定不动点</em>，因为无论我们如何初始化解，<em class="mr"> x </em>最终都会稳定在0.5。</p><h2 id="1a95" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">不是每个x都是“有吸引力的”</h2><p id="4fb0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">逻辑规则是如此简单，以至于没有人会认为它会出错。我们知道<em class="mr"> a </em>系数决定了扩散率(在文献中通常称为<em class="mr"> R </em>)。现在，让我们把它改成一些不同的值。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="aae2" class="mt kz it nn b gy nr ns l nt nu">fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=100)<br/><br/>axs = axs.flatten()<br/>cobweb_plot(axs[0], 0.12, 3.31, maxiter=150)<br/>cobweb_plot(axs[1], 0.62, 3.31, maxiter=150)<br/>cobweb_plot(axs[2], 0.12, 3.51, maxiter=150)<br/>cobweb_plot(axs[3], 0.12, 3.99, maxiter=150)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/be39e3e0763c5d2029c044189a2d5c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vie7ZIOGZ03nEEx-vTI2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5。系统的不同演化情况。顶部:` a = 0.31 '和不同的初始值。下图:相同的初始值“0.12”，但不同的比率“a = 3.51”和“a = 3.99”。图片由作者提供。</p></figure><p id="271c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如我们在图5中看到的。选择稍高的复制率值<em class="mr"> a = 3.31 </em>，我们获得两个固定点。系统变得双稳态，并且当<em class="mr"> t → ∞ </em>时，解在0.825664338273154和0.4465353535之间交替翻转。1982 . 00000000005</p><p id="df95" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">进一步增加速率a = 3.51，我们得到4倍的周期。最后，对于更高，似乎没有一点吸引解决方案了。它变得<em class="mr">不稳定</em>，其中初始值<em class="mr"> x0 </em>的微小变化导致完全不同的路径。字面意思就是<a class="ae ms" href="https://www.imdb.com/video/vi1771308569?playlistId=tt0289879&amp;ref_=tt_ov_vi" rel="noopener ugc nofollow" target="_blank">蝴蝶效应</a>。</p><p id="480a" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">请注意，这是<strong class="ls iu">而不是</strong>随机性，因为我们的计算是完全确定的。然而，正是由于刚才提到的不稳定性，在实践中，即使对于完美的数据集和设计良好的方程，我们也可能面临无法做出任何长期预测的情况。</p><p id="9809" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这只是…数学。</p><h2 id="dd58" class="mt kz it bd la mu mv dn le mw mx dp li lz my mz lk md na nb lm mh nc nd lo ne bi translated">分叉</h2><p id="0afa" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在我们结束这一部分之前，想象一个更有趣的图形可能会很有趣。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="7ff0" class="mt kz it nn b gy nr ns l nt nu">N_SAMPLES = 200<br/><br/><br/>def get_fixed_point(x_init, a):<br/>    return update(x_init, 100, rule=partial(logistic_growth, a=a))<br/><br/>a_values = np.tile(np.linspace(0.0, 4.0, num=200000) \<br/>    .reshape(-1, 1), N_SAMPLES)<br/>df = pd.DataFrame(a_values) \<br/>    .applymap(lambda a: (np.random.random(), a)) \<br/>    .applymap(lambda c: get_fixed_point(*c))<br/><br/>df = df.unstack().xs(1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/d0c01153085318a6c8d9ef971540c8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HXGupt8r3xZNk4WOMNa1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图。分支图是通过扫描“a”和每个“a”随机初始化“200次并让系统每次进化100次迭代而获得的。图片由作者提供。</p></figure><p id="623c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">图6。显示了所谓的分叉图，它显示了不同的<em class="mr"> x(∞) </em>值作为<em class="mr"> (a，x0) </em>的函数。我们可以看到，只要<em class="mr"> a &lt; 1 </em>，最终的被感染比例就会降到零。对于<em class="mr"> 1 &lt; a ≈ &lt; 3，</em>它会非零，但至少有一个解。然而，随着进一步增加，系统的最终行为变得越来越不可预测，即使<em class="mr"> a </em>被精确估计。这个系统对微小的变化过于敏感，因此不能被信任。</p><h1 id="cb4e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="3bdc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">创建数学模型并非易事。我们已经看到了人们可能面临的三种主要挑战，最后一种挑战似乎是数学本身在捉弄我们。尽管如此，许多人发现，即使是简单的方程也能表现出如此丰富的行为，这令人着迷。</p><p id="e33c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">从实践的角度来看，预测模型通常由数学“驱动”,包括某种更新规则。即使它们不是直接基于微分方程，这些模型产生的解是否<em class="mr">稳定</em>也常常值得考虑。正如我们所看到的，即使是简单的规则，连续应用它们的长期效果可能会直接导致混乱。</p><h1 id="48e0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">还会有更多…</h1><p id="f1b4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我计划把文章带到下一个层次，并提供简短的视频教程。</p><p id="b613" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果您想了解关于视频和未来文章的更新，<strong class="ls iu">订阅我的</strong> <a class="ae ms" href="https://landing.mailerlite.com/webforms/landing/j5y2q1" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">简讯</strong> </a> <strong class="ls iu">。你也可以通过填写<a class="ae ms" href="https://forms.gle/bNpf9aqZJGLgaU589" rel="noopener ugc nofollow" target="_blank">表格</a>让我知道你的期望。回头见！</strong></p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="6f23" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="mr">原载于</em><a class="ae ms" href="https://zerowithdot.com/time-forecasting-challenges/" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://zerowithdot.com</em></a><em class="mr">。</em></p></div></div>    
</body>
</html>