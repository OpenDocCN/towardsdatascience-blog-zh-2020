<html>
<head>
<title>How to Get Feature Importances from Any Sklearn Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从任何Sklearn管道中获取特性重要性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-get-feature-importances-from-any-sklearn-pipeline-167a19f1214?source=collection_archive---------9-----------------------#2020-10-12">https://towardsdatascience.com/how-to-get-feature-importances-from-any-sklearn-pipeline-167a19f1214?source=collection_archive---------9-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="19ba" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="190d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">管道可能很难导航，下面是一些通用的代码。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f937487b801f7c3d900ca2f5276dcfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1UnWSd2fYjVaLOXP"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@quinten149?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">昆腾·德格拉夫</a>在<a class="ae lh" href="https://unsplash.com/s/photos/pipeline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="762f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="7cac" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">管道太神奇了！我基本上在我从事的每个数据科学项目中都使用它们。但是，轻松获得特性的重要性要比需要的困难得多。在本教程中，我将介绍如何从管道中访问单个特征名称及其系数。在那之后，我将展示一个通用的解决方案来获取几乎所有管道的特性重要性。</p><h1 id="c902" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">管道</h1><p id="ddc8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">让我们从一个超级简单的管道开始，它应用一个单独的特征化步骤，然后是一个分类器。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="146d" class="nb lj it mx b gy nc nd l ne nf">from datasets import list_datasets, load_dataset, list_metrics<br/>from sklearn.pipeline import FeatureUnion, Pipeline<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>from sklearn import svm</span><span id="9eb5" class="nb lj it mx b gy ng nd l ne nf"># Load a dataset and print the first examples in the training set<br/>imdb_data = load_dataset('imdb')</span><span id="b1cf" class="nb lj it mx b gy ng nd l ne nf">classifier = svm.LinearSVC(C=1.0, class_weight="balanced")<br/>model = Pipeline(<br/>    [<br/>        ("vectorizer", TfidfVectorizer()),<br/>        ("classifier", classifier),<br/>    ]<br/>)<br/>x_train = [x["text"]for x in imdb_data["train"]]<br/>y_train = [x["label"]for x in imdb_data["train"]]<br/>model.fit(x_train, y_train)</span></pre><p id="c29c" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这里我们使用优秀的<a class="ae lh" href="https://pypi.org/project/datasets/" rel="noopener ugc nofollow" target="_blank">数据集</a> python包来快速访问imdb情感数据。这个由HuggingFace整理的包有大量的数据集，它们都已经准备好了，所以你可以直接进入有趣的模型构建。</p><p id="1190" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">上面的管道在一个列表中定义了两个步骤。它首先接受输入并将其传递给TfidfVectorizer，后者接受文本并将文本的TF-IDF特征作为向量返回。然后，它将该向量传递给SVM分类器。</p><p id="f7e7" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">注意这是如何按顺序发生的，TF-IDF步骤，然后是分类器。您可以链接任意多的特征化步骤。例如，上述管道相当于:</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="9089" class="nb lj it mx b gy nc nd l ne nf">model = Pipeline(<br/>    [<br/>        ("vectorizer", CountVectorizer()),<br/>        ("transformer", TfidfTransformer()),<br/>        ("classifier", classifier),<br/>    ]<br/>)</span></pre><p id="c030" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在这里，我们甚至更多地手动操作。首先，我们得到每个单词的计数，其次，我们应用TF-IDF变换，最后，我们将这个特征向量传递给分类器。TfidfVectorizer一步就完成了这两项工作。但这说明了一点。<strong class="mc jd">在原始管道中，事情按顺序执行。</strong>稍后我们将讨论如何将特性堆叠在一起。现在，让我们努力获得第一个示例模型的特性重要性。</p><h1 id="b33f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">特征重要性</h1><p id="ce1c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">管道使得访问单个元素变得容易。如果您在培训后打印出模型，您将会看到:</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="8f0c" class="nb lj it mx b gy nc nd l ne nf">Pipeline(memory=None,<br/>         steps=[('vectorizer',<br/>                 TfidfVectorizer(...)<br/>                ('classifier',<br/>                 LinearSVC(...))],<br/>         verbose=False)</span></pre><p id="3de4" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">也就是说有两个步骤，一个叫做<code class="fe nm nn no mx b">vectorizer</code>，另一个叫做<code class="fe nm nn no mx b">classifier</code>。我们可以通过查看管道的<code class="fe nm nn no mx b">named_steps</code>参数来访问它们，如下所示:</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="d9e7" class="nb lj it mx b gy nc nd l ne nf">model.named_steps["vectorizer"]</span></pre><p id="3e99" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这将返回我们拟合的This矢量器。相当整洁！Sklearn中的大多数特征化步骤还实现了一个<code class="fe nm nn no mx b">get_feature_names()</code>方法，我们可以通过运行该方法来获得每个特征的名称:</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="69c1" class="nb lj it mx b gy nc nd l ne nf"># Get the names of each feature<br/>feature_names = model.named_steps["vectorizer"].get_feature_names()</span></pre><p id="7267" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">这将为我们提供矢量器中每个特征名称的列表。然后我们只需要从分类器中获取系数。对于Sklearn中的大多数分类器来说，这就像获取<code class="fe nm nn no mx b">.coef_</code>参数一样简单。(集合方法略有不同，它们有一个<code class="fe nm nn no mx b">feature_importances_</code>参数代替)</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="172d" class="nb lj it mx b gy nc nd l ne nf"># Get the coefficients of each feature<br/>coefs = model.named_steps["classifier"].coef_.flatten()</span></pre><p id="0e62" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">现在我们有了分类器中的系数和特征名称。让我们把它们组合成一个好的情节。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="b2c3" class="nb lj it mx b gy nc nd l ne nf">import pandas as pd</span><span id="9168" class="nb lj it mx b gy ng nd l ne nf"># Zip coefficients and names together and make a DataFrame<br/>zipped = zip(feature_names, coefs)<br/>df = pd.DataFrame(zipped, columns=["feature", "value"])</span><span id="f707" class="nb lj it mx b gy ng nd l ne nf"># Sort the features by the absolute value of their coefficient<br/>df["abs_value"] = df["value"].apply(lambda x: abs(x))<br/>df["colors"] = df["value"].apply(lambda x: "green" if x &gt; 0 else "red")<br/>df = df.sort_values("abs_value", ascending=False)</span></pre><p id="6e0c" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">想象一下:</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="c2c4" class="nb lj it mx b gy nc nd l ne nf">import seaborn as sns</span><span id="b3ae" class="nb lj it mx b gy ng nd l ne nf">fig, ax = plt.subplots(1, 1, figsize=(12, 7))<br/>sns.barplot(x="feature",<br/>            y="value",<br/>            data=df.head(20),<br/>           palette=df.head(20)["colors"])<br/>ax.set_xticklabels(ax.get_xticklabels(), rotation=90, fontsize=20)<br/>ax.set_title("Top 20 Features", fontsize=25)<br/>ax.set_ylabel("Coef", fontsize=22)<br/>ax.set_xlabel("Feature Name", fontsize=22)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/0ceda2e17440628df9b02e5fd23eb1bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYLBuHX-I2IK3c2wWg-HMg.png"/></div></div></figure><p id="6a83" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">所以我们可以看到，负面的单字似乎是最有冲击力的。那很酷。获得这些特性的重要性很容易。让我们尝试一个稍微复杂一点的例子。</p><h1 id="489c" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">从要素联合中获取要素重要性</h1><p id="bead" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在大多数真实的应用程序中，我发现我以复杂的方式将许多功能结合在一起。前面我们看到了管道如何按顺序执行每个步骤。我们如何处理多个同时发生的步骤？答案是FeatureUnion类。假设我们想要构建一个模型，在这个模型中，我们采用TF-IDF的二元模型特性，但是也有一些手工策划的二元模型。(参见我关于使用模型寻找好的unigrams的博文。)我们可以使用FeatureUnion来定义这个管道。FeatureUnion接受一个<code class="fe nm nn no mx b">transformer_list</code>，它可以是转换器、管道、分类器等的列表。然后连接它们的结果。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="3fa7" class="nb lj it mx b gy nc nd l ne nf">classifier = svm.LinearSVC(C=1.0, class_weight="balanced")<br/>vocab = {"worst": 0, "awful": 1, "waste": 2,<br/>         "boring": 3, "excellent": 4}<br/>model = Pipeline([<br/>    ("union", FeatureUnion(transformer_list=[<br/>        ("handpicked", TfidfVectorizer(vocabulary=vocab)),<br/>        ("bigrams", TfidfVectorizer(ngram_range=(2, 2)))])<br/>    ),<br/>    ("classifier", classifier),<br/>    ])</span></pre><p id="d597" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">正如你所看到的，我们的模型有两个步骤，一个是T4，一个是T5。在<code class="fe nm nn no mx b">union</code>中，我们做了两个不同的特征化步骤。我们找到一组手工挑选的一元特征，然后是所有二元特征。</p><p id="97c8" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">从这个模型中提取特征稍微复杂一些。我们必须进入联盟，然后获得所有的个人特征。让我们手动尝试一下，然后看看我们是否可以推广到任意管道。我们已经知道如何访问管道的成员，要进入FeatureUnion内部，我们可以直接查看<code class="fe nm nn no mx b">transformer_list</code>并遍历每个元素。所以代码应该是这样的。</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="6a05" class="nb lj it mx b gy nc nd l ne nf">handpicked = (model<br/>              .named_steps["union"]<br/>              .transformer_list[0][1]<br/>              .get_feature_names())</span><span id="5c11" class="nb lj it mx b gy ng nd l ne nf">bigrams = (model<br/>           .named_steps["union"]<br/>           .transformer_list[1][1]<br/>           .get_feature_names())</span><span id="723e" class="nb lj it mx b gy ng nd l ne nf">feature_names = bigrams + handpicked</span></pre><p id="1d03" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">因为分类器是对单个向量进行操作的SVM，所以系数将来自相同的地方并且处于相同的顺序。我们可以再次看到我们的结果。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nq"><img src="../Images/93eb9b362b4b5efaf81776964b0a71af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6MJluf2pM_uRw5DjWwjJw.png"/></div></div></figure><p id="ce71" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">看起来我们的二元模型比我们手工选择的二元模型信息量更大。</p><h1 id="ecb9" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">一般情况</h1><p id="ef9c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">因此，我们已经做了一些简单的例子，但现在我们需要一种方法来实现任何(几乎任何)管道和功能联合的组合。为此，我们求助于老朋友深度优先搜索(DFS)。我们将把管道看作一棵树。每一层都可以有任意数量的特征联合，但它们最终都会叠加成一个特征向量。遍历时大致有三种情况需要考虑。第一种是基本情况，我们在一个实际的转换器或分类器中，它将生成我们的特征。第二个是如果我们在管道中。第三种也是最后一种情况是当我们处于FeatureUnion内部时。让我们更深入地讨论这些。</p><h2 id="8e6b" class="nb lj it bd lk nr ns dn lo nt nu dp ls mj nv nw lu mn nx ny lw mr nz oa ly iz bi translated">案例1:特征化步骤</h2><p id="a1a4" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这里我们想写一个函数，给定一个某种类型的特征，它将返回特征的名称。这是我们DFS中的基本情况。在Sklearn中，有许多不同类型的东西可用于生成特征。一些例子是聚类技术、降维方法、传统分类器和预处理器等等。每一种都允许您以不同的方式访问特性名称。例如，文本预处理器TfidfVectorizer实现了一个<code class="fe nm nn no mx b">get_feature_names</code>方法，就像我们上面看到的那样。然而，大多数聚类方法没有任何命名的特征，它们是任意的聚类，但是它们有固定数量的聚类。让我们编写一个助手函数，给定一个Sklearn特征化方法，它将返回一个特征列表。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="925c" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在这里，我们尝试并列举一些可能发生在Sklearn内部的潜在情况。我们使用<code class="fe nm nn no mx b">hasattr</code>来检查所提供的模型是否有给定的属性，如果有，我们调用它来获得特性名称。如果该方法类似于聚类，并且不涉及实际命名的特征，那么我们通过使用提供的名称来构造我们自己的特征名称。例如，假设我们将这个方法应用到有两个组件的<code class="fe nm nn no mx b">PCA</code>，我们将步骤命名为<code class="fe nm nn no mx b">pca</code>，那么返回的结果特征名称将是<code class="fe nm nn no mx b">[pca_0, pca_1].</code></p><h2 id="fa14" class="nb lj it bd lk nr ns dn lo nt nu dp ls mj nv nw lu mn nx ny lw mr nz oa ly iz bi translated">深度优先搜索</h2><p id="55fc" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在我们可以实现DFS了。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="448b" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">让我们一起来解决这个问题。这个函数需要三样东西。首先是我们要分析的模型。这个模型应该是一个管道。第二个是我们想要提取的所有命名的特征化步骤的列表。在我们的上一个示例中，这是<code class="fe nm nn no mx b">bigrams</code>和<code class="fe nm nn no mx b">handpicked.</code>这是我们在模型中使用的各个步骤的名称。最后一个参数是我们正在查看的当前名称。这对于递归来说是必要的，在第一遍中并不重要。(我应该创建一个helper方法来对最终用户隐藏这一点，但是现在需要解释的代码较少)。</p><ul class=""><li id="1ee4" class="od oe it mc b md nh mg ni mj of mn og mr oh mv oi oj ok ol bi translated">第19–25行构成了基本案例。它们处理步骤名称与我们所需名称列表中的名称匹配的情况。这对应于一个叶节点，它实际上执行特征化，我们希望从它那里获得名称。</li><li id="d035" class="od oe it mc b md om mg on mj oo mn op mr oq mv oi oj ok ol bi translated">第26–30行管理管道中的实例。当这种情况发生时，我们希望通过访问<code class="fe nm nn no mx b">named_steps</code>参数来获得每一步的名称，然后遍历它们来收集特征。我们遍历管道中的每个命名步骤，并在一个列表中获取所有的特性名称。</li><li id="1052" class="od oe it mc b md om mg on mj oo mn op mr oq mv oi oj ok ol bi translated">第31–35行管理我们在FeatureUnion时的实例。当这种情况发生时，我们希望从<code class="fe nm nn no mx b">transformer_list</code>参数中获得每个子转换器的名称，然后遍历它们来收集特性。</li></ul><p id="1a41" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">有了这些，我们现在可以使用任意嵌套的管道，比如说下面的代码，并以正确的顺序获得特性名称！</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="c549" class="nb lj it mx b gy nc nd l ne nf">from sklearn.decomposition import TruncatedSVD<br/>classifier = svm.LinearSVC(C=1.0, class_weight="balanced")<br/>vocab = {"worst": 0, "awful": 1, "waste": 2,<br/>         "boring": 3, "excellent": 4}<br/>model = Pipeline([<br/>    ("union", FeatureUnion(transformer_list=[<br/>        ("h1", TfidfVectorizer(vocabulary={"worst": 0})),<br/>        ("h2", TfidfVectorizer(vocabulary={"best": 0})),<br/>        ("h3", TfidfVectorizer(vocabulary={"awful": 0})),<br/>        ("tfidf_cls", Pipeline([<br/>            ("vectorizer", CountVectorizer()),<br/>            ("transformer", TfidfTransformer()),<br/>            ("tsvd", TruncatedSVD(n_components=2))<br/>        ]<br/>        ))<br/>    ])<br/>     ),<br/>    ("classifier", classifier),<br/>])</span></pre><p id="3a5e" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">在这个例子中，我们构造了三个手写的规则特征化器和一个子管道，该子管道执行多个步骤并导致维数减少的特征。我们可以使用一行代码从这个管道中获得所有的特性名称！</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="bb2a" class="nb lj it mx b gy nc nd l ne nf">get_feature_names(model, ["h1", "h2", "h3", "tsvd"], None)</span></pre><p id="d7da" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">它会回来的</p><pre class="ks kt ku kv gt mw mx my mz aw na bi"><span id="519f" class="nb lj it mx b gy nc nd l ne nf">['worst', 'best', 'awful', 'tsvd_0', 'tsvd_1']</span></pre><p id="fcc0" class="pw-post-body-paragraph ma mb it mc b md nh kd mf mg ni kg mi mj nj ml mm mn nk mp mq mr nl mt mu mv im bi translated">正如我们所料。</p><h1 id="5cd6" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="2fa1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">有很多方法可以混合和匹配管道中的步骤，获得特性名称可能是一种痛苦。如果我们使用DFS，我们可以按照正确的顺序提取它们。这种方法在SciKit-Learn的生态系统中的大多数情况下都有效，但我还没有测试所有的东西。要扩展它，你只需要查看你试图从中提取名字的任何类的文档，并用一个新的条件检查来更新<code class="fe nm nn no mx b">extract_feature_names</code>方法，如果想要的属性存在的话。我希望这有助于使管道更容易使用和探索:)。你可以在这里找到一个Jupyter笔记本，里面有这篇文章的一些代码示例<a class="ae lh" href="https://gist.github.com/nbertagnolli/bf5bd2cc7e0b142d6a862e54dd3ac871" rel="noopener ugc nofollow" target="_blank">。和我所有的帖子一样，如果你遇到困难，请在这里评论或在LinkedIn上给我发消息，我总是很有兴趣听到人们的意见。编码快乐！</a></p></div></div>    
</body>
</html>