<html>
<head>
<title>Unzip, update and zip again XMLs in a folder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在一个文件夹中解压缩、更新和再压缩XML</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unzip-update-and-zip-again-xmls-in-a-folder-7d57f9710ddb?source=collection_archive---------24-----------------------#2020-11-03">https://towardsdatascience.com/unzip-update-and-zip-again-xmls-in-a-folder-7d57f9710ddb?source=collection_archive---------24-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bbff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用python自动化办公程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ff171ac8700ceddbb7a52d281f0130c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CeTuZfPNB_wAtUW7nVcdw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7f95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">日常办公中，经常要带着一堆文件做一些事情。解压，移动，重命名，更新，再次压缩，发送或加载到FTP。所有这些事情做起来都很简单，但是非常耗时，你必须手动地在数十或数百个文件上重复它们。</p><p id="6b6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，您可以使用编程语言来自动化这些重复的任务。Python是一个理想的选择，因为它很容易在计算机上安装，几乎不用试错，即使是计算机新手也能创建程序。Python是一种通用的编程语言，基本上你可以用它解决任何问题。</p><p id="1365" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来探讨一个在许多行业中相当常见的任务。我们将:</p><ol class=""><li id="09b2" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">解压缩一组文件</li><li id="3053" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">更新它们的内容—在我们的示例中，我们将更改XML节点的内容</li><li id="067d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用<code class="fe mi mj mk ml b">zipfile </code>和<code class="fe mi mj mk ml b">shutil </code>库再次压缩结果</li></ol><p id="e301" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在github笔记本-<a class="ae mm" href="https://github.com/vaclavdekanovsky/data-analysis-in-examples/blob/master/Unzip/XML/Unzip_Update_Zip_full.ipynb" rel="noopener ugc nofollow" target="_blank">Unzip _ Update _ Zip _ full . ipynb</a>中跟进这个练习。</p><h1 id="349e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">安装Python</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/05261290e03b2cee1a3c9898f33c1b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*84zBkJBBGBLIF8KKiZOcCQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Jupyter笔记本中执行的示例python代码</p></figure><p id="71b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有几种方法可以在你的电脑上设置python。我个人很喜欢使用Anaconda和Jupyter笔记本。您下载并安装conda包，该包旨在通过所有可能的增强使python环境易于管理，并运行笔记本，这是包的重要部分。</p><p id="f897" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在笔记本中，您可以运行包含一行或多行代码的单独单元格，并立即看到结果。这种方法非常适合原型开发。在google、<a class="ae mm" href="http://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank"> stackoverflow、</a>和教程的帮助下，例如在<a class="ae mm" href="https://medium.com/" rel="noopener"> medium </a>上，你可以快速组合你需要做的事情所需的代码片段。</p><h1 id="ed5a" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak">解压缩</strong></h1><p id="e475" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">让我们探索一下如何在python中处理解压文件的任务。只要去谷歌输入“解压python”就可以了。它会快速列出结果，你可以选择，比如说最大的编码问答网站之一——<a class="ae mm" href="https://stackoverflow.com/questions/3451111/unzipping-files-in-python" rel="noopener ugc nofollow" target="_blank">stack overflow的Python解压文件</a>。在3行代码中，您将了解如何做到这一点:</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="a08e" class="np mo it ml b gy nq nr l ns nt">import zipfile<br/>with zipfile.ZipFile(path_to_zip_file, 'r') as zip_ref:<br/>    zip_ref.extractall(directory_to_extract_to)</span></pre><p id="2c78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你在<code class="fe mi mj mk ml b">import</code>图书馆工作所需的<code class="fe mi mj mk ml b">.zip</code>文件— <code class="fe mi mj mk ml b">zipfile</code>。这允许您使用它的函数和方法来解包归档文件并再次压缩它们。</p><p id="3187" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，使用<code class="fe mi mj mk ml b">zipfile.ZipFile(path_to_zip_file, 'r')</code>打开归档文件进行读取，然后将包的内容提取到目录<code class="fe mi mj mk ml b">zip_ref.extractall(directory_to_extract_to)</code>中。</p><p id="1f28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用了<code class="fe mi mj mk ml b">with</code>符号来确保打开归档文件，执行一个操作，然后关闭归档文件，以便从内存中释放其内容。它可以防止在处理成百上千个文件时出现内存泄漏。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="761c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">解压缩包含许多文件的文件夹</h1><p id="93ec" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">在python中解压缩一个文件需要使用三行代码。要解压缩一堆文件，您只需再添加几行。您必须识别文件夹中的zip文件，并将它们传递给我们上面描述的过程。</p><p id="edbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mi mj mk ml b">os</code>库让你既可以获得文件夹<code class="fe mi mj mk ml b">os.listdir()</code>的内容，又可以使用<code class="fe mi mj mk ml b">os.path.join(folder,file)</code>将文件夹和文件名组合起来。Listdir返回文件和子文件夹。您可以添加<code class="fe mi mj mk ml b">file.endswith(".zip")</code>来仅识别档案。</p><blockquote class="nw nx ny"><p id="89cc" class="ky kz nz la b lb lc ju ld le lf jx lg oa li lj lk ob lm ln lo oc lq lr ls lt im bi translated">或者你可以使用<code class="fe mi mj mk ml b">os.path.splitext()</code>。它的第二个输出是文件扩展名。</p></blockquote><p id="8839" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">知道了文件夹中的所有文件，就可以应用前面的代码来解压缩它们。同样，您可以遍历文件并解压缩每个文件，或者将解压缩打包到一个函数中，该函数在一行综合符号中调用。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="aa26" class="np mo it ml b gy nq nr l ns nt">def unzip(folder: str, file: str, folder_to_extract: str) -&gt; list:<br/>    """unzips a file in a folder into folder_to_extract<br/>    returns a list of files in the zip archive"""<br/>    with zipfile.ZipFile(os.path.join(folder,file), 'r') as zip_ref:<br/>        zip_ref.extractall(folder_to_extract)<br/>        return zip_ref.namelist()</span><span id="6fff" class="np mo it ml b gy od nr l ns nt"># applying a function to the output can be squeezed into the list comprehension<br/>[unzip(folder, f, "temp") for f in os.listdir(folder) if f.endswith(".zip")]</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="4259" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">更新提取的XML</h1><p id="f367" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">一旦我们将XML提取到<code class="fe mi mj mk ml b">temp</code>文件夹中，我们就可以使用它了。Python包含<a class="ae mm" href="https://docs.python.org/3.9/library/xml.etree.elementtree.html#module-xml.etree.ElementTree" rel="noopener ugc nofollow" target="_blank"> xml.etree </a>库来处理xml文件。在我们的例子中，我们知道zip存档包含一个XML文件<code class="fe mi mj mk ml b">a.xml</code>，尽管您可以使用<code class="fe mi mj mk ml b">zip_ref.namelist()</code>列出存档中的所有文件。</p><p id="61fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要更新XML文件，您必须导入树库并加载XML文档。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="7d1b" class="np mo it ml b gy nq nr l ns nt">from xml.etree import ElementTree as ET</span><span id="0005" class="np mo it ml b gy od nr l ns nt"># parse the XML document into a variable<br/>tree = ET.parse(path)</span><span id="1899" class="np mo it ml b gy od nr l ns nt"># get the root emelement containing all the XML nodes<br/>root = tree.getroot()</span></pre><blockquote class="nw nx ny"><p id="16c8" class="ky kz nz la b lb lc ju ld le lf jx lg oa li lj lk ob lm ln lo oc lq lr ls lt im bi translated">请记住，从<code class="fe mi mj mk ml b">tree </code>派生的任何变量都是一个引用。当您更新这些变量的内容时，您也更新了<code class="fe mi mj mk ml b">tree</code>。</p></blockquote><p id="d406" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们想要更新XML中的<code class="fe mi mj mk ml b">&lt;id&gt;...&lt;/id&gt;</code>节点。我们必须首先找到它。etree库中有几种定位XML节点的方法。</p><ul class=""><li id="f98d" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt oe ma mb mc bi translated"><code class="fe mi mj mk ml b">.find()</code>找到XML元素的第一次出现</li><li id="b99b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated"><code class="fe mi mj mk ml b">.findall()</code>列出子元素的所有外观</li></ul><p id="195b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两种方法都接受元素的名称，或者您可以使用<code class="fe mi mj mk ml b">xpath</code>找到它。Xpath是一种在XML中定位所需元素的地址。一旦找到使用的节点，就用<code class="fe mi mj mk ml b">.text</code>参数来获取写在标签之间的值。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="a03c" class="np mo it ml b gy nq nr l ns nt"># in the &lt;data&gt; find the &lt;id&gt;...&lt;/id&gt; node and show its content (.text)<br/>id = root.find("id").text</span></pre><p id="9a8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的Id由下划线“_”分隔成三部分:</p><ul class=""><li id="0435" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt oe ma mb mc bi translated">前缀</li><li id="6564" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">版本</li><li id="13a5" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">日期</li></ul><p id="6d14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一个XML的id是<code class="fe mi mj mk ml b">test_001_20201026</code>。<code class="fe mi mj mk ml b">.text</code>返回字符串形式的值，您可以应用<code class="fe mi mj mk ml b">.split("_")</code>函数将文本分解成细节。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="03b3" class="np mo it ml b gy nq nr l ns nt">[In]: <br/>  split_id = id.split("_")<br/>  print(split_id)</span><span id="af7a" class="np mo it ml b gy od nr l ns nt">[Out]: ["test","001","20201026"]</span></pre><p id="9667" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出是一个python列表，可以很容易地按元素更新。首先我们改变前缀<code class="fe mi mj mk ml b">split_id[0] = new_prefix</code>。然后我们更新版本。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="04c0" class="np mo it ml b gy nq nr l ns nt">split_id[0] = new_prefix<br/>split_id[1] = "{:03d}".format(new_version) </span></pre><p id="165c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果需要将<code class="fe mi mj mk ml b">1</code>转换为<code class="fe mi mj mk ml b">001</code>，我们已经使用<code class="fe mi mj mk ml b">"{:03d}".format(new_version)</code>添加了最多3个字符的前导零。</p><p id="7879" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更新的值可以通过<code class="fe mi mj mk ml b">.join("_")</code>组合成一个字符串，原始的XML组件可以用它来更新:</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="7c80" class="np mo it ml b gy nq nr l ns nt">root.find("id").text = "_".join(split_id)</span></pre><p id="c247" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我提到的，对从<code class="fe mi mj mk ml b">tree</code>派生的变量的任何更新也会更新<code class="fe mi mj mk ml b">tree</code>。我们已经实现了我们想要的XML更新，我们只需要使用<code class="fe mi mj mk ml b">tree.write(output_path)</code>将其导出。</p><p id="8913" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看XML更新的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="1682" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">压缩更新的XML</h1><p id="ed3e" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">现在更新后的<code class="fe mi mj mk ml b">a.xml</code>位于<code class="fe mi mj mk ml b">temp</code>文件夹中。我们只需要压缩它，并将这个归档文件放到<code class="fe mi mj mk ml b">processed </code>文件夹中。让我们首先创建输出文件夹，如果它不存在的话。我们将使用<code class="fe mi mj mk ml b">pathlib</code>库中的<code class="fe mi mj mk ml b">Path</code>。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="9fce" class="np mo it ml b gy nq nr l ns nt"># create the output folder if it doesn't exists<br/>Path(output_folder).mkdir(parents=True, exist_ok=True)</span></pre><p id="35f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们使用<code class="fe mi mj mk ml b">zipfile</code> lib将XML打包到zip存档中。现在我们必须打开归档文件进行写入<code class="fe mi mj mk ml b">'w'</code>。然后我们使用这个档案和<code class="fe mi mj mk ml b">.write(path_to_file, name_of_this_file)</code>的引用。</p><blockquote class="nw nx ny"><p id="212c" class="ky kz nz la b lb lc ju ld le lf jx lg oa li lj lk ob lm ln lo oc lq lr ls lt im bi translated">如果不指定第二个参数<code class="fe mi mj mk ml b">name_of_the_zipped_file</code>，那么包括文件夹和子文件夹在内的整个路径都会被压缩。</p></blockquote><p id="5d0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不知道文件名，<code class="fe mi mj mk ml b">os</code>库可以用它的<code class="fe mi mj mk ml b">os.path.basename()</code>功能帮你。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="178e" class="np mo it ml b gy nq nr l ns nt">with zipfile.ZipFile(output_path, 'w') as myzip:<br/>    myzip.write(path_to_processed_xml, os.path.basename(path_to_processed_xml))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/45307bd07e97e28b0639c7b3bc4d9baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18XCZrisUp40BoXbt1ZGCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">压缩时，指定压缩文件的名称，以避免压缩包含的文件夹。作者图片</p></figure><p id="a71d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管有时你也需要打包文件夹和文件。在我们的例子中<code class="fe mi mj mk ml b">Folder_001_20201101.zip</code>包含一个文件和另一个文件夹中的文件。</p><ul class=""><li id="18bf" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt oe ma mb mc bi translated">folder_A/a.xml</li><li id="d978" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oe ma mb mc bi translated">efg.txt</li></ul><p id="90bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，使用zipfile会有点太完整，但是在<code class="fe mi mj mk ml b"><a class="ae mm" href="https://docs.python.org/3/library/shutil.html" rel="noopener ugc nofollow" target="_blank">shutil.make_archive</a>(output_folder, format, folder_to_pack)</code>中有一个替代方法。这个方法只将<code class="fe mi mj mk ml b">folder_to_pack</code>的内容存档，并将结果放在<code class="fe mi mj mk ml b">output_folder</code>中。您可以选择<code class="fe mi mj mk ml b">zip</code>、<code class="fe mi mj mk ml b">tar</code>、<code class="fe mi mj mk ml b">gztar</code>、<code class="fe mi mj mk ml b">bztar</code>、<code class="fe mi mj mk ml b">xztar</code>格式。</p><h1 id="2afe" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">把它们放在一起</h1><p id="071f" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">现在我们知道了该过程的所有组成部分:</p><ol class=""><li id="5598" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">将一个文件夹中的多个归档文件解压缩到一个临时文件夹中</li><li id="b962" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">更新了每个解压后的文件</li><li id="f29a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">并将更新后的文件再次压缩到归档文件中</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="4cf5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个最后的练习中，我们必须做一些小小的调整。我们将使用原始存档的名称，更新它，同时更新所有包含的XML的内容。原因是归档中可能有两个或更多的XML，每个都有不同的id，我们将它们全部压缩回更新的zip归档(不能有两个不同的名称)。</p><p id="34cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整的代码，可以在这个笔记本中找到—<a class="ae mm" href="https://github.com/vaclavdekanovsky/data-analysis-in-examples/blob/master/Unzip/XML/Unzip_Update_Zip_full.ipynb" rel="noopener ugc nofollow" target="_blank">Unzip _ Update _ Zip _ full . ipynb</a></p><h1 id="70d1" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="675c" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">在这个简单的教程中，您已经看到了python(或任何其他编程语言)的威力。在几行代码中，您可以自动执行任务，如果手动执行，将会花费大量时间。当决定是否值得花时间编码时，我使用这个原则:</p><blockquote class="nw nx ny"><p id="530f" class="ky kz nz la b lb lc ju ld le lf jx lg oa li lj lk ob lm ln lo oc lq lr ls lt im bi translated">如果你做一次小事情，手动做。如果它很大，你在许多项目上重复同样的操作，或者你认为你将来不得不这样做——用编程语言自动化。</p></blockquote><p id="e9a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子中的操作可以有许多变化。您可能希望更新不同的XML节点。zip可能包含CSV文件。您宁愿更新日期，而不是前缀和版本。您可能需要修改输入—例如，将版本增加1或在日期上添加一周。</p><p id="7933" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只要对代码稍加修改，所有这些都是可能的。您也可以在Github<a class="ae mm" href="https://github.com/vaclavdekanovsky/data-analysis-in-examples/blob/master/Unzip/XML/Unzip_Update_Zip_full.ipynb" rel="noopener ugc nofollow" target="_blank">上的jupyter笔记本中查看完整的示例。</a></p><p id="eac7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇关于压缩和XML处理的教程，也希望你喜欢用python可以实现的东西。可能性是无限的。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="8c67" class="np mo it ml b gy nq nr l ns nt">Other articles:</span><span id="6faf" class="np mo it ml b gy od nr l ns nt">* <a class="ae mm" rel="noopener" target="_blank" href="/visualization-with-plotly-express-comprehensive-guide-eb5ee4b50b57">Plotly Express complete tutorial</a><br/>* <a class="ae mm" rel="noopener" target="_blank" href="/highlighted-line-chart-with-plotly-express-e69e2a27fea8">Very illustrative highlighted line chart</a><br/>* <a class="ae mm" rel="noopener" target="_blank" href="/histograms-with-plotly-express-complete-guide-d483656c5ad7">Plotly Histogram - Complete Guide</a><br/>* <a class="ae mm" rel="noopener" target="_blank" href="/complete-guide-to-pythons-cross-validation-with-examples-a9676b5cac12">Everything you wanted to know about Kfold train-test split</a><br/>* <a class="ae mm" rel="noopener" target="_blank" href="/pythons-geocoding-convert-a-list-of-addresses-into-a-map-f522ef513fd6">How to turn a list of addreses into a map</a></span></pre></div></div>    
</body>
</html>