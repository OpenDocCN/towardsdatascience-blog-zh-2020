<html>
<head>
<title>How to deploy your first Machine learning models — Part#2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何部署你的第一个机器学习模型——第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-deploy-your-first-machine-learning-models-part-2-9e1d0fcfb68?source=collection_archive---------45-----------------------#2020-11-11">https://towardsdatascience.com/how-to-deploy-your-first-machine-learning-models-part-2-9e1d0fcfb68?source=collection_archive---------45-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f9fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用带有较少命令的CircleCI管道将机器学习API部署到Heroku</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b98c0ef7c10a60f039856a11ee19c18c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRJgUzD7CgJ-VX6zbAEESw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@the_roaming_platypus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> timJ </a>在<a class="ae ky" href="https://unsplash.com/s/photos/ultimate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ee76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/exclusive-how-to-deploy-your-first-machine-learning-models-bf0a2109e522">在之前的文章</a>中，我给出了根据行业最佳实践开发机器学习管道所需步骤的高度概述。在这一部分中，我将继续构建可访问的REST-API端点，并使用CI/CD管道将其部署到Heroku平台。</p><blockquote class="lv lw lx"><p id="8899" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">这篇文章中的大部分代码已经在第一部分解释过了。</p></blockquote><p id="b534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Github的<a class="ae ky" href="https://github.com/salma71/prediction_app" rel="noopener ugc nofollow" target="_blank">项目回购</a>如果你想跟进的话。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="2f02" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">目录</h1><ol class=""><li id="3e97" class="nb nc it lb b lc nd lf ne li nf lm ng lq nh lu ni nj nk nl bi translated">开发REST-api包</li><li id="7cbb" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">定义所需的circleci配置</li><li id="a27f" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">部署到Heroku平台</li><li id="b0b4" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">测试一个端点。</li></ol></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="abb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们一个一个的分解一下，了解一下结构。</p><h1 id="7990" class="mj mk it bd ml mm nr mo mp mq ns ms mt jz nt ka mv kc nu kd mx kf nv kg mz na bi translated">什么是REST API？</h1><p id="7535" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">REST代表表述性状态转移(REST ),这意味着服务器将向客户机传送所请求的资源状态的表示。API代表应用编程接口；在本教程中，我们不会构建一个完整的REST-API；我们将开发一种预测服务。这是因为本教程的范围是为ML模型开发一个REST-API。</p><p id="4607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解API结构，<a class="ae ky" href="https://www.fullstackpython.com/api-creation.html" rel="noopener ugc nofollow" target="_blank">这里有一个很好的资源，可以从头开始学习API </a>和<a class="ae ky" href="https://programminghistorian.org/en/lessons/creating-apis-with-python-and-flask" rel="noopener ugc nofollow" target="_blank">的创建，本指南</a>和<a class="ae ky" href="https://realpython.com/flask-connexion-rest-api/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="34d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个软件架构的思维模式，你会专注于做出设计决策，使其易于更改、可扩展性，当然还有更少的错误。这就是使用MVC(模型、视图、控制器)架构的好处，它在应用程序中模块化不同的功能，提供三个组件的抽象。让我们简要总结一下这三个组成部分:</p><ol class=""><li id="2c1b" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu ni nj nk nl bi translated">视图:终端用户在与应用程序交互时的体验——界面。</li><li id="e7ae" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">模型:数据驻留和更改的位置</li><li id="c2dc" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">控制器:模型和视图组件之间的通信器。</li></ol><h2 id="7bf9" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">MVC模式的好处是:</h2><ol class=""><li id="f3c4" class="nb nc it lb b lc nd lf ne li nf lm ng lq nh lu ni nj nk nl bi translated">模块化:每个部分都是独特的、封装的，并且可以在不破坏应用程序其余部分的情况下进行替换。</li><li id="e5d4" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">语言不可知——可用于多种语言，不仅仅是python。</li><li id="6cf6" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">简单快速的开发过程。</li><li id="83e1" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">可伸缩和可扩展。</li></ol><p id="0ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于MVC模式和软件工程中的其他模式，<a class="ae ky" href="https://realpython.com/the-model-view-controller-mvc-paradigm-summarized-with-legos/" rel="noopener ugc nofollow" target="_blank">查看本指南</a>和<a class="ae ky" href="https://www.tutorialspoint.com/python_design_patterns/python_design_patterns_model_view_controller.htm" rel="noopener ugc nofollow" target="_blank">本指南</a>。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="286c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/exclusive-how-to-deploy-your-first-machine-learning-models-bf0a2109e522">第1部分</a>是通过在Gemfury上以私人包的形式发布回归模型而完成的。在这一部分中，我们将使用这个包来处理数据并部署到Heroku平台。</p><p id="9d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先在<strong class="lb iu">包</strong>主目录下创建一个名为<strong class="lb iu"> ml_api </strong>的新包。包框架将包括以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/8fa1fe347a389cefd34c75efe831376d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUmdGyUlKcWLn3RDQafmdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包目录结构</p></figure><p id="6663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ml_package </strong>有三个主目录和其他python脚本文件。</p><p id="defd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> requirements.txt </strong>:包含运行包的所有需求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ml_api包的requirements.txt</p></figure><p id="6be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有什么新的，我只是包括了我希望使用的flask版本。此外，包括我在gemfury上发布的<strong class="lb iu"> regression_model </strong>包——我提供了<strong class="lb iu"> index-url </strong>变量，因为它是私有包，还没有公开。如果您希望在本地使用这个包，只需添加您的路径而不是我的路径，然后取消注释即可。我包含了用于模式验证的marshmallow，以及用于部署的gunicorn。</p><blockquote class="lv lw lx"><p id="f309" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">重要的是每个单独的包都有自己的需求文件。</p><p id="4a6c" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果您克隆了<a class="ae ky" href="https://github.com/salma71/prediction_app" rel="noopener ugc nofollow" target="_blank"> Github repo </a>并遵循以下步骤，请确保在ml_api包目录中安装所需的依赖项。</p></blockquote><ul class=""><li id="d9d2" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated">app.py :这个文件就像flask应用程序的工厂，它通过一系列命令来创建flask应用程序和蓝图。这个蓝图负责创建位于控制器中的端点。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><ul class=""><li id="4075" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated"><strong class="lb iu"> controller.py </strong>:该文件作为浏览器后端代码和前端的接口。所以，这个控制器有三个端点，<em class="ly">健康</em>、<em class="ly">版本</em>、<em class="ly">v1/预测/回归</em>。保持API版本化是一个很好的实践。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">controller.py</p></figure><ul class=""><li id="d7fd" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated"><strong class="lb iu"> run.py </strong>:这将是启动应用程序的入口点。负责调用<strong class="lb iu"> create_app() </strong>方法来启动应用程序。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">run.py</p></figure><p id="00cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段，您可以尝试检查浏览器上的API端点。我们可以通过告诉flask启动API的入口点来做到这一点。在终端中，运行以下命令</p><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="e2f2" class="oc mk it ot b gy ox oy l oz pa">FLASK_APP=run.py</span></pre><p id="6cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后从终端运行<code class="fe pb pc pd ot b">python run.py</code>执行<strong class="lb iu"> run.py </strong>文件；现在您可以看到服务器已经启动并运行在<strong class="lb iu"> /health </strong>端点的端口5000上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/d20a0a24138ca32ba6afe4789a2614bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSmX4bv-Q2Mov8cH_mlHQA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在端口5000成功运行服务器，端点健康</p></figure><p id="6d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好地了解Flask微框架的资源:</p><ul class=""><li id="f3fe" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated">链接Python装饰初级读本:<a class="ae ky" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/primer-on-python-decorators/</a></li><li id="9c13" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu or nj nk nl bi translated">烧瓶入门:<a class="ae ky" href="http://flask.pocoo.org/docs/1.0/quickstart/" rel="noopener ugc nofollow" target="_blank">http://flask.pocoo.org/docs/1.0/quickstart/</a></li><li id="bd1e" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu or nj nk nl bi translated">Flask Mega教程:<a class="ae ky" href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world" rel="noopener ugc nofollow" target="_blank">https://blog . miguelgrinberg . com/post/the-flask-Mega-tutorial-part-I-hello-world</a></li><li id="5801" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu or nj nk nl bi translated">烧瓶设计图:<a class="ae ky" href="http://flask.pocoo.org/docs/1.0/blueprints/" rel="noopener ugc nofollow" target="_blank">http://flask.pocoo.org/docs/1.0/blueprints/</a></li><li id="12b4" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu or nj nk nl bi translated">烧瓶源代码:<a class="ae ky" href="https://github.com/pallets/flask" rel="noopener ugc nofollow" target="_blank">https://github.com/pallets/flask</a>(可读性很强！)</li><li id="d1ad" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu or nj nk nl bi translated">Flask Web开发:<em class="ly">用Python开发Web应用程序</em></li></ul></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><ul class=""><li id="f52c" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated"><strong class="lb iu"> config.py </strong>:如果你是从<a class="ae ky" rel="noopener" target="_blank" href="/exclusive-how-to-deploy-your-first-machine-learning-models-bf0a2109e522"> part#1 </a>跟进的话，跟<strong class="lb iu"><em class="ly">regression _ model</em></strong>包的逻辑是一样的。我只添加了一些配置对象来设置特定的flask属性。除了微框架使用的其他几个不同的标志之外，还将development设置为true。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置. py</p></figure><ul class=""><li id="d839" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated"><strong class="lb iu">版本</strong>文件:将版本添加到<code class="fe pb pc pd ot b">__init__.py</code>文件中，以便能够调用版本。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><ul class=""><li id="0bbc" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated"><strong class="lb iu"> validation.py </strong>:这将负责验证模式；模式是数据的一种表示。在这里，它表示我们将接收到API的输入。关于模式优先API设计方法的争论越来越多。虽然有一种观点认为模式应该存在于模型包中，但是我们在这里使用它来定义API契约，这在这里是有意义的。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">验证. py</p></figure><p id="bc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实例化了模式，然后将输入数据转换成正确的格式。之后，加载输入数据并对模式进行检查，以确保没有错误。如果在验证检查过程中出现问题，它只会引发一个验证错误。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="45ed" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使用容器Docker映像进行部署</h1><p id="1d4d" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这些步骤如下:</p><ol class=""><li id="a8ca" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu ni nj nk nl bi translated">安装docker。</li><li id="483a" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">通过Circleci配置Docker</li><li id="4cf2" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">通过Circleci将docker映像部署到Heroku。</li></ol><p id="8ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来有点吓人，但是一旦你有了这个想法，这将是一个简单的任务。所以，让我们开始吧！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="c61c" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">什么是容器？</h2><p id="aff1" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">容器是软件的标准单元，它将代码及其所有依赖项打包，以便应用程序能够从一个计算环境快速可靠地运行到另一个计算环境。</p><h2 id="94ed" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">Docker是什么？</h2><p id="4404" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Docker是一个让创建、部署和运行容器变得简单的工具。Docker容器是软件开发的标准化单元，包含软件应用程序运行所需的一切。这包括代码、运行时、系统工具、库、依赖等。</p><h2 id="54e2" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">以上所有这些看起来都很好，很新奇，我为什么要使用它们呢？</h2><p id="4c4b" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">容器自2013年发现以来变得如此受欢迎，因为它们提供了可再现性。这是一个巨大的好处，因为你确切地知道创建一个给定容器的步骤，容易跟踪错误。此外，它比虚拟机更快、更轻量级。易于与CI/CD管道一起使用。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ea02" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.安装Docker</h1><p id="8aca" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">你可以导航到<a class="ae ky" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank"> docker </a>并按照步骤将其下载到你的本地机器上。</p><h1 id="12f3" class="mj mk it bd ml mm nr mo mp mq ns ms mt jz nt ka mv kc nu kd mx kf nv kg mz na bi translated">2.Dockerfile文件设置</h1><p id="29b1" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">因此，我们想要创建的是一个基于linux的容器映像，这就是为什么大多数命令都是linux命令。</p><ul class=""><li id="d681" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated">Dockerfile:它拉下所需的python版本镜像，指定工作目录，安装需求，设置服务器端口。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile文件</p></figure><ul class=""><li id="ef4a" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated"><strong class="lb iu"> run.sh </strong>:这个shell脚本负责运行guicorn来启动flask应用程序。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">run.sh</p></figure><ul class=""><li id="4449" class="nb nc it lb b lc ld lf lg li nz lm oa lq ob lu or nj nk nl bi translated"><strong class="lb iu"> dockerignore: </strong>在构建映像后告诉docker忽略哪些文件。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">。dockerignore</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="c9d9" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">建立码头工人形象</h1><p id="e5ab" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">现在我们已经准备好构建图像了；为此，如果您在OSX/莱纳斯，我们需要在终端中运行以下命令:</p><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="4933" class="oc mk it ot b gy ox oy l oz pa">prediction_app $ docker build --build-arg PIP_EXTRA_INDEX_URL=${PIP_EXTRA_INDEX_URL} -t YOUR_APP_NAME:latest .</span></pre><blockquote class="lv lw lx"><p id="3166" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">重要提示:如果您希望首先在本地机器上构建映像作为测试，您可以使用<code class="fe pb pc pd ot b">.env</code>文件在本地定义PIP_EXTRA_INDEX_URL。否则，下面的命令将抛出一个错误，即它无法获取所需的包，回归模型。</p></blockquote><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="f448" class="oc mk it ot b gy ox oy l oz pa">In the above command, just replace <!-- -->${PIP_EXTRA_INDEX_URL}<!-- --> with yours if you wish to build locally before doing so through the circleci pipeline. </span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/1a820ce72b838a051718064851ed1582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*337jT1cyfvA2XJdeZk83_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建映像的快照</p></figure><p id="b5bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过在终端中使用<code class="fe pb pc pd ot b">docker images</code>来检查图像是否已成功构建。它将列出在您的本地机器上构建的所有docker映像。</p><h2 id="238d" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">一些有用的docker命令:</h2><ol class=""><li id="0644" class="nb nc it lb b lc nd lf ne li nf lm ng lq nh lu ni nj nk nl bi translated">建造一个集装箱— <a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">参考</a></li></ol><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="618d" class="oc mk it ot b gy ox oy l oz pa">docker build --build-arg PIP_EXTRA_INDEX_URL=${PIP_EXTRA_INDEX_URL} -t YOUR_APP_NAME:latest .</span></pre><p id="ecd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.运行docker镜像— <a class="ae ky" href="https://docs.docker.com/engine/reference/run/" rel="noopener ugc nofollow" target="_blank">参考</a></p><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="59d1" class="oc mk it ot b gy ox oy l oz pa">docker run --name YOUR_APP_NAME -d -p 8000:5000 --rm YOUR_APP_NAME:latest</span></pre><p id="e83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.查看正在运行的容器:</p><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="047f" class="oc mk it ot b gy ox oy l oz pa">docker ps</span></pre><p id="2680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.查看容器日志(通过运行<code class="fe pb pc pd ot b">docker ps</code>获得容器ID)—<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/container_logs/" rel="noopener ugc nofollow" target="_blank">引用</a></p><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="400c" class="oc mk it ot b gy ox oy l oz pa">docker logs CONTAINER_ID — tail</span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9f91" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">和docker一起部署到Heroku</h1><p id="5a7c" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Heroku是一个基于云的平台即服务，允许开发人员完全在云中构建、运行和操作应用程序。</p><h2 id="7950" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">实现应用程序所需的步骤有:</h2><ol class=""><li id="ca55" class="nb nc it lb b lc nd lf ne li nf lm ng lq nh lu ni nj nk nl bi translated">如果您没有帐户，请浏览heroku网站并创建帐户。</li><li id="0129" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">导航至<code class="fe pb pc pd ot b">New</code>菜单并创建新应用，填写应用名称并选择地区，然后点击创建应用。</li><li id="b994" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">安装<a class="ae ky" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> heroku-cli </a>工具，确保保留默认设置，以便heroku被添加到您的系统路径中。</li><li id="10f4" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">安装后重新启动命令行工具。</li><li id="0bb2" class="nb nc it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">通过<code class="fe pb pc pd ot b">heroku login</code>使用cli工具登录heroku账户，输入你的邮箱和密码，你就可以登录heroku平台了。</li></ol></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="dc9b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Heroku构型</h1><p id="400a" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">为了能够部署，您需要将<strong class="lb iu"> PIP_EXTRA_INDEX_URL </strong>变量添加到heroku项目设置中的config vars列表中。</p><p id="e761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，导航至应用程序设置→显示配置变量→</p><p id="d8d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键字:PIP_EXTRA_INDEX_URL</p><p id="fe1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值:your_token@pypi.fury.io/user_name/→添加。</p><p id="bc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候配置部署管道了，以便在每次提交到远程时自动执行部署。</p><h2 id="c24f" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">为此，我们将从以下方面着手:</h2><ol class=""><li id="1534" class="nb nc it lb b lc nd lf ne li nf lm ng lq nh lu ni nj nk nl bi translated">根据<a class="ae ky" href="https://devcenter.heroku.com/articles/getting-started-with-python#define-a-procfile" rel="noopener ugc nofollow" target="_blank"> heroku指令</a>创建过程文件。这个文件负责运行应用程序和访问错误日志文件。</li></ol><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="f0a4" class="oc mk it ot b gy ox oy l oz pa">web: gunicorn --pythonpath packages/ml_api --access-logfile - --error-logfile - run:application</span></pre><p id="d68d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.确保<strong class="lb iu">regression-model = = 1 . 0 . 0</strong>和<strong class="lb iu"> gunicorn==19.9.0 </strong>都被导入到<strong class="lb iu"> ml_api </strong>目录下的需求文件中。</p><p id="1060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.创建负责捕获主分支上最新变更的提交id的Makefile，然后创建一个remote，最后将工作推入heroku。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成文件</p></figure><p id="32b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<strong class="lb iu"> config.py </strong>将所需步骤添加到circleci配置文件——第10节和第11节。它基本上设置了部署所需的步骤，从重新安装需求到捕获新的依赖项，再到设置heroku remote并进行部署。最后，指定管道的工作流，在训练模型之后应该在哪里进行部署——逻辑步骤。</p><blockquote class="lv lw lx"><p id="72d8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">页（page的缩写）n:在第114行，我设置了<code class="fe pb pc pd ot b">docker_layer_caching: false</code>,因为在运行circleci时将它设置为true会出错。您需要升级您的飞机才能将此设置为真。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">完整配置文件</p></figure><p id="43ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当您将更改提交到github时，应用程序应该会自动部署到heroku平台。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="872b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">测试API</h1><p id="c3af" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">你可以导航到heroku dashboard并从那里打开应用程序，或者使用像<a class="ae ky" href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop/related?hl=en" rel="noopener ugc nofollow" target="_blank"> postman </a>这样的工具来确保API正在工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/51dda2d4eea4f47705655fc1fe95e790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sla0KhwUF4fbQe4UcSUjKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用postman测试API，为GET动词返回200状态代码</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/f1ab449be9ba92a990ad05a4cdb09fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBiBqtXflNHIQx8nGsfySw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作应用JSON</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/3b97eb0ff0bde6e2c77aba04179d0a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Va36YebqH2br3Byz1XHfHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">circleci仪表板工作流程</p></figure><p id="527a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们只有两个端点，健康和版本。一旦确认一切正常，就可以添加额外的端点。这种方法非常有用，从简单开始会更容易捕捉错误和bug，从而在调试会话中花费更少的时间。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="4d55" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">总结和结论</h1><p id="a231" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在这一部分中，我们探讨了许多关于API设计的概念，以及如何自动化这个过程以节省时间。这个项目为您提供了一些构建产品级应用程序的最佳实践。此外，它还让您领略了SLCD的实际工作流程——机器学习模型的软件生命周期开发。有问题就问吧；我很乐意帮忙！快乐学习！</p></div></div>    
</body>
</html>