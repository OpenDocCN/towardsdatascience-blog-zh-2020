<html>
<head>
<title>Looping through the Fantasy Premier League API “Element-Summary” Endpoint to Download Player History with Python and Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过梦幻英超API“元素-概要”端点循环下载Python和Pandas的球员历史</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/looping-through-the-fantasy-premier-league-api-element-summary-endpoint-to-download-player-df4ab5151fcb?source=collection_archive---------18-----------------------#2020-09-28">https://towardsdatascience.com/looping-through-the-fantasy-premier-league-api-element-summary-endpoint-to-download-player-df4ab5151fcb?source=collection_archive---------18-----------------------#2020-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/12bf9f414e967b79b5abc4431e35375d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAr9W8R8B1_Ju5ACR8ZXCA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=918830" rel="noopener ugc nofollow" target="_blank">免费提供-照片</a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=918830" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="b0b1" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">用于创建当前赛季所有玩家游戏周历史和所有过去赛季历史的主数据框架的文档</h2></div><p id="56f4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大家好。看起来我的第一个FPL API教程很成功，所以我又为你们带来了另一个Python/Pandas Fantasy Premier League API教程。</p><p id="5294" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，我们将创建两个不同的数据帧:(1)包含每个玩家当前赛季游戏周历史的数据帧，以及(2)包含每个玩家所有过去赛季历史的数据帧。</p><p id="5571" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将是对使用Requests包访问API端点并构建数据帧的极好介绍，也是对使用Python“For循环”迭代一系列玩家id并访问每个玩家的<code class="fe lu lv lw lx b">/api/element-summary/{element_id}</code>的极好介绍。</p><p id="0888" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在赛季结束时，你将能够将这第一个数据帧(每个球员的FPL个人资料的“本赛季”部分中可用的相同数据)保存为CSV或Pickle，允许你建立自己的FPL数据库，明年将无法通过FPL API获得。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/36f512ffe5921281667e57d41d4914e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zuq7LG2niCNMGh9ZLUWHrg.png"/></div></div></figure><p id="ace6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二个数据框架将允许转换和分析在每个球员的FPL档案的“前几个赛季”部分中可用的完全相同的数据。将这些数据与其他玩家放在一起进行对比将会很有趣，而且可能会有所启发。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/f3bcb915c421a10e3d2ff74741fc3cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_9z0mQSojLfpFiMNKfDIA.png"/></div></div></figure><p id="667c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始吧！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="0692" class="mk ml jj bd mm mn mo mp mq mr ms mt mu kp mv kq mw ks mx kt my kv mz kw na nb bi translated">目录</h1><ol class=""><li id="a1ce" class="nc nd jj la b lb ne le nf lh ng ll nh lp ni lt nj nk nl nm bi translated">入门指南</li><li id="9dff" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">进口</li><li id="2701" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">点击API并创建带有请求的响应对象</li><li id="7e1c" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">用Json()方法将响应对象转换成JSON</li><li id="62b2" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">使用JSON <code class="fe lu lv lw lx b">Keys()</code>创建数据帧</li><li id="354b" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">构建并测试For循环</li><li id="8be8" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">遍历所有元素，用f字符串格式构建主数据帧</li><li id="1619" class="nc nd jj la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">保存到CSV并保存</li></ol></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="1434" class="ns ml jj bd mm nt nu dn mq nv nw dp mu lh nx ny mw ll nz oa my lp ob oc na od bi translated">步骤0:开始</h2><p id="dc42" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">如果您是Python、Pandas和Jupyter笔记本的新手，请阅读下面我的文章“Python、Pandas和Jupyter笔记本入门”,然后回到这里继续学习本教程。</p><div class="is it gp gr iu oh"><a href="https://medium.com/dev-genius/getting-started-with-python-pandas-and-jupyter-notebooks-bd08c963914" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jk gy z fp om fr fs on fu fw ji bi translated">Python、Pandas和Jupyter笔记本入门</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">用Jupyter笔记本设置您的机器并开始用Python编程所需的所有文档…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ja oh"/></div></div></a></div><h2 id="e1f8" class="ns ml jj bd mm nt nu dn mq nv nw dp mu lh nx ny mw ll nz oa my lp ob oc na od bi translated">步骤1:导入和设置</h2><p id="ef20" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">对于这个任务，我们需要<code class="fe lu lv lw lx b">pandas</code>和<code class="fe lu lv lw lx b">requests</code>。启动新的Jupyter笔记本，然后在第一个单元格中，导入您的包:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="2f0c" class="ns ml jj lx b gy pa pb l pc pd">import pandas as pd<br/>import requests</span></pre><p id="9bf7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢键盘快捷键，你会喜欢按住“shift”键的同时按下“enter”键来运行每个单元格。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/805da26de33f0270d7216b33a3728667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V79g3I_8sXwoakOVPc-_JA.png"/></div></div></figure><p id="54e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还喜欢更新笔记本中的设置，这样我就可以左右滚动，看到任何给定数据帧中的所有列。如果您以前在Jupyter笔记本上玩过，您可能会经历过这样一个恼人的时刻:由于数据框包含“太多”列，所以您看不到部分数据框。运行下一个单元格以更新显示设置:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="a8de" class="ns ml jj lx b gy pa pb l pc pd">pd.options.display.max_columns = None</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pf"><img src="../Images/4302460c03035f3a174af424f36df966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNe7ISalMYxpKoDxz53BSA.png"/></div></div></figure><p id="2bb4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">附言:如果你想知道我是如何在这些截图中创建这些部分标题的，请尝试选择一个单元格，然后将该单元格从“Code”转换为“Markdown”，方法是选择该单元格并点击“m”键，或者选择该单元格，然后从菜单的下拉菜单中选择“Markdown”。当您使用键盘快捷键“m”时，单元格高亮显示应为蓝色，而不是绿色:</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/c9fd43284937e59d48c0d4595ac78ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*jKWqwN30wYLRUoAOQjMwPA.gif"/></div></figure><h2 id="4aae" class="ns ml jj bd mm nt nu dn mq nv nw dp mu lh nx ny mw ll nz oa my lp ob oc na od bi translated">步骤2:点击API并创建带有请求的响应对象</h2><p id="096c" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">接下来，我们将目标url设置为FPL API的主端点:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="83a3" class="ns ml jj lx b gy pa pb l pc pd">url = '<a class="ae jg" href="https://fantasy.premierleague.com/api/bootstrap-static/'" rel="noopener ugc nofollow" target="_blank">https://fantasy.premierleague.com/api/bootstrap-static/'</a></span></pre><p id="670a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们需要使用<code class="fe lu lv lw lx b">GET</code>方法创建一个带有请求包的响应对象:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="764c" class="ns ml jj lx b gy pa pb l pc pd">r = requests.get(url)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/079ce332965a4ee524b3145a25f2f65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Zx7yvHaoLy0G8jvVEWovA.png"/></div></div></figure><h2 id="19dc" class="ns ml jj bd mm nt nu dn mq nv nw dp mu lh nx ny mw ll nz oa my lp ob oc na od bi translated">步骤3:用Json()方法将响应对象转换成JSON</h2><p id="e31f" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">接下来，我们将使用<code class="fe lu lv lw lx b">json()</code>方法将响应对象的正文解析成JSON。</p><p id="9fbb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您尝试在一个单元格中运行响应对象<code class="fe lu lv lw lx b">r</code>，您将看到的只是响应:<code class="fe lu lv lw lx b">&lt;Response [200]&gt;</code>。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/42c75429c1f016d01042a4c6e64d7b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vu9mFQPaDK3wnOk7b21CSg.png"/></div></div></figure><p id="4147" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">响应对象有各种不同的属性和方法！点击查看他们的列表<a class="ae jg" href="https://www.w3schools.com/python/ref_requests_response.asp" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7bd0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们当前的目的，我们真的只关心使用<code class="fe lu lv lw lx b">json()</code>方法，但是知道这些其他方法是可用的也很好。</p><p id="3f54" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们继续将响应体转换为JSON对象:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="d9e4" class="ns ml jj lx b gy pa pb l pc pd">json = r.json()</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/a65117e898b80eb9bdb62577771d286a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzVS8QZ4yOeuACNjHzba2g.png"/></div></div></figure><h2 id="eac2" class="ns ml jj bd mm nt nu dn mq nv nw dp mu lh nx ny mw ll nz oa my lp ob oc na od bi translated">步骤4:使用JSON <code class="fe lu lv lw lx b">Keys()</code>创建数据帧</h2><p id="7ff2" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">接下来，我们将使用<code class="fe lu lv lw lx b">keys()</code>方法来查看JSON字典中有哪些类型的键可用:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="c661" class="ns ml jj lx b gy pa pb l pc pd">json.keys()</span></pre><p id="4931" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将返回一个键列表:</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/15c65e5da0254c56ae92b8744faceede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnsSxSiz6dCLXANZO7KxAA.png"/></div></div></figure><p id="7a33" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我已经研究了这些键中的每一个都提供了什么，所以我已经确切地知道我想要从哪个键构建我的第一个数据帧:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="a7a7" class="ns ml jj lx b gy pa pb l pc pd">elements_df = pd.DataFrame(json['elements'])</span></pre><p id="594c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建新的数据帧后，我将使用<code class="fe lu lv lw lx b">head()</code>方法检查前4行:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="32ba" class="ns ml jj lx b gy pa pb l pc pd">elements_df.head()</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/115508005105f36b8ca4a8add8420b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XkLnZDBa4d2pfhSb_a1kg.png"/></div></div></figure><p id="8232" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个数据帧对于在下一节循环游戏中的所有玩家元素是必要的。</p><h2 id="17a3" class="ns ml jj bd mm nt nu dn mq nv nw dp mu lh nx ny mw ll nz oa my lp ob oc na od bi translated">步骤5:构建并测试For循环</h2><p id="7c53" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">现在我们有了要迭代的元素列表，我们可以构建For循环并点击<code class="fe lu lv lw lx b">element-summary</code>端点，在每次迭代中注入玩家的<code class="fe lu lv lw lx b">element_id </code>:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="4676" class="ns ml jj lx b gy pa pb l pc pd">url = f'<a class="ae jg" href="https://fantasy.premierleague.com/api/element-summary/{element_id}/'" rel="noopener ugc nofollow" target="_blank">https://fantasy.premierleague.com/api/element-summary/{element_id}/'</a></span></pre><p id="ab65" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们解决这个问题时，请记住，我不一定要分享如何进行For循环的“最佳实践”。我确信有更有效的做事方法。这就是我做这件事的方式。</p><p id="9ed1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">警告结束后，让我们首先构建一个For循环的微型示例，并确保我们的迭代器将为我们工作:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="203e" class="ns ml jj lx b gy pa pb l pc pd">for x in elements_df.index[:5] :<br/>    element_id = elements_df.id[x]<br/>    element_name = elements_df.first_name[x]<br/>    print(x)<br/>    print(element_id)<br/>    print(element_name)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/cb16e1058ebf329ba6084c870d5f8e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdiNdK2A69j600bV4DxOFQ.png"/></div></div></figure><p id="fe51" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意这里的一些事情。首先，这个拼图的<code class="fe lu lv lw lx b">for x in elements_df.index[:5]:</code>部分。</p><p id="d6ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经要求计算机使用DataFrame索引作为迭代器，遍历<code class="fe lu lv lw lx b">elements_df</code> DataFrame的前5个元素。</p><p id="5599" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的<code class="fe lu lv lw lx b">[:x]</code>语法有助于将循环限制在前5个元素。</p><p id="ffb5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">[:x]</code>语法是一种非常常见的Pandas操作，用于按行分割数据帧。例如，<code class="fe lu lv lw lx b">elements_df[:5]</code>实际上和<code class="fe lu lv lw lx b">elements_df.head()</code>是一回事。</p><p id="5838" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用这个切片操作来帮助测试我们的For循环，因为我们绝对不想遍历整个数据帧来测试我们的循环。</p><p id="377c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的<code class="fe lu lv lw lx b">x</code>变量表示我们正在循环的每一行的索引。如果您检查<code class="fe lu lv lw lx b">elements_df.head()</code>，您会在一个未命名的列中看到数据帧最左边的数据帧索引:</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/fa1f508cb056374f3edd1a27ed6d2188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zb3AbA7-mdNrvYNLH7TaNw.png"/></div></div></figure><p id="3378" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用索引来访问数据帧中的任何值。例如，让我们使用索引获取第一行的<code class="fe lu lv lw lx b">first_name</code>:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="b584" class="ns ml jj lx b gy pa pb l pc pd">elements_df.first_name[0]</span></pre><p id="3f6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将返回<code class="fe lu lv lw lx b">‘Mesut’</code>，DataFrame中第一个元素的名字。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/951d190ff8f094f6304842f91ff406df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iaOJ_xZxM8Id1bMWqcMC2Q.png"/></div></div></figure><p id="b085" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以批量执行这个操作，使用一个索引列表来单独遍历每一行，并给一个变量赋值。现在让我们再做一次，但是这次得到前10个元素:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="446b" class="ns ml jj lx b gy pa pb l pc pd">for x in elements_df.index[:10] :<br/>    element_id = elements_df.id[x]<br/>    element_name = elements_df.first_name[x]<br/>    print(x)<br/>    print(element_id)<br/>    print(element_name)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/443f65286351662e1852b9a4a543742e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYY3bABw6VuuclVpGK_hsg.png"/></div></div></figure><p id="5c22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了！我们的For循环运行良好。</p><h2 id="eb7f" class="ns ml jj bd mm nt nu dn mq nv nw dp mu lh nx ny mw ll nz oa my lp ob oc na od bi translated">步骤6:遍历所有元素，用f字符串格式构建主数据帧</h2><p id="73e8" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">你会注意到我们在上面设置的一个变量是<code class="fe lu lv lw lx b">element_df.id</code>。这个<code class="fe lu lv lw lx b">id</code>对于我们的下一个API调用至关重要。</p><p id="d585" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用<code class="fe lu lv lw lx b">id</code>传递到<code class="fe lu lv lw lx b">/api/element-summary/{element_id}</code>端点，为每个玩家获取<code class="fe lu lv lw lx b">element-summary</code>。</p><p id="b9a7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是通过<a class="ae jg" href="https://www.datacamp.com/community/tutorials/f-string-formatting-in-python?utm_source=adwords_ppc&amp;utm_campaignid=898687156&amp;utm_adgroupid=48947256715&amp;utm_device=c&amp;utm_keyword=&amp;utm_matchtype=b&amp;utm_network=g&amp;utm_adpostion=&amp;utm_creative=332602034352&amp;utm_targetid=aud-392016246653:dsa-429603003980&amp;utm_loc_interest_ms=&amp;utm_loc_physical_ms=2784&amp;gclid=EAIaIQobChMIkMrorcmE7AIVQeDICh07xAVAEAAYASAAEgLDavD_BwE" rel="noopener ugc nofollow" target="_blank"> f字符串格式化</a>完成的。让我们用一个例子来快速回顾一下f-string格式:有 f-string格式的<em class="pm">和没有</em>的<em class="pm">:</em></p><p id="efd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">不带f字符串格式:</strong></p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="281d" class="ns ml jj lx b gy pa pb l pc pd">your_name = "David"<br/>print("Hi, my name is {your_name}"</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pn"><img src="../Images/0e27f4ef15d0c1884260de2a968e08c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OU3jpK1E9-UD5a9-AULu2A.png"/></div></div></figure><p id="67f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，不是我们想要的。</p><p id="53f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们尝试将变量<code class="fe lu lv lw lx b">your_name</code>传递到我的字符串语句中:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="cc94" class="ns ml jj lx b gy pa pb l pc pd">your_name = "David"<br/>print(f"Hi, my name is {your_name}"</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pn"><img src="../Images/c50fbdfbdba526ba03d2632b9aad780f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7dxcGzJ7i1Zpp7fboLBAg.png"/></div></div></figure><p id="ab63" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">啊，是的！f-string允许我们将自己的变量注入到字符串中。这很重要，因为<code class="fe lu lv lw lx b">/api/element-summary/{element_id}</code>端点将被设置为字符串，但我们需要在每次点击url时将<code class="fe lu lv lw lx b">element_id</code>注入URL。像这样:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="a355" class="ns ml jj lx b gy pa pb l pc pd">url = f'<a class="ae jg" href="https://fantasy.premierleague.com/api/element-summary/{element_id}/'" rel="noopener ugc nofollow" target="_blank">https://fantasy.premierleague.com/api/element-summary/{element_id}/'</a></span></pre><p id="97dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="11d8" class="ns ml jj lx b gy pa pb l pc pd">url = f'<a class="ae jg" href="https://fantasy.premierleague.com/api/element-summary/1/'" rel="noopener ugc nofollow" target="_blank">https://fantasy.premierleague.com/api/element-summary/1/'</a><br/>r = requests.get(url)<br/>json = r.json()<br/>json.keys()</span></pre><p id="67bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将返回<code class="fe lu lv lw lx b">JSON</code> blob的密钥:</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi po"><img src="../Images/be5c57e4f9b9d9cd845fa89eb831709e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6oN6T2n-fsxekS1VDP56g.png"/></div></div></figure><p id="abaf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和以前一样，我们将使用这些键来创建数据帧:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="9bb2" class="ns ml jj lx b gy pa pb l pc pd">json_fixtures_df = pd.DataFrame(json['fixtures'])<br/>json_history_df = pd.DataFrame(json['history'])<br/>json_history_past_df = pd.DataFrame(json['history_past'])</span></pre><p id="5037" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，让我们使用<code class="fe lu lv lw lx b">head()</code>方法查看每个数据帧:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="41b2" class="ns ml jj lx b gy pa pb l pc pd">json_fixtures_df.head()</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/1010ea6e9c7eb75383c2ef462777c4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K64P7BeRzrREybJZbMbI7w.png"/></div></div></figure><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="9a4c" class="ns ml jj lx b gy pa pb l pc pd">json_history_df.head()</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/2ec8349cb8cb800eee34fae2103eb1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2YhT4PGX9QpmSeAYRHL7Q.png"/></div></div></figure><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="082c" class="ns ml jj lx b gy pa pb l pc pd">json_history_past_df.head()</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/60cad3e4c443ff92ac7968b42585e770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbGQGQ5f8FckJsKDjzxNvA.png"/></div></div></figure><p id="6bae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看完这些数据帧后，我对为所有玩家保存<code class="fe lu lv lw lx b">json_history_df</code>和<code class="fe lu lv lw lx b">json_history_past_df</code>感兴趣，但我现在对<code class="fe lu lv lw lx b">json_fixtures_df</code>不太感兴趣。</p><p id="08dd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有了所有的部分，让我们继续把它们放在我们的For循环中:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="3be9" class="ns ml jj lx b gy pa pb l pc pd">for x in elements_df.index[:5] :<br/>    print(x)<br/>    element_id = elements_df.id[x]<br/>    url = f'<a class="ae jg" href="https://fantasy.premierleague.com/api/element-summary/{element_id}/'" rel="noopener ugc nofollow" target="_blank">https://fantasy.premierleague.com/api/element-summary/{element_id}/'</a><br/>    r = requests.get(url)<br/>    json = r.json()<br/>    json_history_df = pd.DataFrame(json['history'])<br/>    json_history_past_df = pd.DataFrame(json['history_past'])</span></pre><p id="e50d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">print(x)</code>通过查看屏幕，可以帮助我了解操作位置。它充当一种“进度条”</p><p id="5d90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其余的手术我们已经经历过了。</p><p id="5575" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过这还不够好，因为每次我们循环一个新的<code class="fe lu lv lw lx b">element_id</code>，我们都会覆盖保存在<code class="fe lu lv lw lx b">json_history_df</code>和<code class="fe lu lv lw lx b">json_history_past_df</code>数据帧中的数据。</p><p id="8644" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要另一个数据框架来存储所有这些数据！</p><p id="ab5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将通过创建两个名为<code class="fe lu lv lw lx b">all_history_df</code>和<code class="fe lu lv lw lx b">all_history_past_df</code>的新数据帧来处理这个问题，然后将每个新的<code class="fe lu lv lw lx b">json_history_df</code>数据帧和每个新的<code class="fe lu lv lw lx b">json_history_past_df</code>数据帧附加到这些主<code class="fe lu lv lw lx b">all_history_df</code>和<code class="fe lu lv lw lx b">all_history_past_df</code>数据帧中:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="08a7" class="ns ml jj lx b gy pa pb l pc pd">for x in elements_df.index[:5] :<br/>    print(x)<br/>    element_id = elements_df.id[x]<br/>    url = f'<a class="ae jg" href="https://fantasy.premierleague.com/api/element-summary/{element_id}/'" rel="noopener ugc nofollow" target="_blank">https://fantasy.premierleague.com/api/element-summary/{element_id}/'</a><br/>    r = requests.get(url)<br/>    json = r.json()<br/>    json_history_df = pd.DataFrame(json['history'])<br/>    json_history_past_df = pd.DataFrame(json['history_past'])<br/>    <br/>    if x == 0 :<br/>        all_history_df = json_history_df<br/>        all_history_past_df = json_history_past_df<br/>    else : <br/>        all_history_df = all_history_df.append(json_history_df)<br/>        all_history_past_df = all_history_past_df.append(json_history_past_df)</span></pre><p id="49e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这是我们第一次运行这个循环——我们通过索引号<code class="fe lu lv lw lx b">x==0</code>知道它——将<code class="fe lu lv lw lx b">json_history_df</code>和<code class="fe lu lv lw lx b">json_history_past_df</code>数据帧复制为<code class="fe lu lv lw lx b">all_history_df</code>和<code class="fe lu lv lw lx b">all_history_past_df</code>。</p><p id="efce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果这是第一个索引之后的任何内容<em class="pm">，则将新数据帧附加到主数据帧。这只是将每个玩家的个人历史数据帧一个接一个地堆叠到一个包含所有玩家的核心数据帧中。</em></p><p id="0f95" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用前5个元素来测试一下:</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pp"><img src="../Images/2b64bdb73ba2a7892a1d745a6fb77d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKnNhYyhCEfJQJPPZxuWpA.png"/></div></div></figure><p id="4453" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看<code class="fe lu lv lw lx b">all_history_df</code>数据帧的前10行，我们可以看到我们的循环成功了！</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pq"><img src="../Images/54b8492e763dcba214e41650b9ae64b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBr8LaRV6MjzZFLYKVs0TA.png"/></div></div></figure><p id="b65b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe lu lv lw lx b">all_history_past_df</code>也好看！</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/75a5ae7ae91ee141416210a2874218d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHS4sbw1Vz2UkFXRKDbGUA.png"/></div></div></figure><p id="3cfa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们通过移除<code class="fe lu lv lw lx b">[:5]</code>切片，让她撕开整个FPL球员数据库:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="030c" class="ns ml jj lx b gy pa pb l pc pd">for x in elements_df.index :<br/>    print(x)<br/>    element_id = elements_df.id[x]<br/>    url = f'<a class="ae jg" href="https://fantasy.premierleague.com/api/element-summary/{element_id}/'" rel="noopener ugc nofollow" target="_blank">https://fantasy.premierleague.com/api/element-summary/{element_id}/'</a><br/>    r = requests.get(url)<br/>    json = r.json()<br/>    json_history_df = pd.DataFrame(json['history'])<br/>    json_history_past_df = pd.DataFrame(json['history_past'])<br/>    <br/>    if x == 0 :<br/>        all_history_df = json_history_df<br/>        all_history_past_df = json_history_past_df<br/>    else : <br/>        all_history_df = all_history_df.append(json_history_df)<br/>        all_history_past_df = all_history_past_df.append(json_history_past_df)</span></pre><h2 id="8e93" class="ns ml jj bd mm nt nu dn mq nv nw dp mu lh nx ny mw ll nz oa my lp ob oc na od bi translated">第七步:保存到CSV和泡菜</h2><p id="4225" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">这一步是可选的，但当2020/21赛季结束时，你会希望将<code class="fe lu lv lw lx b">all_history_df</code>数据帧保存到你的本地计算机上，以确保你仍然可以访问那些辉煌的数据。您可以将此数据帧保存为CSV或Pickle文件。</p><p id="6120" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不确定Python中的<strong class="la jk">泡菜</strong>是什么？</p><p id="4a32" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">来自geeksforgeeks.org:</p><blockquote class="pr ps pt"><p id="efc9" class="ky kz pm la b lb lc kk ld le lf kn lg pu li lj lk pv lm ln lo pw lq lr ls lt im bi translated">Python pickle模块用于序列化和反序列化Python对象结构。Python中的任何对象都可以被腌制，以便保存在磁盘上。pickle所做的是在将对象写入文件之前先“序列化”对象。Pickling是一种转换python对象(list、dict等)的方法。)转换成字符流。这个想法是，这个字符流包含在另一个python脚本中重建对象所需的所有信息。</p></blockquote><p id="25c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pickle是一种更好的存储python对象的格式，因为它“包含了在另一个Python脚本中重建对象所需的所有信息”</p><p id="3c7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CSV通常也是一种可靠的方式，但泡菜是一种更安全、更有效的方式。</p><p id="a270" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在下面介绍这两种方法:</p><p id="f16d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">保存</strong>T9】</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="a2e4" class="ns ml jj lx b gy pa pb l pc pd">all_history_df.to_csv('/Users/davidallen/fpl_python/all_history_df_1920.csv')</span><span id="2e66" class="ns ml jj lx b gy px pb l pc pd">all_history_past_df.to_csv('/Users/davidallen/fpl_python/all_history_past_df_1920.csv')</span></pre><p id="4bcd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">保存</strong>T10】</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="163c" class="ns ml jj lx b gy pa pb l pc pd">all_history_df.to_pickle('/Users/davidallen/fpl_python/all_history_df_2021_09252020.pickle')</span><span id="b894" class="ns ml jj lx b gy px pb l pc pd">all_history_past_df.to_pickle('/Users/davidallen/fpl_python/all_history_past_df_2021_09252020.pickle')</span></pre><p id="5b84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您想读取您的pickle或CSV文件时，您需要做的就是将文件分配给一个变量，如下所示:</p><pre class="lz ma mb mc gt ow lx ox oy aw oz bi"><span id="ccd0" class="ns ml jj lx b gy pa pb l pc pd">#READING A CSV</span><span id="aa92" class="ns ml jj lx b gy px pb l pc pd">all_history_df = pd.read_csv('/Users/davidallen/fpl_python/all_history_df_2021_09252020.csv')</span><span id="8c48" class="ns ml jj lx b gy px pb l pc pd">all_history_past_df = pd.read_csv('/Users/davidallen/fpl_python/all_history_past_df_2021_09252020.csv')</span><span id="176f" class="ns ml jj lx b gy px pb l pc pd">#READING A PICKLE</span><span id="b55c" class="ns ml jj lx b gy px pb l pc pd">all_history_df = pd.read_pickle('/Users/davidallen/fpl_python/all_history_df_2021_09252020.pickle')</span><span id="ea44" class="ns ml jj lx b gy px pb l pc pd">all_history_past_df = pd.read_pickle('/Users/davidallen/fpl_python/all_history_past_df_2021_09252020.pickle')</span></pre><p id="60c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唷。我们做到了。</p><p id="0043" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下次见…干杯。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi py"><img src="../Images/32a06430d0617e779adad9bfa129c32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*eFncC5lOjCB3waKIRjTOKw.gif"/></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="592a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，可以考虑报名成为一名媒体成员。每月5美元，让您可以无限制地访问数以千计的Python指南和数据科学文章。如果你使用<a class="ae jg" href="https://deallen7.medium.com/membership" rel="noopener">我的链接</a>注册，我会赚一小笔佣金，不需要你额外付费。</p><div class="is it gp gr iu oh"><a href="https://deallen7.medium.com/membership" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jk gy z fp om fr fs on fu fw ji bi translated">通过我的推荐链接加入媒体-大卫艾伦</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">阅读大卫·艾伦(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">deallen7.medium.com</p></div></div><div class="oq l"><div class="pz l os ot ou oq ov ja oh"/></div></div></a></div></div></div>    
</body>
</html>