<html>
<head>
<title>Space Science with Python — Asteroid Project (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的空间科学——小行星计划(三)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/space-science-with-python-asteroid-project-part-3-d7dc0941a717?source=collection_archive---------57-----------------------#2020-10-02">https://towardsdatascience.com/space-science-with-python-asteroid-project-part-3-d7dc0941a717?source=collection_archive---------57-----------------------#2020-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="65c3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/space-science-with-python" rel="noopener" target="_blank">用Python进行空间科学</a></h2><div class=""/><div class=""><h2 id="5907" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated"><a class="ae kr" href="https://towardsdatascience.com/tagged/space-science-with-python" rel="noopener" target="_blank">系列教程的第23部分</a>继续我们科学项目的第三部分。今天，我们将通过一个测试驱动的开发例子，一步一步地详细介绍。</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/2d0af651df6aece85628a0e694308364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tzN05KQ0SkSh2469"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">照片由<a class="ae kr" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·克洛德</a>在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="8e9c" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">前言</h1><p id="e3eb" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><em class="mw">这是我的Python教程系列“用Python进行空间科学”的第23部分。教程会话中显示的所有代码都上传到</em><a class="ae kr" href="https://github.com/ThomasAlbin/SpaceScienceTutorial" rel="noopener ugc nofollow" target="_blank"><em class="mw">GitHub</em></a><em class="mw">上。尽情享受吧！</em></p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="a712" class="li lj it bd lk ll ne ln lo lp nf lr ls ki ng kj lu kl nh km lw ko ni kp ly lz bi translated">TDD和现在？</h1><p id="5b04" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">上次我们讨论了测试驱动开发的概念，简称:TDD。TDD将帮助我们为我们的项目开发一个Python库，从一开始就确保更少的错误，更高的可靠性(和质量)和可维护性。当然，我们将开发新的数值模拟，并对复杂的“计算链”进行建模，以确定近地天体的可探测性。然而，TDD方法可以很容易地涵盖基本功能，如将物体的视在星等转换为相应的辐照度。</p><div class="nj nk gp gr nl nm"><a rel="noopener follow" target="_blank" href="/asteroid-project-part-2-test-driven-development-ed7af6c1820e"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">小行星计划(第二部分)——测试驱动开发</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">教程系列的第22部分继续我们科学项目的第二部分。在我们深入研究Python之前…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">towardsdatascience.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa lc nm"/></div></div></a></div><p id="38f2" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">每次为每个函数和类提供一步一步的指南完全超出了本系列教程的范围。因此，在这节课中，我们将详细讨论一个例子；供您复制，也适用于任何其他编码相关的问题！</p><p id="eb95" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">请注意:今天我们处理一个相当简单的问题，来了解一下TDD。任何高级Python用户可能会感到厌烦，但是请考虑使用TDD的概念，并将其推广到您可能面临的其他问题！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="1b67" class="li lj it bd lk ll ne ln lo lp nf lr ls ki ng kj lu kl nh km lw ko ni kp ly lz bi translated">让我们深入研究一下</h1><p id="58d9" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在开始任何编码之前，请确保您有一个虚拟Python环境(至少3.8版本)。我还推荐安装一个像<a class="ae kr" href="https://www.spyder-ide.org/" rel="noopener ugc nofollow" target="_blank"> Spyder </a>这样的IDE，以及像<a class="ae kr" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> NumPy </a>、<a class="ae kr" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>、<a class="ae kr" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>、<a class="ae kr" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>等科研工作常用的软件包。您可能会考虑我的第一篇关于设置和安装一些重要包的文章:</p><div class="nj nk gp gr nl nm"><a rel="noopener follow" target="_blank" href="/space-science-with-python-setup-and-first-steps-1-8551334118f6"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">使用Python的空间科学-设置和初步步骤</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">成为公民太空科学家的入门指南</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">towardsdatascience.com</p></div></div><div class="nv l"><div class="og l nx ny nz nv oa lc nm"/></div></div></a></div><p id="934a" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">最后，我们需要一个用于测试的库。<a class="ae kr" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> Unittest </a>是在Python安装中注册的标准测试库。在我们的TDD课程中，我们将使用<em class="mw"> pytest </em>:</p><div class="nj nk gp gr nl nm"><a href="https://docs.pytest.org/en/stable/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">帮助你编写更好的程序</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">pytest和数以千计的其他软件包的维护者正在与Tidelift合作，以提供商业支持和…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">docs.pytest.org</p></div></div></div></a></div><p id="b266" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">首先，我们创建一个Python库文件夹，其“占位符”名为<em class="mw"> mylib </em>。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oh"><img src="../Images/fd55cbc4aae14d703b0e304d4c078504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5edGwdFgrl9v47upl2BmtQ.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="77eb" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">在这个文件夹中，我们需要创建一些文件夹和文件来满足Python库的最低要求。</p><p id="7628" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">首先，我们创建一个名为<em class="mw"> tests </em>的文件夹。<em class="mw"> pytest </em>需要特定的文件夹和文件名来自动识别测试并执行它们。在<em class="mw">测试</em>目录中，Python文件名必须以前缀<em class="mw"> test_ </em>开头，在这些文件中，测试例程/函数也以<em class="mw"> test_ </em>开头。这很容易记忆，也能带来一个干净的测试环境。当然，也可以设置单独的名称和约定，但是在调用<em class="mw"> pytest </em>时需要进行不常见的修改，或者需要编写测试套件的配置文件。</p><p id="8faf" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">添加第二个文件夹，名为<em class="mw">通用</em>。在这个目录中，我们将放置一些可用于库的不同核心功能的生产代码。现在，在这一点上没有理由添加这个文件夹，因为我们还没有进行任何测试。从技术上来说，TDD要求我们在创建任何单元测试之前不要创建代码。创建一个原始的文件夹结构完全没问题。</p><p id="b379" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">最后，我们需要创建<em class="mw"> __init__。py </em>文件，以便Python可以识别这个库的内容。<em class="mw"> mylib </em>的init文件包含信息:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">__init__。mylib中的py/</p></figure><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oh"><img src="../Images/2e2c6562c09d3481a926bdd1c751e748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rr6DneFhQntLcTkkb1p1eQ.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="414b" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">在<em class="mw">中，通用</em>和<em class="mw">测试</em>是相应导入/加载文件的初始化文件。我们在<em class="mw"> general </em>中的第一个脚本应该包含简单的向量运算。文件应为<em class="mw"> vec.py </em>。<em class="mw">测试</em>中对应的测试文件应命名为<em class="mw"> test_general_vec.py </em>。整个目录结构如下所示:</p><pre class="kt ku kv kw gt ok ol om on aw oo bi"><span id="e78d" class="op lj it ol b gy oq or l os ot">mylib<br/>+-- __init__.py<br/>+-- general<br/>|   +-- __init__.py<br/>|   +-- vec.py<br/>+-- tests<br/>|   +-- __init__.py<br/>|   +-- test_general_vec.py</span></pre><p id="3515" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们的第一个任务:我们想要创建一个函数来计算两个向量<em class="mw"> a </em>和<em class="mw"> b: </em>之间的角度<em class="mw"> p </em></p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ou"><img src="../Images/07707d43a2ed512b65807649bd914cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OTf7CzNwFF6TixLEuW6ibQ.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">计算两个向量a和b之间的角度p的方程。图片由作者提供(T. Albin)</p></figure><p id="3774" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们确定了几个相当容易理解的计算步骤:</p><ul class=""><li id="f25e" class="ov ow it mc b md ob mg oc mj ox mn oy mr oz mv pa pb pc pd bi translated">arccos应用于分数</li><li id="417f" class="ov ow it mc b md pe mg pf mj pg mn ph mr pi mv pa pb pc pd bi translated"><em class="mw">分子:</em>两个向量的点积</li><li id="cd55" class="ov ow it mc b md pe mg pf mj pg mn ph mr pi mv pa pb pc pd bi translated"><em class="mw">分母:</em>两个向量的长度(分别称为范数)的乘积。因为我们在几何环境中应用这个方程，所以我们使用欧几里得范数</li></ul><p id="05b8" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们没有为角度计算编写一个单独的单元测试，而是确定了几个“小步骤”,它们可以被分成单独的测试。这允许我们有更大的测试覆盖面，我们有更多的通用函数可以在以后使用！</p><p id="6d7a" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">先说范数函数。我们将其命名为<em class="mw"> vec_norm </em>，并将其放入<em class="mw"> general.vec </em>中。第一个测试覆盖值为[1.0，0.0]的向量。显然，这个向量的欧几里德范数是1:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">测试_通用_vec.py</p></figure><p id="d29e" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们可以在Spyder中使用插件(<a class="ae kr" href="https://www.spyder-ide.org/blog/introducing-unittest-plugin/" rel="noopener ugc nofollow" target="_blank"> Spyder博客文章</a>)或者在终端中执行单元测试。在这次会议中，我们将继续使用终端。在<em class="mw"> mylib </em>中，我们运行<em class="mw"> pytest </em>:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pj"><img src="../Images/d41ae15eb9409dbd433f3c3a1b210567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*025sQuMJUu0bgO5XFU9Hxw.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="2703" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">显然，单元测试失败了。这并不奇怪，因为错误消息指出<em class="mw"> mylib.general.vec </em>中没有“vec_norm”。直到现在，我们没有实现任何东西。所以我们切换到<em class="mw"> mylib.general.vec </em>添加函数。此外，欧几里德范数的计算是相当明显的。没必要假装:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">vec . copy</p></figure><p id="237d" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">现在<em class="mw"> pytest </em>成功了！完美！<em class="mw">我们完成了，对吗？嗯……不。我们的实现只包括二维向量，我们没有测试不太明显的情况。因此，首先，我们添加一些不太明显的测试，并尝试以更通用的方式处理代码:</em></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">测试_通用_vec.py</p></figure><p id="36fd" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">请注意:添加新测试后，需要执行<em class="mw"> pytest </em>！所以在这种情况下，在添加第9/10行和第12/13行之后<em class="mw"> pytest </em>被调用。</p><p id="f309" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">现在，我们在测试程序中添加一个三维向量:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">测试_通用_vec.py</p></figure><p id="9ec4" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated"><em class="mw"> pytest </em>结果:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pj"><img src="../Images/d6a325bf4c161f8da3e8ced9f28b6022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BUAjHWAaAeI4CShj3cQlA.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="05a1" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们在<em class="mw"> vec.py </em>中的方法不是最佳的，只对二维向量有效。让我们尝试一种通用的方法:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">vec . copy</p></figure><p id="7ade" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们完全改变了我们的功能！该函数现在遍历向量元素并对它们的平方结果求和。但是新的重构版本提供了相同的结果吗？这就是TDD显示其优势之一的地方:我们已经编码了一些测试，并且还添加了一个新的测试。没必要担心。如果测试通过:很好。如果测试没有通过:嗯，我们有一个二维向量的工作版本…</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pj"><img src="../Images/46b5d25601019b85671042e78c9b935a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OqbRSAaZSbY1YRCUk9zrmw.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="d28e" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">成功！</p><p id="7d26" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">对于我们的用例，我们将继续使用欧几里德范数。但是由于TDD方法，我们可以很容易地扩展我们的功能，以提供更多的标准功能，如:</p><ul class=""><li id="992b" class="ov ow it mc b md ob mg oc mj ox mn oy mr oz mv pa pb pc pd bi translated">最大模</li><li id="3a3c" class="ov ow it mc b md pe mg pf mj pg mn ph mr pi mv pa pb pc pd bi translated">求和范数</li><li id="e410" class="ov ow it mc b md pe mg pf mj pg mn ph mr pi mv pa pb pc pd bi translated">p范数</li><li id="9849" class="ov ow it mc b md pe mg pf mj pg mn ph mr pi mv pa pb pc pd bi translated">诸如此类…</li></ul><p id="c5d3" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">实际上，p=2的P范数对应的是欧氏范数。因此，让我们更一般化我们的功能！我们添加另一个测试…</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">测试_通用_vec.py</p></figure><p id="abda" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">…失败了，所以我们稍微编辑了一下我们的函数…</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">vec . copy</p></figure><p id="ace2" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">注意:由于我们的第一次测试不包括参数<em class="mw"> norm </em>，我们需要在第3行定义一个默认值(这里:<em class="mw"> p2 </em>),否则第一次测试将会失败。if语句现在检查所请求的向量范数。目前，我们只执行了P规范。随意添加更多的范数例程，如最大范数，否则一个if语句似乎是不必要的。再者，P范数不能是p=0或负数；大于10的值也会成为问题(检查第6行的逻辑)！尝试通过使用TDD方法实现逻辑来改进功能。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pj"><img src="../Images/a55323270755666bf5e3c33efe1c2fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-VdHk0DN8Ga1DKEzSoz0A.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="76d7" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">既然我们已经编写了第一个基于TDD的函数，稍微清理一下有助于我们从长远角度理解代码。<a class="ae kr" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP8 </a>和<a class="ae kr" href="https://numpydoc.readthedocs.io/en/latest/format.html" rel="noopener ugc nofollow" target="_blank"> Numpy Docstrings </a>是创建可理解和可持续代码的可行方法。我们的职能变成了:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">vec . copy</p></figure><p id="71b7" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">同样的清理程序也适用于测试程序。请花一些时间让Python测试脚本PEP8和Numpdy Docstring兼容。</p><p id="dfd1" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们的下一个函数是两个向量的点积。这一次我们稍微加快了这个过程。首先，我们在第22到26行添加一个新的测试函数，并创建一个点积示例。结果由人工决定。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">测试_通用_vec.py</p></figure><p id="f2d8" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">让我们执行<em class="mw"> pytest </em>。它失败了，因为我们还没有这个函数:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pj"><img src="../Images/b92b1f82d40b1d9dc8413512a63b4881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbJPP8z7uAas7hbocCgIiw.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="4327" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们在<em class="mw"> general/vec.py </em>中创建了一个名为<em class="mw"> vec_dotprod </em>的新函数，并实现了这个例程的显而易见的解决方案(第46行)。<em class="mw"> pytest </em>没有失败，两个功能都通过！我们通过第二次和第三次测试来验证该功能，并使用提到的标准来清理该功能。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">第二次清理前的vec.py</p></figure><p id="17b5" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">最后，我们可以定义最后一个函数来计算两个向量之间的夹角。我们调用函数<em class="mw"> vec_angle </em>我们添加了一个测试，当然测试在第一次运行时失败了。因为我们有了等式(见上)，我们就有了显而易见的解决方案，并可以相应地实现它。然而，我们决定以弧度返回角度！</p><p id="4e09" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">角度计算单元测试可能看起来像:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">test_general_vec.py中的第三个函数(在其他两个单元测试下面)</p></figure><p id="1c69" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">我们实现了函数…</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">vec.py的一部分</p></figure><p id="5528" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">…并且<em class="mw"> pytest </em>不返回任何错误。随意添加更多的测试作为练习！看来我们的实现终于完成了。我们做到了，第一个基于TDD方法的编码会话。</p><p id="f88f" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">但是有些东西长此以往可能会成为问题。让我们来看看我们最近的测试结果:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pj"><img src="../Images/2a8a8feff54c9fe6fc1bb0a1e4dd5a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YR-vjGEGGphdY_fUfX4qw.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="0baf" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">默认情况下，<em class="mw"> pytest </em>测试所有函数。所有测试在0.02秒内通过。然而，图像更广泛和复杂的功能，需要几分钟才能通过。当我们不向旧的(已经通过的)函数添加新的单元测试时，我们不希望重新测试所有的函数。那么我们如何才能只执行特定的测试例程呢？</p><p id="f527" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">谢天谢地，<em class="mw"> pytest </em>提供了更多的功能(我强烈推荐文档),允许我们在不执行整个测试目录的情况下测试单个功能。</p><div class="nj nk gp gr nl nm"><a href="https://docs.pytest.org/en/stable/contents.html" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">完整的pytest文档</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">测试中断言的编写和报告</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">docs.pytest.org</p></div></div></div></a></div><p id="f542" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">通过设置所谓的标记，我们可以对单个函数和类执行<em class="mw"> pytest </em>。这些标记是Python装饰器，并且“装饰”每个测试函数。我们的测试套件变成了:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">带标记的test_general_vec.py</p></figure><p id="7e59" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">如您所见，我们导入了<em class="mw"> pytest </em>(第3行)，并分别在第5、24和39行定义了装饰器/标记。现在我们需要在名为<em class="mw"> pytest.ini </em>的配置文件中注册这些标记，该文件存储在我们库的主目录中:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="oi oj l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">mylib/中的pytest.ini</p></figure><p id="eb9c" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">如果没有这个文件，<em class="mw"> pytest </em>例程将调用警告，并提示配置单独设置的标记。</p><p id="f875" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">现在我们只测试一个函数。比方说:<em class="mw"> vec_norm </em>。我们的<em class="mw"> pytest </em>命令变成(其中<em class="mw"> -m </em>表示标记的用法，<em class="mw"> vec_norm </em>是注册的标记名):</p><pre class="kt ku kv kw gt ok ol om on aw oo bi"><span id="439b" class="op lj it ol b gy oq or l os ot">pytest -m vec_norm</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pj"><img src="../Images/4ab5980186fd71e50df805cbc105e5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sx3qe8lcP39uU7VpEAiPsw.png"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">作者图片(T. Albin)</p></figure><p id="132b" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">根据要求，只有1项测试通过，2项被取消选择。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="7974" class="li lj it bd lk ll ne ln lo lp nf lr ls ki ng kj lu kl nh km lw ko ni kp ly lz bi translated">结论与展望</h1><p id="90b7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">测试驱动开发… <em class="mw">看起来很乏味，对吗？</em>嗯……是的。开始时，遵循这种方法需要大量的训练。但是从长远来看，一个人为他的项目创建的功能是一个坚实的基础。经过证明，没有错误(至少对于例子和测试来说)并且可靠。你不需要担心对你的代码可能产生的负面影响。<em class="mw">你改变了什么？还是添加了新的功能？你的同事是否改变了一些东西，而你对结果不确定？</em>没问题:只要执行已经存在的测试程序，你的直觉就会变得可以衡量。</p><h2 id="a94a" class="op lj it bd lk pk pl dn lo pm pn dp ls mj po pp lu mn pq pr lw mr ps pt ly iz bi translated">那么下一步是什么？</h2><p id="4a4f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">从现在开始，我们将开发我们的NEO Python库。我们将从基本功能开始(星等计算、望远镜设置的实施、最新近地天体和模型数据的下载等等)。我们不会像在这个TDD例子中那样广泛地涵盖每个项目步骤。但是，我们将使用TDD来确保代码的一定质量和可靠性。</p><p id="a42c" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">同时，我将考虑一个库名，并为它建立一个额外的GitHub存储库。</p><p id="7aff" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">敬请关注，</p><p id="5560" class="pw-post-body-paragraph ma mb it mc b md ob kd mf mg oc kg mi mj od ml mm mn oe mp mq mr of mt mu mv im bi translated">托马斯</p></div></div>    
</body>
</html>