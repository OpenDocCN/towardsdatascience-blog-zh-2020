<html>
<head>
<title>Walkthrough: Categorizing Fraudulent Credit Card Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">演练:对欺诈性信用卡交易进行分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/categorizing-fraudulent-credit-card-transactions-8c6490645fd7?source=collection_archive---------49-----------------------#2020-11-16">https://towardsdatascience.com/categorizing-fraudulent-credit-card-transactions-8c6490645fd7?source=collection_archive---------49-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="72e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">尝试各种分类器模型并深入研究XG Boost</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7e1b05eabdc9d73cad1b3c568957baa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOdKHI04cFsEgV9dC60Qcw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Pexels.com<a class="ae kv" href="https://www.pexels.com/photo/making-a-payment-with-a-debit-card-4968635/" rel="noopener ugc nofollow" target="_blank">的</a>卡罗琳娜·格拉博斯卡的<a class="ae kv" href="https://www.pexels.com/@karolina-grabowska" rel="noopener ugc nofollow" target="_blank">照片</a></p></figure><p id="d1b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">简介:</strong></p><p id="08d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为Metis数据科学训练营的一名学生，我选择探索欺诈卡交易作为我的第二个个人项目。这个项目有三个需求:用SQL从postgreSQL数据库中查询数据，开发一个分类模型，以及创建一个交互式可视化。我发现postgreSQL和交互式可视化组件相当简单，所以这篇文章的大部分讨论了一个可用模型的开发，但是，我包含了其他两个组件的一些见解和技巧。此外，查看<a class="ae kv" href="https://github.com/josephpcowell/cowell_proj_3" rel="noopener ugc nofollow" target="_blank"> Github库</a>了解项目背后的所有代码。</p><p id="9c63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">背景:</strong></p><p id="1076" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在寻找一些有趣的数据进行分析后，我在Kaggle上偶然发现了<a class="ae kv" href="https://www.kaggle.com/c/ieee-fraud-detection" rel="noopener ugc nofollow" target="_blank">这个比赛</a>。电子商务支付解决方案公司Vesta Corporation收集了一些信息。包含卡交易信息的csv文件，包括交易金额、卡类型、购买浏览器、一些其他各种基本信息，以及该公司设计的但在数据描述中未定义的300多项功能。目标包含在名为“isFraud”的列中，用1定义欺诈交易，用0定义有效交易。与。手里拿着csv文件，是时候将它们放入postgreSQL数据库并将这些信息转化为见解了。</p><p id="5e48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在深入探讨之前，我想先介绍一下这个项目:</p><ul class=""><li id="fd80" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">SQL技能(postgreSQL、SQLAlchemy、Psycopg2)</li><li id="26c8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">分类建模(逻辑回归、XG Boost、随机森林等等)</li><li id="7e07" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">交互式可视化(Streamlit)</li></ul><p id="ec2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤1:使用postgreSQL 🗄 </strong></p><p id="d2ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我前面提到的，这个项目的一个要求是使用SQL来查询数据。将数据放入。csv文件，我可以将它们转换成数据帧，然后放入SQL数据库。</p><p id="d3b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码如下，我将讨论它的全部含义。首先，我阅读了。csv文件转换成数据帧，然后创建一个引擎来连接本地postgreSQL数据库，我将它命名为“project3”。这个SQLAlchemy引擎是整个代码块的关键。它允许jupyter笔记本与postgreSQL交互，并在给定的数据库中创建表。还有，这些。csv文件包含多种类型(对象、整型、浮点型等)。)，而且SQLAlchemy能够解释DataFrame并创建具有相应数据类型的列的方式令人惊叹。此外，它使这个过程比使用命令行快得多(更大。csv文件超过300列)。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="3f48" class="ml mm iq mh b gy mn mo l mp mq"><em class="mr"># First, turn those csv files into DataFrames.</em></span><span id="206a" class="ml mm iq mh b gy ms mo l mp mq">train_identity = pd.read_csv('../Project-3/train_identity.csv')</span><span id="04e8" class="ml mm iq mh b gy ms mo l mp mq">train_transaction = pd.read_csv('../Project-3/train_transaction.csv')</span><span id="16ec" class="ml mm iq mh b gy ms mo l mp mq"># Create a connection to the project3 postgreSQL database.</span><span id="a833" class="ml mm iq mh b gy ms mo l mp mq">engine = create_engine(‘postgresql://[USERNAME]:[PASSWORD]@localhost:5432/project3’)</span><span id="d0dc" class="ml mm iq mh b gy ms mo l mp mq"># Turn the DataFrames into tables in the postgreSQL database</span><span id="1597" class="ml mm iq mh b gy ms mo l mp mq">table_name = 'train_ident'</span><span id="44d8" class="ml mm iq mh b gy ms mo l mp mq">train_identity.to_sql(table_name,<br/>engine,<br/><em class="mr">if_exists</em>='replace',<br/><em class="mr">index</em>=False,<br/><em class="mr">chunksize</em>=500)</span><span id="219c" class="ml mm iq mh b gy ms mo l mp mq">table_name = 'train_trans'</span><span id="45d0" class="ml mm iq mh b gy ms mo l mp mq">train_transaction.to_sql(table_name,<br/>engine,<br/><em class="mr">if_exists</em>='replace',<br/><em class="mr">index</em>=False,<br/><em class="mr">chunksize</em>=500)</span></pre><p id="f14a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是该项目的大部分SQL组件。我不会在这方面做更多的讨论，但我会发布连接两个表的更复杂的SQL查询来进一步研究数据。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="cac5" class="ml mm iq mh b gy mn mo l mp mq">mastercard_full = pd.read_sql(<br/>"""SELECT * FROM train_trans LEFT JOIN train_ident ON train_trans.”TransactionID” = train_ident.”TransactionID” WHERE train_trans.card4=’mastercard’""", <em class="mr">con</em>=engine)</span></pre><p id="b1cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二步:分类建模🎯</strong></p><p id="ce97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着数据成功地存储在postgreSQL数据库中，然后查询到DataFrame中，我从一些基本的EDA开始，并很快理解了我的主要挑战:类不平衡。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/e2b6072e1a1a1f84feb5b19ba76f2273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_bmF6BcJdaQ-GtjnSm7Zg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9b8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阶级不平衡的问题归结到如何决定模型的成功。如果我只关心准确性，我可以预测所有的交易都是有效的，并且有97%的准确性。对于未经训练的人来说，97%的准确率看起来非常理想，但这意味着该模型预测欺诈交易的比例为0%。这个0%的指标被称为召回。回忆回答了这个问题:在所有欺诈交易中，模型正确预测的百分比是多少？另一方面，有效事务的召回将是100%，因为所有有效事务都被正确预测为有效。因为大家都知道问题在于类别不平衡，而目标是预测欺诈性交易，所以衡量成功的标准就变成了欺诈性交易的召回率和整体准确性。</p><p id="ec78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我是如何解决阶级不平衡的问题的呢？有几种方法可以解决类不平衡问题，但我选择关注过采样。我探索的三种方法是RandomOverSampler、SMOTE和ADASYN。这些方法中的每一种都采用少数类并对其进行过采样，直到它与多数类平衡。RandomOverSampler随机复制少数类中的数据点。合成少数过采样技术(SMOTE)在少数类中创建新点，但使用线性插值和K-最近邻，因此它是一种更高级的过采样技术。最后，自适应合成采样(ADASYN)根据密度分布在少数类中创建新点。</p><p id="1935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于代码，实现这些过采样技术非常简单，如下所示。值得注意的是，训练数据是过采样的，然后用于拟合模型，从而得到整体更好的模型。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="b283" class="ml mm iq mh b gy mn mo l mp mq"># RandomOverSampler<br/>ros = RandomOverSampler(<em class="mr">random_state</em>=0)<br/>X_tr_sam, y_tr_sam = ros.fit_sample(X_train,y_train)</span><span id="aa3d" class="ml mm iq mh b gy ms mo l mp mq"># SMOTE<br/>X_smoted, y_smoted = SMOTE(<em class="mr">random_state</em>=42).fit_sample(X_train,y_train)</span><span id="a0db" class="ml mm iq mh b gy ms mo l mp mq"># ADASYN<br/>X_adasyn, y_adasyn = ADASYN(<em class="mr">random_state</em>=42).fit_sample(X_train,y_train)</span></pre><p id="7cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">评估二元分类问题的另一个常用指标是ROC曲线和曲线下面积(AUC)。下面是三条ROC曲线，对应于不同的过度拟合方法和我想要测试的几个分类器模型。很明显，Random Forest和XG Boost是最好的模型，它们也是集合模型，这表明了集合模型在整体上创建更好的模型的卓越质量。</p><div class="kg kh ki kj gt ab cb"><figure class="mu kk mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/8fec7fde843c88a209c47dfc1a4285c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*zg-_oO8P0kVXF8XRPN3lNg.png"/></div></figure><figure class="mu kk mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/f9a60a0f554d4a09bf2676cef90db13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*I7PfFDuUrE5fe6W6GiTKEw.png"/></div></figure><figure class="mu kk mv mw mx my mz paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/48ec49ec5ad260fba1aae43b58b68c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*bPPOwyCDZUIcZAm6IDjnqg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk na di nb nc translated">作者图片</p></figure></div><p id="366e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">利用这些视觉效果和度量标准，为前进创造了更清晰的愿景。我决定用随机过采样来研究XG Boost分类器。此外，值得注意的是，XG Boost的性能比随机森林分类器稍差，但是，我选择XG Boost是因为Kaggler大肆宣传XG Boost，所以我想更深入地研究这种特定类型的建模。</p><p id="9e1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于特性和特性工程，最好查看<a class="ae kv" href="https://github.com/josephpcowell/cowell_proj_3/blob/main/Notebooks/fraud_prediction.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>了解更多信息。关于XG增强，我非常兴奋地调整超参数以增加ROC AUC分数，从而增加模型召回。为了找到最佳的超参数，我查看了<a class="ae kv" href="https://xgboost.readthedocs.io/en/latest/tutorials/param_tuning.html" rel="noopener ugc nofollow" target="_blank">文档</a>，以找到要调整的具体参数。参数max_depth、min_child_weight和gamma与模型复杂度相关，而colsample_bytree和subsample与处理噪声的模型相关。在使用GridSearchCV之后，我找到了这些参数的最优值。GridSearchCV是一个非常密集的过程，所以由于计算机的压力，我分别运行我的参数，同时运行所有的参数可能更好。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="bcdb" class="ml mm iq mh b gy mn mo l mp mq"># Choose the parameters to tune</span><span id="e025" class="ml mm iq mh b gy ms mo l mp mq">cv_params = {'max_depth': [4,5,6], 'min_child_weight': [1,2,3], 'gamma': [0,1,2]}</span><span id="7d64" class="ml mm iq mh b gy ms mo l mp mq"># Run gridsearch</span><span id="8f63" class="ml mm iq mh b gy ms mo l mp mq">xgbc1 = GridSearchCV(<em class="mr">estimator</em>=xgb, <em class="mr">param_grid</em>=cv_params,<em class="mr">scoring</em>=’roc_auc’)</span><span id="a477" class="ml mm iq mh b gy ms mo l mp mq">xgbc1.fit(X_tr_sam, y_tr_sam)</span><span id="1712" class="ml mm iq mh b gy ms mo l mp mq"># Observe the best parameters</span><span id="4c53" class="ml mm iq mh b gy ms mo l mp mq">xgbc1.best_params_<br/>{'gamma': 2, 'max_depth': 6, 'min_child_weight': 1}</span><span id="dda3" class="ml mm iq mh b gy ms mo l mp mq"># Repeat with other parameters</span><span id="4445" class="ml mm iq mh b gy ms mo l mp mq">cv_params = {'subsample': [0.5,0.75,1], 'colsample_bytree': [0.5,0.75,1]}</span><span id="4890" class="ml mm iq mh b gy ms mo l mp mq">fix_params = {'gamma': 2, 'max_depth': 6, 'min_child_weight': 1}</span><span id="3482" class="ml mm iq mh b gy ms mo l mp mq">xgbc = GridSearchCV(<em class="mr">estimator</em>=XGBClassifier(**fix_params), <em class="mr">param_grid</em>=cv_params,<em class="mr">scoring</em>='roc_auc')</span><span id="7662" class="ml mm iq mh b gy ms mo l mp mq">xgbc.fit(X_tr_sam, y_tr_sam)</span><span id="55a6" class="ml mm iq mh b gy ms mo l mp mq">xgbc.best_params_</span><span id="5816" class="ml mm iq mh b gy ms mo l mp mq">{'colsample_bytree': 1, 'subsample': 0.75}</span></pre><p id="aa4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着数据过采样(以对抗阶级不平衡)，特征的选择和设计，以及模型参数的调整，是时候看看结果了。下图结合了ROC曲线和混淆矩阵。混淆矩阵是另一种轻松查看分类模型结果的方式。首先，AUC得分为0.96，比上面ROC曲线中显示的任何模型都好。关于混淆矩阵，很容易看出模型哪里工作得好，哪里不理想。至于这个项目的目标，在1949个欺诈交易中有1589个被正确预测似乎非常好，但是还能做什么呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/1ee47351c61ffe2171cbb043cb7e6741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiwgjVs2TLH1T2fpUn8IQg.png"/></div></div></figure><p id="82a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数(如果不是全部的话)分类模型输出特定预测的概率。通常有一个概率阈值参数，它可以告诉模型在哪里截断正预测。对于XG Boost，我无法找出一种方法来调整模型中的概率阈值，但使用…</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="589b" class="ml mm iq mh b gy mn mo l mp mq">xgb.predict_proba(X_test)</span></pre><p id="1386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…输出一个概率数组，描述有问题的特定点被分类为欺诈的概率。我将重点放在这个预测概率数组上，作为Streamlit应用程序的基础。</p><p id="ff2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第三部分:streamlit应用</strong></p><p id="f834" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.streamlit.io/" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>是一个为编程新手创建应用程序的神奇工具。由于我今年才开始大量编写代码，并重点关注python，因此跳入高级flask、html、d3或任何更深入的开发语言和工具似乎有点超出了这个简短分类项目的范围。幸运的是，作为python程序员，Steamlit非常容易使用，生成的应用程序看起来很专业。</p><p id="03a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序的代码在<a class="ae kv" href="https://github.com/josephpcowell/cowell_proj_3/blob/main/streamlit_app.py" rel="noopener ugc nofollow" target="_blank">这个python文件</a>中，但我将贯穿我最终应用程序的基本概念。如果一家银行要使用这个模型，我想提供一个助手来确定这个模型的概率阈值。由于阈值非常低，所有欺诈性交易都会被正确预测，但许多有效交易会被错误地预测为欺诈。另一方面，更高的概率阈值将导致更多的欺诈交易被分类为有效交易。该应用程序允许银行查看在不同阈值下会发生什么，并选择适合其需求的特定阈值。</p><p id="2f00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个图表显示了召回率和精确度与阈值之间的关系，金色线条代表所选的阈值。第一张图表下方是召回和通过识别欺诈交易节省的金额。在这些数字的更下方是一个混淆矩阵，提供了一个额外的视觉辅助来帮助确定最佳概率阈值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者提供的视频</p></figure><p id="793d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论:📗</strong></p><p id="cd0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在处理分类问题时，类不平衡是一个常见的问题，在处理大型(或小型)数据集时，过采样是解决这个问题的一个很好的方法。另外，python使得用基本代码比较多个模型，然后用GridSearchCV调优超参数变得很容易。这些技术对于数据科学家早期学习非常重要，因为有了这些基础知识，模型改进可以很快完成。现在，我觉得有必要回到我的<a class="ae kv" rel="noopener" target="_blank" href="/predicting-imdb-movie-ratings-using-supervised-machine-learning-f3b126ab2ddb">以前的项目</a>，调整超参数并测试更多的模型，以增加该项目的有效性。无论如何，这里有一些关于这个项目的基本要点:</p><ul class=""><li id="7dd1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">学习SQL！</li><li id="534c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">总是花时间探索数据</li><li id="0181" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">尽早开发一个MVP，并在该模型的基础上进行构建</li><li id="c5c0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Streamlit让创建应用变得简单</li><li id="7051" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">给利益相关者一个容易理解的解决方案或解释</li></ul><p id="7042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看<a class="ae kv" href="https://github.com/josephpcowell/cowell_proj_3" rel="noopener ugc nofollow" target="_blank"> Github仓库</a>以获得关于这个项目的更多信息——我真的喜欢让我的笔记本容易跟随。此外，如果您有任何问题或意见，请联系我们。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="1514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的很喜欢我的数据科学之旅，并希望继续分享我的学习经历。请随意查看<a class="ae kv" rel="noopener" target="_blank" href="/predicting-imdb-movie-ratings-using-supervised-machine-learning-f3b126ab2ddb">关于我的第二个项目</a>的博客，并在我继续探索数据科学世界时回来获取更多更新。</p><p id="0ccd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">伸手:<br/>T5】LinkedIn|<a class="ae kv" href="https://twitter.com/josephpcowell" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div></div>    
</body>
</html>