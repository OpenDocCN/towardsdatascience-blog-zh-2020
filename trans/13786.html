<html>
<head>
<title>Are you using the “Scikit-learn wrapper” in your Keras Deep Learning model?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你在你的Keras深度学习模型中使用了“Scikit-learn wrapper”吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/are-you-using-the-scikit-learn-wrapper-in-your-keras-deep-learning-model-a3005696ff38?source=collection_archive---------6-----------------------#2020-09-22">https://towardsdatascience.com/are-you-using-the-scikit-learn-wrapper-in-your-keras-deep-learning-model-a3005696ff38?source=collection_archive---------6-----------------------#2020-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd92" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Keras的特殊包装类进行超参数调优？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4ac7e037ba053fef95ecd3d4bf25f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRmF_XhObEdI8zTB2wGgQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用开源模板创建的图像</p></figure><h1 id="2c9d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="f9f7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Keras是深度学习领域最受初学者和专业人士欢迎的Python库/API之一。虽然它最初是由弗朗索瓦·乔莱作为一个独立项目开发的，但从2.0版本开始，它已经被原生集成到TensorFlow中。点击 了解更多信息<a class="ae mm" href="https://keras.io/about/" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">。</strong></a></p><p id="595d" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">正如官方文档所说，它是“<em class="ms">一个为人类而不是机器</em>设计的API”，因为它“<em class="ms">遵循了减少认知负荷的最佳实践</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/670858568074e4ef9bb9a64dda88df78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UaRWNoKis9AlmbEAYM-iw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae mm" href="https://pixabay.com/illustrations/thoughts-think-psyche-psychology-551263/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd mu"> Pixabay </strong> </a></p></figure><p id="b33c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">认知负荷肯定会增加的情况之一是<strong class="ls iu">超参数调整</strong>。尽管有这么多支持库和框架来处理它，但对于简单的网格搜索，我们总是可以依赖Keras中的一些内置的好东西。</p><div class="mv mw gp gr mx my"><a href="https://www.jeremyjordan.me/hyperparameter-tuning/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">机器学习模型的超参数调整。</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">当创建一个机器学习模型时，你会看到如何定义你的模型的设计选择…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.jeremyjordan.me</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ks my"/></div></div></a></div><p id="8a67" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在本文中，我们将快速查看一个这样的内部工具，并研究我们可以用它来进行超参数调优和搜索。</p><h1 id="cf62" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">sci kit-学习交叉验证和网格搜索</h1><p id="a312" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">几乎每个Python机器学习实践者都非常熟悉Scikit-learn库和它的<a class="ae mm" href="https://www.tutorialspoint.com/scikit_learn/scikit_learn_estimator_api.htm" rel="noopener ugc nofollow" target="_blank">漂亮的API以及简单的方法</a>，比如<code class="fe nn no np nq b">fit</code>、<code class="fe nn no np nq b">get_params</code>和<code class="fe nn no np nq b">predict</code>。</p><p id="6d3d" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">该库还为<a class="ae mm" href="https://scikit-learn.org/stable/modules/cross_validation.html" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu"/></a><a class="ae mm" href="https://scikit-learn.org/stable/model_selection.html" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu">模型选择</strong></a><a class="ae mm" href="https://scikit-learn.org/stable/tutorial/statistical_inference/putting_together.html" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu">流水线</strong></a><a class="ae mm" href="https://scikit-learn.org/stable/modules/grid_search.html" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu">网格搜索</strong> </a>能力提供了极其有用的方法。如果你环顾四周，你会发现大量使用这些API方法解决经典ML问题的例子。但是对于你遇到的一个深度学习问题，如何使用相同的API呢？</p><div class="mv mw gp gr mx my"><a href="https://stackabuse.com/cross-validation-and-grid-search-for-model-selection-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">Python中模型选择的交叉验证和网格搜索</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">简介典型的机器学习过程包括在数据集上训练不同的模型，并选择一个…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">stackabuse.com</p></div></div><div class="nh l"><div class="nr l nj nk nl nh nm ks my"/></div></div></a></div><blockquote class="ns"><p id="4c4e" class="nt nu it bd nv nw nx ny nz oa ob ml dk translated">认知负荷肯定会增加的情况之一是超参数调整。</p></blockquote><h2 id="b49c" class="oc kz it bd la od oe dn le of og dp li lz oh oi lk md oj ok lm mh ol om lo on bi translated">当Keras与Scikit-learn纠缠在一起时</h2><p id="d7ed" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Keras提供了几个<strong class="ls iu">特殊的包装类</strong>——都是为了回归和分类问题——来充分利用这些Scikit-learn自带的API的全部功能。</p><p id="ce7e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在本文中，让我向您展示一个使用简单的<a class="ae mm" href="https://medium.com/datadriveninvestor/k-fold-cross-validation-6b8518070833" rel="noopener"> k-fold交叉验证</a>和穷举网格搜索以及<a class="ae mm" href="https://www.tensorflow.org/api_docs/python/tf/keras/wrappers/scikit_learn/KerasClassifier" rel="noopener ugc nofollow" target="_blank"> Keras分类器模型</a>的例子。它利用了针对Keras的Scikit-learn分类器API的实现。</p><p id="bd4a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Jupyter笔记本演示可以在我的Github repo 中找到<a class="ae mm" href="https://github.com/tirthajyoti/Deep-learning-with-Python/blob/master/Notebooks/Keras_Scikit_Learn_wrapper.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="662f" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">从模型生成函数开始</h2><p id="68d6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了正常工作，我们应该创建一个简单的函数来合成和编译带有一些内置可调参数的Keras模型。这里有一个例子，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/55363e073be0534c17f7d00251bde66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*RI29EvFR5eItcObsvLZd5w.png"/></div></figure><h2 id="5bed" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">数据</h2><p id="33ef" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">对于这个演示，我们使用的是流行的<a class="ae mm" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">皮马印第安人糖尿病</strong> </a>。这个数据集最初来自国家糖尿病、消化和肾脏疾病研究所。数据集的目的是基于数据集中包含的某些诊断测量结果，诊断性地预测患者是否患有糖尿病。所以，这是一个二元分类任务。</p><ul class=""><li id="8265" class="ou ov it ls b lt mn lw mo lz ow md ox mh oy ml oz pa pb pc bi translated">我们创建特征和目标向量— <code class="fe nn no np nq b">X</code>和<code class="fe nn no np nq b">Y</code></li><li id="87bd" class="ou ov it ls b lt pd lw pe lz pf md pg mh ph ml oz pa pb pc bi translated">我们使用Scikit的缩放API来缩放特征向量——像<code class="fe nn no np nq b">MinMaxScaler</code>一样学习。我们称之为<code class="fe nn no np nq b">X_scaled</code>。</li></ul><p id="16f2" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">数据预处理到此为止。我们可以将这个<code class="fe nn no np nq b">X_scaled</code>和<code class="fe nn no np nq b">Y</code>直接传递给特殊类，我们将在下一步构建。</p><blockquote class="ns"><p id="ce70" class="nt nu it bd nv nw pi pj pk pl pm ml dk translated">Keras提供了几个<strong class="ak">特殊的包装类</strong>——都是为了回归和分类问题——来充分利用这些Scikit-learn自带的API的全部功能。</p></blockquote><h2 id="54bd" class="oc kz it bd la od oe dn le of og dp li lz oh oi lk md oj ok lm mh ol om lo on bi translated">KerasClassifier类</h2><p id="5c81" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这是来自Keras的特殊包装类，它将Scikit-learn分类器API与Keras参数模型结合在一起。我们可以传递与<code class="fe nn no np nq b">create_model</code>函数对应的各种模型参数，以及其他超参数，比如epochs和batch size。</p><p id="e5b7" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这是我们如何创造它，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/ab12dbe5a46b62adb49d389bb5a676ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*G75jUYmGh8_zUP_3Fg4pkA.png"/></div></figure><p id="9166" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">请注意，我们是如何将模型创建函数作为<code class="fe nn no np nq b"><strong class="ls iu">build_fn</strong></code>参数传递的。这是一个<a class="ae mm" href="https://dbader.org/blog/python-first-class-functions" rel="noopener ugc nofollow" target="_blank">使用函数作为Python </a>中一级对象的例子，在这里你可以将函数作为常规参数传递给其他类或函数。</p><div class="mv mw gp gr mx my"><a href="https://dbader.org/blog/python-first-class-functions" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">Python的函数是一流的——dbader.org</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">Python的函数是一级对象。你可以将它们赋给变量，存储在数据结构中，传递它们…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">dbader.org</p></div></div><div class="nh l"><div class="po l nj nk nl nh nm ks my"/></div></div></a></div><p id="4730" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">现在，我们已经确定了批量大小和我们想要运行模型的时期数，因为我们只想在这个模型上运行交叉验证。稍后，我们将这些作为超参数，并进行网格搜索以找到最佳组合。</p><h2 id="f2c3" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">10重交叉验证</h2><p id="dcdb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">使用Scikit-learn API可以轻松构建10重交叉验证估计器。这是代码。请注意我们是如何从Scikit-learn的<code class="fe nn no np nq b">model_selection</code> S模块导入估算器的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/151349b436bf46f7bf1f49fb4d12ad20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*zwlDLQhVQXw3--0xzZt82A.png"/></div></figure><p id="fa45" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">然后，我们可以简单地用这段代码运行模型，在这里我们传递我们之前构建的<code class="fe nn no np nq b">KerasClassifier</code>对象以及特征和目标向量。这里重要的参数是我们传递上面构建的<code class="fe nn no np nq b">kfold</code>对象的<code class="fe nn no np nq b">cv</code>。这告诉<code class="fe nn no np nq b">cross_val_score</code>估算者在10重分层交叉验证设置中使用提供的数据运行Keras模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/551f0ce4681501d7189bc630ad8754e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*cnZRvXvdPFYuzboHIkQhGA.png"/></div></figure><p id="3f42" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">输出<code class="fe nn no np nq b">cv_results</code>是所有准确度分数的简单Numpy数组。为什么是准确性？因为这是我们在模型编译过程中选择的度量标准。我们可以选择任何其他分类标准，如精确度、召回率等。并且，在这种情况下，该度量将被计算并存储在<code class="fe nn no np nq b">cv_results</code>数组中。</p><pre class="kj kk kl km gt pr nq ps pt aw pu bi"><span id="62e0" class="oc kz it nq b gy pv pw l px py">model.compile(loss='binary_crossentropy', <br/>                  optimizer='adam', <br/>                  metrics=['<strong class="nq iu">accuracy</strong>'])</span></pre><p id="b762" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我们可以很容易地计算10倍CV运行的平均值和标准偏差，以估计模型预测的稳定性。这是交叉验证运行的主要工具之一。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/40c21f60dc85b6a96b8327b8d802ed78.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*zpQSar4jjbC7-hWMAEcC6A.png"/></div></figure><h2 id="a68d" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">增强网格搜索的模型创建功能</h2><p id="6a1c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">穷举(或随机化)网格搜索通常是超参数调整或深入了解机器学习模型工作的常见做法。被赋予了大量超参数的深度学习模型是这种系统搜索的主要候选对象。</p><p id="51bd" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在本例中，我们将搜索以下超参数，</p><ul class=""><li id="31ef" class="ou ov it ls b lt mn lw mo lz ow md ox mh oy ml oz pa pb pc bi translated"><strong class="ls iu"> <em class="ms">激活功能</em> </strong></li><li id="5509" class="ou ov it ls b lt pd lw pe lz pf md pg mh ph ml oz pa pb pc bi translated"><strong class="ls iu"> <em class="ms">优化器类型</em> </strong></li><li id="138e" class="ou ov it ls b lt pd lw pe lz pf md pg mh ph ml oz pa pb pc bi translated"><strong class="ls iu"> <em class="ms">初始化方法</em> </strong></li><li id="79b2" class="ou ov it ls b lt pd lw pe lz pf md pg mh ph ml oz pa pb pc bi translated"><strong class="ls iu"> <em class="ms">批量</em> </strong></li><li id="f9f1" class="ou ov it ls b lt pd lw pe lz pf md pg mh ph ml oz pa pb pc bi translated"><strong class="ls iu"> <em class="ms">历元数</em> </strong></li></ul><p id="abc9" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">不用说，我们必须将前三个参数添加到我们的模型定义中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/d1cfc8fc7fa7707e970a50cd0f86d8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q51Lmm1kY1E9-iD2nYJnjw.png"/></div></div></figure><p id="18e0" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">然后，我们创建和以前一样的<code class="fe nn no np nq b">KerasClassifier</code>对象，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/5acfee39ce5e029d0985bfb4d7432d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*KL1KSAztfxGS6L2dl2St8A.png"/></div></figure><h2 id="47ef" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">搜索空间</h2><p id="222e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们决定使穷举超参数搜索空间大小为3×3×3×3=243。</p><p id="6cff" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">请注意，Keras运行的<strong class="ls iu">实际数量也将取决于我们选择的交叉验证</strong>的数量，因为交叉验证将用于这些组合中的每一个。</p><p id="1971" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">以下是选择，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/4f7c22ad6f0a403d473fd6efcd08fb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*ZfErXUdE7TR6dZ5JTVfbqg.png"/></div></figure><p id="a4dd" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">要搜索的维度太多了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/aaf23d0f5cb9e3d3cbc6debabc20aca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Wu0AdIucBUXVzXOj3rLgA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae mm" href="https://pixabay.com/illustrations/fractal-complexity-mathematical-1906796/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd mu"> Pixabay </strong> </a></p></figure><h2 id="3272" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">用Keras学习GridSearchCV</h2><p id="f300" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们必须创建一个搜索参数字典，并将其传递给Scikit-learn <code class="fe nn no np nq b">GridSearchCV</code>估计器。这是代码，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/9812101a78cb0c2385d6b523014e95af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*0wGmImwknC7Q7FzS3zwd9g.png"/></div></figure><p id="c840" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">默认情况下，如果没有明确指定<code class="fe nn no np nq b">cv</code>参数，GridSearchCV会运行5重交叉验证(从Scikit-learn v0.22开始)。这里，我们将它保持在3，以减少总运行次数。</p><p id="1774" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">建议将<code class="fe nn no np nq b">GridSearchCV</code>的详细程度设置为2，以保持对正在发生的事情的可视化跟踪。<strong class="ls iu">记住保留</strong> <code class="fe nn no np nq b"><strong class="ls iu">verbose=0</strong></code> <strong class="ls iu">作为主</strong> <code class="fe nn no np nq b"><strong class="ls iu">KerasClassifier</strong></code> <strong class="ls iu">类虽然</strong>，因为你可能不想显示训练单个时代的所有血淋淋的细节。</p><h2 id="5bf4" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">然后，就合体了！</h2><p id="79e3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当我们都开始欣赏Scikit-learn漂亮统一的API时，是时候调用这种能力，只需说<code class="fe nn no np nq b">fit</code>就可以搜索整个空间了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/548deeeea911aca17fe3a24ab79e6de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*KAx9mR_rxWTWkAwL-BB0wg.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/97bf852a99e25d0925a4c4a727c32fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TK0JDyxSe7t7GKui1skuQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae mm" href="https://pixabay.com/illustrations/woman-coffee-mug-coffee-mug-902214/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd mu"> Pixabay </strong> </a></p></figure><p id="350e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">喝杯咖啡，因为这可能需要一段时间，具体取决于深度学习模型架构、数据集大小、搜索空间复杂性和您的硬件配置。</p><p id="a206" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">总共将有729个模型拟合，243个参数组合中的每一个都有3次交叉验证运行。</p><p id="46f7" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如果你不喜欢全网格搜索，你可以随时尝试Scikit-learn stable的随机网格搜索！</p><p id="f689" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">结果看起来怎么样？正如您对Scikit-learn估算器的期望一样，为您的探索存储了所有好东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/c96792159f972f4a08bfadad45b934c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*Z5DW00_jBBdAj-RUiRgO4A.png"/></div></figure><h1 id="6891" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">你能对结果做什么？</h1><p id="d6dd" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您可以根据您的研究兴趣或业务目标，以多种方式探索和分析结果。</p><h2 id="920b" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">最佳精度的组合是什么？</h2><p id="6c27" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这可能是你最关心的问题。只需使用来自<code class="fe nn no np nq b">GridSearchCV</code>估算器的<code class="fe nn no np nq b">best_score_</code>和<code class="fe nn no np nq b">best_params_</code>属性将其打印出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/39d0a5fdcfa4e2a19ff32f8e761a4dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_H9Zm7PlkGOscYCeT33-Yg.png"/></div></div></figure><p id="efb3" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我们使用<a class="ae mm" href="https://machinelearningmastery.com/rectified-linear-activation-function-for-deep-learning-neural-networks/" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu">ReLU activation</strong></a>和<a class="ae mm" rel="noopener" target="_blank" href="/adam-latest-trends-in-deep-learning-optimization-6be9a291375c"><strong class="ls iu">Adam optimizer</strong></a>做了最初的10重交叉验证，得到的平均准确率为0.691。在进行彻底的网格搜索后，我们发现<a class="ae mm" href="https://stats.stackexchange.com/questions/330559/why-is-tanh-almost-always-better-than-sigmoid-as-an-activation-function" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu">tanh activation</strong></a>和<a class="ae mm" rel="noopener" target="_blank" href="/understanding-rmsprop-faster-neural-network-learning-62e116fcf29a"><strong class="ls iu">rms prop optimizer</strong></a>可能是解决这个问题的更好选择。我们有更好的准确性！</p><h2 id="8429" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">提取数据帧中的所有结果</h2><p id="630a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">很多时候，我们可能希望在广泛的超参数下分析深度学习模型性能的统计性质。为此，从网格搜索结果中创建一个熊猫数据框架并进一步分析它们是非常容易的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/aa0ff8ed5cd3f7a0ee6851643b43a677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*D1QGOuCp2RUQDhdh8Vq7tA.png"/></div></figure><p id="5a5a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这是结果，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qj"><img src="../Images/f52d0d8fdbd1071760d8b7686f1952c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ETMy2HfrZXPQQLqRZYaYQ.png"/></div></div></figure><h2 id="c4ff" class="oc kz it bd la od oo dn le of op dp li lz oq oi lk md or ok lm mh os om lo on bi translated">视觉分析</h2><p id="3b66" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们可以从这个数据集创建漂亮的可视化效果，来检查和分析选择什么样的超参数可以提高性能并减少变化。</p><p id="390a" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这是一组使用Seaborn从网格搜索数据集中创建的平均精确度的小提琴图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qk"><img src="../Images/54d9e4f12e62e7f385d0f18a3f7ad087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UX5GawF42-7E7T69XW_hmA.png"/></div></div></figure><p id="cca7" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这是另一个情节，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ql"><img src="../Images/431350b43adbb874074fa365d46fafcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-QXTN_a1iKLIQW6COQIbA.png"/></div></div></figure><blockquote class="ns"><p id="7e8e" class="nt nu it bd nv nw nx ny nz oa ob ml dk translated">…从网格搜索结果中创建熊猫数据框架并对其进行进一步分析非常容易。</p></blockquote><h1 id="e9ef" class="ky kz it bd la lb lc ld le lf lg lh li jz qm ka lk kc qn kd lm kf qo kg lo lp bi translated">总结和进一步的思考</h1><p id="9655" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在本文中，我们介绍了如何使用Keras库提供的强大的Scikit-learn包装器API来进行10重交叉验证和超参数网格搜索，以实现二进制分类问题的最佳准确性。</p><p id="53c5" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">使用该API，可以融合基于Scikit-learn的通用ML管道和Keras模型的最佳工具和技术。这种方法无疑具有巨大的潜力，可以节省从业者为交叉验证、网格搜索、Keras模型管道化编写定制代码的大量时间和精力。</p><p id="d137" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">同样，这个例子的<a class="ae mm" href="https://github.com/tirthajyoti/Deep-learning-with-Python/blob/master/Notebooks/Keras_Scikit_Learn_wrapper.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">演示代码可以在这里</strong> </a>找到。其他相关深度学习教程可以在<a class="ae mm" href="https://github.com/tirthajyoti/Deep-learning-with-Python" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">同库</strong> </a>中找到。如果您愿意，请随意启动和分叉该存储库。</p></div><div class="ab cl qp qq hx qr" role="separator"><span class="qs bw bk qt qu qv"/><span class="qs bw bk qt qu qv"/><span class="qs bw bk qt qu"/></div><div class="im in io ip iq"><p id="5470" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi qw translated"><span class="l qx qy qz bm ra rb rc rd re di"> Y </span>你可以查看作者的<a class="ae mm" href="https://github.com/tirthajyoti?tab=repositories" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu"> GitHub </strong> </a> <strong class="ls iu">知识库</strong>中的代码、思想和机器学习和数据科学方面的资源。如果你和我一样，对人工智能/机器学习/数据科学充满热情，请随时<a class="ae mm" href="https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/" rel="noopener ugc nofollow" target="_blank">在LinkedIn上添加我</a>或<a class="ae mm" href="https://twitter.com/tirthajyotiS" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a>。</p><div class="mv mw gp gr mx my"><a href="https://www.linkedin.com/in/tirthajyoti-sarkar-2127aa7/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">Tirthajyoti Sarkar - Sr .首席工程师-半导体、人工智能、机器学习- ON…</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">通过写作使数据科学/ML概念易于理解:https://medium.com/@tirthajyoti开源和…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.linkedin.com</p></div></div><div class="nh l"><div class="rf l nj nk nl nh nm ks my"/></div></div></a></div></div></div>    
</body>
</html>