<html>
<head>
<title>Hands-on Machine Learning in Python — Decision Tree Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的动手机器学习—决策树分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hands-on-machine-learning-in-python-decision-tree-classification-eba67a37a39c?source=collection_archive---------43-----------------------#2020-10-12">https://towardsdatascience.com/hands-on-machine-learning-in-python-decision-tree-classification-eba67a37a39c?source=collection_archive---------43-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0cc72b8fdea49c8f713bc099ada2c8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xELBvqxtvJ3nYiZaY_b6_A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/fietzfotos-6795508/" rel="noopener ugc nofollow" target="_blank"> fietzfotos </a>在<a class="ae jg" href="https://pixabay.com/photos/landscape-tree-bench-park-meadow-5591270/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="9a5c" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">实现决策树模型的完整工作流程</h2></div><p id="08ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为最流行的经典机器学习算法之一，决策树在可解释性方面比其他算法更直观。今天，在本文中，我将向您展示实现决策树分类模型的整个工作流程。</p><p id="741b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">机器学习任务的典型工作流程通常始于数据争论，因为我们最初获得的数据通常无法直接使用。这就是所谓的原始数据。典型的工作流程通常如下。</p><ol class=""><li id="51ac" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">问题陈述</li><li id="1632" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">探索性数据分析</li><li id="fc17" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">数据清理</li><li id="c5f1" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">特征工程</li><li id="7870" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">模特培训</li><li id="ca01" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">模型评估</li></ol><p id="7f36" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，工作流程可能不是线性的。比如有时候在我们做了模型评估之后，模型的表现并不是很好，我们还有其他的想法可以尝试。然后，我们可能会回到第3-5步中的任何一步，应用我们的想法来改进模型。</p><p id="b1bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将以线性方式展示这些步骤。我假设你已经知道什么是决策树，以及它是如何工作的。然而，如果没有，我写了许多文章来介绍决策树模型的直觉。如果需要的话，请在本文末尾查看它们。</p><h1 id="3112" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">1.问题陈述</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/41b76e34e040b64dca853e6d41434b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2XNf7FP564eDVUpOqMNAzA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/pixel2013-2364555/" rel="noopener ugc nofollow" target="_blank"> pixel2013 </a>在<a class="ae jg" href="https://pixabay.com/photos/ship-wreck-old-rust-stranded-3401500/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="8fde" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">泰坦尼克号生存数据集在数据科学领域很有名，也被认为是Kaggle的“第一课”。当然，很多优秀的解都可以很好的预测存活数，事实证明决策树并不是最好的解。但是，这并不妨碍我们使用这个数据集作为例子来训练我们的决策树分类模型。</p><p id="f7ba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集可以在Kaggle中找到，可以免费下载。</p><div class="is it gp gr iu ne"><a href="https://www.kaggle.com/c/titanic/data" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jk gy z fp nj fr fs nk fu fw ji bi translated">泰坦尼克号:机器从灾难中学习</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">从这里开始！预测泰坦尼克号上的生存并熟悉ML基础知识</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">www.kaggle.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ja ne"/></div></div></a></div><p id="5829" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们将只使用<code class="fe nt nu nv nw b">train.csv</code>。<code class="fe nt nu nv nw b">test.csv</code>用于提交你的预测结果，因为Kaggle是用于比赛目的的。<code class="fe nt nu nv nw b">gender_submission.csv</code>与机器学习模型无关，请忽略。</p><p id="fc53" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集的说明，包括变量、训练/测试集等。可以在上面的链接中找到，还有可下载的数据集。</p><p id="9f1a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在实践中，给定原始数据集的所有信息可能不够清楚。知道问题是“预测生存”是远远不够的。可能有必要与数据所有者和其他利益相关者召开研讨会。</p><p id="4ee4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相信我，阐明一个数据集不是一件容易的工作。大多数时候，我们可能不得不在没有100%理解的情况下开始处理数据集，因为有时这是不可能的。</p><h1 id="1aa1" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">2.探索性数据分析</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2a33a960e5f026619968697c4835d6fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxGaSKbXonPyJcKlgcfnOg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/julius_silver-4371822/" rel="noopener ugc nofollow" target="_blank"> Julius_Silver </a>在<a class="ae jg" href="https://pixabay.com/photos/portugal-algarve-benagil-caves-3029665/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="2aed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">EDA的成果并不直接用于模型训练，但也不可忽视。我们需要详细了解数据集，以便于数据清洗和特征选择。</p><p id="8850" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我将展示一些基本的和常用的EDA。</p><h2 id="a6cb" class="nx mj jj bd mk ny nz dn mo oa ob dp ms lh oc od mu ll oe of mw lp og oh my oi bi translated">数据预览</h2><p id="6a41" class="pw-post-body-paragraph ky kz jj la b lb oj kk ld le ok kn lg lh ol lj lk ll om ln lo lp on lr ls lt im bi translated">在一切之前，我们通常想知道数据集是什么样子的。然而，数据集太大以至于我们无法完全打印出来的情况并不少见。有一个简单的函数<code class="fe nt nu nv nw b">head()</code>可以预览前5行。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="6ebe" class="nx mj jj nw b gy os ot l ou ov">df_train.head()</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/7ef1cb9b8af3ee6356befafad7861298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjkHZqv69tDX_gWxrTB3Gw.png"/></div></div></figure><h2 id="c254" class="nx mj jj bd mk ny nz dn mo oa ob dp ms lh oc od mu ll oe of mw lp og oh my oi bi translated">数据剖析</h2><p id="1b96" class="pw-post-body-paragraph ky kz jj la b lb oj kk ld le ok kn lg lh ol lj lk ll om ln lo lp on lr ls lt im bi translated">Pandas为我们提供了一个非常方便的功能来分析我们拥有的数据框架。简单调用数据框的<code class="fe nt nu nv nw b">info()</code>函数如下。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="ab41" class="nx mj jj nw b gy os ot l ou ov">df_train.info()</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/6558734cf9d3b02ec2ca5d3f36967a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*tbxb2I2DXR4BNk20SZUDqA.png"/></div></figure><h2 id="d01c" class="nx mj jj bd mk ny nz dn mo oa ob dp ms lh oc od mu ll oe of mw lp og oh my oi bi translated">特征统计</h2><p id="1fc9" class="pw-post-body-paragraph ky kz jj la b lb oj kk ld le ok kn lg lh ol lj lk ll om ln lo lp on lr ls lt im bi translated">检查特征的统计数据也非常重要。熊猫数据框也可以很容易地为我们做到这一点。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="7813" class="nx mj jj nw b gy os ot l ou ov">df_train.describe()</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/f6be82399c464c10e46ecafa4a35f08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wpAQ_qHZyImIDDd3tDWXQ.png"/></div></div></figure><p id="161c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nt nu nv nw b">describe()</code>功能将自动选择数字特征并为我们计算它们的统计数据。然而，如果我们也想得到这些分类的或字符串类型的特征的图片呢？我们可以在<code class="fe nt nu nv nw b">describe()</code>函数中使用<code class="fe nt nu nv nw b">include</code>参数，并显式传入一个对象类型列表，如下所示。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="f0e5" class="nx mj jj nw b gy os ot l ou ov">df_train.describe(include=['O'])</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/04d482b773dbf9898bf1476177c3cd48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*71KyK2P6Hvx1ts2d2vbajA.png"/></div></figure><p id="46e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，类型<code class="fe nt nu nv nw b">'O'</code>是指字符串类型。在Pandas中，默认情况下，没有变量会被读取为分类变量，除非您明确要求它这样做。如果您真的有任何分类类型的列(可以在数据配置文件中找到)，您还需要在列表中传递<code class="fe nt nu nv nw b">'categorical'</code>。</p><h2 id="7595" class="nx mj jj bd mk ny nz dn mo oa ob dp ms lh oc od mu ll oe of mw lp og oh my oi bi translated">EDA成果</h2><p id="4e43" class="pw-post-body-paragraph ky kz jj la b lb oj kk ld le ok kn lg lh ol lj lk ll om ln lo lp on lr ls lt im bi translated">在实践中，您可能需要为EDA执行更多的任务，例如绘制直方图中的特征以查看它们的分布或获取相关矩阵等等。本文将在此停止，因为它意味着向您展示在EDA中做什么类型的事情。</p><p id="0b7b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成上述EDA任务后，我们发现了一些需要在数据清理阶段解决的问题。</p><ul class=""><li id="1ef5" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt pa ma mb mc bi translated">在<code class="fe nt nu nv nw b">Age</code>、<code class="fe nt nu nv nw b">Cabin</code>和<code class="fe nt nu nv nw b">Embarked</code>栏中有一些缺失的数据。</li><li id="6d8a" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">在那些有缺失数据的列中，<code class="fe nt nu nv nw b">Age</code>是数值型的，而<code class="fe nt nu nv nw b">Cabin</code>和<code class="fe nt nu nv nw b">Embarked</code>是分类型的。</li><li id="aba0" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated"><code class="fe nt nu nv nw b">Age</code>和<code class="fe nt nu nv nw b">Embarked</code>有很少的缺失值，而<code class="fe nt nu nv nw b">Cabin</code>有大部分的缺失值。</li></ul><h1 id="d4f5" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">3.数据清理</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e6adf8f22e2a30008da48d5f3050cd59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsLC2ruXUKt-rSF_BtCsog.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/sztrapacska74-8968314/" rel="noopener ugc nofollow" target="_blank"> Sztrapacska74 </a>在<a class="ae jg" href="https://pixabay.com/photos/kitten-cat-4274170/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="d96a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们先来看一下<code class="fe nt nu nv nw b">Age</code>栏。我们可以首先仔细检查是否有缺少的带有年龄的数据条目。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="9899" class="nx mj jj nw b gy os ot l ou ov">df_train[df_train['Age'].isna()].head()</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/3d6e8941f89f5580903187d46bec5d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f2EGovZqh5avqSqxT8o5fQ.png"/></div></div></figure><p id="5205" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有许多方法可以修复数据缺口，例如</p><ul class=""><li id="ab7f" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt pa ma mb mc bi translated">如果有任何缺失，请删除整行</li><li id="9901" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">保持原样(对于某些类型的机器学习算法，空值会导致问题。因此，此选项将不适用)</li><li id="bef3" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">用平均值填补空白(仅适用于数值变量)</li><li id="a65b" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">用模式值填补空白(适用于数值和分类变量)</li><li id="21c6" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated">定制的间隙填充算法(可能非常复杂，例如使用另一个机器学习模型来预测缺失值)</li></ul><p id="faea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，让我们采取相对简单的方法。也就是说，使用平均值填充数值列，然后使用模式填充分类值。</p><p id="c79e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要用均值填充<code class="fe nt nu nv nw b">Age</code>缺失数据，我们可以如下操作。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="c48b" class="nx mj jj nw b gy os ot l ou ov">df_train['Age'] = df_train['Age'].fillna(df_train['Age'].mean())</span></pre><p id="40ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<code class="fe nt nu nv nw b">Embarked</code>列，我们用模式值来填充。这里我们不需要再次寻找模式，因为<code class="fe nt nu nv nw b">describe(include=['O'])</code>已经告诉我们<code class="fe nt nu nv nw b">'S'</code>具有最大的频率，即889个条目中的644个。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/79abae30716adb662abe186bc41886b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*f9Eg7x-zzgT5gIraDkMXhA.png"/></div></figure><p id="3c83" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，让我们使用<code class="fe nt nu nv nw b">'S'</code>来填充<code class="fe nt nu nv nw b">Embarked</code>列中的空值。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="7aca" class="nx mj jj nw b gy os ot l ou ov">df_train['Embarked'] = df_train['Embarked'].fillna('S')</span></pre><p id="5402" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，对于<code class="fe nt nu nv nw b">Cabin</code>栏，有超过70%的缺失。这是绝对不能填补的。事实上，对于这样的专栏，我想暂时忽略它。换句话说，我们不会用它来进行模型训练。</p><h1 id="6d20" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">4.特征工程</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/52927a29749d6c8fbbde4655ddd3e803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GcL_o-fFUL3i6IcEJqqwA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/users/silviarita-3142410/" rel="noopener ugc nofollow" target="_blank">西尔维娅丽塔</a>在<a class="ae jg" href="https://pixabay.com/photos/tray-breakfast-muesli-fruit-fruits-2546077/" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄的照片</p></figure><p id="66c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">特征工程对于训练一个机器学习模型是非常重要的一步，尤其是对于经典的机器学习算法(不是深度学习)。有时它占据了整个工作流的大部分时间，因为我们可能需要多次重新访问这个阶段来提高模型的性能。</p><p id="747e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的数据集中，首先我们需要识别一些不可用或无用的特征。</p><ul class=""><li id="d0e8" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt pa ma mb mc bi translated"><code class="fe nt nu nv nw b">PassengerId</code>特性需要被拒绝，因为它没有用</li><li id="6d5c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated"><code class="fe nt nu nv nw b">Name</code>功能也应该被拒绝，因为它对乘客能否幸存没有任何影响。</li><li id="3e41" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated"><code class="fe nt nu nv nw b">Cabin</code>特征可以被拒绝，因为有超过70%的缺失。</li><li id="5ced" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pa ma mb mc bi translated"><code class="fe nt nu nv nw b">Ticket</code>特性也应该被拒绝，因为它在EDA中没有显示任何模式。他们只是另一种“身份”。</li></ul><p id="f2a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于其余的特性:<code class="fe nt nu nv nw b">Pclass</code>、<code class="fe nt nu nv nw b">Sex</code>、<code class="fe nt nu nv nw b">Age</code>、<code class="fe nt nu nv nw b">SibSp</code>、<code class="fe nt nu nv nw b">Parch</code>、<code class="fe nt nu nv nw b">Fare</code>、<code class="fe nt nu nv nw b">Embarked</code>，它们似乎都很有用，我们应该选择它们。因为我们将使用决策树，所以如果有任何对模型没有帮助的特征，它们将不太可能被选择来分割树节点。让算法告诉我们。</p><p id="94da" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，让我们构建我们的要素数据框和标注系列。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="5f7c" class="nx mj jj nw b gy os ot l ou ov">features = ['Pclass', 'Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'Embarked']</span><span id="1acc" class="nx mj jj nw b gy pd ot l ou ov">label = 'Survived'</span><span id="afbb" class="nx mj jj nw b gy pd ot l ou ov">df_train_features = df_train[features]</span><span id="a93f" class="nx mj jj nw b gy pd ot l ou ov">s_train_label = df_train[label]</span></pre><h1 id="026c" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">5.模特培训</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/deecf78839fb52b39ec75a6b18ebd7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bbpzTS9T0cuKXJKv0EfAw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/stevepb-282134/" rel="noopener ugc nofollow" target="_blank"> stevepb </a>在<a class="ae jg" href="https://pixabay.com/photos/dumbbells-training-fitness-gym-2465478/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="c544" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以使用这些特征来训练我们的模型。然而，由于我们将使用Sci-kit学习库，并且其决策树算法不接受字符串类型的分类值，因此我们必须对我们的特征数据集进行一次热编码。具体来说，我们的<code class="fe nt nu nv nw b">Sex</code>和<code class="fe nt nu nv nw b">Embarked</code>特征是字符串类型的，需要转换成数字。</p><p id="ec00" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码是数据预处理中最重要的技术之一，值得另写一篇文章来介绍。因此，在本文中，我们将跳过一个热门编码的讲座。如果你不明白它是什么，你将能够在网上获得许多优秀的教程。</p><p id="3f09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，让我们从Sci-kit学习库中导入One Hot编码器。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="bbb1" class="nx mj jj nw b gy os ot l ou ov">from sklearn.preprocessing import OneHotEncoder</span></pre><p id="feaa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">初始化编码器非常容易。之后，让我们用两个分类特征来拟合编码器:<code class="fe nt nu nv nw b">Sex</code>和<code class="fe nt nu nv nw b">Embarked</code>。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="fef5" class="nx mj jj nw b gy os ot l ou ov">encoder = OneHotEncoder()<br/>encoded_arr = encoder.fit_transform(df_train_features[['Sex', 'Embarked']]).toarray()</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/24a09ab2dcc14f22aebbb836596f316b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0lR8PnToFS1jNTA6_iJnw.png"/></div></div></figure><p id="dd02" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以看出，我们得到了一个891×5的矩阵，这意味着编码的特征集有5列。这是因为<code class="fe nt nu nv nw b">Sex</code>特性有2个不同的值:<code class="fe nt nu nv nw b">female</code>和<code class="fe nt nu nv nw b">male</code>，<code class="fe nt nu nv nw b">Embarked</code>特性有3个不同的值:<code class="fe nt nu nv nw b">S</code>，<code class="fe nt nu nv nw b">C</code>和<code class="fe nt nu nv nw b">Q</code>。所以，总数是五。</p><p id="7cf3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过调用编码器的<code class="fe nt nu nv nw b">categories_</code>得到标签的顺序。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="390c" class="nx mj jj nw b gy os ot l ou ov">encoder.categories_</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pf"><img src="../Images/3cbffdd7ea4e5a21329722dd2ca3a4a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJLeDVwuVN_I5OyizeOxwg.png"/></div></div></figure><p id="23b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们知道了新要素的顺序，我们就可以使用新要素标签从编码矩阵生成数据框。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="64d0" class="nx mj jj nw b gy os ot l ou ov">df_encoded = pd.DataFrame(encoded_arr, columns=[<br/>    'Sex=female', 'Sex=male', 'Embarked=C', 'Embarked=Q', 'Embarked=S'<br/>]).astype(int)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/35e0cac8ef1b6c892e9c41a7b1d60162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*t5bdwumG-MtOz-CayAuzAw.png"/></div></figure><p id="a6d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的编码特性集是有意义的。例如，上述数据框中的第一行显示乘客是一名男性，乘坐的是s。</p><p id="a533" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以将编码的要素集与原始要素数据框连接起来。不要忘记从原来的列中删除<code class="fe nt nu nv nw b">Sex</code>和<code class="fe nt nu nv nw b">Embarked</code>列，因为它们应该被编码的新特性所取代。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="e8eb" class="nx mj jj nw b gy os ot l ou ov">df_train_features = df_train_features.drop(columns=['Sex', 'Embarked'])<br/>df_train_features = pd.concat([df_train_features, df_encoded], axis=1)</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/f7b6122845b9c00779ffb211e250034d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUoLvlR8mSjnX0ZeQTViTw.png"/></div></div></figure><p id="ce1a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以训练我们的决策树模型。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="9115" class="nx mj jj nw b gy os ot l ou ov">from sklearn.tree import DecisionTreeClassifier</span><span id="c007" class="nx mj jj nw b gy pd ot l ou ov">model = DecisionTreeClassifier()<br/>model.fit(df_train_features, s_train_label)</span></pre><p id="7ec2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完了！</p><p id="c2ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是等等，我们的模型长什么样？通常，对于大多数机器学习算法来说，不太容易“看到”模型看起来是什么样子。然而，决策树不在其中。我们可以可视化我们的模型，看看节点是如何分裂的。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="09cf" class="nx mj jj nw b gy os ot l ou ov">import matplotlib.pyplot as plt <br/>from sklearn import tree</span><span id="9e47" class="nx mj jj nw b gy pd ot l ou ov">fig, _ = plt.subplots(nrows=1, ncols=1, figsize=(100,50), dpi=300)<br/>tree.plot_tree(<br/>    model,<br/>    feature_names=df_train_features.columns,<br/>    filled=True<br/>)</span><span id="165f" class="nx mj jj nw b gy pd ot l ou ov">fig.savefig('tree.png')</span></pre><p id="a347" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码将使用Matplotlib绘制树，并将图形保存为图像文件。建议检查图像文件中的树，因为如果您使用Jupyter Notebook，它太大了，无法在网页中显示。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/8bf4186b33f150eec58942728785dcdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-aUkJg82nPdhaiZaUDQhBA.png"/></div></div></figure><p id="c3ba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是“tree.png”图片中的一部分树。</p><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/d8b558238ae808f7a50a10da0b8bd65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fqt5PfD-LZXLTdaLNUjBng.png"/></div></div></figure><h1 id="5c52" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">6.模型评估</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2c80f66f5e369b2123b2c28c646e6df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdiS0-r55-k_FxTMbxbTMQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/users/qimono-1962238/" rel="noopener ugc nofollow" target="_blank">奇莫诺</a>在<a class="ae jg" href="https://pixabay.com/photos/measurement-millimeter-centimeter-1476919/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的照片</p></figure><p id="f8ae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最后阶段，但可能不是我们工作流程的结束，我们需要评估我们的模型。</p><p id="6431" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">评估我们的模型的最佳方式是从上面的Kaggle页面下载test.csv并预测测试数据集的存活率，然后提交它。但是，这是因为Kaggle是一个提供这样一个功能的竞赛平台。在实践中，我们通常需要将原始数据集分成训练数据集和测试数据集。</p><p id="2ef7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在本文中，我想使用另一种方法来评估我们的模型，这就是交叉验证。</p><p id="5e19" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">交叉验证的基本思想是评估模型训练方法和超参数，而不是已训练的模型。可以认为是以下步骤。</p><ol class=""><li id="e8df" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">将数据集分割成大小相等的<em class="pk"> n </em>个片段。</li><li id="e7a2" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用<em class="pk"> n-1个</em>片段训练模型，剩余1个片段将用作测试集。</li><li id="0f5c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">计算模型预测精度。</li><li id="d376" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">重复步骤2-3，使用不同的段作为测试集，直到所有段都被评估。</li><li id="ad66" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">获取<em class="pk"> n </em>个精度数字的平均值，该值将被视为模型的得分。</li></ol><p id="e9df" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来实施吧。</p><pre class="na nb nc nd gt oo nw op oq aw or bi"><span id="b365" class="nx mj jj nw b gy os ot l ou ov">import numpy as np<br/>from sklearn.model_selection import cross_val_score</span><span id="0a05" class="nx mj jj nw b gy pd ot l ou ov">accuracy_list = cross_val_score(model, df_train_features, s_train_label, cv=10)</span><span id="9826" class="nx mj jj nw b gy pd ot l ou ov">print(f'The average accuracy is {(np.mean(accuracy_list)*100).round(2)}%')</span></pre><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/c1d598bb06c5673642dffb65003b94ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j27PzXLA-7vXAaYPwnYHTw.png"/></div></div></figure><p id="774e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，参数<code class="fe nt nu nv nw b">cv</code>是提到的段数<em class="pk"> n </em>。为此使用10是很常见的。</p><p id="1e31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实证明，结果可能并不理想。在实践中，我们可能会重新访问前面的某个阶段，看看我们是否可以重塑数据集以获得更好的结果，例如在数据清理阶段更改间隙填充机制。</p><h1 id="9b33" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">摘要</h1><figure class="na nb nc nd gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1189ec565bf4e22fb7e67569570c1922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_O2Ds1ahw7lK-v755kEsA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/larisa-k-1107275/" rel="noopener ugc nofollow" target="_blank">拉里莎-K </a>在<a class="ae jg" href="https://pixabay.com/photos/spring-tree-flowers-meadow-276014/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="7b01" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，我要说的是，我们从交叉验证中得到的平均准确度确实不是很理想。你可以去Kaggle问题网页上找到其他人已经完成的其他解决方案，其中一些已经达到了非常高的准确率。</p><p id="341b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我展示了机器学习作业的整个典型工作流程。它从问题陈述开始，如何处理数据等等，而不是像大多数其他文章一样直接跳到训练机器学习模型。虽然有太多的细节可以扩展，如EDA和功能工程步骤，但我希望本文展示了数据科学家将遵循的典型步骤，并为您提供一个大致的描述。</p><p id="01a7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望你喜欢阅读！</p><div class="is it gp gr iu ne"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jk gy z fp nj fr fs nk fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">medium.com</p></div></div><div class="nn l"><div class="pm l np nq nr nn ns ja ne"/></div></div></a></div><p id="948c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p><h1 id="6049" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">其他相关作品</h1><p id="b6da" class="pw-post-body-paragraph ky kz jj la b lb oj kk ld le ok kn lg lh ol lj lk ll om ln lo lp on lr ls lt im bi translated">下面是我之前的一些介绍决策树算法的文章。如果你有兴趣，请去看看！</p><p id="d3d8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"><em class="pk">【ID3算法决策树(熵)</em> </strong></p><div class="is it gp gr iu ne"><a rel="noopener follow" target="_blank" href="/go-out-for-exercise-or-not-let-data-science-decide-34f8f28ce7b4"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jk gy z fp nj fr fs nk fu fw ji bi translated">出去锻炼还是不锻炼？让数据科学来决定</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">决策树机器学习算法简介</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="pn l np nq nr nn ns ja ne"/></div></div></a></div><p id="069f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="pk">决策树采用C4.5算法(信息增益比)</em> </strong></p><div class="is it gp gr iu ne"><a rel="noopener follow" target="_blank" href="/do-not-use-decision-tree-like-this-369769d6104d"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jk gy z fp nj fr fs nk fu fw ji bi translated">不要像这样使用决策树</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">展示ID3中信息获取的局限性以及使用C4.5的优势</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="po l np nq nr nn ns ja ne"/></div></div></a></div><p id="9ca2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="pk">决策树逐车算法(基尼指数)</em> </strong></p><div class="is it gp gr iu ne"><a rel="noopener follow" target="_blank" href="/get-your-decision-tree-model-moving-by-cart-82765d59ae09"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jk gy z fp nj fr fs nk fu fw ji bi translated">让您的决策树模型随车移动</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">基尼杂质——另一种决策树节点划分标准</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="pp l np nq nr nn ns ja ne"/></div></div></a></div><p id="7a23" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="pk">回归问题决策树</em> </strong></p><div class="is it gp gr iu ne"><a href="https://medium.com/towards-artificial-intelligence/everyone-can-understand-machine-learning-regression-tree-model-28e3541b3e79" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jk gy z fp nj fr fs nk fu fw ji bi translated">每个人都能理解机器学习——回归树模型</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">没有公式、方程和科学陈述回归树模型介绍</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">medium.com</p></div></div><div class="nn l"><div class="pq l np nq nr nn ns ja ne"/></div></div></a></div></div></div>    
</body>
</html>