<html>
<head>
<title>Data Grouping in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的数据分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-grouping-in-python-d64f1203f8d3?source=collection_archive---------0-----------------------#2020-11-12">https://towardsdatascience.com/data-grouping-in-python-d64f1203f8d3?source=collection_archive---------0-----------------------#2020-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6987" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">检查“困难”的任务，并尝试给出替代的解决方案</h2></div><p id="2c43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">按列对记录进行分组是数据分析的常见需求。这样的场景包括统计公司各个部门的员工，分别计算各个部门男女员工的平均工资，计算不同年龄段员工的平均工资。熊猫有分组功能，可以方便地处理大部分分组任务。但是该职能部门发现有些任务很难管理。在这里，让我们检查这些“困难”的任务，并尝试给出替代的解决方案。</p><p id="3644" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分组是熊猫最重要的功能之一。它用于根据拆分-应用-组合策略对记录进行分组和汇总。下图显示了工作流程:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/f73a691acee6d0eac03e1442f397d2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/0*5Zzcwe-rlxz-EQ_N"/></div><p class="lj lk gj gh gi ll lm bd b be z dk translated">作者图片</p></figure><h1 id="4d8f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">I .按单个字段分组和聚合</h1><p id="0f9d" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">您按特定字段对记录进行分组，然后对每个组执行聚合。</p><p id="bd1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是上述策略最简单的用法。例如，根据员工信息计算每个部门的员工数:</p><p id="31b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:以department为关键字，按其对记录进行分组，统计每组中的记录。</p><p id="56b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是部分员工信息:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/5cb7a45f990b202df7d883a49e1336d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uQFv7RW4yCCGTmfa"/></div></div></figure><p id="0251" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="b7e4" class="mu lo iq mq b gy mv mw l mx my">import pandas as  pd</span><span id="2f30" class="mu lo iq mq b gy mz mw l mx my">#Import data<br/>employee =  pd.read_csv("Employees.csv")</span><span id="0af4" class="mu lo iq mq b gy mz mw l mx my">#Grouping and perform count over each group<br/>dept_emp_num =  employee.groupby('DEPT')['DEPT'].count()</span><span id="7417" class="mu lo iq mq b gy mz mw l mx my">print(dept_emp_num)</span></pre><p id="cc08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释:groupby('DEPT ')按部门对记录进行分组，count()计算每组中的雇员数。</p><h1 id="cd7c" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">II按多个字段分组和聚合</h1><p id="72f4" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">您按多个字段对记录进行分组，然后对每个组执行聚合。</p><p id="7cb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们以类似的方式处理它。根据前一个实例中相同的员工信息计算每个部门中男性和女性员工的平均工资。</p><p id="8fd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:分组键有两个，部门和性别。我们将组合键作为一个整体来进行分组和聚合。</p><p id="d3a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="3250" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="aec4" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="f09f" class="mu lo iq mq b gy mz mw l mx my">#Group by two keys and then summarize each group<br/>dept_gender_salary =  employee.groupby(['DEPT','GENDER'],as_index=False).SALARY.mean()</span><span id="1b39" class="mu lo iq mq b gy mz mw l mx my">print(dept_gender_salary)</span></pre><p id="3876" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释:表达式groupby(['DEPT '，' GENDER'])将两个分组字段作为列表形式的参数。表达式as_index使用True或False指定是否将分组字段用作索引(这里False表示不将它们用作索引)。mean()函数计算平均工资。</p><h1 id="bad2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">III按计算列分组和聚合</h1><p id="cc4f" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">分组键不是显式数据，需要根据已有数据进行计算。这样的键称为计算列。例如，要计算不同年份员工的平均工资:</p><p id="92f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:员工信息中没有年份一栏。我们需要根据员工的生日来计算，按计算列对记录进行分组，并计算平均工资。</p><p id="42c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="e5a9" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="30bd" class="mu lo iq mq b gy mz mw l mx my">import numpy as np</span><span id="f08f" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="ca6d" class="mu lo iq mq b gy mz mw l mx my">#Convert the BIRTHDAY column into date format<br/>employee['BIRTHDAY']=pd.to_datetime(employee['BIRTHDAY'])</span><span id="a3f1" class="mu lo iq mq b gy mz mw l mx my">#Calculate an array of calculated column values, group records by them, and calculate the average salary<br/>years_salary =  employee.groupby(np.floor((employee['BIRTHDAY'].dt.year-1900)/10)).SALARY.mean()</span><span id="8ce7" class="mu lo iq mq b gy mz mw l mx my">print(years_salary)</span></pre><p id="cd01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明:由于原始数据中不存在年值，Python使用NP . floor((employee[' BIRTHDAY ']. dt . year-1900)/10)来计算年列，按新列对记录进行分组，并计算平均工资。</p><h1 id="e9f3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">四多重集合</h1><p id="ccd1" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">您可以对多列中的每一列执行一种类型的聚合操作，或者对一列或多列执行几种类型的聚合操作。</p><p id="b241" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.多列中的每一列都有一个聚合</p><p id="af9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对多列中的每一列执行一种类型的聚合。计算每个部门的雇员数和平均工资，例如:</p><p id="efbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:count聚合在EID列上，average聚合在salary列上。每个列都有自己的一个聚合。</p><p id="ac1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="fc5a" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="c5b8" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="e5c0" class="mu lo iq mq b gy mz mw l mx my">#Group records by DEPT, perform count on EID and average on SALARY<br/>dept_agg =  employee.groupby('DEPT',as_index=False).agg({'EID':'count','SALARY':'mean'})</span><span id="d839" class="mu lo iq mq b gy mz mw l mx my">#Rename the columns<br/>print(dept_agg.rename(columns={'EID':'NUM','SALARY':'AVG_SALARY'}))</span></pre><p id="c382" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释:Pandas agg()函数可以用来处理这类计算任务。相关的列和涉及的聚合操作以字典的形式传递给函数，其中列是键，聚合是值，以完成聚合。</p><p id="ade9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.一根色谱柱上的多种聚合</p><p id="565f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您在单个列上执行多种类型的聚合。对于之前的任务，我们也可以把工资加起来，然后算出平均值。这样，我们在salary列上执行两个聚合，count和average。</p><p id="b373" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="9e7a" class="mu lo iq mq b gy mv mw l mx my">import pandas as  pd</span><span id="ca9c" class="mu lo iq mq b gy mz mw l mx my">employee =  pd.read_csv("Employees.csv")</span><span id="62ef" class="mu lo iq mq b gy mz mw l mx my">#Perform count and then average on SALARY column<br/>dept_agg = employee.groupby('DEPT').SALARY.agg(['count','mean']).reset_index()</span><span id="ea25" class="mu lo iq mq b gy mz mw l mx my">#Rename columns<br/>print(dept_agg.rename(columns={'count':'NUM','mean':'AVG_SALARY'}))</span></pre><p id="3b66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明:我们可以把聚合操作组合成一个列表，并把它作为参数传递给agg()函数。</p><p id="2421" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.多个色谱柱上的多个聚合</p><p id="d103" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您汇总了多个列，在此期间，单个列上有多个聚合。聚合操作可以由用户定义。</p><p id="9228" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以获取每个部门的员工人数、平均工资和最大年龄为例:</p><p id="c50e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:统计员工人数，计算平均工资，都是对工资列(一列多个合计)的操作。查找最大年龄需要对生日列进行自定义操作。</p><p id="ecac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="d305" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="81fa" class="mu lo iq mq b gy mz mw l mx my">import datetime</span><span id="4b31" class="mu lo iq mq b gy mz mw l mx my">#The user-defined function for getting the largest age<br/>def max_age(s):<br/>    #Year<br/>    today = datetime. datetime.today().year<br/>    #Get ages<br/>    age = today-s.dt.year</span><span id="59e5" class="mu lo iq mq b gy mz mw l mx my">    return age.max()</span><span id="b8d2" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="1240" class="mu lo iq mq b gy mz mw l mx my">employee['BIRTHDAY']=pd.to_datetime(employee\['BIRTHDAY'\])</span><span id="76a9" class="mu lo iq mq b gy mz mw l mx my">#Group records by DEPT, perform count and average on SALARY, and use the user-defined max_age function to get the largest age<br/>dept_agg = employee.groupby('DEPT').agg({'SALARY':['count','mean'],'BIRTHDAY':max_age})</span><span id="c743" class="mu lo iq mq b gy mz mw l mx my">#Rename columns<br/>dept_agg.columns = ['NUM','AVG_SALARY','MAX_AGE']</span><span id="4807" class="mu lo iq mq b gy mz mw l mx my">print(dept_agg.reset_index())<br/></span></pre><p id="54b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明:要汇总的列和聚合操作以字典的形式通过参数传递给函数。对于需要多个聚合操作的列，我们需要将这些操作组合成一个列表，用作字典值。</p><h1 id="c8f8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">复制分组和汇总结果</h1><p id="06ed" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">您可以将每个聚合结果扩展到相应组的长度。这相当于将聚合结果复制到其组中的所有行。向员工信息中添加包含每个部门平均工资的新列，例如:</p><p id="c631" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:按部门对记录进行分组，计算每个部门的平均工资，在保持原有顺序的情况下，将每个平均值填充到相应的组中。</p><p id="756d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="c2a3" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="d7a4" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="f5e6" class="mu lo iq mq b gy mz mw l mx my">#Group records by DEPT and calculate average on SLARY</span><span id="5e2f" class="mu lo iq mq b gy mz mw l mx my">employee['AVG_SALARY'] = employee.groupby('DEPT').SALARY.transform('mean')</span><span id="c6fa" class="mu lo iq mq b gy mz mw l mx my">print(employee)</span></pre><p id="079e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明:按部门对记录进行分组，并计算每组的平均工资。transform()函数计算每个组的聚合，返回结果并按照原始索引的顺序将其填充到所有行中。这确保了记录保持原始顺序。</p><h1 id="d3af" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">VI处理分组子集</h1><p id="c904" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">您可以在每个组中执行一个或多个非聚合操作。例如，为了对每个组进行排序，我们关心的是记录的顺序，而不是集合。要按聘用日期以升序对每个部门的记录进行排序，例如:</p><p id="c5fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:按部门对记录进行分组，并在每个组中循环，按雇用日期对记录进行排序。</p><p id="6884" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="5977" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="ee09" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="2fda" class="mu lo iq mq b gy mz mw l mx my">#Modify hire date format<br/>employee['HIREDATE']=pd.to_datetime(employee['HIREDATE'])</span><span id="d275" class="mu lo iq mq b gy mz mw l mx my">#Group records by DEPT, sort each group by HIREDATE, and reset the index<br/>employee_new = employee.groupby('DEPT',as_index=False).apply(lambda x:x.sort_values('HIREDATE')).reset_index(drop=True)</span><span id="5d25" class="mu lo iq mq b gy mz mw l mx my">print(employee_new)</span></pre><p id="5fe2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明:要对每个组中的记录进行排序，我们可以使用apply()函数和lambda的组合。lambda表达式通过组进行循环，使用sort_values()函数对每个组中的记录进行排序，并返回排序结果。</p><p id="a026" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有更复杂的计算目标。例如，要找出每个部门中年龄最大的员工和年龄最小的员工之间的工资差异:</p><p id="d026" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:将记录按部门分组，定位最年长的员工记录和最年轻的员工记录，计算他们的工资差异。</p><p id="b07c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="da9e" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="cf47" class="mu lo iq mq b gy mz mw l mx my">#salary_diff(g)function calculates the salary difference over each group<br/>def salary_diff(g):<br/>    <br/>    #The index of the eldest employee record<br/>    max_age = g['BIRTHDAY'].idxmin()</span><span id="342b" class="mu lo iq mq b gy mz mw l mx my">    #The index of the youngest employee record<br/>    min_age = g['BIRTHDAY'].idxmax()</span><span id="795c" class="mu lo iq mq b gy mz mw l mx my">    #Calculate the salary difference<br/>    diff = g.loc[max_age]['SALARY']-g.loc[min_age]['SALARY']</span><span id="8e43" class="mu lo iq mq b gy mz mw l mx my">    return diff</span><span id="f2b9" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="5897" class="mu lo iq mq b gy mz mw l mx my">employee['BIRTHDAY']=pd.to_datetime(employee['BIRTHDAY'])</span><span id="1a19" class="mu lo iq mq b gy mz mw l mx my">#Group by DEPT and use a user-defined function to get the salary difference<br/>salary_diff = employee.groupby('DEPT').apply(salary_diff)</span><span id="fc53" class="mu lo iq mq b gy mz mw l mx my">print(salary_diff)<br/></span></pre><p id="2682" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释:该脚本使用apply()和一个用户定义的函数来获取目标。apply()将分组结果作为参数传递给用户定义的函数。自定义函数salary_diff()中的参数g本质上是熊猫data frame格式的一个数据帧，这里是分组结果。该脚本通过参数获取最老员工记录的索引和最年轻员工记录的索引，然后计算salary字段的差异。</p><p id="6ce9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">概要:</strong></p><p id="59d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">掌握Pandas groupby方法对处理数据分析任务特别有帮助。</p><p id="8279" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进一步看看Pandas groupby的使用，尽管现实世界中的问题来自堆栈溢出。</p><h1 id="2f9e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">VII基于职位的分组</h1><p id="6f39" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">您按位置对记录进行分组，也就是说，使用位置作为键，而不是按某个字段。这种情况包括将每三行放入同一组，并将奇数位置的行放入一组，偶数位置的行放入另一组。下面是一个例子:</p><p id="e291" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:https://stack overflow . com/questions/59110612/pandas-group by-mode-every-n-rows</p><p id="2476" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是部分源数据:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="5394" class="mu lo iq mq b gy mv mw l mx my">time     a      b<br/>0       0.5    -2.0<br/>1       0.5    -2.0<br/>2       0.1    -1.0<br/>3       0.1    -1.0<br/>4       0.1    -1.0<br/>5       0.5    -1.0<br/>6       0.5    -1.0<br/>7       0.5    -3.0<br/>8       0.5    -1.0</span></pre><p id="f6c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望每隔三行对数据进行分组和组合，并保持每组中每列的模式。预期结果如下:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="bfa8" class="mu lo iq mq b gy mv mw l mx my">time     a      b<br/>2       0.5    -2.0<br/>5       0.1    -1.0<br/>8       0.5    -1.0</span></pre><p id="6f14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:这个分组任务与列值无关，但涉及位置。我们通过位置执行整数乘法来获得一个计算列，并将其用作分组条件。</p><p id="485a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="1573" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="343d" class="mu lo iq mq b gy mz mw l mx my">import numpy as np</span><span id="b705" class="mu lo iq mq b gy mz mw l mx my">data = pd.read_csv("group3.txt",sep='\\t')</span><span id="76bf" class="mu lo iq mq b gy mz mw l mx my">#Group records by the calculated column, calculate modes through the cooperation of agg function and lambda, and get the last mode of each column to be used as the final value in each group</span><span id="5cf5" class="mu lo iq mq b gy mz mw l mx my">res = data.groupby(np.arange(len(data))//3).agg(lambda x: x.mode().iloc[-1])</span><span id="71cc" class="mu lo iq mq b gy mz mw l mx my">print(res)</span></pre><p id="949c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明:表达式NP . arange(len(data))//3生成一个计算列，其值为[0 0 1 1 1 2 2]。该脚本使用它作为每三行对数据进行分组的键。表达式agg(lambda x: x.mode())从每个组中的每一列获取模式。在第一组中，时间列中的模式是[0，1，2]，a和b列中的模式分别是[0.5]和[-2.0]。然后，该脚本使用iloc[-1]来获取它们的最后模式，以用作最终的列值。</p><h1 id="2b96" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">VIII按变化值分组</h1><p id="cd4b" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">您可以根据特定字段中的值是否更改来对有序数据进行分组。也就是说，每次出现新值时，都会创建一个新组。这里有一个例子:</p><p id="77cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:https://stack overflow . com/questions/41620920/group by-conditional-sum-of-adjacent-rows-pandas</p><p id="40dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是部分原始数据:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="358f" class="mu lo iq mq b gy mv mw l mx my">duration  location  user<br/>0 10       house    A<br/>1 5        house    A<br/>2 5        gym      A<br/>3 4        gym      B<br/>4 10       shop     B<br/>5 4        gym      B<br/>6 6        gym      B<br/></span></pre><p id="13e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据按用户分组后，对位置值连续相同的持续时间值求和，并在位置值改变时对持续时间执行下一次求和。以下是预期结果:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="39b1" class="mu lo iq mq b gy mv mw l mx my">duration  location  user<br/>15        house     A<br/>5         gym       A<br/>4         gym       B<br/>10        shop      B<br/>10        gym       B</span></pre><p id="ffe7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:订单是为位置列导入的。具有连续相同位置值的记录被放入同一个组，一旦值改变，一个记录被放入另一个组。当用户为B时，第4行(其索引为3)中的位置值为[健身房、商店、健身房、健身房]。这里我们不应该把三个健身房放在一个组里，而应该把第一个健身房放在一个单独的组里，因为第一个健身房之后的位置值是商店，这是一个不同的值。商店应该另设一个小组。然后，其他两个健身房应该在同一组，因为他们一直是相同的。所以用户B的分组结果应该是[[健身房]，[商店]，[健身房，健身房]]。这就是为什么我们不能用df.groupby(['user '，' location']).duration.sum()来得到结果。相反，我们需要一个计算列作为分组条件。</p><p id="0b2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们的Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="2190" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="4e17" class="mu lo iq mq b gy mz mw l mx my">#Generate data for computation<br/>df = pd.DataFrame({'user' : ['A', 'A', 'A', 'B', 'B', 'B','B'],</span><span id="c61e" class="mu lo iq mq b gy mz mw l mx my">                'location' : ['house','house','gym','gym','shop','gym','gym'],</span><span id="cb02" class="mu lo iq mq b gy mz mw l mx my">                'duration':[10,5,5,4,10,4,6]})</span><span id="9f88" class="mu lo iq mq b gy mz mw l mx my">#Create a calculated column<br/>derive = (df.location != df.location.shift()).cumsum()</span><span id="fe7f" class="mu lo iq mq b gy mz mw l mx my">#Group records by user, location and the calculated column, and then sum duration values<br/>res = df.groupby(['user', 'location', derive], as_index=False, sort=False)['duration'].sum()</span><span id="2b3f" class="mu lo iq mq b gy mz mw l mx my">print(res)</span></pre><p id="a268" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释:计算列derive通过在每次位置值发生变化之前累计位置值来获取其值。累积值为[1 1 2 2 3 4 4]。然后按用户、位置和计算出的数组对原始数据进行分组，并对持续时间进行求和。</p><h1 id="7b94" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">IX按条件分组</h1><p id="67ac" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">当对有序数据进行分组时，只要某个字段的值满足指定的条件，就会创建一个新组。下面是一个例子:</p><p id="20c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来源:https://stack overflow . com/questions/62461647/choose-random-rows-in-pandas-data fram</p><p id="75d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是部分原始数据:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="6426" class="mu lo iq mq b gy mv mw l mx my">ID            code<br/>333_c_132     x<br/>333_c_132     n06<br/>333_c_132     n36<br/>333_c_132     n60<br/>333_c_132     n72<br/>333_c_132     n84<br/>333_c_132     n96<br/>333_c_132     n108<br/>333_c_132     n120<br/>999_c_133     x<br/>999_c_133     n06<br/>999_c_133     n12<br/>999_c_133     n24<br/>998_c_134     x<br/>998_c_134     n06<br/>998_c_134     n12<br/>998_c_134     n18<br/>998_c_134     n36<br/>997_c_135     x<br/>997_c_135     n06<br/>997_c_135     n12<br/>997_c_135     n24<br/>997_c_135     n36<br/>996_c_136     x<br/>996_c_136     n06<br/>996_c_136     n12<br/>996_c_136     n18<br/>996_c_136     n24<br/>996_c_136     n36<br/>995_c_137     x<br/></span></pre><p id="c2a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望在代码列中的每两个x值之间得到一个随机行。</p><p id="3c5a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预期结果如下:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="2299" class="mu lo iq mq b gy mv mw l mx my">333_c_132     n06<br/>999_c_133     n12<br/>998_c_134     n18<br/>997_c_135     n36<br/>996_c_136     n18</span></pre><p id="8846" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:从两个x值中随机获取一行，我们可以根据代码值是否为x对行进行分组(即每当代码值变为x时创建一个新组)，从当前组中随机获取一行。所以我们仍然需要一个计算列作为分组键。</p><p id="d967" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="3d2b" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="cad6" class="mu lo iq mq b gy mz mw l mx my">df = pd.read_csv("data.txt")</span><span id="6961" class="mu lo iq mq b gy mz mw l mx my">#Generate a calculated column<br/>derive = df.code.eq('x').cumsum()</span><span id="3b1a" class="mu lo iq mq b gy mz mw l mx my">#Group records by the calculated column and get a random record from each groupthrough the cooperation of apply function and lambda<br/>res=df[df.code.ne('x')].groupby(derive).apply(lambda  x : x.sample(1))</span><span id="3b6e" class="mu lo iq mq b gy mz mw l mx my">#Reset the index<br/>res=res.reset_index(level=0, drop=True)</span><span id="5a97" class="mu lo iq mq b gy mz mw l mx my">print(res)</span></pre><p id="1034" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释:code.eq(x)当code为x时返回True，当code不是x时返回False，cumsum()累加真值和假值的个数，生成计算列[1 1 1 1 1 1 1 1 1 2 2…]。然后，该脚本查找code为x的记录，根据这些x值对记录进行分组，并从每个组中获得一个随机记录。</p><p id="1b3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">概要:</strong></p><p id="3c74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上述所有例子中，原始数据集根据指定的条件被分成若干子集，并具有以下两个特征:</p><p id="4b37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1)没有子集是空的；</p><p id="348c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2)原始数据集中的每个成员属于且只属于一个子集。</p><p id="71d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称这种类型的分组为全分。也有偏科的。</p><p id="015c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是一些例子。</p><h1 id="2f1a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">x对齐分组</h1><p id="a1a0" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">路线编组有一个基础集。它将待分组集合的成员的属性(字段或表达式)与基本集合的成员进行比较，并将与基本集合的成员匹配的成员放入同一子集中。子集的数量与基本集中的成员数量相同。路线分组有三个特征:</p><p id="647a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1)可能存在空的子集(例如，基本集合的一个或多个成员不存在于要分组的集合中)；</p><p id="0d73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2)可能存在未被放入任何组的待分组集合的成员(例如，它们并不重要到包括在基本集合中)；</p><p id="8c40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3)待分组集合中的每个成员最多属于一个子集。</p><p id="53b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.空子集</p><p id="43e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一家公司想知道每个部门员工的准确人数。如果一个部门没有男性员工或女性员工，它会将他们的人数记录为0。</p><p id="372f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:如果我们直接按部门和性别分组数据，也就是groupby(['DEPT '，' GENDER'])，那么一个部门中没有女性员工或者男性员工的员工都会被放到一个组中，缺失性别的信息就会缺失。很容易想到一个替代方案。该解决方案按部门对记录进行分组，生成一个[男性，女性]基集以左连接每个组，按性别对每个连接结果进行分组，然后计算男性和女性员工的数量。这将确保每个小组都包括女性雇员和男性雇员。</p><p id="94d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="b7fa" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="668f" class="mu lo iq mq b gy mz mw l mx my">#Alignment grouping function<br/>def align_group(g,l,by):<br/>    <br/>    #Generate the base dataframe set and use merge function to perform the alignment grouping<br/>    d = pd.DataFrame(l,columns=[by])</span><span id="82a9" class="mu lo iq mq b gy mz mw l mx my">    m = pd.merge(d,g,on=by,how='left')</span><span id="1626" class="mu lo iq mq b gy mz mw l mx my">return m.groupby(by,sort=False)</span><span id="1203" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="40cc" class="mu lo iq mq b gy mz mw l mx my">#Define a sequence<br/>l = ['M','F']</span><span id="e278" class="mu lo iq mq b gy mz mw l mx my">#Group records by DEPT, perform alignment grouping on each group, and perform count on EID in each subgroup</span><span id="fe3c" class="mu lo iq mq b gy mz mw l mx my">res = employee.groupby('DEPT').apply(lambda x:align_group(x,l,'GENDER').apply(lambda s:s.EID.count()))</span><span id="5491" class="mu lo iq mq b gy mz mw l mx my">print(res)</span></pre><p id="dfd7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解释:</p><p id="545d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用户自定义函数align _ groupuses使用merge()函数生成基集，并对基集和要分组的集执行左连接，然后按合并列对每个连接结果集进行分组。记录按部门分组后，apply()函数和lambda表达式的配合通过自定义函数对每组进行对齐分组，然后对EID列进行计数。(注意:您不应该对性别执行计数，因为在合并操作期间，所有性别成员都会保留。当有一个空的子集时，对性别计数的结果将是1，而其余的列在左连接时将被记录为null。这将导致EID计数的结果为零)。</p><p id="3057" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.未放入任何组的待分组集合的成员</p><p id="9ab1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务是按指定的部门['管理'，'人力资源'，'营销'，'销售']对记录进行分组，计算它们的员工数，并按指定的部门顺序返回结果。</p><p id="8b26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:我们可以使用left join过滤掉未包含在指定部门集合中的记录。</p><p id="30fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="adde" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="99a9" class="mu lo iq mq b gy mz mw l mx my">#Alignment grouping function<br/>def align_group(g,l,by):</span><span id="ab02" class="mu lo iq mq b gy mz mw l mx my">    d =   pd.DataFrame(l,columns=[by])</span><span id="5fcb" class="mu lo iq mq b gy mz mw l mx my">    m =   pd.merge(d,g,on=by,how='left')</span><span id="fc22" class="mu lo iq mq b gy mz mw l mx my">    return   m.groupby(by,sort=False)</span><span id="be6c" class="mu lo iq mq b gy mz mw l mx my">employee = pd.read_csv("Employees.csv")</span><span id="a80c" class="mu lo iq mq b gy mz mw l mx my">#The specified subset of departments<br/>sub_dept = ['Administration', 'HR', 'Marketing', 'Sales']</span><span id="6509" class="mu lo iq mq b gy mz mw l mx my">#Use the alignment function to group records and perform count on EID<br/>res =  align_group(employee,sub_dept,'DEPT').apply(lambda x:x.EID.count())</span><span id="b2e3" class="mu lo iq mq b gy mz mw l mx my">print(res)</span></pre><p id="1456" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明:Pandas并不直接支持对齐分组功能，所以实现起来比较迂回。此外，使用合并函数会导致性能下降。</p><h1 id="27ee" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">XI计数分组</h1><p id="33ca" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">枚举分组指定一组条件，通过将待分组集合的每个成员作为参数传递给它们来计算条件，并将使条件为真的记录放入同一子集中。结果集中的子集和指定的条件有一对一的关系。枚举分组的一个特点是，要分组的集合中的成员可以放入多个子集中。</p><p id="20e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个例子</p><p id="64c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务是根据雇佣期限对员工进行分组，雇佣期限为[雇佣期限&lt;5 years, 5 years&lt;= employment duration&lt;10 years, employment duration&gt; =10年，雇佣期限&gt; =15年]，并统计每组中的女性和男性员工(列出每个枚举条件的所有符合条件的员工记录，即使他们也满足其他条件)。</p><p id="a345" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题分析:列举条件任职年限&gt; =10年和任职年限&gt; =15年有重叠期间。在公司工作了至少15年的员工也符合另一个条件。计算列不支持将一条记录放入多个组中。我们需要遍历所有条件，为每个条件搜索符合条件的记录，然后执行计数。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="48a4" class="mu lo iq mq b gy mv mw l mx my">import pandas as pd</span><span id="5641" class="mu lo iq mq b gy mz mw l mx my">import datetime</span><span id="daf3" class="mu lo iq mq b gy mz mw l mx my">#The function for converting strings into expressions<br/>def eval_g(dd:dict,ss:str):</span><span id="cad7" class="mu lo iq mq b gy mz mw l mx my">    return   eval(ss,dd)   </span><span id="a5b6" class="mu lo iq mq b gy mz mw l mx my">emp_file = 'E:\\txt\\employee.txt'</span><span id="df6b" class="mu lo iq mq b gy mz mw l mx my">emp_info = pd.read_csv(emp_file,sep='\\t')</span><span id="6a6c" class="mu lo iq mq b gy mz mw l mx my">employed_list = ['Within five years','Five to ten   years','More than ten years','Over fifteen years']</span><span id="54cf" class="mu lo iq mq b gy mz mw l mx my">#Grouping conditions<br/>employed_str_list = ["(s&lt;5)","(s&gt;=5) &amp; (s&lt;10)","(s&gt;=10)","(s&gt;=15)"]</span><span id="ac49" class="mu lo iq mq b gy mz mw l mx my">today = datetime.datetime.today().year</span><span id="9774" class="mu lo iq mq b gy mz mw l mx my">arr = pd.to_datetime(emp_info['HIREDATE'])</span><span id="c6b0" class="mu lo iq mq b gy mz mw l mx my">#Calculate employment durations<br/>employed = today-arr.dt.year</span><span id="198f" class="mu lo iq mq b gy mz mw l mx my">emp_info['EMPLOYED']=employed</span><span id="ca61" class="mu lo iq mq b gy mz mw l mx my">dd = {'s':emp_info['EMPLOYED']}</span><span id="8cda" class="mu lo iq mq b gy mz mw l mx my">group_cond = []</span><span id="3064" class="mu lo iq mq b gy mz mw l mx my">#Loop through grouping conditions</span><span id="d046" class="mu lo iq mq b gy mz mw l mx my">for n in range(len(employed_str_list)):</span><span id="ea1f" class="mu lo iq mq b gy mz mw l mx my">    #Group records by conditions<br/>    emp_g = emp_info.groupby(eval_g(dd,employed_str_list[n]))</span><span id="e182" class="mu lo iq mq b gy mz mw l mx my">    #Grouping indexes<br/>    emp_g_index = [index for index in emp_g.size().index]</span><span id="ad13" class="mu lo iq mq b gy mz mw l mx my">    #If there are not eligible records Then the number of female or male employees are 0</span><span id="5070" class="mu lo iq mq b gy mz mw l mx my">    if True not in emp_g_index:</span><span id="ff4a" class="mu lo iq mq b gy mz mw l mx my">          female_emp=0</span><span id="28f4" class="mu lo iq mq b gy mz mw l mx my">          male_emp=0<br/>    <br/>    #If there are records meeting the current condition Then create a group for them And count the female and male employees</span><span id="ecbe" class="mu lo iq mq b gy mz mw l mx my">    else:</span><span id="b59e" class="mu lo iq mq b gy mz mw l mx my">        group =   emp_g.get_group(True)</span><span id="76b2" class="mu lo iq mq b gy mz mw l mx my">        sum_emp = len(group)</span><span id="45b3" class="mu lo iq mq b gy mz mw l mx my">          female_emp = len(group[group['GENDER']=='F'])</span><span id="d382" class="mu lo iq mq b gy mz mw l mx my">          male_emp = sum_emp-female_emp</span><span id="9c35" class="mu lo iq mq b gy mz mw l mx my">      group_cond.append([employed_list[n],male_emp,female_emp])</span><span id="05df" class="mu lo iq mq b gy mz mw l mx my">#Summarize the count results for all conditions</span><span id="d3c3" class="mu lo iq mq b gy mz mw l mx my">group_df = pd.DataFrame(group_cond,columns=['EMPLOYED','MALE','FEMALE'])</span><span id="80c4" class="mu lo iq mq b gy mz mw l mx my">print(group_df)</span></pre><p id="dafd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明:已雇佣是根据雇佣日期列新计算的雇佣期限列。用户定义的函数eval_g()将枚举条件转换为表达式。列举条件&lt;5, for instance, is equivalent to the eval_g(dd,ss) expression emp_info[‘EMPLOYED’]&lt;5. The new calculated column value will then be used to group the records. The script loops through the conditions to divide records into two groups according to the calculated column. get_group(True) gets eligible groups. Finally the script uses concat() function to concatenate all eligible groups.</p><p id="6432" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">汇总</strong></p><p id="81d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python可以优雅地处理大多数分组任务。在处理基于顺序的分组任务时，它需要生成一个满足分组条件的计算列，例如按更改的值/条件分组。有点复杂。当面对排列分组和枚举分组任务时，它变得很尴尬，因为它需要采取非常迂回的方式，例如使用合并操作和多重分组。那很费时间和精力。熊猫在处理分组任务方面仍有弱点</p><p id="c889" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">esProc SPL巧妙地处理分组任务。esProc是专门的数据计算引擎。它所基于的语言SPL提供了丰富的分组函数，以更加一致的代码风格方便地处理分组计算。</p><p id="543d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个esProc分组函数group()和group()用于实现按组聚合和子集处理。他们能够以简洁的方式处理上述六个简单的分组问题:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi na"><img src="../Images/c56508bd58d172f03a86e66eea88c369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U1yzYfGtdoRe0a3_b6w6pw.png"/></div></div></figure><p id="0c2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python在处理它们时也很方便，但通过涉及许多其他函数，包括agg、transform、apply、lambda表达式和用户定义的函数，它具有不同的编码风格。SPL以组的形式采取一致的编码风格(x；y)和组(x)。(y)。</p><p id="1932" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python脚本在处理以下三个涉及计算列的问题时有点复杂。基于有序集的SPL通过提供处理基于有序的分组任务的选项，能够保持优雅的编码风格</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi na"><img src="../Images/df0a6d22f119944e8d8a9331a6c2e831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*smXj2ad9Hw2hVSuFWAOljg.png"/></div></div></figure><p id="8340" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据是需要分组后聚合还是希望进一步处理每个子集中的数据，可以选择使用组或组函数来处理分组和聚合任务。</p><p id="48a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python在通过使用合并函数和多重分组操作来管理最后两个类型组任务(对齐分组和枚举分组)时确实有些笨拙。SPL有专门的对齐分组函数align()和枚举分组函数enum()，以保持其优雅的编码风格。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nb"><img src="../Images/023ff9eb7d6b1d7529a4b97f40400f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCxJIGU84ljnPJ58pl26ng.png"/></div></div></figure><p id="cd9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python的致命弱点是对大数据分组的处理(数据放不进内存)。该语言需要外部存储读/写和哈希分组。对于一个非专业程序员来说，用Python来完成几乎是不可能的。阅读<a class="ae nc" href="https://medium.com/analytics-vidhya/how-python-handles-big-files-fc60ff90b819" rel="noopener">Python如何处理大文件</a>了解更多信息。</p><p id="b3bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那篇文章指出了Python在计算大数据(包括大数据分组)方面的问题，并介绍了esProc SPL的游标机制。该机制提供了group函数和groupx()函数，以优雅的方式处理大数据计算。</p></div></div>    
</body>
</html>