<html>
<head>
<title>How to Avoid a Pandas Pandemonium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免熊猫大混乱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-avoid-a-pandas-pandemonium-e1bed456530?source=collection_archive---------18-----------------------#2020-11-15">https://towardsdatascience.com/how-to-avoid-a-pandas-pandemonium-e1bed456530?source=collection_archive---------18-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="67cb" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="cb47" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">深入探究熊猫的常见错误。第一部分:编写好的代码并发现无声的失败。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b4cf414a768ca378da4e65ce3c57c9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qDeZcZ6LXq0z8qy5"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3302" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当你第一次开始使用熊猫的时候，最好是先把脚弄湿，然后在出现问题的时候处理。然后，几年过去了，你已经能够用它构建的惊人的东西开始积累，但是你有一个模糊的暗示，你一直在犯同样的错误，对于看起来很简单的操作，你的代码运行得非常慢。这是时候深入了解熊猫的内部工作原理，让你的代码更上一层楼了。与任何库一样，优化代码的最佳方式是理解语法下面发生了什么。</p><p id="6b64" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，在第一部分<strong class="lh ja">中，我们将吃我们的蔬菜，并涵盖编写干净的代码和发现常见的无声故障。然后在<a class="ae le" href="https://medium.com/@protagonistwu/how-to-avoid-a-pandas-pandemonium-part-ii-3426f53d7fba" rel="noopener"> <strong class="lh ja">第二部分</strong> </a>中，我们将开始加速你的运行时间并降低你的内存占用。</strong></p><p id="3ea3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我还做了一个<a class="ae le" href="https://github.com/pambot/notebooks/blob/master/pandas-pandemonium.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本，上面有整个课程</a>，包括两部分。</p><p id="44e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，让我们制造一些假数据来玩。我将制作一个大的数据框来说明更大的处理问题，并制作一个小的数据框来说明局部的点变化。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="fb8d" class="mg mh iq mc b gy mi mj l mk ml"><em class="mm"># for neatness, it helps to keep all of your imports up top</em><br/><strong class="mc ja">import</strong> <strong class="mc ja">sys</strong><br/><strong class="mc ja">import</strong> <strong class="mc ja">traceback</strong><br/><strong class="mc ja">import</strong> <strong class="mc ja">numba</strong><br/><strong class="mc ja">import</strong> <strong class="mc ja">numpy</strong> <strong class="mc ja">as</strong> <strong class="mc ja">np</strong><br/><strong class="mc ja">import</strong> <strong class="mc ja">pandas</strong> <strong class="mc ja">as</strong> <strong class="mc ja">pd</strong><br/><strong class="mc ja">import</strong> <strong class="mc ja">numpy.random</strong> <strong class="mc ja">as</strong> <strong class="mc ja">nr</strong><br/><strong class="mc ja">import</strong> <strong class="mc ja">matplotlib.pyplot</strong> <strong class="mc ja">as</strong> <strong class="mc ja">plt</strong><br/><br/>% matplotlib inline</span><span id="6b6f" class="mg mh iq mc b gy mn mj l mk ml"><em class="mm"># generate some fake data to play with</em><br/>data = {<br/>    "day_of_week": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"] * 1000,<br/>    "booleans": [<strong class="mc ja">True</strong>, <strong class="mc ja">False</strong>] * 3500,<br/>    "positive_ints": nr.randint(0, 100, size=7000),<br/>    "mixed_ints": nr.randint(-100, 100, size=7000),<br/>    "lat1": nr.randn(7000) * 30,<br/>    "lon1": nr.randn(7000) * 30,<br/>    "lat2": nr.randn(7000) * 30,<br/>    "lon2": nr.randn(7000) * 30,<br/>}<br/><br/>df_large = pd.DataFrame(data)</span><span id="b1cf" class="mg mh iq mc b gy mn mj l mk ml">df_large.head()</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/9d7ee7e5c3ef8ddcf6335614b966f1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NfUt16e1vmAvBLChYv7Mg.png"/></div></div></figure><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="2179" class="mg mh iq mc b gy mi mj l mk ml">small = {<br/>    'a': [1, 1],<br/>    'b': [2, 2]<br/>}</span><span id="fa4c" class="mg mh iq mc b gy mn mj l mk ml">df_small = pd.DataFrame(small)</span><span id="260f" class="mg mh iq mc b gy mn mj l mk ml">df_small</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mp"><img src="../Images/2fabd0cb36157ecc7c6e57f179ef87e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A0JWM3eITJU7YyNos9j-QQ.png"/></div></div></figure><p id="7a50" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">太好了，现在我们都准备好了！</p><h1 id="f1b7" class="mq mh iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">编写优秀的代码</h1><p id="7248" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">在我们做“酷”的事情之前，比如编写更快、更优化内存的代码，我们需要在一些看起来相当平凡的编码最佳实践的基础上做这件事。这些都是小事情，比如有表达性地命名事物和编写健全性检查，这将有助于保持代码的可维护性和可读性。</p><h2 id="b361" class="mg mh iq bd mr nm nn dn mv no np dp mz lo nq nr nb ls ns nt nd lw nu nv nf iw bi translated">健全检查很简单，完全值得</h2><p id="e551" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">仅仅因为这大部分只是数据分析，并且为它建立一整套单元测试可能没有意义，并不意味着你根本不能做任何种类的检查。在你的笔记本代码中加入<code class="fe nw nx ny mc b">assert</code>不需要太多额外的工作就可以走很长的路。</p><p id="c6f4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上面，我们制作了一个数据帧<code class="fe nw nx ny mc b">df_large</code>,其中包含一些带有预定义规则的数字。例如，您可以通过修剪空白并检查条目数量是否保持不变来检查数据输入错误:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="b33d" class="mg mh iq mc b gy mi mj l mk ml">large_copy = df_large.copy()</span><span id="b85f" class="mg mh iq mc b gy mn mj l mk ml"><strong class="mc ja">assert</strong> large_copy["day_of_week"].str.strip().unique().size == large_copy["day_of_week"].unique().size</span></pre><p id="9d56" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果运行这段代码，应该不会发生任何事情。但是，稍微修改一下，打破它，然后…</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="d559" class="mg mh iq mc b gy mi mj l mk ml">large_copy.loc[0, "day_of_week"] = "Monday "</span><span id="f64b" class="mg mh iq mc b gy mn mj l mk ml"><strong class="mc ja">assert</strong> large_copy["day_of_week"].str.strip().unique().size == large_copy["day_of_week"].unique().size</span></pre><p id="057e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">嘭！AssertionError。</strong>假设您有一些丢弃重复项并将增量发送给客户端的代码。添加的少量空白会被遗漏，并作为它自己唯一的数据点发送出去。当是一周中的某几天时，这没什么大不了的，您可以很容易地对其进行抽查，但是如果是潜在的成千上万或更多的唯一字符串，这种检查可以让您省去一个大麻烦。</p><h2 id="8aa3" class="mg mh iq bd mr nm nn dn mv no np dp mz lo nq nr nb ls ns nt nd lw nu nv nf iw bi translated">使用一致的索引</h2><p id="fca4" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">Pandas在索引方面给了你很大的灵活性，但是如果你没有保持一致的风格，它会给你带来很多困惑。这是一个提议的标准:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="804b" class="mg mh iq mc b gy mi mj l mk ml"><em class="mm"># for getting columns, use a string or a list of strings for </em>multiple columns<br/><em class="mm"># note: a one-column DataFrame and a Series are not the same thing</em><br/>one_column_series = df_large["mixed_ints"]<br/>two_column_df = df_large[["mixed_ints", "positive_ints"]]</span><span id="f3d6" class="mg mh iq mc b gy mn mj l mk ml"><em class="mm"># for getting a 2D slice of data, use `loc`</em><br/>data_view_series = df_large.loc[:10, "positive_ints"]<br/>data_view_df = df_large.loc[:10, ["mixed_ints", "positive_ints"]]</span><span id="03f6" class="mg mh iq mc b gy mn mj l mk ml"><em class="mm"># for getting a subset of rows, also use `loc`</em><br/>row_subset_df = df_large.loc[:10, :]</span></pre><p id="7520" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这只是结合了我个人用的和我见过别人做的。这里有另一组方法来做与上面完全相同的事情，但是你可能会明白为什么它们要么没有被广泛采用，要么不被鼓励使用。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="52b3" class="mg mh iq mc b gy mi mj l mk ml"><em class="mm"># one way is to use `df.loc` for everything, but it can look clunky</em><br/>one_column_series = df_large.loc[:, "mixed_ints"]<br/>two_column_df = df_large.loc[:, ["mixed_ints", "positive_ints"]]</span><span id="7b4e" class="mg mh iq mc b gy mn mj l mk ml"><em class="mm"># you can use `iloc`, which is `loc` but with indexes, but it's not as clear<br/># also, you're in trouble if you ever change the column order</em><br/>data_view_series = df_large.iloc[:10, 2]<br/>data_view_df = df_large.iloc[:10, [3, 2]]</span><span id="9538" class="mg mh iq mc b gy mn mj l mk ml"><em class="mm"># you can get rows like you slice a list, but this can be confusing</em><br/>row_subset_df = df_large[:10]</span></pre><p id="2ee5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里有一个关于最后一个例子的小问题:<code class="fe nw nx ny mc b">df_large[:10]</code>得到前10行，但是<code class="fe nw nx ny mc b">df_large[10]</code>得到第10列。这就是为什么尽可能清晰地对事物进行索引是如此重要，即使这意味着你必须做更多的打字工作。</p><h2 id="17f0" class="mg mh iq bd mr nm nn dn mv no np dp mz lo nq nr nb ls ns nt nd lw nu nv nf iw bi translated">但是不要使用链式索引</h2><p id="279b" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">什么是链式索引？当你分别索引列和行时，会对<code class="fe nw nx ny mc b">__getitem__()</code>进行两次单独的调用(或者更糟，如果你正在赋值，一次调用<code class="fe nw nx ny mc b">__getitem__()</code>，一次调用<code class="fe nw nx ny mc b">__setitem__()</code>，我们将在下面演示)。如果您只是索引而不是赋值，这还不错，但是从可读性的角度来看，这仍然不理想，因为如果您在一个地方索引行，然后索引一列，除非您对变量命名非常严格，否则很容易丢失索引的确切内容。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="7a44" class="mg mh iq mc b gy mi mj l mk ml"><em class="mm"># this is what chained indexing looks like</em><br/>data_view_series = df_large[:10]["mixed_ints"]<br/>data_view_df = df_large[:10][["mixed_ints", "positive_ints"]]</span><span id="e5f6" class="mg mh iq mc b gy mn mj l mk ml"><em class="mm"># this is also chained indexing, but low-key</em><br/>row_subset_df = df_large[:10]<br/>data_view_df = row_subset_df[["mixed_ints", "positive_ints"]]</span></pre><p id="d3cb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第二个例子不是人们通常想要做的，它经常发生在人们在嵌套的<code class="fe nw nx ny mc b">for</code>循环中修改数据帧的时候，首先你遍历每一行，然后你想对一些列做一些事情。如果你得到了一个<code class="fe nw nx ny mc b">SettingWithCopyWarning</code>，试着寻找这些类型的模式或者任何你可能分别切片行然后切片列(或者反过来)的模式，并用<code class="fe nw nx ny mc b">df.loc[rows, columns]</code>替换它们。</p><h1 id="543f" class="mq mh iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">常见的无声故障</h1><p id="ea25" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">即使你做了以上所有的事情，有时熊猫的灵活性会诱使你犯错误，而这些错误实际上并不会使你犯错。这些是特别有害的，因为你常常意识不到有问题，直到下游的事情没有意义，并且很难追溯到原因是什么。</p><h2 id="0986" class="mg mh iq bd mr nm nn dn mv no np dp mz lo nq nr nb ls ns nt nd lw nu nv nf iw bi translated">查看与复制</h2><p id="32c8" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">数据框的视图和副本在其包含的值方面可能与您完全相同，但视图引用的是现有数据框的一部分，而副本则是完全不同的数据框。如果更改视图，则更改现有数据框架，但如果更改副本，则原始数据框架不受影响。当您认为正在修改副本时，请确保没有修改视图，反之亦然。</p><p id="c805" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">事实证明，你是在处理一个副本，还是一个观点是很难预测的！从内部来说，panases会返回一个视图或一个副本，来尝试进行优化，具体取决于数据帧和您采取的操作。您可以使用<code class="fe nw nx ny mc b">df.copy()</code>强制熊猫为您制作一份拷贝，也可以通过设置<code class="fe nw nx ny mc b">inplace=True</code>强制熊猫在数据帧可用时就地操作。</p><p id="2ca2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">何时进行复制，何时使用视图？这很难确定，但是如果您的数据很小，或者您的资源很大，并且您希望实现功能化和无状态化，您可以尝试为每个操作创建一个副本，就像Spark所做的那样，因为这可能是最安全的方法。另一方面，如果您有大量数据，并且有一台普通的笔记本电脑，您可能希望在适当的位置进行操作，以防止笔记本电脑崩溃。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="6272" class="mg mh iq mc b gy mi mj l mk ml"><em class="mm"># intentionally making a copy will always make a copy</em><br/>small_copy = df_small.copy()</span><span id="39dc" class="mg mh iq mc b gy mn mj l mk ml">small_copy</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/39ea68dffdd34b20a57172df30c2409f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYq7oMUkpWU-XMGuEKj5Kw.png"/></div></div></figure><p id="7d18" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">虽然它们看起来完全相同，但这实际上是一个完全独立的数据对象，不同于我们之前制作的<code class="fe nw nx ny mc b">df_small</code>。</p><p id="30cb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们来看看<code class="fe nw nx ny mc b">inplace=True</code>是做什么的。<code class="fe nw nx ny mc b">df.drop()</code>是一个允许您从数据框架中删除列的方法，也是一个熊猫数据框架方法，它允许您指定是希望就地执行操作，还是希望操作返回新对象。返回一个新的对象，或者<code class="fe nw nx ny mc b">inplace=False</code>始终是缺省值。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="811d" class="mg mh iq mc b gy mi mj l mk ml">small_copy.drop("b", axis=1)</span><span id="152b" class="mg mh iq mc b gy mn mj l mk ml">small_copy</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/39ea68dffdd34b20a57172df30c2409f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYq7oMUkpWU-XMGuEKj5Kw.png"/></div></div></figure><p id="7f04" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">跌落发生了什么？它返回一个新对象，但您没有用变量指向它，所以它消失了。原文<code class="fe nw nx ny mc b">small_copy</code>保持不变。现在让我们打开就地修改:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="b62f" class="mg mh iq mc b gy mi mj l mk ml">small_copy.drop("b", axis=1, inplace=True)</span><span id="ebb3" class="mg mh iq mc b gy mn mj l mk ml">small_copy</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/9b2c20d2acf15c4efbd0d6e382b20e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7lEDirew4R1zzfDG4QOuw.png"/></div></div></figure><p id="edbc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">原来的<code class="fe nw nx ny mc b">small_copy</code>，现在已经变了。好在我们做了一份拷贝！</p><p id="b115" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们重新制作<code class="fe nw nx ny mc b">small_copy</code>并做点修改，看看我之前所说的原始数据框架是一个不同的对象是什么意思。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="84ce" class="mg mh iq mc b gy mi mj l mk ml"><em class="mm"># let's see what happens if you assign to a copy</em><br/>small_copy = df_small.copy()</span><span id="ff75" class="mg mh iq mc b gy mn mj l mk ml"><em class="mm"># you should always use `loc` for assignment</em><br/>small_copy.loc[0, 'b'] = 4</span><span id="389f" class="mg mh iq mc b gy mn mj l mk ml">small_copy</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/4345716e7650717c697fafb2bda55f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJjuWcggE1GP8P505iKS-Q.png"/></div></div></figure><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="3693" class="mg mh iq mc b gy mi mj l mk ml"><em class="mm"># original is unchanged</em><br/>df_small</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/39ea68dffdd34b20a57172df30c2409f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYq7oMUkpWU-XMGuEKj5Kw.png"/></div></div></figure><h2 id="5045" class="mg mh iq bd mr nm nn dn mv no np dp mz lo nq nr nb ls ns nt nd lw nu nv nf iw bi translated">注意无序处理</h2><p id="d153" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">在Jupyter笔记本中，无序地更改和重新处理单元几乎是不可避免的——我们知道不该这样做，但最终总是会发生。这是view vs. copy问题的一个子集，因为如果知道要进行的更改从根本上改变了列的属性，就应该消耗内存成本并创建一个新的副本，否则可能会发生类似的情况，在此块中反复运行后两个单元格，看到最大值变得非常不稳定。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="5c55" class="mg mh iq mc b gy mi mj l mk ml">large_copy = df_large.copy()<br/>large_copy.loc[0, "positive_ints"] = 120<br/>large_copy["positive_ints"].max()</span><span id="bf8d" class="mg mh iq mc b gy mn mj l mk ml">&gt; 120</span></pre><p id="94a0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">记住，<code class="fe nw nx ny mc b">positive_ints</code>被设置在0到100之间，这意味着将第一个值设置为120意味着现在最大值必须是120。但是如果我运行几次这样的细胞会怎么样呢？</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="4d29" class="mg mh iq mc b gy mi mj l mk ml">large_copy["positive_ints"] = large_copy["positive_ints"] * 3<br/>large_copy["positive_ints"].max()</span><span id="81e6" class="mg mh iq mc b gy mn mj l mk ml">&gt; 360</span></pre><p id="fc26" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第一次运行它时，它的行为与预期的一样，但是再次运行它…</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="eb98" class="mg mh iq mc b gy mi mj l mk ml">large_copy["positive_ints"] = large_copy["positive_ints"] * 3<br/>large_copy["positive_ints"].max()</span><span id="3fb6" class="mg mh iq mc b gy mn mj l mk ml">&gt; 1080</span></pre><p id="7af9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个例子看似显而易见，但让细胞不可逆地改变数据，并在每次重新运行时自动构建，这真的很容易。避免这个问题的最好方法是，当您开始一个将产生显著的就地数据突变的单元时，用新的变量名创建一个新的数据框架。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="0792" class="mg mh iq mc b gy mi mj l mk ml">large_copy_x3 = large_copy.copy()<br/>large_copy_x3["positive_ints"] = large_copy["positive_ints"] * 3<br/>large_copy_x3["positive_ints"].max()</span><span id="4321" class="mg mh iq mc b gy mn mj l mk ml">&gt; 360</span></pre><p id="ad4b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">无论你运行那个块多少次，它总会返回360，就像你最初预期的那样。</p><h2 id="2d26" class="mg mh iq bd mr nm nn dn mv no np dp mz lo nq nr nb ls ns nt nd lw nu nv nf iw bi translated">切勿将错误设置为“忽略”</h2><p id="ff96" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">默认情况下，一些Pandas方法允许您忽略错误。这几乎总是一个坏主意，因为忽略错误意味着它只是将未解析的输入放在输出应该在的地方。让我们用两个正常的日期和一个未来的日期制作一个系列。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="051c" class="mg mh iq mc b gy mi mj l mk ml">parsed_dates = pd.to_datetime(["10/11/2018", "01/30/1996", "04/15/9086"], format="%m/%d/%Y", errors="ignore")</span><span id="0eed" class="mg mh iq mc b gy mn mj l mk ml">parsed_dates</span><span id="a6e8" class="mg mh iq mc b gy mn mj l mk ml">&gt; array(['10/11/2018', '01/30/1996', '04/15/9086'], dtype=object)</span></pre><p id="8553" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，在示例输出中，如果您不太熟悉Pandas输出应该是什么，那么看到<code class="fe nw nx ny mc b">array</code>类型的输出对您来说可能并不奇怪，您可能只是继续您的分析，而不知道有什么地方出错了。</p><p id="8c47" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你关闭<code class="fe nw nx ny mc b">errors="ignore"</code>，你会看到回溯:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="358b" class="mg mh iq mc b gy mi mj l mk ml">Traceback (most recent call last):<br/>  File "&lt;ipython-input-22-12145c38fd6e&gt;", line 3, in &lt;module&gt;<br/>    pd.to_datetime(["10/11/2018", "01/30/1996", "04/15/9086"], format="%m/%d/%Y")<br/>pandas._libs.tslibs.np_datetime.OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 9086-04-15 00:00:00</span></pre><p id="6870" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这里发生的事情是，Python时间戳以纳秒为单位进行索引，该数字存储为一个<code class="fe nw nx ny mc b">int64</code>，因此任何晚于大约2262年的年份都将超出其存储能力。作为一名数据科学家，你可能会被原谅不知道这一点点的秘密，但这只是隐藏在Python/Pandas中的许多隐藏的特质之一，所以忽略它会给你带来危险。</p><p id="f942" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你想知道，这就是约会系列应该有的样子:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="603b" class="mg mh iq mc b gy mi mj l mk ml">pd.to_datetime(["10/11/2018", "01/30/1996"], format="%m/%d/%Y")</span><span id="7b3f" class="mg mh iq mc b gy mn mj l mk ml">&gt; DatetimeIndex(['2018-10-11', '1996-01-30'], dtype='datetime64[ns]', freq=None)</span></pre><h2 id="cd8f" class="mg mh iq bd mr nm nn dn mv no np dp mz lo nq nr nb ls ns nt nd lw nu nv nf iw bi translated"><code class="fe nw nx ny mc b">object</code> dtype可以隐藏混合类型<a class="ae le" href="http://localhost:8888/notebooks/pandas-pandemonium.ipynb#The-object-dtype-can-hide-mixed-types" rel="noopener ugc nofollow" target="_blank"> </a></h2><p id="05eb" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">每个熊猫列都有一个类型，但是有一个叫做<code class="fe nw nx ny mc b">object</code>的超级类型，这意味着每个值实际上只是一个指向某个任意对象的指针。这使得熊猫有很大的灵活性(即列表或字典或任何你想要的东西的列！)，但这可能会导致静默失败。</p><p id="95af" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">剧透预警:</strong>这不会是<code class="fe nw nx ny mc b">object</code>型第一次给我们带来问题。我不想说你不应该使用它，但是一旦你进入生产模式，你绝对应该谨慎使用它。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="ec0c" class="mg mh iq mc b gy mi mj l mk ml"><em class="mm"># we start out with integer types for our small data</em><br/>small_copy = df_small.copy()<br/>small_copy.dtypes</span><span id="24f4" class="mg mh iq mc b gy mn mj l mk ml">&gt; <br/>a    int64<br/>b    int64<br/>dtype: object</span><span id="e31a" class="mg mh iq mc b gy mn mj l mk ml"><em class="mm"># reset ones of the column's dtype to `object`</em><br/>small_copy["b"] = small_copy["b"].astype("object")<br/>small_copy.dtypes</span><span id="2fd2" class="mg mh iq mc b gy mn mj l mk ml">&gt;<br/>a    int64<br/>b    object<br/>dtype: object</span></pre><p id="c9a9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在让我们再做一些恶作剧，用可能是最令人沮丧的无声失败之一来改变<code class="fe nw nx ny mc b">b</code>专栏。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="1a7f" class="mg mh iq mc b gy mi mj l mk ml">small_copy["b"] = [4, "4"]<br/>small_copy</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/69d74abf2e4bde4bb8c3301233ce39be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbADKa5N3TMYze5WanedZA.png"/></div></div></figure><p id="1d24" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(我相信对你们中的许多人来说，这是黑板上的钉子的数据等价物。)</p><p id="89a9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，假设您需要删除重复项并发送结果。如果您按列<code class="fe nw nx ny mc b">a</code>放置，您将得到预期的结果:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="f8ee" class="mg mh iq mc b gy mi mj l mk ml">small_copy.drop_duplicates("a")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/d95a55704263beb64af433ca936d800f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqAOTVIJZ47LczyyhnSZ8g.png"/></div></div></figure><p id="52d0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是，如果您按列<code class="fe nw nx ny mc b">b</code>放置，您将得到以下结果:</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="16e9" class="mg mh iq mc b gy mi mj l mk ml">small_copy.drop_duplicates("b")</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/69d74abf2e4bde4bb8c3301233ce39be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbADKa5N3TMYze5WanedZA.png"/></div></div></figure><h2 id="ba76" class="mg mh iq bd mr nm nn dn mv no np dp mz lo nq nr nb ls ns nt nd lw nu nv nf iw bi translated">谨慎对待熊猫模式推理</h2><p id="84a1" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">当你加载一个大的混合型CSV时，Pandas给你设置<code class="fe nw nx ny mc b">low_memory=False</code>的选项，当它遇到一些它不知道如何处理的数据时，它实际上正在做的只是使整个列<code class="fe nw nx ny mc b">object</code>类型化，以便它可以转换为<code class="fe nw nx ny mc b">int64</code>或<code class="fe nw nx ny mc b">float64</code>的数字得到转换，但它不能转换的东西只是作为<code class="fe nw nx ny mc b">str</code>放在那里。这使得列值暂时能够和平共存。但是一旦你尝试对它们做任何操作，你会发现Pandas一直试图告诉你，你不能假设所有的值都是数字。</p><p id="796d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">注意:</strong>记住，在Python中，<code class="fe nw nx ny mc b">NaN</code>是一个<code class="fe nw nx ny mc b">float</code>！因此，如果您的数字列有它们，即使它们实际上是<code class="fe nw nx ny mc b">int</code>，也将其转换为<code class="fe nw nx ny mc b">float</code>。</p><p id="0cba" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们创建一个故意迟钝的数据帧，并把它保存在某个地方，以便我们可以读回它。这个数据帧有一个整数和一个字符串的组合，作者(很可能是人，可能在Excel中工作)认为这是一个NaN值的指示，但实际上缺省的NaN解析器并不包含它。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="5927" class="mg mh iq mc b gy mi mj l mk ml">mixed_df = pd.DataFrame({"mixed": [100] * 100 + ["-"] + [100] * 100, "ints": [100] * 201})</span><span id="92b5" class="mg mh iq mc b gy mn mj l mk ml">mixed_df.to_csv("test_load.csv", header=True, index=False)</span></pre><p id="8cd2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当您读回它时，Pandas将尝试进行模式推理，但它会在混合类型列上出错，并且不会试图对此过于固执己见，而是将值保留在<code class="fe nw nx ny mc b">object</code>列中。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="dd71" class="mg mh iq mc b gy mi mj l mk ml">mixed_df = pd.read_csv("test_load.csv", header=0)<br/>mixed_df.dtypes</span><span id="5777" class="mg mh iq mc b gy mn mj l mk ml">&gt;<br/>mixed    object<br/>ints     int64<br/>dtype: object</span></pre><p id="0e6d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">确保正确解释数据的最佳方法是手动设置dtypes并指定NaN字符。这是一件痛苦的事情，而且您并不总是必须这样做，但是打开您拥有的任何数据文件的前几行并确保它真的可以被自动解析总是一个好主意。</p><pre class="kp kq kr ks gt mb mc md me aw mf bi"><span id="85d8" class="mg mh iq mc b gy mi mj l mk ml">mixed_df = pd.read_csv("test_load.csv", header=0, dtype={"mixed": float, "ints": int}, na_values=["-"])<br/>mixed_df.dtypes</span><span id="4795" class="mg mh iq mc b gy mn mj l mk ml">&gt;<br/>mixed    float64<br/>ints     int64<br/>dtype: object</span></pre><h1 id="60a4" class="mq mh iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">结论，第一部分</h1><p id="3479" class="pw-post-body-paragraph lf lg iq lh b li nh ka lk ll ni kd ln lo nj lq lr ls nk lu lv lw nl ly lz ma ij bi translated">熊猫可能是自切片列表以来最伟大的东西，但它是自动魔法，直到它不是。要了解何时以及如何让它掌控方向盘，何时必须手动超越，你要么需要对它的内部工作原理有一个扎实的了解，要么你可以像我一样，用头撞它们五年，并尝试从你的错误中吸取教训。俗话说，骗我一次，不要脸。愚弄我725次…不能再愚弄我了。</p><p id="6103" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请查看<a class="ae le" href="https://medium.com/@protagonistwu/how-to-avoid-a-pandas-pandemonium-part-ii-3426f53d7fba" rel="noopener">第二部分:加速和内存优化</a>。</p></div></div>    
</body>
</html>