<html>
<head>
<title>Implementing Gene Drives into Genetic Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在遗传算法中实现基因驱动</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-gene-drives-into-genetic-algorithms-d245a5cc989f?source=collection_archive---------46-----------------------#2020-11-06">https://towardsdatascience.com/implementing-gene-drives-into-genetic-algorithms-d245a5cc989f?source=collection_archive---------46-----------------------#2020-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f2bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索基因工程的新技术</h2></div><p id="a173" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人类已经转向大自然去寻找优化的系统，去解决复杂的问题。就遗传算法而言，人类已经在一个程序中模拟了进化，以优化神经网络的权重。</p><p id="dc0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着最近遗传工程的兴起，我相信遗传算法可以通过这些技术得到改进。在这篇文章中，我将介绍一下基因驱动的实现</p><h1 id="1a83" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">什么是基因驱动？</h1><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/01170ac5ded9e71fa82e1285976c862d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCri8uXsIyFeRH26FVm5CQ.png"/></div></div><p class="mi mj gj gh gi mk ml bd b be z dk translated"><a class="ae mm" href="https://en.wikipedia.org/wiki/File:Gene_Drive.png" rel="noopener ugc nofollow" target="_blank">图片</a>来自<a class="ae mm" href="https://en.wikipedia.org/wiki/Gene_drive" rel="noopener ugc nofollow" target="_blank">维基百科</a>。<a class="ae mm" href="https://en.wikipedia.org/wiki/Wikipedia:Ten_things_you_may_not_know_about_images_on_Wikipedia#:~:text=You%20can%20use%20(free)%20images,site%2C%20or%20anywhere%20you%20like.&amp;text=While%20all%20article%20text%20is,licenses%20for%20the%20many%20possibilities." rel="noopener ugc nofollow" target="_blank">版权所有</a></p></figure><p id="02e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基因驱动允许基因以更高的速度传递给下一代生物。看上面的图表:图像的左边代表一个基因从父母传给下一代。由于一半的遗传信息来自父亲，一半来自母亲，所以后代有50%的机会继承这一基因。</p><p id="904c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在一种昆虫的情况下，其遗传信息已经被基因驱动改变，该昆虫的所有后代都将获得这种基因，因此允许这种改变影响未来的所有世代。</p><h1 id="8225" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">基因驱动是如何工作的？</h1><p id="9139" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在正常的CRISPR-Cas9基因工程中，CRISPR蛋白被编程为针对特定基因，该基因被新的序列取代。</p><p id="4f04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于基因驱动，过程是不同的。CRISPR蛋白将自身插入到基因序列中，同时插入目标基因的信息。当序列的这一部分被激活时，CRISPR蛋白将搜索这个基因，并用“正确的”(插入基因驱动的同一基因)替换所有“错误的”(不是插入基因驱动的同一基因)，导致该基因有可能传播。</p><p id="bb5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然你对基因驱动有了基本的了解，让我们从创建一个简单的遗传算法开始，它能够训练神经网络。</p><h1 id="884c" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">遗传算法:</h1><p id="b531" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">正如我前面提到的，遗传算法模拟进化。生成具有特定遗传信息(在这种情况下，是神经网络的权重)的代理群体(在这种情况下，是神经网络)。一个算法计算每个代理的适应值，并计算适应值(在这种情况下，损失)。损失最低的前20%的人口然后随机选择一个父母并产生两个后代，每个后代包含每个父母的遗传信息。重复该循环，直到产生具有令人满意的损失值的代理。</p><p id="5890" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们试着用Python来创建这个:</p><h2 id="4952" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">步骤1|先决条件:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="286d" class="ms lf it nf b gy nj nk l nl nm">import random<br/>import numpy as np<br/>from IPython.display import clear_output</span><span id="ff83" class="ms lf it nf b gy nn nk l nl nm">def sigmoid(x):<br/>    return 1/(1+np.exp(-x))</span></pre><p id="f149" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">先决条件是程序运行所需的基本依赖关系。Random用于代理的随机生成，numpy用于矩阵的初始化和操作，IPython display用于消除屏幕上的混乱。</p><p id="77d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简单起见，我将在这个项目中使用的唯一激活函数是sigmoid函数。</p><h2 id="ed9a" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">步骤2|代理蓝图:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="c7d7" class="ms lf it nf b gy nj nk l nl nm">class genetic_algorithm:<br/>        <br/>    def execute(pop_size,generations,threshold,X,y,network):<br/>        class Agent:<br/>            def __init__(self,network):<br/>                class neural_network:<br/>                    def __init__(self,network):<br/>                        self.weights = []<br/>                        self.activations = []<br/>                        for layer in network:<br/>                            if layer[0] != None:<br/>                                input_size = layer[0]<br/>                            else:<br/>                                input_size = network[network.index(layer)-1][1]<br/>                            output_size = layer[1]<br/>                            activation = layer[2]<br/>                            self.weights.append(np.random.randn(input_size,output_size))<br/>                            self.activations.append(activation)<br/>                    def propagate(self,data):<br/>                        input_data = data<br/>                        for i in range(len(self.weights)):<br/>                            z = np.dot(input_data,self.weights[i])<br/>                            a = self.activations[i](z)<br/>                            input_data = a<br/>                        yhat = a<br/>                        return yhat<br/>                self.neural_network = neural_network(network)<br/>                self.fitness = 0<br/>                self.gene_drive = []<br/>            def __str__(self):<br/>                    return 'Loss: ' + str(self.fitness[0])</span></pre><p id="96b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是程序的开始，创建了遗传算法类和执行函数。</p><p id="74d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代理具有包含网络传播指令的蓝图。在代理的init中，初始化一个神经网络类，并根据给定的矩阵结构随机生成其权重。</p><h2 id="9abe" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">步骤3|创建群体:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="1b45" class="ms lf it nf b gy nj nk l nl nm">def generate_agents(population, network):<br/>            return [Agent(network) for _ in range(population)]</span></pre><p id="5bbd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数，给定群体大小和网络结构作为参数，生成代理群体，具有随机生成权重的神经网络。</p><h2 id="987c" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">第4步|计算健康度:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="1b73" class="ms lf it nf b gy nj nk l nl nm">def fitness(agents,X,y):<br/>            for agent in agents:<br/>                yhat = agent.neural_network.propagate(X)<br/>                cost = (yhat - y)**2<br/>                agent.fitness = sum(cost)<br/>            return agents</span></pre><p id="e394" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是该遗传算法的基本适应度函数。它只是使用MSE公式来计算损失。</p><h2 id="4269" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">第五步|选择:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="de46" class="ms lf it nf b gy nj nk l nl nm">def selection(agents):<br/>            agents = sorted(agents, key=lambda agent: agent.fitness, reverse=False)<br/>            print('\n'.join(map(str, agents)))<br/>            agents = agents[:int(0.2 * len(agents))]<br/>            return agents</span></pre><p id="c55a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">程序的这一部分是选择算法，它根据智能体的适应值以相反的顺序对智能体进行排序。然后，它会清除不在此列表前五分之一的所有代理。</p><h2 id="68ba" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">第六步|交叉:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="718b" class="ms lf it nf b gy nj nk l nl nm">def crossover(agents,network,pop_size):<br/>            offspring = []<br/>            for _ in range((pop_size - len(agents)) // 2):<br/>                parent1 = random.choice(agents)<br/>                parent2 = random.choice(agents)<br/>                child1 = Agent(network)<br/>                child2 = Agent(network)<br/>                <br/>                shapes = [a.shape for a in parent1.neural_network.weights]<br/>                <br/>                genes1 = np.concatenate([a.flatten() for a in parent1.neural_network.weights])<br/>                genes2 = np.concatenate([a.flatten() for a in parent2.neural_network.weights])<br/>                <br/>                split = random.randint(0,len(genes1)-1)</span><span id="b8b3" class="ms lf it nf b gy nn nk l nl nm">child1_genes = np.array(genes1[0:split].tolist() + genes2[split:].tolist())<br/>                child2_genes = np.array(genes1[0:split].tolist() + genes2[split:].tolist())<br/>                <br/>                for gene in parent1.gene_drive:<br/>                    child1_genes[gene] = genes1[gene]<br/>                    child2_genes[gene] = genes1[gene]<br/>                    <br/>                for gene in parent2.gene_drive:<br/>                    child1_genes[gene] = genes2[gene]<br/>                    child2_genes[gene] = genes2[gene]<br/>                <br/>                child1.neural_network.weights = unflatten(child1_genes,shapes)<br/>                child2.neural_network.weights = unflatten(child2_genes,shapes)<br/>                <br/>                offspring.append(child1)<br/>                offspring.append(child2)<br/>            agents.extend(offspring)<br/>            return agents</span></pre><p id="83e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从人口的前20%中随机选择两个父母。然后它们繁殖。这是如何做到的:</p><ol class=""><li id="6997" class="no np it kk b kl km ko kp kr nq kv nr kz ns ld nt nu nv nw bi translated">它们的重量变平了</li><li id="aed7" class="no np it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">找到一个随机的交点。这个点是一个父母的遗传信息结束的地方，也是一个父母的遗传信息开始的地方。</li><li id="173a" class="no np it kk b kl nx ko ny kr nz kv oa kz ob ld nt nu nv nw bi translated">创建两个子代，然后将它们添加到代理列表中。这些孩子彼此不同，因为他们有不同交叉点。</li></ol><p id="0a40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有望让好父母的优良品质传递给他们的后代。</p><h2 id="7066" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">第七步|突变:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="aa76" class="ms lf it nf b gy nj nk l nl nm">def mutation(agents):<br/>            for agent in agents:<br/>                if random.uniform(0.0, 1.0) &lt;= 0.1:<br/>                    weights = agent.neural_network.weights<br/>                    shapes = [a.shape for a in weights]</span><span id="20b8" class="ms lf it nf b gy nn nk l nl nm">flattened = np.concatenate([a.flatten() for a in weights])<br/>                    randint = random.randint(0,len(flattened)-1)<br/>                    flattened[randint] = np.random.randn()</span><span id="e7cf" class="ms lf it nf b gy nn nk l nl nm">newarray = []<br/>                    indeweights = 0<br/>                    for shape in shapes:<br/>                        size = np.product(shape)<br/>                        newarray.append(flattened[indeweights : indeweights + size].reshape(shape))<br/>                        indeweights += size<br/>                    agent.neural_network.weights = newarray<br/>            return agents</span></pre><p id="954a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每一种药剂都有10%的几率会发生变异。在这种情况下，突变是指某个权重值被随机的浮点值替换。这是通过展平权重、找到要改变的随机权重，然后最后重新整形要重新插入代理的权重来完成的。</p><h2 id="05f2" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">第八步|基因驱动:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="300b" class="ms lf it nf b gy nj nk l nl nm">def gene_drive(agents):<br/>            for agent in agents:<br/>                if random.uniform(0.0, 1.0) &lt;= 0.1:<br/>                    weights = agent.neural_network.weights<br/>                    shapes = [a.shape for a in weights]</span><span id="de14" class="ms lf it nf b gy nn nk l nl nm">flattened = np.concatenate([a.flatten() for a in weights])<br/>                    target_gene = random.randint(0,len(flattened)-1)<br/>                    if not(target_gene in agent.gene_drive):<br/>                        agent.gene_drive.append(target_gene)</span><span id="b904" class="ms lf it nf b gy nn nk l nl nm">newarray = []<br/>                    indeweights = 0<br/>                    for shape in shapes:<br/>                        size = np.product(shape)<br/>                        newarray.append(flattened[indeweights : indeweights + size].reshape(shape))<br/>                        indeweights += size<br/>                    agent.neural_network.weights = newarray<br/>            return agents</span></pre><p id="e652" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这个脚本将基因驱动插入到代理中，但是如果您仔细查看代码，您已经可以看到对基因驱动框架的规避，从而影响程序的其他部分。比如在交叉指令中，其实解释了基因驱动是如何实现的。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="9aca" class="ms lf it nf b gy nj nk l nl nm">for gene in parent1.gene_drive:<br/>                    child1_genes[gene] = genes1[gene]<br/>                    child2_genes[gene] = genes1[gene]<br/>                    <br/>                for gene in parent2.gene_drive:<br/>                    child1_genes[gene] = genes2[gene]<br/>                    child2_genes[gene] = genes2[gene]</span></pre><p id="6613" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就这么简单！如果基因存在于父母的基因驱动中，孩子会将自己的基因改变为父母的基因，即具有基因驱动的基因。</p><h2 id="ef9f" class="ms lf it bd lg mt mu dn lk mv mw dp lo kr mx my lq kv mz na ls kz nb nc lu nd bi translated">第9步|执行:</h2><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="45bb" class="ms lf it nf b gy nj nk l nl nm">for i in range(generations):<br/>            print('Generation',str(i),':')<br/>            agents = generate_agents(pop_size,network)<br/>            agents = fitness(agents,X,y)<br/>            agents = selection(agents)<br/>            agents = gene_drive(agents)<br/>            agents = crossover(agents,network,pop_size)<br/>            agents = mutation(agents)<br/>            agents = fitness(agents,X,y)<br/>            <br/>            if any(agent.fitness &lt; threshold for agent in agents):<br/>                print('Threshold met at generation '+str(i)+' !')<br/>                <br/>            if i % 100:<br/>                clear_output()<br/>                <br/>        return agents[0]</span></pre><p id="07be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将最后一段代码粘贴到函数中，函数应该在被调用时运行。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="ed09" class="ms lf it nf b gy nj nk l nl nm">X = np.array([[0,0,1], [1,1,1], [1, 0, 1], [0, 1, 1]])<br/>y = np.array([[0,1,1,0]]).T<br/>network = [[3,20,sigmoid],[None,1,sigmoid]]<br/>ga = genetic_algorithm<br/>agent = ga.execute(10000,1000,0.1,X,y,network)<br/>weights = agent.neural_network.weights<br/>agent.fitness<br/>agent.neural_network.propagate(X)</span></pre><p id="f1ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">神经网络的任务很简单。结构为(3，20，1)的网络，每层都有sigmoid激活函数。对于每一代新的群体，会产生10000个新的因子，这样重复1000代。</p><h1 id="1306" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">结论:</h1><p id="b306" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">基因驱动遗传算法实际上比普通遗传算法更差。我的假设是，基因驱动将应用于早期的代理人，从定义上来说，没有未来的代理人好。</p><p id="71c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我决定实现一个阈值，在这个阈值中，只有低丢失值才会有随机归因于其基因组中某个基因的基因驱动。</p><p id="5d44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新代码:</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="bd8f" class="ms lf it nf b gy nj nk l nl nm">def gene_drive(agents):<br/>            for agent in agents:<br/>                if agent.fitness &lt;= 0.1:<br/>                    weights = agent.neural_network.weights<br/>                    shapes = [a.shape for a in weights]</span><span id="aaaf" class="ms lf it nf b gy nn nk l nl nm">flattened = np.concatenate([a.flatten() for a in weights])<br/>                    target_gene = random.randint(0,len(flattened)-1)<br/>                    if not(target_gene in agent.gene_drive):<br/>                        agent.gene_drive.append(target_gene)</span><span id="05c0" class="ms lf it nf b gy nn nk l nl nm">newarray = []<br/>                    indeweights = 0<br/>                    for shape in shapes:<br/>                        size = np.product(shape)<br/>                        newarray.append(flattened[indeweights : indeweights + size].reshape(shape))<br/>                        indeweights += size<br/>                    agent.neural_network.weights = newarray<br/>                    break<br/>            return agents</span></pre><p id="7bdd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比普通的遗传算法工作得更好，产生的结果也更好。</p><h1 id="3b7f" class="le lf it bd lg lh li lj lk ll lm ln lo jz lp ka lq kc lr kd ls kf lt kg lu lv bi translated">我的链接:</h1><p id="a665" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">如果你想看更多我的内容，点击这个<a class="ae mm" href="https://linktr.ee/victorsi" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">链接</strong> </a>。</p></div></div>    
</body>
</html>