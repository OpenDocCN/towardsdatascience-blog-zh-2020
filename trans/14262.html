<html>
<head>
<title>Curious Case of Decorators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中装饰者的奇特案例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/curious-case-of-decorators-in-python-9644a99e538?source=collection_archive---------37-----------------------#2020-10-01">https://towardsdatascience.com/curious-case-of-decorators-in-python-9644a99e538?source=collection_archive---------37-----------------------#2020-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35b1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习使用Python中的函数作为对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/edf9c0812156a414156a383a1b3248f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nphtlrDbU-l1Tlfsp_nlvg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0d45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我第一次接触Python中的decorators是在我使用Flask部署我的模型的时候。我在浏览Flask文档时遇到了一个decorator函数，读起来像@app.route("/")。我很感兴趣，开始阅读更多关于它的内容，并意识到装饰者的概念非常有趣和有用。</p><p id="55fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你也遇到了类似于<strong class="la iu"> @some_function </strong>的东西，并且你很想知道它，那么你应该通读这篇文章。装饰者的概念被认为有点难以破解，本文试图简化对装饰者的理解。</p><p id="5588" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们快速浏览基础和构建模块以理解概念。</p><h2 id="acb2" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">目录:</h2><ol class=""><li id="a5a6" class="mn mo it la b lb mp le mq lh mr ll ms lp mt lt mu mv mw mx bi translated">函数是Python中的第一个类对象</li><li id="5034" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">嵌套函数的一个重要特征</li><li id="e84c" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">建造装饰者</li><li id="dad1" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">广义装饰者</li><li id="1f96" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">结论</li><li id="9b14" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">参考</li></ol><p id="2fb0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了掌握装饰者的概念，我们应该首先知道并习惯于将函数作为对象使用。</p><h1 id="edc7" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated"><strong class="ak">函数是Python中的第一类对象</strong></h1><p id="f5a8" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在Python中，一切都是对象，称某个对象为第一类对象只是一个花哨的形容词，用于表示具有以下特权的对象。</p><ul class=""><li id="b039" class="mn mo it la b lb lc le lf lh nr ll ns lp nt lt nu mv mw mx bi translated">函数可以存储在列表、元组和字典等数据结构中。</li><li id="225f" class="mn mo it la b lb my le mz lh na ll nb lp nc lt nu mv mw mx bi translated">变量可以被分配给一个函数。</li><li id="f91b" class="mn mo it la b lb my le mz lh na ll nb lp nc lt nu mv mw mx bi translated">函数可以作为参数传递给其他函数。</li><li id="d469" class="mn mo it la b lb my le mz lh na ll nb lp nc lt nu mv mw mx bi translated">函数可以从函数返回。</li></ul><p id="b525" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，一个第一类对象就像一个足球，可以在程序中的任何地方传递和投掷。让我们把上面提到的第一类对象的所有特征一个一个地看一下。</p><p id="bf13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">函数可以存储在列表、元组、字典等数据结构中:</strong></p><p id="fbbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建几个简单的函数，并将它们作为集合存储在一个列表中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="20ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们定义了两个函数“加法”和“乘法”。</p><p id="bd43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其次，将这两个函数添加到一个列表中，然后通过列表访问这些函数来调用它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/26a007df15de4f05a50209f5a70e4530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbOAUNFf5SCG8T8bqqR2gg.png"/></div></div></figure><p id="f128" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，由此我们可以很容易地看出，函数可以存储到一个集合类型的数据结构中。</p><p id="6d3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">变量可以分配给一个函数:</strong></p><p id="4714" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将一个变量赋给一个函数，然后使用所赋的变量名调用该函数。下面给出的代码显示了同样的情况。</p><p id="c336" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在代码中，我们将变量“var_add”赋给了函数“add”。最后，分配的变量已被用来成功调用函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/be17d55ec42a36a87318a1eaeb66208d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-RSdo7864lVkAj2lKHXbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">***</p></figure><p id="5d37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">函数可以作为参数传递给其他函数:</strong></p><p id="6fe1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Python中，函数是一个对象，所以它也可以作为参数传递给其他函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/8d826394263a03bb687ee615f1d3ee09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNj69R0YkVG0l8pIU6Y1zw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">***</p></figure><p id="0dc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里要注意的一件重要事情是，当我们将函数作为对象传递时，我们从不使用带括号的函数。原因很简单，函数和括号是用来进行函数调用的。</p><p id="c76f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面提到的代码显示了不同之处。我们知道type()函数返回对象/类的类型，因此我们将type function应用于带括号和不带括号的函数名，以了解两者之间的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/c065b73997066fa05730a283808ecfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwyfTjISrjoGQT7_en5ppw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">***</p></figure><p id="832e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">一个函数可以从一个函数返回:</strong></p><p id="3224" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上所述，我们知道函数是一个对象，因此函数可以返回一个函数对象。下面的代码显示了同样的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f528d301222f5632d3d9d6511e70d1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNQV3SovC2zJXyKjWdG-Tg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">***</p></figure><h1 id="43f9" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated">嵌套函数的一个重要特征</h1><p id="f3b7" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">为了理解Decorators，我们需要知道嵌套函数的一个非常重要的特性，我们将在这里简要讨论这个特性。</p><p id="87f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的代码中，我们定义了一个外部函数，一个内部函数嵌套在外部函数中。这里要注意的有趣的事情是，内部嵌套函数可以访问外部函数的参数/自变量。</p><p id="65ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:参数指的是我们定义函数时的变量，而实参是调用函数时赋给那些参数的值。</p><p id="1c54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嵌套函数可以访问封闭范围的参数/变量。这种功能的嵌套函数叫做 <a class="ae od" href="https://www.programiz.com/python-programming/closure" rel="noopener ugc nofollow" target="_blank"> <em class="oa">闭包</em> </a> <em class="oa">。这个特性在装饰者中被广泛使用。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/766fad4cc1d06d9e69ed02ddcbde62ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8j5LcqhsSnKLyOSNM9teSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">***</p></figure><h1 id="efbd" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated">建造装饰者</h1><p id="5870" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">现在，我们知道了函数对象的一些最重要的特性。因此，我们有完美的基础来建立装饰者的概念。</p><p id="c474" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先让我们看一下装饰函数的定义。</p><blockquote class="of og oh"><p id="8fe5" class="ky kz oa la b lb lc ju ld le lf jx lg oi li lj lk oj lm ln lo ok lq lr ls lt im bi translated">Python中的decorator是一个接受另一个函数作为参数的函数，它通常会修改或增强它接受的函数，并返回修改后的函数。</p></blockquote><p id="d702" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解decorator的定义，让我们一步一步地看下面给出的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="55e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们定义了一个名为“decorator”的装饰函数。此函数接受另一个函数“func”作为参数。</p><p id="bd82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其次，decorator函数是一个外部函数，它还有一个内部函数，名为“wrapper ”,定义在decorator函数内部。这个包装函数调用func(a，b)函数，返回func(a，b)函数返回值的平方。</p><p id="35f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第三，这个装饰函数接受' func '作为参数，并返回包装函数。</p><p id="8ee0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第四，我们还单独定义了一个函数add。定义这个函数的目的是将这个函数传递给装饰函数，并检查它是如何被修改的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/05afd9baf2eef457b844c4489dedb010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UgV_dMXsfJ7tIUaWQBjn7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">***</p></figure><p id="d116" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，在对它应用装饰函数之后,“添加”函数的行为被完全修改了。</p><p id="d2c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们更深入地检查底层函数的名称，我们会看到它是包装函数，运行在名称“add”下。因此' add '只是一个赋给包装函数的变量名。</p><p id="abe8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么在应用装饰器之后，原始函数“add”不是将数字相加，而是将数字的和平方的原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/c9c92b3b690e550b61ac6f8b63a4f36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMfgpRPqSlNJkWBFB7QMJA.png"/></div></div></figure><p id="4264" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">装饰者中@的使用:</strong></p><p id="5d60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了提高装饰器的可读性，我们使用@和装饰器函数名。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="3dad" class="lu lv it oo b gy os ot l ou ov"># Without using @<br/>add = decorator(add)</span></pre><p id="46bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="a6ad" class="lu lv it oo b gy os ot l ou ov"># with @<br/>@decorator<br/>def add(x,y):<br/>     return x+y</span></pre><p id="a1d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两种方式(有或没有' @ ')我们都可以分配一个装饰函数。然而，使用' @ '是一种普遍接受的、干净的方法，可以给python函数分配decorators。</p><h1 id="3a8f" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated">广义装饰者</h1><p id="9bff" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">装饰器通常在它修改的函数之前定义。然而，在上面定义的装饰器中，包装函数使用的参数数量与装饰器所应用的函数中的参数数量相同。这只是一个简单的例子，展示了decorator如何工作。</p><p id="f0eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与上面定义的装饰器相比，如果我们想要创建一个可以应用于任何函数的装饰器，那么我们需要在分配参数数量上的灵活性。这种灵活性是通过*args和**kwargs实现的。*args和**kwargs允许我们向函数传递多个参数或基于关键字的参数。</p><p id="c88c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从下面的代码中我们可以看到，在调用函数xyz时，我们传递了多个参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d791" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">多个参数存储在变量args中，而*用于解包这些参数，因此我们能够实现函数中参数数量的灵活性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/ef5867afb502d63eacc3d44d9f037173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opPVlvDB5GAPqmzQH9pvvQ.png"/></div></div></figure><p id="8835" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用两个参数调用同一个xyz函数，它工作得很好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/921d90662d7cea3b5e75f2944a5719e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kJz4LsEDJnt1-szeL0p7A.png"/></div></div></figure><p id="7400" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们可以理解下面代码中提到的**kwargs的功能。这里**再次充当解包操作符，而kwargs充当键值对的字典。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e5b752ab0ba78314e83afc0512b1e55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siNxdx879CdTPzkZtzaD8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk">***</p></figure><p id="8602" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在知道了*args和**kwargs之后，我们可以创建一个与参数数量无关的通用装饰器。</p><p id="069c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面提到的代码显示了我们如何根据包装函数的要求使用*args，**kwargs，因为最终包装函数将通过使用原始函数的参数来替换原始函数(add_num(x，y))。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="83e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在对原始函数add_num应用装饰函数之后，它被修改了，它开始返回参数的平方和，而不是添加参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/3da4a5cae760a8ad915e0084d6717643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q37f3HZ3k7qth0tNmLE21Q.png"/></div></div></figure><p id="8992" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在带有任意数量参数的函数上应用这个装饰器(参考下面的代码)。所以我们可以一次创建一个装饰器，并在任何需要的地方使用它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/19bd8040175daf80ad4529dfd722bc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zi6OkxlDE6KNagw0t3XjYw.png"/></div></div></figure><h1 id="a968" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated">结论</h1><p id="9e78" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">本文的目的是给你足够的信息，让读者更容易理解、工作和构建装饰者的基础。</p><p id="2716" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于数据爱好者来说，有几个地方你会遇到Python中的decorators:</p><ol class=""><li id="0315" class="mn mo it la b lb lc le lf lh nr ll ns lp nt lt mu mv mw mx bi translated">同时使用Flask或Django等框架部署您的模型。</li><li id="8b95" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">创建web应用程序时。</li><li id="4d21" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">Python中有几个内置的decorators，比如@classmethod和@staticmethod，它们在定义类时被用来创建可选的构造函数等等。</li><li id="ae98" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">关于decorators的更多信息，请浏览参考列表中给出的文章和文档。</li></ol><h1 id="52f0" class="nd lv it bd lw ne nf ng lz nh ni nj mc jz nk ka mf kc nl kd mi kf nm kg ml nn bi translated">参考</h1><ol class=""><li id="8ed8" class="mn mo it la b lb mp le mq lh mr ll ms lp mt lt mu mv mw mx bi translated">文献:<a class="ae od" href="https://wiki.python.org/moin/PythonDecoratorLibrary" rel="noopener ugc nofollow" target="_blank">https://wiki.python.org/moin/PythonDecoratorLibrary</a></li><li id="cc53" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae od" href="https://realpython.com/primer-on-python-decorators/#:~:text=Decorators%20provide%20a%20simple%20syntax,function%20without%20explicitly%20modifying%20it." rel="noopener ugc nofollow" target="_blank">盖尔·阿恩Hjelle的《Python装饰者入门》</a></li><li id="3aa4" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae od" href="https://python101.pythonlibrary.org/chapter25_decorators.html" rel="noopener ugc nofollow" target="_blank">https://python 101 . python library . org/chapter 25 _ decorators . html</a></li><li id="32fa" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">关闭:<a class="ae od" href="https://www.programiz.com/python-programming/closure" rel="noopener ugc nofollow" target="_blank">https://www.programiz.com/python-programming/closure</a></li><li id="a72d" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated"><a class="ae od" href="https://www.datacamp.com/community/tutorials/decorators-python" rel="noopener ugc nofollow" target="_blank">Derrick MW iti关于装饰者的文章</a></li></ol></div></div>    
</body>
</html>