<html>
<head>
<title>Pytest for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家Pytest</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pytest-for-data-scientists-2990319e55e6?source=collection_archive---------6-----------------------#2020-09-26">https://towardsdatascience.com/pytest-for-data-scientists-2990319e55e6?source=collection_archive---------6-----------------------#2020-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ff51" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">适用于您的数据科学项目的Pytest综合指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb1ef6e79cdedf92311854f85ab5dc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdxIFtI2AeW3WkTaFePRjA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/@startup-stock-photos?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a>来自<a class="ae ky" href="https://www.pexels.com/photo/man-wearing-black-and-white-stripe-shirt-looking-at-white-printer-papers-on-the-wall-212286/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a></p></figure><h1 id="cb07" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动机</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="a1fd" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">应用不同的python代码来处理笔记本中的数据是很有趣的，但是为了使代码可复制，您需要将它们放入函数和类中。当你把你的代码放到脚本中时，代码可能会因为一些函数而中断。即使你的代码没有崩溃，你怎么知道你的函数是否会像你期望的那样工作？</p><p id="b388" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">例如，我们用<a class="ae ky" href="https://textblob.readthedocs.io/en/dev/" rel="noopener ugc nofollow" target="_blank"> TextBlob </a>创建一个函数来提取文本的情感，这是一个用于处理文本数据的Python库。我们希望确保它像我们预期的那样工作:如果测试结果是肯定的，函数将返回一个大于0的值，如果文本是否定的，函数将返回一个小于0的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><p id="769b" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">要确定函数是否每次都会返回正确的值，最好的方法是将函数应用于不同的示例，看看它是否会产生我们想要的结果。这就是测试变得重要的时候。</p><p id="6e3e" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">一般来说，您应该对您的数据科学项目使用测试，因为它允许您:</p><ul class=""><li id="8be1" class="mq mr it lv b lw lx lz ma mc ms mg mt mk mu mo mv mw mx my bi translated">确保代码按预期运行</li><li id="c69f" class="mq mr it lv b lw mz lz na mc nb mg nc mk nd mo mv mw mx my bi translated">检测边缘情况</li><li id="7e9b" class="mq mr it lv b lw mz lz na mc nb mg nc mk nd mo mv mw mx my bi translated">放心地用改进的代码替换现有的代码，而不用担心破坏整个管道</li><li id="4312" class="mq mr it lv b lw mz lz na mc nb mg nc mk nd mo mv mw mx my bi translated">你的队友可以通过查看你的测试来理解你的功能</li></ul><p id="7c66" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">有许多Python工具可用于测试，但最简单的工具是Pytest。</p><h1 id="d838" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Pytest入门</h1><p id="58c8" class="pw-post-body-paragraph lt lu it lv b lw ne ju ly lz nf jx mb mc ng me mf mg nh mi mj mk ni mm mn mo im bi translated">Pytest 是一个框架，它使得用Python写小测试变得很容易。我喜欢pytest，因为它帮助我用最少的代码编写测试。如果您不熟悉测试，pytest是一个很好的入门工具。</p><p id="1752" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">要安装pytest，请运行</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a66d" class="no la it nk b gy np nq l nr ns">pip install -U pytest</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e6f9" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">为了测试上面显示的函数，我们可以简单地创建一个以<code class="fe nt nu nv nk b">test_</code>开头的函数，后面是我们想要测试的函数的名称，即<code class="fe nt nu nv nk b">extract_sentiment</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><p id="7aa5" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在测试函数中，我们将函数<code class="fe nt nu nv nk b">extract_sentiment</code>应用于一个示例文本:“我认为今天将是伟大的一天”。我们使用<code class="fe nt nu nv nk b">assert sentiment &gt; 0</code>来确保情绪是积极的。</p><p id="4d2a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">就是这样！现在我们准备运行测试。</p><p id="9441" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果我们脚本的名字是<code class="fe nt nu nv nk b">sentiment.py</code>，我们可以运行</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="fac2" class="no la it nk b gy np nq l nr ns">pytest sentiment.py</span></pre><p id="a468" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">Pytest将遍历我们的脚本，并运行以<code class="fe nt nu nv nk b">test</code>开头的函数。上面测试的输出将如下所示</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="63d8" class="no la it nk b gy np nq l nr ns">========================================= test session starts ==========================================<br/>platform linux -- Python 3.8.3, pytest-5.4.2, py-1.8.1, pluggy-0.13.1</span><span id="458a" class="no la it nk b gy nw nq l nr ns">collected 1 item</span><span id="fd15" class="no la it nk b gy nw nq l nr ns">process.py .                                                                                     [100%]</span><span id="8b0b" class="no la it nk b gy nw nq l nr ns">========================================== 1 passed in 0.68s ===========================================</span></pre><p id="8490" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">相当酷！我们不需要指定测试哪个函数。只要函数名以<code class="fe nt nu nv nk b">test,</code>开头，pytest就会检测并执行那个函数！为了运行pytest，我们甚至不需要导入pytest</p><p id="b274" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果测试失败，pytest会产生什么输出？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d708" class="no la it nk b gy np nq l nr ns">&gt;&gt;&gt; pytest sentiment.py</span><span id="71e4" class="no la it nk b gy nw nq l nr ns">========================================= test session starts ==========================================<br/>platform linux -- Python 3.8.3, pytest-5.4.2, py-1.8.1, pluggy-0.13.1<br/>collected 1 item</span><span id="e942" class="no la it nk b gy nw nq l nr ns">process.py F                                                                                     [100%]</span><span id="493f" class="no la it nk b gy nw nq l nr ns">=============================================== FAILURES ===============================================<br/>________________________________________ test_extract_sentiment ________________________________________</span><span id="0cbc" class="no la it nk b gy nw nq l nr ns">def test_extract_sentiment():<br/>    <br/>        text = "I think today will be a great day"<br/>    <br/>        sentiment = extract_sentiment(text)<br/>    <br/>&gt;       assert sentiment &lt; 0<br/>E       assert 0.8 &lt; 0</span><span id="4f3b" class="no la it nk b gy nw nq l nr ns">process.py:17: AssertionError<br/>======================================= short test summary info ========================================<br/>FAILED process.py::test_extract_sentiment - assert 0.8 &lt; 0<br/>========================================== 1 failed in 0.84s ===========================================</span></pre><p id="268b" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">从输出可以看出，测试失败是因为函数的情绪是0.8，而且不小于0！我们不仅能够知道我们的功能是否像预期的那样工作，还能知道它为什么不工作。从这种洞察力中，我们知道在哪里修复我们的函数，使其按照我们想要的那样工作。</p><h1 id="1d13" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">同一功能的多次测试</h1><p id="eb57" class="pw-post-body-paragraph lt lu it lv b lw ne ju ly lz nf jx mb mc ng me mf mg nh mi mj mk ni mm mn mo im bi translated">我们可能想用其他例子来测试我们的功能。新测试函数的名称是什么？</p><p id="e33e" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果我们想在带有负面情绪的文本上测试我们的函数，第二个函数的名字可以是类似于<code class="fe nt nu nv nk b">test_extract_sentiment_2</code>或<code class="fe nt nu nv nk b">test_extract_sentiment_negative</code>的名字。任何函数名只要以<code class="fe nt nu nv nk b">test</code>开头都可以</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="c714" class="no la it nk b gy np nq l nr ns">&gt;&gt;&gt; pytest sentiment.py</span><span id="7427" class="no la it nk b gy nw nq l nr ns">========================================= test session starts ==========================================<br/>platform linux -- Python 3.8.3, pytest-5.4.2, py-1.8.1, pluggy-0.13.1<br/>collected 2 items</span><span id="ae5b" class="no la it nk b gy nw nq l nr ns">process.py .F                                                                                    [100%]</span><span id="33ec" class="no la it nk b gy nw nq l nr ns">=============================================== FAILURES ===============================================<br/>___________________________________ test_extract_sentiment_negative ____________________________________</span><span id="fbbb" class="no la it nk b gy nw nq l nr ns">def test_extract_sentiment_negative():<br/>    <br/>        text = "I do not think this will turn out well"<br/>    <br/>        sentiment = extract_sentiment(text)<br/>    <br/>&gt;       assert sentiment &lt; 0<br/>E       assert 0.0 &lt; 0</span><span id="436b" class="no la it nk b gy nw nq l nr ns">process.py:25: AssertionError<br/>======================================= short test summary info ========================================<br/>FAILED process.py::test_extract_sentiment_negative - assert 0.0 &lt; 0<br/>===================================== 1 failed, 1 passed in 0.80s ======================================</span></pre><p id="a12d" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">从输出中，我们知道一个测试通过了，一个测试失败了，以及测试失败的原因。我们期望句子‘我不认为这会变好’是否定的，但是结果是0。</p><p id="41df" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">这有助于我们理解这个函数可能不是100%准确的；因此，在使用该函数提取文本情感时，我们应该谨慎。</p><h1 id="1dd6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参数化:组合测试</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="bf0a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">上面的两个测试函数用于测试相同的函数。有没有什么方法可以把两个例子合并成一个测试函数？这就是参数化派上用场的时候</p><h2 id="f5de" class="no la it bd lb nx ny dn lf nz oa dp lj mc ob oc ll mg od oe ln mk of og lp oh bi translated">用样本列表进行参数化</h2><p id="5568" class="pw-post-body-paragraph lt lu it lv b lw ne ju ly lz nf jx mb mc ng me mf mg nh mi mj mk ni mm mn mo im bi translated">使用<code class="fe nt nu nv nk b">pytest.mark.parametrize()</code>，我们可以通过在参数中提供一个例子列表来执行不同例子的测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><p id="92b5" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在上面的代码中，我们将变量<code class="fe nt nu nv nk b">sample</code>分配给一个样本列表，然后将该变量添加到测试函数的参数中。现在每个例子将被一次测试一次。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="094e" class="no la it nk b gy np nq l nr ns">========================== test session starts ===========================<br/>platform linux -- Python 3.8.3, pytest-5.4.2, py-1.8.1, pluggy-0.13.1<br/>collected 2 items</span><span id="a707" class="no la it nk b gy nw nq l nr ns">sentiment.py .F                                                    [100%]</span><span id="614e" class="no la it nk b gy nw nq l nr ns">================================ FAILURES ================================<br/>_____ test_extract_sentiment[I do not think this will turn out well] _____</span><span id="4d7a" class="no la it nk b gy nw nq l nr ns">sample = 'I do not think this will turn out well'</span><span id="028e" class="no la it nk b gy nw nq l nr ns"><a class="ae ky" href="http://twitter.com/pytest" rel="noopener ugc nofollow" target="_blank">@pytest</a>.mark.parametrize('sample', testdata)<br/>    def test_extract_sentiment(sample):<br/>    <br/>        sentiment = extract_sentiment(sample)<br/>    <br/>&gt;       assert sentiment &gt; 0<br/>E       assert 0.0 &gt; 0</span><span id="83a0" class="no la it nk b gy nw nq l nr ns">sentiment.py:19: AssertionError<br/>======================== short test summary info =========================<br/>FAILED sentiment.py::test_extract_sentiment[I do not think this will turn out well]<br/>====================== 1 failed, 1 passed in 0.80s ===================</span></pre><p id="46a5" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">使用<code class="fe nt nu nv nk b">parametrize()</code>，我们能够在一次函数中测试2个不同的例子！</p><h2 id="06d3" class="no la it bd lb nx ny dn lf nz oa dp lj mc ob oc ll mg od oe ln mk of og lp oh bi translated">用一系列例子和预期输出来参数化</h2><p id="bfe1" class="pw-post-body-paragraph lt lu it lv b lw ne ju ly lz nf jx mb mc ng me mf mg nh mi mj mk ni mm mn mo im bi translated">如果我们期望<strong class="lv iu">不同的例子</strong>有<strong class="lv iu">不同的输出</strong>会怎样？Pytest还允许我们向测试函数的参数中添加示例和预期输出！</p><p id="942d" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">例如，下面的函数检查文本是否包含特定的单词。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><p id="5880" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果文本包含单词，它将返回<code class="fe nt nu nv nk b">True</code>。</p><p id="718d" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果单词是“duck ”,文本是“在这个文本中有一只鸭子”,我们期望这个句子返回<code class="fe nt nu nv nk b">True.</code></p><p id="798f" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果单词是“duck ”,文本是“There nothing here ”,我们希望句子返回<code class="fe nt nu nv nk b">False.</code></p><p id="fa0d" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们将使用<code class="fe nt nu nv nk b">parametrize()</code>,但是使用元组列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><p id="22ad" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们函数的参数结构是<code class="fe nt nu nv nk b">parametrize(‘sample, expected_out’, testdata)</code>和<code class="fe nt nu nv nk b">testdata=[(&lt;sample1&gt;, &lt;output1&gt;), (&lt;sample2&gt;, &lt;output2&gt;)</code></p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="f5a9" class="no la it nk b gy np nq l nr ns">&gt;&gt;&gt; pytest process.py</span><span id="1acd" class="no la it nk b gy nw nq l nr ns">========================================= test session starts ==========================================<br/>platform linux -- Python 3.8.3, pytest-5.4.2, py-1.8.1, pluggy-0.13.1<br/>plugins: hydra-core-1.0.0, Faker-4.1.1<br/>collected 2 items</span><span id="8c22" class="no la it nk b gy nw nq l nr ns">process.py ..                                                                                    [100%]</span><span id="fb67" class="no la it nk b gy nw nq l nr ns">========================================== 2 passed in 0.04s ===========================================</span></pre><p id="7935" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">厉害！我们两个测试都通过了！</p><h1 id="7b94" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">一次测试一个功能</h1><p id="ed81" class="pw-post-body-paragraph lt lu it lv b lw ne ju ly lz nf jx mb mc ng me mf mg nh mi mj mk ni mm mn mo im bi translated">当脚本中测试函数的数量增加时，您可能希望一次测试一个函数，而不是多个函数。使用<code class="fe nt nu nv nk b">pytest file.py::function_name</code>可以轻松做到这一点</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><p id="8244" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">例如，如果您只想运行<code class="fe nt nu nv nk b">test_text_contain_word</code>，运行</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="c689" class="no la it nk b gy np nq l nr ns">pytest process.py::test_text_contain_word</span></pre><p id="ec99" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">pytest将只执行我们指定的一个测试！</p><h1 id="ba27" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">夹具:使用相同的数据测试不同的功能</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7621" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果我们想用相同的数据测试不同的功能呢？例如，我们想测试句子“今天我找到了一只鸭子，我很高兴”是否包含单词“鸭子”<strong class="lv iu">和</strong>它的情绪是积极的。我们想对相同的数据应用两个函数:“今天我发现了一只鸭子，我很高兴”。这时候<code class="fe nt nu nv nk b">fixture</code>就派上用场了。</p><p id="5df1" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated"><code class="fe nt nu nv nk b">pytest</code>夹具是向不同测试功能提供数据的一种方式</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><p id="990a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在上面的例子中，我们用函数<code class="fe nt nu nv nk b">example_data.</code>上面的装饰符<code class="fe nt nu nv nk b">@pytest.fixture</code>创建了一个示例数据，这将把<code class="fe nt nu nv nk b">example_data</code>变成一个值为“今天我找到了一只鸭子，我很高兴”的变量</p><p id="2bcc" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">现在，我们可以使用<code class="fe nt nu nv nk b">example_data</code>作为任何测试的参数！</p><h1 id="efb0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">构建您的项目</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="0f4f" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">最后但同样重要的是，当我们的代码变大时，我们可能希望将数据科学函数和测试函数放在两个不同的文件夹中。这将使我们更容易找到每个功能的位置。</p><p id="1cb6" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">用<code class="fe nt nu nv nk b">test_&lt;name&gt;.py</code>或<code class="fe nt nu nv nk b">&lt;name&gt;_test.py</code>来命名我们的测试函数。Pytest将搜索名称以“test”结尾或开头的文件，并在该文件中执行名称以“test”开头的函数。多方便啊！</p><p id="1a23" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">有不同的方法来组织你的文件。您可以将我们的数据科学文件和测试文件组织在同一个目录中，或者组织在两个不同的目录中，一个用于源代码，一个用于测试</p><p id="a64a" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">方法1:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="01a2" class="no la it nk b gy np nq l nr ns">test_structure_example/<br/>├── process.py<br/>└── test_process.py</span></pre><p id="c434" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">方法二:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ea6e" class="no la it nk b gy np nq l nr ns">test_structure_example/<br/>├── src<br/>│   └── process.py<br/>└── tests<br/>    └── test_process.py</span></pre><p id="00a5" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">由于您很可能有多个数据科学函数文件和多个测试函数文件，您可能希望将它们放在不同的目录中，就像方法2一样。</p><p id="0dfc" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">这是两个文件的样子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp ls l"/></div></figure><p id="b727" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">只需添加<code class="fe nt nu nv nk b">sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir)))</code>即可从父目录导入函数。</p><p id="431b" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在根目录(<code class="fe nt nu nv nk b">test_structure_example/</code>下，运行<code class="fe nt nu nv nk b">pytest tests/test_process.py</code>或者运行<code class="fe nt nu nv nk b">test_structure_example/tests</code>目录下的<code class="fe nt nu nv nk b">pytest test_process.py</code>。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="ba5c" class="no la it nk b gy np nq l nr ns">========================== test session starts ===========================<br/>platform linux -- Python 3.8.3, pytest-5.4.2, py-1.8.1, pluggy-0.13.1<br/>collected 1 item</span><span id="e304" class="no la it nk b gy nw nq l nr ns">tests/test_process.py .                                            [100%]</span><span id="751e" class="no la it nk b gy nw nq l nr ns">=========================== 1 passed in 0.69s ============================</span></pre><p id="6565" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">相当酷！</p><h1 id="a560" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="143b" class="pw-post-body-paragraph lt lu it lv b lw ne ju ly lz nf jx mb mc ng me mf mg nh mi mj mk ni mm mn mo im bi translated">恭喜你！您刚刚了解了pytest。我希望这篇文章能够让您很好地了解为什么测试很重要，以及如何使用pytest将测试融入到您的数据科学项目中。通过测试，您不仅能够知道您的功能是否如预期的那样工作，而且能够自信地用不同的工具或不同的代码结构切换现有的代码。</p><p id="7fd2" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">本文的源代码可以在这里找到:</p><div class="oi oj gp gr ok ol"><a href="https://github.com/khuyentran1401/Data-science/tree/master/data_science_tools/pytest" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">khuyentran 1401/数据科学</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">有用的数据科学主题以及代码和文章的集合— khuyentran1401/Data-science</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div></div></a></div><p id="cc0e" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我喜欢写一些基本的数据科学概念，并尝试不同的算法和数据科学工具。你可以在<a class="ae ky" href="https://www.linkedin.com/in/khuyen-tran-1ab926151/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ky" href="https://twitter.com/KhuyenTran16" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上联系我。</p><p id="26fb" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">如果你想查看我写的所有文章的代码，请点击这里。在Medium上关注我，了解我的最新数据科学文章，例如:</p><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/sentiment-analysis-of-linkedin-messages-3bb152307f84"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">使用Python和情感分析探索和可视化您的LinkedIn网络</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">希望优化您的LinkedIn个人资料？为什么不让数据为你服务呢？</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/i-scraped-more-than-1k-top-machine-learning-github-profiles-and-this-is-what-i-found-1ab4fb0c0474"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">我收集了超过1k的顶级机器学习Github配置文件，这就是我的发现</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">从Github上的顶级机器学习档案中获得见解</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://medium.com/swlh/get-the-most-out-of-your-array-with-these-four-numpy-methods-2fc4a6b04736" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">使用这四种Numpy方法充分利用您的阵列</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">如何垂直拆分Numpy数组或查找特定范围内的元素。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/how-to-fine-tune-your-machine-learning-models-with-ease-8ca62d1217b1"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">如何有效地微调你的机器学习模型</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">发现为您的ML模型寻找最佳参数非常耗时？用这三招</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz ks ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/how-to-create-reusable-command-line-f9a2bb356bc9"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">如何创建可重用的命令行</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">你能把你的多个有用的命令行打包成一个文件以便快速执行吗？</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pd l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>