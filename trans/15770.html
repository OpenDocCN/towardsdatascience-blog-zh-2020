<html>
<head>
<title>3 underrated strategies to deal with Missing Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个被低估的应对缺失价值观的策略</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-underrated-strategies-to-deal-with-missing-values-a539fb6c0690?source=collection_archive---------15-----------------------#2020-10-30">https://towardsdatascience.com/3-underrated-strategies-to-deal-with-missing-values-a539fb6c0690?source=collection_archive---------15-----------------------#2020-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecb7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实施、理解和学习如何使用3种强大的方法(包括深度学习)来估算数据。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/27de5ebba6eb4582339e4cdab5f3ebe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2sqy12JTGAp_B-q-cUKKA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/black-and-white-blank-challenge-connect-262488/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="b593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信每个数据科学家/ ML从业者都面临过数据集中缺失值的挑战。这是一个常见的数据清理过程，但坦率地说，是一个非常容易被忽视的过程。但是，有效的缺失值策略会对模型的性能产生重大影响。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e73" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">出现缺失值的原因</h1><p id="aa88" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">缺失值出现的原因通常是特定于问题域的。但是，大多数情况下，它们发生在以下场景中:</p><ul class=""><li id="fa1b" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu">代码错误</strong>:数据收集方法遇到了一个错误，一些值没有被正确获取(例如，如果您要通过<em class="ni"> REST API </em>收集数据，并且您可能没有正确解析响应，那么值将会丢失。)</li><li id="7b0e" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated"><strong class="lb iu">不可用</strong>:对于给定的观察，没有足够的数据可用(例如，如果有一个名为“学院”的特征，但是该观察(人/运动员等)没有上过学院，那么显然该值将为空。)</li><li id="0515" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated"><strong class="lb iu">故意NaN插补:</strong>这可能发生在Kaggle等编码竞赛中，其中部分挑战是处理缺失值。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/b393aa6904bd7d5468b45365c1c9c4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GGh6oUuIHipCeVk-A2zUvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.geeksforgeeks.org/python-pandas-dataframe-fillna-to-replace-null-values-in-dataframe/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks </a></p></figure><blockquote class="np nq nr"><p id="b0c8" class="kz la ni lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">您应该处理缺失值的原因是因为<strong class="lb iu">许多</strong> ML算法需要数字输入值，并且不能对缺失值进行操作，因此如果您尝试运行缺失值的算法，它将会响应一个错误(scikit-learn)。<strong class="lb iu">然而</strong>，一些算法，如XGBoost，将基于训练损失减少来估算值。</p></blockquote><h1 id="0564" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated"><strong class="ak">缺失值的处理方法:</strong></h1><p id="4f4a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有两种方法可以用来处理丢失的值:</p><ul class=""><li id="0f13" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu">插补</strong>:使用某种方法填充数据</li><li id="fd55" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated"><strong class="lb iu">删除</strong>:删除缺失值的行</li></ul><p id="aded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然没有真正的"<strong class="lb iu">最佳</strong>"选项，但是<em class="ni">通常</em> <em class="ni">估算数据比删除数据更好</em>，因为不这样做可能会导致大量信息丢失，以及更有可能对数据进行欠填充的模型。</p><p id="dbac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">然而</strong>，请注意，有时删除行可能是更好的选择，因为它创建了一个更健壮的模型，并且可以加速训练。</p><p id="5146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我知道你可能很想得到深度学习法(我知道，太神奇了！).所以，事不宜迟，让我们来了解一下技术！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e45c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">策略1: KNNImputer</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/ab0144dc0196347e5bd4918d95e53988.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*lIO9fY5z6Y414tLetYpZyA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://medium.com/feedium/does-top-writer-status-on-medium-actually-mean-anything-2edb0041a4a8" rel="noopener">维基百科</a></p></figure><p id="d55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法基本上使用KNN，一种机器学习算法，来估算缺失值，每个值是在样本附近找到的<strong class="lb iu"> n_neighbors </strong>个样本的平均值。</p><p id="2159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道KNN是如何工作的，你可以看看我关于它的文章。但本质上，KNNImputer将执行以下操作:</p><ol class=""><li id="99a5" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ob nf ng nh bi translated">测量新样本和第<strong class="lb iu"> N </strong>个最近样本之间的距离(由<strong class="lb iu">N _ neighbors</strong>参数指定)</li></ol><ul class=""><li id="a6e9" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">基于其最近的邻居，它将把第<strong class="lb iu"> N </strong>个最近的非空邻居的平均值作为缺失值。</li></ul><h2 id="1add" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">KNNImputer在行动</h2><p id="eded" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们看一个使用KNNImputer的简单例子:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="8b0d" class="oc md it op b gy ot ou l ov ow">import pandas as pd<br/>import numpy as np<br/>from sklearn.impute import KNNImputer</span><span id="276d" class="oc md it op b gy ox ou l ov ow">df = pd.read_csv('<a class="ae ky" href="https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv'</a>)</span></pre><p id="c472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用著名的泰坦尼克号数据集作为我们的示例数据集。</p><p id="306b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们检查哪些要素缺少值:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="ee58" class="oc md it op b gy ot ou l ov ow">df.isnull().sum()</span><span id="68f8" class="oc md it op b gy ox ou l ov ow">OUT:<br/>passengerId      0<br/>Survived         0<br/>Pclass           0<br/>Name             0<br/>Sex              0<br/>Age            177<br/>SibSp            0<br/>Parch            0<br/>Ticket           0<br/>Fare             0<br/>Cabin          687<br/>Embarked         2<br/>dtype: int64</span></pre><p id="db07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，我们可以看到哪些值需要估算。</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="f356" class="oc md it op b gy ot ou l ov ow">df = df.drop(['PassengerId','Name'],axis=1)<br/>df = df[["Survived", "Pclass", "Sex", "SibSp", "Parch", "Fare", "Age"]]</span><span id="d82b" class="oc md it op b gy ox ou l ov ow">df["Sex"] = [1 if x=="male" else 0 for x in df["Sex"]]</span></pre><p id="59a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们删除了一些不需要的特征，并快速地对我们的性特征进行一次性编码。</p><blockquote class="np nq nr"><p id="0321" class="kz la ni lb b lc ld ju le lf lg jx lh ns lj lk ll nt ln lo lp nu lr ls lt lu im bi translated">注意:通常人们会做一些特性工程和转换，但这不是本文的目的，因此我跳过这一部分。然而，在一个正常的项目中，您应该总是正确地检查和清理您的数据。</p></blockquote><p id="e008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们实例化我们的KNNImputer，并给它一个n _ neighbours值5。</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="7338" class="oc md it op b gy ot ou l ov ow">imputer = KNNImputer(n_neighbors=5)<br/>imputer.fit(df)</span></pre><p id="da06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在剩下要做的就是转换数据，以便估算值:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="e2fc" class="oc md it op b gy ot ou l ov ow">imputer.transform(df)</span></pre><p id="d926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你要的。KNNImputer。scikit-learn再次使这个过程变得非常简单和直观，但是我建议在Github上查看这个算法的代码，以便更好地理解KNNImputer真正做了什么。</p><h2 id="cb8b" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">KNNImputer的优点:</h2><ul class=""><li id="86c7" class="mz na it lb b lc mu lf mv li oy lm oz lq pa lu ne nf ng nh bi translated">可能比平均值、中间值或众数更准确(取决于数据集)。</li></ul><h2 id="81d2" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">KNNImputer的缺点:</h2><ul class=""><li id="784a" class="mz na it lb b lc mu lf mv li oy lm oz lq pa lu ne nf ng nh bi translated">计算开销很大，因为它存储在内存中的整个数据集中。</li><li id="0630" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">对异常值非常敏感，因此估算值可能会导致模型无法尽可能好地运行。</li><li id="c73a" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">您必须指定邻居的数量</li></ul><h1 id="8980" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated">策略2:通过链式方程进行多重插补(小鼠)</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/42232bb54d4a794e924a2603f35085c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*nqjbF3dJ0-sLHHmabs-ELg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片可以从<a class="ae ky" href="https://stackoverflow.com/questions/50351736/mice-number-of-multiply-imputed-data-sets" rel="noopener ugc nofollow" target="_blank">栈中找到</a></p></figure><p id="c0f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种非常强大的算法，其基本工作原理是选择一个具有缺失值的要素作为目标变量，并利用回归模型根据数据集中的所有其他变量来估算缺失值。</p><p id="7e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它以循环方式重复这一过程，这意味着将针对所有其他要素回归每个缺失值的要素。</p><p id="1e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有点迷惑？没错。这就是为什么它的…类比时间！</p><h1 id="40b2" class="mc md it bd me mf nv mh mi mj nw ml mm jz nx ka mo kc ny kd mq kf nz kg ms mt bi translated">用类比的方法理解老鼠</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/1e32a9093b1f8bb322a84e8105963dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZorPG8lMGneDVntANV-CQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@bonniekdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">邦妮·凯特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/mice?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="de9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您的数据集具有以下特征:</p><ul class=""><li id="ed2b" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">年龄</li><li id="0d14" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">性别</li><li id="d868" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">身体质量指数</li><li id="5316" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">收入</li></ul><p id="3f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而每个特征，<em class="ni">除了</em>性别，都有缺失值。在这个场景中，<strong class="lb iu">鼠标</strong>算法将执行以下操作:</p><ol class=""><li id="f472" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ob nf ng nh bi translated">对于每个缺少值的特性(年龄、身体质量指数、收入)，您用一些临时的“占位符”来填充这些值。这通常是要素中所有值的平均值，因此，在这种情况下，我们将使用数据的平均年龄填充缺失的年龄，使用身体质量指数的平均值填充缺失的身体质量指数，等等。</li><li id="01da" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ob nf ng nh bi translated">返回到缺少一个要估算的要素。因此，如果我们选择估算年龄，那么年龄将是一个缺少值的要素，正如我们在上一步中估算其他要素一样。</li><li id="371f" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ob nf ng nh bi translated">回归所有(或部分)要素的年龄。为了使这一步起作用，删除age可能包含的所有NaN值。本质上我们是在拟合线性回归，年龄是目标特征，其他特征是独立特征。</li><li id="9a1c" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ob nf ng nh bi translated">使用之前拟合的回归模型来预测缺少的年龄值。(<strong class="lb iu">重要提示:</strong>当年龄稍后被用作独立变量来预测其他特征的缺失值时，观察值和预测值都将被使用)。随机成分也被添加到该预测中。</li><li id="c64a" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ob nf ng nh bi translated">对所有缺失数据的要素(在本例中为身体质量指数和收入)重复步骤2-4</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<strong class="lb iu">鼠标</strong>算法完成了从1到5的所有步骤时，这就是所谓的<strong class="lb iu">循环。</strong>通常，鼠标需要用户浏览数据5-10次左右。</p><p id="3153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们到了最后一个周期，我们输出一个估算数据集。通常，我们希望在数据集的5个副本上运行该算法，然后将<strong class="lb iu">池</strong>我们的<strong class="lb iu"> </strong>结果放在一起。完成此操作后，我们可以分析结果并报告综合结果。</p><h2 id="a780" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">老鼠在行动</h2><p id="42aa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然这些步骤可能看起来漫长而困难，但多亏了我们的朋友scikit-learn，实现mice就像做馅饼一样简单:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="384a" class="oc md it op b gy ot ou l ov ow">import numpy as np <br/>import pandas as pd<br/>from sklearn.experimental import enable_iterative_imputer<br/>from sklearn.impute import IterativeImputer</span><span id="b913" class="oc md it op b gy ox ou l ov ow">df = pd.read_csv('<a class="ae ky" href="https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/datasciencedojo/datasets/master/titanic.csv'</a>)</span><span id="0600" class="oc md it op b gy ox ou l ov ow">df = df.drop(['PassengerId','Name'],axis=1)<br/>df = df[["Survived", "Pclass", "Sex", "SibSp", "Parch", "Fare", "Age"]]</span><span id="f788" class="oc md it op b gy ox ou l ov ow">df["Sex"] = [1 if x=="male" else 0 for x in df["Sex"]]</span></pre><p id="98cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:确保在导入迭代估算器之前导入<em class="ni">enable _ iterative _ inputr</em>函数，因为该特性被归类为实验性的，否则将导致导入错误。</p><p id="8b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们调用实例化IterativeImputer类:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="29ae" class="oc md it op b gy ot ou l ov ow">imputer = IterativeImputer(imputation_order='ascending',max_iter=10,random_state=42,n_nearest_features=None)</span></pre><p id="5948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意一些事情:</p><p id="2bcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> max_iter </strong>:返回插补数据集之前要进行插补的周期数</p><p id="dd6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">插补_顺序:</strong>特征插补的顺序。</p><p id="05f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能的值:</p><p id="e1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ni">升序</em></strong><br/>从缺失值最少的特征到最多的特征。<br/><strong class="lb iu"><em class="ni">降序</em></strong><br/>从缺失值最多的特征到最少的特征。<br/><strong class="lb iu"><em class="ni">罗马</em></strong><br/>从左到右。<br/><strong class="lb iu"><em class="ni">阿拉伯文</em></strong><br/>从右向左。<br/><strong class="lb iu"><em class="ni">随机</em></strong><br/>每轮随机下单。</p><p id="13c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> n_nearest_features </strong>:用于估计每个特征列缺失值的其他特征的数量。特征的接近度由绝对相关系数决定</p><p id="c52e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> random_state: </strong>为使您的结果可重复而设置的随机种子</p><p id="3929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们只需将它与数据相匹配，并对其进行转换！</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="2aba" class="oc md it op b gy ot ou l ov ow">imputed_dataset = imputer.fit_transform(df)</span></pre><h2 id="5b18" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">鼠标的优点:</h2><ul class=""><li id="ac46" class="mz na it lb b lc mu lf mv li oy lm oz lq pa lu ne nf ng nh bi translated">非常灵活，可以处理二进制和连续值</li><li id="bcdd" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">通常比简单的均值/众数/中位数插补更准确。</li></ul><h2 id="7595" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">鼠标的缺点:</h2><ul class=""><li id="903d" class="mz na it lb b lc mu lf mv li oy lm oz lq pa lu ne nf ng nh bi translated">计算量很大，因为它存储数据集并循环N次。</li><li id="79d9" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">对于大型数据集可能会很慢</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f1b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">策略3:利用深度学习进行插补</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/ae42ae064adb0d3cf3f9dfec11ba7e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Cnmqcxc1MVlJtodTknWiMA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://computersciencewiki.org/index.php/Multi-layer_perceptron_(MLP)" rel="noopener ugc nofollow" target="_blank">计算机科学维基</a>拍摄的照片</p></figure><p id="fc15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是现有的最强大和最准确的插补方法。它本质上利用MXnet的深度神经网络来预测缺失值。它非常灵活，因为它支持分类变量和连续变量，可以在CPU和GPU上运行。</p><h2 id="1168" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">行动中的深度学习归因</h2><p id="2a0e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们正在使用的库名为<a class="ae ky" href="https://datawig.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> datawig </a>。来安装它。只需运行:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="218b" class="oc md it op b gy ot ou l ov ow">pip3 install datawig</span></pre><p id="a701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的终端/命令行中。</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="ed7a" class="oc md it op b gy ot ou l ov ow">import pandas as pd<br/>import numpy as np<br/>import datawig</span><span id="963c" class="oc md it op b gy ox ou l ov ow">df = df.drop(['PassengerId','Name'],axis=1)<br/>df = df[["Survived", "Pclass", "Sex", "SibSp", "Parch", "Fare", "Age"]]</span><span id="b5f9" class="oc md it op b gy ox ou l ov ow">df["Sex"] = [1 if x=="male" else 0 for x in df["Sex"]]</span></pre><p id="4787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将实例化datawig的SimpleImputer类:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="47c0" class="oc md it op b gy ot ou l ov ow">imputer = datawig.SimpleImputer(<br/>    input_columns=['Pclass','SibSp','Parch'], <br/>    output_column= 'Age', <br/>    output_path = 'imputer_model'<br/>    )</span></pre><p id="dd57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意一些参数:</p><ul class=""><li id="7fa4" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><em class="ni"> input_columns </em>:包含我们想要估算的列的信息的列</li><li id="c8b4" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated"><em class="ni"> output_columns: </em>我们要为其估算值的列</li><li id="df1c" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated"><em class="ni">输出_模型</em>:存储模型数据和度量</li></ul><p id="697a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将估算值与我们的数据进行拟合，估算缺失值并返回估算数据框架:</p><pre class="kj kk kl km gt oo op oq or aw os bi"><span id="dbe5" class="oc md it op b gy ot ou l ov ow"># Fit an imputer model on the train data<br/># num_epochs: defines how many times to loop through the network<br/>imputer.fit(train_df=df, num_epochs=50)</span><span id="06a1" class="oc md it op b gy ox ou l ov ow"># Impute missing values and return original dataframe with predictions<br/>imputed = imputer.predict(df)</span></pre><p id="d66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是深度学习的估算方法。</p><h2 id="bb98" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">深度学习插补的优势</h2><ul class=""><li id="4b7b" class="mz na it lb b lc mu lf mv li oy lm oz lq pa lu ne nf ng nh bi translated">与其他方法相比相当准确。</li><li id="05d9" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">它具有可以处理分类数据的功能(特征编码器)。</li><li id="6c7a" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">它支持CPU和GPU。</li></ul><h2 id="55cb" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">深度学习插补的缺点</h2><ul class=""><li id="bd73" class="mz na it lb b lc mu lf mv li oy lm oz lq pa lu ne nf ng nh bi translated">在大型数据集上可能会很慢</li><li id="04e5" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">一次只能估算一个特征</li><li id="8a8a" class="mz na it lb b lc nj lf nk li nl lm nm lq nn lu ne nf ng nh bi translated">您必须指定输入和输出列</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ff6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/cc762922bb700073f3ed2be19318a850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3dCVTr_0G3HX7tZc0cBxg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ky" href="https://unsplash.com/s/photos/conclusion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，我们必须承认，没有一种有保证的策略可以永远适用于每一个数据集。有些方法可能对一个数据集非常有效，但对另一些数据集则很差。</p><p id="0ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，检查您的数据，看看您应该如何输入值，以及使用什么策略总是好的。确保对不同的插补方法进行交叉验证，看看哪种方法最适合给定的数据集。</p><p id="098b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，非常感谢我所有的追随者，他们让我保持不断的动力和求知欲！我希望你今天学到了一些新东西，请继续关注，因为我还有更多内容要发布！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/21b3c14b3f8b12476c21479ba9605336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxHlyjqXC5dUTxOgGMQkTw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@priscilladupreez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae ky" href="https://unsplash.com/s/photos/thanks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div></div>    
</body>
</html>