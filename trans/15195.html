<html>
<head>
<title>Anchors Away! More R Regex Concepts You Wish You Knew</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">起锚！更多你希望知道的R正则表达式概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/anchors-away-more-regex-concepts-in-r-f00fe7f07d52?source=collection_archive---------25-----------------------#2020-10-19">https://towardsdatascience.com/anchors-away-more-regex-concepts-in-r-f00fe7f07d52?source=collection_archive---------25-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="745f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">教程| R |正则表达式(Regex)</h2><div class=""/><div class=""><h2 id="9053" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在R中使用高级正则表达式工具处理文本的秘密</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/8bed48d51edfb4a4385a63372b01e371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*m1s88h4WoO0C2lp1e0n6OQ.png"/></div></figure><p id="0238" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以你已经知道了r中正则表达式的基本知识，比如如何使用字符集、元字符、量词和捕获组。这些是基本的构建模块，但是你是一个超级用户，永远不会满足于仅仅是基本的。你的文本争论问题比你希望用这些工具解决的要复杂得多。幸运的是，R中有更多的正则表达式概念需要学习。这是更多文本争论善良的锚！</p><blockquote class="lv lw lx"><p id="2220" class="kz la ly lb b lc ld kd le lf lg kg lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">不确定基本的？请查看我在r。</p></blockquote><div class="mc md gp gr me mf"><a rel="noopener follow" target="_blank" href="/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd jd gy z fp mk fr fs ml fu fw jc bi translated">R正则表达式的简明介绍</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">正则表达式是数据科学家对付非结构化文本最强大的武器。他们曾经是野餐…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">towardsdatascience.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt kx mf"/></div></div></a></div><h1 id="25db" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">(正文)起锚了！</h1><p id="1f3d" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在我们开始SS正则表达式之前，我们需要讨论锚。更具体地说，<strong class="lb jd">文本锚</strong>。文本锚表示在字符串的开头或结尾查找匹配。在R中，有两种类型的锚:</p><ul class=""><li id="3fc8" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe oa ob oc od b">^</code>:匹配字符串开头的以下正则表达式</li><li id="bcf7" class="nr ns it lb b lc oe lf of li og lm oh lq oi lu nw nx ny nz bi translated"><code class="fe oa ob oc od b">$</code>:匹配字符串末尾的前一个正则表达式</li></ul><p id="2633" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提醒一下，要在R中使用regex，您需要使用<code class="fe oa ob oc od b">stringr</code>包。在尝试新的正则表达式主题(比如锚点)时，<code class="fe oa ob oc od b">str_extract_all()</code>函数特别有用。它将返回一个包含字符串中匹配项实际值的向量的列表。确保在开始之前加载<code class="fe oa ob oc od b">stringr</code>包。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="4a4c" class="on mv it od b gy oo op l oq or">library(stringr)</span></pre><h2 id="8b98" class="on mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk iz bi translated">起锚，<code class="fe oa ob oc od b">^</code>起锚</h2><p id="0899" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">要起航，我们必须在旅行开始时起锚。当处理文本数据时，您可能需要匹配一个正则表达式模式，但前提是它出现在字符串中的第一项。为此，我们使用<code class="fe oa ob oc od b">^</code>锚。</p><p id="6955" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示，我们的目标是找到单词“the”，但前提是它出现在字符串的开头。这里有几个示例字符串供您试用。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="d377" class="on mv it od b gy oo op l oq or">anchor &lt;- "The ship sets sail on the ocean"<br/>anchor_n &lt;- "Ships set sail on the ocean to go places"</span></pre><p id="b2de" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe oa ob oc od b">anchor</code>字符串开始，当我们使用<code class="fe oa ob oc od b">^</code>锚查找“the”时，我们只返回了它的一个实例。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="94c0" class="on mv it od b gy oo op l oq or">str_extract_all(anchor, "^[Tt]he")</span><span id="87be" class="on mv it od b gy pc op l oq or">[[1]]<br/>[1] "The"</span></pre><p id="ebc1" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道这是第一个实例，因为字符串开头的“the”是大写的。现在用<code class="fe oa ob oc od b">anchor_n</code>，不返回任何结果。正则表达式通常匹配句子中的“The ”,但是使用<code class="fe oa ob oc od b">^</code>定位符时，它只检查句子的开头。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="0222" class="on mv it od b gy oo op l oq or">str_extract_all(anchor_n, "^[Tt]he")</span><span id="ad01" class="on mv it od b gy pc op l oq or">[[1]]<br/>character(0)</span></pre><h2 id="7337" class="on mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk iz bi translated">抛锚，<code class="fe oa ob oc od b">$</code>锚</h2><p id="69a5" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在我们的正则表达式巡航结束时，我们需要放下锚。有时，只有当正则表达式出现在字符串末尾时，才需要匹配它。这是通过<code class="fe oa ob oc od b">$</code>锚完成的。</p><p id="a1ee" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再来看一下<code class="fe oa ob oc od b">anchor</code>字符串，这次是在字符串的末尾寻找“海洋”。我们会有一个结果，“海洋。”</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="b17f" class="on mv it od b gy oo op l oq or">str_extract_all(anchor, "ocean$")</span><span id="0fa4" class="on mv it od b gy pc op l oq or">[[1]]<br/>[1] "ocean"</span></pre><p id="f69c" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果我们查看<code class="fe oa ob oc od b">anchor_n</code>，这次使用<code class="fe oa ob oc od b">$</code>或结束锚，我们将得不到匹配，即使“海洋”出现在字符串中。如果它不在绳子的末端，<code class="fe oa ob oc od b">$</code>号锚就不会把它捡起来。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="fd24" class="on mv it od b gy oo op l oq or">str_extract_all(anchor_n, "ocean$")</span><span id="2145" class="on mv it od b gy pc op l oq or">[[1]]<br/>character(0)</span></pre><h1 id="4888" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">正则表达式否定(避免冰山)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="pe pf di pg bf ph"><div class="gh gi pd"><img src="../Images/8ea7b75c38bc575a7960cb0cfbc207ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HG7j6J4rz9kD2xvJ"/></div></div><p class="pi pj gj gh gi pk pl bd b be z dk translated">安妮·斯普拉特在<a class="ae pm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a7ca" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了如何匹配字符串开头和结尾的模式(提升和降低SS正则表达式的锚)，我们可以继续下一个概念:告诉regex匹配什么<strong class="lb jd">不匹配</strong>。</p><p id="00c5" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，你是一艘大船的船长，这艘船正在进行它的处女航。让我们称这艘船为泰坦尼克号。作为那艘船的船长，你可能对<strong class="lb jd">而不是</strong>撞上冰山非常感兴趣。</p><p id="840a" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在字符串中，您可能希望指定某些模式来避免。要做到这一点，使用否定。这些将匹配除了您指定的内容之外的任何内容。在R中有两种主要的方法来处理它们:</p><ul class=""><li id="77f4" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">大写元字符:元字符匹配一组特定的字符。一个大写的元字符通常会匹配除该字符集之外的所有内容</li><li id="965b" class="nr ns it lb b lc oe lf of li og lm oh lq oi lu nw nx ny nz bi translated"><code class="fe oa ob oc od b">^</code>和字符集:使用一个<code class="fe oa ob oc od b">^</code>和一个字符集将匹配除了在字符集中指定的以外的所有内容</li></ul><h2 id="0990" class="on mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk iz bi translated">大写元字符</h2><p id="2aa7" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在我上一篇关于R中正则表达式的文章中，我们介绍了三种不同的元字符:<code class="fe oa ob oc od b">\\s</code>、<code class="fe oa ob oc od b">\\w</code>和<code class="fe oa ob oc od b">\\d</code>。作为复习，它们匹配字符串中的一组字符:<code class="fe oa ob oc od b">\\s</code>匹配空白字符(空格、制表符和换行符)，<code class="fe oa ob oc od b">\\w</code>匹配字母数字字符(字母和数字)，而<code class="fe oa ob oc od b">\\d</code>匹配任何数字(数字)。</p><p id="ca67" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您大写这些元字符中的任何一个时，它将匹配除了正常匹配之外的所有内容。要查看它们的运行情况，让我们创建一个包含空格、数字、字母和标点符号的新字符串:</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="0b95" class="on mv it od b gy oo op l oq or">negation &lt;- "I sail my 3 ships on the 7 seas."</span></pre><p id="5028" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们看一看我们的大写元字符时，我们会看到它们与小写元字符的操作方式有所不同。</p><ul class=""><li id="fd6b" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">这将匹配除空格之外的任何内容。我们在输出中看到来自<code class="fe oa ob oc od b">negation</code>字符串的所有字母、数字和标点符号</li></ul><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="8fc5" class="on mv it od b gy oo op l oq or">str_extract_all(negation, "\\S")</span><span id="be61" class="on mv it od b gy pc op l oq or">[[1]]<br/>[1] "I" "s" "a" "i" "l" "m" "y" "3" "s" "h" "i" "p" "s" "o" "n" "t" "h" "e" "7" "s" "e" "a" "s" "."</span></pre><ul class=""><li id="8d69" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe oa ob oc od b">\\W</code>:这将匹配除了字母和数字以外的任何内容。我们这里的输出是每个空格和句尾的句号</li></ul><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="97c9" class="on mv it od b gy oo op l oq or">str_extract_all(negation, "\\W")</span><span id="8d24" class="on mv it od b gy pc op l oq or">[[1]]<br/>[1] " " " " " " " " " " " " " " " " "."</span></pre><ul class=""><li id="37cf" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe oa ob oc od b">\\D</code>:这将匹配除数字以外的任何内容。您可能已经猜到，输出中有字母、空格和标点符号</li></ul><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="18d8" class="on mv it od b gy oo op l oq or">str_extract_all(negation, "\\D")</span><span id="ec0e" class="on mv it od b gy pc op l oq or">[[1]]<br/> [1] "I" " " "s" "a" "i" "l" " " "m" "y" " " " " "s" "h" "i" "p" "s" " " "o" "n" " " "t" "h" "e" " " " " "s" "e" "a" "s" "."</span></pre><h2 id="6341" class="on mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk iz bi translated"><code class="fe oa ob oc od b">^</code>和字符集</h2><p id="a561" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">一些用例需要比元字符更灵活的否定。让我们看一个示例场景:</p><ul class=""><li id="96c3" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated">匹配给定字符串中的所有辅音</li></ul><p id="fc83" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来分解一下这个问题。字母表里有21个辅音，我们想要全部。它们是不连续的，所以我们不能仅仅用一个字符集中的一系列字母来得到它们。我们确实知道元音和辅音是互斥的，而且只有5个元音。如果我们可以找到所有的元音，我们应该能够否定它得到所有的辅音。让我们从复习如何用字符集查找元音开始。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="93c4" class="on mv it od b gy oo op l oq or">str_extract_all(negation, "[AEIOUaeiou]")</span><span id="e755" class="on mv it od b gy pc op l oq or">[[1]]<br/>[1] "I" "a" "i" "i" "o" "e" "e" "a"</span></pre><p id="639d" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">括号内的字符定义了字符集。在这种情况下，每个元音都匹配。为了获得除元音以外的所有内容，我们可以使用字符集内的<code class="fe oa ob oc od b">^</code>。这会否定里面的一切。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="a683" class="on mv it od b gy oo op l oq or">str_extract_all(negation, "[^AEIOUaeiou]")</span><span id="8d3e" class="on mv it od b gy pc op l oq or">[[1]]<br/>[1] " " "s" "l" " " "m" "y" " " "3" " " "s" "h" "p" "s" " " "n" " " "t" "h" " " "7" " " "s" "s" "."</span></pre><p id="37b2" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…但那不是辅音。还有一点工作要做。我们的结果中有空格、数字和标点符号。由于捕获组中的所有内容都被否定，所以我们只需在结果中匹配所有不想要的内容。<code class="fe oa ob oc od b">\\s</code>负责空格，<code class="fe oa ob oc od b">\\d</code>负责数字，<code class="fe oa ob oc od b">\\.</code>负责句点。</p><blockquote class="lv lw lx"><p id="e202" class="kz la ly lb b lc ld kd le lf lg kg lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">注意:<code class="fe oa ob oc od b">\\.</code>不是元字符，是转义句号。</p></blockquote><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="8d39" class="on mv it od b gy oo op l oq or">str_extract_all(negation, "[^AEIOUaeiou\\s\\d\\.]")</span><span id="d752" class="on mv it od b gy pc op l oq or">[[1]]<br/>[1] "s" "l" "m" "y" "s" "h" "p" "s" "n" "t" "h" "s" "s"</span></pre><p id="a111" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在添加了所有需要的字符后，我们最终只需要辅音字母，也许这并不比输入21个不同的辅音字母更快，但它确实演示了我们如何将所有字符相加，并使用正则表达式来获得我们想要的结果。</p><h1 id="c958" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">环顾四周(观赏野生动物)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="pe pf di pg bf ph"><div class="gh gi pn"><img src="../Images/2eb248d9c24bfe6ea873dbf995365df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UpjDdX5sksU2K-5E"/></div></div><p class="pi pj gj gh gi pk pl bd b be z dk translated">马丁·韦特斯坦在<a class="ae pm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2e51" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出海时，我们可能会留意一些东西。看到一些野生动物将会是一次更有趣的旅行。我们寻找野生动物，这样我们就可以找到一个靠近它的地方来停泊我们的船。作为一名经验丰富的船长，我们并不真正关心野生动物本身，只关心附近的安全空间，以便驾驶船只。</p><p id="d3ff" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于我们想通过野生动物寻找一个停车的地方，我们可能想在一些字符串周围寻找我们真正想要的信息。与大多数任务一样，正则表达式使这变得容易得多。为此，我们使用了一种叫做<strong class="lb jd">环视</strong>的东西。Look arounds在字符串中搜索特定的匹配项，然后返回它之前或之后的某个值。这给我们留下了两种主要的环视方式:向前看和向后看。</p><p id="e566" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用下面的字符串作为例子来说明这两者是如何工作的。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="8376" class="on mv it od b gy oo op l oq or">lookaround &lt;- "A penguin costs 2.99, a whale costs 5.99, I only have 3.50 left."</span></pre><p id="9013" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们想从这个字符串中提取什么信息，我们有两个场景。</p><ol class=""><li id="d968" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu po nx ny nz bi translated">每只动物的成本是多少？</li><li id="e6eb" class="nr ns it lb b lc oe lf of li og lm oh lq oi lu po nx ny nz bi translated">卖什么动物？</li></ol><p id="5a43" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，你可能会想为什么我们需要环顾四周才能做到这一点。你可以简单地寻找一个数字，句号，和另外两个数字。大概是这样的:</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="e48d" class="on mv it od b gy oo op l oq or">str_extract_all(lookaround, "\\d\\.\\d{2}")</span></pre><p id="73d8" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个不错的开始，但是这一行代码的输出会给出三种价格。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="7313" class="on mv it od b gy oo op l oq or">[[1]]<br/>[1] "2.99" "5.99" "3.50"</span></pre><p id="6159" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有两种动物价格，最后一种是不相关的，所以我们想排除它。环顾四周将有助于我们删除最后一个，并把一切都很好地纳入一个数据框架。</p><h2 id="ad25" class="on mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk iz bi translated">向后看</h2><p id="7652" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">查看<code class="fe oa ob oc od b">lookaround</code>字符串，我们看到每种动物的价格前面都有单词“costs”我们将在后面使用一个<strong class="lb jd">外观。这将匹配我们通常匹配的任何内容，但前提是它之前有其他内容的匹配。前瞻的通用公式是<code class="fe oa ob oc od b">"(?&lt;=if preceded by this)match_this"</code>。在我们的例子中，这将翻译如下(<code class="fe oa ob oc od b">\\s</code>被添加以说明单词和数字之间的空间):</strong></p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="2554" class="on mv it od b gy oo op l oq or"># Look behind<br/>prices &lt;- str_extract_all(lookaround, "(?&lt;=costs)\\s\\d\\.\\d{2}")<br/>prices</span></pre><p id="5c2b" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了每只动物的价格，不包括我在绳子上剩下的钱。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="be84" class="on mv it od b gy oo op l oq or">[[1]]<br/>[1] " 2.99" " 5.99"</span></pre><p id="b19d" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仔细看，你会注意到琴弦上有空隙。现在不要担心这些，当我们建立一个数据框架来保存我们的价目表时，我们会处理这些问题。</p><h2 id="c37f" class="on mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk iz bi translated">向前看</h2><p id="40f0" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在，我们已经从字符串中获得了动物的价格，我们希望为价格列表数据框获取动物的名称。</p><p id="daf0" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们现在需要匹配单词“costs”前面的单词。为此，我们将使用<strong class="lb jd">前瞻</strong>。前瞻的基本公式如下:<code class="fe oa ob oc od b">"match this(?=if followed by this)"</code>。要从我们的字符串中获取动物名称，应该是这样的:</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="1aa2" class="on mv it od b gy oo op l oq or"># Look Aheads<br/>animals &lt;- str_extract_all(lookaround, "\\w+\\s(?=costs)")<br/>animals</span></pre><p id="fb8f" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我们抓住了单词costs之前的每个单词。在我们的字符串中是所有动物的名字。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="5b18" class="on mv it od b gy oo op l oq or">[[1]]<br/>[1] "penguin " "whale "</span></pre><h2 id="0c42" class="on mv it bd mw os ot dn na ou ov dp ne li ow ox ng lm oy oz ni lq pa pb nk iz bi translated">创建动物价格数据框</h2><p id="7356" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了创建动物价格的数据框架，我们已经拥有了大部分我们需要的东西。我们只是创建一个数据帧，用向量<code class="fe oa ob oc od b">animals</code>和<code class="fe oa ob oc od b">prices</code>作为列。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="8925" class="on mv it od b gy oo op l oq or">animal_prices &lt;- data.frame(<br/>    animals=animals[[1]],<br/>    prices=prices[[1]],<br/>    stringsAsFactors=FALSE<br/>)</span></pre><p id="0d1a" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你忘了，当我们使用<code class="fe oa ob oc od b">str_extract_all()</code>时，它返回一个包含字符串向量的列表。为了访问字符串向量，我们使用了双括号符号(<code class="fe oa ob oc od b">animals[[1]]</code>)。参数<code class="fe oa ob oc od b">stringsAsFactors</code>被设置为false，否则R将把列创建为因子，而不是字符串。</p><p id="2fbc" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的下一步是解决这些多余的空间。对于包含更多列的数据框，我们可以考虑使用<code class="fe oa ob oc od b">purrr</code>包中的<code class="fe oa ob oc od b">map</code>函数，但是由于我们的函数很小，我们可以手动完成这个过程。我们将使用<code class="fe oa ob oc od b">str_trim()</code>功能。默认情况下，它会删除字符串开头和结尾的空格。</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="4175" class="on mv it od b gy oo op l oq or">animal_prices$animals &lt;- str_trim(animal_prices$animals)<br/>animal_prices$prices &lt;- as.numeric(str_trim(animal_prices$prices))</span></pre><p id="c4e3" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加了<code class="fe oa ob oc od b">as.numeric()</code>函数来将<code class="fe oa ob oc od b">prices</code>列的类型从字符更正为数字。生成的数据框如下所示:</p><pre class="ks kt ku kv gt oj od ok ol aw om bi"><span id="1753" class="on mv it od b gy oo op l oq or">  animals prices<br/>1 penguin   2.99<br/>2   whale   5.99</span></pre><h1 id="7a46" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">结论</h1><p id="c257" class="pw-post-body-paragraph kz la it lb b lc nm kd le lf nn kg lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">就这样，你在SS正则表达式上的巡航结束了。你学到了:</p><ol class=""><li id="cce2" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu po nx ny nz bi translated">如何匹配出现在字符串开头或结尾的模式</li><li id="2b04" class="nr ns it lb b lc oe lf of li og lm oh lq oi lu po nx ny nz bi translated">如何使用否定来匹配除指定内容之外的任何内容</li><li id="65c7" class="nr ns it lb b lc oe lf of li og lm oh lq oi lu po nx ny nz bi translated">如何使用look arounds来匹配后面或前面有您指定的其他内容的内容</li></ol><p id="eae2" class="pw-post-body-paragraph kz la it lb b lc ld kd le lf lg kg lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些与R中的正则表达式相关的资源，您可能会觉得有帮助:</p><ul class=""><li id="f6bf" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae pm" href="https://stringr.tidyverse.org/index.html" rel="noopener ugc nofollow" target="_blank">tidy verse网站官方</a> <code class="fe oa ob oc od b"><a class="ae pm" href="https://stringr.tidyverse.org/index.html" rel="noopener ugc nofollow" target="_blank">stringr</a></code> <a class="ae pm" href="https://stringr.tidyverse.org/index.html" rel="noopener ugc nofollow" target="_blank">页面</a>:r studio<a class="ae pm" href="https://rstudio.com/" rel="noopener ugc nofollow" target="_blank">的伙计们</a>整理了资源帮助学习<code class="fe oa ob oc od b">stringr</code>之类的包。他们甚至包括一个<code class="fe oa ob oc od b"><a class="ae pm" href="https://github.com/rstudio/cheatsheets/blob/master/strings.pdf" rel="noopener ugc nofollow" target="_blank">stringr</a></code> <a class="ae pm" href="https://github.com/rstudio/cheatsheets/blob/master/strings.pdf" rel="noopener ugc nofollow" target="_blank">备忘单</a>，你可以打印出来参考。</li><li id="8df1" class="nr ns it lb b lc oe lf of li og lm oh lq oi lu nw nx ny nz bi translated"><a class="ae pm" href="https://r4ds.had.co.nz/strings.html" rel="noopener ugc nofollow" target="_blank"> R for Data Science </a>:由Hadley Wickham编写，<code class="fe oa ob oc od b">stringr</code> package的作者，这本书对于R中的一切都是很好的参考。甚至有一章介绍了R中的高级正则表达式。它可以在网上免费获得<a class="ae pm" href="https://r4ds.had.co.nz/strings.html" rel="noopener ugc nofollow" target="_blank">这里</a>，或者你可以在这里购买硬拷贝<a class="ae pm" href="https://amzn.to/2QUBYaG" rel="noopener ugc nofollow" target="_blank">(付费链接)。</a></li><li id="aea1" class="nr ns it lb b lc oe lf of li og lm oh lq oi lu nw nx ny nz bi translated"><a class="ae pm" href="https://www.datacamp.com/join-me/ODczNDQ5" rel="noopener ugc nofollow" target="_blank"> Datacamp课程</a>(付费链接):一个致力于数据科学、机器学习和数据可视化的在线学习社区。查看他们的课程“用r中的stringr进行字符串操作”，Datacamp上每个课程的第一章都是免费的！</li></ul><div class="mc md gp gr me mf"><a href="https://realdrewdata.medium.com/membership" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd jd gy z fp mk fr fs ml fu fw jc bi translated">通过我的推荐链接加入Medium-Drew Seewald</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">realdrewdata.medium.com</p></div></div><div class="mo l"><div class="pp l mq mr ms mo mt kx mf"/></div></div></a></div></div></div>    
</body>
</html>