<html>
<head>
<title>Pandas concat() tricks you should know to speed up your data analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的提高数据分析速度的技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-concat-tricks-you-should-know-to-speed-up-your-data-analysis-cd3d4fdfe6dd?source=collection_archive---------1-----------------------#2020-10-30">https://towardsdatascience.com/pandas-concat-tricks-you-should-know-to-speed-up-your-data-analysis-cd3d4fdfe6dd?source=collection_archive---------1-----------------------#2020-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1dce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你应该知道的一些最有用的熊猫把戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/acdf354b6bba5a17faa571dfe3224ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3U7nRWqWeeU23nhUtTATkg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1892023" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/graphicmama-team-2641041/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1892023" rel="noopener ugc nofollow" target="_blank"> GraphicMama-team </a></p></figure><p id="663a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas提供了各种内置函数来轻松组合数据帧。其中，<code class="fe lv lw lx ly b">concat()</code>函数看起来使用起来相当简单，但仍有许多技巧你应该知道，以加快你的数据分析。</p><p id="f944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，你将学习熊猫<code class="fe lv lw lx ly b">concat()</code>处理以下常见问题的技巧:</p><ol class=""><li id="98b8" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">处理索引和轴</li><li id="fa38" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">避免重复索引</li><li id="4f69" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">使用<code class="fe lv lw lx ly b">keys</code>和<code class="fe lv lw lx ly b">names</code>选项添加分层索引</li><li id="aa14" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">列匹配和排序</li><li id="b879" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">从一堆CSV文件中加载和连接数据集</li></ol><p id="fc78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码请查看我的<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/master/data-analysis/016-pandas-concat/pandas-concat.ipynb" rel="noopener ugc nofollow" target="_blank"> Github repo </a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c305" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.处理索引和轴</h1><p id="db5c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">假设我们有两个关于考试成绩的数据集。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="5fbc" class="nv mv it ly b gy nw nx l ny nz">df1 = pd.DataFrame({<br/>    'name': ['A', 'B', 'C', 'D'],<br/>    'math': [60,89,82,70],<br/>    'physics': [66,95,83,66],<br/>    'chemistry': [61,91,77,70]<br/>})</span><span id="6499" class="nv mv it ly b gy oa nx l ny nz">df2 = pd.DataFrame({<br/>    'name': ['E', 'F', 'G', 'H'],<br/>    'math': [66,95,83,66],<br/>    'physics': [60,89,82,70],<br/>    'chemistry': [90,81,78,90]<br/>})</span></pre><p id="dfa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">concat()</code>最简单的连接是传递一系列数据帧，例如<code class="fe lv lw lx ly b">[df1, df2]</code>。默认情况下，它沿着轴<code class="fe lv lw lx ly b">0</code>垂直连接，并保留所有现有的索引。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="e93b" class="nv mv it ly b gy nw nx l ny nz">pd.concat(<strong class="ly iu">[df1, df2]</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b63bf2f5a400c82e7fff6a082d6b8601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*0CZkhWv0PuYYVgEHZyVi7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">默认情况下，df1和df2的索引都会保留</p></figure><p id="c522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望串联忽略现有的索引，您可以设置参数<code class="fe lv lw lx ly b">ignore_index=True</code>。然后，产生的数据帧索引将用<code class="fe lv lw lx ly b">0</code>、…、<code class="fe lv lw lx ly b">n-1</code>标记。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="3914" class="nv mv it ly b gy nw nx l ny nz">pd.concat([df1, df2], <strong class="ly iu">ignore_index=True</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d90636b33117cac319169b9eefc8dd77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*gNr6ZLEEbX0N4pasg4J5Bg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe lv lw lx ly b">pd.concat([df1, df2], ignore_index=True)</code>的输出</p></figure><p id="8e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要沿轴<code class="fe lv lw lx ly b">1</code>水平连接数据帧，可以设置参数<code class="fe lv lw lx ly b">axis=1</code>。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="7859" class="nv mv it ly b gy nw nx l ny nz">pd.concat([df1, df2], <strong class="ly iu">axis=1</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/d254c0257f3a4cace208ebc187a6144a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYSrNc_UrVFR6hzA_dgAxw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe lv lw lx ly b">pd.concat([df1, df2], axis=1)</code>的输出</p></figure><h1 id="39ba" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">2.避免重复索引</h1><p id="de0e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在，我们知道<code class="fe lv lw lx ly b">concat()</code>函数保留了索引。如果您想验证<code class="fe lv lw lx ly b">pd.concat()</code>结果中的索引没有重叠，您可以设置参数<code class="fe lv lw lx ly b">verify_integrity=True</code>。设置为<code class="fe lv lw lx ly b">True</code>时，如果有重复的索引，将引发异常。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="6a93" class="nv mv it ly b gy nw nx l ny nz">try:<br/>    pd.concat([df1,df2], <strong class="ly iu">verify_integrity=True</strong>)<br/>except ValueError as e:<br/>    print('ValueError', e)</span><span id="b33c" class="nv mv it ly b gy oa nx l ny nz">ValueError: Indexes have overlapping values: Int64Index([0, 1, 2, 3], dtype='int64')</span></pre><h1 id="5497" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">3.使用<code class="fe lv lw lx ly b">keys</code>和<code class="fe lv lw lx ly b">names</code>选项添加分层索引</h1><p id="e809" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">增加一个<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#hierarchical-indexing-multiindex" rel="noopener ugc nofollow" target="_blank">层次索引</a>(也叫多级索引)对于更复杂的数据分析还是挺有用的。在这种情况下，我们分别为<code class="fe lv lw lx ly b">df1</code>和<code class="fe lv lw lx ly b">df2</code>增加指标<strong class="lb iu">第一年</strong>和<strong class="lb iu">第二年</strong>。为此，我们可以简单地指定<code class="fe lv lw lx ly b">keys</code>参数。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="2e01" class="nv mv it ly b gy nw nx l ny nz">res = pd.concat([df1, df2], <strong class="ly iu">keys=['Year 1','Year 2']</strong>)<br/>res</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9e479ed16dd7ace0454c3bcc8a2a123c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*4RdjCd4P48ZjMmasJMpt3A.png"/></div></figure><p id="9bf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并访问一组特定的值，例如，<strong class="lb iu"> Year 1 </strong>:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="db59" class="nv mv it ly b gy nw nx l ny nz">res.<strong class="ly iu">loc['Year 1']</strong></span></pre><p id="e0da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，参数<code class="fe lv lw lx ly b">names</code>可用于为产生的分层索引添加名称。例如:将name <strong class="lb iu"> <em class="ok"> Class </em> </strong>添加到我们刚刚创建的最外层索引中。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="3da7" class="nv mv it ly b gy nw nx l ny nz">pd.concat(<br/>    [df1, df2], <br/>    keys=['Year 1', 'Year 2'],<br/>    <strong class="ly iu">names=['Class', None],</strong><br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/e1060ebeb32d001d3e0e0f02e9ef1a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*VmVJaNwrbj5tk-7_1W5rxA.png"/></div></figure><p id="43d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要重置索引并将其转换为数据列，可以使用<code class="fe lv lw lx ly b">reset_index()</code></p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="e6ed" class="nv mv it ly b gy nw nx l ny nz">pd.concat(<br/>    [df1, df2], <br/>    keys=['Year 1', 'Year 2'],<br/>    names=['Class', None],<br/>).<strong class="ly iu">reset_index(level=0)   </strong></span><span id="be1b" class="nv mv it ly b gy oa nx l ny nz"><strong class="ly iu"># reset_index(level='Class')</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/d23880edcc4df137b6b58bff7df8a515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*PrdTidLAAbSezEN2AA74OA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重置类别索引</p></figure><h1 id="1625" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">4.列匹配和排序</h1><p id="171c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe lv lw lx ly b">concat()</code>函数能够以不同的顺序连接数据帧和列。默认情况下，结果数据帧将与第一个数据帧具有相同的排序。比如下面这个例子，和<code class="fe lv lw lx ly b">df1</code>的顺序一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/40673d78b748b5ba4de8696d60fb8498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3xxU3APQ2FsDDrUQOQ7I3w.png"/></div></div></figure><p id="7dd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望得到的数据帧按字母顺序排序，您可以设置参数<code class="fe lv lw lx ly b">sort=True</code>。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="840e" class="nv mv it ly b gy nw nx l ny nz">pd.concat([df1, df2], <strong class="ly iu">sort=True</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/a9886caa9eb8b8e701d8bcf7efe2eef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*C1N7-4TOOgeHA3KhoP4a-g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按列名排序</p></figure><p id="b3c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您喜欢自定义排序，以下是如何进行的:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="af28" class="nv mv it ly b gy nw nx l ny nz"><strong class="ly iu">custom_sort</strong> = ['math', 'chemistry', 'physics', 'name']<br/>res = pd.concat([df1, df2])<br/><strong class="ly iu">res[custom_sort]</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d48008d0371e41bbd93642b7a55ba36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*dr2pse0CIU3sCmYfkFnLyg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义排序</p></figure><h1 id="27ef" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">5.从一堆CSV文件中加载和连接数据集</h1><p id="c1cf" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">假设我们需要从一堆CSV文件中加载和连接数据集。这是一个使用for循环的解决方案。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="087d" class="nv mv it ly b gy nw nx l ny nz"># Bad<br/>import pathlib2 as pl2<br/>ps = pl2.Path('data/sp3')</span><span id="94a9" class="nv mv it ly b gy oa nx l ny nz">res = None<br/><strong class="ly iu">for p in ps.glob('*.csv'):</strong><br/>    if res is None:<br/>        res = pd.read_csv(p)<br/>    else:<br/>        res = <strong class="ly iu">pd.concat([res, pd.read_csv(p)])</strong></span></pre><p id="6399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然有用。但是<code class="fe lv lw lx ly b">pd.concat()</code>在每次for循环迭代中都会被调用。我们可以使用列表理解有效地解决这个问题。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="83b0" class="nv mv it ly b gy nw nx l ny nz">import pathlib2 as pl2<br/>ps = pl2.Path('data/sp3')</span><span id="277f" class="nv mv it ly b gy oa nx l ny nz">dfs = (<br/>    <strong class="ly iu">pd.read_csv(p, encoding='utf8') for p in ps.glob('*.csv')</strong><br/>)</span><span id="8727" class="nv mv it ly b gy oa nx l ny nz">res = <strong class="ly iu">pd.concat(dfs)</strong><br/>res</span></pre><p id="5541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一行代码读取所有CSV文件并生成一个数据帧列表<code class="fe lv lw lx ly b">dfs</code>。然后，我们只需要调用一次<code class="fe lv lw lx ly b">pd.concat(dfs)</code>就可以得到相同的结果。</p><p id="2873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用<code class="fe lv lw lx ly b">%%timeit</code>计算两次执行的时间，你可能会发现列表理解解决方案节省了一半的时间。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="55d5" class="nv mv it ly b gy nw nx l ny nz"># for-loop solution<br/><strong class="ly iu">298 ms ± 11.8 ms per loop</strong> (mean ± std. dev. of 7 runs, 1 loop each)</span><span id="77f1" class="nv mv it ly b gy oa nx l ny nz"># list comprehension solution<br/><strong class="ly iu">153 ms ± 6 ms per</strong> loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="c137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解节省时间和代码。与使用循环相比，这是一种简单的生成列表的方法。</p><h1 id="a0b1" class="mu mv it bd mw mx oe mz na nb of nd ne jz og ka ng kc oh kd ni kf oi kg nk nl bi translated">好了</h1><p id="a0e6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">感谢阅读。</p><p id="571c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码请查看<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/master/data-analysis/016-pandas-concat/pandas-concat.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>。</p><p id="d442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对机器学习的实用方面感兴趣，请继续关注。</p><h2 id="3ade" class="nv mv it bd mw op oq dn na or os dp ne li ot ou ng lm ov ow ni lq ox oy nk oz bi translated">你可能会对我的其他一些熊猫文章感兴趣:</h2><ul class=""><li id="98ee" class="lz ma it lb b lc nm lf nn li pa lm pb lq pc lu pd mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/how-to-do-a-custom-sort-on-pandas-dataframe-ac18e7ea5320">如何对熊猫数据帧进行自定义排序</a></li><li id="1422" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu pd mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/when-to-use-pandas-transform-function-df8861aa0dcf">何时使用熊猫变换()函数</a></li><li id="4dcd" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu pd mf mg mh bi translated"><a class="ae ky" href="https://medium.com/@bindiatwork/using-pandas-method-chaining-to-improve-code-readability-d8517c5626ac" rel="noopener">使用熊猫方法链接提高代码可读性</a></li><li id="0f3b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu pd mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/working-with-datetime-in-pandas-dataframe-663f7af6c587">在Pandas数据帧中处理日期时间</a></li><li id="6ac5" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu pd mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/working-with-missing-values-in-pandas-5da45d16e74">处理熊猫中缺失的值</a></li><li id="c884" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu pd mf mg mh bi translated"><a class="ae ky" href="https://medium.com/@bindiatwork/all-the-pandas-read-csv-you-should-know-to-speed-up-your-data-analysis-1e16fe1039f3" rel="noopener">熊猫阅读_csv()你应该知道的招数</a></li><li id="78e3" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu pd mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/4-tricks-you-should-know-to-parse-date-columns-with-pandas-read-csv-27355bb2ad0e">用Pandas read_csv()解析日期列应该知道的4个技巧</a></li></ul><p id="4c2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多可以从我的<a class="ae ky" href="https://github.com/BindiChen/machine-learning" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到</p></div></div>    
</body>
</html>