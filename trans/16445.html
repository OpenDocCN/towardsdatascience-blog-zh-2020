<html>
<head>
<title>FuzzyWuzzy: Fuzzy String Matching in Python, Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FuzzyWuzzy:Python中的模糊字符串匹配，初学者指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fuzzywuzzy-fuzzy-string-matching-in-python-beginners-guide-9adc0edf4b35?source=collection_archive---------7-----------------------#2020-11-13">https://towardsdatascience.com/fuzzywuzzy-fuzzy-string-matching-in-python-beginners-guide-9adc0edf4b35?source=collection_archive---------7-----------------------#2020-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="526f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及在真实世界数据集上的实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84f48180cc5314c00425165273081cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEBeHqA_3ovSat2Z_VZM1g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">照片由</strong> <a class="ae kz" href="https://pixabay.com/users/stephennorris-7555778/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3052477" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ky">史蒂夫·诺里斯</strong> </a> <strong class="bd ky">上</strong> <a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3052477" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ky"> Pixabay </strong> </a></p></figure><h2 id="f981" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="2bbd" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">如果您以前处理过文本数据，您会知道它的问题是最难处理的。对于文本问题，没有一个放之四海而皆准的解决方案，对于每个数据集，你必须想出新的方法来清理你的数据。在我之前的一篇文章中，我谈到了这类问题的最坏情况:</p><blockquote class="mp"><p id="3f82" class="mq mr it bd ms mt mu mv mw mx my mo dk translated">例如，考虑这种最坏的情况:您正在处理一个在美国进行的调查数据，数据集中每个观察的状态都有一个state列。美国有50个州，想象一下人们能想出的各种州名。如果数据收集者决定使用缩写:ca，Ca，CA，Caliphornia，Californa，California，calipornia，calipornia，CAL，CALI，你的问题就更大了……这样的栏目总是充满了错别字、错误和不一致。</p></blockquote><p id="25b7" class="pw-post-body-paragraph lw lx it ly b lz mz ju mb mc na jx me lj nb mg mh ln nc mj mk lr nd mm mn mo im bi translated">由于数据收集过程中的自由文本，经常会出现与文本相关的问题。它们将充满错别字，不一致，无论你能说出什么。当然，最基本的问题可以使用简单的正则表达式或内置的Python函数来解决，但是对于上面这种经常发生的情况，您必须用更复杂的工具来武装自己。</p><p id="51aa" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">今天的特色是<code class="fe nj nk nl nm b">fuzzywuzzy</code>，这是一个带有非常简单的API的包，可以帮助我们计算字符串相似度。</p><div class="nn no gp gr np nq"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">通过我的推荐链接加入Medium-BEXGBoost</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><p id="80df" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">获得由强大的AI-Alpha信号选择和总结的最佳和最新的ML和AI论文:</p><div class="nn no gp gr np nq"><a href="https://alphasignal.ai/?referrer=Bex" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">阿尔法信号|机器学习的极品。艾总结的。</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">留在循环中，不用花无数时间浏览下一个突破；我们的算法识别…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">alphasignal.ai</p></div></div><div class="nz l"><div class="of l ob oc od nz oe ks nq"/></div></div></a></div></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="8d18" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="op oq or"><p id="cde0" class="lw lx os ly b lz ne ju mb mc nf jx me ot ng mg mh ou nh mj mk ov ni mm mn mo im bi translated">从<a class="ae kz" href="https://www.kaggle.com/bextuychiev/fuzzywuzzy-fuzzy-string-matching-in-python" rel="noopener ugc nofollow" target="_blank">本</a> Kaggle笔记本或<a class="ae kz" href="https://github.com/BexTuychiev/medium_stories/tree/master/november_2020/string_matching_w_fuzzy_wuzzy" rel="noopener ugc nofollow" target="_blank">本</a> GitHub repo获取本文使用的笔记本和数据。</p></blockquote></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="b73f" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">字符串匹配是如何执行的</h2><p id="272f" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">为了理解字符串匹配，让我们用最小编辑距离来帮助您加快速度。作为人类，如果两个或更多的字符串相似或不相似，我们没有任何问题。为了在计算机中创造这种能力，人们创造了许多算法，几乎所有的算法都依赖于最小编辑距离。</p><p id="5797" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">最小编辑距离(MED)是从一个字符串过渡到另一个字符串所需的最少可能的步数。MED仅使用4种运算来计算:</p><ul class=""><li id="aacc" class="ow ox it ly b lz ne mc nf lj oy ln oz lr pa mo pb pc pd pe bi translated">插入</li><li id="8b32" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">删除</li><li id="63f4" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">代替</li><li id="84eb" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">替换连续字符</li></ul><p id="a9b8" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">考虑这两个词:<strong class="ly iu">程序</strong>和<strong class="ly iu">声谱图</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/5503808b065c509263a355bc775e4754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*lPGAmXo17Wu9HHmmKcd12g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片由</strong> <a class="ae kz" href="https://medium.com/@ibexorigin" rel="noopener"> <strong class="bd ky">作者</strong> </a></p></figure><p id="3e42" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">从程序到声谱图，我们需要3个步骤:</p><ol class=""><li id="a745" class="ow ox it ly b lz ne mc nf lj oy ln oz lr pa mo pl pc pd pe bi translated">在“Program”的开头加上字母“S”。</li><li id="8f12" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pl pc pd pe bi translated">用O代替P。</li><li id="3974" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pl pc pd pe bi translated">用N代替R。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/73afef0f65ce414f183b81978e7e8b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*HJ5O9UzQbxUlvo7xKsSNCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">最小编辑距离为3。图片由</strong> <a class="ae kz" href="https://medium.com/@ibexorigin" rel="noopener"> <strong class="bd ky">作者</strong> </a> <strong class="bd ky">提供。</strong></p></figure><p id="1048" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">我说过，有很多算法可以计算MED:</p><ul class=""><li id="a4cf" class="ow ox it ly b lz ne mc nf lj oy ln oz lr pa mo pb pc pd pe bi translated">达默劳-莱文斯坦</li><li id="95c8" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">莱文斯坦</li><li id="30b1" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">加重平均</li><li id="6853" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">Jaro距离</li></ul><p id="5c93" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">此外，还有使用这些算法的软件包:<code class="fe nj nk nl nm b">nltk</code>、<code class="fe nj nk nl nm b">fuzzywuzzy</code>、<code class="fe nj nk nl nm b">textdistance</code>、<code class="fe nj nk nl nm b">difflib</code>，...</p><p id="1127" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">在本文中，我们将只涉及<code class="fe nj nk nl nm b">fuzzywuzzy</code>。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="a228" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">模糊不清:安装</h2><p id="4bde" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">尽管使用<code class="fe nj nk nl nm b">pip</code>可以轻松完成基本安装，但对于<code class="fe nj nk nl nm b">fuzzwuzzy</code>的安装还有一些其他选项或注意事项:</p><ul class=""><li id="037e" class="ow ox it ly b lz ne mc nf lj oy ln oz lr pa mo pb pc pd pe bi translated">通过PyPI使用PIP(标准):</li></ul><p id="c249" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><code class="fe nj nk nl nm b">pip install fuzzywuzzy</code></p><p id="368f" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">上述方法安装软件包的默认最新版本。起初，我用这种方法安装它。但是每当我导入它的时候，它就开始给出警告，说这个包本身很慢，我应该安装<code class="fe nj nk nl nm b">python-Levenshtein</code>包来加快速度。如果你像我一样讨厌Jupyter笔记本上的警告，下面是你安装额外依赖项的方法:</p><ul class=""><li id="b14c" class="ow ox it ly b lz ne mc nf lj oy ln oz lr pa mo pb pc pd pe bi translated">直接安装<code class="fe nj nk nl nm b">python-Levenshtein</code>:</li></ul><p id="ffe3" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><code class="fe nj nk nl nm b">pip install python-Levenshtein</code></p><p id="625f" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">或者</p><p id="1f40" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><code class="fe nj nk nl nm b">pip install fuzzywuzzy[speedup]</code></p><p id="93b9" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><strong class="ly iu">对Windows用户的警告</strong>:如果没有安装Microsoft Visual Studio构建工具，安装<code class="fe nj nk nl nm b">python-Levenshtein</code>会失败。你可以从<a class="ae kz" href="https://visualstudio.microsoft.com/downloads/" rel="noopener ugc nofollow" target="_blank">这里</a>下载MVS构建工具。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="9f91" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">FuzzyWuzzy:WRatio的基础</h2><p id="184d" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">为了从<code class="fe nj nk nl nm b">fuzzywuzzy</code>开始，我们首先导入<code class="fe nj nk nl nm b">fuzz</code>子模块:</p><pre class="kj kk kl km gt pn nm po pp aw pq bi"><span id="55ea" class="la lb it nm b gy pr ps l pt pu">from fuzzywuzzy import fuzz</span></pre><p id="640d" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">在这个子模块中，有5个函数用于两个字符串之间不同的比较方法。日常使用最灵活最好的是<code class="fe nj nk nl nm b">WRatio</code>(加权比率)功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="584a" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">在这里，我们将“Python”与“Cython”进行比较。输出返回0到100之间的百分比，0表示完全不相似，100表示完全相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="94da" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><code class="fe nj nk nl nm b">fuzzywuzzy</code>的所有函数都不区分大小写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="22c9" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><code class="fe nj nk nl nm b">WRatio</code>对于不同排序的部分字符串也很好:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="6211" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">模糊:不同方法的比较</h2><p id="564d" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">除了<code class="fe nj nk nl nm b">WRatio</code>之外，还有4个函数可以计算字符串相似度:</p><ul class=""><li id="999e" class="ow ox it ly b lz ne mc nf lj oy ln oz lr pa mo pb pc pd pe bi translated">模糊比率</li><li id="c662" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">模糊.部分_比率</li><li id="c694" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">fuzz.token_sort_ratio</li><li id="0fed" class="ow ox it ly b lz pf mc pg lj ph ln pi lr pj mo pb pc pd pe bi translated">fuzz.token_set_ratio</li></ul><p id="4156" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><code class="fe nj nk nl nm b">fuzz.ratio</code>非常适合长度和顺序相似的字符串:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="1108" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">对于不同长度的字符串，最好使用“fuzz.patial_ratio”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6092" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">如果字符串含义相同，但顺序不同，使用<code class="fe nj nk nl nm b">fuzz.token_sort_ratio</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="46cf" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">更多边缘情况，有<code class="fe nj nk nl nm b">fuzz.token_set_ratio</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="7e02" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">如你所见，这5个函数充满了警告。他们的比较完全是另一个话题，所以我给你留了一个由软件包创建者写的<a class="ae kz" href="https://chairnerd.seatgeek.com/fuzzywuzzy-fuzzy-string-matching-in-python/" rel="noopener ugc nofollow" target="_blank">文章</a>的链接，这篇文章很好地解释了他们的区别。</p><blockquote class="op oq or"><p id="1a3e" class="lw lx os ly b lz ne ju mb mc nf jx me ot ng mg mh ou nh mj mk ov ni mm mn mo im bi translated">我想你已经看到了<code class="fe nj nk nl nm b">WRatio</code>函数为<code class="fe nj nk nl nm b">fuzzywuzzy</code>的所有函数提供了中间基础。对于许多边缘情况和不同问题，最好使用<code class="fe nj nk nl nm b">WRatio</code>以获得最佳效果。</p></blockquote></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="a338" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用<code class="fe nj nk nl nm b">fuzzywuzzy.process</code>从选项列表中提取字符串的最佳匹配</h2><p id="476c" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">现在我们对<code class="fe nj nk nl nm b">fuzzywuzzy</code>的不同功能有了一些了解，我们可以继续处理更复杂的问题。对于现实生活中的数据，大多数时候您必须从选项列表中找到与您的字符串最相似的值。考虑这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="3588" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">我们必须找到与<code class="fe nj nk nl nm b">Mercedez-Benz</code>最匹配的，用汽车的正确拼法替换它们。我们可以对每个值进行循环，但是如果有数百万个选项可供选择，这样的过程会花费很长时间。由于这个操作非常常用，<code class="fe nj nk nl nm b">fuzzywuzzy</code>为我们提供了一个有用的子模块:</p><pre class="kj kk kl km gt pn nm po pp aw pq bi"><span id="b0f2" class="la lb it nm b gy pr ps l pt pu">from fuzzywuzzy import process</span></pre><p id="726a" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">使用这个子模块，您可以从一系列字符串中提取与您的字符串最匹配的内容。让我们解决我们最初的问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8232" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><code class="fe nj nk nl nm b">process.extract</code>中感兴趣的参数有<code class="fe nj nk nl nm b">query</code>、<code class="fe nj nk nl nm b">choices</code>和<code class="fe nj nk nl nm b">limit</code>。该函数根据<code class="fe nj nk nl nm b">choices</code>中给出的一系列选项计算<code class="fe nj nk nl nm b">query</code>中给出的字符串的相似度，并返回一个元组列表。<code class="fe nj nk nl nm b">limit</code>控制返回的元组数量。每个元组包含两个元素，第一个是匹配字符串，第二个是相似性得分。</p><p id="cbd9" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">在引擎盖下，<code class="fe nj nk nl nm b">process.extract</code>使用默认的<code class="fe nj nk nl nm b">WRatio</code>功能。但是，根据您的情况和了解5个功能之间的差异，您可以使用<code class="fe nj nk nl nm b">scorer</code>更改评分功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="462e" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">如果你有很多选择，最好坚持使用<code class="fe nj nk nl nm b">WRatio</code>，因为它最灵活。</p><p id="233e" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">在<code class="fe nj nk nl nm b">process</code>模块中，有其他功能执行类似的操作。<code class="fe nj nk nl nm b">process.extractOne</code>仅返回一个包含最高匹配分数的字符串的输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="6fec" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">真实数据集上的模糊文本清理</h2><p id="f626" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">现在我们准备解决一个现实世界的问题。我将加载原始数据进行练习:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pv"><img src="../Images/b7d94a1aac92c70fd02b0aa9fd58817b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*TZq-9xKVizHZGo-7nZ9_dA.png"/></div></figure><pre class="kj kk kl km gt pn nm po pp aw pq bi"><span id="73db" class="la lb it nm b gy pr ps l pt pu">cars.shape</span><span id="796a" class="la lb it nm b gy pw ps l pt pu">(8504, 4)</span></pre><p id="76fc" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">我在我的一个个人项目中使用了这个数据集，任务是根据另一个文件中给出的正确值来纠正每个车辆品牌和型号的拼写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="7502" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">加载pickle文件后，<code class="fe nj nk nl nm b">make_model</code>现在是一个字典，包含每个汽车品牌的正确拼写和每个关键字下的车型的正确拼写。</p><p id="9dbe" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">例如，让我们看看<code class="fe nj nk nl nm b">Toyota</code>汽车品牌和型号的拼法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="c417" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">现在，让我们对<code class="fe nj nk nl nm b">Toyota</code>汽车的原始数据进行子集划分:</p><pre class="kj kk kl km gt pn nm po pp aw pq bi"><span id="abda" class="la lb it nm b gy pr ps l pt pu">&gt;&gt;&gt; cars[cars['vehicle_make'] == 'TOYOTA']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pv"><img src="../Images/375afb16fc6bd0a5105dd0edf4d4290a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*vftBwyxS0M_GYvM3wm9VeA.png"/></div></figure><p id="4950" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">该数据集包含多达100个独特的汽车品牌，如奥迪、宾利、宝马，每一个都包含几个充满边缘案例的模型。我们不能把每一个都转换成大写或小写。我们也不知道这些是否包含任何拼写错误或不一致，视觉搜索对于这样的大数据集不是一个选项。也有一些情况下，使用多于一个单词的make标签用一个<code class="fe nj nk nl nm b">space</code>来分隔名称，而其他标签用一个<code class="fe nj nk nl nm b">dash</code>来分隔名称。如果有这么多的不一致，并且没有一个清晰的模式，请使用字符串匹配。</p><p id="1ab4" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">让我们从清理标签开始。为了便于比较，以下是两个数据集中的制作标签:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="706d" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">我认为差异是显而易见的。我们将使用<code class="fe nj nk nl nm b">process.extract</code>将每个品牌与正确的拼写相匹配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="3ccc" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">如您所见，存在于<code class="fe nj nk nl nm b">make_model</code>中的品牌标签被转换成了正确的拼写。现在，是时候给模特贴标签了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pv"><img src="../Images/d4d8d858d927974e837fb53d180cc0b4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dkR4TVSS-YvJFLDrqrO1WQ.png"/></div></figure><blockquote class="op oq or"><p id="c315" class="lw lx os ly b lz ne ju mb mc nf jx me ot ng mg mh ou nh mj mk ov ni mm mn mo im bi translated">最后两个代码片段有点吓人。为了充分理解它们是如何工作的，你应该在<code class="fe nj nk nl nm b">process.extract</code>上做一些练习。</p></blockquote><p id="22ca" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated">这就对了。如果你不知道字符串匹配，这个任务就不可能完成，甚至正则表达式也不能帮助你。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="6cc9" class="px lb it bd lc py pz qa lf qb qc qd li jz qe ka lm kc qf kd lq kf qg kg lu qh bi translated">如果你喜欢这篇文章，请分享并留下反馈。作为一名作家，你的支持对我来说意味着一切！</h1><p id="d739" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">阅读更多与主题相关的文章:</p><p id="cc57" class="pw-post-body-paragraph lw lx it ly b lz ne ju mb mc nf jx me lj ng mg mh ln nh mj mk lr ni mm mn mo im bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/data-type-constraints-data-range-constraints-duplicate-data-with-pandas-44897a350b1e?source=your_stories_page-------------------------------------">https://towards data science . com/data-type-constraints-data-range-constraints-duplicate-data-with-pandas-44897 a 350 B1 e？source=your_stories_page - </a></p><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/master-the-most-hated-task-in-ds-ml-3b9779276d7c"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">掌握DS/ML中最讨厌的任务</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">用Pandas清理分类数据</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="qi l ob oc od nz oe ks nq"/></div></div></a></div><div class="nn no gp gr np nq"><a rel="noopener follow" target="_blank" href="/meet-the-hardest-functions-of-pandas-part-i-7d1f74597e92"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">认识熊猫最难的功能，第一部分</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">掌握pivot_table()、stack()、unstack()的时机和方式</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="qj l ob oc od nz oe ks nq"/></div></div></a></div></div></div>    
</body>
</html>