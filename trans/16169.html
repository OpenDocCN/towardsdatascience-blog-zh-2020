<html>
<head>
<title>Introduction to Graph Algorithm: Breadth-First Search Algorithm in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图算法简介:Python中的广度优先搜索算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-graph-algorithm-breadth-first-search-algorithm-in-python-8644b6d31880?source=collection_archive---------17-----------------------#2020-11-07">https://towardsdatascience.com/introduction-to-graph-algorithm-breadth-first-search-algorithm-in-python-8644b6d31880?source=collection_archive---------17-----------------------#2020-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/64f82a5eeb38c5cc2bb88cb359566d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RLyd-nxaD3doq7Lh"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jg" href="https://unsplash.com/@gkumar2175?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">甘帕尼·库马尔</a>拍摄</p></figure><h2 id="fd80" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="8d13" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">清晰理解可视化广度优先搜索算法</h2></div><p id="cc1c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">图表形式的数据存在于许多流行和广泛使用的应用程序中。网络爬虫、计算机网络、关系数据库和社交网络都是很好的例子。图搜索算法对于计算机科学的任何部分都是重要的。同样，这对于许多编码面试来说也是重要和有用的。</p><p id="5ce6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有几种不同的图形搜索算法可用。这是最简单的图搜索算法之一，也是许多其他图算法的一种原型。今天我将详细解释广度优先搜索算法，并展示广度优先搜索算法的一个用例。以下是这篇文章的要点:</p><ol class=""><li id="5461" class="md me jj lj b lk ll ln lo lq mf lu mg ly mh mc mi mj mk ml bi translated">广度优先搜索算法如何处理视觉效果</li><li id="2806" class="md me jj lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">用Python开发算法</li><li id="13e8" class="md me jj lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">如何用这个算法找到任意节点到源节点的最短路径。</li><li id="2928" class="md me jj lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">时间复杂度</li></ol><p id="a252" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">我们开始吧！</strong></p><h1 id="4173" class="mr ms jj bd mt mu mv mw mx my mz na nb ky nc kz nd lb ne lc nf le ng lf nh ni bi translated">广度优先搜索算法的工作原理</h1><p id="526e" class="pw-post-body-paragraph lh li jj lj b lk nj kt lm ln nk kw lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">一个图有两个元素。顶点和边。</p><p id="fc1b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">鉴于，</p><p id="dc62" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一个图G = (V，E)，</p><p id="b8ec" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中V是顶点，E是边。</p><p id="77d5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">广度优先搜索算法系统地逐层探索边，以发现从给定的源顶点s可到达的每个顶点。</p><p id="caee" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以下是广度优先搜索流程的步骤:</p><ol class=""><li id="9d18" class="md me jj lj b lk ll ln lo lq mf lu mg ly mh mc mi mj mk ml bi translated">有一个起始顶点s。</li><li id="a686" class="md me jj lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">用开始顶点S作为级别1初始化级别集。</li><li id="7d55" class="md me jj lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">探索另一个顶点从开始就可以到达。这些顶点将被视为级别2。</li><li id="b6ec" class="md me jj lj b lk mm ln mn lq mo lu mp ly mq mc mi mj mk ml bi translated">这样顶点就会一层一层的打开。</li></ol><p id="8535" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以下是这些步骤的直观演示:</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/67a7a62a4c3f5b14e20e2e146962a393.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/0*4fWf_0-UIgsBIO5t.png"/></div></figure><p id="14b6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，我们有六个顶点，u，v，w，x，y，z和七条边ux，uv，vx，vy，xy，wy，wz。</p><p id="b2fe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将顶点u视为源顶点或起始顶点。现在看下图他们是怎么一级一级打开的。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/58c7c85cfb10daec6ada8f6825dcc2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/0*dftH9xkgJtQssy0U.png"/></div></div></figure><p id="7c0d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">源顶点是u是level 1。我们查一下我们能从L1去哪里。从图中可以看出,‘u’有一条直接通向v和x的路径，所以，它们是2级。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1fd8022c9a851c01e87ffb1b4d7dfd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*dJqDbS5sn0oxv85D.png"/></div></figure><p id="36fb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们在节点x和v中。x和v只能直接访问y。因此，y是第3层。<strong class="lj jt"> <em class="nv">从x和v两方面，我们可以去u也。但是我们忽略了已经访问过的节点。</em>T11】</strong></p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/416d6bceab00a484e7dc55ad10597103.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/0*HW3jLgSNqNM98Fm_.png"/></div></div></figure><p id="89a8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">y只能直接访问w。所以，w是第四级。我们也可以从y到v和x，但是它们已经被访问过了。所以，我们再也不用担心他们了。</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d8c19a474832ba2fa864001ddfdc63a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/0*uNmUjcUO7OiNgFhs.png"/></div></figure><p id="6ff0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后w可以到z，z是level5。</p><h1 id="2ffe" class="mr ms jj bd mt mu mv mw mx my mz na nb ky nc kz nd lb ne lc nf le ng lf nh ni bi translated">Python中的算法</h1><p id="6777" class="pw-post-body-paragraph lh li jj lj b lk nj kt lm ln nk kw lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">在我们深入算法之前，让我们先做一个邻接表。也就是说，创建一个字典，其中每个节点都是一个键，链接到它的节点都是存储在列表中的值。</p><p id="b597" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，节点u链接到节点v和x。因此，它将表示为:</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="02ca" class="ob ms jj nx b gy oc od l oe of">'u': ['v', 'x']</span></pre><p id="dd29" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里的“u”是“v”和“x”的父代。</p><p id="bd2b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们还需要对所有其他节点进行同样的操作。邻接表将看起来像这样:</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="1c38" class="ob ms jj nx b gy oc od l oe of">adj = {<br/>    'u': ['v', 'x'],<br/>    'x': ['u', 'v', 'y'],<br/>    'v': ['u', 'x', 'y'],<br/>    'y': ['w'],<br/>    'w': ['y', 'z'],<br/>    'z': ['w']<br/>    }</span></pre><p id="a2a4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们需要初始化几个变量:</p><p id="341e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">变量来跟踪我们已经访问过的节点，</p><p id="09b2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">“级别”变量来跟踪我们当前所处的级别，</p><p id="5dfe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">“parent”变量来存储节点的父节点。</p><p id="a383" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">“traversal_output”来列出经过的节点。</p><p id="b0d4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我们将使用一个队列来开发这个算法。Python有一个内置的队列，我们可以导入并使用它。</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="a7df" class="ob ms jj nx b gy oc od l oe of">from queue import Queue<br/>visited = {}<br/>level = {}<br/>parent = {}<br/>traversal_output = []<br/>queue = Queue()</span></pre><p id="597d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">开始时，将“已访问”字典中的所有节点设置为“False ”,将“父”字典中的所有节点设置为“None ”,并将级别设置为-1。</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="b199" class="ob ms jj nx b gy oc od l oe of">for node in adj_list.keys():<br/>        visited[node] = False<br/>        parent[node] = None<br/>        level[node] = -1</span></pre><p id="5d48" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如图，假设来源是‘u’。首先，使用visited[s] = True，使用level 0并在队列中添加“u”。</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="1849" class="ob ms jj nx b gy oc od l oe of">s = "u"<br/>visited[s] = True<br/>level[s] = 0<br/>queue.put(s)</span></pre><p id="3266" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">循环来了！</strong></p><p id="f5eb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个阶段，我们需要访问链接到源节点“u”的节点。我们将它列在上面的邻接表中。对于它们中的每一个，将它们设置为已访问，将它们的级别升级为比源节点的级别高一级，将它们的父节点设置为“u”，最后将它们添加到队列中。</p><p id="f3b5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后对它们的子节点重复同样的操作。以下是完整的循环:</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="03d6" class="ob ms jj nx b gy oc od l oe of">while not queue.empty():<br/>    u = queue.get()<br/>    traversal_output.append(u)<br/>    for v in adj_list[u]:<br/>        if not visited[v]:<br/>            visited[v] = True<br/>            parent[v] = u<br/>            level[v] = level[u] + 1<br/>            queue.put(v)<br/>print(traversal_output)<br/>print(visited)<br/>print(level)<br/>print(parent)</span></pre><p id="caba" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="2d29" class="ob ms jj nx b gy oc od l oe of">['u', 'v', 'x', 'y', 'w', 'z']<br/>{'u': True, 'x': True, 'v': True, 'y': True, 'w': True, 'z': True}<br/>{'u': 0, 'x': 1, 'v': 1, 'y': 2, 'w': 3, 'z': 4}<br/>{'u': None, 'x': 'u', 'v': 'u', 'y': 'v', 'w': 'y', 'z': 'w'}</span></pre><p id="f93e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Traversal_output显示我们遍历了所有节点。</p><p id="52e2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于每个节点，第二行中的visited为true。</p><p id="6ab4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在第三行中，我们有所有节点的级别。请对照上面的图片。</p><p id="6c85" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在第四行，我们有所有节点的父节点。“u”是源节点。所以,“u”没有父代。</p><p id="d71d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将所有代码组合起来，放入一个函数中:</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="e2fd" class="ob ms jj nx b gy oc od l oe of">def Breadth_first_search(adj_list):<br/>    visited = {}<br/>    level = {}<br/>    parent = {}<br/>    traversal_output = []<br/>    queue = Queue()<br/>    for node in adj_list.keys():<br/>        visited[node] = False<br/>        parent[node] = None<br/>        level[node] = -1<br/>    s = "u"<br/>    visited[s] = True<br/>    level[s] = 0<br/>    queue.put(s)<br/>    while not queue.empty():<br/>        u = queue.get()<br/>        traversal_output.append(u)<br/>        for v in adj_list[u]:<br/>            if not visited[v]:<br/>                visited[v] = True<br/>                parent[v] = u<br/>                level[v] = level[u] + 1<br/>                queue.put(v)<br/>    return traversal_output, visited, level, parent</span></pre><p id="58ec" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">调用这个函数并传递邻接表' adj '会给你同样的输出。</p><h1 id="0de8" class="mr ms jj bd mt mu mv mw mx my mz na nb ky nc kz nd lb ne lc nf le ng lf nh ni bi translated">寻找最短的距离</h1><p id="2344" class="pw-post-body-paragraph lh li jj lj b lk nj kt lm ln nk kw lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">该算法可用于寻找从源到任何其他节点的最短路径。怎么会？</p><p id="fa51" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">看，我们知道每个节点的父节点。从任何一个节点，我们通过父节点不断回溯，最终会回到源节点。对吗？</p><p id="5c13" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">比如说，我想从源节点‘u’找到最短路径‘w’。让我们看看，谁是w的父母。是y。y的父代是‘v’，然后v的父代是‘u’。所以，最短路径是u，v，y，w。</p><p id="ef49" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">检查图片，看看你是否认为这是最短的路径。</p><p id="de8a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以从上面定义的函数中找到每个节点的父节点。</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="9f06" class="ob ms jj nx b gy oc od l oe of">traversed, visited, level, parent = Breadth_first_search(adj)</span></pre><p id="6cf9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是查找最短路径的代码</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="2759" class="ob ms jj nx b gy oc od l oe of">v = "w"<br/>path = []<br/>while v is not None:<br/>    path.append(v)<br/>    v = parent[v]<br/>path.reverse()<br/>print(path)</span></pre><p id="c3cb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">输出:</p><pre class="np nq nr ns gt nw nx ny nz aw oa bi"><span id="9d53" class="ob ms jj nx b gy oc od l oe of">['u', 'v', 'y', 'w']</span></pre><h1 id="d046" class="mr ms jj bd mt mu mv mw mx my mz na nb ky nc kz nd lb ne lc nf le ng lf nh ni bi translated">时间复杂度</h1><p id="9705" class="pw-post-body-paragraph lh li jj lj b lk nj kt lm ln nk kw lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">我们这里只有两个元素。<strong class="lj jt">顶点和边。</strong></p><p id="37b7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，小心。我们只访问每个顶点一次。在for循环中，我们忽略已经访问过的顶点。假设V是顶点的集合。</p><p id="f859" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在这里使用了一个无向图。对于无向图，我们可以双向访问。我们可以从“u”到“v ”,也可以从“v”到“u”。在上面的邻接表' adj '中，你可以看到一个节点可以出现不止一次。我们最多会遍历一条边两次。设E是边的集合，在最坏的情况下，它将穿过边2E次。Som最坏情况下的总时间V+2E。</p><p id="604c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">时间复杂度可以表示为O(V+E ),因为系数包含在O中。</p><h1 id="7dfe" class="mr ms jj bd mt mu mv mw mx my mz na nb ky nc kz nd lb ne lc nf le ng lf nh ni bi translated">结论</h1><p id="8d19" class="pw-post-body-paragraph lh li jj lj b lk nj kt lm ln nk kw lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">我试图解释，width _ first _ search算法如何使用视觉效果工作，用Python开发了该算法，如何使用width _ first _ search算法找到最短路径，以及该算法的时间复杂度。我希望你现在清楚了。</p><p id="ee4c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">欢迎在推特上关注我，喜欢我的T2脸书页面。</p><h1 id="91e1" class="mr ms jj bd mt mu mv mw mx my mz na nb ky nc kz nd lb ne lc nf le ng lf nh ni bi translated">更多阅读:</h1><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/clear-understanding-of-depth-first-search-algorithm-and-its-python-implementation-graph-algorithm-3e87d8f1a9ea"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jt gy z fp ol fr fs om fu fw js bi translated">清晰理解深度优先搜索算法及其Python实现:图算法</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">借助清晰的视觉效果进行学习。还要学习人们在深度优先搜索算法中常犯的一个错误</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ja og"/></div></div></a></div><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/an-ultimate-cheat-sheet-for-numpy-bb1112b0488f"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jt gy z fp ol fr fs om fu fw js bi translated">Numpy的终极备忘单</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">对学习也有好处</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ja og"/></div></div></a></div><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/an-ultimate-cheat-sheet-for-data-visualization-in-pandas-4010e1b16b5c"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jt gy z fp ol fr fs om fu fw js bi translated">熊猫数据可视化的终极备忘单</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">熊猫的所有基本视觉类型和一些非常高级的视觉…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ja og"/></div></div></a></div><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/a-complete-anomaly-detection-algorithm-from-scratch-in-python-step-by-step-guide-e1daf870336e"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jt gy z fp ol fr fs om fu fw js bi translated">Python中从头开始的完整异常检测算法:分步指南</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">基于概率的异常检测算法</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ox l or os ot op ou ja og"/></div></div></a></div><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/great-quality-free-courses-to-learn-machine-learning-and-deep-learning-1029048fd0fc"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jt gy z fp ol fr fs om fu fw js bi translated">学习机器学习和深度学习的优质免费课程</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">顶级大学高质量免费课程的链接</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oy l or os ot op ou ja og"/></div></div></a></div><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/efficient-python-programming-with-lambda-map-filter-and-sorted-cfdf536afc36"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jt gy z fp ol fr fs om fu fw js bi translated">使用Lambda、Map、Filter和Sorted进行高效的Python编程</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">使用数字、字符串和字典列表的快乐编程</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oz l or os ot op ou ja og"/></div></div></a></div><div class="is it gp gr iu og"><a rel="noopener follow" target="_blank" href="/a-complete-guide-to-confidence-interval-and-examples-in-python-ff417c5cb593"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jt gy z fp ol fr fs om fu fw js bi translated">置信区间的完整指南，以及Python中的示例</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">对统计学中一个非常流行的参数——置信区间及其计算的深入理解</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="pa l or os ot op ou ja og"/></div></div></a></div></div></div>    
</body>
</html>