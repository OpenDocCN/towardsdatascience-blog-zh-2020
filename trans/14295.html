<html>
<head>
<title>Ultimate Pandas Guide: Time Series Window Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">终极熊猫指南:时间序列窗口函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ultimate-pandas-guide-time-series-window-functions-a5362b782f3e?source=collection_archive---------19-----------------------#2020-10-02">https://towardsdatascience.com/ultimate-pandas-guide-time-series-window-functions-a5362b782f3e?source=collection_archive---------19-----------------------#2020-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/84b0d7580a976ac5cacd79f3bc97fef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*ymm8kHrmDvTgaQmYPoiabg.png"/></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">劳拉·伍德伯里摄于<a class="ae jc" href="https://www.pexels.com/photo/panda-bear-on-green-grass-3608263/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a></p></figure><div class=""/><div class=""><h2 id="3f00" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">掌握时间序列分析的“移位”、“滚动”和“扩展”</h2></div><p id="903f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的<a class="ae jc" rel="noopener" target="_blank" href="/ultimate-pandas-guide-window-functions-f527f64fd550">上一篇文章</a>中，我演示了如何基于列值在Pandas中运行窗口函数。</p><p id="c073" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法在我们想要知道关于单个记录<strong class="kw jg"> <em class="lq">和它们所属的</em> </strong>组的信息时非常有用。</p><p id="165e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我们有客户级别的交易数据，像这样的方法可以为我们提供关于每笔交易的信息，以及交易发生当月的总销售额:</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lr"><img src="../Images/c2858689943e72918c83f0581d1353c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yv3PA4qDO-RgGy3qM8DGSA.png"/></div></div></figure><p id="e680" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将介绍另一种类型的窗口函数——我们根据行的位置而不是分类列的值来执行计算。</p><h1 id="e1d0" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">关于数据的注释</h1><p id="db7e" class="pw-post-body-paragraph ku kv jf kw b kx ms kg kz la mt kj lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">对于我下面的例子，我将使用来自Kaggle上的<a class="ae jc" href="https://www.kaggle.com/c/google-cloud-ncaa-march-madness-2020-division-1-mens-tournament" rel="noopener ugc nofollow" target="_blank"> NCAA大联盟比赛</a>的一些游戏级别的篮球数据。</p><p id="4b90" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你不喜欢篮球，不要害怕。</p><p id="8ad3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个快速数据字典，告诉你所有你需要知道的变量:</p><ol class=""><li id="c1d8" class="mx my jf kw b kx ky la lb ld mz lh na ll nb lp nc nd ne nf bi translated"><strong class="kw jg"> DayNum: </strong>我们对时间的度量。它计算游戏进行到赛季的第几天。</li><li id="96c2" class="mx my jf kw b kx ng la nh ld ni lh nj ll nk lp nc nd ne nf bi translated">游戏发生的年份。</li><li id="24d6" class="mx my jf kw b kx ng la nh ld ni lh nj ll nk lp nc nd ne nf bi translated"><strong class="kw jg"> Team1/Team2: </strong>参赛队伍的id。</li><li id="057a" class="mx my jf kw b kx ng la nh ld ni lh nj ll nk lp nc nd ne nf bi translated"><strong class="kw jg">效率:</strong>衡量团队1在游戏中的表现。</li><li id="6417" class="mx my jf kw b kx ng la nh ld ni lh nj ll nk lp nc nd ne nf bi translated"><strong class="kw jg">结果:</strong>团队1是否赢得比赛的标志(1表示赢，0表示输)。</li></ol><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nl"><img src="../Images/df0d6dd68577c143fc9068c2f71bab15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pe_DJkSBpnto8nXiZHaY2w.png"/></div></div></figure><p id="d4b9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，让我们假设我们的目标是预测谁赢得了每场比赛。我们不会在这里做任何机器学习，但这将有助于激发用例。</p><h1 id="af42" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">创建“移位”列</h1><p id="cf65" class="pw-post-body-paragraph ku kv jf kw b kx ms kg kz la mt kj lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">让我们从做一个简单的“转移”开始。</p><p id="c18f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个方法确实像它听起来那样。它将一列中的值向前或向后移动。</p><p id="0f06" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面我们将游戏效率提高1:</p><pre class="ls lt lu lv gt nm nn no np aw nq bi"><span id="09d4" class="nr mb jf nn b gy ns nt l nu nv">game_data[‘prior_game_outcome’] = game_data[‘Outcome’].shift(1)</span></pre><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nw"><img src="../Images/38e4f10ba9522fb5907806da10f5a898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FSy1YyFSwYCkricQA8mbw.png"/></div></div></figure><p id="0f57" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，对于每场比赛，我们都知道团队1在前一场比赛中表现如何。也许这能帮助我们预测结果。</p><p id="99eb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们可以传递正整数或负整数来向前或向后移动:</p><pre class="ls lt lu lv gt nm nn no np aw nq bi"><span id="6d9d" class="nr mb jf nn b gy ns nt l nu nv">game_data['NextEfficiency'] = game_data['GameEfficiency'].shift(-1)</span></pre><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nx"><img src="../Images/e044eeb6949276da79cd4be77c3640be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9W9cE31VT8uwnKEAU65nHA.png"/></div></div></figure><p id="a7a0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要记住，当我们对第一行进行正移位时，我们会得到一个空值，因为前一行中没有可用的数据。我们可以通过设置“fill_value”参数用我们选择的不同值替换空值来解决这个问题。</p><h1 id="ce84" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">在滚动窗口上执行聚合</h1><p id="35d9" class="pw-post-body-paragraph ku kv jf kw b kx ms kg kz la mt kj lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">虽然shift方法很有用，但它不允许我们对之前或未来的行执行任何功能。</p><p id="12bc" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我们可能想要找出团队1在前三场比赛中的平均效率。</p><p id="a4d1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们可以利用滚动方法的地方。</p><p id="d785" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本语法非常简单——我们只需要传递我们想要查看的先前行数，然后执行聚合:</p><pre class="ls lt lu lv gt nm nn no np aw nq bi"><span id="2cb4" class="nr mb jf nn b gy ns nt l nu nv">game_data[‘AvgEfficiency’] = game_data[‘GameEfficiency’].rolling(3).mean()</span></pre><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ny"><img src="../Images/ba1297280b8f40ab6ece33ba0c0ac604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEUcEL5NBW3VTjacvKwWAA.png"/></div></div></figure><p id="9a77" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，这里有两个技术步骤:“rolling”方法创建一个滚动对象，然后“mean”方法返回新列。</p><p id="0162" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可能想在这里再做一次调整。默认情况下，每个记录都包含在自己的窗口平均值中。如果我们想预测每场比赛，这是不好的，因为这意味着我们有关于结果的信息编码在平均值中。</p><p id="4b6d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们可以添加一个移位函数，以便包含前3行的数据(而不是当前行和前2行):</p><pre class="ls lt lu lv gt nm nn no np aw nq bi"><span id="777f" class="nr mb jf nn b gy ns nt l nu nv">game_data[‘AvgEfficiency’] = game_data[‘GameEfficiency’].shift(1).rolling(3).mean()</span></pre><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nz"><img src="../Images/b468c959d43dd27147eddb145ef4498d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eg6RxkUBEqZCyA0kDszKpg.png"/></div></div></figure><h1 id="ae3f" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">在扩展窗口上执行聚合</h1><p id="0364" class="pw-post-body-paragraph ku kv jf kw b kx ms kg kz la mt kj lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">扩展方法与滚动方法非常相似，只是它会根据给定的数据创建尽可能大的窗口。</p><p id="562b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个例子:</p><pre class="ls lt lu lv gt nm nn no np aw nq bi"><span id="038b" class="nr mb jf nn b gy ns nt l nu nv">game_data[‘AvgEfficiency’] = game_data[‘GameEfficiency’].shift(1).expanding().mean()</span></pre><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oa"><img src="../Images/2775f67172a84e56aa7db4cc64193040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXPitjkTNyZOdu6PwTVepQ.png"/></div></div></figure><p id="e8ac" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，倒数第二行中的AvgEfficiency值与我们运行上面的滚动方法(12.02)时相同，但最后几行不同(2.41对13.46)。</p><p id="baae" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为当我们在倒数第二行时，我们只有3个先前的记录可用，但是当我们到达最后一行时，我们有4个先前的记录。同样，扩展方法使用尽可能多的数据。</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ob"><img src="../Images/b646be79bcb6d042ece9247937e25865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qy7Zy3VngHySuOWn3gk3OQ.png"/></div></div></figure><p id="bdcd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，如果我们希望确保扩展窗口至少有一定数量的记录，以便应用聚合，我们可以使用“min_periods”参数:</p><pre class="ls lt lu lv gt nm nn no np aw nq bi"><span id="18bb" class="nr mb jf nn b gy ns nt l nu nv">game_data[‘AvgEfficiency’] = game_data[‘GameEfficiency’].shift(1) .expanding(min_periods = 4).mean()</span></pre><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oc"><img src="../Images/d105874d8d617f302a99c5be3af48315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zavt84jm62Wy0oeoj8j78g.png"/></div></div></figure><h1 id="52ef" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">将所有这些放在一起:一个高级用例</h1><p id="7a72" class="pw-post-body-paragraph ku kv jf kw b kx ms kg kz la mt kj lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">我们从区分基于列的窗口和基于位置的窗口开始这篇文章。</p><p id="eb7d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的最终用例利用了这两者。</p><p id="232c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上所有工作的问题是:我们的数据集中实际上有多个球队和赛季，所以我们在分类数据的边缘遇到了问题:</p><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi od"><img src="../Images/69fa65e91e421640f70a0ca1ab024be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B21EiBoqr4ddRg46B8wqzg.png"/></div></div></figure><p id="6b83" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了解决这个问题，我们需要将我们的数据分成团队/赛季组<strong class="kw jg"> <em class="lq">和</em> </strong>执行扩展窗口聚合:</p><pre class="ls lt lu lv gt nm nn no np aw nq bi"><span id="0da3" class="nr mb jf nn b gy ns nt l nu nv">game_data[‘AvgEfficiency’] = game_data.groupby([‘Season’, ‘Team1’])[[‘GameEfficiency’]].transform(lambda x: x.shift(1).expanding().mean())</span></pre><figure class="ls lt lu lv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oe"><img src="../Images/53ce4e139cba28c5df3378012a1146cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxqO8sJHX6D9ZEzsAynlaQ.png"/></div></div></figure><p id="4b81" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们的扩展平均计算开始为每个队的时间表新鲜！</p><p id="f6bd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码中有很多内容，但我是这样想的:</p><ol class=""><li id="11c0" class="mx my jf kw b kx ky la lb ld mz lh na ll nb lp nc nd ne nf bi translated">首先，我们将数据分成季节组和团队组1</li><li id="d24c" class="mx my jf kw b kx ng la nh ld ni lh nj ll nk lp nc nd ne nf bi translated">然后，我们将一个定制的匿名函数(<a class="ae jc" href="https://www.w3schools.com/python/python_lambda.asp" rel="noopener ugc nofollow" target="_blank">λ</a>)应用到每一组，该函数会移动数据并计算一个扩展平均值</li><li id="165b" class="mx my jf kw b kx ng la nh ld ni lh nj ll nk lp nc nd ne nf bi translated">最后，我们将这些值返回到原始索引</li></ol><h1 id="be1c" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">结束语</h1><p id="38f7" class="pw-post-body-paragraph ku kv jf kw b kx ms kg kz la mt kj lc ld mu lf lg lh mv lj lk ll mw ln lo lp im bi translated">在这篇文章中，我们浏览了熊猫的时间序列窗口函数。其中一些方法的语法可能有点复杂，但是当你把它分解成更小的步骤时，一切都会变得更加清晰。花些时间尝试每种方法，直到你掌握了窍门，这也没有坏处。编码快乐！</p><figure class="ls lt lu lv gt iv"><div class="bz fp l di"><div class="of og l"/></div></figure></div></div>    
</body>
</html>