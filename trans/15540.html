<html>
<head>
<title>Spark vs Pandas, part 3 — Scala vs Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark vs Pandas，第3部分——Scala vs Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/spark-vs-pandas-part-3-scala-vs-python-7b267b130158?source=collection_archive---------30-----------------------#2020-10-26">https://towardsdatascience.com/spark-vs-pandas-part-3-scala-vs-python-7b267b130158?source=collection_archive---------30-----------------------#2020-10-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1ae1" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">为什么编程语言很重要</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c5b7c2736ca7d8bf85b986f34a74b4ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a_DljbPIhy4TJbUU"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">蒂莫西·戴克斯在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="4c0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在“熊猫vs Spark”系列的第三部分中，我们将更仔细地看看编程语言以及选择一种语言的含义。</p><p id="625d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最初我想写一篇文章来公平地比较熊猫和火花，但它继续增长，直到我决定把它分开。这是小编的第二部。</p><ul class=""><li id="e10a" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/spark-vs-pandas-part-1-pandas-10d768b979f5">星火大战熊猫，第一部——熊猫</a></li><li id="c3ab" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/spark-vs-pandas-part-2-spark-c57f8ea3a781">星火大战熊猫，第二部——星火</a></li><li id="074a" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">Spark vs Pandas，第3部分—编程语言</li><li id="30e4" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">星火大战熊猫，第四部分——枪战与推荐</li></ul><h2 id="0762" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">期待什么</h2><p id="4b0e" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">本系列的第三部分将关注编程语言Scala和Python。Spark本身是用Scala编写的，绑定了Python，而Pandas只适用于Python。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="6467" class="np ml iu bd mm nq nr ns mp nt nu nv ms ka nw kb mv kd nx ke my kg ny kh nb nz bi translated">为什么编程语言很重要</h1><p id="6433" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">当然，编程语言起着重要的作用，尽管它们的相关性经常被误解。在简历中加入合适的编程语言可能最终会成为获得一份特定工作或项目的决定性因素之一。这是编程语言的相关性可能被误解的一个很好的例子，尤其是在数据科学的背景下。</p><p id="57f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不要误解我的意思，成为一个给定编程语言的专家要比花几周时间编写代码花费更多的时间。你不仅需要习惯语法，还需要习惯语言特有的习惯用法。这真的就像学习一门外国自然语言，需要的不仅仅是知道单词和语法(这本身已经是一项巨大的任务)。</p><p id="135e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，在某些领域，比如数据科学，方法学至少和了解特定的编程语言一样重要。我更愿意雇佣一个在使用Python的R for ML项目中有深厚知识的机器学习专家，而不是一个没有数据科学知识的Python专家，我打赌你们大多数人都会同意。因此，从专家的角度来看，编程语言在你的简历中并不重要(至少不应该如此——我知道它在现实中是不同的)，只要你知道在引擎盖下发生了什么，并且理解处理问题的科学方法。</p><p id="6ceb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是从一个<em class="oa">项目的</em>角度来看，事情看起来完全不同:当建立一个更大的项目并开始创建实际的代码时，你最终需要考虑你<em class="oa">最好</em>想要使用哪种编程语言。而且这个决定有很多后果，你应该清楚。我将在本文中讨论其中的许多，重点关注Scala和Python，它们是Spark和Pandas的自然编程语言。</p><h1 id="8bd8" class="np ml iu bd mm nq ob ns mp nt oc nv ms ka od kb mv kd oe ke my kg of kh nb nz bi translated">Python vs Scala</h1><p id="0497" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">在比较Spark和Pandas时，我们还应该包括每个框架所支持的编程语言的比较。虽然Pandas是“只支持Python”的，但是你可以将Spark与Scala、Java、Python和R一起使用，并且相应的社区正在开发更多的绑定。</p><p id="6aa9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为选择一种编程语言将会有一些严重的直接和间接的影响，我想指出Python和Scala之间的一些基本差异。更详细的讨论可能会形成一篇独立的文章。我主要选择了这个比较，因为<a class="ae kz" rel="noopener" target="_blank" href="/stop-using-pandas-and-start-using-spark-with-scala-f7364077c2e0">我在开头提到的原始文章</a>也建议人们应该开始使用Scala(而不是Python ),而我再次提出了一个更有区别的观点。</p><h2 id="5c06" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">类型系统</h2><p id="95d5" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">让我们先来看看类型系统:两种语言都提供了一些简单的内置类型，比如整数、浮点数和字符串。Scala中的基本类型也提供了一些特定的大小，比如16位整数的<code class="fe og oh oi oj b">Short</code>，64位浮点数的<code class="fe og oh oi oj b">Double</code>。</p><p id="743e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">两种语言都提供了具有继承的类，尽管许多细节确实不同。</p><p id="8946" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Scala和Python中的类型系统有两个主要区别:</p><ul class=""><li id="d745" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">虽然Scala是一种强类型语言(即每个变量和参数都有固定的类型，如果试图使用错误的类型，Scala会立即抛出错误)，但Python是动态类型的(即单个变量或参数在技术上可以接受任何数据类型——尽管代码可能会采用特定的类型，因此在执行过程中会失败)。</li><li id="e87b" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">由于Python的动态类型特性，某个操作的<em class="oa">合适类型通常只由它实现的操作决定。使用正确的基类或继承通常并不重要，重要的只是可用的方法。这种范式被称为“<a class="ae kz" href="https://en.wikipedia.org/wiki/Duck_typing" rel="noopener ugc nofollow" target="_blank">鸭子分型</a></em></li></ul><p id="4c76" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些差异有着巨大的影响，我们将在后面看到。</p><h2 id="8cba" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">功能语言方面</h2><p id="73e1" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">虽然Python已经从一种简单的脚本语言发展成为一种功能齐全的编程语言，但是Scala作为一个研究项目，从一开始就把函数式编程语言(比如Haskell)的一些方面与面向对象语言(比如Java)的一些方面结合起来——这种结合是否成功，甚至是否可取，还存在一些争议。</p><p id="410f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对我来说，术语<em class="oa">函数式编程</em>指的是某种范式，即<em class="oa">函数不应该有副作用</em>(即它们不改变某些全局状态，并尊重<em class="oa">不变性</em>)。<em class="oa">另一方面，面向对象编程</em>正好相反，其中每个方法都被视为与对象<em class="oa">进行通信的某种方式，而对象<em class="oa">又会改变其状态</em>。将范式本身与特定的语言特性分开是很重要的——几乎任何语言都可以实现纯函数式程序，但只有一些语言会提供支持概念，而其他语言会变得复杂。</em></p><p id="beba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python和Scala都支持一些函数概念，具体来说函数可以作为值和匿名函数传递(<a class="ae kz" href="https://en.wikipedia.org/wiki/Anonymous_function" rel="noopener ugc nofollow" target="_blank"> lambda函数</a>)。Scala还提供了一个丰富的集合库，它很好地支持了函数式方法，比如不变性，而Pythons在这一领域最好的贡献是列表理解。</p><h2 id="ce6c" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">执行模型</h2><p id="6430" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">Python是一种<em class="oa">解释的</em>语言，本质上意味着Python可以立即执行任何代码，只要它是有效的Python语法。不需要“构建”或“编译”步骤。这使得Python成为交互式工作的绝佳选择，因为Python可以在您键入代码时立即执行。</p><p id="1086" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，Scala是一种<em class="oa">编译的</em>语言，这意味着<em class="oa"> Scala编译器</em>首先需要将Scala代码转换成所谓的用于JVM的<a class="ae kz" href="https://en.wikipedia.org/wiki/Java_bytecode" rel="noopener ugc nofollow" target="_blank"> Java字节码</a>(在执行过程中，它又被翻译成本机代码)。这种三步法(编写、编译、执行)通常会使代码实验更加困难，因为周转时间更长。幸运的是，Scala还提供了一个交互式shell，它能够编译并立即执行你输入的代码。但是一般来说，Scala是用来编译的。</p><h2 id="d40c" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">学习曲线</h2><p id="c34b" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">总的来说，Python非常容易学习——它是专门设计来强调可读性的。Pythons的动态类型系统非常适合从未接触过编程语言的初学者。Python非常宽容，它的语法很容易理解。</p><p id="864f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，Scala的学习曲线要陡峭得多，而且——与Python相反——对于新手来说，代码很快就会变得难以阅读。尽管使用Spark首先只需要一小部分，但当你开始深入Spark并试图解决更复杂的问题时，你最终需要理解越来越多的Scala细节。</p><p id="f250" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我发现大多数Java程序员在开始时在习惯Scala的功能方面有很大的问题，部分原因是因为非常简洁的语法。我总觉得Scala中的信息密度(即每个字母程序代码编码多少逻辑)比Java中的高得多，这种密度在开始时对大多数人的大脑来说是一种挑战，因为他们习惯了Java中更多的锅炉板代码，这大大降低了信息密度。</p><h2 id="af2f" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">代码的健壮性</h2><p id="692f" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">与静态类型语言相比，动态类型语言有一个巨大的缺点:使用错误的类型只能在运行时检测到，而不能在更早的时候(编译时)检测到。这意味着，如果在一些非常罕见的情况下用错误的数据类型调用一个函数，您可能只会在为时已晚的时候(在生产中)才注意到这一点。</p><p id="2d49" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相比之下，静态类型和编译语言将阻止您将损坏的代码发布到产品中。它会直接指向错误类型的用法，你必须在编译器完成它的工作之前修复它。</p><p id="16f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于这种差异，我发现编写健壮的、生产就绪的Python代码比编写健壮的Scala代码要困难得多。当编写一个完整的<em class="oa">框架</em>或<em class="oa">库</em>供其他应用程序使用时，这就更加困难了。应用程序可能会将错误的数据类型传递给函数，但这些类型在某些情况下可能“足够好”(因为它们实现了所有必需的方法)，但在其他情况下可能会失败(因为缺少其他方法或它们的签名已被更改)。</p><p id="6e75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最重要的是，用Python进行重构可能非常困难，因为使用不同类型或重命名方法的后果并不总是能被您的IDE正确检测到。</p><h2 id="d544" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">生态系统</h2><p id="5044" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">如今，一门编程语言的成功不主要依赖于它的语法或概念，而是依赖于它的生态系统。这包括许多方面，如有用的库的可用性、优秀编辑器的选择、相关操作系统的支持等等。</p><p id="dfff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">具体来说，当今的一系列库对使用特定编程语言的主要领域有着巨大的影响。最突出的例子是Python，其中实现了大多数最新的机器学习算法——这是Scala远远落后的领域，尽管像<a class="ae kz" href="http://www.scalanlp.org/" rel="noopener ugc nofollow" target="_blank"> ScalaNLP </a>这样的项目试图改善这种情况。</p><p id="8ae0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然Scalas boost在过去几年中可能可以追溯到Apache Spark的成功，但它也用于许多需要高并发性的网络服务项目，Scalas函数式编程特性可以为实现健壮的多线程代码提供支持。</p><h2 id="89d0" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">结论</h2><p id="195a" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">Scala和Python都有自己的位置。特别是在数据处理领域，Python非常适合科学工作流，在探索阶段进行许多小而快速的代码实验，以获得新的见解。</p><p id="0ee5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Scala的“编写-编译-执行”工作流其静态类型系统更适合工程工作流，其中处理特定问题的知识已经存在，因此不再进行实验。</p><p id="d459" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如我在“代码的健壮性”中指出的，我更喜欢使用强类型语言来编写产品代码，除非是在一些简单的情况下，在这些情况下应用程序几乎是微不足道的。</p><h1 id="3923" class="np ml iu bd mm nq ob ns mp nt oc nv ms ka od kb mv kd oe ke my kg of kh nb nz bi translated">生态系统的价值</h1><p id="c2b3" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">在Scala和Python的比较之后，让我们回到Pandas和Spark。有一个方面与编程语言高度相关，那就是生态系统。我在上面已经提到了这个方面，但是让我们更关注可以与Pandas和Spark一起使用的库。</p><h2 id="8b2f" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">Python生态系统</h2><p id="0500" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">由于Pandas的核心是建立在NumPy数组之上的，它自然地与一个由许多数字和统计库组成的非常丰富的生态系统集成得非常好。仅举几个重要的例子:</p><ul class=""><li id="3d3a" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><a class="ae kz" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> SciKit学习</a></li><li id="a5a4" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="https://www.statsmodels.org/" rel="noopener ugc nofollow" target="_blank">统计模型</a></li><li id="ef87" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank">张量流</a></li><li id="a2c4" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a></li></ul><p id="a1d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，我们还有可爱的<a class="ae kz" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>用于互动工作，作为实验驱动的探索阶段的一部分。</p><h2 id="439b" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">Scala生态系统</h2><p id="faa1" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">另一方面，火花生活在一个完全不同的世界。作为JVM世界的一员，你可以使用所有种类的Java库——但是大多数Java库的焦点是网络、web服务和数据库。数值算法不是Java的核心领域。</p><p id="d8db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，Spark的生态系统看起来非常不同。最重要的是，有许多连接器可以将Spark用于各种数据库，比如通过JDBC连接器的关系数据库、HBase、MongoDB、Cassandra等等。</p><p id="5051" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了连接器，Spark已经实现了<a class="ae kz" href="https://spark.apache.org/docs/latest/ml-guide.html" rel="noopener ugc nofollow" target="_blank">最重要的机器学习算法</a>，如回归、决策树等。然后我们还有<a class="ae kz" href="https://github.com/scalanlp/breeze/" rel="noopener ugc nofollow" target="_blank"> Breeze </a>和<a class="ae kz" href="http://www.scalanlp.org/" rel="noopener ugc nofollow" target="_blank"> ScalaNLP </a>用于较低级别的数值算法(Spark也不能直接扩展这些算法以在不同的机器上并行工作)。但是当您将这些库与相应的Python库的可能性进行比较时，您会很快发现这些库的范围要小得多。</p><p id="6bb9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，通过使用Zeppelin或者在Jupyter中使用py Spark(Spark的Python绑定),我们也可以在笔记本环境中使用Spark。</p><h2 id="8bca" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">结论</h2><p id="123a" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">我们看到熊猫和星火生态系统的巨大差异。虽然Pandas与各种数字包有着紧密的联系，但Spark在统一连接各种数据源方面表现出色。</p><h1 id="c6b9" class="np ml iu bd mm nq ob ns mp nt oc nv ms ka od kb mv kd oe ke my kg of kh nb nz bi translated">Python vs Scala for Spark</h1><p id="973f" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">因为Spark可以与Scala和Python一起使用，所以有必要更深入地研究选择合适的编程语言来使用Spark。</p><p id="94e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我已经指出，Python有一个更大的数字库集合，通常用于数据科学项目。虽然这已经是使用Python和PySpark而不是Scala和Spark的有力论据，但另一个有力的论据是学习Python的容易程度，与非平凡的Scala程序所需的陡峭学习曲线形成对比。更糟糕的是，Scala代码不仅难以编写，而且难以阅读和理解。这使得Scala成为协作项目的一种困难语言，在协作项目中，同事甚至非程序员也需要或想要理解应用程序的逻辑细节。在数据科学环境中，这种情况很常见。</p><h2 id="de49" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">用于数据科学的Python</h2><p id="81f5" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">因为有许多与数据科学相关的库可用，也因为Python代码的易读性，所以我总是推荐使用PySpark进行真正的数据科学。这也非常符合许多数据科学家的概况，他们有很强的数学背景，但往往不是编程专家(他们的工作重点在其他地方)。</p><p id="ed21" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过使用PySpark，数据科学家可以处理不再适合本地机器内存的巨大数据集，同时(在一定程度上)他们仍然可以访问所有相关的Python库——只要他们可以缩减采样或聚合数据，以便这些工具和库再次变得可行。</p><h2 id="5d05" class="mk ml iu bd mm mn mo dn mp mq mr dp ms lj mt mu mv ln mw mx my lr mz na nb nc bi translated">数据工程的Scala</h2><p id="5178" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">对于数据工程来说，情况有所不同。对于这些类型的任务，我强烈推荐使用Spark和Scala。首先，数据工程师应该有很强的技术背景，这样使用Scala才是可行的。接下来可能需要一些Spark中没有的自定义转换。但是Spark是非常可扩展的，在这种情况下，使用Scala作为原生Spark编程语言真的很划算。</p><p id="52ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用Scala代替Python不仅能提供更好的性能，还能让开发人员以比使用Python更多的方式扩展Spark。使用Scala，你甚至可以访问Spark的内部开发者API(只要它们不是<code class="fe og oh oi oj b">private</code>)，而Python只能访问Spark的公共终端用户API。</p><p id="1d72" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，我坚信在数据工程项目中,“产品质量代码”的所有方面都比在笔记本环境中执行的探索性数据分析任务重要得多。这正是像Scala这样的静态类型和编译语言带来巨大好处的地方。</p></div><div class="ab cl ni nj hy nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="in io ip iq ir"><h1 id="dc56" class="np ml iu bd mm nq nr ns mp nt nu nv ms ka nw kb mv kd nx ke my kg ny kh nb nz bi translated">结论</h1><p id="0db9" class="pw-post-body-paragraph la lb iu lc b ld nd jv lf lg ne jy li lj nf ll lm ln ng lp lq lr nh lt lu lv in bi translated">选择一种编程语言并不容易。你必须考虑你的需求，包括功能性的和非功能性的。虽然Python非常适合数据科学，但我更喜欢使用Scala和Spark进行数据工程。</p><p id="1999" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下一节也是最后一节将总结所有的发现，并给出更多何时使用什么的建议。</p></div></div>    
</body>
</html>