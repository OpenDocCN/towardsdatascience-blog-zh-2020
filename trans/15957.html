<html>
<head>
<title>Practical Guide to Entity Resolution — part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体解析实用指南—第3部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practical-guide-to-entity-resolution-part-3-1b2c262f50a7?source=collection_archive---------12-----------------------#2020-11-03">https://towardsdatascience.com/practical-guide-to-entity-resolution-part-3-1b2c262f50a7?source=collection_archive---------12-----------------------#2020-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fc25" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">特征化和阻塞密钥生成</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/1173e2a9dbae68588f6531060777a69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BVBq7eNCvhBJnc_i"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@honeyyanibel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Honey Yanibel Minaya Cruz </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e783" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="lt">这是关于实体解析的小型系列的第3部分。查看</em> <a class="ae kw" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-1-f7893402ea7e" rel="noopener"> <em class="lt">第一部分</em> </a> <em class="lt">，</em> <a class="ae kw" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-2-ab6e42572405" rel="noopener"> <em class="lt">第二部分</em> </a> <em class="lt">如果你错过了</em></p><p id="d3c9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">什么是特征化和阻塞，为什么它很重要？</strong></p><p id="9014" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在ER的上下文中，特征化意味着将现有的列转换为派生的特征，这些派生的特征可以通知不同的记录是否引用同一事物。分块意味着选择一个目标特征子集作为自连接键，以有效地创建潜在的匹配候选对。在我们的讨论中将这两个步骤分组的原因是块密钥通常是从特征中派生出来的。</p><p id="8aaa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">良好的特征化能够实现高效的阻塞以及下游良好的匹配精度，因此它是ER过程的关键部分。这也是定义最少的一步，在这个过程中可以注入大量的创造力。</p><p id="2a3d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">良好的分块可以极大地提高ER过程的效率，并且可以扩展到许多输入源和大型数据集。正如我们在<a class="ae kw" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-1-f7893402ea7e" rel="noopener"> <em class="lt">第一部分</em> </a>中所讨论的，潜在候选对的论域是N与记录数。然而，并不是所有的候选对都值得评估。比如<code class="fe lu lv lw lx b">learning quickbooks 2007</code>和<code class="fe lu lv lw lx b">superstart fun with reading writing</code>显然不是一回事，不应该包含在候选对中。解决这个问题的一种方法是使用更具体的阻塞键，例如产品的确切字符串名称，来创建候选对。这样，只有具有完全相同的标准化名称字符串的产品才会包含在候选对中。然而，这显然限制太多，会错过像<code class="fe lu lv lw lx b">learning quickbooks 2007</code>和<code class="fe lu lv lw lx b">learning qb 2007</code>这样的潜在匹配。好的阻塞键选择对于有效地平衡好的效率和低的假阴性率之间的折衷是至关重要的。</p><p id="a325" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">如何实现特征化和模块化？</strong></p><p id="b96d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">特征化，也许比ER中前面的步骤更重要，取决于源数据的类型和所需的下游比较算法。在这里，我们不会尝试提供一组详尽的可能技术，而是专注于Amazon vs Google产品的示例用例的说明性实现。在规范化的数据集中，我们有4列要处理，它们的特征是<code class="fe lu lv lw lx b">name, description, manufacturer, price</code>。4列中有3列是基于文本的，大部分识别信息都存储在其中。因此，我们将在这里集中大部分的特性化工作。有许多方法来特征化文本数据，但是在高层次上，它们通常归结为</p><ol class=""><li id="c934" class="ly lz iq kz b la lb ld le lg ma lk mb lo mc ls md me mf mg bi translated">标记化——例如<a class="ae kw" href="https://nlp.stanford.edu/IR-book/html/htmledition/tokenization-1.html" rel="noopener ugc nofollow" target="_blank">将句子分解成单词</a></li><li id="5c81" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">令牌标准化——例如<a class="ae kw" href="https://en.wikipedia.org/wiki/Stemming" rel="noopener ugc nofollow" target="_blank">词干</a>或<a class="ae kw" href="https://en.wikipedia.org/wiki/Lemmatisation" rel="noopener ugc nofollow" target="_blank">词汇化</a></li><li id="031e" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">嵌入——例如<a class="ae kw" href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" rel="noopener ugc nofollow" target="_blank"> TF-IDF </a>、<a class="ae kw" href="https://en.wikipedia.org/wiki/Word_embedding" rel="noopener ugc nofollow" target="_blank">单词嵌入</a>、<a class="ae kw" href="https://en.wikipedia.org/wiki/Sentence_embedding" rel="noopener ugc nofollow" target="_blank">句子嵌入</a></li></ol><p id="34e5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于我们的特定示例，我们将使用一个基本的TF-IDF模型，在该模型中，我们对文本进行标记，删除英语停用词，并应用TF-IDF矢量化。我们还将使用Tensorflow的U <a class="ae kw" href="https://tfhub.dev/google/universal-sentence-encoder/4" rel="noopener ugc nofollow" target="_blank">通用语句编码器</a>模型，将名称和描述字符串转换成512维向量。</p><p id="4898" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过将这两个转换应用到<code class="fe lu lv lw lx b">name, description, manufacturer</code>中的文本列，我们最终得到了许多丰富的特性，可以用来评估候选对之间的潜在匹配，以及帮助选择阻塞键。具体来说，TF-IDF向量和句子编码向量在生成良好的块密钥方面非常有用。</p><p id="3267" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">正如我们上面讨论的，一个好的阻塞键是平衡特异性和假阴性率的东西。一个产品的全称是特定的，但也有非常高的假阴性率。我们可以通过在产品名称或描述中选择单个单词来解决这个问题。但是，重要的是要注意，就阻塞的目的而言，有些标记比其他标记更好。例如在<code class="fe lu lv lw lx b">learning quickbooks 2007</code>中，<code class="fe lu lv lw lx b">quickbooks</code>直观上是最好的阻挡键，其次是<code class="fe lu lv lw lx b">2007</code>，再其次是<code class="fe lu lv lw lx b">learning</code>。这是因为<code class="fe lu lv lw lx b">quickbooks</code>是定义产品最有意义的关键词，<code class="fe lu lv lw lx b">2007</code>是特定于产品版本的，而<code class="fe lu lv lw lx b">learning</code>是一个非常通用的描述符。方便的是，这也正是TF-IDF试图系统测量的，并且<code class="fe lu lv lw lx b">learning quickbooks 2007</code>的归一化TF-IDF令牌权重是<code class="fe lu lv lw lx b">quickbooks</code> : 0.7，<code class="fe lu lv lw lx b">2007</code> : 0.51，<code class="fe lu lv lw lx b">learning</code> : 0.5。如您所见，令牌的TF-IDF权重是一个不错的代理指标，可用于区分优先级和选择良好的阻塞密钥。</p><p id="5475" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">类似地，句子编码向量权重也告诉我们潜在向量空间中的哪个维度对句子的意义最显著，并且可以用于选择分块密钥。然而，在句子编码的情况下，具有最高权重的维度不直接映射到单词标记，因此可解释性较低。</p><p id="de3f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">实现上述内容的PySpark代码示例如下</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="cf04" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面的代码利用<code class="fe lu lv lw lx b">pyspark.ml</code>库来</p><ol class=""><li id="a597" class="ly lz iq kz b la lb ld le lg ma lk mb lo mc ls md me mf mg bi translated">将TF-IDF变换应用于<code class="fe lu lv lw lx b">name</code>、<code class="fe lu lv lw lx b">description</code>和<code class="fe lu lv lw lx b">manufacturer</code></li><li id="70c7" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">根据TF-IDF令牌权重挑选出前5个令牌作为阻止密钥</li><li id="3d2d" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">使用通用语句编码器将<code class="fe lu lv lw lx b">name</code>和<code class="fe lu lv lw lx b">descriptions</code>转换为512维向量表示。我们在这里省略了<code class="fe lu lv lw lx b">manufacturer</code>,因为它是稀疏的，并且作为一个英语句子也没有太多的语义意义。请注意，我们实际上并没有从编码中生成块密钥，但是类似于TF-IDF令牌的方法也可以很容易地应用到这里</li><li id="9454" class="ly lz iq kz b la mh ld mi lg mj lk mk lo ml ls md me mf mg bi translated">将top name标记、top description标记和top manufacturer组合成每个记录的一个块键数组。请注意，每条记录可以有一个以上的阻止键。这也是为了减少潜在匹配的假阴性率。</li></ol><p id="ce54" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">应用通用语句编码器的用户定义函数值得快速解包</p><pre class="kh ki kj kk gt mo lx mp mq aw mr bi"><span id="b5ab" class="ms mt iq lx b gy mu mv l mw mx"># magic function to load model only once per executor<br/>MODEL = None<br/>def get_model_magic():<br/>  global MODEL<br/>  if MODEL is None:<br/>      MODEL = hub.load("<a class="ae kw" href="https://tfhub.dev/google/universal-sentence-encoder/4" rel="noopener ugc nofollow" target="_blank">https://tfhub.dev/google/universal-sentence-encoder/4</a>")<br/>  return MODEL</span><span id="ab1d" class="ms mt iq lx b gy my mv l mw mx"><a class="ae kw" href="http://twitter.com/udf" rel="noopener ugc nofollow" target="_blank">@udf</a>(returnType=VectorUDT())<br/>def encode_sentence(x):<br/>  model = get_model_magic()<br/>  emb = model([x]).numpy()[0]<br/>  return Vectors.dense(emb)</span></pre><p id="5cec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这到底是在做什么，为什么有必要？Tensorflow hub提供了一个预训练的模型，可以帮助用户将文本转换为矢量表示。这个模型不是分布式的，这意味着为了利用Spark这样的分布式计算框架，我们必须将它封装在一个用户定义的函数中，并使它在每个执行器节点上都可用。然而，我们不希望每次转换一段文本时都执行昂贵的<code class="fe lu lv lw lx b">load</code>调用。我们只希望每个执行器加载一次，然后在分配给该节点的所有任务中重用。<code class="fe lu lv lw lx b">get_model_magic</code>方法本质上是实现这一点的技巧。</p><p id="c0d0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们已经有了我们的特征和阻塞键，我们准备好处理<a class="ae kw" href="https://yifei-huang.medium.com/practical-guide-to-entity-resolution-part-4-299ac89b9415" rel="noopener">候选对生成和匹配评分</a>。</p></div></div>    
</body>
</html>