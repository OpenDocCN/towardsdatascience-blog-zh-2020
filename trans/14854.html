<html>
<head>
<title>20 Great Pandas Tricks For Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学的20个大熊猫技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/20-great-pandas-tricks-for-data-science-3a6daed71da0?source=collection_archive---------7-----------------------#2020-10-13">https://towardsdatascience.com/20-great-pandas-tricks-for-data-science-3a6daed71da0?source=collection_archive---------7-----------------------#2020-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b92" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你应该每天使用的20个大熊猫技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c7c3a6be79f4d3377cc79dc1720a67f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*saCTpBlAZ5hs4nQSuxCKlw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="d3d1" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="cc0b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi mm translated">除非你是Python数据科学的新手，或者你的路由器上连接了某种设备来阻止所有与熊猫有关的传入数据包，否则你可能听说过熊猫。Pandas是Python数据组织、清理和IPython显示的首选库，在过去10年中，它已经成为读取和处理数据的行业标准。在处理数据方面，Pandas不仅在很大程度上满足并超出了所有人的预期，它还与Numpy紧密相连，并与Numpy合作得非常好——将它进一步整合到Pythonic数据科学包的奇妙生态系统中。</p><p id="5daf" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">虽然Pandas很受欢迎，并且大多数使用Python的科学家都非常频繁地使用它，但它仍然是一个非常深入的库，具有许多特性。这些特性中有很多很容易被忽略，但是它们的价值却不能被夸大。幸运的是，今天我在Pandas library中整理了20个鲜为人知的特性，它们将帮助任何数据科学家掌握这个软件包！</p><blockquote class="na"><p id="fa04" class="nb nc it bd nd ne nf ng nh ni nj ml dk translated"><a class="ae nk" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/20%20Pandas%20tricks.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><h1 id="00c7" class="ky kz it bd la lb lc ld le lf lg lh li jz nl ka lk kc nm kd lm kf nn kg lo lp bi translated">数据帧</h1><p id="e0ff" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">数据框是熊猫图书馆的核心特征。尽管数据框本身就是一个强大的功能，但是如果没有强大的功能和操作，它们最终只是被美化了的字典。幸运的是，Pandas为您提供了这些非常酷的方法来探索您的数据、清理您的数据和调整您的数据。对于以下所有示例，我将使用此数据框:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/abc2832871e6a64527265f6516d828fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sUhBVezPZ7An6ssUlSkKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="fde5" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这些数据是早至1910年、晚至2006年的历史天气数据</p><h2 id="99f4" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.describe()</h2><p id="a067" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Pandas中最被低估的功能之一是一个叫做describe()的简单函数。对数据框使用describe函数会产生一个非常统计的结果，它会告诉您需要单独了解的每一列的值。这是了解给定列中大多数数据的位置的好方法，而不需要考虑平均值。了解了标准偏差、最小-最大值和平均值，也就很容易知道数据中的方差有多大。使用这个函数是一个非常好的方法，可以非常快速地获得每一列的以下所有统计数据:</p><ul class=""><li id="29fa" class="ob oc it ls b lt mv lw mw lz od md oe mh of ml og oh oi oj bi translated">意思是</li><li id="01ac" class="ob oc it ls b lt ok lw ol lz om md on mh oo ml og oh oi oj bi translated">数数</li><li id="71af" class="ob oc it ls b lt ok lw ol lz om md on mh oo ml og oh oi oj bi translated">标准偏差</li><li id="65ae" class="ob oc it ls b lt ok lw ol lz om md on mh oo ml og oh oi oj bi translated">第一个四分位数</li><li id="909b" class="ob oc it ls b lt ok lw ol lz om md on mh oo ml og oh oi oj bi translated">第二个四分位数(中位数)</li><li id="742e" class="ob oc it ls b lt ok lw ol lz om md on mh oo ml og oh oi oj bi translated">第三四分位数</li><li id="2327" class="ob oc it ls b lt ok lw ol lz om md on mh oo ml og oh oi oj bi translated">最小值</li><li id="cf60" class="ob oc it ls b lt ok lw ol lz om md on mh oo ml og oh oi oj bi translated">最大值</li></ul><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="c515" class="np kz it oq b gy ou ov l ow ox">df.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/7d591ba5fc77b52f82aacc047e883ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AwdSSv_aOp8rbCtZpl-W6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="db2f" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.groupby()</h2><p id="e6c5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">groupby()函数是一个很棒的函数，可用于根据分类值或数值的连续等级来重新组织您的观察值。该函数只是将相同或相似的值最接近地放在一起。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="cf29" class="np kz it oq b gy ou ov l ow ox">df.groupby(['Temperature (C)']).mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/3a335aed04852401da329f9ffcb1bc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3njpm5yTdYDZVn6Rq1JeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="5113" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.stack()</h2><p id="66e7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">stack函数可用于返回具有更多最内层的数据框和序列类型。通过旋转数据框来创建新的最内层。第一个参数控制堆叠哪个或哪些层:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="98b6" class="np kz it oq b gy ou ov l ow ox">df.stack([0])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/24892f56f6fce6f693a5077177546338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7guJDLlfZkMNbCC49fY8sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="69aa" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">Stack似乎并没有对这些数据做什么。这种功能只有在桌子主要是可旋转的时候才能感觉到。</p><h2 id="d0f2" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.apply()</h2><p id="5043" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">应用函数用于使用Python函数在整个数据框或系列类型中应用算术或逻辑代码。虽然这当然可以应用于数据框，但我只打算将其应用于系列，因为该数据框包含字符串和日期时间数据类型。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="0a16" class="np kz it oq b gy ou ov l ow ox">df["Temperature (C)"].apply(np.sqrt)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/6db671692c10d95612cd26f6fc33e4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MtiVN8V-UHU9kHwi5gu0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="0186" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.info()</h2><p id="7870" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">info函数可用于数据框，以提供有关数据框的信息，这些信息通常与性能而非统计数据相关。如果您想要检查内存分配或数据框内每个系列的数据类型，这将非常有用。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="ab60" class="np kz it oq b gy ou ov l ow ox">df.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/bbad3066874f7ec96f34c2a85b36c189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*nJRR-eIB76UCzdU2-4ehcA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="0855" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.query()</h2><p id="0362" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Query是一个Pandas函数，允许在整个数据框中应用条件掩膜。query和典型的条件掩码之间的唯一显著区别是，query函数可以接受一个将被解释为条件语句的字符串，而条件掩码将使用布尔值屏蔽数据，然后返回为真的条件。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="0fc2" class="np kz it oq b gy ou ov l ow ox">df.query('Humidity &lt; .89')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/238275b6cc78fb3b24087b740c652224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNHunDxlitMUJFeHfyf1Wg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="9197" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.cumsum()</h2><p id="ddad" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">cumsum函数可用于获取数据框和熊猫系列类型的累积和。这意味着数字将按降序相加，并在此过程中不断相加。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="e1ef" class="np kz it oq b gy ou ov l ow ox">df.cumsum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/7d43c5a99c74d5a51cc96e3a9f10e955.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*t6SP3s7whNV9tXEVRS62-Q.png"/></div></figure><blockquote class="na"><p id="dbba" class="nb nc it bd nd ne pf pg ph pi pj ml dk translated">坏消息。</p></blockquote><p id="c7ad" class="pw-post-body-paragraph lq lr it ls b lt pk ju lv lw pl jx ly lz pm mb mc md pn mf mg mh po mj mk ml im bi translated">不幸的是，内核似乎已经死亡。因为我的Jupyter内核今天感觉特别情绪化，所以我会让她(她是女的)休息一下，而是只在一个系列上运行这个函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/b5a1ecd1474a75c4ce0fd0a54ff240a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*ahL-MNpXK89CJokErThUWg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="abbf" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">条件掩码</h2><p id="e261" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Pandas库里面我最喜欢的特性之一是能够很容易地用条件屏蔽数据帧。虽然有办法用滤镜做到这一点！()方法在我最喜欢的语言中，朱莉娅，这是我真正想念的一件事，我希望能被带入语言中。首先，你需要提出一个条件，在这个例子中，我们将使用低于14级的风速。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="8561" class="np kz it oq b gy ou ov l ow ox">our_mask = df["Wind Speed (km/h)"] &lt; 14</span></pre><p id="63ed" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">接下来，我们将通过简单地设置一些与布尔相等的东西作为索引来应用这个掩码:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="655a" class="np kz it oq b gy ou ov l ow ox">seconddf = df[our_mask]</span></pre><p id="8329" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在我们的数据框不包含大于或等于14:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/01ae8b1db4f8d4278896d73fc89e338c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcDD8VZalJ7u6XbTKduPsA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="33d9" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.melt()</h2><p id="c803" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">熔化与pivot函数相反，pivot函数会将您的数据转换为横向格式。如果你想改变观察结果和特征，这是很有用的。但是，需要注意的是，在某些情况下，如果不提供参数或更改数据框的结构，效果可能不如预期。我正在处理的数据框就是一个很好的例子:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="f32d" class="np kz it oq b gy ou ov l ow ox">df = df.melt()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/e32e2d568bc1bcedafeb2e975396bd46.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*b8YcO_Ew41KjgJpc9usatA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="6ff1" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.explode()</h2><p id="d80a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">你有没有因为某种原因碰到过类似这样的数据？：</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/7a7934515611c32c7fde5a28168549df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SzNGmXCWc02t5Ez4o_S5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="7c1a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">除了与数据框上的A相对应的观测值之外，所有其他值都是具有单个整数的精确观测值。幸运的是，我们可以简单地在数据框上运行explode来纠正这一点。Explode将“分解”数据框内的所有可迭代集合，并将它们放入单独的观测值中。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="47ec" class="np kz it oq b gy ou ov l ow ox">data.explode("B")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/e61eb5f72de2cd3cb16f73bbaeec046f.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*ZBdn0znJe1L8iyktGZ_pjQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="ead0" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.nunique()</h2><p id="52d1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们有一个包含许多类别的数据框架，我们希望找到一个分类问题的解决方案。唯一的问题是，我们不想使用一个容易过度拟合的模型，如果我们有这么少的类别，该模型最终会矫枉过正。这在数据科学家的典型日常生活中是很常见的场景。幸运的是，这个问题的解决方案非常简单——需要对所有唯一值进行计数。更幸运的是，Pandas通过nunique函数让这一切变得异常简单！</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="f6dc" class="np kz it oq b gy ou ov l ow ox">df.nunique()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/dbe8fc0b59a81167fc9ab2b23f835a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*MgrRAL3TLr6UaXRm6i62uw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="c3a7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这将提供数据框中所有要素及其相应唯一值计数的综合列表。</p><h2 id="9d52" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.infer_objects()</h2><p id="23ff" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在处理脏数据时，您可能会遇到的另一件事是最初被认为不是脏数据的类型。使用df.infer_objects()是在数据框内更改这些数据类型的一个很好的潜在节省时间的方法。infer_objects函数根据经验猜测每一列的数据类型，并将整个系列设置为该类型。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="60fb" class="np kz it oq b gy ou ov l ow ox">df.infer_objects()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/49c1974b5dc8d6c1284b26910d6ea1d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YyMP_aNZDkKgMnVS0RSyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="7eb6" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.memory_usage()</h2><p id="e5cc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">内存使用是return most可能已经假定的一个函数。虽然我们使用info()函数大致了解了数据框中的内存使用情况，但memory_usage要全面得多，它将允许我们找出哪些列消耗了大部分内存。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="a21e" class="np kz it oq b gy ou ov l ow ox">df.memory_usage()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/31c3168439d80f36040e95ec36ac6280.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*N_wn1xr5sD9e-ziR0XBLXg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="a4ef" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.select_dtypes()</h2><p id="829a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">select_dtypes函数可用于根据类型从数据框中提取某些列。一个很好的例子就是apply，我们希望将np.sqrt()应用于整个数据框，但是由于数据框中的字符串，我们只能对单个系列执行此操作。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="acd5" class="np kz it oq b gy ou ov l ow ox">df.select_dtypes(float).apply(np.sqrt)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/18851b1a4c5e6b8ec5443b700147453b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGPpbxDWpSgYUCaBq7sg_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="71cf" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">df.iterrows()</h2><p id="68c5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">iterrows()函数是一个简单的生成器类型，它将生成一个新的迭代数组—每列一个。如果您需要将所有行压缩到一个可迭代对象中，这非常有用:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="3f4d" class="np kz it oq b gy ou ov l ow ox">rowlist = df.iterrows()</span></pre><p id="9be1" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在我们可以迭代这个生成器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/a907d6117fcbbb41c5f3ec9bb9d857b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3wNo786aFzR8ckrsurSeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="1b64" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">压型</h2><p id="71c3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">提到熊猫数据分析，就很难不谈到熊猫概况。尽管它需要另一个库，但它无疑是Pythonic数据科学家拥有的最好的工具之一，只需一个函数调用就可以快速浏览数据。你可以在这里查看:</p><div class="pz qa gp gr qb qc"><a href="https://github.com/pandas-profiling/pandas-profiling" rel="noopener  ugc nofollow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd iu gy z fp qh fr fs qi fu fw is bi translated">熊猫简介/熊猫简介</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">文档|松弛|堆栈溢出从pandas数据帧生成配置文件报告。熊猫df.describe()…</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">github.com</p></div></div><div class="ql l"><div class="qm l qn qo qp ql qq ks qc"/></div></div></a></div><p id="1c29" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">为了使用它，只需调用</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="e170" class="np kz it oq b gy ou ov l ow ox">df.profile_report()</span></pre><p id="6034" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这将在一个方便的HTML传单中提供对您的数据的彻底检查，该传单易于理解并且与IPython完全兼容！</p><h1 id="4b1e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">系列</h1><p id="41e8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Pandas系列类型虽然可能不像数据框那样是Pandas的组成部分，但肯定有其重要性。与普通列表的功能相反，熊猫系列有很多不同的选项，这些选项在其他地方都不被支持。这些工具通常包括大多数数据科学家期望从Python中获得的典型生活质量工具。</p><h2 id="4d84" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">Series.isin()</h2><p id="53e8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">isin函数将返回一个条件掩码，如果序列中的给定观察值在它所调用的值列表内，该条件掩码将返回true。例如，我们可以为我们的:PrecipType列中的每个值是否为“rain”创建一个掩码:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="4cba" class="np kz it oq b gy ou ov l ow ox">df["Precip Type"].isin(["rain"])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/1cf3236e1437bf3467cf054bcd45d0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*NdMwc5bd_iN75R5jMOm0Kg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="a4a0" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">Series.where()</h2><p id="1fdc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Where将对给定的系列应用一个条件，并返回满足所述条件的值。where函数几乎直接以该函数用途的SQL等价物命名。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="a89c" class="np kz it oq b gy ou ov l ow ox">df["Summary"].where(df["Summary"] != "Mostly Cloudy")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/414ee5b6222f4eae317239a1b1b969b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*msPtolTmoAfseUq_EGSFQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h2 id="06d6" class="np kz it bd la nq nr dn le ns nt dp li lz nu nv lk md nw nx lm mh ny nz lo oa bi translated">Loc和ILoc系列</h2><p id="8aff" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果您不熟悉iloc和loc，那么您可能应该开始练习了——因为这两个非常重要！经验法则是<code class="fe qt qu qv oq b">loc is used for labels</code>和<code class="fe qt qu qv oq b">iloc is used for integer-based indexing. </code>首先，让我们尝试在一个系列类型上使用iloc，看看我们会得到什么回报。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="334c" class="np kz it oq b gy ou ov l ow ox">df["Precip Type"].iloc[2]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qw"><img src="../Images/b73299bef9e04e445ebf9262eecec735.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*w9E9kCvQ_TCDCZPt_FSgMg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="2e2b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们在这里得到“rain”作为回报，因为它是我们的“Precip Type”列中的第二个索引。让我们再来看看数据帧头:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qx"><img src="../Images/1a92b54ba00b596801a84a48d5a69277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ep6i4sZ6HOiVG46Zhu1GCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="acd8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">或者，我们可以使用loc而不是iloc来获取基于索引中标签的值。考虑以下数据帧:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="8ed1" class="np kz it oq b gy ou ov l ow ox">data = pd.DataFrame({"Age": [25, 35,45]}, index = ["Corgi", "Maltese", "Pug"])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qy"><img src="../Images/77b666e2dae6533e5c9d8f9bdcc5a4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*LQWSJe5n95r62Rd_a8frcA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a040" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在，我们可以对任何给定的索引调用loc，并接收带有每个特性的整个观察集:</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="8ae7" class="np kz it oq b gy ou ov l ow ox">data.loc["Corgi"]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qz"><img src="../Images/3b94034fe59cf1791a1724aaa46eb1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*wHVScZrseW9YYSaAzjat6A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="na"><p id="b704" class="nb nc it bd nd ne pf pg ph pi pj ml dk translated">我现在才意识到25岁对一只狗来说太老了。</p></blockquote><p id="e13c" class="pw-post-body-paragraph lq lr it ls b lt pk ju lv lw pl jx ly lz pm mb mc md pn mf mg mh po mj mk ml im bi translated">实际上，我不确定这将返回什么数据类型，所以我也很想知道这是什么类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ra"><img src="../Images/0c60f7f383cd52145b0ce68631e63761.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*5ar1QsBprNQ3zVh1ROkt0w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="na"><p id="0177" class="nb nc it bd nd ne pf pg ph pi pj ml dk translated">谁能想到呢？</p></blockquote><h2 id="385b" class="np kz it bd la nq rb dn le ns rc dp li lz rd nv lk md re nx lm mh rf nz lo oa bi translated">Series.rank()</h2><p id="eea3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">rank函数可用于根据值在数据中相对于最小值和最大值的位置为值提供数值等级。这在一系列不同的原因中是有用的，但是在Wilcox秩和检验中可以看到秩的巨大应用，Wilcox秩和检验是一种使用秩来返回概率的统计检验。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="1130" class="np kz it oq b gy ou ov l ow ox">df["Humidity"].rank()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi rg"><img src="../Images/a7e69bf29f29ea595c9a2d75b74341e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*0tE6jsjTrIJBHgfW0KfJRA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl rh ri hx rj" role="separator"><span class="rk bw bk rl rm rn"/><span class="rk bw bk rl rm rn"/><span class="rk bw bk rl rm"/></div><div class="im in io ip iq"><h1 id="32dd" class="ky kz it bd la lb ro ld le lf rp lh li jz rq ka lk kc rr kd lm kf rs kg lo lp bi translated">结论</h1><p id="f219" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">不用说，Pandas是一个管理和清理大型数据集的神奇库。熊猫让很多事情变得简单多了，坦白地说，这些事情在其他语言中很难。虽然有很多其他语言的伟大软件包试图完成类似的任务，但它们中的大多数让我怀念熊猫处理复杂问题的出色方式。</p><p id="b283" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">使用这些功能，几乎可以保证科学家可能遇到的大多数问题都能得到解决。虽然Pandas是一个非常深入的库，但总是有一个伟大的功能可以加快你的工作，让你更快地找到有趣的东西，这是很棒的！</p></div></div>    
</body>
</html>