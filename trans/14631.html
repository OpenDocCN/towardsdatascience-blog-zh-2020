<html>
<head>
<title>Finding the Most Common Colors in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中查找最常见的颜色</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-most-common-colors-in-python-47ea0767a06a?source=collection_archive---------6-----------------------#2020-10-09">https://towardsdatascience.com/finding-most-common-colors-in-python-47ea0767a06a?source=collection_archive---------6-----------------------#2020-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="743f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">图像处理任务中的标准但至关重要的功能</h2></div><p id="3b57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们知道图像或物体最常见的颜色是什么，就可以解决图像处理中的几个用例。例如，在农业领域，我们可能想要确定水果的成熟度，例如橙子或草莓。我们可以简单地检查水果的颜色是否落在预定的范围内，看看它是否成熟、腐烂或太年轻。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/fa67a283bcfe9265d2aeafa64d798d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*px1mjBN-Ked4n-1V"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@sarahjgualtieri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莎拉·瓜尔蒂埃里</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="642d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样，我们可以使用Python加上简单而强大的库(如Numpy、Matplotlib和OpenCV)来解决这个问题。我将演示几种方法来使用这些包找到图像中最常见的颜色。</p><h2 id="4df0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">步骤1 —加载包</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f07b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在这里加载基本包。我们会继续加载更多的包。还有，既然我们是用Jupyter编程，那就别忘了包含<code class="fe mn mo mp mq b">%matplotlib inline</code>命令。</p><h2 id="a25d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">步骤2 —加载并显示样本图像</h2><p id="d586" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在本教程中，我们将大量并排显示两幅图像。因此，让我们创建一个助手函数来完成这项工作。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d12c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将加载一些我们将在本教程中使用的示例图像，并使用上面的函数显示它们。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mw"><img src="../Images/1bd39ffe3ac1943810af67cd1635c692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBJIhb2dGTZVA6WMX8MhyA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">来源:作者图片</p></figure><p id="d230" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们准备好了。是时候找出这些图片中最常见的颜色了。</p><h2 id="6744" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">方法1 —平均</h2><p id="1b8b" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">第一种方法是最简单的(但不是最有效的)，只需找到平均像素值。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7e43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mn mo mp mq b">numpy</code>的<code class="fe mn mo mp mq b">average</code>函数，我们可以很容易地得到整个行和宽度的平均像素值— <code class="fe mn mo mp mq b">axis=(0,1)</code></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mw"><img src="../Images/2d82bb77bc45bae79c3a0a96a27ab5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBT608ysePkOmeEvUnidEQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">最常见的颜色#1 —平均法</p></figure><p id="9bb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，平均方法可能会产生误导或不准确的结果，因为它给出的最常见的颜色有点偏离。这是因为平均值考虑了所有像素值。当我们有高对比度的图像(在一个图像中既有“亮”又有“暗”)时，这确实是个问题。这在第二张图中更加清晰。</p><blockquote class="mx my mz"><p id="4fe0" class="kf kg na kh b ki kj jr kk kl km ju kn nb kp kq kr nc kt ku kv nd kx ky kz la ij bi translated">它给了我们一种新的颜色，在图像中看不清楚/不明显。</p></blockquote><h2 id="f172" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">方法2 —最高像素频率</h2><p id="2c90" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">第二种方法会比第一种方法更精确一点。我们将简单地计算每个像素值中出现的次数。</p><p id="9022" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我们来说幸运的是，<code class="fe mn mo mp mq b">numpy</code>再次给了我们一个函数，给出了这个精确的结果。但是首先，我们必须重塑图像数据结构，以仅给出3个值的列表(每个值对应一个R、G和B通道强度)。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mw"><img src="../Images/b93f1955de2bd7e437d6b57f90c39c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCNrQGhEXipO7k_b0DKkrg.png"/></div></div></figure><p id="c55b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以简单地使用<code class="fe mn mo mp mq b">numpy</code>的<code class="fe mn mo mp mq b">reshape</code>函数来获取像素值列表。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mw"><img src="../Images/cf3a3ae6ab352431ee255aba15724223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJtQo0fvzc5HVuM1Y0Gc-A.png"/></div></div></figure><p id="6ca3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们有了正确结构的数据，我们可以开始计算像素值的频率。我们可以使用<code class="fe mn mo mp mq b">numpy</code>的<code class="fe mn mo mp mq b">unique</code>函数，带参数<code class="fe mn mo mp mq b">return_counts=True</code>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mw"><img src="../Images/49c5a194ec3355286375fa629f60b963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aG862Pvng1syu1RFTMI8Uw.png"/></div></div></figure><p id="efa7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，让我们运行它到我们的图像。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ne"><img src="../Images/aa20450a2b1c9000155ab7d50f194d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dK7b_wYbmJ2-kUXzAeg09Q.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">最常见的颜色#2 —频率法</p></figure><p id="ce87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比第一个更有意义，对吗？最常见的颜色在黑色区域。但是我们可以更进一步。如果我们不只选择一种最常见的颜色，而是不止一种呢？用同样的概念，我们可以取前N个最常见的颜色。除此之外，如果你看第一张图片，许多频率最高的颜色很可能是相邻的颜色，可能只有很小的像素差异。</p><blockquote class="mx my mz"><p id="7f34" class="kf kg na kh b ki kj jr kk kl km ju kn nb kp kq kr nc kt ku kv nd kx ky kz la ij bi translated">换句话说，我们想要取最普通的、不同的<strong class="kh ir">色群</strong>。</p></blockquote><h2 id="53da" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">方法3 —使用K均值聚类</h2><p id="1500" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">Scikit-learn package来拯救我们。我们可以使用臭名昭著的K-Means聚类来将颜色分组。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ne"><img src="../Images/affe49ebedf077adc3549b7146532229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY9azogc-j302cqYUh343Q.png"/></div></div></figure><p id="f967" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单，对吧？现在，我们需要的是一个函数来显示上面的颜色簇，并立即显示出来。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="568a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们简单地创建一个高度为50，宽度为300像素的图像来显示颜色组/调色板。对于每个颜色簇，我们将其分配到调色板中。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ne"><img src="../Images/5d25073d2901e04e27c4e8a54f7ed442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIt9jA-Zs0Plo53tVpDy6w.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">最常见的颜色# 3—K-均值聚类</p></figure><p id="be5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很漂亮不是吗？K-Means聚类在图像中最常见的颜色方面给出了很好的结果。在第二个图像中，我们可以看到调色板中有太多的棕色阴影。这很可能是因为我们选择了太多的集群。让我们看看是否可以通过选择一个更小的<em class="na"> k </em>值来修复它。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ne"><img src="../Images/d7e0202524108f0bc3cf8e38dfc74eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zbESJqoWlAf_PuopNeJc1A.png"/></div></div></figure><p id="e8c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，解决了。由于我们使用K-Means聚类，我们仍然需要自己确定合适的聚类数。三簇似乎是个不错的选择。</p><p id="5b1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们仍然可以改进这些结果，并且仍然可以解决一些集群问题。</p><blockquote class="mx my mz"><p id="e899" class="kf kg na kh b ki kj jr kk kl km ju kn nb kp kq kr nc kt ku kv nd kx ky kz la ij bi translated">不如我们也显示整个图像中聚类的比例？</p></blockquote><h2 id="9761" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">方法3.1-K均值+比例显示</h2><p id="d6bc" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们需要做的就是修改我们的<code class="fe mn mo mp mq b">palette</code>函数。我们不使用固定的步长，而是改变每个聚类的宽度，使其与该聚类中的像素数量成比例。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/04d72739164eda1636cfda3d5f88317e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*9S_7r23Z3Vd2zNeYOV4s5Q.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">最常见的颜色# 3.1—K-表示聚类+比例</p></figure><p id="d858" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好多了。</p><p id="6a91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不仅给了我们图像中最常见的颜色。它还给出了每个像素出现的比例。</p><p id="7e7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还有助于回答我们应该使用多少个集群。在顶部图像的情况下，两到四个集群似乎是合理的。在第二个图像的情况下，看起来我们至少需要两个集群。我们不使用一个集群(<em class="na"> k=4 </em>)的原因是我们会遇到与平均方法相同的问题。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi gj"><img src="../Images/42a14e364046bf9454ffed173c342fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1g9qhqU-ImCb0x-cwus2g.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">结果为k=1的k均值</p></figure><h1 id="6cf8" class="ng lt iq bd lu nh ni nj lx nk nl nm ma jw nn jx md jz no ka mg kc np kd mj nq bi translated">结论</h1><p id="cab4" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们已经介绍了几种使用Python和几个著名的库来获得图像中最常见颜色的技术。另外，我们也看到了这些技术的优缺点。到目前为止，使用K-Means和<em class="na"> k &gt; 1 </em>找到最常见的颜色是找到图像中最常见的颜色的最佳解决方案之一(至少与我们经历过的其他方法相比)。</p><p id="8150" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对剧本有问题，请在评论中或者我的<a class="ae lr" href="https://github.com/mrakelinggar/data-stuffs/tree/master/frequent_color" rel="noopener ugc nofollow" target="_blank"> Github </a>中告诉我。</p></div></div>    
</body>
</html>