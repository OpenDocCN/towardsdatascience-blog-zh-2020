<html>
<head>
<title>Eager Execution vs. Graph Execution in TensorFlow: Which is Better?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow中的急切执行与图形执行:哪个更好？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/eager-execution-vs-graph-execution-which-is-better-38162ea4dbf6?source=collection_archive---------3-----------------------#2020-10-23">https://towardsdatascience.com/eager-execution-vs-graph-execution-which-is-better-38162ea4dbf6?source=collection_archive---------3-----------------------#2020-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="74dd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="/beginners-guide-to-tensorflow-2-x-for-deep-learning-applications-c7ebd0dcfbee">←Part 1</a>|<a class="ae ep" rel="noopener" target="_blank" href="/mastering-tensorflow-tensors-in-5-easy-steps-35f21998bb86">←Part 2</a>|<a class="ae ep" rel="noopener" target="_blank" href="/mastering-tensorflow-variables-in-5-easy-step-5ba8062a1756">←Part 3</a>|深度学习用TENSORFLOW 2。X —第4部分</h2><div class=""/><div class=""><h2 id="8224" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用代码示例比较急切执行和图形执行，了解何时使用两者以及TensorFlow为何切换到急切执行|使用TensorFlow 2.x进行深度学习</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3c828ae06d7ed91b7f979729b108a0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCte6Loh8DxH6-PABdqn0g@2x.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图一。急切执行与图形执行(图由作者提供)</p></figure><p id="aeb3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi md translated"><span class="l me mf mg bm mh mi mj mk ml di"> T </span>这是TensorFlow 2.x系列深度学习的第4部分，我们将比较TensorFlow中可用的两个执行选项:</p><blockquote class="mm"><p id="49fe" class="mn mo it bd mp mq mr ms mt mu mv mc dk translated">急切执行与图形执行</p></blockquote><p id="ada1" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">你可能没有注意到，你实际上可以在这两者中选择一个。原因是TensorFlow将急切执行设置为默认选项，除非您想找麻烦，否则它不会打扰您😀。但是，在TensorFlow 1.x版本中并非如此。让我们看看什么是急切执行，以及为什么TensorFlow在TensorFlow 2.0中从图形执行进行了重大转变。</p><div class="ks kt ku kv gt ab cb"><figure class="nb kw nc nd ne nf ng paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/0e21baf4e0817404f4e16c7c1204fc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*Hib89fc2y2iPCxYR"/></div></figure><figure class="nb kw nc nd ne nf ng paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/5b2e03d2531a5f03f88eb700d9288027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*IT-3FObj4qx8CT_Z"/></div><p class="ld le gj gh gi lf lg bd b be z dk nh di ni nj translated">图二。图形执行与急切执行的类比(由<a class="ae nk" href="https://unsplash.com/@jamesponddotco" rel="noopener ugc nofollow" target="_blank">詹姆斯·庞德</a>拍摄于<a class="ae nk" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a> |由<a class="ae nk" href="https://unsplash.com/@tvbeats?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> TVBEATS </a>拍摄于<a class="ae nk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure></div><h1 id="3716" class="nl nm it bd nn no np nq nr ns nt nu nv ki nw kj nx kl ny km nz ko oa kp ob oc bi translated">急切的执行</h1><p id="3491" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">渴望执行是一个强大的执行环境，它可以立即评估操作。它不构建图形，并且操作返回实际值，而不是稍后运行的计算图形。通过快速执行，TensorFlow计算代码中出现的张量值。</p><p id="97b0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">急切执行简化了TensorFlow中的模型构建体验，您可以立即看到TensorFlow操作的结果。由于急切执行直观且易于测试，因此对于初学者来说是一个极好的选择。热切执行不仅使调试更容易，而且还减少了对重复样板代码的需求。急切执行也是研究和实验的一个灵活选项。它提供:</p><ul class=""><li id="d1ea" class="oi oj it lj b lk ll ln lo lq ok lu ol ly om mc on oo op oq bi translated"><strong class="lj jd">具有自然Python代码和数据结构的直观界面</strong>；</li><li id="5b68" class="oi oj it lj b lk or ln os lq ot lu ou ly ov mc on oo op oq bi translated"><strong class="lj jd">调试更简单</strong>，直接调用操作检查测试模型；</li><li id="65f2" class="oi oj it lj b lk or ln os lq ot lu ou ly ov mc on oo op oq bi translated"><strong class="lj jd">自然控制流</strong>用Python，代替图形控制流；和</li><li id="0930" class="oi oj it lj b lk or ln os lq ot lu ou ly ov mc on oo op oq bi translated">支持<strong class="lj jd"> GPU &amp; TPU加速。</strong></li></ul><p id="4d93" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在急切执行中，TensorFlow操作由原生Python环境一个接一个地执行。这使得急切执行(I)易于调试，(ii)直观，(iii)易于原型化，以及(iv)对初学者友好。由于这些原因，TensorFlow团队将急切执行作为TensorFlow 2.0的默认选项。<em class="ow">但是，在接下来的章节中会有更多相关内容……</em></p><blockquote class="mm"><p id="d7de" class="mn mo it bd mp mq mr ms mt mu mv mc dk translated">让我们来看看图形执行。</p></blockquote><h1 id="348b" class="nl nm it bd nn no np nq nr ns nt nu nv ki ox kj nx kl oy km nz ko oz kp ob oc bi translated">图形执行</h1><p id="45bf" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">我们在上一节中介绍了急切执行是多么有用和有益，但是有一个问题:</p><blockquote class="mm"><p id="ca37" class="mn mo it bd mp mq mr ms mt mu mv mc dk translated">急切执行比图形执行慢！</p></blockquote><figure class="pb pc pd pe pf kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/3fbc92f82a960d9332a711ffc38b8b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1sBnG4Ei8J00AyEYKnQqg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图3。在<a class="ae nk" href="https://www.tensorflow.org/tensorboard" rel="noopener ugc nofollow" target="_blank"> Tensorboard </a>中的模型示例的图形可视化(图片由作者提供)</p></figure><p id="2828" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于急切执行在Python中逐个运行所有操作，因此它不能利用潜在的加速机会。Graph execution从Python中提取张量计算，并在评估之前构建一个高效的<em class="ow">图</em>。图形，或者说<code class="fe pg ph pi pj b">tf.Graph</code>对象，是带有<code class="fe pg ph pi pj b">tf.Operation</code>和<code class="fe pg ph pi pj b">tf.Tensor</code>对象的特殊数据结构。<code class="fe pg ph pi pj b">tf.Operation</code>对象代表计算单元，<code class="fe pg ph pi pj b">tf.Tensor</code>对象代表数据单元。无需原始Python代码就可以保存、运行和恢复图形，这为跨平台应用程序提供了额外的灵活性。有了图，您可以在Python不可用的移动、嵌入式和后端环境中利用您的模型。在本系列的稍后阶段，我们将看到，无论您选择哪一个执行选项，经过训练的模型都被保存为图形。</p><p id="dcf9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">图表很容易优化。它们允许编译器级别的转换，例如具有常数折叠的张量值的统计推断，在线程和设备之间分布操作的子部分(高级级别分布)，并简化算术运算。<a class="ae nk" href="https://www.tensorflow.org/guide/graph_optimization" rel="noopener ugc nofollow" target="_blank">抓钩</a>执行这些整体优化操作。在图形执行中，只有在我们完全调用了程序之后，才会对所有操作进行评估。因此，总而言之，图形执行是:</p><ul class=""><li id="bc3f" class="oi oj it lj b lk ll ln lo lq ok lu ol ly om mc on oo op oq bi translated"><strong class="lj jd">非常快</strong>；</li><li id="247f" class="oi oj it lj b lk or ln os lq ot lu ou ly ov mc on oo op oq bi translated"><strong class="lj jd">非常灵活</strong>；</li><li id="fb3b" class="oi oj it lj b lk or ln os lq ot lu ou ly ov mc on oo op oq bi translated"><strong class="lj jd">与</strong>并行运行，即使在子操作层面；和</li><li id="4171" class="oi oj it lj b lk or ln os lq ot lu ou ly ov mc on oo op oq bi translated"><strong class="lj jd">非常高效</strong>，适用于多种设备</li><li id="2035" class="oi oj it lj b lk or ln os lq ot lu ou ly ov mc on oo op oq bi translated">拥有<strong class="lj jd"> GPU &amp; TPU加速</strong>能力。</li></ul><p id="7d1e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，尽管难以学习、难以测试且不直观，图形执行对于大型模型训练来说是理想的。对于小型模型培训、初学者和一般开发人员来说，急切执行更适合。</p><p id="117b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">嗯，考虑到急切执行易于构建和测试，而图形执行高效而快速，您会希望用急切执行来构建，用图形执行来运行，对吗？好吧，我们会谈到那个…</p><blockquote class="mm"><p id="1856" class="mn mo it bd mp mq mr ms mt mu mv mc dk translated">寻找两全其美的世界？一个快速但易于构建的选项？继续读:)</p></blockquote><p id="95c9" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">在深入代码示例之前，我们先来讨论一下为什么TensorFlow在TensorFlow 2.0中从图形执行切换到急切执行。</p><h1 id="518b" class="nl nm it bd nn no np nq nr ns nt nu nv ki nw kj nx kl ny km nz ko oa kp ob oc bi translated">TensorFlow为什么采用急切执行？</h1><p id="2b12" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">在2.0版本之前，TensorFlow优先考虑图形执行，因为它快速、高效且灵活。对于经验丰富的程序员来说，实现的难度只是一种权衡。另一方面，<a class="ae nk" href="http://pytorch.org" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>采用了一种不同的方法，并对动态计算图进行了优先级排序，这是一个类似于急切执行的概念。尽管动态计算图不如TensorFlow图执行效率高，但它们为新一波研究人员和人工智能程序员提供了一个简单而直观的界面。默认执行策略的这种差异使得PyTorch对新来者更有吸引力。很快，PyTorch虽然是后来者，却开始追赶TensorFlow。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/df991262517dc4cf1d84bebbd73d6447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dob3swHoF12Xu6PDRu0JBw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图4。TensorFlow vs. PyTorch谷歌搜索结果由<a class="ae nk" href="https://trends.google.com/trends/explore?date=today%205-y&amp;q=%2Fg%2F11bwp1s2k3,%2Fg%2F11gd3905v1" rel="noopener ugc nofollow" target="_blank">谷歌趋势</a>(图由作者提供)</p></figure><p id="80a3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在看到PyTorch越来越受欢迎后，TensorFlow团队很快意识到他们必须优先考虑急切执行。因此，他们采用了急切执行作为默认的执行方式，而图形执行是可选的。这就好比，PyTorch将动态计算图设置为默认的执行方法，你可以选择使用静态计算图来提高效率。</p><p id="8435" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于现在TensorFlow和PyTorch都采用了初学者友好的执行方法，PyTorch失去了对初学者的竞争优势。目前，由于其成熟性，TensorFlow占据上风。然而，毫无疑问，PyTorch也是构建和训练深度学习模型的一个很好的替代方案。选择权在你…</p><h1 id="7b10" class="nl nm it bd nn no np nq nr ns nt nu nv ki nw kj nx kl ny km nz ko oa kp ob oc bi translated">用渴望编码，用图形执行</h1><p id="746b" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">在这一节中，我们将使用基本代码示例比较急切执行和图形执行。为了简单起见，我们将有意避免构建复杂的模型。但是，在本系列接下来的部分中，我们还可以使用更复杂的模型来比较这些执行方法。</p><p id="60c1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们已经提到TensorFlow优先考虑急切执行。但这还不是全部。现在，您实际上可以像急切执行一样构建模型，然后用图形执行来运行它。TensorFlow 1.x需要用户手动创建图表。然后通过将一组输出张量和输入张量传递给一个<code class="fe pg ph pi pj b">session.run()</code>调用来手动编译这些图形。但是，在TensorFlow 2.0中，图形构建和会话调用被简化为实现细节。这种简化是通过用<code class="fe pg ph pi pj b">tf.function()</code>装饰者代替<code class="fe pg ph pi pj b">session.run()</code>来实现的。在TensorFlow 2.0中，您可以使用<code class="fe pg ph pi pj b">tf.function()</code>来修饰Python函数，使其作为单个graph对象运行。使用这种新方法，您可以轻松地构建模型，并获得图形执行的所有好处。</p><h1 id="8c75" class="nl nm it bd nn no np nq nr ns nt nu nv ki nw kj nx kl ny km nz ko oa kp ob oc bi translated">代码示例</h1><p id="065e" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">这篇文章将通过几个基本的例子和一个完整的虚拟模型来测试eager和graph的执行。请注意，由于这是一篇介绍性的帖子，我们现在不会深入到一个完整的基准测试分析<em class="ow"/>。</p><h2 id="fcbc" class="pl nm it bd nn pm pn dn nr po pp dp nv lq pq pr nx lu ps pt nz ly pu pv ob iz bi translated">基本示例</h2><p id="1dd4" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">我们将从两个初始导入开始:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pw px l"/></div></figure><pre class="ks kt ku kv gt py pj pz qa aw qb bi"><span id="1456" class="pl nm it pj b gy qc qd l qe qf"><a class="ae nk" href="https://docs.python.org/2/library/timeit.html" rel="noopener ugc nofollow" target="_blank"><strong class="pj jd">timeit</strong></a> is a Python module which provides a simple way to time small bits of Python and it will be useful to compare the performances of eager execution and graph execution.</span></pre><p id="fd21" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要运行一个热切执行的代码，我们不需要做什么特别的事情；我们创建一个函数，传递一个<code class="fe pg ph pi pj b">tf.Tensor</code>对象，然后运行代码。在下面的代码中，我们创建了一个名为<code class="fe pg ph pi pj b">eager_function</code>的函数来计算张量值的平方。然后，我们创建一个<code class="fe pg ph pi pj b">tf.Tensor</code>对象，最后调用我们创建的函数。我们的代码以急切的执行方式执行:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pw px l"/></div></figure><pre class="ks kt ku kv gt py pj pz qa aw qb bi"><span id="862b" class="pl nm it pj b gy qc qd l qe qf"><strong class="pj jd">Output:</strong> tf.Tensor([ 1.  4.  9. 16. 25.], shape=(5,), dtype=float32)</span></pre><p id="f122" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们首先看看如何用图形执行来运行相同的函数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pw px l"/></div></figure><pre class="ks kt ku kv gt py pj pz qa aw qb bi"><span id="562d" class="pl nm it pj b gy qc qd l qe qf"><strong class="pj jd">Output:</strong> Tensor("pow:0", shape=(5,), dtype=float32)</span></pre><p id="b74c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过用<code class="fe pg ph pi pj b">tf.function()</code>函数包装我们的<code class="fe pg ph pi pj b">eager_function</code>，我们能够用图形执行来运行我们的代码。我们可以用如下所示的<code class="fe pg ph pi pj b">timeit</code>来比较这两种方法的执行时间:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pw px l"/></div></figure><pre class="ks kt ku kv gt py pj pz qa aw qb bi"><span id="19cc" class="pl nm it pj b gy qc qd l qe qf">Output:<br/>Eager time: 0.0008830739998302306<br/>Graph time: 0.0012101310003345134</span></pre><p id="b11d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如您所见，图形执行花费了更多的时间。但是为什么呢？嗯，对于简单的操作，图形执行的表现并不好，因为它必须花费初始计算能力来构建一个图形。我们看到了图形执行在复杂计算中的威力。如果我运行代码100次(通过更改number参数)，结果会发生巨大的变化(<em class="ow">主要是由于本例中的print语句</em>):</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pw px l"/></div></figure><pre class="ks kt ku kv gt py pj pz qa aw qb bi"><span id="3fee" class="pl nm it pj b gy qc qd l qe qf">Output:<br/>Eager time: 0.06957343100020807 <br/>Graph time: 0.02631650599960267</span></pre><h2 id="0a14" class="pl nm it bd nn pm pn dn nr po pp dp nv lq pq pr nx lu ps pt nz ly pu pv ob iz bi translated">全模型试验</h2><p id="8c01" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">既然您已经介绍了基本的代码示例，那么让我们构建一个虚拟神经网络来比较eager和graph执行的性能。我们将:</p><p id="557f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">1-使TensorFlow导入使用所需的模块；</p><p id="461e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">2 —建立基本前馈神经网络；</p><p id="4d85" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">3 —创建一个随机的<code class="fe pg ph pi pj b">Input</code>对象；</p><p id="d262" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">4 —以热切的执行来运行模型；</p><p id="af30" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">5-用<code class="fe pg ph pi pj b">tf.function()</code>包装模型，用图形执行运行它。</p><pre class="ks kt ku kv gt py pj pz qa aw qb bi"><span id="1118" class="pl nm it pj b gy qc qd l qe qf">If you are new to TensorFlow, don’t worry about how we are building the model. We will cover this in detail in the upcoming parts of this Series.</span></pre><p id="4a26" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以下代码行执行所有这些操作:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pw px l"/></div></figure><pre class="ks kt ku kv gt py pj pz qa aw qb bi"><span id="d65b" class="pl nm it pj b gy qc qd l qe qf">Output:<br/>Eager time: 27.14511264399971<br/>Graph time: 17.878579870000067</span></pre><p id="b479" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如您所看到的，我们的图形执行比急切执行多了40%左右。在更复杂的模型训练操作中，这个余量要大得多。</p><h1 id="08cf" class="nl nm it bd nn no np nq nr ns nt nu nv ki nw kj nx kl ny km nz ko oa kp ob oc bi translated">最终注释</h1><p id="8d7d" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">在这篇文章中，我们比较了急切执行和图形执行。虽然急切执行易于使用且直观，但图形执行更快、更灵活、更健壮。因此，对于初学者来说，使用缺省选项“急切执行”是显而易见的。然而，如果你想利用灵活性和速度，并且是一个经验丰富的程序员，那么图形执行是适合你的。另一方面，由于TensorFlow的最新改进，使用图形执行变得更加简单。因此，您甚至可以突破自己的极限来尝试图形执行。但是，请确保您知道在图形执行中调试也更加困难。</p><p id="23a7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">上面的代码示例向我们展示了对简单的示例应用图形执行是很容易的。对于更复杂的模型，图形执行会带来一些额外的工作负载。</p><pre class="ks kt ku kv gt py pj pz qa aw qb bi"><span id="8020" class="pl nm it pj b gy qc qd l qe qf">Note that when you wrap your model with tf.function(), you cannot use several model functions like model.compile() and model.fit() because they already try to build a graph automatically. But we will cover those examples in a different and more advanced level post of this series.</span></pre><h1 id="077f" class="nl nm it bd nn no np nq nr ns nt nu nv ki nw kj nx kl ny km nz ko oa kp ob oc bi translated">恭喜</h1><p id="0668" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">我们已经成功地比较了急切执行和图形执行。</p><blockquote class="qg qh qi"><p id="1413" class="lh li ow lj b lk ll kd lm ln lo kg lp qj lr ls lt qk lv lw lx ql lz ma mb mc im bi translated">给自己一个鼓励！</p></blockquote><p id="df26" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这应该会给你很大的信心，因为你现在对急切执行、图形执行以及使用这些执行方法的利弊有了更多的了解。</p><h1 id="1d0c" class="nl nm it bd nn no np nq nr ns nt nu nv ki nw kj nx kl ny km nz ko oa kp ob oc bi translated">订阅邮件列表获取完整代码</h1><p id="b768" class="pw-post-body-paragraph lh li it lj b lk od kd lm ln oe kg lp lq of ls lt lu og lw lx ly oh ma mb mc im bi translated">如果你想获得Google Colab的全部代码和我的其他最新内容，可以考虑订阅邮件列表。</p><blockquote class="mm"><p id="0be2" class="mn mo it bd mp mq mr ms mt mu mv mc dk translated"><a class="ae nk" href="http://eepurl.com/hd6Xfv" rel="noopener ugc nofollow" target="_blank">现在就订阅</a></p></blockquote><p id="4ba6" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated"><em class="ow">如果你正在阅读这篇文章，我确信我们有着相似的兴趣，并且现在/将来会从事相似的行业。那么我们就通过</em><a class="ae nk" href="https://linkedin.com/in/orhangaziyalcin/" rel="noopener ugc nofollow" target="_blank"><em class="ow">Linkedin</em></a><em class="ow">来连线吧！请不要犹豫发送联系请求！</em><a class="ae nk" href="https://linkedin.com/in/orhangaziyalcin/" rel="noopener ugc nofollow" target="_blank"><em class="ow">Orhan g . Yal n—Linkedin</em></a></p><p id="9ac1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您刚刚开始使用TensorFlow，请考虑从本教程系列的第1部分开始:</p><div class="qm qn gp gr qo qp"><a rel="noopener follow" target="_blank" href="/beginners-guide-to-tensorflow-2-x-for-deep-learning-applications-c7ebd0dcfbee"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd jd gy z fp qu fr fs qv fu fw jc bi translated">深度学习应用TensorFlow 2.x初学者指南</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">了解TensorFlow平台以及它能为机器学习专家提供什么</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">towardsdatascience.com</p></div></div><div class="qy l"><div class="qz l ra rb rc qy rd lb qp"/></div></div></a></div><p id="6cfe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">或<a class="ae nk" rel="noopener" target="_blank" href="/mastering-tensorflow-tensors-in-5-easy-steps-35f21998bb86">检查第二部分</a>:</p><div class="qm qn gp gr qo qp"><a rel="noopener follow" target="_blank" href="/mastering-tensorflow-tensors-in-5-easy-steps-35f21998bb86"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd jd gy z fp qu fr fs qv fu fw jc bi translated">通过5个简单的步骤掌握TensorFlow张量</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">探索TensorFlow的构建模块如何在较低的级别工作，并学习如何充分利用张量…</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">towardsdatascience.com</p></div></div><div class="qy l"><div class="re l ra rb rc qy rd lb qp"/></div></div></a></div><p id="614c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">或者<a class="ae nk" rel="noopener" target="_blank" href="/mastering-tensorflow-variables-in-5-easy-step-5ba8062a1756">检查第3部分</a>:</p><div class="qm qn gp gr qo qp"><a rel="noopener follow" target="_blank" href="/mastering-tensorflow-variables-in-5-easy-step-5ba8062a1756"><div class="qq ab fo"><div class="qr ab qs cl cj qt"><h2 class="bd jd gy z fp qu fr fs qv fu fw jc bi translated">用5个简单的步骤掌握TensorFlow“变量”</h2><div class="qw l"><h3 class="bd b gy z fp qu fr fs qv fu fw dk translated">了解如何使用张量流变量，它们与普通张量对象的区别，以及它们何时优于…</h3></div><div class="qx l"><p class="bd b dl z fp qu fr fs qv fu fw dk translated">towardsdatascience.com</p></div></div><div class="qy l"><div class="rf l ra rb rc qy rd lb qp"/></div></div></a></div></div></div>    
</body>
</html>