<html>
<head>
<title>Kafka in Action: Building a distributed multi-video processing pipeline with Python and Confluent Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡在行动:用Python和融合的卡夫卡构建分布式多视频处理管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kafka-in-action-building-a-distributed-multi-video-processing-pipeline-with-python-and-confluent-9f133858f5a0?source=collection_archive---------7-----------------------#2020-09-25">https://towardsdatascience.com/kafka-in-action-building-a-distributed-multi-video-processing-pipeline-with-python-and-confluent-9f133858f5a0?source=collection_archive---------7-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="903d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实时大规模数据处理和机器学习。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea0e54c1ff2b54c393c72ee0ecd70298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LdAvV2Y3uxmiIJgZFDfGw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们将会建造什么</p></figure><h1 id="8d87" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="9526" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">试图通过建立一个项目来学习任何主题是一种有趣而直观的方式来加强我们的理解。在这篇文章中，我们将通过这样做来探索卡夫卡。</p><h2 id="0096" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">我们将会建造什么</h2><p id="e8be" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">想象一下这样一个场景，我们有多个来源生成视频流，我们需要近乎实时地处理和存储数据(如上图)。卡夫卡是这种情况下的完美契合。</p><h2 id="d58c" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">先决条件</h2><ol class=""><li id="4489" class="my mz it ls b lt lu lw lx lz na md nb mh nc ml nd ne nf ng bi translated">对卡夫卡有基本的了解会有所帮助，但是如果你觉得舒服，你可以随时随地探索和学习。</li><li id="4b19" class="my mz it ls b lt nh lw ni lz nj md nk mh nl ml nd ne nf ng bi translated">你需要在你的系统中安装<a class="ae nm" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank"> docker </a>，因为我们将使用它来运行应用程序，然而，安装软件包的二进制版本也可以。</li></ol><h1 id="57f6" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">我们开始吧</h1><h2 id="0b51" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">开始卡夫卡</h2><p id="e89c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将使用夏羽·马瑞克的惊人项目<a class="ae nm" href="https://github.com/simplesteph/kafka-stack-docker-compose" rel="noopener ugc nofollow" target="_blank">kafka-stack-docker-compose</a>在Docker中运行Kafka。首先，您需要克隆回购:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="018d" class="mm kz it no b gy ns nt l nu nv">git clone <a class="ae nm" href="https://github.com/simplesteph/kafka-stack-docker-compose.git" rel="noopener ugc nofollow" target="_blank">https://github.com/simplesteph/kafka-stack-docker-compose.git</a></span></pre><p id="e138" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">然后，根据集群配置，您可以运行所需的docker-compose文件。在本文中，我们将保持简单，用一个zookeeper和一个kafka服务器运行一个集群。假设您已经启动了Docker，运行:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="3e55" class="mm kz it no b gy ns nt l nu nv">cd <!-- -->kafka-stack-docker-compose<br/>docker-compose -f zk-single-kafka-single.yml up</span></pre><p id="930f" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">我们现在已经通过两个简单的步骤启动了Kafka集群！</p><h2 id="b1f8" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">正在启动MongoDB</h2><p id="68a8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将使用MongoDB来存储处理后的数据。同样，我们将使用Docker来运行MongoDB。首先，我们需要创建一个<code class="fe ob oc od no b">docker volume</code> <em class="oe"> </em>，这个<em class="oe"> </em>将帮助我们在磁盘中持久保存数据，即使我们停止并移除容器。要创建体积管路，请执行以下操作:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="ea08" class="mm kz it no b gy ns nt l nu nv">docker volume create data-mongodb</span></pre><p id="3908" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated"><code class="fe ob oc od no b">data-mongodb </code>是我们卷的名称。接下来，我们将启动MongoDB服务器实例，并在其上挂载<code class="fe ob oc od no b">data-mongodb</code>卷。运行:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6d80" class="mm kz it no b gy ns nt l nu nv">docker run -v data-mongodb:/data/db -p 27017:27017 --name mongodb -d mongo</span></pre><p id="bf85" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">这将自动提取MongoDB映像并启动容器。</p><p id="47e8" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">好吧！现在我们已经有了Kafka和MongoDB，让我们开始研究这个项目。</p><h1 id="2ab1" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">卡夫卡在行动</h1><p id="06c0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将要使用的代码可以在这个<a class="ae nm" href="https://github.com/wingedrasengan927/Distributed-Multi-Video-Streaming-and-Processing-with-Kafka" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到。将repo克隆到工作区中。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="256a" class="mm kz it no b gy ns nt l nu nv">git clone <a class="ae nm" href="https://github.com/wingedrasengan927/Distributed-Multi-Video-Streaming-and-Processing-with-Kafka.git" rel="noopener ugc nofollow" target="_blank">https://github.com/wingedrasengan927/Distributed-Multi-Video-Streaming-and-Processing-with-Kafka.git</a></span></pre><p id="1ab8" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">接下来安装必要的依赖项。最好为项目创建一个单独的虚拟环境，然后安装。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="28fd" class="mm kz it no b gy ns nt l nu nv">cd Distributed-Multi-Video-Streaming-and-Processing-with-Kafka<br/>pip install -r requirements.txt</span></pre><h2 id="de63" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">卡夫卡主题</h2><p id="5827" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们要做的第一件事就是创造一个卡夫卡式的话题。要创建主题运行:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7607" class="mm kz it no b gy ns nt l nu nv">python create_topic.py</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建卡夫卡主题</p></figure><p id="8611" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">这里我创建了一个名为<code class="fe ob oc od no b">multi-video-stream</code>的主题，复制因子为1和3个分区。您可以试验复制因子和分区数量，但是要记住相应地更改<code class="fe ob oc od no b">Admin Client</code>(第6行)中的服务器配置，还要注意副本的数量不能超过集群中服务器的数量。</p><h2 id="56f7" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">卡夫卡制片人</h2><p id="9df5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Producer应用程序从视频中读取帧，并将它们发布到Kafka主题。让我们浏览一下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生产者应用</p></figure><p id="9bdc" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">在开始时，我已经提到，我们将与多个来源产生视频流。我们需要一种在本地环境中模拟这种情况的方法。我们可以通过使用并发性并在一个线程中处理每个视频来做到这一点。</p><p id="d251" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">Kafka Producer是线程安全的——我们可以创建单个Producer实例，并在多个线程间共享它。</p><p id="f366" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">在上面的代码中，我将所有的函数打包成一个类，当我们实例化这个类时，我们创建了一个Kafka Producer。</p><p id="3a20" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">方法<code class="fe ob oc od no b">publishFrame</code>负责从视频中读取帧并将它们发布到卡夫卡主题。我们在这里使用<code class="fe ob oc od no b">opencv</code>进行视频操作。在对produce方法的调用中，我们传递了以下参数:</p><ul class=""><li id="54c4" class="my mz it ls b lt nw lw nx lz oh md oi mh oj ml ok ne nf ng bi translated"><strong class="ls iu">主题:</strong>我们要将数据发送到的主题的名称。请记住，我们之前已经创建了主题。</li><li id="22cc" class="my mz it ls b lt nh lw ni lz nj md nk mh nl ml ok ne nf ng bi translated"><strong class="ls iu">值:</strong>这是实际的视频帧数据，被序列化为字节。</li><li id="6a87" class="my mz it ls b lt nh lw ni lz nj md nk mh nl ml ok ne nf ng bi translated"><strong class="ls iu"> on_delivery: </strong>生产方法是异步的。它不会等待确认消息是否已经传递。我们传入一个回调函数，该函数记录关于所产生的消息或错误(如果有的话)的信息。<a class="ae nm" href="https://www.confluent.io/blog/introduction-to-apache-kafka-for-python-programmers/?utm_medium=sem&amp;utm_source=google&amp;utm_campaign=ch.sem_br.brand_tp.prs_tgt.confluent-brand_mt.mbm_rgn.india_lng.eng_dv.all&amp;utm_term=%2Bconfluent%20%2Bpython&amp;creative=&amp;device=c&amp;placement=&amp;gclid=EAIaIQobChMI3a-A2o_86wIVVz5gCh1yEAx2EAAYASAAEgLFIvD_BwE" rel="noopener ugc nofollow" target="_blank">回调</a>作为调用<code class="fe ob oc od no b">poll</code>或<code class="fe ob oc od no b">flush</code>方法的副作用被执行和发送。</li><li id="342a" class="my mz it ls b lt nh lw ni lz nj md nk mh nl ml ok ne nf ng bi translated"><strong class="ls iu">时间戳:</strong>给出数据时间属性信息的值。注意，这里我传递的是帧数，而不是绝对时间，因为它更相关。</li><li id="c8a6" class="my mz it ls b lt nh lw ni lz nj md nk mh nl ml ok ne nf ng bi translated"><strong class="ls iu"> headers: </strong> Headers包含我们想要发布到主题的任何关联元数据。请注意，回调函数不会记录标头。</li></ul><p id="c271" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">还要注意，我们每三帧发布一次，每一帧后等待一段时间。这是因为在现实世界中，我们以特定的<em class="oe"> fps </em>从源获得帧，并且在每个连续帧之间没有太多的信息差异，尤其是在机器学习的背景下。这也有助于减少Kafka服务器上的负载。</p><p id="d0f4" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated"><code class="fe ob oc od no b">start</code>方法将每个视频映射到一个线程，并发运行应用程序。</p><p id="db94" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">要启动Producer应用程序，将您的视频放入<code class="fe ob oc od no b">video</code>文件夹，在第47行相应地更改扩展名，然后运行:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="79f0" class="mm kz it no b gy ns nt l nu nv">python producer_app.py</span></pre><p id="0d87" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">这将同时开始向Kafka主题发布视频帧。您应该会看到关于所记录的生成消息的信息。</p><p id="64f3" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">现在让我们看看另一面。</p><h2 id="f34e" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">卡夫卡消费者</h2><p id="fac5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">消费者应用程序订阅Kafka主题来接收数据。我们通过图像分类模型对数据进行推理，然后将结果存储到MongoDB数据库中。让我们浏览一下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">消费者应用</p></figure><p id="ad40" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">消费者在一个消费者群体中运作。组中的每个消费者从独占分区读取数据。如果一个组中的消费者数量超过了分区的数量，一些消费者将处于非活动状态。</p><p id="aa71" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">在我们的消费者应用程序中，我们有多个属于同一个组的消费者同时从Kafka主题中读取数据。注意，与生产者不同，消费者不是线程安全的，每个线程需要有一个单独的消费者实例。</p><p id="7a45" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">我们用<code class="fe ob oc od no b">run</code>方法完成从接收数据到处理和存储数据的所有操作。首先，我们对来自主题的数据进行轮询，如果没有错误并且消息有效，我们将继续进行进一步的处理。</p><p id="5aa6" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">注意，消费者从主题中一次轮询一批消息，并将它们存储在内部缓冲区中，并从那里读取。</p><p id="1c4f" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">一旦我们收到消息，我们就对它进行解码，从中提取时间戳和元数据，并将其附加到一个数组中。</p><h2 id="fa5f" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated"><strong class="ak">批量操作</strong></h2><p id="9142" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你观察，我们不是一个接一个地处理消息，而是批量处理数据并对数据执行操作。这提高了效率和吞吐量。</p><p id="08de" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">一旦数据批次形成，我们就将其传递给图像分类模型，在我们的情况下，该模型是在ImageNet上训练的ResNet50模型。该模型每帧输出标签及其相应的置信度。我们只挑选最上面的标签和它的置信度并存储它。</p><p id="e968" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">接下来，我们将获得的结果插入MongoDB数据库。数据在数据库中的组织方式是，我们将每个视频作为一个集合，在每个集合中，我们都有包含该帧信息的记录或文档。该文档具有帧号、帧标签和置信度作为其字段，使得查询数据变得容易。此外，请注意，正如我们之前讨论的那样，我们正在向数据库中执行批量插入。</p><p id="9a24" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">在这之后，我们完成了数据的处理，我们想把同样的事情告诉卡夫卡。Kafka使用偏移量来跟踪消费者轮询的数据记录的位置，因此即使消费者倒下了，Kafka也能够从它停止的地方读回来。我们希望如何提交偏移量以及遵循哪种交付语义由我们决定。这里，我们在数据处理完成后提交偏移量。这遵循了<em class="oe">至少一次</em>交货的语义。</p><p id="3bef" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated"><strong class="ls iu">注意:</strong>因为我们手动提交偏移量，所以在配置文件中我们必须将<code class="fe ob oc od no b">enable.auto.commit</code>属性设置为<code class="fe ob oc od no b">False</code></p><p id="bbd4" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated"><strong class="ls iu">注意:</strong>在<em class="oe">至少一次</em>交付语义中，如果消费者停止使用或处理出错，消息有可能被再次处理。为了避免重复的消息，我们必须维护幂等系统。例如，在我们的例子中，我们确保将一个惟一的文档插入到一个集合中，这样即使再次处理一个消息，数据库中也不会有任何重复。</p><p id="d890" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">好吧，让我们回到代码上。要运行消费者应用程序，请在第108行设置主题，在第124行更改视频名称(注意:这些名称必须与我们通过生产者发布的视频名称相匹配，并且这些名称也将是数据库中的集合名称)，确保消费者的数量不超过第128行中的分区数量，然后运行:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="26c6" class="mm kz it no b gy ns nt l nu nv">python consumer_app.py</span></pre><p id="3eb1" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">如果您同时启动生产者应用程序和消费者应用程序，它看起来会像这样并排:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">左:制片人；右图:消费者</p></figure><p id="ab9f" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">还可以可视化存储在MongoDB中的数据。<a class="ae nm" href="https://robomongo.org/download" rel="noopener ugc nofollow" target="_blank"> Robo3T </a>是一个很好的工具:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/9ff1e7eb31d3591e556c097b772ae53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7slLx7G4WABiQ5aZuUqlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Robo3T中可视化文档</p></figure><h1 id="0a3f" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">在生产中部署</h1><p id="091f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">生产中的事情会变得更加复杂。幸运的是，我们在云平台上有托管服务，如谷歌云发布/订阅(T1)或T2亚马逊kine sis(T3)，这让我们的工作变得更容易。最好在生产中使用它们。</p><p id="5d8a" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">此外，在本文中，我们没有讨论生产者和消费者的配置，但是基于用例对它们进行调优是非常重要的。例如，在某些情况下，延迟可能是高优先级，我们可能不关心数据丢失或数据顺序，而在其他情况下，数据可能被赋予高优先级。需要相应地配置生产者和消费者。</p><p id="8476" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">对于生产中的机器学习，最佳实践是使用<a class="ae nm" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"> Tensorflow服务API </a>，而不是在消费者应用中初始化模型。</p><p id="8442" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">此外，最好使用云中的托管数据库来存储数据。</p><h1 id="9bcb" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="3415" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这让我们走到了尽头！Kafka正在大量的项目中使用，并且还在继续增长。这一点非常重要。下面我提到了一些额外的资源，可以帮助你加深对卡夫卡的了解。</p><p id="207a" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">希望这篇文章是有帮助的。如果您有任何反馈或想与我取得联系，请在<em class="oe">ms.neerajkrishna@gmail.com给我留言。</em></p><p id="3448" class="pw-post-body-paragraph lq lr it ls b lt nw ju lv lw nx jx ly lz ny mb mc md nz mf mg mh oa mj mk ml im bi translated">在<a class="ae nm" href="https://twitter.com/WingedRasengan" rel="noopener ugc nofollow" target="_blank">推特</a>上连线吧！</p><h1 id="6ce8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">额外资源</h1><ul class=""><li id="8092" class="my mz it ls b lt lu lw lx lz na md nb mh nc ml ok ne nf ng bi translated">夏羽·马瑞克在《我的世界》上的精彩课程</li><li id="289f" class="my mz it ls b lt nh lw ni lz nj md nk mh nl ml ok ne nf ng bi translated">汇合者拥有关于卡夫卡的惊人的文档和博客。</li></ul></div></div>    
</body>
</html>