<html>
<head>
<title>Visualising Well Data Coverage Using Matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Matplotlib可视化油井数据覆盖范围</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualising-well-data-coverage-using-matplotlib-f30591c89754?source=collection_archive---------44-----------------------#2020-10-26">https://towardsdatascience.com/visualising-well-data-coverage-using-matplotlib-f30591c89754?source=collection_archive---------44-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0347" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索数据在哪里，不在哪里</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6d6543e2b072bc580b67147d8129593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MAuTdRqdsW4O3Efl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">维尔莫斯·海姆在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><p id="794f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">探索性数据分析(EDA)是数据科学不可或缺的一部分。岩石物理领域也是如此，通常被称为项目的测井质量控制或数据审查阶段。正是在这个阶段，我们开始详细检查数据，并确定我们真正拥有哪些数据，我们在哪里拥有这些数据，以及收集的数据的质量如何。</p><p id="5c4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们花了很大一部分时间(在某些情况下高达90%！— Kohlleffel，2015年)处理测井数据的时间都花在了试图理解数据并将其转换为适合解释的状态上。剩下的10%是我们可以着手进行岩石物理解释的时候。这可以根据正在进行的项目的初始状态而变化。</p><p id="7850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在QC阶段，我们经常会发现自己有多个输入文件、随机的曲线名称、缺失的数据和没有直接用途的额外曲线。这可能会导致困惑和沮丧，尤其是在使用多种工具和老式数据集时。在我们有缺失数据的情况下，我们需要识别它并确定处理它的最佳方式。在文本编辑器中查看单个LAS文件可能很难做到这一点，但使用软件可以使其变得更容易。其中一种方法是使用Python，这是一种常见且流行的编程语言。</p><p id="ca6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇短文中，我们将介绍如何可视化Equinor在2018年发布的Volve数据集的3个井内的数据覆盖范围。</p><p id="1b75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在GitHub上的以下链接中找到本示例的完整Jupyter笔记本9<strong class="lb iu">——我的<strong class="lb iu">岩石物理学和Python系列</strong>的visualizing Data covere . ipynb</strong>:</p><div class="lv lw gp gr lx ly"><a href="https://github.com/andymcdgeo/Petrophysics-Python-Series/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">andymcdgeo/岩石物理学-Python-系列</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">本系列Jupyter笔记本将带您了解使用Python和岩石物理数据的各个方面。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><h1 id="a2b4" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">加载数据和库</h1><p id="48f3" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">与任何Python项目一样，我们需要加载所需的数据和库。对于本文，我们将使用pandas和matplotlib。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="82cb" class="np mo it nl b gy nq nr l ns nt">import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="071d" class="np mo it nl b gy nu nr l ns nt"># Load in our data from a CSV file<br/>data = pd.read_csv('Data/VolveWells.csv')<br/>data.head()</span></pre><p id="2720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/59d767e36f3406efaf65dd40faf82d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*piwz8YmmO9KijT-3pJhiCw.png"/></div></div></figure><p id="42bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，我们可以看到我们的数据集中有12列。第一列是井，随后是深度曲线，随后是每条测井曲线。</p><p id="c599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了识别我们的数据集中有哪些井，我们可以调用<code class="fe nw nx ny nl b">data['WELL'].unique()</code>，它将返回一个数组，但是我们可以通过实现一个简短的for循环并打印出每个值来获得更好的格式。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="607f" class="np mo it nl b gy nq nr l ns nt">for well in data[‘WELL’].unique():<br/>    print(well)</span></pre><p id="0077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回3口井的列表:</p><ul class=""><li id="c51c" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">9月15日-F-1 C</li><li id="5d35" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">2004年9月15日</li><li id="eacc" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">2007年9月15日</li></ul><h1 id="e741" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">数据准备</h1><p id="1a44" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为了让我们的绘图像预期的那样工作，我们需要修改数据集的列顺序。这可以通过首先按照我们想要的顺序创建一个列列表来实现。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="7f05" class="np mo it nl b gy nq nr l ns nt">plot_cols = ['WELL', 'DEPTH', 'CALI', 'BS', 'GR', 'NEU', 'DEN', 'PEF', 'RDEP', 'RMED', 'AC', 'ACS']</span></pre><p id="59a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以用新的列顺序替换现有的数据帧:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="1b86" class="np mo it nl b gy nq nr l ns nt">data = data[plot_cols]<br/>data.head()</span></pre><p id="1d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以调用<code class="fe nw nx ny nl b">data.head()</code>来查看新的数据帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d52291ad6339024e01dc614f77d50b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiIJUSbGLKtetpSl0UMdVw.png"/></div></div></figure><p id="3420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建数据帧的副本。这将允许我们保留原始数据帧，以便在项目的后续工作中使用。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="31eb" class="np mo it nl b gy nq nr l ns nt">data_nan = data.copy()</span></pre><p id="870c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使绘图按预期显示，我们需要替换数据框中的值。</p><p id="ba79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在有实际值的地方，我们将根据它在数据帧中的位置给它分配一个数字。在我们有一个NaN(不是数字)值的地方，我们要给它一个数字- 1的值。这将允许我们在一个数字和另一个数字之间使用阴影，同时为每个井使用一个单独的子图。这使事情变得简单，并且不需要为每个井中的每条曲线创建支线图。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="89bc" class="np mo it nl b gy nq nr l ns nt">for num, col in enumerate(data_nan.columns[2:]):<br/>    data_nan[col] = data_nan[col].notnull() * (num + 1)<br/>    data_nan[col].replace(0, num, inplace=True)</span></pre><p id="c235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解上面这段代码:</p><ul class=""><li id="cbe5" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe nw nx ny nl b">for num, col in enumerate(data_nan.columns[2:]:<br/></code>这一行将循环遍历从第2列开始的每一列。<br/> enumerate()允许我们在遍历每一列时创建一个计数器/索引值</li><li id="1a75" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nw nx ny nl b">data_nan[col] = data_nan[col].notnull()*(num+1)<br/></code>这里我们把实数值转换成布尔值(真或假)。如果为真，则转换为列号加1。当它为假时，这些值将被设置为0。</li><li id="7319" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe nw nx ny nl b">data_nan[col].replace(0, num, inplace=True)<br/></code>我们现在可以用列号替换任何0值。</li></ul><h1 id="e460" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">绘制数据</h1><p id="afc0" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">现在我们已经到了策划阶段。为了在单独的子图中绘制每个井，我们必须按照井名对数据帧进行分组:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="24cb" class="np mo it nl b gy nq nr l ns nt">grouped = data_nan.groupby('WELL')</span></pre><p id="1773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了绘制数据，我们可以调用这段简短的代码。我添加了简短的注释来描述每个部分在做什么。</p><p id="2989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe nw nx ny nl b">ax.fillbetweenx()</code>来填充我们之前设置的每条曲线的两个值。例如，CALI有两个值来指示数据的存在:1表示有实数值，0表示有NaN值。类似地，GR有两个值:有实数据时为3，有NaN时为2。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="3220" class="np mo it nl b gy nq nr l ns nt">#Setup the labels we want to display on the x-axis<br/>labels = ['CALI', 'BS', 'GR', 'NEU', 'DEN', 'PEF', 'RDEP', 'RMED', 'AC', 'ACS']</span><span id="fec5" class="np mo it nl b gy nu nr l ns nt">#Setup the figure and the subplots<br/>fig, axs = plt.subplots(1, 3, figsize=(20,10))</span><span id="766a" class="np mo it nl b gy nu nr l ns nt">#Loop through each well and column in the grouped dataframe<br/>for (name, df), ax in zip(grouped, axs.flat):<br/>    ax.set_xlim(0,9)<br/>    <br/>    #Setup the depth range<br/>    ax.set_ylim(5000, 0)<br/>    <br/>    #Create multiple fill betweens for each curve# This is between<br/>    # the number representing null values and the number representing<br/>    # actual values<br/>    <br/>    ax.fill_betweenx(df.DEPTH, 0, df.CALI, facecolor='grey')<br/>    ax.fill_betweenx(df.DEPTH, 1, df.BS, facecolor='lightgrey')<br/>    ax.fill_betweenx(df.DEPTH, 2, df.GR, facecolor='mediumseagreen')<br/>    ax.fill_betweenx(df.DEPTH, 3, df.NEU, facecolor='lightblue')<br/>    ax.fill_betweenx(df.DEPTH, 4, df.DEN, facecolor='lightcoral')<br/>    ax.fill_betweenx(df.DEPTH, 5, df.PEF, facecolor='violet')<br/>    ax.fill_betweenx(df.DEPTH, 6, df.RDEP, facecolor='darksalmon')<br/>    ax.fill_betweenx(df.DEPTH, 7, df.RMED, facecolor='wheat')<br/>    ax.fill_betweenx(df.DEPTH, 8, df.AC, facecolor='thistle')<br/>    ax.fill_betweenx(df.DEPTH, 9, df.ACS, facecolor='tan')<br/>    <br/>    #Setup the grid, axis labels and ticks<br/>    ax.grid(axis='x', alpha=0.5, color='black')<br/>    ax.set_ylabel('DEPTH (m)', fontsize=14, fontweight='bold')<br/>    <br/>    #Position vertical lines at the boundaries between the bars<br/>    ax.set_xticks([1,2,3,4,5,6,7,8,9,10], minor=False)<br/>    <br/>    #Position the curve names in the centre of each column<br/>    ax.set_xticks([0.5, 1.5 ,2.5 ,3.5 ,4.5 ,5.5 ,6.5 , 7.5, 8.5, 9.5], minor=True)<br/>    <br/>    #Setup the x-axis tick labels<br/>    ax.set_xticklabels(labels,  rotation='vertical', minor=True, verticalalignment='bottom')<br/>    ax.set_xticklabels('', minor=False)<br/>    ax.tick_params(axis='x', which='minor', pad=-10)<br/>    <br/>    #Assign the well name as the title to each subplot<br/>    ax.set_title(name, fontsize=16, fontweight='bold')</span><span id="860c" class="np mo it nl b gy nu nr l ns nt">plt.tight_layout()<br/>plt.subplots_adjust(hspace=0.15, wspace=0.25)<br/>plt.show()</span></pre><p id="ec1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们运行上面的代码，我们会得到一个matplotlib图，其中有3个子图。每个包含每口井的数据范围。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/a83a897b81dfd17f04c8c658022c2674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDPfATgGbpXpffJkjmXRXw.png"/></div></div></figure><p id="ed89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个图中我们可以确定:</p><p id="cd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">9月15日——F-1 C</p><ul class=""><li id="0c90" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">伽马射线和电阻率曲线中的微小间隙。由于间隙出现在两条电阻率曲线的相同位置，我们可以初步假设它们可能与套管鞋有关。需要进一步调查来证实这一点。</li><li id="134c" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">核曲线(登、NEU、PEF)和井径仪仅在一小段上运行，可能指示目的层。</li><li id="ccff" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">无声学曲线(交流和交流)</li></ul><p id="d656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 15/9-F-4 </strong></p><ul class=""><li id="018b" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">包含所有可用的曲线，大部分在朝向井底的一小部分上。</li><li id="5b85" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">在伽马射线(GR)和声波剪切(ACS)曲线中有多个间隙。可能与工具有关。进一步的调查会揭示原因。</li></ul><p id="4831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 15/9-F-7 </strong></p><ul class=""><li id="3be1" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">在一个短而浅的剖面上出现的数据量最少。</li><li id="3a06" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">仅提供钻头尺寸、伽马射线和电阻率测量值。</li><li id="6e09" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">可能由工具故障或钻井时遇到的问题引起。如果有完井报告，可以通过审查这些报告来确认这些信息。</li></ul><h1 id="1643" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="1360" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在这篇短文中，我向您展示了如何从一个CSV文件中加载数据，并以一种您可以识别丢失值所在位置的方式来可视化它。在执行岩石物理解释或应用机器学习模型之前，了解哪里有或没有数据是探索数据集的关键步骤</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><h1 id="a2b5" class="mn mo it bd mp mq ow ms mt mu ox mw mx jz oy ka mz kc oz kd nb kf pa kg nd ne bi translated">参考</h1><p id="92ee" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">本例中使用的数据:<br/> Equinor。(2018).公开所有Volve数据。可在:<a class="ae ky" href="https://www.equinor.com/en/news/14jun2018-disclosing-volve-data.html" rel="noopener ugc nofollow" target="_blank">https://www . equinor . com/en/news/14 jun 2018-discovery-volve-data . html</a></p></div></div>    
</body>
</html>