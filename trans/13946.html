<html>
<head>
<title>A gentle intro to Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Clojure的温和介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-gentle-intro-to-clojure-ad6c6802babe?source=collection_archive---------25-----------------------#2020-09-25">https://towardsdatascience.com/a-gentle-intro-to-clojure-ad6c6802babe?source=collection_archive---------25-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个小的真实世界的例子；探索GitHub repos</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3383786d4252d43f7bd257cfbf0c002f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ad823U0UW9wqwdPO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@arianismmm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Arian Darvishi </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="8d76" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">这个计划</h1><p id="f8c0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将使用<a class="ae ky" href="http://http-kit.github.io/" rel="noopener ugc nofollow" target="_blank"> HttpKit </a>来访问GitHub API，并获取关于一个组织的存储库的信息。然后，我们将利用Clojure的内置特性来操作和探索集合。现在，我们不会尝试任何异步或复杂的东西——我们可以把它留到以后的文章中:)</p><h1 id="0f69" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">入门指南</h1><p id="1d0d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在某个新目录中，我创建了一个<code class="fe mn mo mp mq b">deps.edn</code>文件，具有以下依赖关系:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="156e" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">然后我们可以在与<code class="fe mn mo mp mq b">deps.edn</code>文件相同的目录下启动一个<code class="fe mn mo mp mq b">clj</code> REPL:</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="69fc" class="nc la it mq b gy nd ne l nf ng"><strong class="mq iu">❯</strong> clj</span><span id="f8b6" class="nc la it mq b gy nh ne l nf ng">Clojure 1.10.1</span><span id="d03e" class="nc la it mq b gy nh ne l nf ng">user=&gt;</span></pre><p id="e060" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">并要求(粘贴)我们在REPL的属地:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="ef03" class="nc la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">快速地图提醒</h2><p id="2c21" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">map中的键也是函数，它允许我们非常简洁地从map中访问键值。假设我们用<code class="fe mn mo mp mq b">:error</code>和<code class="fe mn mo mp mq b">:status</code>属性定义了一个名为<code class="fe mn mo mp mq b">test-map</code>的地图。我们可以像这样访问属性<code class="fe mn mo mp mq b">:status</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="f3c5" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">提出API请求</h1><blockquote class="of og oh"><p id="ebc0" class="lr ls oi lt b lu mt ju lw lx mu jx lz oj mv mc md ok mw mg mh ol mx mk ml mm im bi translated">👋生成个人访问令牌来使用API是最容易的。</p></blockquote><p id="44e6" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">此时，最好尝试访问GitHub API，以确保我们的身份验证和URL是正确的。将下面的<code class="fe mn mo mp mq b">def's</code>调整为您自己的信息/设置，并将其粘贴到REPL中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="a030" class="nc la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">承诺</h2><p id="2204" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">HttpKit <code class="fe mn mo mp mq b">(http/get)</code>函数返回一个承诺。一旦完成，这个承诺将解析为一张地图。我们可以使用@ symbol: <code class="fe mn mo mp mq b">@(http/get .. ..)</code>进行阻塞，直到这个承诺完成。一旦完成，我们就可以访问各种键值，比如<code class="fe mn mo mp mq b">:status</code>，应该是200:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="7959" class="nc la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">头球</h2><p id="cc1e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">GitHub有一个很好的分页模型，我们将利用它来告诉我们是否需要发出更多的请求。如果我们查看响应头，有一个名为<code class="fe mn mo mp mq b">link</code>的属性，它包含一个逗号分隔的链接数组以及它们相对于当前页面的位置。我们可以通过<code class="fe mn mo mp mq b">get-in</code>函数从响应图中访问它。然后，如果链接字符串包含<code class="fe mn mo mp mq b">rel="next"</code>，我们可以判断是否有下一页要获取:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="77a9" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">我们现在可以创建一个<code class="fe mn mo mp mq b">get-repos</code>函数来将上述所有内容放在一起。它需要两个参数；<code class="fe mn mo mp mq b">page</code>和<code class="fe mn mo mp mq b">per_page</code> —当前页码和每页返回的库数量，分别为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><blockquote class="of og oh"><p id="e042" class="lr ls oi lt b lu mt ju lw lx mu jx lz oj mv mc md ok mw mg mh ol mx mk ml mm im bi translated">⚠️:到目前为止，GitHub API的最大值是100。</p></blockquote><p id="f67b" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">注意，我们的<code class="fe mn mo mp mq b">get-repos</code>函数返回一个包含响应<code class="fe mn mo mp mq b">:body</code>的映射，作为一个解析的json <strong class="lt iu">数组</strong>和<code class="fe mn mo mp mq b">:has_next</code>作为一个<strong class="lt iu">布尔值</strong>。</p><h1 id="8b1b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">循环浏览GitHub页面</h1><p id="a734" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们有发出请求和检索GitHub库的所有小逻辑。接下来，我们需要遍历所有页面的数据，并将回购添加到一个不断增长的列表中。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="6008" class="nc la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">快速循环提醒</h2><p id="59c3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Clojure中的循环要么很棒，要么是一场灾难，这取决于您的背景。让我们从一个简单的循环开始。这里我们将<code class="fe mn mo mp mq b">i</code>绑定到<code class="fe mn mo mp mq b">0</code>，只有在<code class="fe mn mo mp mq b">i &lt; 5</code>时才调用<code class="fe mn mo mp mq b">recur</code>。当我们调用<code class="fe mn mo mp mq b">recur</code>时，我们将<code class="fe mn mo mp mq b">i</code>绑定到<code class="fe mn mo mp mq b">i + 1</code>的值，从而递增<code class="fe mn mo mp mq b">i</code>并打印其值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7f8e" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">上述表达式的值就是<code class="fe mn mo mp mq b">loop</code>函数最后返回的值。这种情况下，<code class="fe mn mo mp mq b">5</code>。如果我们将这个表达式设置为一个<code class="fe mn mo mp mq b">def</code>，我们将把那个<code class="fe mn mo mp mq b">def</code>的值设置为<code class="fe mn mo mp mq b">5</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="62b2" class="nc la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">循环浏览页面</h2><p id="9149" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以快速检查自己，以确保在请求一个存储库后有更多的页面。</p><blockquote class="of og oh"><p id="069f" class="lr ls oi lt b lu mt ju lw lx mu jx lz oj mv mc md ok mw mg mh ol mx mk ml mm im bi translated">👋请确保您的组织有多个存储库！😅</p></blockquote><p id="9f04" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">请注意下面我们有多个字母绑定。首先，<code class="fe mn mo mp mq b">resp</code>被设置为表达式<code class="fe mn mo mp mq b">(get-repos 1 1)</code>的结果，然后<code class="fe mn mo mp mq b">has_next</code>将访问新设置的<code class="fe mn mo mp mq b">resp</code>变量，所有这些都在同一行代码中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6b50" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">我们可以将上述内容与一些循环逻辑结合起来，以获取所有存储库。我将所有存储库放在一个名为<code class="fe mn mo mp mq b">repos</code>的全局列表中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><blockquote class="of og oh"><p id="4c06" class="lr ls oi lt b lu mt ju lw lx mu jx lz oj mv mc md ok mw mg mh ol mx mk ml mm im bi translated">我知道我的组织中有200多个存储库，所以我将变量<code class="fe mn mo mp mq b">per_page</code>设置为最大值100。</p></blockquote><p id="7d29" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">运行一个快速检查以确保存储库的数量与您预期的相匹配:</p><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="7f7b" class="nc la it mq b gy nd ne l nf ng">(println (count @repos))<br/>; =&gt; 233</span></pre><p id="2796" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">太好了！我们所有的库都在一个全局原子列表中。我们现在可以按照我们认为合适的方式对数据进行分割。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="68fc" class="nc la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">过滤</h2><p id="235b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们试试看有多少回购处于活动状态，即没有<code class="fe mn mo mp mq b">archived</code>。我们可以使用Clojure的<code class="fe mn mo mp mq b">filter</code>和一个匿名函数来实现这一点。匿名函数接受一个存储库映射作为输入，并检查<code class="fe mn mo mp mq b">:archived</code>属性是否为假:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0551" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">我们做到了！<code class="fe mn mo mp mq b">active-repos</code>包含属性<code class="fe mn mo mp mq b">:archived</code>等于<code class="fe mn mo mp mq b">false</code>的存储库。</p><p id="f196" class="pw-post-body-paragraph lr ls it lt b lu mt ju lw lx mu jx lz ma mv mc md me mw mg mh mi mx mk ml mm im bi translated">我希望这是进入Clojure的一个有用的方法！我们利用一个库来发出http请求，然后利用核心语言特性来进行一些基本的循环、过滤、多let和状态管理。</p></div></div>    
</body>
</html>