<html>
<head>
<title>The importance of k-fold cross-validation for model prediction in machine learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k-fold交叉验证对机器学习中模型预测的重要性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-importance-of-k-fold-cross-validation-for-model-prediction-in-machine-learning-4709d3fed2ef?source=collection_archive---------11-----------------------#2020-11-04">https://towardsdatascience.com/the-importance-of-k-fold-cross-validation-for-model-prediction-in-machine-learning-4709d3fed2ef?source=collection_archive---------11-----------------------#2020-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f673002a5ed79619079bbac6e22edb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PNm86WlFDEZaSIG_Ulm8Pw.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片—加拿大桑德湾</p></figure><p id="7ba1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文将讨论和分析使用经验风险最小化(ERM)的最小二乘算法的机器学习中模型预测的k-fold交叉验证的重要性。</p><p id="6ab4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将使用多项式曲线拟合问题来预测样本数据集的最佳多项式。此外，我们将在MATLAB上一步一步地检查10重交叉验证的实现。</p><p id="043a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章结束时，你将知道如何实现k-fold交叉验证方法，并理解它的优点和缺点。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="408b" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">概观</h1><p id="8a20" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">为了更好地可视化在机器学习上应用k-fold交叉验证的好处，我们将分析我们在根本不进行任何类型的交叉验证的情况下估计模型时可能面临的一些问题。</p><p id="cde9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们首先将数据集导入MATLAB，并绘制数据点，以便更好地可视化它们。然后，我们将实施10重交叉验证算法，并计算经验风险最小化(ERM)的<a class="ae mk" href="https://en.wikipedia.org/wiki/Least_squares" rel="noopener ugc nofollow" target="_blank">平方损失误差</a>，以找到我们数据的最佳模型。最后，我们将重复这个过程，但这次没有任何类型的交叉验证，并比较结果。</p><h1 id="fdde" class="lh li iq bd lj lk ml lm ln lo mm lq lr ls mn lu lv lw mo ly lz ma mp mc md me bi translated">资料组</h1><p id="ce2e" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">我们将使用只有100个数据点的数据集。稍后将解释使用如此小的数据集的原因。这个数据集最初是由<a class="ae mk" href="https://www.eecs.yorku.ca/~ruth/" rel="noopener ugc nofollow" target="_blank"> Ruth Urner </a>博士在她的一次机器学习课程作业中提出的。在下面的存储库中，你会发现两个TXT文件:<a class="ae mk" href="https://github.com/jaimedantas/least-squares-regresion/blob/main/dataset/dataset1_inputs.txt" rel="noopener ugc nofollow" target="_blank"> dataset1_inputs.txt </a>和<a class="ae mk" href="https://github.com/jaimedantas/least-squares-regresion/blob/main/dataset/dataset1_outputs.txt" rel="noopener ugc nofollow" target="_blank"> dataset1_outputs.txt </a>。</p><div class="mq mr gp gr ms mt"><a href="https://github.com/jaimedantas/least-squares-regresion" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">jaimedantas/最小二乘回归</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">正则化最小二乘算法用于回归以寻找机器学习模型。这个实现…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh jw mt"/></div></div></a></div><p id="4a9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些文件包含输入和输出向量。在MATLAB上的Home &gt; Import Data中导入它们之后，我们可以绘制如下所示的数据点。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/79a68e18d32e1b60f83fb1f0d0fbc9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*pK8l0G-SxPh3ajKkhTAlug.png"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">资料组</p></figure><h1 id="d70c" class="lh li iq bd lj lk ml lm ln lo mm lq lr ls mn lu lv lw mo ly lz ma mp mc md me bi translated">k倍交叉验证</h1><p id="d9ec" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">当我们没有足够的数据来应用其他更有效的方法，如三分法(训练、验证和测试)或使用维持数据集时，交叉验证通常用于机器学习中，以改善模型预测。这就是我们的数据集只有100个数据点的原因。如果你想更多地了解这种方法背后的数学原理，我推荐你阅读这篇文章。</p><p id="55d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在k-fold交叉验证中，我们首先打乱数据集，使输入和输出的顺序完全随机。我们这样做是为了确保我们的输入没有任何偏差。然后，我们将数据集分成大小相等的<em class="np"> k </em>个部分。在这个分析中，我们将使用10重交叉验证。所以，第一步是把我们的数据集分成10份。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/f631c6fcfa434ec9b7a9592cfc886813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEp6xB0liOuPvziejFmszQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">将数据分成10份</p></figure><p id="edb6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我们将使用一个折叠来测试和计算经验平方损失，其余9个折叠用于在每个<em class="np"> k </em>交互中训练我们的模型。通过这样做，每次我们开始一个新的交互时，我们都使用不同的文件夹进行测试。这样，我们保证每一个<em class="np"> k </em>零件都被用于一次测试。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/13ed529d847598e89e1dd809d3937c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMUYfFJCChud83Vvuct75g.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">10重交叉验证的算法</p></figure><p id="432c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们将有10个经验平方损失值，每个相互作用一个。最终的经验平方损失将是这些值的平均值。说够了，还是去实现本身吧。</p><h2 id="1460" class="ns li iq bd lj nt nu dn ln nv nw dp lr kn nx ny lv kr nz oa lz kv ob oc md od bi translated">履行</h2><p id="89a8" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">首先，我们需要将数据集随机分成10等份。为了做到这一点，我创建了两个循环来迭代向量<strong class="ke ir"> t </strong>和<strong class="ke ir"> x </strong>，将它们分成10个相等的部分。这些部分存储在单元阵列<em class="np"> split_t </em>和<em class="np"> split_x </em>中。我还创建了一个辅助单元格数组来存储为每个部分选择的索引。最后，我创建了一个向量来存储所有已经拆分的索引。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="cc6a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在内部循环中，我生成一个从1到100的均匀分布的随机整数[1]。然后，我检查这个索引是否在被访问的索引列表中。如果它不在那里，我将这个值添加到分割单元数组中，并递增内部循环；否则，我会生成一个新的随机索引。外环重复10次这个过程。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5398" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个过程可能不是混洗和分割数据集的最有效的方法，但是它确实有效，并且保证了随机分割。为了形象化我们创建的10个折叠，我将它们绘制在下图中。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/75da49e3b280669895011c9638899b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C37PxcvqP4Y-bvRPTbbYnw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">数据集随机分成10份</p></figure><p id="431d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们需要对ERM的经验平方损失实施10重交叉验证。在继续之前，我建议阅读一下关于ERM的解释，这样你就能理解它背后的一些主要概念。ERM的解决方案在下面的等式中定义。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b416a8d025b9520d5a57a2ef74344588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*E6AUdyQncTUnj-Hd19cohQ.png"/></div></figure><p id="db00" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">向量<strong class="ke ir"> w </strong>是我们的多项式系数，<strong class="ke ir"> X </strong>是设计矩阵，<strong class="ke ir"> t </strong>是输出向量。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/23ece7af9671e540f97b0ea1338b056e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPcRol1XBiccWRYjRzlGxA.png"/></div></div></figure><p id="8be6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了简化我们的计算，我们将在MATLAB <strong class="ke ir">中手动求解<strong class="ke ir"> w </strong>的线性方程(</strong>通过矩阵<strong class="ke ir">的相乘和求逆)。</strong>请注意，这不是求解线性方程的最有效方法。此外，我们将分析W = 1，2，…，30阶多项式。</p><p id="079c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，对于10重交叉验证，我们在一个循环中执行ERM过程10次，并将每次执行的所有测试分数存储在单元数组<strong class="ke ir"> E </strong>中。经验平方损耗通过以下公式计算。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/60851202090f641eb420f3e8ea0a8d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*jY83cIBeNbMXQoDwn4lz3A.png"/></div></figure><p id="063e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在此过程中，我们使用一个折叠进行测试，其余9个折叠用于训练。在这个循环中，我还计算了训练和测试设计矩阵。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a3d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们算法的输出如下图所示。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/a83c8645a15e2120a843726c7387314a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XenRvA2qSaIP8k5cAGzNJw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae mk" href="https://github.com/jaimedantas/least-squares-regresion/blob/main/code/Cross_Validation.m" rel="noopener ugc nofollow" target="_blank"> Cross_Validation.m </a>脚本的输出</p></figure><p id="e4ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，<strong class="ke ir">W = 6阶多项式最适合该数据</strong>。现在，让我们分析下图中所有多项式的ERM图。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/03dfa5b4d7f65343b86050b4fab374d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRyzXjxEcZDZMFo92UufIw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">缩减规模下交叉验证的经验平方损失</p></figure><p id="3d7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，为了更好地理解趋势，我缩小了上图中图表的比例。我们可以得出结论，随着多项式阶数的增加，经验平方损耗降低。然而，当我们将阶数增加到非常大的值时，我们开始看到过度拟合的行为(本例中W &gt; 21)。此外，请注意，从W = 12到W = 15，平方损耗略有增加。这是因为我们在k倍交叉验证过程中置换了我们的数据集。避免这种情况的一种方法是进行多次k倍交叉验证，最后对平方损失进行平均。</p><p id="b6b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下图显示了W = 6阶多项式相对于数据集的曲线。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/cbe9de4e626e8e877a5b3d5045bb9fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsmmUR2FQ7GONLZD-rcgCw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">6阶多项式与数据集</p></figure><p id="ba92" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，我们没有用我们选择的模型过度拟合我们的数据。</p><blockquote class="ol"><p id="6f82" class="om on iq bd oo op oq or os ot ou kz dk translated">如果我们没有使用10重交叉验证会怎么样？</p></blockquote><figure class="ow ox oy oz pa jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/53124d7318b47179e84b1822e238d5a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNhBRruqcw_AkA70XcRPBg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="2376" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了回答这个问题，让我们看看如果在我们的问题中没有使用10重交叉验证，我们会得到什么结果。为此，我们简单地将平方损失法应用于ERM，如下所示。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d84e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上述算法的输出如下所示。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/db960a51d01cad8a06082993de7f034c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fx445fnAjtLZr1VkxJE0Mg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">脚本的输出</p></figure><p id="79be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如我们所见，这一次21阶多项式是经验平方损失最小的一个。即使我们分析经验平方损失曲线(如下所示),我们最终也会选择一个非常大的模型。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/baf7662415f131e315182e6783962611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWpsekeqFyd6wxMUFIfrfw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">缩小比例下的经验平方损失</p></figure><p id="ebb8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">选择更高阶多项式的结果并不便宜。这不仅会使数据过拟合，还会增加复杂性。下面我们来看看21阶多项式。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pd"><img src="../Images/340272fdaa2fb3f11c341c16b578b0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EFITNDTwqe0ECh1C6PLwtw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">21阶多项式与数据集</p></figure><p id="9a33" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以看到，尽管W = 21阶多项式的经验损失最小，但它以极大的方式过度拟合了数据。</p><h1 id="3497" class="lh li iq bd lj lk ml lm ln lo mm lq lr ls mn lu lv lw mo ly lz ma mp mc md me bi translated">结论</h1><p id="9c37" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">我们看到<strong class="ke ir">交叉验证</strong>允许我们为我们的数据集选择一个<strong class="ke ir">更好的模型</strong>和一个<strong class="ke ir">更小的阶数</strong>(W = 6与W = 21相比)。最重要的是，k-fold交叉验证避免了我们在不执行任何类型的交叉验证时遇到的<strong class="ke ir">过拟合</strong>问题，尤其是对于小数据集。</p><p id="f257" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，这种改进伴随着高成本。当使用k-fold交叉验证时，需要更多的计算能力来找到最佳模型。</p><p id="80be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们分析有交叉验证和没有交叉验证的模型的曲线时，我们可以清楚地看到10重交叉验证在为该数据选择最佳模型时是最重要的。</p><p id="ac61" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还研究了10重交叉验证的算法，详细说明了在MATLAB上实现该算法所需的每个步骤。</p><h1 id="4ca5" class="lh li iq bd lj lk ml lm ln lo mm lq lr ls mn lu lv lw mo ly lz ma mp mc md me bi translated">关于我</h1><p id="370a" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">我是约克大学的一名硕士研究生，骨子里是一名软件工程师。在过去的十年里，我一直在软件开发、云计算和系统工程等领域的几个行业工作。目前，我正在研究云计算和分布式系统。</p><p id="16cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你愿意，你可以在我的<a class="ae mk" href="http://jaimedantas.com/" rel="noopener ugc nofollow" target="_blank">网站</a>上查看我的作品。</p><p id="cae8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读！</p><h1 id="de93" class="lh li iq bd lj lk ml lm ln lo mm lq lr ls mn lu lv lw mo ly lz ma mp mc md me bi translated">参考</h1><p id="63b5" class="pw-post-body-paragraph kc kd iq ke b kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz ij bi translated">[1] Randi函数MATLAB。网址:<a class="ae mk" href="https://www.mathworks.com/help/matlab/ref/randi.html#d122e1072277" rel="noopener ugc nofollow" target="_blank">https://www . mathworks . com/help/MATLAB/ref/randi . html # d 122e 1072277</a></p><p id="6e25" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">[2] Shai Shalev-Shwartz和Ben-David。理解机器学习:从理论到算法。剑桥大学出版社，2014年。DOI:10.1017/CBO9781107298019。网址:<a class="ae mk" href="https://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/understanding-machine-learning-theory-algorithms.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cs . huji . AC . il/~ shais/understanding machine learning/understanding-machine-learning-theory-algorithms . pdf</a></p></div></div>    
</body>
</html>