<html>
<head>
<title>Binary Search in Python — Is it Faster?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的二分搜索法——更快吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/binary-search-in-python-is-it-faster-b960c74c3d11?source=collection_archive---------36-----------------------#2020-10-13">https://towardsdatascience.com/binary-search-in-python-is-it-faster-b960c74c3d11?source=collection_archive---------36-----------------------#2020-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b9f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">二进制与线性搜索—实现和性能测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/acf91d57024cff21f585553a816c2ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KKYwSkOEytgtmnrY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@joshuas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·苏考夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一周的时间！你决定深入一个话题，今天我们来看看二分搜索法。</p><p id="00fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，解决同一个问题有很多方法。当你想检查一个元素是否在一个列表中，你可以用线性搜索和二分搜索法来完成，但是猜猜哪个更快。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0475" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么？</h1><p id="2eb0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你最近在Youtube上看过编程工作面试，你就会知道二分搜索法是最受欢迎的。</p><p id="2620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你为什么要花时间去了解二分搜索法呢？你的C++编程朋友可能已经告诉你了。Python很慢。你要确保你的程序不会比需要的速度慢。</p><p id="6017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您学习Python时，您将学习进行线性搜索来检查元素是否在列表中。当你学习编码时，这没问题，但是当你在一个列表中有60.000.000个元素时会发生什么呢？</p><p id="5fa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在一个有11个元素的列表中进行线性搜索，你必须遍历所有的11个元素。如果你使用二分搜索法，根据你要找的东西，你可能最终只有2次迭代。见下图。</p><p id="ef22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪种方法更快应该是显而易见的。</p><p id="6c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您开始学习Python时，您很可能已经处理过上百次列表了。检查值是否在列表中是一项正常的任务，您以前已经看到过这种情况:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5f29" class="ne md it na b gy nf ng l nh ni">my_list = [1,2,3,3,5,11,12]</span><span id="13cc" class="ne md it na b gy nj ng l nh ni">if 11 in my_list:<br/>    return True</span><span id="45e0" class="ne md it na b gy nj ng l nh ni">return False</span></pre><p id="e8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者这个:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1752" class="ne md it na b gy nf ng l nh ni">my_list = [1,2,3,3,5,11,12]</span><span id="9e2e" class="ne md it na b gy nj ng l nh ni">for each in list:<br/>    if each==11:<br/>        return True</span><span id="ad04" class="ne md it na b gy nj ng l nh ni">return False</span></pre><p id="70b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始看看如何实现二分搜索法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="155c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">如何？</strong></h1><p id="fa9a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们想象一下二分搜索法是如何工作的。</p><p id="0107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要确保列表已经排序。你可以用<code class="fe nl nm nn na b">.sort()</code>或者<code class="fe nl nm nn na b">sorted()</code>来排序你的列表，我用<code class="fe nl nm nn na b">.sort()</code>来改变列表的位置。如果你出于某种原因需要一个新的列表或者不想修改原来的列表，使用<code class="fe nl nm nn na b">sorted()</code></p><p id="ca36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的测试材料:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a61e" class="ne md it na b gy nf ng l nh ni">bin_list = [1,2,3,5,6,9,11,12,15,20,22]<br/>search_value_a = 15</span></pre><p id="bb98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将寻找值<strong class="lb iu"> 15 </strong>。</p><ul class=""><li id="5cb1" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">我们的起点。具有最小值和最大值的列表:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/1c58df4a76241be68306945775773dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYDG-W2UOU86L6D8AfZmhw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="bc6a" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">当我们做二分搜索法时，我们从寻找列表中的中间元素开始:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/655af944159fffb30b6c829a1422d686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yv0ijUM0i_cj7f_givfcBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="7c1e" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">中间索引为<code class="fe nl nm nn na b"><strong class="lb iu">5</strong></code>，值为<code class="fe nl nm nn na b"><strong class="lb iu">9</strong></code>。我们想知道的第一件事是<code class="fe nl nm nn na b"><strong class="lb iu">9</strong></code>是否是我们要找的号码。记住，我们找的是<code class="fe nl nm nn na b"><strong class="lb iu">15</strong></code>。如果不是，我们检查它是更低还是更高。在我们的例子中，<code class="fe nl nm nn na b"><strong class="lb iu">9</strong></code>小于15，所以我们需要设置一个新的最小点。我们知道我们不再需要担心名单的下半部分。新的最小点将被设置为列表上部的第一个可能项目。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e3ff77e10e9d6130d3298d8049e3162b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVG3U5d9qsr4D8hh0LyLOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="16a5" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">有了新的中点，我们检查这是否是我们正在寻找的数字。在这种情况下，它是。</li></ul><p id="0fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在寻找<code class="fe nl nm nn na b"><strong class="lb iu">2</strong></code>，并且我们的第一个中间值是<code class="fe nl nm nn na b"><strong class="lb iu">9</strong></code>，你认为算法会如何表现？你说得对。最大指数将会移动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/811255fb67a66473e14d0e5427e9fa9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYnSBG5GGh3VTII9GMmlLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/137bcf27d065e865374a0939e924a6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tahqu6fN04wozoRqOIdy-w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/928b576f8c9cfffa42c9737a3773389c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyH7gi8pRYWkg78CvhcyXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/c1302ce38dd831ce61145fb1329c16ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_v9THBAW44m6KcPitrISkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d7df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码</h1><p id="d5fa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">好吧，我知道你是来编码的。让我们开始吧。</p><p id="fd6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">伪代码将如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8331" class="ne md it na b gy nf ng l nh ni"># create function with list and target as parameters.</span><span id="6385" class="ne md it na b gy nj ng l nh ni"># make sure the list is sorted.</span><span id="8e26" class="ne md it na b gy nj ng l nh ni"># get length of list minus 1 as max and 0 as start.</span><span id="8df7" class="ne md it na b gy nj ng l nh ni"># a loop will:</span><span id="4607" class="ne md it na b gy nj ng l nh ni">    # get the new middle value<br/>    # check if the middle value is higher or lower than the target. <br/>    # move the min or max to the middle after the check. <br/>    # if middle == target, return True<br/>    # if we reach the end of the list, the target is not in the list</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="3d08" class="ne md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">代码的作用:</h2><p id="034f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经创建了一个带有两个参数的函数。一个<code class="fe nl nm nn na b">list</code>和一个<code class="fe nl nm nn na b">target value</code>。目标值是我们正在寻找的数字。列表是我们迭代的列表，寻找数字。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="720d" class="ne md it na b gy nf ng l nh ni">def binary_search(input_list , target_value):</span></pre><p id="ef9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们找到目标值，我们将返回<code class="fe nl nm nn na b">True</code>。如果没有，我们就返回<code class="fe nl nm nn na b">False</code>。</p><p id="557d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做的第一件事是对列表进行排序，并定义列表的最小索引和最大索引。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c926" class="ne md it na b gy nf ng l nh ni">input_list.sort()<br/>min_index = 0<br/>max_index = len(input_list) -1</span></pre><p id="4e2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe nl nm nn na b">len(list)-1</code>的原因是Python从<code class="fe nl nm nn na b">0</code>开始索引。测试列表的长度为<code class="fe nl nm nn na b">11</code>，但最后一个索引为<code class="fe nl nm nn na b">[10]</code>。</p><p id="238b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">现在，让我们来看看大脑的功能，这个循环:</strong></p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="707a" class="ne md it na b gy nf ng l nh ni">while max_index &gt;= min_index:<br/>    mid_index =(max_index+min_index)//2<br/>    if input_list[mid_index] == target_value:<br/>        return True<br/>    elif input_list[mid_index] &lt; target_value:<br/>        min_index = mid_index+1<br/>    else:<br/>        max_index = mid_index-1</span></pre><p id="573b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要最大指数不高于最小指数，我们就继续前进。如果循环停止，这意味着我们已经折叠了列表，所以max小于min。此时，搜索值没有意义，因为没有更多的列表。</p><ul class=""><li id="650f" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe nl nm nn na b">mid</code>设置为<code class="fe nl nm nn na b">max</code>和<code class="fe nl nm nn na b">min</code>的平均值。注意我们如何使用基数除法/整数除法，例如<code class="fe nl nm nn na b">7//2</code>将是<code class="fe nl nm nn na b">3</code>而不是<code class="fe nl nm nn na b">3.5</code>。这样我们总能为我们的索引得到一个干净的整数。</li><li id="48da" class="no np it lb b lc ol lf om li on lm oo lq op lu nt nu nv nw bi translated">如果带有mid索引的列表项的值等于我们的目标值，我们成功了！返回<code class="fe nl nm nn na b">True</code>回家。</li><li id="2695" class="no np it lb b lc ol lf om li on lm oo lq op lu nt nu nv nw bi translated">如果该值小于目标值，我们知道必须将最小索引提高到该点。新的<code class="fe nl nm nn na b">min</code>因此是<code class="fe nl nm nn na b">mid+1</code></li><li id="8cc5" class="no np it lb b lc ol lf om li on lm oo lq op lu nt nu nv nw bi translated">如果该值不等于或小于目标值，则该值较大。这意味着我们可以删除列表的顶部，并降低max指数。<code class="fe nl nm nn na b">max</code>设置为<code class="fe nl nm nn na b">mid-1</code></li></ul><p id="54cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您发现很难理解，您可以在代码中添加一个<code class="fe nl nm nn na b">print()</code>来获得索引跳转的可视化表示。</p><p id="9dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在while循环中的<code class="fe nl nm nn na b">mid_index =(max_index+min_index)//2</code>之后添加:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="064f" class="ne md it na b gy nf ng l nh ni">print (f'min: {min_index} , mid: {mid_index} , max: {max_index}')</span></pre><p id="a03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> main() </strong></p><p id="9b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的主过程包含测试数据和一些断言，以检查一切是否按预期工作。</p><p id="2946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果您想查看搜索失败的示例，我添加了另一种方法来构建列表。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f0f5" class="ne md it na b gy nf ng l nh ni">#bin_list = list(range(6,501))</span></pre><h1 id="f846" class="mc md it bd me mf oq mh mi mj or ml mm jz os ka mo kc ot kd mq kf ou kg ms mt bi translated">但是这样更快吗？</h1><p id="91fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个函数的时间复杂度是O(n ),其中n是列表的长度。为了检查哪种搜索更快，我们可以用线性搜索来计算二分搜索法的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/fdc0478262cf99c100c215c532cdd94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Vzfpb3rMWKI9ySmPg07PA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/portrait-photo-of-woman-holding-up-a-magnifying-glass-over-her-eye-3771107/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@olly?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Andrea Piacquadio </a>的照片</p></figure><p id="91cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要编写一个线性搜索函数:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="397a" class="ne md it na b gy nf ng l nh ni">def linear_search(input_list, target_value):<br/>    for each in input_list:<br/>        if each==target_value:<br/>            return True<br/>    return False</span></pre><p id="6a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们需要编写性能测试，一个针对二进制，一个针对线性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="7864" class="ne md it bd me oa ob dn mi oc od dp mm li oe of mo lm og oh mq lq oi oj ms ok bi translated">陷阱</h2><p id="c94f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你运行上面的代码(与原代码合并)，你会看到线性搜索比<em class="nk">快</em>。这是什么魔法？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/356fa0e785982899f365bf3e9858a542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYJLs9KVdI3OGSa2Rq98OQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">list = [6…500]，target = 15，跑了10.000次。</p></figure><p id="468a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个问题给二进制带来了困难。</p><ul class=""><li id="304d" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">整理</li><li id="89f4" class="no np it lb b lc ol lf om li on lm oo lq op lu nt nu nv nw bi translated">列表长度</li><li id="f27c" class="no np it lb b lc ol lf om li on lm oo lq op lu nt nu nv nw bi translated">低目标值</li></ul><p id="bf2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上所有因素，给了线性一个良好的开端。现在，让我们继续在那里排序，首先改变列表长度:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3da5" class="ne md it na b gy nf ng l nh ni">bin_list = list(range(1,10000))<br/>lin_list = list(range(1,10000))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/1d7bf39b732c30465a6766eee257dead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULFJLvH1ajRB97vaWSR3Cw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">列表= [1…10.000]，目标= 15，运行了10.000次</p></figure><p id="5e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线性搜索还是占了上风。让我们从函数中取出排序，在将列表传递给函数之前对其进行排序。(这对线性搜索不公平，因为线性搜索不依赖于排序列表)。我们所要做的就是注释掉它，因为我们的列表已经排序了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/9662dc0ee3005e5f19d0c1f620a6b80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUzMxB3hP1oW2EOFfUmFvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">list = [1…10.000]，target = 15，运行了10.000次，正在排序</p></figure><p id="c45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">越来越近了。</p><p id="9780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把目标值移到7.500呢？现在，我们的偏见是闪亮的，因为我们真的希望二进制更快。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/352b8627deae10a020cae8f53bc61ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*begoPaGIlPpciaaRR_qtUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">list = [1…10.000]，target=7500，运行了10.000次，正在排序</p></figure><p id="4ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次的差异是极端的。下面的最后一个例子将会使所有的事情变得公平。</p><p id="d388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用随机目标创建一个随机长度的随机列表。然后我们将对这两个函数运行100.000次。</p><p id="fd17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于他们不能分享列表，我们将相信<a class="ae ky" href="https://en.wikipedia.org/wiki/Monte_Carlo_method" rel="noopener ugc nofollow" target="_blank">蒙特卡洛模拟</a>(同时祈祷Macbook不会着火……)</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f955" class="ne md it na b gy nf ng l nh ni">test_list = list(range(1,random.randint(2,50000)))<br/>test_number = random.randint(2,50000)<br/>binary_search(test_list,test_number)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/1ffdf50b3956f4967cc4b2213f6b27f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCX0DH0b5HX4HNFZsLxFJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">list = rand[1…50.000]，target = rand，运行了100.000次，正在排序</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/09c2cb1b659d570620103fa318d92d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anBeJnPTc3jmEcayCfpBCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">list = rand[1…50.000]，target = rand，运行100.000次，排序依据</p></figure><p id="ac35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们运行6000万次！开玩笑，我相信这些结果。MacBooks很贵。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bef8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后</h1><p id="9320" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">二进制比线性快吗？是的，但是它看情况。</p><p id="1a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有人告诉你二分搜索法更快，那是因为它<em class="nk">通常</em>是。</p><p id="89d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，你必须看设置，不要每次都选择单一的解决方案，因为它“是最好的”。</p><p id="5105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从实验中看到，这取决于你在做什么。如果您有一个简短的列表，或者如果您正在查找列表下部的元素，那么执行线性搜索可能会更好。</p><p id="bfdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是编程的妙处。你不应该在不知道<em class="nk">为什么</em>要做某事的情况下使用一种方式。如果你还不知道二分搜索法，现在你又有了一个搜索工具。当你发现它的用处时，就用它。</p><p id="a717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，我希望我们能在一件事上达成一致。二分搜索法非常酷！</p></div></div>    
</body>
</html>