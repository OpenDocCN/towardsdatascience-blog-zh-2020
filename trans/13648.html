<html>
<head>
<title>Serverless Alternative: Executing Python Functions using AWS, Terraform, and Github Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器替代方案:使用AWS、Terraform和Github操作执行Python函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/better-than-serverless-executing-python-functions-with-aws-terraform-and-github-actions-9967509b030f?source=collection_archive---------16-----------------------#2020-09-19">https://towardsdatascience.com/better-than-serverless-executing-python-functions-with-aws-terraform-and-github-actions-9967509b030f?source=collection_archive---------16-----------------------#2020-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b7a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自动化Python函数的部署和执行，而无需担心包的大小、执行时间或可移植性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/43babb676f98faa2f6f6a2094e59cd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yNqQvvxKGiMKzEzQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@agkdesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="e576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么比无服务器更好？无服务器现在很流行，这是有原因的。Serverless是一个简单而强大的云资源，可以执行函数调用，而无需担心底层基础设施。但是每个超级英雄都有他们的克星，最近，我遇到了一些关于AWS Lambda无服务器功能的问题:</p><ol class=""><li id="f355" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">包大小限制:</strong>我的Python依赖项超过了50 MB压缩(和50 MB未压缩)大小限制。</li><li id="d156" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">执行时间限制:我的Python函数花费的时间超过了15分钟的限制。</li><li id="b39b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">缺乏可移植性:</strong> AWS Lambda函数不容易<em class="mj">移植到其他云供应商。</em></li></ol><p id="0c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显而易见的替代方法是提供一个EC2实例来安装依赖项并执行函数，<strong class="lb iu"> <em class="mj">，但是我不希望服务器一直开着</em> </strong>。时间就是金钱，全天候运行的EC2实例需要花费金钱。<strong class="lb iu"> <em class="mj">我不想管理部署，手动打开和关闭实例，执行函数</em> </strong>。<strong class="lb iu"> <em class="mj">我还希望有功能的可移植性，以防我想在不同的云中部署这个功能。</em> </strong></p><p id="0eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mj">最后，我想自动化提供EC2实例、执行Python函数，然后销毁EC2实例和所有底层基础设施的过程。</em> </strong>(如果你只是简单的关闭EC2实例，你会继续为卷付费)。进入Terraform和Github工作流程。</p><p id="70d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Terraform和Github Workflow是任何现代DevOps或云工程师构建和部署应用程序所需的工具。Terraform快速配置云基础设施来执行该功能。Terraform脚本也可以通过改变所使用的服务轻松地移植到其他云供应商。Github工作流管理部署。我们还使用Github存储库来保存Github Workflow使用的所有Terraform和Python代码。</p><p id="ad7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我运行Github操作的视频，展示了该功能是如何执行的，以及Terraform如何在AWS控制台中进行更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Github工作流使用Terraform部署AWS基础架构并执行Python函数</p></figure><h1 id="84f3" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">大纲:</h1><ol class=""><li id="f427" class="lv lw it lb b lc ne lf nf li ng lm nh lq ni lu ma mb mc md bi translated">AWS设置</li><li id="917a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">地形脚本</li><li id="f18b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Github秘密</li><li id="3dfd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Github工作流YAML设置</li><li id="ca12" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">执行Python函数</li><li id="16e5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">结论</li></ol><h2 id="0816" class="nj mn it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">AWS设置</h2><p id="a175" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">第一步是设置AWS，这样我们就有了正确的用户权限和密钥对，用于以后的Terraform脚本编写。这里就不太深究用户权限了。对于本教程，我只是在IAM中创建了一个新用户，并给了我的用户管理权限(我不推荐这样做；您应该始终为用户提供用户完成任务所需的最少量的访问权限)。将访问密钥和秘密密钥复制到某个地方，以便在本教程的后面使用。</p><p id="0bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您希望创建一个PEM密钥，用于terraform脚本和Github工作流访问AWS。在AWS服务主页上，选择“EC2”。在控制台的左侧，选择“密钥对”。在屏幕的右上角，有一个“创建密钥对”的按钮。输入密钥的名称，并选择“PEM”作为文件格式。最后，点击“创建密钥对”按钮来创建PEM密钥。您的浏览器应该会自动下载私钥。把这个钥匙放在容易拿到的地方，因为它是整个过程的一部分。</p><p id="3666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要与您的私钥相对应的公钥。为此，请打开终端，将目录(cd)更改为私钥的位置，并运行以下脚本:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="a833" class="nj mn it nz b gy od oe l of og"><em class="mj">ssh-keygen -e -f aws_private_key.pem &gt; aws_public_key.pem</em></span></pre><p id="6444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本的结果应该输出相应的公钥。您可以将它复制到您喜欢的代码文本编辑器中。这个公钥以后会很重要。</p><blockquote class="oh oi oj"><p id="8df2" class="kz la mj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">注意:我建议在运行Terraform脚本之前测试密钥，方法是创建一个EC2实例，并尝试使用我们刚刚在AWS中创建的PEM密钥SSH到该实例。</p></blockquote><h2 id="86ca" class="nj mn it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">地形脚本</h2><p id="719c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在我们已经正确配置了AWS，我们可以创建Terraform脚本来提供执行Python函数所需的资源:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on ml l"/></div></figure><p id="d801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们包括了一个并不真正需要的S3桶，但是我想提供一些额外的脚本，以防这个资源适用于您的项目。还要注意，我们在上一步中创建的公钥可以输入到“<the rest="" of="" your="" public="" key="">”中。出口和入口规则是不安全的，它们允许任何具有有效凭证的人连接到实例。但是由于本教程的目的是提供一个例子，所以我还没有正确配置安全性。我选择了一个随机的AMI，但是要确保为您的工作负载找到正确的映像。</the></p><blockquote class="oh oi oj"><p id="9163" class="kz la mj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">注意:我建议在创建Github工作流之前，在您的本地机器上测试运行terraform脚本。在成功初始化Terraform之前，我在Mac桌面上创建了一个文件夹，并在Bash配置文件中添加了Terraform可执行文件的路径。您可以在您的终端上运行本教程稍后定义的与Terraform相关的Github工作流操作。请<a class="ae ky" href="https://www.terraform.io/downloads.html" rel="noopener ugc nofollow" target="_blank">使用此链接安装Terraform </a>。</p></blockquote><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b52a" class="nj mn it nz b gy od oe l of og">export PATH=/path/to/terraform/executable:$PATH</span></pre><blockquote class="oh oi oj"><p id="ee2e" class="kz la mj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">注意:如果你对Terraform完全陌生，我推荐<a class="ae ky" href="https://www.linkedin.com/learning-login/share?forceAccount=false&amp;redirect=https%3A%2F%2Fwww.linkedin.com%2Flearning%2Flearning-terraform-2%3Ftrk%3Dshare_ent_url&amp;account=42751868" rel="noopener ugc nofollow" target="_blank">这个关于Terraform的LinkedIn学习课程</a>。</p></blockquote><h2 id="26a6" class="nj mn it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">Github秘密</h2><p id="512e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在使用Github工作流运行terraform脚本之前，我们需要用一些与AWS和Terraform相关的键来设置Github secrets。以下是我的秘密的截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/0a04b60c4c40ff5f4405e199154d9ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WD4lXVSGs--zv3vt0URQxg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的Github回购秘密</p></figure><p id="bf0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“SSH_KEY”秘密包含在EC2控制台上创建密钥对时自动下载的私有AWS密钥。您可以通过输入以下命令来输出私钥值:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="c53f" class="nj mn it nz b gy od oe l of og">cat aws_private_key.pem</span></pre><p id="d774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所需的“TF_API_TOKEN”密钥是用于Github工作流将用来执行脚本的Terraform API的。使用<a class="ae ky" href="https://www.terraform.io/docs/cloud/users-teams-organizations/api-tokens.html" rel="noopener ugc nofollow" target="_blank">此链接</a>访问Hashicorp Terraform API令牌(您可能需要创建一个帐户)。</p><h2 id="8466" class="nj mn it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">Github工作流YAML设置</h2><p id="4126" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">既然我们的Github秘密已经正确配置，我们可以在Github工作流中创建YAML文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on ml l"/></div></figure><p id="d11f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在高层次上，当这个YAML在Github存储库的新推送上执行时，一个新的“runner”被创建，这是在Github主机上新创建的虚拟环境，它“运行”在您定义的操作系统上。然后它寻求并行完成<strong class="lb iu"> <em class="mj">定义的所有“作业”</em> </strong>。在这种情况下，我只有一个作业，因此所有的“步骤”(由“动作”组成)都按顺序完成<strong class="lb iu"><em class="mj"/></strong>。每个“步骤”都建立在另一个步骤的基础上，这意味着在前面步骤中所做的任何更改都可以被未来的步骤所访问。现在，每个“步骤”中完成的一些“操作”使用了预定义的操作，这些操作是由其他人创建的，可以导入。在本教程中，我使用了4个动作。Github工作流语法令人困惑。我建议花些时间理解我引用的关键术语。</p><blockquote class="oh oi oj"><p id="e2ad" class="kz la mj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">注意:这是对Github动作的一个很好的介绍。我还推荐LinkedIn Learning上的这个Github Actions课程<a class="ae ky" href="https://www.linkedin.com/learning-login/share?forceAccount=false&amp;redirect=https%3A%2F%2Fwww.linkedin.com%2Flearning%2Flearning-github-actions-2%3Ftrk%3Dshare_ent_url&amp;account=42751868" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="4ba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">YAML文件命令非常密集<strong class="lb iu"> <em class="mj">，所以我将从顶部开始向下关注代码的一些细微差别和特性</em> </strong>:</p><ul class=""><li id="8a22" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu op mb mc md bi translated">在第42行，我们必须更改密钥的权限，以便以后将它们用于SCP和SSH。</li><li id="3a28" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu op mb mc md bi translated">在第53行，我们必须将私钥导入Terraform，然后才能在AWS上提供基础设施。</li><li id="8fb1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu op mb mc md bi translated">在第59行，我使用“自动批准”来自动创建基础架构。如果您尝试在没有“自动批准”的情况下运行此命令，终端需要“是”来创建基础架构。</li><li id="284b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu op mb mc md bi translated">在第62行和第65行，我们正在设置未来步骤中需要的环境变量。第62行的命令以JSON格式存储Terraform创建的基础设施。然后，第65行的Python脚本遍历JSON文本，并为EC2公共ip地址创建一个变量，稍后我们将使用SSH访问这个变量。每次我们运行这个工作流时，都会创建一个具有不同公共IP地址的新EC2实例。因此，我们需要一个脚本来获取公共IP地址，稍后我们将SSH和SCP连接到这个地址。</li></ul><p id="435a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我在YAML中称之为“tf_parse.py”的Python脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on ml l"/></div></figure><ul class=""><li id="f93a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu op mb mc md bi translated">第71行可能有很多令人挠头的地方。为什么会有人给工作流程增加时间？这花了我最长的时间来调试。我的假设是，一旦Terraform完成了基础设施，我就可以对实例使用SSH和SCP。  <strong class="lb iu"> <em class="mj">我错了。在运行后续命令之前，您需要一些时间来初始化EC2实例。我增加了20秒，但这可能需要更多或更少的时间，具体取决于您所调配的实例类型。</em></strong></li><li id="9c14" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu op mb mc md bi translated">在第78和79行，我添加了一些额外的参数来防止终端请求授权来添加主机名。如果您喜欢更好的可读性，可以使用以下函数:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on ml l"/></div></figure><blockquote class="oh oi oj"><p id="a209" class="kz la mj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">注意:通过在YAML文件中输入以下命令来使用上述函数:</p></blockquote><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="e5c3" class="nj mn it nz b gy od oe l of og">sshtmp -i <em class="mj">aws_key_pair.pem </em><a class="ae ky" href="mailto:ec2-user@ec2-$aws_compute_public_ip.compute-1.amazonaws.com" rel="noopener ugc nofollow" target="_blank"><em class="mj">ec2-user@ec2-$aws_compute_public_ip.compute-1.amazonaws.com</em></a></span></pre><ul class=""><li id="d629" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu op mb mc md bi translated">最后，第83行的命令防止Terraform在下一步中破坏aws_key_pair。<a class="ae ky" href="https://stackoverflow.com/questions/55265203/terraform-delete-all-resources-except-one#:~:text=It%20doesn't%20destroy%20the,It%20will%20destroy%20the%20rest." rel="noopener ugc nofollow" target="_blank">这里有一个有用的资源</a>输出所有的地形状态，以防你想防止其他资源的破坏。</li></ul><h2 id="6383" class="nj mn it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">执行Python函数</h2><p id="f0e2" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">Python函数正在AWS EC2实例 的第80行<strong class="lb iu"> <em class="mj">上执行。对于本教程，我正在执行一个基本的Python函数，但是没有限制。如果您想在运行脚本之前安装一些依赖项，请查看我上一篇关于在AWS上创建CI/CD管道的文章中的YAML文件的第50行及以上内容。</em></strong></p><blockquote class="oh oi oj"><p id="9183" class="kz la mj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">注意，依赖项需要安装在EC2实例上，而不是Github工作流“runner”上。</p></blockquote><h2 id="0d78" class="nj mn it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">结论</h2><p id="9662" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">本教程展示了如何使用AWS、Terraform和Github工作流自动部署和执行Python函数。我们强调了无服务器功能的一些问题，以及这种工作流程如何成为合理的替代品。然而，重要的是要记住，我们为Terraform启动的EC2实例运行的时间付费。与简单地执行无服务器功能相比，使用Terraform提供实例和运行功能也需要更长的时间。请记住，每次我们想要执行该功能时，我们都必须提供底层基础设施。</p><p id="b83e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更喜欢Terraform和Github Worflow的另一个原因是因为AWS Lambda函数缺乏可移植性。一旦使用了Lambda函数，就很难将它转移到其他地方。这部分是由于Lambda函数返回、Lambda处理程序、层和其他配置的语法限制。此外，利用AWS API Gateway来调用该函数进一步阻止了向其他云供应商的移植。Terraform使得在另一个云厂商中找到相应的服务和部署工作流变得更加容易。无服务器功能仍然是在云中创建可伸缩服务的强大工具，但也有明显的缺陷和缺点。</p><p id="10c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种基础设施创建和部署的结构还能带来哪些可能性？用这个工作流管理不频繁的、对时间不敏感的服务怎么样？通过对本教程的一些修改，我们为应用服务器、负载平衡器、S3存储桶创建并部署底层基础设施，然后在服务完成时销毁这些实例。这对于任何拥有大型数据密集型应用程序、寻求有效方法来降低开发和测试环境甚至生产成本的初创公司来说都可能是至关重要的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.buymeacoffee.com/arshyasharifian"><div class="gh gi oq"><img src="../Images/9feb2f59889762b163b5adb2600d8f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7fPIkcYCVESpBrkCPdEuQ.png"/></div></a></figure><h2 id="b8d0" class="nj mn it bd mo nk nl dn ms nm nn dp mw li no np my lm nq nr na lq ns nt nc nu bi translated">子堆栈:</h2><p id="b9b4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我最近创建了一个<a class="ae ky" href="https://arysharifian.substack.com/" rel="noopener ugc nofollow" target="_blank">子栈</a>来学习如何用Python编程和解决LeetCode问题。</p></div></div>    
</body>
</html>