<html>
<head>
<title>The ultimate String Super Skills you must have: REGEX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你必须拥有的终极字符串超级技能:REGEX</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/best-string-super-skills-you-must-have-regex-2f5ecbfd2bca?source=collection_archive---------42-----------------------#2020-10-29">https://towardsdatascience.com/best-string-super-skills-you-must-have-regex-2f5ecbfd2bca?source=collection_archive---------42-----------------------#2020-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过这个超级简单的介绍，摆脱Python中文本字符串处理问题的困扰。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0e7ec754e705923399e8548072887f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zEy9sQKv2HgJccJQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理数据时，总是有可能不得不处理文本。做好准备，当时机到来时，在Python中一个强大的朋友的帮助下，您将会很好地发现、处理和处理字母数字字符串。</p><p id="9816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我说的是<strong class="lb iu"> REGEX </strong>。Regex代表正则表达式，它描述了一个特殊的字符序列，用于搜索和操作文本字符串中的单词、数字或其他字符。</p><p id="1578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇介绍性的内容旨在为您提供一个很好的方法，并为您提供一些(更多的)初步知识，这些知识对于您熟悉Regex是必不可少的。</p><p id="36ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Regex是如此强大、庞大和复杂，我敢打赌，您也将分享同样的观点，即无限多的pythonic可能性展现在我们面前。让我们来看看一些基本命令。</p><p id="2cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，除了Pandas，让我们导入<code class="fe lv lw lx ly b"><strong class="lb iu">re</strong></code>模块，解锁python中所有与Regex相关的内容。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2212" class="md me it ly b gy mf mg l mh mi">import pandas as pd<br/>import re</span></pre><p id="9805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要定义一个文本，我们将在这篇文章的一些例子上工作。</p><p id="79d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择了Mat Velloso写的一句话，以一种非常好奇的方式试图用简单的术语来区分机器学习和人工智能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/1506b5e75b5015be278115870e481c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YUz6wygw4gx58pP-1ujUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Mat Velloso是微软首席执行官的技术顾问，也是开发者的忠实拥护者。<a class="ae ky" href="https://twitter.com/matvelloso" rel="noopener ugc nofollow" target="_blank">https://twitter.com/matvelloso</a></p></figure><p id="98b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们剪切并坚持较短的文本部分，使其更简单:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="47b7" class="md me it ly b gy mf mg l mh mi">text = "If it is written in PYTHON, it's probably machine learning"<br/></span></pre><h1 id="5950" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">re.findall()</h1><p id="bccb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">re</code>模块有一组函数，允许我们搜索、返回和替换一个字符串或字符串的任何部分。我们从<strong class="lb iu"> findall() </strong>函数开始，它返回一个包含所有事件的列表。</p><p id="9366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'.*PYTHON', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5c1d" class="md me it ly b gy mf mg l mh mi">['If it is written in PYTHON']<br/></span></pre><p id="ad21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解:首先，<code class="fe lv lw lx ly b">findall() </code>函数按照它找到的顺序返回一个事件列表。其次，<code class="fe lv lw lx ly b"><strong class="lb iu">‘r’</strong></code>是在开始时确保字符串被视为“原始字符串”。</p><p id="28f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移动到<code class="fe lv lw lx ly b">‘.*PYTHON’</code>部分。我们希望返回所有内容，直到单词PYTHON，inclusive。因此，<code class="fe lv lw lx ly b"><strong class="lb iu">.*</strong></code>是某种王牌符号，从某种意义上说，<code class="fe lv lw lx ly b"><strong class="lb iu">*</strong></code>将所有内容重复零次或更多次，直到它找到星星，而<code class="fe lv lw lx ly b"><strong class="lb iu">.</strong></code>告诉星星返回它找到的所有内容，无论是字母、数字、符号还是空格。</p><p id="b030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们颠倒命令，我们会收到句子的另一半，请看一个例子。</p><p id="fc90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'PYTHON.*', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7c18" class="md me it ly b gy mf mg l mh mi">["PYTHON, it's probably machine learning"]<br/></span></pre><p id="f505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe lv lw lx ly b">re.flags</code>设置为ignore-case，以便它匹配出现的大小写。</p><p id="6f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall('python.*',text, flags=re.IGNORECASE)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="45e9" class="md me it ly b gy mf mg l mh mi">["PYTHON, it's probably machine learning"]</span></pre><p id="8fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这一点开始，我们可以建立一系列的可能性。</p><p id="91af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'written.*machine', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1f1a" class="md me it ly b gy mf mg l mh mi">["written in PYTHON, it's probably machine"]<br/></span></pre><p id="24ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'tt.*bl', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f9a8" class="md me it ly b gy mf mg l mh mi">["tten in PYTHON, it’s probabl"]<br/></span></pre><p id="c726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来看看其他符号，这些符号用于检查字符串<strong class="lb iu">是否以</strong>、(符号<code class="fe lv lw lx ly b"><strong class="lb iu">^</strong></code>)或<strong class="lb iu">开始，以特定字符</strong>(符号<code class="fe lv lw lx ly b"><strong class="lb iu">$</strong></code>)结束。</p><ul class=""><li id="e1cd" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">^</strong></code>评估并匹配字符串的开头(与<code class="fe lv lw lx ly b"><strong class="lb iu">\A</strong></code>相同)</li><li id="7a66" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">\w+</strong></code>匹配并返回字符串中的字母数字字符</li></ul><p id="bbba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们去掉符号<code class="fe lv lw lx ly b"><strong class="lb iu">+</strong></code>，我们只收到第一个字符。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="65cd" class="md me it ly b gy mf mg l mh mi">text = "If it is written in PYTHON, it's probably machine learning"<br/></span></pre><p id="6bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'^\w+', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8a1e" class="md me it ly b gy mf mg l mh mi">['If']</span></pre><p id="4750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall('learning$', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ddb7" class="md me it ly b gy mf mg l mh mi">['learning']</span></pre><p id="296c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不匹配，我们会收到一个空列表。</p><p id="2ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一个字符尽可能匹配时，它就被认为是贪婪的。符号<code class="fe lv lw lx ly b"><strong class="lb iu">?</strong></code>检查下一个字符是否从该精确位置开始匹配0次或1次。意思是它指定了一个非贪婪版本的<code class="fe lv lw lx ly b"><strong class="lb iu">*</strong></code> <strong class="lb iu"> </strong>和<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b"><strong class="lb iu">+</strong></code>。</p><p id="9777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r' .*? ', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bf38" class="md me it ly b gy mf mg l mh mi">[' it ', ' written ', ' PYTHON, ', ' probably ']</span></pre><p id="05a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符<strong class="lb iu">大括号</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">{b,n}</strong></code> <strong class="lb iu"> </strong>用于当我们想要检查至少<code class="fe lv lw lx ly b"><strong class="lb iu">b</strong></code> <strong class="lb iu"> </strong>次，并且最多<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b"><strong class="lb iu">n</strong></code> <strong class="lb iu"> </strong>次的图案时。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="dd5f" class="md me it ly b gy mf mg l mh mi">text = "If it is written in PYTHON, it's probably machine learning"<br/></span></pre><p id="b0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'(t{1,4}|i{1,})', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="264a" class="md me it ly b gy mf mg l mh mi">['i', 't', 'i', 'i', 'tt', 'i', 'i', 't', 'i', 'i']</span></pre><p id="4c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个例子中(如下)，我们要求检查至少1个<code class="fe lv lw lx ly b"><strong class="lb iu">t</strong></code> <strong class="lb iu"> </strong>和最多4个<code class="fe lv lw lx ly b"><strong class="lb iu">t </strong></code>，我们得到了这个精确的结果。</p><p id="bb90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，我们还检查了至少1个<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b"><strong class="lb iu">e</strong></code> <strong class="lb iu"> </strong>和最多3个<code class="fe lv lw lx ly b"><strong class="lb iu">e</strong></code>，但是正如您所看到的，一行中有4个<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b"><strong class="lb iu">e</strong></code> <strong class="lb iu"> </strong>，这意味着这4个<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b"><strong class="lb iu">e</strong></code>将被分成3个一组，这就是我们得到剩余的单个<code class="fe lv lw lx ly b"><strong class="lb iu">e</strong></code> <strong class="lb iu"> </strong>的原因。</p><p id="a7ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'(t{1,4}|e{1,3})', 'listttt compreheeeension')<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7360" class="md me it ly b gy mf mg l mh mi">['tttt', 'e', 'eee', 'e']</span></pre><p id="798f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu">方括号</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">[]</strong></code>指定我们想要匹配的一组字符。比如<code class="fe lv lw lx ly b"><strong class="lb iu">[abc]</strong></code>和<code class="fe lv lw lx ly b"><strong class="lb iu">a</strong></code>有1个匹配，和<code class="fe lv lw lx ly b"><strong class="lb iu">cab</strong></code>有3个匹配，和<code class="fe lv lw lx ly b"><strong class="lb iu">hello</strong></code>没有匹配。</p><p id="1b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以使用方括号内的(符号<code class="fe lv lw lx ly b"><strong class="lb iu">-</strong></code>)来指定值的范围。因此，<code class="fe lv lw lx ly b"><strong class="lb iu">[a-d]</strong></code>与<code class="fe lv lw lx ly b"><strong class="lb iu">[abcd]</strong></code>相同，范围<code class="fe lv lw lx ly b"><strong class="lb iu">[1-4]</strong></code>与<code class="fe lv lw lx ly b"><strong class="lb iu">[1234]</strong></code>相同，以此类推。</p><p id="af38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照同样的推理，范围<code class="fe lv lw lx ly b"><strong class="lb iu">[a-z]</strong></code>匹配任何小写字母，范围<code class="fe lv lw lx ly b"><strong class="lb iu">[A-Z]</strong></code>匹配任何大写字母。如果设置了<code class="fe lv lw lx ly b"><strong class="lb iu">[a-zA-Z]</strong></code> <strong class="lb iu"> </strong>的组合，我们就同时检查上下两种情况。让我们用一些例子来试试。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="eacd" class="md me it ly b gy mf mg l mh mi"># assigning new text<br/>alpha_num = "Hello 1234"</span></pre><p id="9af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'[a-z]', 'alpha_num')<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d778" class="md me it ly b gy mf mg l mh mi">['e', 'l', 'l', 'o']</span></pre><p id="1df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'[a-zA-Z]', 'Hello 1234')<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="de27" class="md me it ly b gy mf mg l mh mi">['H', 'e', 'l', 'l', 'o']</span></pre><p id="e89a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'[a-zA-Z0-9]', 'Hello 1234')<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ebd2" class="md me it ly b gy mf mg l mh mi">['H', 'e', 'l', 'l', 'o', '1', '2', '3', '4']</span></pre><p id="7737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们加上符号<code class="fe lv lw lx ly b"><strong class="lb iu">+</strong></code>，会发生什么？</p><p id="d9d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'[a-zA-Z0-9]+', 'Hello 1234')<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="bc23" class="md me it ly b gy mf mg l mh mi">['Hello', '1234']</span></pre><p id="11d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:如果集合内的第一个字符是<code class="fe lv lw lx ly b"><strong class="lb iu">^</strong></code>，那么集合外的所有字符都将被匹配。</p><p id="b6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall(r'[^a-zA-Z ]+', 'Hello 1234')<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2510" class="md me it ly b gy mf mg l mh mi">['1234']</span></pre><p id="653f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些对你来说有意义吗？厉害！</p><p id="f1fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在来说说<strong class="lb iu">特殊序列</strong>。这些用反斜杠<code class="fe lv lw lx ly b"><strong class="lb iu">\</strong></code>写，后跟所需的字符(及其含义)。</p><ul class=""><li id="521e" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">\ w</strong>——如前所述，返回字符串包含字母、数字和下划线的匹配项</li><li id="389e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">\ W</strong>-返回每个非字母数字字符</li><li id="abcf" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">\ d</strong>-返回一个匹配项，其中字符串包含从0到9(0–9)的数字。</li></ul><p id="18e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果星号<code class="fe lv lw lx ly b"><strong class="lb iu">*</strong></code>重复所有事情零次或更多次，符号<code class="fe lv lw lx ly b"><strong class="lb iu">+</strong></code>重复所有事情一次或更多次。那么有什么区别呢？让我们创建另一个字符串来举例说明，并仔细看看。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="026b" class="md me it ly b gy mf mg l mh mi"># assigning new text<br/>letters_numbers = "The letter A, the character * and the numbers 11, 222 and 3456."</span></pre><p id="b256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall('\w', letters_numbers)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2edb" class="md me it ly b gy mf mg l mh mi">['T', 'h', 'e', 'l', 'e', 't', 't', 'e', 'r', 'A', 't', 'h', 'e', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', 'a', 'n', 'd', 't', 'h', 'e', 'n', 'u', 'm', 'b', 'e', 'r', 's', '1', '1', '2', '2', '2', 'a', 'n', 'd', '3', '4', '5', '6']</span></pre><p id="c9dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，如果我们加上符号<code class="fe lv lw lx ly b"><strong class="lb iu">+</strong></code>，会有什么不同？</p><p id="847b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall('\w+', letters_numbers)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e77c" class="md me it ly b gy mf mg l mh mi">['The', 'letter', 'A', 'the', 'character', 'and', 'the', 'numbers', '11', '222', 'and', '3456']</span></pre><p id="fade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall('\W', letters_numbers)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="167a" class="md me it ly b gy mf mg l mh mi">[' ', ' ', ',', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ',', ' ', ' ', ' ', '.']</span></pre><p id="3b59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅提取数字:</p><p id="e7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall('\d+', letters_numbers)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a6d0" class="md me it ly b gy mf mg l mh mi">['11', '222', '3456']</span></pre><p id="b2c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall('\d{3,}', letters_numbers)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d52d" class="md me it ly b gy mf mg l mh mi">['222', '3456']</span></pre><p id="752c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们想从两个元素组成的字符串中只提取大写单词。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e834" class="md me it ly b gy mf mg l mh mi">upper_extract = "Regex is very NICE for finding and processing text in PYTHON"</span></pre><p id="e800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.findall('([A-Z]{2,})', upper_extract)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7c52" class="md me it ly b gy mf mg l mh mi">['NI', 'CE', 'PY', 'TH', 'ON']</span></pre><h1 id="ecdc" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">重新拆分()</h1><p id="1d30" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">split方法非常方便，因为它在找到匹配项时会拆分字符串，并返回精确拆分后的字符串列表。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3733" class="md me it ly b gy mf mg l mh mi">numbers = 'The air we breath is made up of 78% nitrogen, 21% oxygen and 1% of other stuff.'</span></pre><p id="a06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.split(r'\d+', numbers)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="81b2" class="md me it ly b gy mf mg l mh mi">['The air we breath is made up of ', '% nitrogen, ', '% oxygen and ', '% of other stuff.']</span></pre><p id="73bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果模式不匹配，则返回原始字符串。</p><p id="6226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个有用的资源是设置可能发生的最大拆分。我们可以通过将<code class="fe lv lw lx ly b">maxsplit</code>参数传递给<code class="fe lv lw lx ly b">re.split()</code>方法来进行设置。</p><p id="f6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.split(r'\d+', numbers, 1)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="db92" class="md me it ly b gy mf mg l mh mi">['The air we breath is made up of ', '% nitrogen, 21% oxygen and 1% of other stuff.']</span></pre><p id="90ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个示例中，只在第一次出现的五个空格处设置拆分。</p><p id="cb47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.split(r'\s', numbers, 5)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0ad7" class="md me it ly b gy mf mg l mh mi">['The', 'air', 'we', 'breath', 'is', 'made up of 78% nitrogen, 21% oxygen and 1% of other stuff.']</span></pre><h1 id="a61d" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">re.sub()</h1><p id="e22a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Sub代表SubString，使用这个方法，您可以在任何时候用任何文本替换任何匹配。</p><p id="4713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法很简单:<code class="fe lv lw lx ly b">re.sub(pattern, replacement, string)</code>。</p><p id="73a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以添加其他参数，例如替换发生的最大次数、区分大小写等。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="17a2" class="md me it ly b gy mf mg l mh mi">text = "If it is written in PYTHON, it's probably machine learning"<br/></span></pre><p id="69df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.sub(r'written', 'coded', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="9c27" class="md me it ly b gy mf mg l mh mi">If it is <strong class="ly iu">coded</strong> in PYTHON, it's probably machine learning</span></pre><p id="ae12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.sub(r'it', 'THAT', text) print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ce0e" class="md me it ly b gy mf mg l mh mi">If <strong class="ly iu">THAT</strong> is wr<strong class="ly iu">THAT</strong>ten in PYTHON, <strong class="ly iu">THAT</strong>'s probably machine learning<br/></span></pre><p id="040f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个例子中，我们想要的是用“THAT”替换“it ”,但只在第一次出现时。</p><p id="ee97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.sub(r'it', 'THAT', text, count=1)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2071" class="md me it ly b gy mf mg l mh mi">If <strong class="ly iu">THAT</strong> is written in PYTHON, it's probably machine learning</span></pre><p id="8f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个示例中，将通过单词“PYTHON”前后的空格进行拆分，并替换为“code”。如果我们以这种方式键入“PYthon ”,那么设置ignore-case so并不重要。</p><p id="1077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.sub(r’\sPYthon,\s’, ‘ code, ‘, text, flags=re.IGNORECASE)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f34c" class="md me it ly b gy mf mg l mh mi">If it is written in <strong class="ly iu">code</strong>, it's probably machine learning<br/></span></pre><h1 id="1168" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">re.subn()</h1><p id="caab" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe lv lw lx ly b">re.subn()</code>产生与<code class="fe lv lw lx ly b">re.sub()</code>相同的结果，除了它返回替换的数量。</p><p id="2401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">rx = re.subn(r'it', 'THAT', text)<br/>print(rx)</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8c02" class="md me it ly b gy mf mg l mh mi">("If <strong class="ly iu">THAT</strong> is wr<strong class="ly iu">THAT</strong>ten in PYTHON, <strong class="ly iu">THAT</strong>'s probably machine learning", 3) </span></pre><p id="273f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，我相信你会发现这些也很有趣。</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/pandas-made-easy-the-guide-i-81834f075893"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">熊猫变得容易(指南— I)</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">有许多最常用的函数和方法的例子</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/machine-learning-costs-prediction-of-a-marketing-campaign-exploratory-data-analysis-part-i-758b8f0ff5d4"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">机器学习:营销活动的成本预测(探索性数据分析——第一部分)</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">预测营销活动最佳目标候选人的数据科学方法</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><h1 id="40e2" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="76a5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">作为Regex能力的初步探索，我猜想到现在为止，在处理字母数字字符串时，您会更多地考虑应用这些技术。</p><p id="ab90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Regex将对您在Python上的工作效率产生巨大影响，所以我希望您继续研究并投入一些时间，因为一旦您对它感到满意，您就会意识到几乎有无限的可能性，只有天空才是极限。</p><p id="853c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随时和我联系，我会很高兴的。谢谢大家！</p><h1 id="9614" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">联系人</h1><ul class=""><li id="68b5" class="ng nh it lb b lc nb lf nc li on lm oo lq op lu nl nm nn no bi translated"><a class="ae ky" href="http://bit.ly/2ybRqYT" rel="noopener ugc nofollow" target="_blank"> Linkedin </a></li><li id="41fa" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://bit.ly/3gAwMTP" rel="noopener ugc nofollow" target="_blank">推特</a></li><li id="1ee8" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://bit.ly/3gDC5Sp" rel="noopener ugc nofollow" target="_blank">中等</a></li><li id="0012" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://bit.ly/3hHvuHR" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li><li id="903a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://bit.ly/31Co038" rel="noopener ugc nofollow" target="_blank">卡格尔</a></li><li id="1dc6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="mailto:goncaloggomes@gmail.com" rel="noopener ugc nofollow" target="_blank">电子邮件</a></li></ul><p id="c6ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的阅读，伟大的编码！</p></div></div>    
</body>
</html>