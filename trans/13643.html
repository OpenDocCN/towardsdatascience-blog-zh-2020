<html>
<head>
<title>A Python Library to Generate a Synthetic Time Series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成合成时间序列数据的Python库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tsbngen-a-python-library-to-generate-time-series-data-from-an-arbitrary-dynamic-bayesian-network-4b46e178cd9f?source=collection_archive---------11-----------------------#2020-09-19">https://towardsdatascience.com/tsbngen-a-python-library-to-generate-time-series-data-from-an-arbitrary-dynamic-bayesian-network-4b46e178cd9f?source=collection_archive---------11-----------------------#2020-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d54c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">tsBNgen:一个Python库，用于从任意动态贝叶斯网络结构中生成时间序列数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4fbcafb32a721f0898fc8335460974ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uaClxKyds57MFNB2"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@behz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Behzad Ghaffarian </a>拍摄的照片</p></figure><p id="b9c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">合成数据广泛应用于各个领域。这是因为许多现代算法需要大量数据来进行有效的训练，而数据收集和标记通常是一个耗时的过程，并且容易出错。此外，一些真实世界的数据，由于其性质，是保密的，不能共享。</p><p id="1484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提出了生成对抗网络等方法来生成时间序列数据。然而，GAN难以训练并且可能不稳定；此外，它需要大量的数据来进行有效的训练。</p><p id="47de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将介绍一个python库<strong class="ky ir"> tsBNgen </strong>，它基于任意的动态贝叶斯网络结构生成合成时间序列数据。</p><p id="1086" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然<strong class="ky ir"> tsBNgen </strong>主要用于生成时间序列，但是通过将时间序列的长度设置为1，它也可以生成横截面数据。</p><p id="8c8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是本文中讨论的主题列表。</p><ul class=""><li id="dc19" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">简介</strong></li><li id="b463" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">特性</strong></li><li id="e1a9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">指令</strong></li><li id="03b0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">示例</strong></li><li id="16a7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">结论</strong></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/ebf8a5c851d6b4c9c82949202f9b1573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Do5Q_lJsK6ThW9HU"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@miroslava?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米洛丝拉娃</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="0bfb" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated"><strong class="ak">简介</strong></h1><p id="0147" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">tsBNgen 是在MIT许可下发布的python包，用于从任意贝叶斯网络结构中生成时间序列数据。贝叶斯网络是一种广泛用于对现实世界过程中的不确定性建模的概率图形模型。动态贝叶斯网络(DBNs)是一类特殊的贝叶斯网络，用于对时间和时间序列数据进行建模。</p><p id="858c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">贝叶斯网络在教育和医学等领域受到了广泛的关注。例如，在中，作者使用HMM(DBN的一种变体)来预测学生在教育视频游戏中的表现。有向图模型(贝叶斯网络)的一个显著优点是，它们可以表示图中节点之间的因果关系；因此，它们提供了一种直观的方法来模拟现实世界的过程。一旦专家确定了图形结构，这种说法使得<strong class="ky ir"> tsBNgen </strong>成为生成数据的非常有用的软件。从某种意义上说，与GAN等数据驱动的方法不同，tsBNgen是一种基于模型的方法。</p><p id="f1a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解关于这个包、文档和例子的更多信息，请访问下面的GitHub资源库。</p><div class="ne nf gp gr ng nh"><a href="https://github.com/manitadayon/tsBNgen" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">马尼塔代翁/茨布恩根</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">描述说明tsBNgen是一个Python包，基于任意贝叶斯网络生成时间序列数据…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div><p id="d83f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近在YouTube上制作了一系列视频来使用这个包。这些视频也在我的GitHub页面上，你可以在这里观看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d5cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我尝试详细检查贝叶斯网络和tsBNgen包。如果你有任何问题或意见，你可以在我的YouTube频道问我。</p><h1 id="3870" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">特征</h1><p id="3ec8" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">以下是<strong class="ky ir"> tsBNgen </strong>支持的特性和功能列表:</p><ol class=""><li id="1167" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ny ly lz ma bi translated">简单易用的界面。</li><li id="2f7d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated">支持离散、连续和混合网络(离散和连续节点的混合)。</li><li id="0ec2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated">对连续节点使用多项式分布和高斯分布支持离散节点。</li><li id="9fd2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated">支持任意环回(时间连接)值的时间依赖性。</li><li id="cc52" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated">易于修改和扩展代码以支持新的结构。</li><li id="86d3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated">基于模型的方法，一旦知道了因果结构，就可以生成综合数据。</li></ol><h1 id="7ed4" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated"><strong class="ak">指令</strong></h1><p id="c58e" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">要使用<strong class="ky ir"> tsBNgen </strong>，要么克隆上述存储库，要么使用以下命令安装软件:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="f8ec" class="oe mi iq oa b gy of og l oh oi">pip install tsBNgen</span></pre><p id="2640" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">软件成功安装后，发出以下命令导入所有函数和变量。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="55ad" class="oe mi iq oa b gy of og l oh oi">from tsBNgen import * <br/>from tsBNgen.tsBNgen import *</span></pre><p id="0c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是你利用软件中存在的所有功能所需要的。</p><h1 id="2911" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated"><strong class="ak">例子</strong></h1><p id="57da" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在查看一些示例之前，让我定义以下参数，这些参数将在本节中使用。<br/> <strong class="ky ir">注</strong>:以下描述、表格(作为图像的一种形式)、图像均由作者从本文中获得。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/8239f78b7a6f4161a52a56780b999127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kilBkZI6fum-EP7aUerfw.jpeg"/></div></div></figure><p id="0345" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ok">例1 </em> </strong></p><p id="1d51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您想要为图1中的以下架构生成数据，这是一个HMM结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/4abf2aeb5d0a3e7935773f395999316b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJqn6Hgx_cq52BepHV-A1g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。(作者供图)</p></figure><p id="cdd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顶层节点被称为状态，下面的节点被称为观察。在HMM中，状态是离散的，而观察值可以是连续的，也可以是离散的。下表总结了图1的参数设置和概率分布。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/234d2bbe0588cd12371d7a306383852c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GpRWqwDSXROn9cBTv--Sg.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/a775383f5ebcfd4aba8ba617cee91460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSzSRsO06paMvGOV232yoQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">t时刻所有节点的条件概率分布(作者供图)</p></figure><p id="b59a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在表1中，T是指时间序列的长度，N是指样本数，loopback决定了时间连接的长度。例如，loopback值为1意味着一个节点在以前连接到一些其他节点。</p><p id="f47e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注</strong> : <strong class="ky ir"> tsBNgen </strong>可以通过设置T=1来模拟标准贝叶斯网络(横截面数据)。</p><p id="3472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具有上述CPD和参数的架构1可以轻松实现如下:</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="6d26" class="oe mi iq oa b gy of og l oh oi">import time<br/>START=time.time()<br/>T=20<br/>N=1000<br/>N_level=[4]<br/>Mat=pd.DataFrame(np.array(([0,1],[0,0]))) # HMM<br/>Node_Type=['D','C']</span><span id="f080" class="oe mi iq oa b gy oo og l oh oi">CPD={'0':[0.25,0.25,0.25,0.25],'01':<br/>{'mu0':20,'sigma0':5,'mu1':40,'sigma1':5,<br/>'mu2':60,'sigma2':5,'mu3':80,'sigma3':5}}</span><span id="87d2" class="oe mi iq oa b gy oo og l oh oi">Parent={'0':[],'1':[0]}</span><span id="8c6d" class="oe mi iq oa b gy oo og l oh oi">CPD2={'00':[[0.6,0.3,0.05,0.05],[0.25,0.4,0.25,0.1],[0.1,0.3,0.4,0.2],<br/>[0.05,0.05,0.4,0.5]],'01':{'mu0':20,'sigma0':5,'mu1':40,'sigma1':5,<br/>'mu2':60,'sigma2':5,'mu3':80,'sigma3':5<br/>}}</span><span id="ddfb" class="oe mi iq oa b gy oo og l oh oi">loopbacks={'00':[1]}<br/>Parent2={'0':[0],'1':[0]}<br/>Time_series1=tsBNgen(T,N,N_level,Mat,Node_Type,CPD,Parent,CPD2,Parent2,loopbacks)<br/>Time_series1.BN_data_gen()<br/>FINISH=time.time()<br/>print('Total Time is',FINISH-START)</span></pre><p id="4fed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码生成1000个长度为20的时间序列，对应于状态和观察值。观察值正态分布，具有特定的平均值和标准偏差。这些状态是离散的(因此是“D”)，并采用由<em class="ok"> N_level </em>变量确定的四个可能的级别。<em class="ok"> loopbacks </em>是一个字典，其中每个键都有以下形式:node+它的parent。因为在架构1中，只有状态，即节点0(根据图的拓扑排序)跨时间连接，并且在时间t时节点0的父节点是在时间t-1时的节点0；因此，<em class="ok">回环</em>的键值是‘00 ’,并且由于时间连接仅跨越一个时间单位，所以其值是1。Node_Type确定图中节点的类别。例如，在本例中，第一个节点是离散的(“D”)，第二个节点是连续的(“C”)。Mat表示网络的邻接矩阵。</p><p id="23a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成上述数据的总时间为2.06秒，通过HMM算法运行该模型，即使是五个样本，我们的准确率也超过93.00 %。<br/>现在让我们看一个更复杂的例子。从现在开始，为了节省空间，我避免显示CPD表，只显示用于生成数据的架构和python代码。</p><p id="38c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ok">例2 </em> </strong></p><p id="a330" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例2参考图2中的架构，其中前两层中的节点是离散的，而最后一层nodes(u₂是连续的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/f8c6e4a255e372a5c3fb3ba5bff6782a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmi5zcoobynP_we_U5kscA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2(作者照片)</p></figure><p id="0e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据图的拓扑排序，可以将每个时间点的节点命名为0、1和2。假设您希望在以下情况下生成数据:节点0(顶部节点)取两个可能值(二进制)，节点1(中间节点)取四个可能值，最后一个节点是连续的，并且对于其父节点的每个可能值将根据高斯分布进行分布。以下python代码模拟了2000个样本的场景，每个样本的长度为20。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="867d" class="oe mi iq oa b gy of og l oh oi">T=20<br/>N=2000<br/>N_level=[2,4]<br/>Mat=pd.DataFrame(np.array(([0,1,1],[0,0,1],[0,0,0])))<br/>Node_Type=['D','D','C']</span><span id="0fb3" class="oe mi iq oa b gy oo og l oh oi">CPD={'0':[0.6,0.4],'01':[[0.5,0.3,0.15,0.05],[0.1,0.15,0.3,0.45]],'012':{'mu0':10,'sigma0':2,'mu1':30,'sigma1':5,<br/> 'mu2':50,'sigma2':5,'mu3':70,'sigma3':5,'mu4':15,'sigma4':5,'mu5':50,'sigma5':5,'mu6':70,'sigma6':5,'mu7':90,'sigma7':3<br/>}}</span><span id="34c6" class="oe mi iq oa b gy oo og l oh oi">Parent={'0':[],'1':[0],'2':[0,1]}</span><span id="c2a8" class="oe mi iq oa b gy oo og l oh oi">CPD2={'00':[[0.7,0.3],[0.2,0.8]],'011':[[0.7,0.2,0.1,0],[0.6,0.3,0.05,0.05],[0.35,0.5,0.15,0],<br/>[0.2,0.3,0.4,0.1],[0.3,0.3,0.2,0.2],[0.1,0.2,0.3,0.4],[0.05,0.15,0.3,0.5],[0,0.05,0.25,0.7]],'012':{'mu0':10,'sigma0':2,'mu1':30,'sigma1':5,<br/>  'mu2':50,'sigma2':5,'mu3':70,'sigma3':5,'mu4':15,'sigma4':5,'mu5':50,'sigma5':5,'mu6':70,'sigma6':5,'mu7':90,'sigma7':3<br/>}}<br/>Parent2={'0':[0],'1':[0,1],'2':[0,1]}<br/>loopbacks={'00':[1],'11':[1]}<br/>Time_series2=tsBNgen(T,N,N_level,Mat,Node_Type,CPD,Parent,CPD2,Parent2,loopbacks)<br/>Time_series2.BN_data_gen()</span></pre><p id="3fab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上面的代码所示，节点0(顶部节点)在第一个时间步中没有父节点(这是变量parent所代表的)。在因果或贝叶斯网络中，这有时被称为根或外生变量。节点1连接到节点0，节点2连接到节点0和1。为了表示时间0之后的其他时间步长的结构，使用变量Parent2。这表示节点0跨时间连接到自身(因为在环回中‘00’是[1]，所以时间t仅连接到t-1)。节点1同时连接到节点0，并在之前连接到节点1(这也可以从loopback变量中看出)。</p><p id="01e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<strong class="ky ir"> tsBNgen </strong>是基于模型的数据生成，因此您需要提供每个节点的分布(对于外部节点)或条件分布。如果您想要生成与任意分布的架构相对应的合成数据，那么您可以选择CPD和CPD2为您喜欢的任何值，只要每个离散分布的条目之和为1。例如，节点0的CPD为[0.6，0.4]。你可以把这些值改成你喜欢的任何值，只要它们加到1上。</p><p id="e9cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ok">例3 </em> </strong></p><p id="d62f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例3参考图3中的架构，其中前两层中的节点是离散的，而最后一层nodes(u₂是连续的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/f48eaa8c9484b57b4c02e30f27d5c5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIAeEtv9c6xUH9K08bTfFA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3(作者照片)</p></figure><p id="16b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您希望在以下情况下生成数据:节点0(顶部节点)是二进制的，节点1(中间节点)取四个可能值，节点2是连续的，并且将根据其父节点的每个可能值的高斯分布进行分布。以下python代码模拟了1000个样本的场景，每个样本的长度为10。</p><pre class="kg kh ki kj gt nz oa ob oc aw od bi"><span id="1490" class="oe mi iq oa b gy of og l oh oi">T=10<br/>N=1000<br/>N_level=[2,4]<br/>Mat=pd.DataFrame(np.array(([0,1,0],[0,0,1],[0,0,0])))<br/>Node_Type=['D','D','C']<br/>CPD={'0':[0.5,0.5],'01':[[0.6,0.3,0.05,0.05],[0.1,0.2,0.3,0.4]],'12':{'mu0':10,'sigma0':5,'mu1':30,'sigma1':5,<br/>    'mu2':60,'sigma2':5,'mu3':80,'sigma3':5}}<br/>Parent={'0':[],'1':[0],'2':[1]}</span><span id="b3c5" class="oe mi iq oa b gy oo og l oh oi">CPD2={'00':[[0.7,0.3],[0.3,0.7]],'0011':[[0.7,0.2,0.1,0],[0.5,0.4,0.1,0],[0.45,0.45,0.1,0],<br/>[0.3,0.4,0.2,0.1],[0.4,0.4,0.1,0.1],[0.2,0.3,0.3,0.2],[0.2,0.3,0.3,0.2],[0.1,0.2,0.3,0.4],[0.3,0.4,0.2,0.1],[0.2,0.2,0.4,0.2],<br/> [0.2,0.1,0.4,0.3],[0.05,0.15,0.3,0.5],[0.1,0.3,0.3,0.3],[0,0.1,0.3,0.6],[0,0.1,0.2,0.7],[0,0,0.3,0.7]],'112':{'mu0':10,'sigma0':2,'mu1':30,'sigma1':2,<br/>    'mu2':50,'sigma2':2,'mu3':60,'sigma3':5,'mu4':20,'sigma4':2,'mu5':25,'sigma5':5,'mu6':50,'sigma6':5,'mu7':60,'sigma7':5,<br/>   'mu8':40,'sigma8':5,'mu9':50,'sigma9':5,'mu10':70,'sigma10':5,'mu11':85,'sigma11':2,'mu12':60,'sigma12':5, <br/>    'mu13':60,'sigma13':5,'mu14':80,'sigma14':3,'mu15':90,'sigma15':3}}</span><span id="5239" class="oe mi iq oa b gy oo og l oh oi">Parent2={'0':[0],'1':[0,0,1],'2':[1,1]}<br/>loopbacks={'00':[1], '01':[1],'11':[1],'12':[1]}</span><span id="3544" class="oe mi iq oa b gy oo og l oh oi">Time_series2=tsBNgen(T,N,N_level,Mat,Node_Type,CPD,Parent,CPD2,Parent2,loopbacks)<br/>Time_series2.BN_data_gen()</span></pre><p id="f0e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，您可以为任何想要的图形模型生成时间序列数据。这是一个非常好的工具，因为许多现实世界的问题都可以建模为贝叶斯和因果网络。</p><p id="f608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关更多示例和最新文档，请访问下面的GitHub页面。</p><div class="ne nf gp gr ng nh"><a href="https://github.com/manitadayon/tsBNgen" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">马尼塔代翁/茨布恩根</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">描述说明tsBNgen是一个Python包，基于任意贝叶斯网络生成时间序列数据…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="or l ns nt nu nq nv kp nh"/></div></div></a></div><p id="26e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多，请务必在我的YouTube频道上观看我最近的视频。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a20a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">奖励</strong>:如果你想看HMM等图形建模算法和LSTM等深度学习方法在合成生成的时间序列上的对比分析，请看看这个paper⁴.</p><h1 id="ab6d" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="4b99" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">在本文中，我介绍了<strong class="ky ir"> tsBNgen </strong>，这是一个从任意BN生成合成数据的python库。使用两个示例解释了该软件的特性和功能。有关该软件的更多最新信息，请访问上面提到的GitHub页面。</p></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><h1 id="38a0" class="mh mi iq bd mj mk oz mm mn mo pa mq mr jw pb jx mt jz pc ka mv kc pd kd mx my bi translated"><strong class="ak">参考</strong></h1><p id="e1c4" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">[1] M. Frid-Adar，E. Klangand，M. Amitai，J. Goldberger，H. Greenspan，使用gan的合成数据增强用于改进肝脏病变分类(2018)，IEEE 2018第15届生物医学成像国际研讨会<br/>。</p><p id="ee48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] M. Tadayon，G. Pottie，<a class="ae kv" href="https://ieeexplore.ieee.org/abstract/document/9084102/" rel="noopener ugc nofollow" target="_blank">利用隐马尔可夫模型预测教育游戏中的学生表现</a> (2020)，IEEE 2020 IEEE教育汇刊。</p><p id="9b68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3] M. Tadayon，G. Pottie，<a class="ae kv" href="https://arxiv.org/abs/2009.04595" rel="noopener ugc nofollow" target="_blank"> tsBNgen:一个从任意动态贝叶斯网络结构生成时间序列数据的Python库</a> (2020)，arXiv 2020，arXiv预印本arXiv:2009.04595。</p><p id="3024" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[4] M. Tadayon，G. Pottie，<a class="ae kv" href="https://arxiv.org/abs/2008.03825" rel="noopener ugc nofollow" target="_blank">隐马尔可夫模型与LSTM的比较分析:一种模拟方法</a> (2020)，arXiv 2020，arXiv预印本arXiv:2008.03825。</p></div></div>    
</body>
</html>