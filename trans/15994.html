<html>
<head>
<title>How I Completely Destroyed This Challenge Using “One Line of Code”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用“一行代码”彻底摧毁了这个挑战</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-think-like-a-competitive-coder-146918397a1c?source=collection_archive---------49-----------------------#2020-11-03">https://towardsdatascience.com/how-to-think-like-a-competitive-coder-146918397a1c?source=collection_archive---------49-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="90a3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><div class=""><h2 id="6b8c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">三思而后行，编码一次——像专家一样解决“最大化游戏”问题</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b2f8d85ac7fca3c6fd508a69e06e8f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iONMISdcsRxDtzs4Ux5EJA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:图片由作者提供(引自Linus Torvalds)</p></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="5cf8" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi mk translated">最近我参加了一个由<a class="ae mt" href="https://www.hackerrank.com/hackerrank-hackfest-2020/" rel="noopener ugc nofollow" target="_blank">hacker rank</a>(hacker fest 2020)举办的比赛，在那里我遇到了一个问题叫做<strong class="lq jd"> <em class="mu">“最大化的游戏”。</em> </strong>而我只用<strong class="lq jd">一行代码就解决了！</strong></p><p id="119c" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><em class="mu">如何？让我给你展示一下…</em></p><p id="2a1a" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我用这个问题作为例子来描述“<em class="mu">在解决一个竞争性的编码挑战</em>时，你应该如何思考”；如何写出更好的算法，更快。</p><p id="da0a" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">对我来说，竞争性编码是一种艺术形式(就像<a class="ae mt" href="https://en.wikipedia.org/wiki/Obfuscation_(software)" rel="noopener ugc nofollow" target="_blank">模糊编程</a>)，一个人试图用最少的代码最有效地解决一个给定的问题。</p><blockquote class="mv"><p id="1cd5" class="mw mx it bd my mz na nb nc nd ne mj dk translated">通常，代码越少=效率越高</p></blockquote><blockquote class="nf ng nh"><p id="78c5" class="lo lp mu lq b lr ni kd lt lu nj kg lw nk nl lz ma nm nn md me no np mh mi mj im bi translated">记住这一点，我将从初学者可以理解的代码开始，然后一步一步地进一步改进它，达到专业水平。每次都向你解释我的方法。</p></blockquote><p id="e2cd" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">所以让我们开始吧！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="eada" class="nq nr it bd ns nt nu nv nw nx ny nz oa ki ob kj oc kl od km oe ko of kp og oh bi translated">问题是</h1><p id="4ec9" class="pw-post-body-paragraph lo lp it lq b lr oi kd lt lu oj kg lw lx ok lz ma mb ol md me mf om mh mi mj im bi translated">先看看问题陈述:—</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/663adbe2d0219a2fcfb5746e0c762fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5OKYNANOwrfLmVVKVSPMQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:图片由作者提供(问题截图)</p></figure><p id="ed61" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">正如你所看到的，你需要从奇数位置的石堆和偶数位置的石堆中挑选相同数量的石头；同时挑选不超过相应堆中可用石头数量的石头。</p><p id="15e0" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">暂停一下，用一秒钟思考一下。</p><p id="8acd" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们将构建一个名为<strong class="lq jd"><em class="mu">maximum stones</em></strong>的函数，它将接受一个整数数组<strong class="lq jd"> <em class="mu"> arr，</em> </strong>代表每堆中的石头数量。并返回一个整数，代表您可以选择的最大宝石总数。</p><p id="eeef" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">为了简单和更快的开发，我将使用Python。</p><p id="7ca7" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">你认为你需要多少行代码来解决这个问题？</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="e7df" class="nq nr it bd ns nt nu nv nw nx ny nz oa ki ob kj oc kl od km oe ko of kp og oh bi translated">第一次迭代——新手方法</h1><p id="defb" class="pw-post-body-paragraph lo lp it lq b lr oi kd lt lu oj kg lw lx ok lz ma mb ol md me mf om mh mi mj im bi translated">不要试图根据问题的类型来识别问题。可能是贪心问题，也可能是来自动态编程的问题，<strong class="lq jd">我们不管</strong>。让它自然地来到你身边。</p><p id="88bb" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">如果我们完全按照问题陈述中所写的去做，我们将得到这样的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:作者代码</p></figure><p id="319e" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">不要被它吓倒。其实很简单。</p><h2 id="56fa" class="oq nr it bd ns or os dn nw ot ou dp oa lx ov ow oc mb ox oy oe mf oz pa og iz bi translated">代码解释</h2><p id="54d1" class="pw-post-body-paragraph lo lp it lq b lr oi kd lt lu oj kg lw lx ok lz ma mb ol md me mf om mh mi mj im bi translated">这里，我们已经预先分别在变量<strong class="lq jd"><em class="mu"/></strong>和<strong class="lq jd"> <em class="mu"> b </em> </strong>中计算了奇数排和偶数排中的石头数量的总和。然后，我们进行循环，直到两者之差(<strong class="lq jd"><em class="mu"/></strong>和<strong class="lq jd"> <em class="mu"> b </em> </strong>)，在变量<strong class="lq jd"><em class="mu"/></strong>c中，变为零，也就是说，直到<strong class="lq jd"> <em class="mu"> a == b. </em> </strong></p><p id="0cdb" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在每次迭代中，我们看到哪些桩需要修改。如果奇数位置的堆(<strong class="lq jd"> <em class="mu"> a </em> </strong>)有更多的石头(<strong class="lq jd"> <em class="mu"> c </em> </strong> &gt; 0)，那么我们将从那些堆中减去石头，否则，从偶数位置的堆中减去。</p><p id="b630" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们需要减去多少颗石头？ <strong class="lq jd"> <em class="mu"> c颗石子的数量</em> </strong></p><p id="1057" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在每次减法的同时，我们需要确认是否能减去整堆(if<strong class="lq jd"><em class="mu">picks[k]-c&gt;0</em></strong>)；以及<strong class="lq jd"> <em class="mu"> c==0 </em> </strong>与否。</p><p id="1dd2" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">很简单。对吗？</p><blockquote class="nf ng nh"><p id="a877" class="lo lp mu lq b lr ls kd lt lu lv kg lw nk ly lz ma nm mc md me no mg mh mi mj im bi translated"><strong class="lq jd">结果:</strong>14个测试用例中有13个通过(一个错误答案)</p></blockquote><p id="9607" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">那么我们如何识别错误呢？</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="0799" class="nq nr it bd ns nt nu nv nw nx ny nz oa ki ob kj oc kl od km oe ko of kp og oh bi translated">第二次迭代—减少代码</h1><p id="432a" class="pw-post-body-paragraph lo lp it lq b lr oi kd lt lu oj kg lw lx ok lz ma mb ol md me mf om mh mi mj im bi translated">识别代码冗余和未使用的循环，并消除它们。</p><blockquote class="mv"><p id="bed3" class="mw mx it bd my mz na nb nc nd ne mj dk translated">代码越少=错误越少</p></blockquote><p id="da75" class="pw-post-body-paragraph lo lp it lq b lr ni kd lt lu nj kg lw lx nl lz ma mb nn md me mf np mh mi mj im bi translated">你自己看吧:—</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:作者代码</p></figure><h2 id="a05d" class="oq nr it bd ns or os dn nw ot ou dp oa lx ov ow oc mb ox oy oe mf oz pa og iz bi translated">代码解释</h2><p id="7fcb" class="pw-post-body-paragraph lo lp it lq b lr oi kd lt lu oj kg lw lx ok lz ma mb ol md me mf om mh mi mj im bi translated">在我们的例子中，<em class="mu"> while-loop </em>没有任何用途，基本上只运行一次。一旦我们确定了<strong class="lq jd"> <em class="mu"> c、</em> </strong>的值，我们只需要从那些对应的桩(奇数桩或偶数桩)中减去石头。</p><p id="c455" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">正如你在我们之前的代码中看到的，我们在两个<em class="mu"> for循环</em>中写了同样的东西两次。所以我们也可以用一个决定元素选择的条件来去除它——</p><pre class="ks kt ku kv gt pb pc pd pe aw pf bi"><span id="e0ad" class="oq nr it pc b gy pg ph l pi pj">idx = range(1,n,2) if c&lt;0 else range(0,n,2)</span></pre><blockquote class="nf ng nh"><p id="aa44" class="lo lp mu lq b lr ls kd lt lu lv kg lw nk ly lz ma nm mc md me no mg mh mi mj im bi translated"><strong class="lq jd">结果:</strong>没有改进(因为我们只删除了不必要的代码)</p></blockquote></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="c821" class="nq nr it bd ns nt nu nv nw nx ny nz oa ki ob kj oc kl od km oe ko of kp og oh bi translated">第三次迭代——重新定义问题</h1><p id="5c7e" class="pw-post-body-paragraph lo lp it lq b lr oi kd lt lu oj kg lw lx ok lz ma mb ol md me mf om mh mi mj im bi translated">现在，既然你已经走了这么远，你已经掌握了我们正在做的事情的逻辑。但问题是，我们真的需要做所有这些来得到我们想要的吗？ </p><p id="7174" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">如果你仔细思考这个问题，你会发现，我们不需要一次从一堆石头中减去一颗。事实上，我们根本不需要这么做。因为每次我们减去那些石头，我们基本上是在从一堆石头中减去。</p><p id="7925" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">从数学上讲，<strong class="lq jd">两者是等价的</strong>。</p><p id="3440" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">所以如果我们已经计算出了差值(abs <strong class="lq jd"> ( <em class="mu"> c </em> ) </strong>，那么我们可以直接从整个数组的和<strong class="lq jd"> <em class="mu"> arr </em> </strong>中减去它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:作者代码</p></figure><p id="df02" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们可以像这样进一步简化它…</p><pre class="ks kt ku kv gt pb pc pd pe aw pf bi"><span id="d438" class="oq nr it pc b gy pg ph l pi pj">def maximumStones(arr):<br/>    return sum(arr) - abs(sum(arr[::2]) - sum(arr[1::2]))</span></pre><p id="6cfb" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">所以我们在这里，作为我们最终答案的单行代码是—</p><p id="183b" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><strong class="lq jd">sum(arr)—ABS(sum(arr[::2])—sum(arr[1::2]))</strong></p><blockquote class="nf ng nh"><p id="a2d5" class="lo lp mu lq b lr ls kd lt lu lv kg lw nk ly lz ma nm mc md me no mg mh mi mj im bi translated"><strong class="lq jd">结果:</strong> 14个测试用例中有14个通过(成功！)</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/26effbb0a509f9127f3203ee6846d5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-1nTU1eyzO3hWu3TqDfsQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:作者图片(投稿截图)</p></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="8a89" class="nq nr it bd ns nt nu nv nw nx ny nz oa ki ob kj oc kl od km oe ko of kp og oh bi translated">外卖—</h1><p id="7527" class="pw-post-body-paragraph lo lp it lq b lr oi kd lt lu oj kg lw lx ok lz ma mb ol md me mf om mh mi mj im bi translated">不要一看到问题就急于解决。花几分钟思考一下，因为不是每个问题都需要你直截了当地思考。</p><p id="2796" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">有些问题要你跳出框框思考。全新的视角；一个重要的知识可以为你节省大量的编码和调试时间。</p><p id="d62e" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">有几条经验法则你需要记住—</p><ul class=""><li id="2e68" class="pl pm it lq b lr ls lu lv lx pn mb po mf pp mj pq pr ps pt bi translated">尽可能地减少代码<strong class="lq jd">以提高效率和减少错误。使用内置库，去除冗余，尽可能减少循环次数。</strong></li><li id="9312" class="pl pm it lq b lr pu lu pv lx pw mb px mf py mj pq pr ps pt bi translated">当你不能再做了，问题仍然存在时，<strong class="lq jd">改变方法</strong>。不要让<strong class="lq jd"> <em class="mu">而不是</em> </strong>依附于你现在已经编写好的程序。重新定义问题——抽象地、数学地思考。</li></ul><p id="5013" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">显然，竞争性编程的内容比我在本文中所能涵盖的要多。随着你获得更多的经验，所有的提示和窍门都会来到你面前。但目前就这些了。我希望你喜欢这篇文章。</p><p id="99a1" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">编程快乐！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="73c5" class="pw-post-body-paragraph lo lp it lq b lr ls kd lt lu lv kg lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><strong class="lq jd">你可能会喜欢的其他精彩文章— </strong></p><div class="pz qa gp gr qb qc"><a rel="noopener follow" target="_blank" href="/mathematics-of-music-in-python-b7d838c84f72"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd jd gy z fp qh fr fs qi fu fw jc bi translated">如何在Python中使用数学来演奏音乐</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">音乐数学</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ql l"><div class="qm l qn qo qp ql qq lb qc"/></div></div></a></div><div class="pz qa gp gr qb qc"><a href="https://medium.com/towards-artificial-intelligence/10-game-changing-ai-breakthroughs-worth-knowing-about-b2076afc4930" rel="noopener follow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd jd gy z fp qh fr fs qi fu fw jc bi translated">值得了解的10个改变游戏规则的人工智能突破</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">过去几十年中引人入胜的想法和概念</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">medium.com</p></div></div><div class="ql l"><div class="qr l qn qo qp ql qq lb qc"/></div></div></a></div><div class="pz qa gp gr qb qc"><a href="https://medium.com/towards-artificial-intelligence/why-its-super-hard-to-be-an-ml-researcher-or-developer-67fa62fc1971" rel="noopener follow" target="_blank"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd jd gy z fp qh fr fs qi fu fw jc bi translated">为什么做一个ML研究员或者开发者超级难？</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">这一认识彻底改变了我的生活</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">medium.com</p></div></div><div class="ql l"><div class="qs l qn qo qp ql qq lb qc"/></div></div></a></div><div class="pz qa gp gr qb qc"><a rel="noopener follow" target="_blank" href="/how-i-won-a-national-level-ml-competition-with-my-unique-informal-approach-e86fd95532fd"><div class="qd ab fo"><div class="qe ab qf cl cj qg"><h2 class="bd jd gy z fp qh fr fs qi fu fw jc bi translated">我是如何用我独特的“非正式方法”赢得国家级ML比赛的</h2><div class="qj l"><h3 class="bd b gy z fp qh fr fs qi fu fw dk translated">像数据科学黑客一样思考——你不需要遵守规则就能获胜</h3></div><div class="qk l"><p class="bd b dl z fp qh fr fs qi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ql l"><div class="qt l qn qo qp ql qq lb qc"/></div></div></a></div></div></div>    
</body>
</html>