<html>
<head>
<title>Demystifying Bubble Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开冒泡排序的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-bubble-sort-e1cc6b15a08d?source=collection_archive---------48-----------------------#2020-10-08">https://towardsdatascience.com/demystifying-bubble-sort-e1cc6b15a08d?source=collection_archive---------48-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="803f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">排序算法指南</h2><div class=""/><div class=""><h2 id="ebe9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">升级你的排序游戏！</h2></div><p id="1d6b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在前面的文章中，我们一直在讨论搜索算法。您可能还记得二分搜索法和插值搜索只对有序数组有效。可以肯定地说，排序是搜索算法的补充。排序是将数据结构中的元素重新排列成某种特定顺序(升序或降序)的操作。为了简单起见，我们将对所有数组进行升序排序。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/c2dfe0eaa59b5c68aace552bb2785fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y2OJvi0wgZqSkzRh"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">图片由<a class="ae md" href="https://unsplash.com/@edgr" rel="noopener ugc nofollow" target="_blank">edu·格兰德</a>在<a class="ae md" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c42c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有许多可用的排序算法，其中一些比另一些更好。然而，对我们来说，重要的是理解它们中的每一个，给我们一个完整的算法基础。在本文中，我们将从最简单的冒泡排序开始。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="757d" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">什么是冒泡排序？</h1><p id="fab9" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">冒泡排序也称为下沉排序，是一种简单的排序算法，它通过比较每对相邻元素来进行操作。首先，它比较第一个和第二个元素，然后是第二个和第三个元素，依此类推。如果前一个元素大于后一个元素，这两个元素将互换。</p><p id="72d0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该算法因较大的元素会向最右边的位置“冒泡”而得名。在每个周期之后，最大的元素将是数组中未排序部分的最后一个元素。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="8f11" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">它是如何工作的？</h1><p id="78c6" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">冒泡排序中完成的操作:</p><ol class=""><li id="4f9d" class="ni nj it kt b ku kv kx ky la nk le nl li nm lm nn no np nq bi translated">比较前两个元素。</li><li id="4b0f" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">如果前一个元素较大，则互换这两个元素。</li><li id="0721" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">重复步骤1和2，直到到达数组的末尾。</li><li id="cb82" class="ni nj it kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated">重复步骤1、2和3，直到所有元素都排序完毕。</li></ol><p id="72ef" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要注意的是，在第一次运行中，假设数组中的元素数量为n，您需要进行n-1次比较。在第二次运行中，您只需要进行n-2次比较，而不需要进行最后一次比较，因为此时最后一个元素是最大的。这意味着，在每次运行中，比较的次数减少1。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="2bc5" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">冒泡排序示例</h1><p id="96cd" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">在我们用3种不同的编程语言进行真正的实现之前，我会先给你们提供伪代码。</p><blockquote class="nw nx ny"><p id="733d" class="kr ks nz kt b ku kv kd kw kx ky kg kz oa lb lc ld ob lf lg lh oc lj lk ll lm im bi translated">冒泡排序伪代码</p></blockquote><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="500a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">是时候继续学习Python、C和JavaScript的真正代码了。</p><blockquote class="nw nx ny"><p id="7abd" class="kr ks nz kt b ku kv kd kw kx ky kg kz oa lb lc ld ob lf lg lh oc lj lk ll lm im bi translated">Python中的冒泡排序代码</p></blockquote><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="od oe l"/></div></figure><blockquote class="nw nx ny"><p id="652d" class="kr ks nz kt b ku kv kd kw kx ky kg kz oa lb lc ld ob lf lg lh oc lj lk ll lm im bi translated">C中的冒泡排序代码</p></blockquote><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="od oe l"/></div></figure><blockquote class="nw nx ny"><p id="a1b0" class="kr ks nz kt b ku kv kd kw kx ky kg kz oa lb lc ld ob lf lg lh oc lj lk ll lm im bi translated">JavaScript中的冒泡排序代码</p></blockquote><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="od oe l"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="537d" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">冒泡排序的时间复杂度</h1><p id="5bbe" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">冒泡排序操作是基本的，但是它的时间复杂度不是最好的。最佳情况/最差情况/平均情况的时间复杂度是O(n ),因为在任何阵列中，比较的总数是:</p><p id="7e0b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">(n-1) + (n-2) + … + 3 + 2 + 1 = n(n-1)/2</p><p id="eba8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">对于任何数组，尽管该数组已经被排序，但是算法将精确地进行n(n-1)/2次比较。由于冒泡排序的时间复杂度为O(N ),所以它很少在实际实现中使用。随着n变大，运行时间的增长会非常大。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="5768" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">放弃</h1><p id="4ff4" class="pw-post-body-paragraph kr ks it kt b ku nd kd kw kx ne kg kz la nf lc ld le ng lg lh li nh lk ll lm im bi translated">虽然冒泡排序可能很少使用。学习冒泡排序绝对值得。学习冒泡排序将帮助你更容易地学习更高级的主题，因为它将充当你理解更高级概念的桥梁。</p><blockquote class="of"><p id="b5e3" class="og oh it bd oi oj ok ol om on oo lm dk translated">"我没有学到新东西的一天就是虚度的一天."</p><p id="b6a1" class="og oh it bd oi oj ok ol om on oo lm dk translated">— B. B .金</p></blockquote><p id="ea57" class="pw-post-body-paragraph kr ks it kt b ku op kd kw kx oq kg kz la or lc ld le os lg lh li ot lk ll lm im bi translated">每天愉快地学习新概念！</p><p id="e0af" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">问候，</p><p id="6076" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">弧度克里斯诺</strong></p></div></div>    
</body>
</html>