<html>
<head>
<title>Full Stack Development in 1 Twitter Thread</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个Twitter线程中的全栈开发</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/full-stack-development-in-1-twitter-thread-5a0cbce2e059?source=collection_archive---------31-----------------------#2020-11-13">https://towardsdatascience.com/full-stack-development-in-1-twitter-thread-5a0cbce2e059?source=collection_archive---------31-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a4e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将你的想法变成现实的端到端步骤</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9e9c507fb7e29dbd8ed662960928231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzX8tGLXv1v2SzlUeXoVEQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你好，我是尼克🎞 on <a class="ae kv" href="https://unsplash.com/s/photos/builder?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="9cd7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">当形式追随功能</h1><p id="5cb9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">人有想法。很多想法。但是他们有多少次把这些想法变成现实呢？我们脑袋里的东西和<em class="mk">创造的东西</em>有明显的区别。</p><p id="c7c2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">大部分人不做软件。这包括实际软件团队中的许多人。如果你现在不编码，你会认为创建工作软件是别人的工作。也许你想自己开始学习(或重新学习),但认为这需要太长时间，太具技术挑战性，或者只是你不感兴趣。</p><p id="8502" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">想法通常以图画、便利贴、模型和“可点击的应用程序”的形式存在，所有这些都可以捕捉想法，但很难验证可行的东西。在一个人的想法和自然允许发生的事情之间有一个过渡点，通过这个过渡，创新<em class="mk">实际上</em>发生了。在形式和功能之间有一个美丽的对应，只有一个真正的工作软件才能展示出来。</p><p id="d683" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">不做软件的人没有任何借口。不管你的兴趣是什么，如果你想看到你的想法变成现实，那么你需要开发软件。鉴于当今工具的抽象水平，完整的软件可以被快速地创建出来。</p><p id="12d9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">软件开发不是给计算机“编程”,而是制作一些真实的东西，与人互动，成为工作经济的一部分。</p><p id="f506" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我最初在Twitter上用一个线程写了这篇文章，以展示任何人创建端到端的软件应用程序是多么容易。</p><p id="1e60" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">有许多错误的机会守门人。你需要正规教育、在线课程或多年丰富经验的假设显然是错误的。每个人都有能力把他们的想法拼凑成实际可行的东西。</p><p id="8cf5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们开始吧。</p><h1 id="526d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">这些碎片</h1><p id="3e38" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你只需要一个浏览器，一个记事本，和你电脑的终端(PC上的命令提示符)。构建所有应用程序需要几个高级步骤:</p><ul class=""><li id="425b" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj mv mw mx my bi translated">一页</li><li id="bf38" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">风格</li><li id="036e" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">布局</li><li id="69b9" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">互动元素</li><li id="8356" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">事件</li><li id="5a00" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">计算机网络服务器</li><li id="03f0" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">获取/存储数据</li></ul><p id="affa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">人们很少从头开始写程序了。那太慢了。今天我们使用图书馆。我们将使用<strong class="lq ir"> JavaScript </strong>和<strong class="lq ir"> Python </strong>库。我会用<a class="ae kv" href="https://azlejs.com" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> Azle </strong> </a>做前端的东西(<code class="fe ne nf ng nh b">DISCLAIMER</code> : <em class="mk">我创建了Azle，但是你可以用任何JS库</em>，后端的东西用Flask。</p><p id="ff1c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们从我们的页面开始。</p><p id="3591" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">页面总是有一个<code class="fe ne nf ng nh b">index.html</code>文件。进入<a class="ae kv" href="https://azlejs.com" rel="noopener ugc nofollow" target="_blank"> Azle </a>主页，点击左上角的<strong class="lq ir"> STARTER HTML </strong>图标。<em class="mk">复制</em>和<em class="mk">粘贴</em>这个到记事本或者任何你想要的编辑器(我会用<a class="ae kv" href="https://www.barebones.com/products/bbedit/TimetoSwitchFree.html?gclid=Cj0KCQiA-rj9BRCAARIsANB_4ACrnAhFW61USqgftoMWarqrPhY93mgSfnR_CxVenPMoBcg2i-RWUeoaAj2rEALw_wcB" rel="noopener ugc nofollow" target="_blank"> TextWrangler </a>)，然后保存文件为<code class="fe ne nf ng nh b">index.html</code>(在你的桌面上)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/94f1ecf06084063bd460c9c15966040a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjU6r1zNjALPI1lDkKwHMQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从<a class="ae kv" href="https://azlejs.com" rel="noopener ugc nofollow" target="_blank"> Azle </a>中抓取启动HTML文件。</p></figure><p id="6ae0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">每个web应用程序都有一个<code class="fe ne nf ng nh b">index.html</code>文件。它是当你加载一个网站或网络应用程序时，你的浏览器指向的页面。让我们把这个文件放在一个叫做<code class="fe ne nf ng nh b">my_app</code>的文件夹中，然后把你的<code class="fe ne nf ng nh b">index.html</code>文件拖到这个文件夹中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/49bb19be3d03bcec2a0d5e967c786e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4B7UCrP3vtHpcfNt908Hg.jpeg"/></div></div></figure><p id="6212" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果右击<code class="fe ne nf ng nh b">index.html</code>文件并选择您的浏览器，您可以查看该页面。这样做将弹出打开您的浏览器，并显示一个空白页。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e065" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们用<em class="mk">样式</em>页面。从<a class="ae kv" href="https://azlejs.com" rel="noopener ugc nofollow" target="_blank"> Azle </a>中获取<code class="fe ne nf ng nh b">style_body</code>代码，然后<em class="mk">将</em>粘贴到你的<code class="fe ne nf ng nh b">index.html</code>文件中(在<code class="fe ne nf ng nh b">create_azle</code>函数内):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="d14f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">不要像Reddit一样，因为自己丑就觉得自己很酷。去拿一些极简的十六进制代码，把你的页面设计成2020年的样子。没有什么比俄罗斯粉彩更能体现我的现代感:</p><p id="2906" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><a class="ae kv" href="https://t.co/urjIhvFRiz?amp=1" rel="noopener ugc nofollow" target="_blank">flatuicolors.com/palette/ru</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/0317fc24154f610e9efabbb73027a172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqpMKZC4jflrBEiDlLKK0g.jpeg"/></div></div></figure><p id="c580" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">点击<em class="mk">上的</em>选择你喜欢的颜色。<em class="mk">用新颜色替换<code class="fe ne nf ng nh b">style_body</code>功能中的</em>背景颜色。我会选择比斯开。我们也不想使用标准的浏览器字体，因为唯一比看起来像Reddit更糟糕的是看起来像Craigslist。</p><p id="e002" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><a class="ae kv" href="https://fonts.google.com" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">谷歌字体</strong> </a>救场。我会选择Ubuntu。好看又现代。</p><p id="6fcc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当然，我们需要让我们的谷歌字体可用。让我们在调用我们的<code class="fe ne nf ng nh b">style_body</code>函数之前<em class="mk">加载</em>。<em class="mk">在文档中搜索</em>中的“字体”找到<code class="fe ne nf ng nh b">load_font</code>功能):</p><pre class="kg kh ki kj gt nn nh no np aw nq bi"><span id="67eb" class="nr kx iq nh b gy ns nt l nu nv">az.load_font("Ubuntu")</span></pre><p id="4236" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我还将<code class="fe ne nf ng nh b">style_body</code>函数中的<code class="fe ne nf ng nh b">min-width</code>属性设置为1150px，这样当我调整浏览器大小时页面不会挤压。因为我们只是<em class="mk">原型制作</em>一个应用程序，所以我们不关心响应度。</p><p id="58b9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们的<strong class="lq ir">代码</strong>现在应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="ab74" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因为这些都在我们的<code class="fe ne nf ng nh b">index.html</code>文件中，我们可以刷新浏览器并查看结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/d8a5ffa4a59e95d19c20b66bd408e26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQKu-EefCoWsaOL1660TsA.png"/></div></div></figure><p id="80fa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这里有<a class="ae kv" href="https://codepen.io/cybertime/pen/vYKbxGB" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">码笔</strong> </a>如果想玩代码的话。尝试更改背景的颜色。当然，改变字体不会有什么影响，因为我们没有显示任何文本。</p><blockquote class="nx ny nz"><p id="5ac7" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated">每当你在本文中看到<strong class="lq ir"> CodePen </strong>时，点击它打开一个标签，显示我们当前代码的实时交互版本。根据自己的喜好调整这些值。</p></blockquote><p id="43e5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们正在取得进展…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/ee1320f72c8961c7f924a80b8d5dc4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNgyGhUxhGb29-PqZODbxQ.jpeg"/></div></div></figure><p id="e3c5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当然，我们的页面上什么都没有。让我们改变这一点。我们将添加一个<strong class="lq ir">部分</strong>来保存我们的内容。使用<code class="fe ne nf ng nh b">add_sections</code>功能添加1个部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="0cef" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">…刷新您的浏览器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/cfa874071bfd8f52f577149c9acad65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1RoISENLF5cqpsqY_SKtQ.png"/></div></div></figure><p id="a19c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">Azle的默认部分颜色是蓝色，但是当然，我们可以根据需要改变它。</p><p id="268d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><a class="ae kv" href="https://codepen.io/cybertime/pen/NWrojaO" rel="noopener ugc nofollow" target="_blank">代码笔</a></p><p id="9eda" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">尝试更改部分的数量。</p><p id="8a61" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们回到俄罗斯，看看我们是否能找到比蓝色更好的颜色。使用<code class="fe ne nf ng nh b">style_sections</code>函数(位于<code class="fe ne nf ng nh b">add_sections</code>函数的正下方)来设置新部分的样式。为了样式化一个元素，我们必须使用它的<strong class="lq ir">类名</strong>和<strong class="lq ir">实例号</strong>来定位它。我们知道我们的部分的类名叫做“my_sections ”,因为我们只创建了一个部分，所以它一定是第一个实例。我们的<code class="fe ne nf ng nh b">style_sections</code>函数看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="22a3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我将选择苹果谷作为我的部分背景色。我还加了一个<code class="fe ne nf ng nh b">6px</code>的<code class="fe ne nf ng nh b">border-radius</code>来圆角。我将<code class="fe ne nf ng nh b">height</code>设置为<code class="fe ne nf ng nh b">auto</code>，这允许HTML元素根据元素内部的内容进行增长和收缩。</p><p id="5f37" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因为我们想在页面上<strong class="lq ir">安排</strong>事情，我们将使用<strong class="lq ir">布局</strong>。这些只是网格；放置在页面上的框，我们用文本、按钮、滑块、输入等填充。我将<em class="mk">使用<code class="fe ne nf ng nh b">add_layout</code>功能添加</em>一个2行1列的布局:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="a68c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/e7cf7ebe50d12aa0c9e568cc66bd7982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVUxJhu77LZVVdnE6y46ag.png"/></div></div></figure><p id="24d7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我希望第一排能守住我的头衔。我将通过使用另一个<code class="fe ne nf ng nh b">style_layout</code>函数将<em class="mk">定位到我的布局的第一行</em>来将第一行的高度更改为<code class="fe ne nf ng nh b">60px</code>，该函数直接位于上一个函数的下方:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="25f2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意我是如何定位行“my_layout_rows”和第一个实例(行1)的类名的。刷新浏览器以查看不同之处:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/20e32adcc49b6f4d616faa4ff9424345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mz2XyVS2lbLVfJMVRfQa5w.png"/></div></div></figure><blockquote class="nx ny nz"><p id="c4b9" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated">我们在样式函数的花括号中添加的所有内容都是标准的CSS样式。当你试图找出如何实现你想要的风格时，只需在网上搜索合适的CSS。随着时间的推移，你会学到许多造型技巧。</p></blockquote><p id="f04a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们继续展示我们之前加载的Ubuntu字体，为我们的应用程序添加一个标题。我们瞄准布局的第一个单元格，使用<code class="fe ne nf ng nh b">add_text</code>函数添加文本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/bf0ae20f380632f3566b34f05279e739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFGEAXNZ5ZYwiLaK7UbOZw.png"/></div></div></figure><p id="445f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让<em class="mk">增加<strong class="lq ir">标题</strong>的字体大小</em>，并使<em class="mk">居中</em>对齐:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/3a7623c2245ba9026602dff60e63584f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-UBlouJpF1khodm1YDTj2w.png"/></div></div></figure><p id="fa81" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">目前为止还不错。现在事情变得更有趣了，因为我们的下一步是向我们的应用程序添加交互元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/67ca4e76c38ad3a9226f4c21945a5e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*QgCdEGCTk2pNEqG2pjHp4A.jpeg"/></div></figure><p id="0185" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们在第二个单元格中添加另一个布局来容纳我们的交互元素。<em class="mk">复制</em>我们之前使用的相同布局代码，<em class="mk">粘贴</em>在底部。<em class="mk">目标</em>我们最初布局的第二个单元格，使用1行2列，将背景涂成奶油色(或者任何你喜欢的颜色)。我们将<code class="fe ne nf ng nh b">add_layout</code>和<code class="fe ne nf ng nh b">style_layout</code>作为函数添加到前面代码的正下方，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/bd6953daefcbee9471c2cf590a921e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6R3JudbMofTImTG5pMT3g.png"/></div></div></figure><p id="4050" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意，我还使用了<code class="fe ne nf ng nh b">style_layout</code>函数的<code class="fe ne nf ng nh b">column_widths</code>属性在列宽之间进行20/80分割。</p><p id="d1a3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这款应用看起来太“线性”了。让我们通过将边框的<code class="fe ne nf ng nh b">border</code>设置为<code class="fe ne nf ng nh b">0</code>来从最近的布局中移除边框:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/80065799fbcc74e795996ad3492ebce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-KiXR2VGvMcOec8wexAzA.png"/></div></div></figure><p id="d82d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这样更干净。然而，我仍然希望我们内部布局的两个单元之间有某种分离。让我们从俄罗斯调色板中为第二个单元格“Squeaky”着色:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/02c0cde22c05ef26ccfe8faf107c0ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJznifW9_9ZvGF1QUUFKTA.png"/></div></div></figure><p id="3a39" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，我们的应用程序不再需要任何边框，因为颜色单独划分了我们的布局单元格。让我们通过移除外部布局的(我们添加的第一个)边界来使它最小化和平滑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/d4ab19f429112914472413eb45222db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jbw95niBQflhgLizdzFdrg.png"/></div></div></figure><p id="44a5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这里是此时的<a class="ae kv" href="https://codepen.io/cybertime/pen/yLJZbEm" rel="noopener ugc nofollow" target="_blank">密码本</a>。</p><p id="33b1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在我们准备添加我们的交互元素。我们没有从我们想要创造的任何<strong class="lq ir">模型</strong>开始，这很好。但是现在可能是一个好时机去思考我们想要的是什么。</p><p id="6701" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当今大多数有趣的应用程序都是数据驱动的。我们可以获取什么样的有趣数据，我们可以使用什么样的模型？当我写这篇文章时，每个人都在想着新冠肺炎。让我们获取新冠肺炎的数据，并使用一个模型来预测病例。</p><blockquote class="nx ny nz"><p id="8e0e" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated">****通常的<strong class="lq ir">免责声明</strong>* * * * * *别傻了，用这个模型来做关于疫情的现实生活决策。这只是为了演示的目的。</p></blockquote><p id="99ba" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们想要公开可用的数据，理想情况下作为“<a class="ae kv" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> RESTful服务</a>”(“REST API”)交付。REST APIs将数据和功能“通过网络”传递到我们的浏览器中，使得创建有趣的应用程序变得更加容易，而无需编写大量代码。</p><p id="19f7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果有人提供新冠肺炎数据作为REST API，这意味着我们不必自己存储/管理数据；我们可以直接用它</p><p id="3556" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我在这里找到了一个:<a class="ae kv" href="https://t.co/CWGBGGIWXx?amp=1" rel="noopener ugc nofollow" target="_blank">https://about-corona.net</a>它是免费的，不需要认证。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/8934d3802d8080e5d92bd05ac9cfe0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnxCrgYPz7l68CuU8WrG7w.png"/></div></div></figure><p id="8eb6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">REST APIs有“端点”，我们用浏览器指向这些端点来获取实际数据。查看文档后，我找到了我们将使用的端点:</p><p id="7161" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b"><a class="ae kv" href="https://t.co/pvWimRKAi3?amp=1" rel="noopener ugc nofollow" target="_blank">https://corona-api.com/timeline</a></code></p><p id="61b0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这给出了全球死亡<strong class="lq ir">、</strong>、确诊和<strong class="lq ir">痊愈</strong>病例的总数。</p><p id="dce6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">任何时候你想看REST API的数据是什么样子，只需<em class="mk">打开你的浏览器</em>到端点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/935e7aec4b19584143c7a9725dfe98ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcCp04NZSeDJeM9wwrgbyw.png"/></div></div></figure><p id="8e1a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了在我们的应用程序中使用数据，我们不像上面那样访问它，而是使用JavaScript<em class="mk">摄取</em>数据，并将结果解析成某种有用的形式。但首先，让我们回到我们的模型。现在我们已经看到了数据，我们可以考虑我们的应用程序可能的外观和行为。</p><p id="8e3e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">一个肮脏的模型是我们锚定我们的方法所需要的。这是我用谷歌幻灯片创作的草图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/8e03d5f85dbb91303f4505c1f81eb232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwZv_pEx-NLbhjwyNDDBfA.jpeg"/></div></div></figure><p id="d671" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">用户选择一种类型(死亡、已确认、已康复)，结果显示在右侧的图表中。然后，用户选择一个“地平线”(未来几天)，并单击FORECAST在后端运行一个模型，其结果在返回时也会可视化。</p><p id="9b17" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">有了数据和模型，我们可以开始添加交互UI元素。我们需要一个<strong class="lq ir">下拉菜单</strong>，一个<strong class="lq ir">滑块</strong>，一个<strong class="lq ir">按钮</strong>，以及一个<strong class="lq ir">线图</strong>。先说前3个。我将在第一个内部布局单元格中添加一个新布局，以帮助定位我们的元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="d5e3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，我将<code class="fe ne nf ng nh b">border</code>设置为<code class="fe ne nf ng nh b">1</code>，这样我就可以看到新的布局:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/559ff87a5fe6e6369733605c858024a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXxdbKGf5Iop7nTd47sTLA.png"/></div></div></figure><p id="bafa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在让我们<em class="mk">在这些新的单元格中添加</em>我们的UI元素。从Azle的文档中我们可以得到我们需要的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo nl l"/></div></figure><p id="b8c7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><em class="mk">添加</em> <strong class="lq ir">下拉菜单</strong>、<strong class="lq ir">滑块</strong>和<strong class="lq ir">按钮</strong>代码到我们的应用程序中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="6354" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">嘣，现在我们有了UI元素:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/387faad851e9efd7491b992931b40142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*aHsOebw8eibjO7TCGg5mpw.gif"/></div></figure><p id="e649" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们<em class="mk">为我们的应用程序定制</em>这些元素。我们知道下拉列表中需要的选项(死亡、已确认、已康复)。现在添加:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="be07" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们为预测留出最多<code class="fe ne nf ng nh b">30</code>天的时间。将默认值设置为1周(<code class="fe ne nf ng nh b">7</code>天)，最小值为<code class="fe ne nf ng nh b">1</code>天，最大值为<code class="fe ne nf ng nh b">30</code>天:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="bfdd" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们<em class="mk">将</em>元素居中，<em class="mk">将</em>边框从最近的布局中移除。</p><p id="f369" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们将在新的<code class="fe ne nf ng nh b">style_layout</code>函数前使用<code class="fe ne nf ng nh b">all_</code>前缀，将中心对齐一次应用于所有3个单元格:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="8a16" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我还将布局上的边框设置为<code class="fe ne nf ng nh b"> 0</code>，因为我们不再需要它。</p><blockquote class="nx ny nz"><p id="23e2" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated">开发时在1和0之间切换边框。</p></blockquote><p id="a10a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b">halign</code>和<code class="fe ne nf ng nh b">center</code>确保所有3个单元格的内容水平对齐。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/1535d34f7c87561920b4200d3ce72fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EKxMBxrNS5yNCdhtGvWug.png"/></div></div></figure><p id="d820" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在让我们将<em class="mk">添加</em>我们的<strong class="lq ir">线图</strong>可视化。</p><p id="b0a9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在开始看起来像一个真正的应用程序。对于折线图，我们将使用另一个名为<a class="ae kv" href="https://plotly.com/javascript/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">的库。Plotly构建在<strong class="lq ir"> D3.js </strong>之上，这是一个用Javascript编写的行业标准可视化库。</strong></a></p><div class="or os gp gr ot ou"><a href="https://t.co/ROsNy5974s?amp=1" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">Plotly JavaScript图形库</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">Telsa Motors和Standard &amp; Poors等组织将Plotly.js开发与Chart Studio Enterprise配对，后者…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">t.co</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi kp ou"/></div></div></a></div><p id="ac0d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">虽然您可以学习D3.js本身，但Plotly提供了一个抽象层，使开发(更)快速。<em class="mk">点击Plotly网站上的</em>折线图选项:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pj nl l"/></div></figure><p id="b41f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们将<em class="mk">将折线图代码复制到我们的应用程序中。首先，我们需要使这个库可用。使JS库对应用程序可用的最简单的方法是通过<strong class="lq ir"> CDN </strong>(内容交付网络)。我们只需将适当的URL添加到我们的<code class="fe ne nf ng nh b">index.html</code>文件的头中。我们从Plotly的<a class="ae kv" href="https://plotly.com/javascript/getting-started/#plotlyjs-cdn" rel="noopener ugc nofollow" target="_blank">入门</a>页面找到了这个URL:</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/20185f1dd502d8e1a05cea6d694a9b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fcI2T3oJU46NMVHhVO_7eQ.jpeg"/></div></div></figure><p id="9b18" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在我们可以在我们的应用程序中使用任何Plotly的视觉效果。<em class="mk">从Plotly的网站上抓取</em>的<a class="ae kv" href="https://plotly.com/javascript/line-charts/" rel="noopener ugc nofollow" target="_blank">折线图代码</a>并将其放入一个名为<code class="fe ne nf ng nh b">draw_line_chart</code>的函数中，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="154f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">将它放在<code class="fe ne nf ng nh b">index.html</code>文件中的任何地方，主<code class="fe ne nf ng nh b">create_azle</code>函数之外(所以在底部的任何地方，但是仍然在<code class="fe ne nf ng nh b">&lt;script&gt;</code>标签之内)。<em class="mk">看看下一个密码本就知道了。</em></p><p id="28d9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果我们调用我们的<code class="fe ne nf ng nh b">draw_line_chart</code>函数，它将在id为<code class="fe ne nf ng nh b">my_div</code>的元素中绘制我们的折线图。当然，我们现在没有这样的元素，所以让我们创建一个HTML元素来存放我们的情节。</p><p id="7b48" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们将使用Azle的<code class="fe ne nf ng nh b">add_html</code>函数。我将给div一个名为“hold_chart”的id:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="3137" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们回过头来，将前面的<code class="fe ne nf ng nh b">draw_line_chart</code>函数中的‘my div’改为’<strong class="lq ir">hold _ chart</strong>，这样它就能正确定位目标。</p><p id="79ed" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们需要一种方法来调用我们的<code class="fe ne nf ng nh b">draw_line_chart</code>函数。让我们点击预测按钮来绘制我们的折线图。</p><p id="26b9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了将<strong class="lq ir">事件</strong>添加到Azle的UI元素中，我们使用了<code class="fe ne nf ng nh b">add_event</code>函数。让我们向预测按钮添加一个点击事件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="1f4a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果我们现在单击“预测”按钮，我们将看到绘制的折线图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/c6b185141a2dd8668f300d9c0b7c0089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*xlOLA7IFS-CDu-YrVGXi1w.gif"/></div></figure><p id="6a60" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">看起来很棒。这是最新的<a class="ae kv" href="https://codepen.io/cybertime/pen/oNLVMWG?editors=1000" rel="noopener ugc nofollow" target="_blank">密码本</a>。</p><p id="b89d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">Plotly提供了许多现成的东西。我们得到了<strong class="lq ir">工具提示</strong>、<strong class="lq ir">缩放</strong>、<strong class="lq ir">平移</strong>，以及一系列可定制的选项。在raw D3里自己做这些并不好玩。</p><p id="ac2f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">折线图显示的数据只是Plotly提供的模拟数据。显然，我们想获得真实的数据。让我们现在做那件事。</p><p id="a050" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我前面提到过，我们将使用JavaScript获取其余数据，并将结果解析成某种有用的形式。关于构建依赖提取数据的应用程序，一个重要的事实是数据必须在使用之前可用。</p><p id="e3b0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">虽然这听起来很明显，但当一个人刚刚开始学习软件开发时，很容易忽略这一点。例如，当我们的用户第一次加载我们的应用程序时，我们希望显示折线图。但是这个线图依赖于可用的数据。</p><p id="9f2b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了确保我们的应用程序的任何部分都可以使用数据，我们使用了所谓的“异步代码”异步代码在调用我们选择的函数之前会一直等待，直到发生了什么事情(例如，数据已经被获取)。</p><p id="cc39" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在我们的例子中，我们希望<em class="mk">获取</em>新冠肺炎数据，<em class="mk">等待</em>直到它在我们的应用程序中可用，然后绘制我们的折线图。JavaScript通过它的“获取”API使这一切成为可能。使用fetch，我们只需指向REST服务提供的URL，并告诉它一旦收到数据该做什么。</p><p id="7aac" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们使用fetch将我们的新冠肺炎数据引入我们的应用程序。我们如何使用它？一个简单的谷歌搜索把我带到了今年的<a class="ae kv" href="https://mzl.la/2ysL4pm" rel="noopener ugc nofollow" target="_blank"/>，这很好地解释了这个问题。它告诉我们像这样使用fetch:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/26b36af5851c1191717d687f6612971a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f97AYyMC8SEJtWuazQn1oQ.png"/></div></div></figure><p id="f059" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们<em class="mk">将</em>粘贴到我们的代码中，使用我们在上面找到的新冠肺炎URL(就在我们的Plotly代码之后):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/d9828d7f8ce893b4ad25f097155bd6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGCCWbJ_FWjdcAVYFZNEig.png"/></div></div></figure><p id="8f9c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">刷新您的浏览器。应用程序本身看起来没有任何不同。但是如果我们打开“<strong class="lq ir">浏览器控制台</strong>，我们可以看到我们获取的新冠肺炎数据。通过在<em class="mk">屏幕上的任意位置右击</em>并点击<strong class="lq ir">检查</strong>，打开浏览器控制台。然后单击控制台。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm nl l"/></div></figure><p id="2a8f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">你会看到一个<strong class="lq ir">物体</strong>坐在控制台上。这是我们获取的新冠肺炎数据(注意，我们在上面粘贴的获取API显示console.log(data))。重复单击此对象以查看其结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nl l"/></div></figure><p id="7fd5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这看起来比我们第一次指向新冠肺炎网址时出现在浏览器中的要好得多。现在我们可以<em class="mk">解析</em>这个数据对象，使用它的内容来填充我们的折线图。为此，我们需要对绘制折线图的方式做一点小小的改变。</p><p id="f5ba" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">检查我们之前添加的折线图代码，我们可以看到它使用“跟踪”将原始数据转换为线条。我们需要将获取结果中的数据放入跟踪对象的x和y属性中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/5a738abb84a2deb14f6dbb2b8ae48de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BgrMeNFqbNyUnwRRKpd9Aw.jpeg"/></div></div></figure><p id="760e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们编写一些JavaScript来解析获取的结果。我们需要:1。了解源结构；2.了解目的地结构。我们可以像前面一样，通过在浏览器控制台中检查数据来理解源结构。</p><p id="19e6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">目的结构是Plotly需要的trace对象。我编写了以下函数来获取从fetch检索的原始数据，并将其转换为Plotly所需的跟踪结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="2862" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">函数</strong>是我们在软件中对代码进行分组的方式。它们有一个名字，接受参数，并返回一些结果。函数有助于保持代码的模块化和可维护性。</p><p id="ad4b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这里重要的是理解这不是解析数据的<em class="mk">和</em>方式。这是一种方式。您必须尝试使用JavaScript，直到找到合适的为止。在线搜索如何解析JavaScript对象、遍历对象并返回新的结构。</p><p id="0dd7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我的<code class="fe ne nf ng nh b">get_dates_and_cases</code>函数接受提取的数据，一个选择(例如死亡)，循环遍历它的内容，提取我需要绘制的片段，并返回Plotly的对象。我将编写另一个函数，用我们准备好的数据绘制折线图。</p><p id="d1bd" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们可以删除我们添加的原始Plotly代码，并使用该函数来代替。它使用我们的第一个函数来准备跟踪数据，然后像往常一样绘制折线图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="9414" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请确保保留我们添加的“hold _ chart”div，以便绘图有地方可去。</p><p id="50cc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">回想一下，我们的获取代码只获取数据，但不处理数据。一旦数据到达，让我们的fetch函数绘制我们的折线图。将我们的原始获取代码更改为如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="54c9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">最后，移除对当前位于我们的<code class="fe ne nf ng nh b">add_event</code>函数中的<code class="fe ne nf ng nh b">draw_line_chart</code>的调用。我们一会儿再把它加回去。还有，现在还不用担心<code class="fe ne nf ng nh b">az.hold_value.fetched_data = data</code>线。我们稍后再解释。</p><p id="a616" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">您当前的代码应该是这样的:<a class="ae kv" href="https://codepen.io/cybertime/pen/BazEQaQ?editors=1000" rel="noopener ugc nofollow" target="_blank"> CodePen </a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/c2b7c8ad5104b69c659eb19a354bf28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUnDzGe8qizbr3Dhv6AHvg.jpeg"/></div></div></figure><blockquote class="nx ny nz"><p id="f32b" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated">注意，在CodePen中，我在fetch函数周围包装了一个<code class="fe ne nf ng nh b">setTimeout</code>。这只是增加了一点延迟，以确保绘制图形时元素在屏幕上。一旦我们在下一步将fetch函数移到我们的<code class="fe ne nf ng nh b">add_event</code>内部，这就不是问题了。</p></blockquote><p id="9da8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们的covid数据现在显示在折线图中。重要的是，只有从REST API中完全提取数据后，才会绘制折线图。概括地说，我们使用JavaScript中的异步代码从API获取数据，然后在数据准备好之后创建一个可视化。</p><p id="6e86" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们还编写了两个函数来准备原始数据和绘制结果。我们越来越接近了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/c42d4a3faab5876ac257ad2dce3e7144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQzjw7XJdcOrC-KDPcnLVw.jpeg"/></div></div></figure><p id="6955" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">…尽管我们还没有讨论数据存储。</p><p id="3672" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们的下一步是允许用户<em class="mk">选择</em>一个选择(<strong class="lq ir">死亡</strong>、<strong class="lq ir">确诊</strong>、<strong class="lq ir">痊愈</strong>)来相应地重新绘制折线图。让我们<strong class="lq ir">存储</strong>返回的数据，这样我们可以在需要时使用它，而不必每次都重新提取数据。</p><p id="9374" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我将把返回的数据保存在一个JavaScript对象中。我将像这样使用Azle的名称空间:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/9ba01c02cf1bc8f9f67e561c3cd2eb81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVwefVBLkYJbnHLE8YCLvA.png"/></div></div></figure><p id="8f43" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><em class="mk">在浏览器控制台中键入</em> <code class="fe ne nf ng nh b">az.hold_value.fetched_data</code>，然后<em class="mk">点击</em>回车。您可以看到，我们可以通过简单地使用这个对象随时访问我们的新冠肺炎数据。</p><p id="f686" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">首先，我们想在用户从下拉列表中做出选择时重新绘制折线图。让我们使用Azle的“<code class="fe ne nf ng nh b">change</code>”事件来实现这一点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pp nl l"/></div></figure><p id="19a0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了<em class="mk">添加</em>一个事件到我们的元素中，我们使用Azle的<code class="fe ne nf ng nh b">add_event</code>函数，就像我们之前对按钮所做的一样，目标是选择的元素，就像我们对样式所做的一样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="c24c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果您刷新浏览器并从下拉列表中进行选择，您应该会看到提示选择。</p><p id="1b18" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在我们只需要<strong class="lq ir">重绘折线图</strong>而不是调用alert。我们之前写的<code class="fe ne nf ng nh b">draw_line_chart</code>函数已经准备好了。它已经将数据和选择作为参数，并相应地重新绘制图形。所以我们需要做的就是将<code class="fe ne nf ng nh b">draw_line_chart</code>添加到<strong class="lq ir">下拉菜单</strong>的<code class="fe ne nf ng nh b">add_event</code>函数中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nl l"/></div></figure><p id="e690" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意，我们使用的是存储在<code class="fe ne nf ng nh b">az.hold_value.fetched_data</code>中的数据。我们还使用了一个叫做<code class="fe ne nf ng nh b">grab_value</code>的新Azle函数；这允许我们获取用户在元素上选择的任何值(像往常一样，用<code class="fe ne nf ng nh b">class name</code>和<code class="fe ne nf ng nh b">class instance</code>定位)。</p><p id="c6fa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们看看它是否有效:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pq nl l"/></div></figure><p id="caf9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">太美了。</p><p id="a6d8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这是目前的<a class="ae kv" href="https://codepen.io/cybertime/pen/rNLbXJz?editors=1000" rel="noopener ugc nofollow" target="_blank">代号</a>。</p><p id="fbfb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">向其他元素添加事件也是同样的方式。但是这些元素涉及到调用一些后端模型来使用我们的新冠肺炎数据进行预测。因此，在添加其他事件之前，让我们开始处理后端<strong class="lq ir">模型</strong>。</p><p id="07a9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">对于“后端”,我们需要一台服务器来支持计算我们的预测所需的繁重工作。我们可以使用云提供商，如<a class="ae kv" href="https://www.digitalocean.com/" rel="noopener ugc nofollow" target="_blank">数字海洋</a>或<a class="ae kv" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务</a>，但是因为我们只是在原型制作想法，我们将使用我们自己的<strong class="lq ir">本地</strong>计算机。</p><p id="40b9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让前端与后端通信需要一个<strong class="lq ir"> web服务</strong>。web服务将允许我们向服务器发送请求并接收一些回报。这就是我们所需要的，因为我们想从我们的前端给一个后端模型数据，并返回一个预测。</p><p id="3720" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们将使用一个名为<a class="ae kv" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> Flask </strong> </a>的轻量级web框架来用Python构建我们的web服务。让我们现在做那件事。一开始，我们创建了我们的<code class="fe ne nf ng nh b">index.html </code>文件。让我们将另一个文件添加到同一个文件夹中，将其命名为<code class="fe ne nf ng nh b">predict.py</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr nl l"/></div></figure><p id="8ea1" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我只是复制了index.html文件，并删除了内容，使一个空的<code class="fe ne nf ng nh b">predict.py</code>文件。</p><p id="fd6a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在我们将<em class="mk">添加</em>一些基本的Flask代码到我们当前空白的<code class="fe ne nf ng nh b">predict.py </code>文件中。Flask的文档中有一个<a class="ae kv" href="https://bit.ly/3c9pfct" rel="noopener ugc nofollow" target="_blank">快速入门</a>指南，向我们展示了设置所需的最少代码:</p><p id="ab6c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们将需要更多的东西，比如额外的库，以使我们的web服务适合我们的目的。下面是我们的<code class="fe ne nf ng nh b">predict.py</code>文件的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/4306c7e2b0ed02db6ecb7672b9377084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-B2lA84WDYXlzudwLBasrA.jpeg"/></div></div></figure><p id="037f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在JavaScript中，我们使用“cdn”向应用程序添加额外的库，而在Python中，我们使用<code class="fe ne nf ng nh b">import</code>语句。上面我们正在导入Flask，以及“request”和“jsonify”库，这将使我们能够从前端接收数据和向前端发送数据。</p><p id="5749" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们还设置了一个“路由”,它是我们服务的“端点”。回想一下我们在从REST API获取新冠肺炎数据时对端点的讨论。如果你认为我们正在开发自己的REST API，那么你是对的:)</p><p id="3d50" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如今，企业软件中的许多后端机制都以服务的形式提供，作为REST APIs使用。这使得修补各种功能以及维护和扩展应用程序变得更加容易。</p><p id="07ef" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在我们的<code class="fe ne nf ng nh b">predict.py</code>文件中的“route”下面，我们创建了一个函数。Python函数看起来和Javascript函数不一样，但思想是一样的；一段可以接受参数并返回值的模块化代码。我给我们的函数预测员打了电话。</p><p id="dc40" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">最后，我们在文件末尾指定“端口”。端口是一个编程的停靠点，它允许外界访问我们的本地系统。我选择了5000端口。如果您愿意，您可以选择不同的号码(如果它已经被使用，您的电脑会告诉您)</p><p id="aab3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们启动我们的web服务，看看它是否工作。如果一切顺利，我们将添加我们的预测模型，并开始为我们的应用程序提供真实的预测，以进行消费和可视化。</p><p id="aa91" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">到目前为止，我们只是使用浏览器和记事本来创建我们的应用程序。但是现在我们需要直接与我们的操作系统对话，为此我们必须使用<strong class="lq ir">终端</strong>(PC上的命令提示符)。</p><p id="9901" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我用的是苹果电脑，所以你在这里看到的一切都会在苹果电脑上。但是同样的一般步骤也适用于PC。开放终端。在Mac中，最快的方法是通过键入“command +空格键”和键入“终端”来使用Spotlight搜索:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pt nl l"/></div></figure><p id="9a43" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在终端打开的情况下，通过运行以下命令进入我们的<code class="fe ne nf ng nh b">my_app</code>目录:</p><p id="d217" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b">cd Desktop/my_app/</code></p><p id="a484" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">…然后按回车键。现在键入:</p><p id="9125" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b">ls</code></p><p id="04c3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">…然后再次按回车键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pu nl l"/></div></figure><p id="8d41" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">你应该可以看到index.html和<code class="fe ne nf ng nh b">predict.py</code>文件。很难相信我们的整个应用程序只有2个文件。</p><blockquote class="nx ny nz"><p id="2131" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated">由于当今工具中可用的抽象级别，我们只需要最少的代码来创建一个完整的应用程序。</p></blockquote><p id="9096" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，通过运行以下命令来启动我们的web服务:</p><p id="b21b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b">python predict.py</code></p><p id="3b44" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">…然后按回车键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pv nl l"/></div></figure><p id="ddaa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">您现在正在运行一个web服务，将您的Python代码公开给任何能够与之通信的应用程序。考虑到现在Python中有这么多高性能的库，这很酷。想想你能创造什么！</p><p id="9a3f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们的后端在"<strong class="lq ir"> localhost </strong>"，<strong class="lq ir"> port </strong> <strong class="lq ir"> 5000 </strong>上被服务，带有一个<em class="mk">端点</em>叫做" predict_covid "，接受<em class="mk">参数</em>叫做" x "和" y "。要“通过网络”传递所有这些信息，我们可以构建以下URL:</p><p id="6c74" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b"><a class="ae kv" href="http://localhost:5000/predict_covid/?x=100&amp;y=400" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/predict_covid/?x=100&amp;y=400</a></code></p><p id="93a7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这是在浏览器中使用URL时与REST API通信的标准方式。那个？标记在第一个参数名之前，而&amp;在第二个参数名之前。在浏览器中打开一个新标签，将上面的URL添加到顶部，然后按回车键。您应该看到以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/edd7966a89adaa1d1f68081e19e1ba26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkW9vztyEm_PBmzt_zJUJw.png"/></div></div></figure><p id="4203" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们的web服务只是返回我们为“x”和“y”传递的值。不太令人兴奋，但它确实证明了我们的web服务是有效的。</p><p id="ff56" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们把它们端到端地连接起来，这样我们用JavaScript (Azle)编写的前端应用程序就可以向我们的web服务(而不是浏览器)传递数据，并从其接收数据。如果我们成功了，剩下唯一要做的事情就是用Python构建一个好的预测模型。</p><p id="f9b5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们需要将以下数据传递到我们的后端:</p><ul class=""><li id="ce43" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj mv mw mx my bi translated">下拉选择</li><li id="e84f" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">滑块值</li><li id="3a1a" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">日期和案件数量</li></ul><blockquote class="nx ny nz"><p id="a31c" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated"><strong class="lq ir">注意</strong>:我们可以在后端获取covid数据，而不是通过网络传递它，但是这样我们会获取数据两次。因为我们只预测几个日期和值，所以使用已经从前端获取的数据更有意义。</p></blockquote><p id="ddff" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们已经知道如何使用Azle的<code class="fe ne nf ng nh b">grab_value</code>函数从UI元素中“获取”值。我们还在我们的<code class="fe ne nf ng nh b">az.hold_value.fetched_data</code>对象中很好地构造了我们获取的数据。</p><p id="37c0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">要将它发送给我们的web服务，我们可以再次使用JavaScript的<code class="fe ne nf ng nh b">fetch</code> API。相反，让我们在按钮的事件监听器中使用Azle的<code class="fe ne nf ng nh b">call_api</code>函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/377fc153a5abf6dc934401a7ab8e9e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvkRF-evQoDbSmn2LQTleA.jpeg"/></div></div></figure><p id="4eb5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">下面是正在发生的事情的分类:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/51afc071769a52ec309a569a8930f690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XS3ud75h6bq_XRcj-xUUew.jpeg"/></div></div></figure><p id="fdc9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们在按钮上添加了一个“事件监听器”，就像我们之前在下拉菜单上做的一样。我们还在事件的函数属性中添加了Azle的<code class="fe ne nf ng nh b">call_api</code>,指定了Flask服务的URL,“x”和“y”参数，以及数据返回时的警告。</p><p id="2762" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">刷新浏览器并点击预测按钮:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pz nl l"/></div></figure><p id="5166" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们的应用程序正式与我们的后端服务进行交互，向我们的Python代码传递数据，并从它接收响应。让我们用我们需要发送的实际数据来替换参数“x”和“y ”,并从滑块值中添加预测范围。</p><p id="d0a7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这里，我从现有的<code class="fe ne nf ng nh b">get_dates_and_cases</code>函数中获取滑块值以及“x”和“y”数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/68ca2f606e195b2bba673b5f069f0169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmd7X2gsexVfugySwabGNQ.jpeg"/></div></div></figure><p id="1202" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们现在已经安排好了我们的活动:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/55cbc001ae6d24995b1122e9b70dfc5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7SvOdS6J74cpzFJ8iiDdw.jpeg"/></div></div></figure><p id="120c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">最后，我们来建立一个预测模型，根据用户选择的类型(<strong class="lq ir">死亡</strong>、<strong class="lq ir">确诊</strong>、<strong class="lq ir">痊愈</strong>)和层位进行预测。经过一番搜索，我找到了一个名为<a class="ae kv" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> Prophet </strong> </a>的库，它是由脸书开源的。</p><blockquote class="nx ny nz"><p id="2668" class="lo lp mk lq b lr ml jr lt lu mm ju lw oa mn lz ma ob mo md me oc mp mh mi mj ij bi translated">脸书最近也发布了他们的<a class="ae kv" href="https://github.com/ourownstory/neural_prophet?utm_source=hootsuite&amp;utm_medium=&amp;utm_term=&amp;utm_content=&amp;utm_campaign=" rel="noopener ugc nofollow" target="_blank">神经先知</a>版本。</p></blockquote><p id="8318" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">Prophet是一个时间序列预测库，有一个针对Python的<a class="ae kv" href="https://bit.ly/3d9ak36" rel="noopener ugc nofollow" target="_blank">快速入门</a>指南，应该可以让我们开始运行。</p><p id="ed4f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们最终的<code class="fe ne nf ng nh b">predict.py</code>文件从前端接收数据(我们已经知道如何做)，准备Prophet库所需的数据(如他们的文档中所指定的)，训练预测模型，进行预测，并返回结果。</p><p id="b2e3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">所有这些都在大约10行代码中。还不错！(这种抽象又为我们工作了)。</p><p id="bb8c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在我们的<code class="fe ne nf ng nh b">index.html</code>文件中，我添加了两个新的函数来为第二次跟踪准备数据(显示预测)。您会看到它与我们为trace 1编写的非常相似。我还将新的<code class="fe ne nf ng nh b">draw_forecast</code>函数添加到了我们的<code class="fe ne nf ng nh b">call_api</code>函数的<code class="fe ne nf ng nh b">done</code>属性中。</p><p id="b37b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">看看最后的<code class="fe ne nf ng nh b">index.html</code>看看变化。您应该将最后的更改视为熟悉的代码。如果有什么东西看起来很陌生，在网上搜索一下，了解一下为什么它会被添加进来。</p><p id="168d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们最后一次刷新浏览器，看看完整的应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qa nl l"/></div></figure><p id="b397" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们实现了最初清单上的所有目标:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/166b788307a98dbbde279018c9fb4bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bEdwaOjrTfxwxBSLS37OA.jpeg"/></div></div></figure><p id="c2f9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在唱完之前，我想添加一个<strong class="lq ir">微调器</strong>，当用户点击预测时，他们就知道要<em class="mk">等待</em>结果。我还希望Plotly图表是透明的，这样我们就可以看到我们有漂亮的蓝色背景。最后，我要改变我们的应用程序的标题，因为它是真实的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qb nl l"/></div></figure><p id="a0ff" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">你可以在这里找到<strong class="lq ir">最终代码</strong>:</p><div class="or os gp gr ot ou"><a href="https://t.co/8xS6zvu9e3?amp=1" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd ir gy z fp oz fr fs pa fu fw ip bi translated">Sean-mcclure/开始构建软件</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">t.co</p></div></div><div class="pd l"><div class="qc l pf pg ph pd pi kp ou"/></div></div></a></div><p id="a006" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">而这里是<a class="ae kv" href="https://codepen.io/cybertime/pen/ZEOZgqJ?editors=1000" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">决赛</strong> <strong class="lq ir"> CodePen </strong> </a>。请注意，因为CodePen没有运行我们的后端web服务，所以您不会看到预测。但是在您的本地机器上一切都应该正常工作。</p><p id="8c7b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些是构建任何应用程序的主要部分。有了这些技能，你就可以进入软件开发的世界(或者只是把它作为一种爱好来构建东西)。</p><p id="a40a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">就是这样。这篇文章可能看起来很长，但是考虑到你刚刚用<em class="mk">所有的</em>主要部分制作了一个<em class="mk">完整的</em>应用程序，还不算太糟糕。如果你遇到困难，可以在<a class="ae kv" href="https://twitter.com/sean_a_mcclure" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我。我们将一起研究代码。不要停在这里。试试其他库。其他用例。其他任何东西。只是建造。</p><p id="c4fd" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">再说一次，机会的唯一看门人是你自己。</p></div></div>    
</body>
</html>