<html>
<head>
<title>How to represent the game state of 2048</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何表现2048年的游戏状态</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-represent-the-game-state-of-2048-a1518c9775eb?source=collection_archive---------21-----------------------#2020-10-02">https://towardsdatascience.com/how-to-represent-the-game-state-of-2048-a1518c9775eb?source=collection_archive---------21-----------------------#2020-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="523d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/playing-2048-with-minimax" rel="noopener" target="_blank">用极大极小算法玩2048</a></h2><div class=""/><div class=""><h2 id="055a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">以及如何以面向对象的方式实现它</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/5064377ace05d06054e5a5e2cbf00da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7Ktzm_LdOrfUCkzulsZQFA.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="efcb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在关于解决这个游戏的上一篇文章中，我已经在概念层面上展示了如何应用极大极小算法来解决2048游戏。但是为了将这些想法付诸实践，我们需要一种方法来表示游戏的状态并对其进行操作。我选择以面向对象的方式，通过一个我命名为<code class="fe md me mf mg b">Grid</code>的类来这样做。这个类保存游戏状态，并为我们提供进一步实现极大极小算法所需的方法(在下一篇文章中)。</p><p id="3abc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你错过了我以前的文章，这里是:</p><div class="mh mi gp gr mj mk"><a rel="noopener follow" target="_blank" href="/playing-2048-with-minimax-algorithm-1-d214b136bffb"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd jd gy z fp mp fr fs mq fu fw jc bi translated">如何将Minimax应用到2048年</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">2048年——一个简单的游戏，但是给计算机编程来解决它并不简单</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">towardsdatascience.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my lb mk"/></div></div></a></div></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="3b79" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们开始用Python实现<code class="fe md me mf mg b">Grid</code>类。</p><p id="df7b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<code class="fe md me mf mg b">Grid</code>类中，我们将游戏状态保存为一个矩阵，矩阵中有方块数，在有空方块的地方，我们将保存一个0。在Python中，我们将使用一个列表列表，并将它存储到<code class="fe md me mf mg b">Grid</code>类的<code class="fe md me mf mg b">matrix</code>属性中。</p><p id="fe02" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这种表示法的一个例子如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ng"><img src="../Images/683820280ff756a3223d28f94e8371e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RK43XDMQScJsR8Y3nbwqg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="ca23" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们的实现中，我们需要稍微传递一下这个矩阵；我们将从一个<code class="fe md me mf mg b">Grid</code>对象获取它，然后用它实例化另一个<code class="fe md me mf mg b">Grid</code>对象，等等。因此，为了避免通过引用传递它所带来的副作用，我们将使用<code class="fe md me mf mg b">deepcopy()</code>函数，因此我们需要导入它。我们将导入的另一个东西是<code class="fe md me mf mg b">Tuple</code>，以及来自<code class="fe md me mf mg b">typing</code>的<code class="fe md me mf mg b">List</code>；这是因为我们将使用类型提示。</p><pre class="ks kt ku kv gt nh mg ni nj aw nk bi"><span id="81b7" class="nl nm it mg b gy nn no l np nq">from copy import deepcopy</span><span id="2ec0" class="nl nm it mg b gy nr no l np nq">from typing import Tuple, List</span></pre><p id="6c8c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以从创建用于设置和获取类的矩阵属性的方法开始。然后我们将创建一个在棋盘上放置瓷砖的方法；为此，我们只需将矩阵的相应元素设置为瓷砖的编号。输入行/列参数是1索引的，所以我们需要减去1；图块编号按原样分配。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="43f3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后我们将定义<code class="fe md me mf mg b">__init__()</code>方法，它将只是设置矩阵属性。</p><p id="69b0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于minimax算法，我们需要测试<code class="fe md me mf mg b">Grid</code>对象的相等性。当两个对象的矩阵相同时，我们将认为两个<code class="fe md me mf mg b">Grid</code>对象是相等的，我们将使用<code class="fe md me mf mg b">__eq__()</code>魔法方法来做到这一点。我们遍历2个矩阵的所有元素，一旦有不匹配，我们就返回False，否则最后返回True。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="829a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们创建一个实用方法。这个方法评估我们的游戏网格“有多好”。对此可能有许多可能的选择，但是这里我们使用下面的度量(如前一篇文章中所述):对矩阵的所有元素求和，然后除以非零元素的数量。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e256" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下一段代码有点棘手。我们需要检查Max是否能做以下动作之一:上、下、左、右。每一步的代码都非常相似，所以我将只解释其中的一步:up，它是在<code class="fe md me mf mg b">.canMoveUp()</code>方法中实现的。</p><p id="4353" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当我们想做“向上”移动时，事情只能垂直变化。棋盘的不同列之间没有交互作用。因此，我们可以为每一列独立运行代码。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a75748df4ce0578efa12b65500a245be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYmivKrnx6hpDU6Zxd8lOQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="5b1c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以在for循环中这样做:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/f2de17e6975cfbb9d290f783ed641ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2y1dGMrMF6_AuPVxlbC-Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="ceaa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们不一定需要检查所有的列。一旦我们遇到一个允许在“向上”移动中改变某些东西的列，我们就返回True。如果没有这样的列，我们最后返回False。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nv"><img src="../Images/142e8e95ba52aabc04b16680d73ef5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Amyc3BYaGxyeBdguaTtdRw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="db08" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于每一列，我们执行以下操作:从底部开始向上移动，直到遇到一个非空(&gt; 0)元素。在我们看到这样一个元素之后，我们如何知道一个“向上”的移动是否改变了这个列中的一些东西呢？有两种可能的情况会产生变化:要么有一个空方块可以移动，要么有两个相邻的相同的方块。</p><p id="3621" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">举个例子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e7e24f95da477613a0952cb742cd8470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*menBzcYtbh_8vB2NTc-VNA.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/bfb3bd1b6043036bf1ec3a28c5ec9f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLSJnHWeO2wvqRFw5GFC1A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者提供的图片</p></figure><p id="53a8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面突出显示的代码负责查找最下面的非空元素:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/7eb758a0eb1f74eef263d9c04c31723e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COm9rJzxYwZc1OdiEyn5eA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="c012" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面突出显示的这段代码一旦找到可以移动方块的空方块或两个方块之间可能的合并，就返回True。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/aa6da3c3842ab6a0d002aaedfd31164b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPqFHJkkmD2PngOAySWE4w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="0a3c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是所有这些方法的代码，它们与<code class="fe md me mf mg b">.canMoveUp()</code>方法的工作方式相似。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3078" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将需要一个方法，返回最大和最小的可用移动。对麦克斯来说，这是动作的子集:上，下，左，右。我们将这些移动表示为整数；每个方向都有一个相关的整数:</p><ul class=""><li id="37b0" class="ny nz it lj b lk ll ln lo lq oa lu ob ly oc mc od oe of og bi translated">向上= 0</li><li id="8846" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">向下= 1</li><li id="0de2" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">左= 2</li><li id="7a41" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">右= 3</li></ul><p id="7218" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<code class="fe md me mf mg b">.getAvailableMovesForMax()</code>方法中，我们使用之前创建的方法检查我们是否可以在每个方向上移动，如果某个方向的结果为真，我们将相应的整数附加到一个列表中，我们将在方法结束时返回该列表。</p><p id="43a8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe md me mf mg b">.getAvailableMovesForMin()</code>方法将返回网格上的空位置集和{2，4}集之间的叉积。该返回值将是(row，col，tile)形式的元组列表，其中row和col是空单元格的1索引坐标，tile是{2，4}之一。</p><p id="f11d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe md me mf mg b">.getChildren()</code>采用一个可以是“最大”或“最小”的参数，并使用前面两种方法之一返回适当的移动。这些是在极大极小算法的树中导致子游戏状态的移动。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ad47" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于极大极小算法，我们需要一种方法来确定一个游戏状态是否是终结的。正如我在上一篇文章中所说的，如果没有可用的移动，或者达到了一定的深度，我们将认为游戏状态是终结的。但是在极大极小算法内部检查深度条件会更容易，而不是在这个类内部。因此，通过<code class="fe md me mf mg b">.isTerminal()</code>方法，我们将只检查最大值或最小值是否有可用的移动。一个简单的方法是使用<code class="fe md me mf mg b">.getAvailableMovesForMin()</code>或<code class="fe md me mf mg b">.getAvailableMovesForMax()</code>返回一个包含所有走法的列表，如果是空的则返回True，否则返回False。但是更有效的方法是，一旦我们“看到”一个可用的移动就返回False，最后，如果没有返回False，则返回True。</p><p id="5971" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe md me mf mg b">.isGameOver()</code>方法只是<code class="fe md me mf mg b">.isTerminal(who=”max”)</code>的简写，它将在我们的游戏求解循环中用作结束条件(在下一篇文章中)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="80b1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面的方法是用来上下左右移动的。这次我们实际做这些动作，不要只检查能不能做。每个移动方向的代码是相似的，所以，我将只解释向上移动。</p><p id="b67a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">每列都可以独立地向上移动。我们将有一个遍历列的for循环。对于每一列，我们将把变量<code class="fe md me mf mg b">w</code>和<code class="fe md me mf mg b">k</code>初始化为0。<code class="fe md me mf mg b">w</code>保存下一个写操作的位置。<code class="fe md me mf mg b">k</code>存储最后遇到的非空单元格的平铺值。</p><p id="d810" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该算法运行如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ng"><img src="../Images/70acc0b312db525e7af505c65c7a3432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zqaf1oMoQUZZkGF3PDWnLw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="70b1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是一个给定列的工作原理示例:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2a9d7ddd99a4ca7df5536635706bf105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tGFvGNidRWChLytKz9czQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="bacb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是包含所有4种方法的代码:<code class="fe md me mf mg b">.up()</code>、<code class="fe md me mf mg b">.down()</code>、<code class="fe md me mf mg b">.left()</code>、<code class="fe md me mf mg b">.right()</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c511" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们围绕上述4个方法创建了一个包装器，并将其命名为<code class="fe md me mf mg b">.move()</code>，它按照参数给定的方向移动。</p><p id="2fa9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们需要的另一件事是移动的“逆”方法。<code class="fe md me mf mg b">.move()</code>将方向代码作为参数，然后进行移动。现在，我们想要一个方法，它将另一个<code class="fe md me mf mg b">Grid</code>对象作为参数，该对象被假定为对<code class="fe md me mf mg b">.move()</code>的调用的直接子对象，并返回生成该参数的方向代码。我们将这种方法命名为<code class="fe md me mf mg b">.getMoveTo()</code>。</p><p id="723e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个方法的工作原理是创建当前对象的副本，然后依次调用这些副本上的<code class="fe md me mf mg b">.up()</code>、<code class="fe md me mf mg b">.down()</code>、<code class="fe md me mf mg b">.left()</code>、<code class="fe md me mf mg b">.right()</code>，并根据方法的参数测试是否相等。当等式成立时，我们返回适当的方向代码。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b41b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是<code class="fe md me mf mg b">Grid</code>类的完整代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="99a0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这就是本文的全部内容。在下一部(这是关于2048年和minimax的最后一部)中，我们将看到我们如何控制这款游戏的网页版游戏板，实现minimax算法，并看着它比我们玩得更好(…或至少比我好)。</p><div class="mh mi gp gr mj mk"><a rel="noopener follow" target="_blank" href="/how-to-control-the-game-board-of-2048-ec2793db3fa9"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd jd gy z fp mp fr fs mq fu fw jc bi translated">如何控制2048的游戏板</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">…并完成最小最大算法的实现</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">towardsdatascience.com</p></div></div><div class="mt l"><div class="om l mv mw mx mt my lb mk"/></div></div></a></div></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="d5bb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我希望这些信息对你有用，感谢你的阅读！</p><p id="f720" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这篇文章也贴在我自己的网站<a class="ae oo" href="https://www.nablasquared.com/how-to-represent-the-game-state-of-2048/" rel="noopener ugc nofollow" target="_blank">这里</a>。随便看看吧！</p></div></div>    
</body>
</html>