<html>
<head>
<title>Context Managers: a Data Scientist’s View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">上下文管理器:数据科学家的观点</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/context-managers-a-data-scientists-view-9733392ff9c9?source=collection_archive---------40-----------------------#2020-11-10">https://towardsdatascience.com/context-managers-a-data-scientists-view-9733392ff9c9?source=collection_archive---------40-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f73b357f9f0ef0e834893b692fbaa8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxt8rY9Yz57sIbPxoEjyyQ.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/photos/KVihRByJR5g?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditShareLink" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/KVihRByJR5g?utm_source=unsplash&amp;UTM _ medium = referral&amp;UTM _ content = creditShareLink</a></p></figure><div class=""/><div class=""><h2 id="48f6" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">python上下文管理器如何清理您的代码</h2></div><p id="88c1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章是一个系列的一部分，在这个系列中，我将分享我在干净的python代码这个主题上所学到的东西。我是一名数据科学家，希望通过编写更多的python代码来提升自己的python技能，并找到更好的方法来构建更大的代码库。我正在通读Python 中的<a class="ae jd" href="https://www.amazon.com/Clean-Code-Python-Refactor-legacy/dp/1788835832#:~:text=Book%20Description&amp;text=The%20book%20begins%20by%20describing,best%20practices%20for%20software%20design." rel="noopener ugc nofollow" target="_blank">干净代码，并用其他资源丰富材料。我的目标是通过在这里总结来巩固我正在学习的主题，并希望帮助其他人理解这些主题！</a></p><p id="2906" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章是关于Python中的上下文管理器的。首先，我将描述什么是上下文管理器，以及它们为什么有用。然后，我将带您看一个web抓取的实际例子。</p><h1 id="c67a" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">什么是上下文管理器？</h1><p id="633a" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">描述上下文管理器的最好方式是展示一个几乎每个Python程序员都在某个时候遇到过的例子，而不知道他们正在使用它！下面的代码片段打开一个. txt文件，并将这些行存储在python列表中。让我们看看这个是什么样子的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7dcb" class="mx ls jg mt b gy my mz l na nb">with open('example.txt') as f:<br/>    lines = f.readlines()</span><span id="96cd" class="mx ls jg mt b gy nc mz l na nb">print(lines)</span></pre><p id="8c66" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来分析一下。第一行打开一个文件，并将文件对象分配给<code class="fe nd ne nf mt b">f</code>。下一行在file对象上执行<code class="fe nd ne nf mt b">readlines</code>方法，返回一个列表，列表中的每一项代表<code class="fe nd ne nf mt b">example.txt</code>文件中的一行文本。最后一行打印列表。使它成为上下文管理器的原因是，一旦with语句下的缩进被退出，文件就会被隐式关闭。如果没有上下文管理器，代码将如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e08c" class="mx ls jg mt b gy my mz l na nb">f = open('example.txt')<br/>lines = f.readlines()<br/>f.close()</span><span id="1efe" class="mx ls jg mt b gy nc mz l na nb">print(lines)</span></pre><p id="e0b2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用上下文管理器使其可读性更好。想象一个打开和关闭多个文件的脚本，它们之间有操作行。它可能会变得难以阅读，并且您很容易忘记关闭文件。即使遇到异常，也要保证成交。</p><h1 id="1fda" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">编写自己的上下文管理器</h1><p id="1317" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">为了说明如何编写自己的代码，我们将使用一个实际的例子。我最近在使用selenium进行网络抓取时遇到了一个问题，我无法在现有的浏览器中打开一个新的url。解决方案是打开一个新的浏览器来访问url，并在我收集完数据后关闭它。有两种方法可以做到。我们将从定义一个类开始，并使用<code class="fe nd ne nf mt b">__enter__</code>和<code class="fe nd ne nf mt b">__exit__</code> dunder方法。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="66c9" class="mx ls jg mt b gy my mz l na nb"># imports<br/>from selenium import webdriver<br/>from selenium.webdriver.common.keys import Keys</span><span id="8300" class="mx ls jg mt b gy nc mz l na nb"># define context manager class<br/>class OpenBrowser():<br/>    <br/>    def __enter__(self):<br/>        self.driver = webdriver.Chrome(chrome_driver_path)<br/>        return self.driver<br/>    <br/>    def __exit__(self, exception_type, exception_value, <br/>                 exception_traceback):<br/>        self.driver.close()</span><span id="df2a" class="mx ls jg mt b gy nc mz l na nb"># use context manager<br/>with OpenBrowser() as driver:<br/>    driver.get("<a class="ae jd" href="http://www.python.org" rel="noopener ugc nofollow" target="_blank">http://www.python.org</a>")<br/>    elem = driver.find_element_by_name("q")<br/>    elem.clear()<br/>    elem.send_keys("pycon")<br/>    elem.send_keys(Keys.RETURN)<br/>    html = driver.page_source</span><span id="d3ff" class="mx ls jg mt b gy nc mz l na nb">print(html)</span></pre><p id="ffbc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这看起来很复杂，其实不然。你用<code class="fe nd ne nf mt b">__enter()__</code>和<code class="fe nd ne nf mt b">__exit()__</code>定义了一个类，它们分别定义了当你通过<code class="fe nd ne nf mt b">with</code>调用它时会发生什么，以及当你退出缩进时会发生什么。<code class="fe nd ne nf mt b">__exit__</code>的参数是固定的，而<code class="fe nd ne nf mt b">__enter__</code>的返回值是可选的。现在读者很清楚，这个驱动程序的存在只是为了在python.org搜索pycon并获取结果html。无论发生什么，浏览器都会关闭。</p><p id="d781" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个语法不算太差，但是有更简单的方法。上下文库提供了一个decorator来处理boiler板，并用函数替换类。让我们看看上面的例子是如何使用装饰器的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="621f" class="mx ls jg mt b gy my mz l na nb"># imports<br/>from selenium import webdriver<br/>from selenium.webdriver.common.keys import Keys<br/>import contextlib</span><span id="fcfd" class="mx ls jg mt b gy nc mz l na nb"><a class="ae jd" href="http://twitter.com/contextlib" rel="noopener ugc nofollow" target="_blank">@contextlib</a>.contextmanager<br/>def open_browser():<br/>    driver = webdriver.Chrome(chrome_driver_path)<br/>    yield driver<br/>    driver.close()</span><span id="1048" class="mx ls jg mt b gy nc mz l na nb">with open_browser() as driver:<br/>    driver.get("<a class="ae jd" href="http://www.python.org" rel="noopener ugc nofollow" target="_blank">http://www.python.org</a>")<br/>    elem = driver.find_element_by_name("q")<br/>    elem.clear()<br/>    elem.send_keys("pycon")<br/>    elem.send_keys(Keys.RETURN)<br/>    html = driver.page_source</span></pre><p id="b01b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，我们只是导入<code class="fe nd ne nf mt b">contextlib</code>并用contextlib.contextmanager修饰一个函数。该函数需要有一个yield语句，yield值是可选的，但它告诉上下文管理器<code class="fe nd ne nf mt b">__enter__</code>和<code class="fe nd ne nf mt b">__exit__</code>出现的位置，分别在yield之前和之后。</p><h1 id="1407" class="lr ls jg bd lt lu lv lw lx ly lz ma mb km mc kn md kp me kq mf ks mg kt mh mi bi translated">结论</h1><p id="440e" class="pw-post-body-paragraph kv kw jg kx b ky mj kh la lb mk kk ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我希望我不仅足够好地解释了上下文管理器，而且让你相信它们在你的工具箱中非常有价值。即使作为一名数据科学家，我也发现了许多这些派上用场的案例。欢迎留下任何问题或评论，编码愉快！</p></div></div>    
</body>
</html>