<html>
<head>
<title>Predict Any Cryptocurrency Applying NLP using Global News</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用全球新闻预测任何应用NLP的加密货币</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predict-any-cryptocurrency-applying-nlp-with-global-news-e938af6f7922?source=collection_archive---------6-----------------------#2020-09-30">https://towardsdatascience.com/predict-any-cryptocurrency-applying-nlp-with-global-news-e938af6f7922?source=collection_archive---------6-----------------------#2020-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aefe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python的分步教程。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/385e4644113a3a126a3b9a0ef63951b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tMIfJjBsJYQFJf4otPKwQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://www.shutterstock.com/" rel="noopener ugc nofollow" target="_blank">shutterstuck.com</a></p></figure><p id="62dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">来自《走向数据科学》编辑的提示:</em> </strong> <em class="ls">虽然我们允许独立作者根据我们的</em> <a class="ae kv" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="ls">规则和指导方针</em> </a> <em class="ls">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae kv" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="ls">读者术语</em> </a> <em class="ls">。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="b502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在当今严峻的全球经济条件下，传统的指标和技术可能表现不佳(至少可以这么说)。</p><p id="0266" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将搜索关于新闻的<strong class="ky ir">有用信息，并使用NLP </strong>将其转换为数字格式<strong class="ky ir">，以训练一个机器学习模型，该模型将预测任何给定加密货币的<strong class="ky ir">上涨</strong>或<strong class="ky ir">下跌</strong>(使用Python)。</strong></p><h1 id="e16c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">先决条件</h1><ul class=""><li id="095b" class="ms mt iq ky b kz mu lc mv lf mw lj mx ln my lr mz na nb nc bi translated">安装Python 3.1以上版本</li><li id="3b3f" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">安装熊猫、sklearn和openblender(带pip)</li></ul><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="dc1f" class="nn mb iq nj b gy no np l nq nr">$ pip install pandas OpenBlender scikit-learn</span></pre><h1 id="17d6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">第一步。获取数据</h1><p id="fb8d" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">我们可以使用任何加密货币。对于这个例子，让我们使用这个<a class="ae kv" href="https://www.openblender.io/#/dataset/explore/5d4c3af79516290b01c83f51/or/40" rel="noopener ugc nofollow" target="_blank">比特币数据集</a>。</p><p id="a39f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来拉一下2020年初的<strong class="ky ir">日价蜡烛</strong>。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="a6e0" class="nn mb iq nj b gy no np l nq nr">import pandas as pd<br/>import numpy as np<br/>import OpenBlender<br/>import json</span><span id="027d" class="nn mb iq nj b gy nv np l nq nr">token = '<strong class="nj ir">YOUR_TOKEN_HERE</strong>'</span><span id="02cd" class="nn mb iq nj b gy nv np l nq nr">action = 'API_getObservationsFromDataset'</span><span id="27cb" class="nn mb iq nj b gy nv np l nq nr"># ANCHOR: 'Bitcoin vs USD'<br/>  <br/>parameters = { <br/>    'token' : token,<br/>    'id_dataset' : '5d4c3af79516290b01c83f51',<br/>    'date_filter':{"start_date" : "2020-01-01",<br/>                   "end_date" : "2020-08-29"} <br/>}</span><span id="ae53" class="nn mb iq nj b gy nv np l nq nr">df = pd.read_json(json.dumps(OpenBlender.call(action, parameters)['sample']), convert_dates=False, convert_axes=False).sort_values('timestamp', ascending=False)</span><span id="4309" class="nn mb iq nj b gy nv np l nq nr">df.reset_index(drop=True, inplace=True)<br/>df['date'] = [OpenBlender.unixToDate(ts, timezone = 'GMT') for ts in df.timestamp]<br/>df = df.drop('timestamp', axis = 1)</span></pre><p id="d9b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>你<em class="ls">需要</em>在<a class="ae kv" href="https://www.openblender.io/#/welcome/or/40" rel="noopener ugc nofollow" target="_blank"> openblender.io </a>(免费)上创建一个帐户，然后<strong class="ky ir">添加你的令牌</strong>(你会在“帐户”部分找到它)。</p><p id="4b09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="06f3" class="nn mb iq nj b gy no np l nq nr">print(df.shape)<br/>df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/c66e6732dc11848b7e3cc1131d7550b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBpFuIHGPdYfwCXXza0icQ.png"/></div></div></figure><p id="efdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自年初以来，我们每天有254次对比特币价格的观察。</p><p id="4a43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">*注意:将应用于这些24小时蜡烛的同一管道可以应用于任何大小的蜡烛(甚至每秒)。</p><h1 id="b48c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">第二步。定义并理解我们的目标</h1><p id="bace" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">在我们的比特币数据中，我们有一列“<strong class="ky ir">价格</strong>和当天的收盘价，以及“<strong class="ky ir">开盘</strong>”和当天的开盘价。</p><p id="fafb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望得到收盘价相对于开盘价的百分比差<strong class="ky ir">，这样我们就有了当天表现的变量。</strong></p><p id="62b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了得到这个变量，我们将计算收盘价和开盘价之间的<strong class="ky ir"/><a class="ae kv" href="https://faculty.fuqua.duke.edu/~rnau/Decision411_2007/411log.htm#:~:text=First%20difference%20of%20LOG%20%3D%20percentage%20change%3A%20When%20used%20in%20conjunction,Y%20from%20period%20to%20period." rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a><strong class="ky ir"/>对数差。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="6230" class="nn mb iq nj b gy no np l nq nr">df['log_diff'] = np.log(df['price']) - np.log(df['open'])<br/>df</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/fdfe761871d77f7f47557c11d6bab962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--2OtbZXJiyBCRKZ1_rTlA.png"/></div></div></figure><p id="241f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">'<strong class="ky ir"> log_diff </strong>'可以被认为是近似的<strong class="ky ir">百分比变化</strong>，对于本教程来说，它们实际上是等价的。</p><p id="e8e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(我们可以看到与'<em class="ls">变化</em>'的相关性非常高)</p><p id="4ee7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/6d39bb4a409bf23f2e8c288c05733141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7-h-aKzzpExNgWDOQyf_Q.png"/></div></div></figure><p id="effe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到全年的看跌行为和-0.1到0.1之间的稳定变化(注意剧烈的异常值)。</p><p id="f366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们<strong class="ky ir">通过设置“<strong class="ky ir">1”</strong>来生成我们的</strong> <strong class="ky ir">目标</strong>变量，如果性能为正(log_diff &gt; 0)，否则设置“<strong class="ky ir"> 0 </strong>”。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="d494" class="nn mb iq nj b gy no np l nq nr">df['target'] = [1 if log_diff &gt; 0 else 0 for log_diff in df['log_diff']]</span><span id="a45e" class="nn mb iq nj b gy nv np l nq nr">df</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/5adb69bc468e4108ffd092ddc3bf09ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhbbRnEQOG2T_L0VuD58SQ.png"/></div></div></figure><p id="599d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，我们的目标是<strong class="ky ir">预测第二天的表现是</strong> <strong class="ky ir">正还是</strong>(这样我们就可以做出潜在的交易决定)。</p><h1 id="bb91" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">第三步。用我们自己的数据获取新闻</h1><p id="9bb9" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">现在，我们想将外部数据与我们的比特币数据进行时间混合。简单地说，这意味着使用<em class="ls">时间戳作为键来外连接另一个数据集。</em></p><p id="c62f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用OpenBlender API很容易地做到这一点，但是首先我们需要创建一个<strong class="ky ir"> Unix时间戳</strong>变量。</p><p id="c889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.unixtimestamp.com/" rel="noopener ugc nofollow" target="_blank"> Unix时间戳</a>是UTC上自1970年以来的秒数，这是一种非常方便的格式，因为它在世界上的每个时区都与<strong class="ky ir">和</strong>相同！</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="3da2" class="nn mb iq nj b gy no np l nq nr">format = '%d-%m-%Y %H:%M:%S'<br/>timezone = 'GMT'</span><span id="0531" class="nn mb iq nj b gy nv np l nq nr">df['u_timestamp'] = OpenBlender.dateToUnix(df['date'], <br/>                                           date_format = format, <br/>                                           timezone = timezone)</span><span id="c846" class="nn mb iq nj b gy nv np l nq nr">df = df[['date', 'timestamp', 'price', 'target']]<br/>df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/ccb170395e58944633c7bcd98ed5dff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BgIQrOGbcYF6Y3tAzYwaA.png"/></div></div></figure><p id="e17c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们搜索与我们的时间交叉的有用数据集。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="a435" class="nn mb iq nj b gy no np l nq nr">search_keyword = 'bitcoin'</span><span id="49ff" class="nn mb iq nj b gy nv np l nq nr">df = df.sort_values('timestamp').reset_index(drop = True)</span><span id="14d5" class="nn mb iq nj b gy nv np l nq nr">print('From : ' + OpenBlender.unixToDate(min(df.timestamp)))<br/>print('Until: ' + OpenBlender.unixToDate(max(df.timestamp)))</span><span id="b9f0" class="nn mb iq nj b gy nv np l nq nr">OpenBlender.searchTimeBlends(token,<br/>                             df.timestamp,<br/>                             search_keyword)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/e58979b30301179ac15aa6f79b245bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBNpwKSpFSuIkQXXg0yK1w.png"/></div></div></figure><p id="cc31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在一个列表中检索了几个数据集，包括它们的名称、描述、界面的url甚至是特征，但更重要的是，与我们的数据集重叠(相交)的<strong class="ky ir">时间百分比。</strong></p><p id="45a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览了一些后，<a class="ae kv" href="https://www.openblender.io/#/dataset/explore/5ea2039095162936337156c9/or/40" rel="noopener ugc nofollow" target="_blank">这一篇</a>关于比特币的新闻和最新的线程看起来很有趣。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/a393f77c5178644f8d98747405adead7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1lPvqUxqXHh8G_MitQ7Pg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/902a3a41e1edc507ecf0bca02ee1b64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3S0ExYGcAKAgpf3SwAsdeg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.openblender.io/#/dataset/explore/5ea2039095162936337156c9/or/40" rel="noopener ugc nofollow" target="_blank">比特币新闻数据集</a>截图</p></figure><p id="1e3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，从上面的数据集中，我们只对包含新闻的“文本”特征感兴趣。所以让我们<strong class="ky ir">混合过去24小时的新闻</strong>。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="e666" class="nn mb iq nj b gy no np l nq nr"># We need to add the '<strong class="nj ir">id_dataset</strong>' and the '<strong class="nj ir">feature</strong>' name we want.</span><span id="efe1" class="nn mb iq nj b gy nv np l nq nr">blend_source = {<br/>                'id_dataset':'<strong class="nj ir">5ea2039095162936337156c9</strong>',<br/>                'feature' : '<strong class="nj ir">text</strong>'<br/>            }</span><span id="749e" class="nn mb iq nj b gy nv np l nq nr"><br/># Now, let's 'timeBlend' it to our dataset</span><span id="b82a" class="nn mb iq nj b gy nv np l nq nr">df_blend = OpenBlender.timeBlend( token = token,<br/>                                  anchor_ts = <strong class="nj ir">df.timestamp</strong>,<br/>                                  blend_source = <strong class="nj ir">blend_source</strong>,<br/>                                  blend_type = 'agg_in_intervals',<br/>                                  interval_size = 60 * 60 * 24,<br/>                                  direction = 'time_prior',<br/>                                  interval_output = 'list',<br/>                                  missing_values = 'raw')</span><span id="09bd" class="nn mb iq nj b gy nv np l nq nr">df = pd.concat([df, df_blend.loc[:, df_blend.columns != 'timestamp']], axis = 1)</span><span id="8505" class="nn mb iq nj b gy nv np l nq nr">df.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/ff28b6144a216cc793272116c0b228cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bEDYV8MHpFabuG3brHiSg.png"/></div></div></figure><p id="e7be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间混合的参数:</p><ul class=""><li id="5f4e" class="ms mt iq ky b kz la lc ld lf of lj og ln oh lr mz na nb nc bi translated"><strong class="ky ir"> anchor_ts </strong>:我们只需要发送我们的时间戳列，这样它就可以作为一个锚来混合外部数据。</li><li id="86cc" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><strong class="ky ir"> blend_source </strong>:关于我们想要的特性的信息。</li><li id="7ace" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><strong class="ky ir">blend _ type</strong>:‘agg _ in _ intervals’因为我们想要对我们的每个观察值进行24小时间隔聚合。</li><li id="b91b" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><strong class="ky ir"> inverval_size </strong>:间隔的大小，以秒为单位(本例中为24小时)。</li><li id="6594" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><strong class="ky ir">方向</strong>:‘time _ prior’因为我们希望时间间隔收集之前24小时的观察结果，而不是向前。</li></ul><p id="93f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了相同的数据集<strong class="ky ir">，但是增加了2列</strong>。一个包含24小时间隔(“过去1天”)内收集的文本列表，另一个包含计数。</p><p id="250f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们更具体一点，让我们试着<strong class="ky ir">用一个添加了一些ngrams的过滤器来收集‘正面’和‘负面’消息</strong>(我马上想到的)。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="06eb" class="nn mb iq nj b gy no np l nq nr"># We add the ngrams to match on a 'positive' feature.<br/><strong class="nj ir">positive_filter</strong> = {'name' : '<strong class="nj ir">positive</strong>', <br/>                   'match_ngrams': [<strong class="nj ir">'positive', 'buy', <br/>                                    'bull', 'boost'</strong>]}</span><span id="a653" class="nn mb iq nj b gy nv np l nq nr">blend_source = {<br/>                'id_dataset':'5ea2039095162936337156c9',<br/>                'feature' : 'text',<br/>                'filter_text' : <strong class="nj ir">positive_filter</strong><br/>            }</span><span id="939c" class="nn mb iq nj b gy nv np l nq nr">df_blend = OpenBlender.timeBlend( token = token,<br/>                                  anchor_ts = df.timestamp,<br/>                                  blend_source = blend_source,<br/>                                  blend_type = 'agg_in_intervals',<br/>                                  interval_size = 60 * 60 * 24,<br/>                                  direction = 'time_prior',<br/>                                  interval_output = 'list',<br/>                                  missing_values = 'raw')</span><span id="c329" class="nn mb iq nj b gy nv np l nq nr">df = pd.concat([df, df_blend.loc[:, df_blend.columns != 'timestamp']], axis = 1)</span><span id="8756" class="nn mb iq nj b gy nv np l nq nr"><br/># And now the negatives<br/><strong class="nj ir">negative_filter</strong> = {'name' : '<strong class="nj ir">negative</strong>', <br/>                   'match_ngrams': [<strong class="nj ir">'negative', 'loss', 'drop', 'plummet', 'sell', 'fundraising'</strong>]}</span><span id="04ae" class="nn mb iq nj b gy nv np l nq nr">blend_source = {<br/>                'id_dataset':'5ea2039095162936337156c9',<br/>                'feature' : 'text',<br/>                'filter_text' : <strong class="nj ir">negative_filter</strong><br/>            }</span><span id="015b" class="nn mb iq nj b gy nv np l nq nr">df_blend = OpenBlender.timeBlend( token = token,<br/>                                  anchor_ts = df.timestamp,<br/>                                  blend_source = blend_source,<br/>                                  blend_type = 'agg_in_intervals', #closest_observation<br/>                                  interval_size = 60 * 60 * 24,<br/>                                  direction = 'time_prior',<br/>                                  interval_output = 'list',<br/>                                  missing_values = 'raw')</span><span id="4f02" class="nn mb iq nj b gy nv np l nq nr">df = pd.concat([df, df_blend.loc[:, df_blend.columns != 'timestamp']], axis = 1)</span></pre><p id="c8ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了4个新栏目，即“正面”和“负面”新闻的数量和列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/a857dedcc1d8759cbec86c4b34e5325b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMkEgc5ZME0ZkAW13XlnSg.png"/></div></div></figure><p id="7c0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看目标和其他数字特征之间的相关性。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="1f5e" class="nn mb iq nj b gy no np l nq nr">features = ['target', 'BITCOIN_NE.text_COUNT_last1days:positive', 'BITCOIN_NE.text_COUNT_last1days:negative']</span><span id="1de6" class="nn mb iq nj b gy nv np l nq nr">df_anchor[features].corr()['target']</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/1b9c0c6d77f42fb4d18f224f67bd563d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_kM8XwwKiylBIxGrz4aYg.png"/></div></div></figure><p id="7320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以注意到与新生成的特征分别存在轻微的负相关和正相关。</p><p id="b20e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使用TextVectorizer来获得大量自动生成的令牌特征。</p><p id="d686" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在OpenBlender上创建了<a class="ae kv" href="https://www.openblender.io/#/text_vectorizer/explorer/5f739fe7951629649472e167" rel="noopener ugc nofollow" target="_blank">这个</a> TextVectorizer，用于BTC新闻数据集的“文本”功能，该数据集有超过1200个ngrams。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/6d9419f084adbbe04851d959c8b8bff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NcgxQlFvrOWTHSoKp-WuA.png"/></div></div></figure><p id="9b1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把这些特点与我们的结合起来。我们可以使用完全相同的代码，我们只需要在blend_source上传递“id_textVectorizer”。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="97ce" class="nn mb iq nj b gy no np l nq nr"># BTC Text Vectorizer<br/>blend_source = { <br/>                '<strong class="nj ir">id_textVectorizer</strong>':'<strong class="nj ir">5f739fe7951629649472e167</strong>'<br/>               }</span><span id="e023" class="nn mb iq nj b gy nv np l nq nr">df_blend = OpenBlender.timeBlend( token = token,<br/>                                  anchor_ts = df_anchor.timestamp,<br/>                                  blend_source = blend_source,<br/>                                  blend_type = 'agg_in_intervals',<br/>                                  interval_size = 60 * 60 * 24,<br/>                                  direction = 'time_prior',<br/>                                  interval_output = 'list',<br/>                                  missing_values = 'raw') .add_prefix('VEC.')</span><span id="217c" class="nn mb iq nj b gy nv np l nq nr">df_anchor = pd.concat([df_anchor, df_blend.loc[:, df_blend.columns != 'timestamp']], axis = 1)<br/>df_anchor.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/40b2de4b7f506f0632f2f2f70f11faff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9m3r4ORPhVReiYN1YhWp7g.png"/></div></div></figure><p id="1234" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个1229列的数据集，在每个时间间隔的聚合新闻上有ngram出现的二进制特征，与我们的目标一致。</p><h1 id="2d27" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">第四步。应用ML并查看结果</h1><p id="a6d5" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">现在，让我们应用一些简单的ML来查看一些结果。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="c4e9" class="nn mb iq nj b gy no np l nq nr">from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import accuracy_score<br/>from sklearn.metrics import precision_score</span><span id="8789" class="nn mb iq nj b gy nv np l nq nr"># We drop correlated features because with so many binary <br/># ngram variables there's a lot of noise</span><span id="612d" class="nn mb iq nj b gy nv np l nq nr">corr_matrix = df_anchor.corr().abs()<br/>upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))<br/>df_anchor.drop([column for column in upper.columns if any(upper[column] &gt; 0.5)], axis=1, inplace=True)</span><span id="ec1c" class="nn mb iq nj b gy nv np l nq nr"><br/># Now we separate in train/test sets</span><span id="2569" class="nn mb iq nj b gy nv np l nq nr">X = df_.loc[:, df_.columns != 'target'].select_dtypes(include=[np.number]).drop(drop_cols, axis = 1).values<br/>y = df_.loc[:,['target']].values<br/>div = int(round(len(X) * 0.2))<br/>X_train = X[:div]<br/>y_train = y[:div]<br/>X_test = X[div:]<br/>y_test = y[div:]</span><span id="0e8d" class="nn mb iq nj b gy nv np l nq nr"># Finally, we perform ML and see results</span><span id="90a2" class="nn mb iq nj b gy nv np l nq nr">rf = RandomForestRegressor(n_estimators = 1000, random_state=0)<br/>rf.fit(X_train, y_train)<br/>y_pred = rf.predict(X_test)<br/>df_res = pd.DataFrame({'y_test':y_test[:, 0], 'y_pred':y_pred})</span><span id="922b" class="nn mb iq nj b gy nv np l nq nr">threshold = 0.5<br/>preds = [1 if val &gt; threshold else 0 for val in df_res['y_pred']]<br/>print(metrics.confusion_matrix(preds, df_res['y_test']))<br/>print('Accuracy Score:')<br/>print(accuracy_score(preds, df_res['y_test']))<br/>print('Precision Score:')<br/>print(precision_score(preds, df_res['y_test']))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/477acca5803e4980d49d902926644416.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*zTu5G55zvL-JjTsL2106ZA.png"/></div></div></figure><p id="cf77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然整体准确性并不令人印象深刻，但我们对“精确得分”特别感兴趣，因为我们的目标是检测未来几天最有可能上涨(并避免下跌)。</p><p id="83c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何解读上述混淆矩阵:</p><ul class=""><li id="42b4" class="ms mt iq ky b kz la lc ld lf of lj og ln oh lr mz na nb nc bi translated">我们的模型预测“起义”102次，其中84次是实际的起义，17次不是(0.83精度分数)。</li><li id="275d" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">总共有157次起义。我们的模型检测到了其中的84个，漏掉了73个。</li><li id="ea5d" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">总共有32个“垮台”(或者仅仅不是“起义”)案例，我们的模型检测到了其中的15个，漏掉了17个。</li></ul><p id="34df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，如果当务之急是<strong class="ky ir">避免</strong>垮台——即使这意味着牺牲大量‘起义’案例——<strong class="ky ir">这种模式在这段时间内</strong>运行良好。</p><p id="c8d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以说，如果优先考虑的是避免错过起义(即使有一些落马渗透)，这个有这个阈值的模型根本不是一个好的选择。</p></div></div>    
</body>
</html>