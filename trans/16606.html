<html>
<head>
<title>Writing a multi-file-upload Python-web app with user authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写带有用户认证的多文件上传Python-web应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-a-multi-file-upload-python-web-app-with-user-authentication-8f75064b819a?source=collection_archive---------7-----------------------#2020-11-16">https://towardsdatascience.com/writing-a-multi-file-upload-python-web-app-with-user-authentication-8f75064b819a?source=collection_archive---------7-----------------------#2020-11-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e32" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为合作者提供了一种简单的方法来上传文件到文件存储，而不需要他们理解任何代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/762bf24b85588b510b8c39164dfb4d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jzbXzGCB3j5qqxwv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你好，我是尼克🎞 on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="4827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当构建一个web服务器时，我们经常希望提出一个想法或主题。在静态网站的情况下，这可以通过在源文件中包含相关信息来实现。在更动态的例子中，在将信息返回给用户之前，可以使用API(应用编程接口)来预处理信息。</p><p id="c7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们设计了一个简单的flask应用程序，它只需要一个用户密钥和一个web浏览器就可以工作。这背后的想法是，任何人都可以使用它，它是一个设备(和操作系统)，独立的。</p><h1 id="4cae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建烧瓶应用程序</h1><p id="188e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">像往常一样，我们首先为服务器安装相关的库。最简单的方法是使用pip(python包管理器)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0846" class="mx lw it mt b gy my mz l na nb">pip install flask, werkzeug</span></pre><h2 id="9c07" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">上传页面模板</h2><p id="1587" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，为登录页面创建HTML模板。为此，我们从应用程序目录开始，创建一个名为<code class="fe nn no np mt b">templates</code>的新文件。在这里，我们创建一个名为<code class="fe nn no np mt b">upload.html</code>的文件，并将下面的代码粘贴到其中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1c2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，我们有一个<code class="fe nn no np mt b">form</code>，其中包含我们的密码<code class="fe nn no np mt b">input</code>，一个文件上传<code class="fe nn no np mt b">input</code>和一个提交按钮。工作时，这将看起来如下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/646e03bd46f4aa4e2761f15a0fc0589e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*prxbT4xx3i7x9p5wblw59w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">upload_simple.html的输出</p></figure><h2 id="e6f3" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">设置上传选项</h2><p id="804f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们为上传选项定义一个配置文件。为此，在主应用程序文件夹中创建一个名为<code class="fe nn no np mt b">config.py</code>的文件。在此范围内，我们可以指定可接受的最大文件大小、上传目的地以及我们可以选择接受的文件扩展名。将下面的代码复制到<code class="fe nn no np mt b">config.py</code>中，并进行相应的调整。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">关于文件类型的注意事项:文件扩展名不保证文件类型，我们应该避免执行任何上传的文件。这就是我们后来引入密码的原因——只有经过批准的用户才能上传。</em></p><h2 id="06e3" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">烧瓶模板</h2><p id="efb4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们从一个基本的flask模板开始，它导入我们的信息，并在导航到<code class="fe nn no np mt b"><a class="ae ky" href="http://127.0.0.1:4000/upload" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:4000/upload</a></code>时服务于<code class="fe nn no np mt b">upload.html</code>页面</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="3290" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">上传文件检查</h2><p id="4cd2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们有了我们的应用程序，我们可以添加一些功能来确保我们有正确的目录，如果没有创建它。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="059e" class="mx lw it mt b gy my mz l na nb">if not os.path.isdir(upload_dest):<br/>    os.mkdir(upload_dest)</span></pre><p id="d3b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以设置最大文件上传大小(使用来自<code class="fe nn no np mt b">config.py</code>的值)</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="48a5" class="mx lw it mt b gy my mz l na nb">app.config['MAX_CONTENT_LENGTH'] = file_mb_max * 1024 * 1024</span></pre><p id="0d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并检查文件扩展名(再次在<code class="fe nn no np mt b">config.py</code>中定义)</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d310" class="mx lw it mt b gy my mz l na nb">def allowed_file(filename):<br/>    return '.' in filename and filename.rsplit('.', 1)[1].lower() in                 extensions</span></pre><p id="274f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就我个人而言，我在代码中的<code class="fe nn no np mt b">app.secret</code>和<code class="fe nn no np mt b">@app.route</code>部分之间添加了这些。</p><h2 id="7bf7" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">上传时要做什么</h2><p id="7426" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，我们还没有告诉程序在上传时做什么。我们通过解析来自上传页面的post请求来做到这一点。有关这意味着什么的信息，请阅读:</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/talking-to-python-from-javascript-flask-and-the-fetch-api-e0ef3573c451"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">从Javascript: Flask和fetch API与Python对话</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用Python处理动态web界面或可视化所需的数据。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><p id="5b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们检查<code class="fe nn no np mt b">request.method</code>是否是一个帖子，如果是，处理任何附加的文件。第一部分处理一个空请求，而第二部分遍历每个文件，检查它们是否有正确的文件扩展名，如果有，将它们保存到我们想要的位置(<code class="fe nn no np mt b">upload_dest</code>)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e0e8" class="mx lw it mt b gy my mz l na nb"><a class="ae ky" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/upload', methods=['POST'])<br/>def upload_file():<br/>    if request.method == 'POST':</span><span id="4f29" class="mx lw it mt b gy om mz l na nb">    if 'files[]' not in request.files:<br/>            flash('No files found, try again.')<br/>            return redirect(request.url)</span><span id="1d58" class="mx lw it mt b gy om mz l na nb">    files = request.files.getlist('files[]')</span><span id="e6af" class="mx lw it mt b gy om mz l na nb">    for file in files:<br/>            if file and allowed_file(file.filename):<br/>                filename = secure_filename(file.filename)<br/>                file.save(os.path.join( upload_dest, filename))</span><span id="2479" class="mx lw it mt b gy om mz l na nb">    flash('File(s) uploaded')<br/>    return redirect('/upload')</span></pre><h2 id="cbb0" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">测试用例</h2><p id="f2fc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，在继续添加密码之前，我们要确保上传功能正常。为此，我们运行python脚本，导航到<a class="ae ky" href="http://127.0.0.1:4000/upload" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:4000/upload</a>，选择几个文件，然后单击upload。如果这已经成功，并且您正在使用上面的配置，那么您的文件现在应该位于与您的应用程序嵌套在同一文件夹中的<code class="fe nn no np mt b">uploads_folder</code>目录中。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="1c36" class="lv lw it bd lx ly ou ma mb mc ov me mf jz ow ka mh kc ox kd mj kf oy kg ml mm bi translated">添加用于用户身份验证的加密数据库</h1><p id="297a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，我们已经创建了一个Flask应用程序，可以用来上传文件。接下来，我们想添加一个基本的安全层，这样我们就可以跟踪哪些文件被上传了，是谁上传的。此外，这允许我们拒绝任何未经授权向目录提交数据的人。</p><h2 id="e27b" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">安装<strong class="ak"> pysqlcipher3 </strong></h2><p id="c4de" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们从安装数据库工具开始。这有时会给人们带来问题，所以下面包含了Mac和Linux的安装说明。</p><p id="5f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> MAC </strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0d41" class="mx lw it mt b gy my mz l na nb">brew install SQLCipher<br/>pip install pysqlcipher3</span></pre><p id="f67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> LINUX </strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3bc0" class="mx lw it mt b gy my mz l na nb">sudo apt install sqlcipher libsqlcipher0 libsqlcipher-dev<br/>sudo -H pip3 install pysqlcipher3</span><span id="54d9" class="mx lw it mt b gy om mz l na nb">python3 -c 'import pysqlcipher3; print(pysqlcipher3.__path__)'</span></pre></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h2 id="18c2" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">连接到数据库</h2><p id="9d88" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们从连接数据库开始。如果您以前使用过数据库，pysqlcipher语法与sqlite或任何postgresql库非常相似。我们从导入库开始</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="af70" class="mx lw it mt b gy my mz l na nb">from pysqlcipher3 import dbapi2 as sqlite3<br/>from config import app_key, db_loc</span></pre><p id="a661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后连接到数据库:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="39d1" class="mx lw it mt b gy my mz l na nb">conn = sqlite3.connect(db_loc)# where this is /path/test.db<br/>cursor = conn.cursor()</span></pre><p id="6146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要为数据库指定一个加密密钥，以便能够访问数据。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="02a1" class="mx lw it mt b gy my mz l na nb">cursor.execute("PRAGMA key='%s'"%app_key)</span></pre><p id="89e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不这样做，或者使用不同的键，您将收到以下错误:<code class="fe nn no np mt b">DatabaseError: file is not a database</code>当试图从数据库模式中读取信息时。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h2 id="73e9" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">创建数据库</h2><p id="e63d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">打开我们的数据库，输入我们的密钥，我们现在可以创建一个表来存储我们的值。我们通过使用<code class="fe nn no np mt b">cursor execute</code>函数执行一个<code class="fe nn no np mt b">create table</code> SQL命令来实现这一点。最简单的用例需要一个<strong class="lb iu">名称</strong>和一个<strong class="lb iu">上传密钥。</strong></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2390" class="mx lw it mt b gy my mz l na nb">cursor.execute(<br/>            '''<br/>            <strong class="mt iu">CREATE</strong> TABLE IF NOT EXISTS <strong class="mt iu">upload</strong> (<br/>            id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,<br/>            <strong class="mt iu">name</strong> TEXT NOT NULL,<br/>            <strong class="mt iu">upload_key</strong> TEXT UNIQUE<br/>            );<br/>            '''<br/>    )</span></pre><p id="ab6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">此外，我设置了一个条件，即每个密钥必须是唯一的，因为我们不使用用户名登录。</em></p><p id="6082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们必须将新表提交给数据库并关闭它。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b670" class="mx lw it mt b gy my mz l na nb">conn.commit()<br/>## conn.close() <br/>## close only when we have finished everything, otherwise we have to reopen the database each time</span></pre></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h2 id="ad24" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">添加用户</h2><p id="3326" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们需要用户能够使用上传工具，所以我们可以使用<code class="fe nn no np mt b">insert</code>命令添加一些。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="50cc" class="mx lw it mt b gy my mz l na nb">cursor.execute(<br/>            '''<br/>            <strong class="mt iu">INSERT</strong> INTO <strong class="mt iu">upload</strong> (name, dir, uploadcode)<br/>            VALUES ("bob", "bobs top secret upload key")<br/>            '''<br/>conn.commit()</span></pre></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h2 id="3109" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">读取数据库</h2><p id="995a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为检查，我们想看看是否有一个名字与upload_key相关联。这可以通过<code class="fe nn no np mt b">select</code>函数和<code class="fe nn no np mt b">where</code>条件来实现。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d5bb" class="mx lw it mt b gy my mz l na nb">user_code = 'bobs top secret upload key'</span><span id="07d1" class="mx lw it mt b gy om mz l na nb">cursor.execute('<strong class="mt iu">select</strong> * from upload <strong class="mt iu">where</strong> uploadcode="%s"'%user_code)</span><span id="7c7d" class="mx lw it mt b gy om mz l na nb">result = cursor.fetchall() # get all the results e.g. [("bob",)]</span></pre></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="a076" class="lv lw it bd lx ly ou ma mb mc ov me mf jz ow ka mh kc ox kd mj kf oy kg ml mm bi translated">把它们串在一起</h1><p id="5b3e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们有了一个数据库和一个上传脚本，我们可以将两者结合起来。</p><h2 id="05ed" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">打开数据库</h2><p id="efa3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们添加所需的库</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="687d" class="mx lw it mt b gy my mz l na nb">from pysqlcipher3 import dbapi2 as sqlite3<br/># from config import app_key, db_loc # already imported</span></pre><p id="24be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nn no np mt b">from config_simple import *</code>线下。</p><h2 id="7eb8" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">读取密码</h2><p id="8fd2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您使用的是之前的HTML代码，我们已经有了一个密码输入字段:<code class="fe nn no np mt b">&lt;p&gt; upload_key: &lt;input name=”psw” type=”password” /&gt;&lt;/p&gt;</code></p><p id="e1a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这在提交表单中，所以我们可以在<code class="fe nn no np mt b">@app.route</code>包装器中将它作为POST请求的一部分来阅读。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cf81" class="mx lw it mt b gy my mz l na nb">user_code = str(request.form.get('psw'))</span></pre><p id="28e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将此与我们数据库阅读器结合起来，形成一个条件检查，看看是否有人拥有访问密钥/密码。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b2f5" class="mx lw it mt b gy my mz l na nb">cursor.execute('select * from upload where uploadcode="%s"'%user_code)<br/>        result = cursor.fetchall()</span><span id="dbe7" class="mx lw it mt b gy om mz l na nb">if len(result)==0: <br/>            flash('Not a valid Code')<br/>            return redirect(request.url)</span></pre><p id="49ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，由于数据库只能从与我们需要放置的网站相同的计算线程中打开和读取</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="08e7" class="mx lw it mt b gy my mz l na nb">conn = sqlite3.connect(db_loc)<br/>cursor = conn.cursor()<br/>cursor.execute("PRAGMA key='%s'"%app_key)</span></pre><p id="951e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nn no np mt b">cursor.execute</code>块之前，以及在<code class="fe nn no np mt b">result =</code>线之后的<code class="fe nn no np mt b">conn.close()</code>。(见最后GitHub repo中的app.py)</p><h1 id="c788" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="f374" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这就是我们要做的——最基本的提交框，允许预先批准的用户上传文件。但是，您可能希望进行一些改进(这些都在下面GitHub资源库中显示的附加文件中)。</p><ul class=""><li id="e7b7" class="oz pa it lb b lc ld lf lg li pb lm pc lq pd lu pe pf pg ph bi translated">检查扩展名的文件名字符串可能会导致问题。文件可能命名不正确，甚至没有扩展名(我的许多文件就是这种情况)。相反，我们可以过滤<code class="fe nn no np mt b">file.mimetype</code>值。这些是格式<code class="fe nn no np mt b">image/png</code>等。</li><li id="69f2" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated">拖放上传。手动选择文件通常很麻烦，尤其是当它们位于不同的位置时。从文件浏览器中拖动它们让用户的生活变得简单多了。</li><li id="a54c" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated">自动上传。另一个常见的错误是选择一个文件，但忘记点击提交。在你放入一个文件后，拥有一个可以立即工作的窗口有助于提高工作效率和用户满意度</li><li id="796a" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated">文件预览。如果用户正在上传图像，提供微缩预览总是很有帮助的。这样可以进行最后一分钟的检查，这样就不会重复提交相同的文件。</li><li id="62a3" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated">文件失败指示器。虽然有一条消息通知我们上传状态，但一个视觉提示(即一个更亮的预览图像)让我们更容易看到是否有什么东西没有工作。</li><li id="aedb" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated">独特的下载空间——如果你有很多用户，你可能会弄不清哪个文件属于谁(更不用说覆盖问题了)。相反，我们可以为每个用户添加一个指定的空间，并将路径保存在数据库中。</li></ul><p id="ac5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加以上所有附加建议，我们得到以下输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/7046836748f9937fe22a220ec0dcf5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KoC8buA0t43KVOb-imIOA.png"/></div></div></figure><p id="daee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到，两个文件都失败了，中间有一个成功了。在这种情况下，这是由于无效的用户凭据和故意无效的文件类型。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="ad2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">免责声明:这不是最安全的凭证检查方法，但是对于许多任务来说，这是一个非常合适的解决方案。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="6bf3" class="lv lw it bd lx ly ou ma mb mc ov me mf jz ow ka mh kc ox kd mj kf oy kg ml mm bi translated">代码库</h1><p id="3550" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">本教程的所有示例代码都被转储到了Github存储库中。</p><div class="nu nv gp gr nw nx"><a href="https://github.com/wolfiex/FlaskPython_FileUpload" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">wolfiex/FlaskPython_FileUpload</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">一个简单的烧瓶上传程序，用于需要凭据的多个文件</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="po l oi oj ok og ol ks nx"/></div></div></a></div><p id="3b25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何改进，请随时提交拉取请求。</p></div></div>    
</body>
</html>