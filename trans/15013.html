<html>
<head>
<title>4 Things You Might Not Know About Python Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python函数你可能不知道的4件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-things-you-might-not-know-about-python-functions-1ff988accd67?source=collection_archive---------41-----------------------#2020-10-15">https://towardsdatascience.com/4-things-you-might-not-know-about-python-functions-1ff988accd67?source=collection_archive---------41-----------------------#2020-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e80b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python函数远比你想象的有趣</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fcba8c3934093d22d8b5d3f4093e14f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Utn4e5P4YryUcaCwltYxzg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:https://unsplash.com/photos/feXpdV001o4</p></figure><p id="a00a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python作为一种多范式编程语言，因其符合任何程序员风格的能力而备受喜爱，这无疑使它成为世界上最流行的编程语言之一。尽管函数的性质千变万化，但它仍然是语言必不可少的一部分，真正理解语言的这一部分对掌握语言本身大有帮助。这就是为什么在本文中，我将讨论Python函数的四个鲜为人知的方面，这将有望让您对Python的威力有新的认识，无论您是Python老手还是完全的新手。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="ec6e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">1.反思你的功能</h2><p id="0f1c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在编程上下文中，自省是检查您用更多代码编写的代码。这里要记住的关键是Python函数本质上是对象，这意味着它们有相关联的属性和方法，这些属性和方法可以给你关于函数本身的信息。这些属性中的大多数是在声明函数时创建的，但是您也可以在事后添加新的属性，就像您对任何其他对象所做的那样。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7b47" class="mc md it nb b gy nf ng l nh ni">def example():<br/>   """ This is an example docstring<br/>   through which I can provide more information<br/>   about the function<br/>   """ </span><span id="f77f" class="mc md it nb b gy nj ng l nh ni">   print("Hello World")</span><span id="2dca" class="mc md it nb b gy nj ng l nh ni">example.__doc__       #Returns the docstring attribute <br/>example.__annotation__</span><span id="76de" class="mc md it nb b gy nj ng l nh ni">dir(example)</span><span id="756b" class="mc md it nb b gy nj ng l nh ni">#['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']</span><span id="6e3e" class="mc md it nb b gy nj ng l nh ni"># These are all the built-in function attributes </span></pre><p id="5185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们定义的任何函数都包含了大量的属性。要查看所有这些函数，只需将您的函数传递给dir()函数(如上所示)，就会返回所有可用方法和属性的数组。</p><p id="c48f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些有趣的属性如下:</p><ul class=""><li id="70e4" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">功能。__defaults__:返回所有默认参数值的元组</li><li id="5730" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">功能。__doc__:返回文档字符串</li><li id="0947" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">功能。__name__:以字符串形式返回函数的名称</li><li id="4aae" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">功能。__globals__:返回一个字典，其中包含函数可以访问的所有全局变量</li><li id="46f4" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">功能。__code__:返回__code__对象，该对象本身具有各种参数，与函数中的实际代码相关(使用dir()函数来检查该对象的所有相关方法和属性)。</li></ul><p id="b860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用函数自省可以做的事情还有很多，我无法用一篇文章的篇幅来介绍，所以一定要打开你的IDE，开始深入研究你自己的函数！</p><h2 id="6ada" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">2.函数类型注释</h2><p id="38d3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Python的灵活性部分来自于它作为动态类型编程语言的本质，在函数的上下文中，这意味着您可以传入任何类型的参数(字符串、整数、数组、布尔值)，并且错误只会在运行时出现(例如，如果您试图将字符串添加到函数中的数组，此时您的程序将会抛出一个TypeErrror)。</p><p id="6f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种更灵活的编程方法，因为在静态类型的语言中，如Java和C++，函数参数的类型必须预先确定，并且事后不能更改。这使得编程更加严格，需要更多的远见，但它有利于在运行时消除错误，并节省运行时错误检查的性能成本。</p><p id="24e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一些Python程序员选择使用函数注释，通过为所有函数输入和输出提供建议的类型，来帮助Python表现得更像静态类型语言(尽管代码仍然是动态类型的)。例如:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1c3a" class="mc md it nb b gy nf ng l nh ni">def a_function(a: 'Int', b: 'String') -&gt; "Repeats a String":<br/>   return a * b</span><span id="27bc" class="mc md it nb b gy nj ng l nh ni"># The annotations inside the brackets indicate what type each argument should be. (Notice the use of colons, as opposed to the equals signs, as in the case of argument defaults)</span><span id="97d2" class="mc md it nb b gy nj ng l nh ni"># The annotation after the function indicates the type of the return value</span><span id="bfd4" class="mc md it nb b gy nj ng l nh ni">a_function.__annotations__</span><span id="bec9" class="mc md it nb b gy nj ng l nh ni">#{'a': 'Int', 'b': 'String', 'return': 'Repeats a String'}<br/># Returns a dictionary of all the associated annotations </span></pre><p id="5f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用注释，您仍然可以将不正确的数据类型传递给函数，但是您至少可以得到正确类型的指示，从而减少用户出错的机会。您还可以通过在函数上运行help()函数来访问这些注释，或者等效地，使用Jupyter笔记本中的Shift + Tab快捷键，它会返回文档字符串、注释和其他函数信息。</p><h2 id="1a12" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">3.Args，Kwargs，参数排序和可迭代解包</h2><p id="efad" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在解释*args和**kwargs的值和用法之前，我需要先解释一下Python中打包和解包的概念。</p><p id="000c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个值数组，我们希望将每个值存储到单独的变量中。我们可以这样写:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0683" class="mc md it nb b gy nf ng l nh ni">a, b, c = [1,2,3]</span><span id="78ef" class="mc md it nb b gy nj ng l nh ni">#a = 1<br/>#b = 2<br/>#c = 3</span></pre><p id="bfc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当数组的长度未知时，这个操作变得更加棘手，因为我们不知道需要多少个独立的变量。此外，我们可能希望将第一个值存储为单个变量，但将其余的值保存在一个新数组中。这就是Python中解包功能的来源。使用' * '符号，我们可以将剩余的值存储在一个数组中，如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9dd4" class="mc md it nb b gy nf ng l nh ni">a, *b = [1,2,3,4,5,6]</span><span id="7875" class="mc md it nb b gy nj ng l nh ni"># a = 1<br/># b = [2,3,4,5,6]</span></pre><p id="ecff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">星号基本上是说:“取任何尚未赋值的值，并将其存储到一个变量中”。这种技术适用于任何可迭代对象，但在函数中打包参数的情况下尤其有用。它允许我们拥有不确定数量的位置和关键字参数，然后我们可以在函数表达式中索引/迭代这些参数。例如:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cf17" class="mc md it nb b gy nf ng l nh ni">def my_func(*args, **kwargs):<br/>   sum(args)</span><span id="dd00" class="mc md it nb b gy nj ng l nh ni"><br/># Note that although it is convention to use the variable names args and kwargs, you can name the variables whatever you'd like</span></pre><p id="c80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，当谈到函数参数时，我们必须按照特定的顺序放置参数:</p><ol class=""><li id="c4c9" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu ny nq nr ns bi translated">位置参数</li><li id="7da8" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu ny nq nr ns bi translated">*参数</li><li id="f96a" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu ny nq nr ns bi translated">关键字参数</li><li id="71a5" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu ny nq nr ns bi translated">* *克瓦查</li></ol><p id="f113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，在我们将a *args放入函数参数之后，后面的参数将被自动视为关键字参数。另一个例子很好地说明了这一点:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4d15" class="mc md it nb b gy nf ng l nh ni">def myfunc(a, b, *args, kw, **kwargs):<br/>    print(args)<br/>    print(kwargs)</span><span id="0854" class="mc md it nb b gy nj ng l nh ni">myfunc(1, 2, 3, 4, 5, kw = 6, kw2 = 7, kw3 = 8)</span><span id="5f45" class="mc md it nb b gy nj ng l nh ni"># (3, 4, 5)<br/># {'kw2': 7, 'kw3': 8}</span></pre><p id="4d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，所有在前两个位置参数(a和b)之后但在第一个关键字参数(kw)之前的位置参数将存储在一个元组中，该元组可以作为变量“args”引用。*args参数实际上用尽了所有剩余的位置参数。同样，kw之后的所有关键字参数都将存储在一个字典中，可以用变量“kwargs”引用该字典。</p><p id="2096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">*Args和**Kwargs在您不确定一个函数将接受多少个参数作为输入的情况下非常有用，并且允许您在用Python编写函数时更加灵活。</p><h2 id="88b4" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">4.利用Lambda表达式</h2><p id="ffea" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Lambda函数是Python对匿名函数的实现。如果您不熟悉这个概念，匿名函数本质上是普通函数的单一使用版本，没有名称，通常用于传递给更高阶的函数。</p><p id="8cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建lambda函数的语法如下:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4bd5" class="mc md it nb b gy nf ng l nh ni">lambda [parameters]: expression</span><span id="20f0" class="mc md it nb b gy nj ng l nh ni">#for example:</span><span id="8205" class="mc md it nb b gy nj ng l nh ni">lambda x: x + 3</span><span id="c215" class="mc md it nb b gy nj ng l nh ni"># Takes a value x, and returns x + 3</span></pre><p id="b501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lambda关键字表示您正在创建一个内联函数。然后，向lambda函数提供参数，类似于在函数定义的括号中提供的内容。最后，在冒号之后，编写表达式本身，在调用lambda函数时对其求值。</p><p id="d0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lambda函数的一个很好的用例是在map或filter中，因为它有助于编写高度Pythonic化和紧凑的代码。例如，如果我们要过滤数组中大于10的值:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9971" class="mc md it nb b gy nf ng l nh ni">arr = [1,3,6,2,13,15,17]</span><span id="8152" class="mc md it nb b gy nj ng l nh ni">list(filter(arr, lambda x: x &gt; 10))</span><span id="b610" class="mc md it nb b gy nj ng l nh ni"># the above function will return a new list where the array values are greater than 10 </span></pre><p id="26b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我所说的将函数传递给高阶函数的意思，因为这里我们将lambda函数传递给filter()函数，后者将iterable和函数作为位置参数。</p><p id="0678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，您也可以使用lambda函数创建一个常规函数，只需将它赋给一个变量名。该函数现在可以像任何其他函数一样被重用和调用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="610d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你能从这篇文章中学到一些新的东西，如果你对我写的东西有任何问题，欢迎在下面发表评论！</p></div></div>    
</body>
</html>