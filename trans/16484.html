<html>
<head>
<title>Testing Streamlit Apps Using SeleniumBase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SeleniumBase测试简化应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/testing-streamlit-apps-using-seleniumbase-f5b34c0d1423?source=collection_archive---------46-----------------------#2020-11-13">https://towardsdatascience.com/testing-streamlit-apps-using-seleniumbase-f5b34c0d1423?source=collection_archive---------46-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我为Streamlit工作的这段时间里，我见过数百款令人印象深刻的数据应用，从计算机视觉应用到公共卫生<a class="ae kl" href="https://discuss.streamlit.io/t/data-apps-regarding-covid-19/2203" rel="noopener ugc nofollow" target="_blank">新冠肺炎</a>的追踪，甚至是简单的<a class="ae kl" href="https://joelgrus.com/2020/10/02/creating-games-in-streamlit/" rel="noopener ugc nofollow" target="_blank">儿童游戏</a>。我相信Streamlit越来越受欢迎的原因是通过<a class="ae kl" href="https://docs.streamlit.io/en/stable/api.html?highlight=magic#magic-commands" rel="noopener ugc nofollow" target="_blank"> Streamlit“魔法”</a>功能和保存Python脚本时自动重新加载前端的快速迭代工作流。编写一些代码，在编辑器中点击“保存”，然后直观地检查每个代码更改的正确性。随着用于简化部署Streamlit应用程序的<a class="ae kl" href="https://www.streamlit.io/sharing" rel="noopener ugc nofollow" target="_blank"> Streamlit sharing </a>的推出，您可以在几分钟内从构思到编码再到部署您的应用程序！</p><p id="46c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您创建了一个Streamlit应用程序，您就可以使用自动化测试来保证它不会出现倒退。在这篇文章中，我将展示如何使用Python包<a class="ae kl" href="https://seleniumbase.io/" rel="noopener ugc nofollow" target="_blank"> SeleniumBase </a>以编程方式验证Streamlit应用程序在视觉上没有改变。</p><h1 id="8b7c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">案例研究:细流叶</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/e71d11bbb134d93c818b27e4963fd781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I4AOQsrRD35R_5p6"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">streamlit-flour测试应用程序的基准图像(作者提供的图像/截图)</p></figure><p id="ce18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示如何创建自动化的可视化测试，我将使用<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium" rel="noopener ugc nofollow" target="_blank">streamlit-leave GitHub repo</a>，这是我为leave . js的<a class="ae kl" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">leave Python库创建的Streamlit组件。</a><a class="ae kl" href="https://baseweb.design/blog/visual-regression-testing/" rel="noopener ugc nofollow" target="_blank">视觉回归测试</a>有助于检测应用的布局或内容何时发生变化，而不需要开发人员在其Python库中每次代码行发生变化时手动视觉检查输出。视觉回归测试还有助于提高您的Streamlit应用程序的跨浏览器兼容性，并提供有关影响应用程序显示方式的新浏览器版本的高级警告。</p><h1 id="d548" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">设置测试工具</h1><p id="3439" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">streamlit-follow测试工具有三个文件:</p><ul class=""><li id="8d04" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/tests/requirements.txt" rel="noopener ugc nofollow" target="_blank">tests/requirements.txt</a></code>:测试只需要Python包</li><li id="5839" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/tests/app_to_test.py" rel="noopener ugc nofollow" target="_blank">tests/app_to_test.py</a></code>:参考要测试的Streamlit应用</li><li id="32e0" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated"><code class="fe mo mp mq mr b"><a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/tests/test_package.py" rel="noopener ugc nofollow" target="_blank">tests/test_package.py</a></code>:演示包按预期工作的测试</li></ul><p id="a1f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是使用要测试的包创建一个Streamlit应用程序，并使用它来设置基线。然后，我们可以使用SeleniumBase来验证应用程序的结构和视觉外观相对于基线保持不变。</p><p id="2c3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的重点是描述<code class="fe mo mp mq mr b">test_package.py</code>,因为它是涵盖如何使用SeleniumBase和OpenCV进行Streamlit测试的文件。</p><h1 id="4932" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">定义测试成功</h1><p id="2b69" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">从测试的角度来看，有几种方法可以思考什么构成了看起来相同的。我选择了以下三个原则来测试我的streamlit-leav包:</p><ol class=""><li id="9791" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk my ml mm mn bi translated">页面的<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" rel="noopener ugc nofollow" target="_blank">文档对象模型(DOM)结构</a>(但不一定是值)应该保持不变</li><li id="b699" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk my ml mm mn bi translated">对于标题等值，测试这些值是否完全相等</li><li id="8059" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk my ml mm mn bi translated">视觉上，应用程序应该看起来一样</li></ol><p id="fb5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定采用这些不太严格的“未更改”定义来测试streamlit-follow，因为follow包本身的内部似乎是不确定的。这意味着，相同的Python代码将创建相同的<em class="mx">外观的</em>图像，但是生成的HTML将会不同。</p><h1 id="4218" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用硒基测试</h1><p id="5cf4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">SeleniumBase是用Python编写的一体化框架，它包装了用于浏览器自动化的<a class="ae kl" href="https://www.selenium.dev/" rel="noopener ugc nofollow" target="_blank"> Selenium WebDriver </a>项目。SeleniumBase有两个函数可以用于上面列出的第一个和第二个测试原则:<a class="ae kl" href="https://seleniumbase.io/examples/visual_testing/ReadMe/#automated-visual-regression-testing" rel="noopener ugc nofollow" target="_blank"> check_window </a>，它测试DOM结构和<a class="ae kl" href="https://seleniumbase.io/help_docs/method_summary/" rel="noopener ugc nofollow" target="_blank"> assert_text </a>，以确保页面上显示特定的一段文本。</p><p id="ce33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了检查DOM结构，我们首先需要一个基线，我们可以使用<code class="fe mo mp mq mr b">check_window</code>函数生成这个基线。根据所需的<code class="fe mo mp mq mr b">name</code>参数，<code class="fe mo mp mq mr b">check_window</code>有两种行为:</p><ul class=""><li id="54e1" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">如果在<code class="fe mo mp mq mr b">visual_baseline/&lt;Python file&gt;.&lt;test function name&gt;</code>路径中不存在文件夹&lt;<strong class="jp ir">名称&gt; </strong>的话，这个文件夹将由所有的基线文件创建</li><li id="1c56" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated">如果文件夹<em class="mx">确实存在</em>，那么SeleniumBase将按照指定的精度级别将当前页面与基线进行比较</li></ul><p id="ad97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在streamlit-leav repo中看到一个调用<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/tests/test_package.py#L19" rel="noopener ugc nofollow" target="_blank"> check_window </a>和结果<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/tree/master/tests/visual_baseline/test_package.test_basic/first_test" rel="noopener ugc nofollow" target="_blank">基线文件</a>的示例。为了在两次运行之间保持基线不变，我将这些文件提交给了repo如果我要对我正在测试的应用程序(<code class="fe mo mp mq mr b">app_to_test.py</code>)进行任何实质性的更改，我需要记住设置新的基线，否则测试将会失败。</p><p id="3f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基线文件夹现在已经存在，运行check_window将运行比较测试。我选择在<strong class="jp ir">级别2 </strong>运行测试，级别定义如下:</p><ul class=""><li id="eea2" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir">级别1(最不严格)</strong> : HTML标签与<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/tests/visual_baseline/test_package.test_basic/first_test/tags_level_1.txt" rel="noopener ugc nofollow" target="_blank"> tags_level1.txt </a>进行比较</li><li id="0135" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated"><strong class="jp ir">级别2 </strong> : HTML标签和属性名与<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/tests/visual_baseline/test_package.test_basic/first_test/tags_level_2.txt" rel="noopener ugc nofollow" target="_blank">标签_级别2.txt </a>进行比较</li><li id="fe09" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated"><strong class="jp ir">第三级(最严格)</strong> : HTML标签、属性名和属性值与<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/tests/visual_baseline/test_package.test_basic/first_test/tags_level_3.txt" rel="noopener ugc nofollow" target="_blank"> tags_level3.txt </a>进行比较</li></ul><p id="e266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如在“定义测试成功”一节中提到的，我在第2级运行了<code class="fe mo mp mq mr b">check_window</code>函数，因为follow库向HTML中的属性值添加了一个类似GUID的ID值，所以测试永远不会在第3级通过，因为属性值在运行之间总是不同的。</p><p id="8300" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于第二个测试原则(“检查某些值是否相等”)，使用<code class="fe mo mp mq mr b">assert_text</code>方法非常容易:</p><p id="92a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mo mp mq mr b">self.assert_text("streamlit-folium")</code></p><p id="431d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数检查应用程序中是否存在准确的文本“streamlit-follow ”,测试通过，因为在本例中这是H1标题的值。</p><h1 id="5123" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用OpenCV进行测试</h1><p id="c487" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">虽然检查DOM结构和一段文本的存在提供了一些有用的信息，但我真正的接受标准是应用程序的视觉外观不会从基线改变。为了测试应用的视觉效果是否与像素相同，我们可以使用SeleniumBase的<code class="fe mo mp mq mr b">save_screenshot</code>方法来捕捉应用的当前视觉状态，并使用OpenCV包与基线进行比较:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="254c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用OpenCV，第一步是读入基线图像和当前快照，然后比较图片的大小是否相同(<code class="fe mo mp mq mr b">shape</code>比较检查像素的NumPy ndarrays是否具有相同的尺寸)。假设图片大小相同，我们可以使用OpenCV中的<code class="fe mo mp mq mr b">subtract</code>函数来计算每个通道(蓝色、绿色和红色)像素之间的差异。如果所有三个通道没有差异，那么我们知道Streamlit应用程序的视觉表示在运行之间是相同的。</p><h1 id="7787" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用GitHub动作自动化测试</h1><p id="ac3d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">随着我们的SeleniumBase和OpenCV代码的设置，我们现在可以自由地对我们的Streamlit组件(或其他Streamlit应用程序)进行更改，而不用担心意外中断。在我的单贡献者项目中，很容易在本地强制运行测试，但是有了开源项目免费提供的工具，如<a class="ae kl" href="https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/" rel="noopener ugc nofollow" target="_blank">GitHub Actions</a>，建立一个<a class="ae kl" href="https://www.infoworld.com/article/3271126/what-is-cicd-continuous-integration-and-continuous-delivery-explained.html" rel="noopener ugc nofollow" target="_blank">持续集成管道</a>保证了每次提交都运行测试。</p><p id="c16d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">streamlit-leav定义了一个工作流程<code class="fe mo mp mq mr b"><a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/.github/workflows/run_tests_each_PR.yml" rel="noopener ugc nofollow" target="_blank">run_tests_each_PR.yml</a></code>,执行以下操作:</p><ul class=""><li id="cb15" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">为Python 3.6、3.7、3.8 建立一个<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/.github/workflows/run_tests_each_PR.yml#L18" rel="noopener ugc nofollow" target="_blank">测试矩阵</a></li><li id="ab44" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated">安装<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/.github/workflows/run_tests_each_PR.yml#L30" rel="noopener ugc nofollow" target="_blank">包依赖关系</a>和<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/.github/workflows/run_tests_each_PR.yml#L31" rel="noopener ugc nofollow" target="_blank">测试依赖关系</a></li><li id="2c64" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated">将代码用薄片8标记</li><li id="36ae" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated"><a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/.github/workflows/run_tests_each_PR.yml#L40" rel="noopener ugc nofollow" target="_blank">用硒鼓安装铬合金</a></li><li id="030b" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated"><a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/.github/workflows/run_tests_each_PR.yml#L43" rel="noopener ugc nofollow" target="_blank">运行Streamlit app </a>进行后台测试</li><li id="5da5" class="mf mg iq jp b jq ms ju mt jy mu kc mv kg mw kk mk ml mm mn bi translated">在Python中运行<a class="ae kl" href="https://github.com/randyzwitch/streamlit-folium/blob/master/.github/workflows/run_tests_each_PR.yml#L46" rel="noopener ugc nofollow" target="_blank"> SeleniumBase和OpenCV测试</a></li></ul><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7a16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过在repo中定义这个工作流，并在GitHub 上启用<a class="ae kl" href="https://docs.github.com/en/github/administering-a-repository/enabling-required-status-checks" rel="noopener ugc nofollow" target="_blank">所需的状态检查，现在每个pull请求都会在底部附加以下状态检查，让您知道您的更改的状态:</a></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nb"><img src="../Images/a9e6cf78465dfe0dcc01380a178c9849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o0vqvmBVpnQM7cPC"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">合并前GitHub运行的检查(图片/作者截图)</p></figure><h1 id="97cf" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">从长远来看，编写测试可以节省工作</h1><p id="b8f3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在代码库中进行测试有很多好处。如上所述，自动化视觉回归测试允许你维护一个应用程序，而不需要一个人在循环中寻找变化。编写测试对潜在用户来说也是一个很好的信号，表明你关心项目的稳定性和长期可维护性。为Streamlit应用程序编写测试并让它们在每次GitHub提交时自动运行不仅容易，而且从长远来看，向Streamlit项目添加测试的额外工作将节省您的时间。</p><p id="9fe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mx">对本文或Streamlit有任何疑问吗？驻足于</em> <a class="ae kl" href="https://discuss.streamlit.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> Streamlit社区论坛</em> </a> <em class="mx">，展开讨论，结识其他Streamlit爱好者，在</em> <a class="ae kl" href="https://discuss.streamlit.io/t/streamlit-components-community-tracker/4634" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> Streamlit组件跟踪器</em> </a> <em class="mx">或</em> <a class="ae kl" href="https://discuss.streamlit.io/c/streamlit-examples/9" rel="noopener ugc nofollow" target="_blank"> <em class="mx">中找到合作者，分享你的Streamlit项目</em> </a> <em class="mx">！有很多方法可以加入Streamlit社区，我们期待着您的到来🎈</em></p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="0697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mx">原载于2020年11月13日</em><a class="ae kl" href="https://blog.streamlit.io/testing-streamlit-apps-using-seleniumbase/" rel="noopener ugc nofollow" target="_blank"><em class="mx">https://blog . streamlit . io</em></a><em class="mx">。</em></p></div></div>    
</body>
</html>