<html>
<head>
<title>All the Pandas merge() you should know for combining datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有的熊猫合并()你应该知道合并数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/all-the-pandas-merge-you-should-know-for-combining-datasets-526b9ecaf184?source=collection_archive---------2-----------------------#2020-11-11">https://towardsdatascience.com/all-the-pandas-merge-you-should-know-for-combining-datasets-526b9ecaf184?source=collection_archive---------2-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e632" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你应该知道的一些最有用的熊猫把戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc9e5e09bc95dfa821d8dbff2fcc8b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5Mp_Yq9XFjCGMnrDcNg6A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Galymzhan Abdugalimov 在<a class="ae ky" href="https://unsplash.com/collections/9038523/marketing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d9a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas提供了各种内置函数来轻松组合数据集。其中，<code class="fe lv lw lx ly b">merge()</code>是一个非常类似于SQL这样的关系数据库的高性能内存操作。当您想进行类似数据库的连接操作时，可以随时使用<code class="fe lv lw lx ly b">merge()</code>。</p><p id="4458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将浏览一些使用熊猫<code class="fe lv lw lx ly b">merge()</code>函数合并数据集的例子。我们将介绍以下常见用法，应该可以帮助您开始使用数据组合。</p><ol class=""><li id="daf6" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">没有任何键列的最简单的调用</li><li id="be92" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">使用<code class="fe lv lw lx ly b">on</code>指定关键列</li><li id="8fa9" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">使用<code class="fe lv lw lx ly b">left_on</code>和<code class="fe lv lw lx ly b">right_on</code>合并</li><li id="71ed" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">各种形式的连接:<code class="fe lv lw lx ly b">inner</code>、<code class="fe lv lw lx ly b">left</code>、<code class="fe lv lw lx ly b">right</code>和<code class="fe lv lw lx ly b">outer</code></li><li id="a192" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">使用<code class="fe lv lw lx ly b">validate</code>避免无效记录</li></ol><p id="2b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码请查看<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/master/data-analysis/018-pandas-merge/pandas-merge.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="260c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.没有任何键列</h1><p id="a073" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">当您使用<code class="fe lv lw lx ly b">merge()</code>时，最简单的调用必须有两个参数:<code class="fe lv lw lx ly b">left</code>数据帧和<code class="fe lv lw lx ly b">right</code>数据帧。例如，要组合<code class="fe lv lw lx ly b">df_customer</code>和<code class="fe lv lw lx ly b">df_info</code>:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="ff89" class="nv mv it ly b gy nw nx l ny nz">df_customer = pd.DataFrame({<br/>    'id': [1, 2, 3, 4],<br/>    'name': ['Tom', 'Jenny', 'James', 'Dan'],<br/>})</span><span id="5cee" class="nv mv it ly b gy oa nx l ny nz">df_info = pd.DataFrame({<br/>    'id': [2, 3, 4, 5],<br/>    'age': [31, 20, 40, 70],<br/>    'sex': ['F', 'M', 'M', 'F']<br/>})</span><span id="e99f" class="nv mv it ly b gy oa nx l ny nz">pd.merge(<strong class="ly iu">df_customer</strong>, <strong class="ly iu">df_info</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/7376de3a2dbc4056428370bdeb3f72b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H60kVHfgvZVZODkFTZksvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最简单的呼叫(图片由作者提供)</p></figure><p id="26bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，该函数将组合公共列(在我们的示例中是列<strong class="lb iu"> <em class="oc"> id </em> </strong>)上的数据，并且只生成在左右数据帧中都匹配的结果。</p><p id="e474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您喜欢从左侧数据帧调用merge，下面是一个等效的语句。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1002" class="nv mv it ly b gy nw nx l ny nz"><strong class="ly iu">df_customer</strong>.merge(df_info) </span></pre><h1 id="d725" class="mu mv it bd mw mx od mz na nb oe nd ne jz of ka ng kc og kd ni kf oh kg nk nl bi translated">2.使用上的参数指定键列</h1><p id="e2b4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">您可以指定用于合并的公共列。为此，向函数<code class="fe lv lw lx ly b">merge()</code>传递一个额外的参数<code class="fe lv lw lx ly b">on</code>作为公共列的名称，在我们的示例中为<code class="fe lv lw lx ly b">'id'</code>:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="6277" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_info, <strong class="ly iu">on='id'</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/8bc615a88f3ff5b3b2984b1d2fda04ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCpo3gXuXI4KFhKivEt2ZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pd.merge(df_customer，df_info，<strong class="bd oj"> on='id' </strong>)(图片由作者提供)</p></figure><p id="14e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用<code class="fe lv lw lx ly b">on</code>，你必须<strong class="lb iu">确保你指定的列必须出现在左右数据帧</strong>中。</p><p id="b4d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要合并多个公共列上的数据，您可以将一个列表传递给<code class="fe lv lw lx ly b">on</code>:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="5631" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_order, <strong class="ly iu">on=['id', 'name']</strong>)</span></pre><h1 id="fc37" class="mu mv it bd mw mx od mz na nb oe nd ne jz of ka ng kc og kd ni kf oh kg nk nl bi translated">3.使用<code class="fe lv lw lx ly b">left_on</code>和<code class="fe lv lw lx ly b">right_on</code>合并</h1><p id="bd99" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">您要合并数据框的列可能会有不同的名称。对于这种合并，您必须指定<code class="fe lv lw lx ly b">left_on</code>作为左侧数据帧名称，指定<code class="fe lv lw lx ly b">right_on</code>作为右侧数据帧名称，例如:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="e9a8" class="nv mv it ly b gy nw nx l ny nz">pd.merge(<br/>  df_customer, <br/>  df_info_2, <br/>  <strong class="ly iu">left_on='id', <br/>  right_on='customer_id'<br/></strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/06fb5d0a7b94fe9ac053b56fd18ae9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ii-_LUrEKNqDULeDZ_4kdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并左_开和右_开(图片由作者提供)</p></figure><p id="206c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果将同时包含<strong class="lb iu"> <em class="oc"> id </em> </strong>和<strong class="lb iu"> <em class="oc"> customer_id </em> </strong>列。</p><h1 id="aa46" class="mu mv it bd mw mx od mz na nb oe nd ne jz of ka ng kc og kd ni kf oh kg nk nl bi translated">4.各种类型的连接:<code class="fe lv lw lx ly b">inner</code>、<code class="fe lv lw lx ly b">left</code>、<code class="fe lv lw lx ly b">right</code>和<code class="fe lv lw lx ly b">outer</code></h1><p id="dbaf" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">它们是Pandas <code class="fe lv lw lx ly b">merge()</code>函数可用的4种连接类型。这些连接背后的逻辑与您在SQL中连接表时的逻辑非常相似。您可以通过使用以下值指定<code class="fe lv lw lx ly b">how</code>参数来执行一种类型的连接:</p><ul class=""><li id="c2ac" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">inner</code>:Pandas<code class="fe lv lw lx ly b">merge()</code>函数中的默认连接类型，它产生在两个数据帧中都有匹配值的记录</li><li id="50ee" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">left</code>:从左侧数据帧产生所有记录，从右侧数据帧产生匹配记录</li><li id="307e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">right</code>:从右侧数据帧产生所有记录，从左侧数据帧产生匹配记录</li><li id="99c6" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">outer</code>:当左侧或右侧数据帧中存在匹配时，生成所有记录</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/52100635ae684af751f5905eab19fb96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bL8ihJmwShib8Xj90X4Pw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源<a class="ae ky" href="https://en.wikipedia.org/wiki/Join_(SQL)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Join _(SQL)</a></p></figure><p id="d0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们测试数据集的维恩图</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="b3f8" class="nv mv it ly b gy nw nx l ny nz">df_customer = pd.DataFrame({<br/>    'id': [1,2,3,4],<br/>    'name': ['Tom', 'Jenny', 'James', 'Dan'],<br/>})</span><span id="c025" class="nv mv it ly b gy oa nx l ny nz">df_info = pd.DataFrame({<br/>    'id': [2,3,4,5],<br/>    'age': [31,20,40,70],<br/>    'sex': ['F', 'M', 'M', 'F']<br/>})</span><span id="a5ec" class="nv mv it ly b gy oa nx l ny nz">pd.merge(df_customer, df_info, <strong class="ly iu">on='id'</strong>, <strong class="ly iu">how=?</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/58544e317301a22b7a5aa843766a5c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xd2B575qzZWi8FlzgrESpw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">维恩图(图片由作者提供)</p></figure><h2 id="b2f5" class="nv mv it bd mw oo op dn na oq or dp ne li os ot ng lm ou ov ni lq ow ox nk oy bi translated">4.1内部连接</h2><p id="413d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">默认情况下，Pandas <code class="fe lv lw lx ly b">merge()</code>执行内部连接，它只产生在两个数据帧中匹配的记录集。</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="b917" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_info, on='id')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/5956fc453dc57933fed101e4e71ef27a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZf-aphE-o8Naqc_2ywB6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe lv lw lx ly b">Pandas merge with inner join </code>(图片作者提供)</p></figure><p id="a321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是等效的SQL查询:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="67a3" class="nv mv it ly b gy nw nx l ny nz">SELECT * from customer<br/><strong class="ly iu">INNER JOIN</strong> info<br/>ON customer.id = info.id</span></pre><p id="7df7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要显式指定内部连接，可以设置参数<code class="fe lv lw lx ly b">how='inner'</code></p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="eaae" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_info, <strong class="ly iu">how='inner'</strong>, on='id')</span></pre><h2 id="ba08" class="nv mv it bd mw oo op dn na oq or dp ne li os ot ng lm ou ov ni lq ow ox nk oy bi translated">4.2左连接</h2><p id="1b18" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">左连接从左侧数据帧产生所有记录，从右侧数据帧产生匹配的记录。如果没有匹配，左侧会包含<code class="fe lv lw lx ly b">NaN</code>。您可以将参数<code class="fe lv lw lx ly b">how='left'</code>设置为左连接:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="d36a" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_info, <strong class="ly iu">how='left'</strong>, on='id')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/1f03f11a731d5fb91c104801ca88183f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zT68RD5jO-SybZye6Y2Fw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带左连接的Panda merge()</p></figure><p id="e742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是等效的SQL查询:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="620d" class="nv mv it ly b gy nw nx l ny nz">SELECT * from customer<br/><strong class="ly iu">LEFT OUTER JOIN</strong> info<br/>ON customer.id = info.id</span></pre><h2 id="dcaf" class="nv mv it bd mw oo op dn na oq or dp ne li os ot ng lm ou ov ni lq ow ox nk oy bi translated">4.3右连接</h2><p id="091a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">右连接从右数据帧产生所有记录，从左数据帧产生匹配的记录。如果没有匹配，右边将包含<code class="fe lv lw lx ly b">NaN</code>。您可以设置参数<code class="fe lv lw lx ly b">how='right'</code>来执行右连接:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="8e15" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_info, <strong class="ly iu">how='right'</strong>, on='id')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/dd9450e192348c2b222fd689af0b0c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kckqogCjVfYAvrawDSWFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫合并()带右连接(图片由作者提供)</p></figure><p id="c28c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是等效的SQL查询:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="5a89" class="nv mv it ly b gy nw nx l ny nz">SELECT * from customer<br/><strong class="ly iu">RIGHT OUTER JOIN</strong> info<br/>ON customer.id = info.id</span></pre><h2 id="d5bd" class="nv mv it bd mw oo op dn na oq or dp ne li os ot ng lm ou ov ni lq ow ox nk oy bi translated">4.4外部连接</h2><p id="f9c8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">当左数据帧或右数据帧中有匹配时，外部连接产生所有记录。<code class="fe lv lw lx ly b">NaN</code>将因双方无比赛而被填满。您可以设置参数<code class="fe lv lw lx ly b">how='outer'</code>进行外部连接:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="3ee6" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_info, <strong class="ly iu">how='outer'</strong>, on='id')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/d8836a3a3def24764e10ce613f62859f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPLSsnORsg910cwhkiM_YQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">熊猫合并()与外部连接(图片由作者提供)</p></figure><p id="bf1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是等效的SQL查询:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="6678" class="nv mv it ly b gy nw nx l ny nz">SELECT * from customer<br/><strong class="ly iu">FULL OUTER JOIN</strong> info<br/>ON customer.id = info.id</span></pre><h1 id="44a2" class="mu mv it bd mw mx od mz na nb oe nd ne jz of ka ng kc og kd ni kf oh kg nk nl bi translated">5.使用<code class="fe lv lw lx ly b">validate</code>避免无效记录</h1><p id="e6f1" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果合并键不是唯一的，那么<code class="fe lv lw lx ly b">merge()</code>的结果可能会增加行数。例如</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="a3cb" class="nv mv it ly b gy nw nx l ny nz">df_customer = pd.DataFrame({<br/>    'id': [1,2,3,4],<br/>    'name': ['Tom', 'Jenny', 'James', 'Dan'],<br/>})</span><span id="6258" class="nv mv it ly b gy oa nx l ny nz">df_order_2 = pd.DataFrame({<br/>    'id': [2, 2, 4, 4],<br/>    'product': ['A', 'B' ,'A', 'C'],<br/>    'quantity': [31, 21, 20,40],<br/>    'date': pd.date_range('2019-02-24', periods=4, freq='D')<br/>})</span></pre><p id="20a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">df_customer</code>和<code class="fe lv lw lx ly b">df_order_2</code>都有4条记录。但是，当运行以下merge语句时，您将得到包含6条记录的结果:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="ccca" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_order_2, <strong class="ly iu">how='left'</strong>, <strong class="ly iu">on='id'</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/047f45b6e88201a2f2dde540be4054f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbneAYYAvXUJ5FtYhCaESg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="c867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因如下:</p><ul class=""><li id="c25e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">how='left'</code>将产生来自<code class="fe lv lw lx ly b">df_customer</code>的所有记录，以及来自<code class="fe lv lw lx ly b">df_order_2</code>的匹配记录。</li><li id="b6ef" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated">另外，<code class="fe lv lw lx ly b">df_order_2</code>中的<code class="fe lv lw lx ly b">id</code>不是唯一的，所有匹配的记录将被合并返回。</li></ul><p id="75fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个<strong class="lb iu"> <em class="oc">一对多</em> </strong>合并的例子。在我们的示例中，这是一个有效的场景，其中一个客户可以有多个订单。但是，<strong class="lb iu">一对多</strong>在其他一些情况下可能无效，例如<code class="fe lv lw lx ly b">df_info</code>中有两条id值为<code class="fe lv lw lx ly b">2</code>的记录</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="2afb" class="nv mv it ly b gy nw nx l ny nz">df_customer = pd.DataFrame({<br/>    'id': [1, <strong class="ly iu">2</strong>, 3, 4],<br/>    'name': ['Tom', <strong class="ly iu">'Jenny'</strong>, 'James', 'Dan'],<br/>})</span><span id="8f09" class="nv mv it ly b gy oa nx l ny nz">df_info = pd.DataFrame({<br/>    'id': [<strong class="ly iu">2</strong>, <strong class="ly iu">2</strong>, 3, 4, 5],<br/>    'age': [<strong class="ly iu">31</strong>, <strong class="ly iu">21</strong>, 20, 40, 70],<br/>    'sex': [<strong class="ly iu">'F'</strong>, <strong class="ly iu">'F'</strong>, 'M', 'M', 'F']<br/>})</span></pre><p id="07fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并结果将以同一个客户的两个不同记录结束<strong class="lb iu">珍妮</strong>:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="670a" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_info, <strong class="ly iu">how='left'</strong>, <strong class="ly iu">on='id'</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/cb9ad7a35088203eed47bf87cbe84e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*Dg0uheCsjW0PUWDdWbWQJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="ff30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然是错误的，因为同一个客户不可能有不同的信息。为了避免这个问题，我们可以将参数<code class="fe lv lw lx ly b">validate</code>设置为<code class="fe lv lw lx ly b">'1:1'</code>，这样它可以检查合并键在左右数据帧中是否是唯一的。如果验证失败，将引发<strong class="lb iu"> MergeError </strong>，例如:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="1e50" class="nv mv it ly b gy nw nx l ny nz">pd.merge(df_customer, df_info, <strong class="ly iu">how='left'</strong>, <strong class="ly iu">on='id', validate='1:1'</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/32f6faa061a41034746d9a0d7a8b6e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HoXzA9RZf_DPzssUfqMe9A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并错误</p></figure><p id="c0b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数<code class="fe lv lw lx ly b">validate</code>采用以下值之一，因此您可以使用它来验证不同的合并输出。</p><ul class=""><li id="38b4" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">one_to_one</code>或<code class="fe lv lw lx ly b">1:1</code>:检查合并键在左右数据集中是否唯一。</li><li id="041e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">one_to_many</code>或<code class="fe lv lw lx ly b">1:m</code>:检查合并键在左侧数据集中是否唯一。</li><li id="5346" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">many_to_one</code>或<code class="fe lv lw lx ly b">m:1</code>:检查右数据集中合并键是否唯一。</li><li id="326a" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><code class="fe lv lw lx ly b">many_to_many</code>或<code class="fe lv lw lx ly b">m:m</code>:允许，但不检查。</li></ul><h1 id="2f86" class="mu mv it bd mw mx od mz na nb oe nd ne jz of ka ng kc og kd ni kf oh kg nk nl bi translated">结论</h1><p id="efbb" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Pandas <code class="fe lv lw lx ly b">merge()</code>函数是一个简单、强大、高性能的内存操作，非常类似于SQL这样的关系数据库。</p><p id="dcf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助你节省组合数据集的时间。我建议你查看一下关于<code class="fe lv lw lx ly b">merge()</code> API的<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html" rel="noopener ugc nofollow" target="_blank">文档</a>,并了解你可以做的其他事情。</p><p id="e5d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。请查看<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/master/data-analysis/018-pandas-merge/pandas-merge.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>获取源代码，如果您对机器学习的实用方面感兴趣，请继续关注。</p><h2 id="0406" class="nv mv it bd mw oo op dn na oq or dp ne li os ot ng lm ou ov ni lq ow ox nk oy bi translated">你可能会对我的其他一些熊猫文章感兴趣:</h2><ul class=""><li id="9cad" class="lz ma it lb b lc nm lf nn li pg lm ph lq pi lu ol mf mg mh bi translated"><a class="ae ky" href="https://bindichen.medium.com/pandas-resample-tricks-you-should-know-for-manipulating-time-series-data-7e9643a7e7f3" rel="noopener">熊猫重采样()你应该知道的处理时间序列数据的技巧</a></li><li id="2144" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/how-to-do-a-custom-sort-on-pandas-dataframe-ac18e7ea5320">如何对熊猫数据帧进行自定义排序</a></li><li id="72a2" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/when-to-use-pandas-transform-function-df8861aa0dcf">何时使用Pandas transform()函数</a></li><li id="1814" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/pandas-concat-tricks-you-should-know-to-speed-up-your-data-analysis-cd3d4fdfe6dd">你应该知道的熊猫串联()招数</a></li><li id="7529" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><a class="ae ky" href="https://medium.com/@bindiatwork/difference-between-apply-and-transform-in-pandas-242e5cf32705" rel="noopener">Pandas中应用()和转换()的区别</a></li><li id="3be8" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><a class="ae ky" href="https://medium.com/@bindiatwork/using-pandas-method-chaining-to-improve-code-readability-d8517c5626ac" rel="noopener">使用熊猫方法链接提高代码可读性</a></li><li id="c16f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/working-with-datetime-in-pandas-dataframe-663f7af6c587">在Pandas数据帧中处理日期时间</a></li><li id="37aa" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><a class="ae ky" href="https://medium.com/@bindiatwork/all-the-pandas-read-csv-you-should-know-to-speed-up-your-data-analysis-1e16fe1039f3" rel="noopener">熊猫阅读_csv()你应该知道的招数</a></li><li id="5559" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu ol mf mg mh bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/4-tricks-you-should-know-to-parse-date-columns-with-pandas-read-csv-27355bb2ad0e">你应该知道的用熊猫read_csv() </a>解析日期列的4个技巧</li></ul><p id="1976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多教程可以在我的<a class="ae ky" href="https://github.com/BindiChen/machine-learning" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到</p></div></div>    
</body>
</html>