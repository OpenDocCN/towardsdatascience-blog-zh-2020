<html>
<head>
<title>Using Dynamic Planning to Help Trump Win the Elections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用动态规划帮助特朗普赢得选举</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-dynamic-planning-to-help-trump-win-the-elections-7b5b34f63961?source=collection_archive---------24-----------------------#2020-11-10">https://towardsdatascience.com/using-dynamic-planning-to-help-trump-win-the-elections-7b5b34f63961?source=collection_archive---------24-----------------------#2020-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/298518c6a8ef06f407c11a2596b28ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__x6xlrmVfzhousb25G-SQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/vectors/maps-country-america-states-land-812736/#" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae jg" href="https://pixabay.com/users/fajarbudi86-1126901/" rel="noopener ugc nofollow" target="_blank"> fajarbudi86 </a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="9c05" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Python中优化选举宣传的动态规划</h2></div><blockquote class="ky kz la"><p id="f630" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">说明:2020年美国大选在本文中仅作为背景。这个故事意在向你展示计算机编程中的这种思维方式。我既不是在表达我的政治观点，也不是在用任何观点进行说服。本文中使用的所有数据都是由假设构成的，无论如何都不一定反映事实。</p></blockquote><p id="52cf" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在我写这篇文章的时候，乔·拜登已经稳操胜券了。我既不是美国人，也没有在美国生活，所以我不会在政治上对此发表评论，尽管我认为大多数阅读我文章的人可能会支持拜登。我哪里知道？就看看加州吧:)</p><p id="24d6" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">好的。现在我们想象一下，我们被聘为特朗普选举团队的一员。假设离投票开始还有10天。大家都知道，最重要的是争取摇摆州。我不太喜欢政治，所以我对这方面的知识有限，但幸运的是，我从维基百科上得到了被认为是2020年美国大选摇摆州的11个州。</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/9e2017524ebc2149dbc28620d2d3530f.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*qX1IRDEgGqw-SVpD0LZNvA.png"/></div></figure><p id="0c3d" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我们就随便编个数据，把所有的州，他们的选举人票数量，以及在这个州推广需要的天数一起放在一个字典里。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="df93" class="ml mm jj mh b gy mn mo l mp mq">states_dict = [<br/>    {'name': 'Maine', 'votes': 5, 'days': 1},<br/>    {'name': 'Nevada', 'votes': 6, 'days': 1},<br/>    {'name': 'Minnesota', 'votes': 10, 'days': 2},<br/>    {'name': 'New Hampshire', 'votes': 4, 'days': 1},<br/>    {'name': 'Michigan', 'votes': 16, 'days': 3},<br/>    {'name': 'Pennsylvania', 'votes': 20, 'days': 4},<br/>    {'name': 'Wisconsin', 'votes': 10, 'days': 2},<br/>    {'name': 'Florida', 'votes': 29, 'days': 5},<br/>    {'name': 'Arizona', 'votes': 11, 'days': 2},<br/>    {'name': 'North Carolina', 'votes': 15, 'days': 3},<br/>    {'name': 'Georgia', 'votes': 16, 'days': 3},<br/>]</span></pre><p id="698c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">假设是，如果我们在相应的州度过该天数，我们将赢得该州。</p><p id="0693" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">问题是川普在最后10天能拿到多少选举人票<strong class="le jk">最多</strong>？所以，如果我们把所有红色州的选票加起来，我们就能估计出特朗普最终会有多少张选举人票。</p><p id="4a3c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">有几种方法可以解决这个问题。最直观的方式大概就是递归函数了。然而，它绝对不是最好的解决方案。</p><p id="01dd" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在本文中，我将提供递归解决方案和动态规划解决方案。将给出解释来说明为什么动态规划比前者更先进。</p><h1 id="2d86" class="mr mm jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">递归解</h1><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/934d60cf3bd45f3669b0335028ad2a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rZuf8xgejGIPvJcVoOUKw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/photos/stairway-spiral-stairs-architecture-5551641/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae jg" href="https://pixabay.com/users/tkirkgoz-16692474/" rel="noopener ugc nofollow" target="_blank"> tkirkgoz </a>拍摄的照片</p></figure><p id="5fee" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">递归解决方案的思想相对简单。也就是说，对于每个州，我们有两个选择——去或不去。</p><p id="d6bb" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">因此，函数将是关于</p><blockquote class="ni"><p id="6619" class="nj nk jj bd nl nm nn no np nq nr lx dk translated">在接下来的几天里从其他州获得最多的选举人票</p></blockquote><p id="19e5" class="pw-post-body-paragraph lb lc jj le b lf ns kk lh li nt kn lk ly nu ln lo lz nv lr ls ma nw lv lw lx im bi translated">如果我们选择去这个州，我们将在剩下的几天里得到选举人票+其他州的最高选举人票。否则，我们应该在接下来的几天里从其他州退回最多的选举人票。</p><p id="6c1f" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">代码如下:</p><figure class="mc md me mf gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4ee7" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">为了防止gist有时不能很好地工作，我也将代码简单地发布如下:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="8bf4" class="ml mm jj mh b gy mn mo l mp mq">def max_vote_recursive(states, days_left, index):<br/>    # Terminating conditions<br/>    if len(states) == 0 or index &gt;= len(states) or days_left &lt;= 0:<br/>        return 0</span><span id="dd42" class="ml mm jj mh b gy nz mo l mp mq"># If we have enough days, go to this state<br/>    votes_if_go = 0<br/>    if states[index]['days'] &lt;= days_left:<br/>        votes_if_go = states[index]['votes'] + max_vote_recursive(states, days_left - states[index]['days'], index + 1)</span><span id="182d" class="ml mm jj mh b gy nz mo l mp mq"># If we don't go to this state<br/>    votes_if_not_go = max_vote_recursive(states, days_left, index + 1)</span><span id="a009" class="ml mm jj mh b gy nz mo l mp mq">    return max(votes_if_go, votes_if_not_go)</span></pre><p id="33b0" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">如果我们运行函数为<code class="fe oa ob oc mh b">max_vote_recursive(states_dict, 10, 0)</code>，我们应该得到56张选举人票的结果。</p><p id="3ac6" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">为什么我说这个递归函数不够高效？我可以直观地展示给你看。</p><p id="336e" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我所做的是将最后一个返回语句<code class="fe oa ob oc mh b">return max(votes_if_go, votes_if_not_go)</code>改为下面的代码片段。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5ea2" class="ml mm jj mh b gy mn mo l mp mq">if votes_if_go &gt; votes_if_not_go:<br/>        print(f'There are {days_left} days left. We should go to {states[index]["name"]}')<br/>        return votes_if_go<br/>    else:<br/>        print(f'There are {days_left} days left. We should not go to {states[index]["name"]}')<br/>        return votes_if_not_go</span></pre><p id="4995" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">因此，递归的每一步都将输出还剩多少天以及当前状态。更改之后，通过再次运行该函数，我们将得到如下所示的大量输出日志。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="d6ec" class="ml mm jj mh b gy mn mo l mp mq">There are 2 days left. We should not go to Georgia<br/>There are 2 days left. We should not go to North Carolina<br/>There are 2 days left. We should go to Arizona<br/>There are 2 days left. We should not go to Florida<br/>There are 2 days left. We should not go to Wisconsin<br/>There are 2 days left. We should not go to Pennsylvania<br/>There are 1 days left. We should not go to Georgia<br/>There are 1 days left. We should not go to North Carolina<br/>There are 1 days left. We should not go to Arizona<br/>There are 1 days left. We should not go to Florida<br/>There are 1 days left. We should not go to Wisconsin<br/>There are 1 days left. We should not go to Georgia<br/>There are 1 days left. We should not go to North Carolina<br/>...</span></pre><p id="01bd" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">请注意，在最初的几行中，我们已经可以找到一个重复的输出<code class="fe oa ob oc mh b">There are 1 days left. We should not go to Georgia</code>。我所做的是将输出放入一个数组，然后计算有多少重复的输出。排序后的结果如下:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="eac7" class="ml mm jj mh b gy mn mo l mp mq">('There are 1 days left. We should not go to Georgia', 74),<br/>('There are 2 days left. We should not go to Georgia', 63),<br/>('There are 3 days left. We should go to Georgia', 51),<br/>('There are 1 days left. We should not go to North Carolina', 45),<br/>('There are 2 days left. We should not go to North Carolina', 41),<br/>('There are 4 days left. We should go to Georgia', 40),<br/>('There are 3 days left. We should not go to North Carolina', 35),<br/>('There are 4 days left. We should not go to North Carolina', 29),<br/>('There are 5 days left. We should go to Georgia', 28),<br/>('There are 1 days left. We should not go to Arizona', 24),<br/>('There are 2 days left. We should go to Arizona', 23),<br/>('There are 5 days left. We should not go to North Carolina', 22),<br/>('There are 3 days left. We should not go to Arizona', 21),<br/>('There are 6 days left. We should go to Georgia', 19),<br/>('There are 4 days left. We should not go to Arizona', 18),<br/>('There are 3 days left. We should not go to Florida', 16),<br/>('There are 6 days left. We should go to North Carolina', 16),<br/>('There are 2 days left. We should not go to Florida', 15),<br/>('There are 4 days left. We should not go to Florida', 15),<br/>('There are 5 days left. We should go to Arizona', 14),<br/>('There are 1 days left. We should not go to Florida', 13),<br/>('There are 5 days left. We should go to Florida', 13),<br/>('There are 7 days left. We should go to Georgia', 12),<br/>('There are 6 days left. We should not go to Arizona', 11),<br/>('There are 6 days left. We should not go to Florida', 11),<br/>('There are 7 days left. We should go to North Carolina', 11),<br/>...</span></pre><p id="80fc" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">请注意，更多的行被截断，但仍然非常明显的是，一些“子问题”重复了很多次。比如下面的子问题，被“计算”了74次。</p><blockquote class="ky kz la"><p id="4b25" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我们还有一天时间，我们应该/可以去乔治亚州吗？</p></blockquote><p id="8fee" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">幸运的是，我们只有11个摇摆州。如果将这类问题转移到另一个领域，我们可能会有数量巨大的节点。递归函数的缺点是重复计算子问题，这可能使问题在合理的硬件资源下无法解决。</p><h1 id="96f9" class="mr mm jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">动态规划解决方案</h1><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/20bd3ca0a7277cf1a06769d08eb3bc1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-P3aRpPMypNtOjoqEw4ZQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/stevepb-282134/" rel="noopener ugc nofollow" target="_blank">史蒂夫布</a>在<a class="ae jg" href="https://pixabay.com/photos/checkmate-chess-resignation-1511866/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="af1e" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">您可能已经意识到递归函数实际上是一种“自顶向下”的解决方案。相反，动态规划指的是以“自下而上”的结构解决问题的方式。它具有以下特点:</p><ul class=""><li id="314c" class="od oe jj le b lf lg li lj ly of lz og ma oh lx oi oj ok ol bi translated">要解决的问题必须分成子问题。</li><li id="e1ef" class="od oe jj le b lf om li on ly oo lz op ma oq lx oi oj ok ol bi translated">在自下而上的推理过程中，我们必须确保每一步(子问题)在给定的条件下都是全局最优的。</li></ul><p id="2848" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我们先来看看代码。</p><figure class="mc md me mf gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c72f" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">万一要点加载有问题，这里是明码。请将它复制粘贴到您的文本编辑器中，以便进行漂亮的缩进。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="d455" class="ml mm jj mh b gy mn mo l mp mq">def max_vote_dynamic_planning(states, total_days):<br/>    dp_matrix = [[0 for days_left in range(total_days + 1)] for index in range(len(states) + 1)]</span><span id="1127" class="ml mm jj mh b gy nz mo l mp mq">for index in range(1, len(states) + 1):<br/>        for days_left in range(1, total_days + 1):<br/>            if states[index-1]['days'] &lt;= days_left:  # If we have enough days left<br/>                votes_if_go = dp_matrix[index-1][days_left - states[index-1]['days']] + states[index-1]['votes']<br/>                votes_if_not_go = dp_matrix[index-1][days_left]<br/>                # Save the maximum votes into cache<br/>                dp_matrix[index][days_left] = max(votes_if_go, votes_if_not_go)<br/>            else:  # We don't have any days left<br/>                dp_matrix[index][days_left] = dp_matrix[index-1][days_left]<br/>    <br/>    return dp_matrix[-1][-1]</span><span id="1c29" class="ml mm jj mh b gy nz mo l mp mq">max_vote_dynamic_planning(states_dict, 10)</span></pre><p id="910c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">然后矩阵计算如下，我们能得到的最大选举人票就是最后一个值——56。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="073c" class="ml mm jj mh b gy mn mo l mp mq">[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],<br/> [0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],<br/> [0, 6, 11, 11, 11, 11, 11, 11, 11, 11, 11],<br/> [0, 6, 11, 16, 21, 21, 21, 21, 21, 21, 21],<br/> [0, 6, 11, 16, 21, 25, 25, 25, 25, 25, 25],<br/> [0, 6, 11, 16, 22, 27, 32, 37, 41, 41, 41],<br/> [0, 6, 11, 16, 22, 27, 32, 37, 42, 47, 52],<br/> [0, 6, 11, 16, 22, 27, 32, 37, 42, 47, 52],<br/> [0, 6, 11, 16, 22, 29, 35, 40, 45, 51, 56],<br/> [0, 6, 11, 17, 22, 29, 35, 40, 46, 51, 56],<br/> [0, 6, 11, 17, 22, 29, 35, 40, 46, 51, 56],<br/> [0, 6, 11, 17, 22, 29, 35, 40, 46, 51, 56]]</span></pre><p id="45dc" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在这里，想法如下:</p><ul class=""><li id="9589" class="od oe jj le b lf lg li lj ly of lz og ma oh lx oi oj ok ol bi translated">初始化一个二维矩阵，使用状态数作为行，天数作为列。</li><li id="b5bf" class="od oe jj le b lf om li on ly oo lz op ma oq lx oi oj ok ol bi translated">从第一个状态(索引= 1)开始，剩余天数为1。</li><li id="4e26" class="od oe jj le b lf om li on ly oo lz op ma oq lx oi oj ok ol bi translated">如果我们去目前的州，我们应该把这个州的选举人票和剩下的日子里我们能得到的最大票数加起来。剩余天数应该是当前剩余天数减去我们在当前状态下需要提升的天数。</li></ul><p id="48b0" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">对于这一点，让我们假设我们正在计算第二个州，内华达州，还有<strong class="le jk"> 2 </strong>天(见<code class="fe oa ob oc mh b">dp_matrix[2][2]</code>)。如果我们选择去内华达州，我们会得到<strong class="le jk"> 6 </strong>张选举人票，但我们会用1天时间来得到它们。所以，我们还有1天时间。因为我们还剩1天，我们可以从前一个州缅因州得到的最多票数是<strong class="le jk"> 5 </strong>。因此，该步骤的优化结果是<strong class="le jk"> 11 </strong>票。</p><ul class=""><li id="ee39" class="od oe jj le b lf lg li lj ly of lz og ma oh lx oi oj ok ol bi translated">如果我们选择不去当前状态，那么我们应该只使用我们已经为先前状态优化的最大票数。</li></ul><p id="0006" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">你迷惑了吗？:)我举个例子，动态规划是怎么知道什么时候不应该去状态的。</p><p id="ebbc" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">假设我们正在计算明尼苏达州，还有<strong class="le jk"> 2 </strong>天(<code class="fe oa ob oc mh b">dp_matrix[3][2]</code>)。如果我们选择去明尼苏达州，我们会得到<strong class="le jk">10</strong>16】张选票。然而，在那之后，我们还剩下<strong class="le jk">2–2 = 0</strong>天。另一方面，如果我们选择不去明尼苏达州，我们还有<strong class="le jk"> 2 </strong>天，我们可以从前两个州获得的最高票数是<strong class="le jk"> 11 </strong>。</p><p id="0b53" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">因此，随着for循环的进行，对于每一个单独的循环，我们可以确保它是到目前为止优化的。这也是为什么你可以看到矩阵是水平和垂直排序的。因此，全局优化数应该在右下角，即56。</p><h1 id="1539" class="mr mm jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">简单的比较</h1><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e92b7d8e5d30e58fdc985a9f5c4228ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FotRIFKp7_cxf5eN6C5lzA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/free-photos-242387/" rel="noopener ugc nofollow" target="_blank">在<a class="ae jg" href="https://pixabay.com/photos/highway-drive-driving-road-travel-1209547/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的免费照片</a>拍摄的照片</p></figure><p id="a83e" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我不应该只谈论动态规划有多有效。让我展示一些证据。</p><p id="273e" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这是递归函数的运行时间。</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/3c734defae2a67716ed646c489253f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*wU-ETl3S0sFEmw1K_CcO3g.png"/></div></figure><p id="a54f" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这是一个动态规划解决方案。</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/432e05f309684b3f5199a73be980a6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*9X67Q0OBTyTgBqZtnQ4-jA.png"/></div></figure><p id="0a0b" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在这种特殊情况下，动态规划大约快10倍。如果我们有更多的节点和可能性的问题，差异将是巨大的。</p><h1 id="be46" class="mr mm jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">摘要</h1><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9f1eec97b098be7a22a3e2628acfe990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jhPlF9tLqYBTsQqAnyBAQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/cocoparisienne-127419/" rel="noopener ugc nofollow" target="_blank"> cocoparisienne </a>在<a class="ae jg" href="https://pixabay.com/photos/texture-handwriting-s%C3%BCtterlin-1362879/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="c994" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在这篇文章中，我提出了一个在有限的几天内优化选举宣传的问题。我们可以很轻松的用递归函数解决问题，但是事实证明效率不高，因为有太多的子问题被计算了多次。</p><p id="e99a" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">不是使用“自上而下”的方法(递归)，而是使用“自下而上”的方法解决问题的动态规划。它从最小的子问题开始，并确保每一步都在当前条件下给出优化结果，因此下一步将建立在当前步骤的基础上。因此，它没有重复计算，算法复杂度小得多。</p><p id="a264" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在给定的问题中，表明动态规划解比递归函数解快10倍。</p><h1 id="7987" class="mr mm jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">一个小笑话</h1><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a912cdbda51082492e344a7366937f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFBF2aAPS9nFSDxkxf_pNg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/www_slon_pics-5203613/" rel="noopener ugc nofollow" target="_blank"> www_slon_pics </a>在<a class="ae jg" href="https://pixabay.com/photos/darth-trump-darth-vader-vader-3830731/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="7d06" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">当你告诉特朗普我们可以用10天时间拿到56张选举人票的时候，他好像挺开心的。</p><blockquote class="ky kz la"><p id="c235" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">他问你:“好。那么，我们的行程是什么？哪些是我们应该去的州。”</p><p id="d0cd" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你:“嗯，我暂时没有那个信息。让我调整一下我的代码……”</p><p id="7311" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">特朗普:“不，让我来。相信我。没有人比我更了解Python！”</p></blockquote><p id="6662" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi">:)</p><div class="is it gp gr iu ot"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd jk gy z fp oy fr fs oz fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ja ot"/></div></div></a></div><p id="948c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><strong class="le jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p></div></div>    
</body>
</html>