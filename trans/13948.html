<html>
<head>
<title>Deploy Angular Apps to Firebase From GitHub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从GitHub向Firebase部署Angular应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-angular-apps-to-firebase-from-github-5f5ef0aad396?source=collection_archive---------27-----------------------#2020-09-25">https://towardsdatascience.com/deploy-angular-apps-to-firebase-from-github-5f5ef0aad396?source=collection_archive---------27-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="459b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何为自动化部署创建简单的CI/CD管道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/411d21ac99e32d7401c978e26b4a5daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PEJWGzRj_QBUgenT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@vadimsadovski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vadim Sadovski </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">持续集成、持续交付或CI/CD。这是开发人员的一个行话，而且有充分的理由。CI/CD管道允许我们自动化大部分代码部署过程，使其在过程中更快更安全。</p><p id="4f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CI部分包括构建、打包和测试我们的应用程序的自动化。在大多数情况下，这是由Angular自动完成的。而且，一旦我们编写了单元测试，它们也很容易集成到过程中。</p><p id="8980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是CD，我们应用程序的自动交付。在我们的例子中，这是对Firebase的部署。</p><p id="a521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用GitHub操作来自动化CI/CD管道。这意味着每次我们点击<code class="fe lv lw lx ly b">git push origin master</code>时，GitHub会自动启动一个完整的构建、打包、(测试)和部署过程。我们将涵盖:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a202" class="md me it ly b gy mf mg l mh mi">&gt; Deployment Setup<br/>  - Writing Our Deployment (YAML)<br/>  - Secret Keys (With GitHub)</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6034" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">部署设置</h1><p id="5c6e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">首先，我们假设Angular应用程序已经通过常规的<code class="fe lv lw lx ly b">firebase deploy</code>部署到Firebase主机上——如果你还没有这样做，请遵循<a class="ae ky" href="https://firebase.google.com/docs/hosting/quickstart" rel="noopener ugc nofollow" target="_blank">这个指南</a>。不会超过几分钟！</p><p id="7e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们准备好了，我们开始在项目的根目录下创建一个<code class="fe lv lw lx ly b">.github</code>文件夹。在那里，我们添加了另一个名为<code class="fe lv lw lx ly b">workflows</code>的文件夹，里面有一个名为<code class="fe lv lw lx ly b">main.yml</code>的YAML文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/f0292f8ff69a36e370a5b23b4cac81d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jyxhgYuFxKvbRIhXblPNQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Github Actions(相当于。github \我们项目目录中的工作流)。图片作者。</p></figure><p id="338f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当目录<code class="fe lv lw lx ly b">.github\workflows</code>被推送到GitHub时，它将被GitHub读取并用作GitHub Actions文件夹——我们为工作流存储YAML文件的地方！</p><p id="99f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是什么是YAML文件呢？嗯，根据我们亲爱的<a class="ae ky" href="https://en.wikipedia.org/wiki/YAML" rel="noopener ugc nofollow" target="_blank">维基百科</a> —</p><blockquote class="nn"><p id="8579" class="no np it bd nq nr ns nt nu nv nw lu dk translated">“YAML是一种人类可读的数据序列化语言。它通常用于配置文件和存储或传输数据的应用程序中。</p></blockquote><p id="f5a6" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">第一句话的意思是YAML是一种我们可以阅读的文件格式！它用于在不同语言或环境之间传输数据(JSON是另一个例子)。</p><p id="5f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二部分是我们需要了解的。这意味着YAML是一种提供指令的标准化方式，通常用于配置文件——就像我们的部署配置一样！</p><h2 id="215a" class="md me it bd mr oc od dn mv oe of dp mz li og oh nb lm oi oj nd lq ok ol nf om bi translated">编写我们的部署</h2><p id="9e7b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">好的，让我们来看看我们将要使用的YAML文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d43f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然它看起来很混乱，但是一旦我们将脚本分解成几个部分，它就会变得非常简单。</p><ul class=""><li id="bcba" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated">简单来说就是给代码的不同部分命名(这是可选的！).</li><li id="4aff" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><code class="fe lv lw lx ly b">on: push: branches: - master</code>，这是我们的触发器。它告诉GitHub，一旦我们<code class="fe lv lw lx ly b">push</code>到<code class="fe lv lw lx ly b">master branch</code>，就触发下面的代码。</li><li id="c6a8" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">接下来，我们在<code class="fe lv lw lx ly b">jobs</code>有我们的执行计划，包括一个<code class="fe lv lw lx ly b">build</code>阶段。</li><li id="1a79" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">我们在最新的Ubuntu机器<code class="fe lv lw lx ly b">ubuntu-latest</code>上执行一切。</li><li id="6986" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">现在我们执行计划中的每一个<code class="fe lv lw lx ly b">steps</code>。</li><li id="547f" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">我们通过<code class="fe lv lw lx ly b">actions/checkout@master</code>将我们的活动分支设置为<code class="fe lv lw lx ly b">master</code>。</li><li id="9707" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">然后用<code class="fe lv lw lx ly b">actions/setup-node@master</code>初始化节点，这样我们就可以在下面的步骤中使用<code class="fe lv lw lx ly b">npm</code>。</li><li id="946e" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><code class="fe lv lw lx ly b">npm install</code>添加了我们所有的应用依赖项，如下所示:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/427194876f45d71754d07b83b5f4e15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYF9tm1gQob0-v0ALTER3g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd pe">在GitHub动作中安装依赖项</strong>部署阶段。</p></figure><ul class=""><li id="0873" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated">之后，我们用<code class="fe lv lw lx ly b">npm run build</code>编译我们的应用程序——它被翻译成<code class="fe lv lw lx ly b">ng build</code>:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/c26bb6f65865892c75240458cd05708e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktD4R6xnKfkBdkWNf4owbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd pe">GitHub操作中部署的构建阶段</strong>。</p></figure><ul class=""><li id="8e8d" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated">最后，我们使用<code class="fe lv lw lx ly b">w9jds/firebase-action@master</code>部署我们新构建的应用程序，其中有两个额外的参数:</li><li id="6e36" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">我们传递了<code class="fe lv lw lx ly b">deploy --only hosting</code>参数，这意味着我们只部署到Firebase主机(而不是函数，例如)。</li><li id="9159" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">我们通过存储在repo中的<code class="fe lv lw lx ly b">FIREBASE_TOKEN</code>密钥传递我们的Firebase安全令牌(对我们进行身份验证)(我们将在接下来讨论这一点)。</li></ul><p id="2cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这涵盖了我们的YAML中的所有内容，只不过是我们在部署应用程序时通常会执行的操作——除了指定操作系统！</p><h2 id="3795" class="md me it bd mr oc od dn mv oe of dp mz li og oh nb lm oi oj nd lq ok ol nf om bi translated">秘密钥匙</h2><p id="eeea" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">唯一缺少的部分就是我们的<code class="fe lv lw lx ly b">FIREBASE_TOKEN</code>。让我们解决这个问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/07fa071f57a90394865625a91c0eabc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lC9_uqXT63D90O5I7eSH1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何使用Firebase CLI获取我们的Firebase令牌。图片作者。</p></figure><p id="251a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要获得我们的访问令牌，为此我们只需:</p><p id="2e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ph translated"><span class="l pi pj pk bm pl pm pn po pp di"> 1。</span>打开我们的CLI并导航到我们的项目——通过键入<code class="fe lv lw lx ly b">firebase use [project-id]</code>(上面未显示)确保正确的Firebase项目处于活动状态。</p><p id="f89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ph translated"><span class="l pi pj pk bm pl pm pn po pp di"> 2。</span>使用<code class="fe lv lw lx ly b">firebase login:ci</code>请求我们的CI(持续集成)访问令牌，这将打开一个新窗口(否则，输入提供的URL)。</p><p id="0814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ph translated"><span class="l pi pj pk bm pl pm pn po pp di"> 3。</span>在授权窗口中，我们需要登录Google Cloud并授权访问我们的帐户。</p><p id="04d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ph translated"><span class="l pi pj pk bm pl pm pn po pp di"> 4。</span>最后，我们收到了一个访问令牌，我们可以使用它将我们的应用程序部署到Firebase！</p><p id="c288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了令牌，我们需要导航到GitHub上的项目repo在这里我们可以添加访问令牌。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/ed08a25a77a1e8d75a15ecb424ecd4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69SQ1iyjUecRvoPiBGsVig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将Firebase令牌添加到项目repo的步骤。图片作者。</p></figure><p id="a0e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，在项目回购中，我们:</p><p id="ff91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ph translated"><span class="l pi pj pk bm pl pm pn po pp di"> 1 </span> /3。从<strong class="lb iu">设置</strong> &gt; <strong class="lb iu">机密</strong>中导航并点击<strong class="lb iu">新机密</strong>。打开新的秘密窗口。</p><p id="d7e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ph translated"><span class="l pi pj pk bm pl pm pn po pp di"> 4 </span> /6。输入<code class="fe lv lw lx ly b">FIREBASE_TOKEN</code>作为秘密名称，输入<code class="fe lv lw lx ly b">login firebase:ci</code>提供的令牌，点击<strong class="lb iu">添加秘密</strong>！</p><p id="57c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，回到我们的YAML文件中，<code class="fe lv lw lx ly b">${{ secrets.FIREBASE_TOKEN }}</code>允许我们访问刚刚为<code class="fe lv lw lx ly b">FIREBASE_TOKEN</code>输入的值，而不需要将它存储在我们的回购文件中。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2729" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">部署！</h1><p id="720e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">一旦我们设置好了一切，我们就像往常一样将项目推送到GitHub repo的主分支。回到我们的CLI，我们输入如下内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4e78" class="md me it ly b gy mf mg l mh mi">git add .<br/>git commit -m "Added CI support"<br/>git push -u origin master</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/41227cef3c8a2ea60dfe122a8d89e3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwuURkSez574idq7KnDidg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<strong class="bd pe"> git推送origin master </strong>之后，我们的Angular应用程序被部署到Firebase。</p></figure><p id="3dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的回购照常推送到GitHub。要查看我们的部署，我们需要在GitHub中打开我们的repo并点击<strong class="lb iu"> Actions </strong>选项卡。我们将看到“所有工作流程”窗口(如上)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/4c1d2e4b10e32670b0e63f32f71eb119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxLpNebbZzWmZ8m9rgBKlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部署进度。</p></figure><p id="c02a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想更详细地查看我们的部署进度，我们单击我们的部署(在这里我们可以看到我们的提交消息)，在侧栏中，单击<strong class="lb iu">构建和部署</strong>。在这里，我们将能够看到我们的部署正在采取的行动列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/07a5e6cdad0c875cebf732450585e9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tT9dZZGjIxB71CJPU0ITNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部署完成！</p></figure><p id="8688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们的部署完成，我们将在右上角看到一个绿色的勾号！我们可以通过点击<strong class="lb iu">构建和部署</strong>窗口中每个部署阶段旁边的下拉箭头来查看部署的更多细节。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7c00" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">最后几个音符</h1><h2 id="f65f" class="md me it bd mr oc od dn mv oe of dp mz li og oh nb lm oi oj nd lq ok ol nf om bi translated">部署生产版本</h2><p id="294e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">目前，我们没有部署角度优化的生产构建。就像我们对<code class="fe lv lw lx ly b">ng build</code>所做的一样——我们将<code class="fe lv lw lx ly b">--prod</code>添加到<code class="fe lv lw lx ly b">npm run build</code>以切换到生产版本。</p><p id="f5ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的YAML文件，我们修改<code class="fe lv lw lx ly b">Build</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b585" class="md me it ly b gy mf mg l mh mi">- name: Build<br/>  uses: npm run build <strong class="ly iu">--prod</strong></span></pre><h2 id="be24" class="md me it bd mr oc od dn mv oe of dp mz li og oh nb lm oi oj nd lq ok ol nf om bi translated">集成测试</h2><p id="68bc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们也可以合并我们的角度单元测试！就在<code class="fe lv lw lx ly b">— name: Install Dependencies</code>之后，我们添加<code class="fe lv lw lx ly b">npm test</code>，就像这样:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="56fc" class="md me it ly b gy mf mg l mh mi">- name: Install Dependencies<br/>        run: npm install<br/><strong class="ly iu">      - name: Testing<br/>        run: npm test</strong><br/>      - name: Build<br/>        run: npm run build</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2314" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">包扎</h1><p id="c0c4" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们结束了，我们已经谈了很多了！包括:</p><ul class=""><li id="65e9" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated">YAML脚本，以及如何编写一个将Angular应用程序部署到Firebase的脚本。</li><li id="208c" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">从Firebase CLI获取我们的<code class="fe lv lw lx ly b">FIREBASE_TOKEN</code>,并将其作为密钥添加到我们的GitHub repo中。</li><li id="6f7f" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated">在GitHub中部署我们的应用程序并查看部署状态！</li><li id="d1bd" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><em class="pt">以及一些关于产品构建和单元测试的额外注释。</em></li></ul><p id="d212" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们建立了一个完全自动化的CI/CD管道——只要我们在GitHub中推送master就会触发！</p><p id="0f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。如果您有任何问题、想法或建议，请随时通过<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或在下面的评论中联系我们！</p><p id="ea62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>