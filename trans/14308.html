<html>
<head>
<title>Collatz — The Simplest Program That You Don’t Fully Understand</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">collatz——你不完全理解的最简单的程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/collatz-the-simplest-program-that-you-dont-fully-understand-30b223c6fd8c?source=collection_archive---------32-----------------------#2020-10-02">https://towardsdatascience.com/collatz-the-simplest-program-that-you-dont-fully-understand-30b223c6fd8c?source=collection_archive---------32-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e859" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Wolfram语言进行计算探索</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/96fb72222e4a20b2c90016f611475b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chzeIszudlOkUVyRZQp74w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">大约10分钟后，一个人看着Collatz程序的照片，由<a class="ae kv" href="https://unsplash.com/s/photos/problem?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@officestock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sebastian Herrmann </a>拍摄</p></figure><p id="7a9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢认为自己无所不知，尤其是在编程方面。而且，很长一段时间以来，我认为如果我观察一段代码足够长的时间，我就能够完全理解它的行为。只需逐行阅读代码，并仔细考虑if语句和for循环的可能情况。只要有足够的时间和耐心，所有代码都是完全可以理解的。</p><p id="9d79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我写的代码并没有像预期的那样运行。事实上，这种情况发生了很多。通常情况下，我写一段新代码的前十次尝试中，有九次都是谦逊编码的经历。但是，我仍然把这归因于输入错误、编写不完整的代码，以及在输入实际代码之前不耐烦和没有充分考虑事情。</p><p id="3922" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一天，有人向我展示了一段实现了Collatz算法的<a class="ae kv" href="https://www.wolfram.com/language/" rel="noopener ugc nofollow" target="_blank"> Wolfram语言</a>代码，这一切都改变了。这个想法非常简单:编写一个接受正整数作为唯一参数的函数。如果数字是1，就完成了，从函数中返回1。如果数字大于1，则有两个分支:如果数字是偶数，则除以2并返回该数字。如果数字是奇数，则返回该数字的三倍加1。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1d39" class="lx ly iq lt b gy lz ma l mb mc">collatz[1] = 1<br/>collatz[n_Integer /; n&gt;1 ] := If[ EvenQ[n], n/2, 3n+1 ]</span></pre><p id="3163" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切顺利。你可以用不同的整数试一下，一切都很好:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1c4b" class="lx ly iq lt b gy lz ma l mb mc">collatz[5] --&gt; 16<br/>collatz[8] --&gt; 4</span></pre><p id="4e2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当你写一个程序来计算下面的序列时，曲线球就出现了:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="275c" class="lx ly iq lt b gy lz ma l mb mc">collatz[16] --&gt; 8<br/>collatz[8] --&gt; 4<br/>collatz[4] --&gt; 2<br/>collatz[1] --&gt; 1 (* done! *)</span></pre><p id="df0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Wolfram语言中实现这一点的一个简单方法是使用<a class="ae kv" href="https://reference.wolfram.com/language/ref/NestWhileList.html" rel="noopener ugc nofollow" target="_blank"> NestWhileList </a>:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="472a" class="lx ly iq lt b gy lz ma l mb mc">collatzSequence[n_Integer /; n &gt; 0] := <br/> NestWhileList[collatz, n, # != 1 &amp;]</span></pre><p id="ff75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">n=16的例子给出:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e1d0" class="lx ly iq lt b gy lz ma l mb mc">collatzSequence[16] --&gt; {16, 8, 4, 2, 1}</span></pre><p id="8f0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来很简单，但是有一个小问题:当你遇到一个奇数的时候，下一个数字将会大三倍(加一)。下一个数字也将是偶数，这意味着之后的数字将再次减半。这里有一个例子，当你从一个奇数开始:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="a2c7" class="lx ly iq lt b gy lz ma l mb mc">collatzSequence[17] --&gt; {17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1}</span></pre><p id="7936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数字序列首先上升到52，但随后又迅速回落到1。显然，这最终会发生在每一个数字上？不幸的是，我们不得不考虑这样一种可能性，即有些数字产生的序列永远不会达到1。例如，可能有一个序列，其中的数字随着时间的推移慢慢反弹，变得越来越大。阅读代码在这里没有太大帮助。下面是一个起始数的示例，其中序列不会快速变为1:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1382" class="lx ly iq lt b gy lz ma l mb mc">collatzSequence[63728127]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi md"><img src="../Images/5d0fb85485368ba11f830daf5c1c90cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWbhRfgAj1Gi52-cAmApqw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="6aad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是这个数列的图表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/37e42586bb694100e5514539508e8de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97qBGTQqcmyw9TM3B5m0VQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="2423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管我们可以阅读代码并理解任何数字的每一步会发生什么，但我们无法知道程序是否会终止(甚至不知道给定数字的序列长度)。仔细研究过这个问题的人推测(但没有证明)每个数字都有一个以1结尾的序列。这个猜想被称为<a class="ae kv" href="https://en.wikipedia.org/wiki/Collatz_conjecture" rel="noopener ugc nofollow" target="_blank">科勒兹猜想</a>以第一个提出这个问题的<a class="ae kv" href="https://en.wikipedia.org/wiki/Lothar_Collatz" rel="noopener ugc nofollow" target="_blank">洛萨科勒兹</a>命名。</p><p id="9ef9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个问题，人们已经有了很多有趣的发现和可视化，而没有实际解决猜想本身。<a class="ae kv" href="https://community.wolfram.com/groups/-/m/t/558256" rel="noopener ugc nofollow" target="_blank">一个非常有趣的视觉效果</a>是一个由许多起点以及这些序列如何最终相遇并融合在一起的图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/4784596648fa152723143d5d5a634c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeV3cHsWjIgq2tAjagBIUw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="fead" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者<a class="ae kv" href="https://mathematica.stackexchange.com/questions/85718/trying-to-visualize-the-collatz-conjecture" rel="noopener ugc nofollow" target="_blank">一个更简单的图形</a>显示不同的Collatz序列如何合并并最终在数字1处相遇:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/eb38ae09c3508855591e940835e6d22a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExNg4VuSveP2cL0TQthoog.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="6c53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我得到的教训是，即使是最简单的程序也不一定能理解。因此，当我看到一个文档记录很差的巨大的源代码文件时，我也不会感觉很糟糕。在许多情况下，你所能做的最好的事情就是运行一个有许多不同输入的程序来开发直觉和推测，并使用它来迭代你的代码到一个点，在这个点上它的行为大部分是你所期望的。也许有一天，有人会为Collatz序列找到一个不以零结尾的起始数。但我觉得这就是那种可能永远解不开的编程难题！</p></div></div>    
</body>
</html>