<html>
<head>
<title>Compact prediction tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">紧凑预测树</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/compact-prediction-tree-af8d23b6b9a0?source=collection_archive---------22-----------------------#2020-10-29">https://towardsdatascience.com/compact-prediction-tree-af8d23b6b9a0?source=collection_archive---------22-----------------------#2020-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="dc3f" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""/><div class=""><h2 id="2959" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated"><strong class="ak">有限字母表上精确序列预测的无损模型</strong></h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b9bd3213b1493f944fcf9b8d75477b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJ9wm6hstM8sSFAXfa76ug.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=683437" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae le" href="https://pixabay.com/users/photoshopper24-81349/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=683437" rel="noopener ugc nofollow" target="_blank"> Bela Geletneky </a></p></figure><h1 id="9b40" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated"><strong class="ak">什么是序列预测问题？</strong></h1><p id="883e" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">序列预测问题包括仅通过查看序列的项目来查找有序序列的下一个元素。</p><p id="b21d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这个问题涵盖了各种领域中的许多应用。它包括产品推荐、预测和网页预取等应用程序。</p><p id="7ed7" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">许多不同的方法被用来解决这个问题，流行的方法包括PPM(部分匹配预测)，马尔可夫链，以及最近的LSTM(长短期记忆)。</p><p id="0f47" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">紧凑预测树(CPT)是2015年发布的一种方法，旨在通过对整个训练集进行无损压缩来匹配精度并超越流行算法的性能(训练和预测的时间)。<br/>我们现在将详细介绍训练和预测的方法，以及这种方法的优缺点。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="c4b1" class="lf lg iq bd lh li nf lk ll lm ng lo lp kf nh kg lr ki ni kj lt kl nj km lv lw bi translated">紧凑预测树定义</h1><p id="77fe" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在进入如何使用它进行预测的细节之前，让我们描述一下组成紧凑预测树(CPT)的不同元素:</p><ul class=""><li id="4377" class="nk nl iq lz b ma mt md mu mg nm mk nn mo no ms np nq nr ns bi translated">一个<em class="nt"> trie </em>，用于序列的有效存储。</li><li id="539c" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">一个<em class="nt">倒排索引</em>，用于恒定时间检索包含某个单词的序列。</li><li id="9cc2" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">一个<em class="nt">查找表</em>，用于从序列Id中检索序列。</li></ul><h2 id="92b1" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated"><strong class="ak">特里</strong></h2><p id="25b8" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">trie通常称为前缀树，是一种基于有序树的数据结构，用于存储序列(如字符串)。序列的元素存储在边中，因此给定节点的每个后代都有相同的前缀。</p><p id="decd" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在这个众所周知的例子中，我们希望存储<code class="fe ok ol om on b">["tea", "ten", "inn"]</code>。我们先把“茶”放在空树上。这棵树的每一根树枝对应一个字母。然后我们添加“ten”:因为“tea”和“ten”共享同一个“te”前缀，所以我们只是在“te”前缀之后创建一个新的分支。最后，我们将“inn”添加到与前两个序列没有共同前缀的树中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8b32a2edac768b0cc476445e733283f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*HqQCfxuyYHS62hg5VqvMKA.png"/></div></figure><p id="43b3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">Trie通常用于获取，对每个以前缀开头的单词进行树搜索。在我们的例子中，我们使用它来压缩和有效地存储我们的训练集。</p><h2 id="0077" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated"><strong class="ak">倒排索引</strong></h2><p id="5b80" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">倒排索引是用于存储从元素到其位置的映射的索引。这里我们用它来存储从序列元素到序列id的映射。</p><p id="68d8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">再次考虑我们之前的示例，我们注意到“T”出现在序列0和1中，“E”出现在序列0和1中，“A”出现在序列0中，“N”出现在序列1和2中，而“I”仅出现在序列2中。<br/>因此，我们有以下反向索引:</p><pre class="kp kq kr ks gt op on oq or aw os bi"><span id="8bb5" class="nz lg iq on b gy ot ou l ov ow">{<br/>  "T": [0, 1],<br/>  "E": [0, 1],<br/>  "A": [0],<br/>  "N": [1, 2],<br/>  "I": [2]<br/>}</span></pre><p id="5324" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">为了提高效率，我们将使用位集来存储倒排索引(这也有助于高效地找到“相似序列”)。</p><h2 id="d849" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated"><strong class="ak">查找表</strong></h2><p id="651b" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">查找表是一种数据结构(通常是一个数组),用于存储每个序列的最后一个节点(叶)的指针。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/7d16224aed675e4e65623289c30fa6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*FPZ33oSxT84x-vns1rtSWw.png"/></div></figure><p id="6b32" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">这种数据结构对于迭代给定序列的元素来说是必不可少的。<br/>例如，如果我们想要检索id为0的序列，我们可以简单地迭代它的父序列。在我们的例子中，id 0序列的叶的父代与“A”链接，然后与“E”链接，最后与“T”链接。这倒过来给了我们第一个序列:“茶”。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="2da7" class="lf lg iq bd lh li nf lk ll lm ng lo lp kf nh kg lr ki ni kj lt kl nj km lv lw bi translated">紧凑预测树使用</h1><h2 id="a9a3" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated"><strong class="ak">训练</strong></h2><p id="7d35" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">训练时间与训练集中的序列数成线性关系。<br/>对于每个训练序列，我们需要执行3个步骤:</p><ul class=""><li id="c168" class="nk nl iq lz b ma mt md mu mg nm mk nn mo no ms np nq nr ns bi translated">在trie中插入序列。</li><li id="fc01" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">添加倒排索引中的元素。</li><li id="c90c" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">添加查找表中最后一个节点的位置。</li></ul><p id="eeaf" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">一张图胜过千言万语，这里是一个经过充分训练的紧凑预测树一步一步来。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/a5c57e4e214ba080d99452ee2a73db47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ud5nfsupoYcEsFMb9Dfiyg.png"/></div></div></figure><h2 id="278b" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated"><strong class="ak">预测</strong></h2><p id="9286" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">为了预测序列S，我们需要做这三个步骤:</p><ul class=""><li id="2bb4" class="nk nl iq lz b ma mt md mu mg nm mk nn mo no ms np nq nr ns bi translated">寻找相似序列(包含S的每个元素的序列)。</li><li id="87c9" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">计算每个相似序列的后续序列(从与S相同的最后一项之后开始的子序列)。</li><li id="3bcf" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">计算每个元素在所有后续序列中的出现次数。</li></ul><p id="e685" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">对于这一部分，让我们举一个稍微复杂一点的例子，我们的模型在<code class="fe ok ol om on b">["ABC", "ABD", "BC", "BAC"]</code>进行训练。我们应该将算法训练成:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/743882b54db48de196cab014123f0732.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*-U6W4m0smejK1rieEbZSIA.png"/></div></figure><p id="0c84" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们试着预测一下<code class="fe ok ol om on b">"AB"</code>之后会发生什么。</p><p id="47a2" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">首先，让我们计算相似的序列。<br/>与S相似的序列是包含S中任意顺序、任意位置的每一项的序列。为了计算相似的序列，我们可以简单地使用我们的倒排索引并计算交集。对于我们的例子，我们需要相交<code class="fe ok ol om on b">[0, 1, 3]</code>(A出现的序列的id)和<code class="fe ok ol om on b">[0, 1, 2, 3]</code>(B出现的位置)。这就给了<code class="fe ok ol om on b">[0, 1, 3]</code>。</p><p id="cc27" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">然后，我们需要计算<code class="fe ok ol om on b">consequent sequences</code>。<br/>序列Y相对于序列S的后件是从与S相同的最后一项之后开始直到Y结束的Y的子序列。<br/>我们例子的后件序列应该是<code class="fe ok ol om on b">"C"</code>、<code class="fe ok ol om on b">"D"</code>和<code class="fe ok ol om on b">"C"</code>。(对于我们相对于<code class="fe ok ol om on b">"AB"</code>的序列0、1和3)。</p><p id="18d4" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">最后，我们简单地计算每个元素在所有后续序列中出现的次数，并预测出现次数最多的字母。<br/>在我们的例子中是<code class="fe ok ol om on b">"C"</code> (2次出现)。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="67f6" class="lf lg iq bd lh li nf lk ll lm ng lo lp kf nh kg lr ki ni kj lt kl nj km lv lw bi translated">紧凑预测树性能</h1><h2 id="390f" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated"><strong class="ak">测试框架</strong></h2><p id="3d91" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">简而言之，作者用几种算法(包括CPT、依赖图、类马尔可夫算法……)在几个<a class="ae le" href="http://www.philippe-fournier-viger.com/spmf/index.php?link=datasets.php" rel="noopener ugc nofollow" target="_blank">公共数据集</a>上预测了下一个元素。<br/>要看结果(要慎用)，建议你看一下原论文，<a class="ae le" href="https://www.philippe-fournier-viger.com/spmf/ADMA2013_Compact_Prediction_tree" rel="noopener ugc nofollow" target="_blank"> <em class="nt">紧凑预测树:精确序列预测的无损模型</em> </a> <em class="nt">。</em></p><p id="3189" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">另一篇论文，<a class="ae le" href="https://dspace.library.uu.nl/bitstream/handle/1874/327511/thesis-jelte-hoekstra-20150121.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="nt">从智能卡数据预测火车行程:序列预测问题的现实应用</em> </a> <em class="nt">，</em>展示了解决序列预测问题的步骤。从字母表的构建到模型的选择。在这篇论文中，Hoekstra博士将CPT与PPM和AKOM等不同方法进行了比较。根据您的需要，它还显示CPT可以是一个具有相对较好准确性的相关解决方案。</p><h2 id="125e" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated"><strong class="ak">利弊</strong></h2><p id="8289" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">紧凑预测树的优点是:</p><ul class=""><li id="eeb4" class="nk nl iq lz b ma mt md mu mg nm mk nn mo no ms np nq nr ns bi translated">CPT是一种无损存储来自训练集的所有数据的算法。</li><li id="aef4" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">该算法是高度可解释的(容易追溯相似序列，后续序列…)</li><li id="6c17" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">快速预测。一些基准可以在原论文或者<a class="ae le" href="https://github.com/bluesheeptoken/CPT/tree/master/benchmark" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li></ul><p id="cbe0" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">紧凑预测树的缺点是:</p><ul class=""><li id="c3b3" class="nk nl iq lz b ma mt md mu mg nm mk nn mo no ms np nq nr ns bi translated">CPT忽略序列中的顺序，因此CPT倾向于预测最频繁出现的项目。(如果您准备好了考虑顺序的稍微慢一点的预测。我建议你去看看由一个共同作者开发的<a class="ae le" href="https://github.com/bluesheeptoken/subseq" rel="noopener ugc nofollow" target="_blank">子序列</a>算法。)</li><li id="c131" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated">CPT对噪音相当敏感。如果一个新元素在要预测的序列中，CPT将无法找到任何相似的序列。CPT+已经解决了这个问题，您可以在“更进一步”一节中找到详细信息。</li></ul></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="12df" class="lf lg iq bd lh li nf lk ll lm ng lo lp kf nh kg lr ki ni kj lt kl nj km lv lw bi translated">走得更远</h1><h2 id="42c9" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated">Python示例</h2><p id="22d6" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">对于这个小例子，我们将使用<a class="ae le" href="https://github.com/bluesheeptoken/CPT" rel="noopener ugc nofollow" target="_blank">这个</a>实现。在合著者之一的<a class="ae le" href="http://www.philippe-fournier-viger.com/publications.php" rel="noopener ugc nofollow" target="_blank">官网</a>上引用为CPT的实现。还包括了降噪等CPT+的一些特性。</p><pre class="kp kq kr ks gt op on oq or aw os bi"><span id="253d" class="nz lg iq on b gy ot ou l ov ow">from cpt.cpt import Cpt</span><span id="1bd1" class="nz lg iq on b gy oz ou l ov ow">model = Cpt()</span><span id="be4c" class="nz lg iq on b gy oz ou l ov ow"># training<br/>model.fit([['hello', 'world'],<br/>           ['hello', 'this', 'is', 'me'],<br/>           ['hello', 'me']<br/>          ])</span><span id="a187" class="nz lg iq on b gy oz ou l ov ow"># predictions<br/>model.predict([['hello'], ['hello', 'this']])</span><span id="7f2e" class="nz lg iq on b gy oz ou l ov ow"># Output: ['me', 'is']</span></pre><p id="dd65" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">有关<code class="fe ok ol om on b">predict</code>方法的参数或超参数的更多信息，您可以查看<a class="ae le" href="https://cpt.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h2 id="71ff" class="nz lg iq bd lh oa ob dn ll oc od dp lp mg oe of lr mk og oh lt mo oi oj lv iw bi translated">进一步阅读</h2><p id="ed59" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">如果你对这个主题感兴趣，我强烈建议你阅读以下论文:</p><ul class=""><li id="cf13" class="nk nl iq lz b ma mt md mu mg nm mk nn mo no ms np nq nr ns bi translated"><a class="ae le" href="https://www.philippe-fournier-viger.com/spmf/PAKDD2015_Compact_Prediction_tree+.pdf" rel="noopener ugc nofollow" target="_blank"><em class="nt">【CPT+】:降低紧凑预测树的时间/空间复杂度</em> </a> <em class="nt"> </em>这增加了噪声降低技术和训练集策略的两次压缩。</li><li id="bfdb" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated"><a class="ae le" href="https://pdfs.semanticscholar.org/5792/01b89b39715cf3b6ea4ecd54ead13d3aef69.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="nt">基于序列预测和Pagerank算法改进网页访问预测</em> </a> <em class="nt"> <br/> </em>本文的思路是增加一个Pagerank算法，只在相关序列上训练CPT。总体上有很好的改善。</li><li id="be22" class="nk nl iq lz b ma nu md nv mg nw mk nx mo ny ms np nq nr ns bi translated"><a class="ae le" href="https://www.researchgate.net/publication/335231805_Succinct_BWT-Based_Sequence_Prediction" rel="noopener ugc nofollow" target="_blank"> <em class="nt">简洁的基于BWT的序列预测(subseq)</em></a><em class="nt"/><br/>CPT的合著者之一开发的算法。这种算法需要更多的时间来预测，需要更多的空间来存储整个训练集，但更重视序列的顺序。你可以看看这个实现。</li></ul></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="21a9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">特别感谢约瑟夫·罗卡的所有帮助。感谢我的朋友们也校对了这篇文章。</p></div></div>    
</body>
</html>