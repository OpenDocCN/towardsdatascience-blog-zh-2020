<html>
<head>
<title>Machine Learning: From Ideation to a Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习:从构思到网络应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-from-ideation-to-a-web-app-ed5ccd3e1df1?source=collection_archive---------36-----------------------#2020-10-05">https://towardsdatascience.com/machine-learning-from-ideation-to-a-web-app-ed5ccd3e1df1?source=collection_archive---------36-----------------------#2020-10-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8560" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python和Flask的端到端数据科学之旅，包括数据收集、Web抓取、数据清理、特征工程、模型训练和云部署</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50472050fa8a65fe3165ec0c1493778c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbV6VeCRFwxZRN2pbiPAgA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/photo/analysis-blackboard-board-bubble-355952/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">像素</a>生成的图像</p></figure><p id="5d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前所有关于实用ML方面的文章都主要围绕您的数据科学之旅中ML管道的单一主题。然而，在这里，我的目标是带您经历整个端到端的旅程，从数据收集开始，到任何地方的任何人都可以访问的云部署的ML模型结束。</p><p id="16a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了通常怀疑的数据管理、特征工程、特征选择、模型训练和验证，我们还将看到如何执行网络搜集(通过<a class="ae ky" href="https://www.crummy.com/software/BeautifulSoup/" rel="noopener ugc nofollow" target="_blank"> BeautifulSoup </a>)，以及使用<a class="ae ky" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>在<a class="ae ky" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>上部署一个ML模型。我希望带您经历一次实用的数据科学之旅，突出ML项目中一些相对无趣且耗时的任务。</p><h1 id="d0f1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">预测问题</h1><p id="ba68" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们在这个项目中的目标将是预测任何两个国家之间的<a class="ae ky" href="https://en.wikipedia.org/wiki/One_Day_International" rel="noopener ugc nofollow" target="_blank">一日国际(ODI) </a>板球比赛的获胜者，即分类问题。</p><p id="bfab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些不熟悉板球的人来说，这个游戏的工作原理如下:</p><ul class=""><li id="6405" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">两支各有11名选手的队伍争夺ODI</li><li id="2555" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">每个队在每一局最多有50次击球或投球出局的机会</li><li id="0742" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">掷硬币获胜的一方(通过掷硬币或掷球棒)可以决定先掷球棒还是先掷保龄球</li><li id="63d6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">该队击球手首先在单局<a class="ae ky" href="https://en.wikipedia.org/wiki/Innings" rel="noopener ugc nofollow" target="_blank">中设定目标得分</a>。每局比赛持续到击球一方“全部出局”(即11名击球手中有10名“出局”)，或者第一方分配的所有回合都完成为止</li><li id="c48d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">第二个击球的队试图得分超过目标得分以赢得比赛。从团队保龄球第二的角度来看，他们试图在击球队达到目标得分之前击败第二队或完成分配的回合</li><li id="66a6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">比赛的结果可以是实际结果(一方获胜，另一方输掉比赛)，平局(在分配的回合结束时双方得分相同)，或平局/没有结果/放弃(在不可能比赛或由于天气条件或其他玩家无法控制的情况下比赛仍未结束的情况下)</li></ul><p id="dab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了训练有素的模型，我们将:</p><ul class=""><li id="f2b7" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">为我们的模型所需的所有独立变量构建一个带有输入表单的HTML前端——需要HTML知识(本文没有明确涉及)</li><li id="6a91" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">使用Flask框架构建应用程序的后端</li><li id="719c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在Heroku上部署web应用程序，使其公开可用并可通过URL访问</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="6dfc" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">数据收集</h1><p id="5c18" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们的主要数据来源将是与男性ODI相关的四个公开数据集<a class="ae ky" href="https://data.world/cclayford/cricinfo-statsguru-data" rel="noopener ugc nofollow" target="_blank">此处</a>。这些数据是从<a class="ae ky" href="https://stats.espncricinfo.com/ci/engine/stats/index.html" rel="noopener ugc nofollow" target="_blank">criinfo的Statsguru </a>搜集来的，包括了从1971年1月第一次对外直接投资到2020年3月所有对外直接投资的基本细节。这四个CSV具有每个游戏的以下必要信息:</p><ul class=""><li id="bcc0" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">相关的比赛细节，包括比赛国家的名称、比赛日期、比赛场地和结果</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/cbc35a7e45a02dac153bc1fe79681c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEnZK1dnVMTXFgn7M8WA_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ODI _结果</p></figure><ul class=""><li id="000e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">单个运动员的击球和保龄球统计，例如得分、击球次数、击球次数、投球次数等。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5b2066ab6b806a88263875bbcc35f357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vg9catDP8PXdq2ryYN3SUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ODI _ Burgess(截断的列)</p></figure><p id="8736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在数据管理阶段将这些数据帧连接在一起。尽管这些文件中提供了丰富的信息，但它们仍然缺少其他一些重要信息，如下所示:</p><ul class=""><li id="292e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">投掷结果，我们将从每场比赛的<a class="ae ky" href="http://www.howstat.com/cricket/Statistics/Matches/MatchScorecard_ODI.asp?MatchCode=4423&amp;Print=Y" rel="noopener ugc nofollow" target="_blank">记分卡</a>中刮出，正如在<a class="ae ky" href="http://howstat.com/cricket/home.asp" rel="noopener ugc nofollow" target="_blank"> Howstat </a>上主持的那样</li><li id="f682" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">国际板球理事会(ICC) ODI球员排名——根据ICC的官方国际击球和保龄球排名。我们将从<a class="ae ky" href="http://www.relianceiccrankings.com/datespecific/odi/" rel="noopener ugc nofollow" target="_blank"> ICC排名</a>中收集这些信息</li></ul><h2 id="1952" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">折腾信息的网络抓取</h2><p id="1b8a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Web抓取是从网站中提取信息，并将其存储在本地计算机或代码中的过程。Python拥有多个web抓取库，允许我们将来自网站的原始数据作为python代码的一部分。我们将使用BeautifulSoup来实现这个目的，因为它使用起来非常简单，同时拥有几个与文本操作和解析相关的高级功能。</p><p id="b28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BeautifulSoup的工作方式是获取一个网站，然后将其HTML元素解析为一个BeautifulSoup对象。然后，我们可以使用HTML标记和它的树状结构，根据它在BeautifulSoup对象中的位置提取特定的文本。例如，BeautifulSoup可以帮助我们:</p><ul class=""><li id="5ae4" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">查找所有链接</li><li id="7d8a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">找到第一个表格，给我它的第一个(或任何其他)单元格的内容</li><li id="746b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">查找特定类的所有链接</li><li id="c0f2" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在表格中查找特定文本，然后在下一个单元格中给我该文本</li></ul><p id="d03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解网站的结构、使用的HTML标签以及如何使用BeautifulSoup处理特定网站的HTML标签，需要一些HTML的基础知识。</p><p id="e96d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Howstat上每个ODI在匹配的URL中都有一个唯一的匹配代码。我们将在一个<code class="fe og oh oi oj b">for</code>循环中使用这些唯一的匹配代码来收集曾经玩过的每个ODI的以下信息:</p><ul class=""><li id="6939" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">团队名称</li><li id="c3ff" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">掷硬币获胜的队</li><li id="d7a8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">比赛日期</li><li id="0b37" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">比赛场地的名称</li></ul><p id="7259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比赛日期和场地名称将用于匹配和合并toss结果与我们的比赛细节的主要数据集。网站上显示的相关信息如下——在所有匹配中保持一致:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a866fb3700b1dd8091a2f23db72055cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*OxcpDz_7oQacdzUOfuZRFg.png"/></div></figure><p id="eafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过一点点的试验和错误，我确定了Howstat上的匹配代码(主要是顺序的)，并将它们保存在一个<a class="ae ky" href="https://drive.google.com/file/d/15-sZtSWipYeYcOIRGdbZZP0THwql0Y7r/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> CSV文件</a>中。一旦这个CSV作为数据帧上传，我们将在一个<code class="fe og oh oi oj b">for</code>循环中检查每个比赛代码，从每个比赛的Howstat记分卡中提取所需的信息，并保存为一个单独的数据帧。前提很简单:</p><ul class=""><li id="d4ad" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">定义每个记分卡的基本URL，在我们的例子中是:<code class="fe og oh oi oj b">http://www.howstat.com/cricket/Statistics/Matches/MatchScorecard_ODI.asp?MatchCode={code}&amp;Print=Y</code></li><li id="6be2" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">解析HTML内容并保存为一个BeautifulSoup对象。</li><li id="2556" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在解析的HTML中查找所有表格。我们没有找到带有toss信息的特定表格，因为源HTML没有任何唯一的表格标识。您可能会遇到一些特定的用例，在这些用例中，您想要的表是用一个惟一的类在HTML中定义的。如果是这样的话，那么不需要找到所有的表，只需用BeautifulSoup的<code class="fe og oh oi oj b">find_all</code>方法的<code class="fe og oh oi oj b">class_</code>参数就可以找到目标表。回到我们的用例，对于BeautifulSoup对象中表格的每个元素:</li></ul><ol class=""><li id="fe33" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ol my mz na bi translated">如果元素的文本是<code class="fe og oh oi oj b">Match Date</code>，查找并保存下一个元素。下一个元素将是比赛的实际日期</li><li id="0556" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated">如果元素的文本是<code class="fe og oh oi oj b">Toss</code>，查找并保存下一个元素。下一个元素将是赢得掷币的队的名字</li><li id="9871" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated">如果元素的文本是<code class="fe og oh oi oj b">Venue</code>，查找并保存下一个元素。下一个元素是比赛场地的名称</li></ol><ul class=""><li id="6024" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">将上述每个匹配的三个数据点添加到字典中</li><li id="e91d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">将字典转换成数据帧，以便有效地处理数据</li></ul><p id="f752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有了它，一个由所有ODI播放过的toss信息组成的数据帧，尽管废弃的文本仍需要一些清理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/81566eb1f31819139173223e19a46bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZYyiUWJOO__UAzh0V0bFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">toss_df(网页抓取后)</p></figure><p id="1fd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止执行的步骤代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="4ead" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">数据管理和更多的网页抓取</h1><p id="3a6a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们现在将承担某些数据清理、预处理和合并任务，为最终摄入分类算法准备数据。</p><h2 id="f4a0" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">ODI _结果数据框架</h2><p id="1718" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将首先清理保存每个游戏高级细节的<code class="fe og oh oi oj b">ODI_results</code>数据帧。注意它的结构:每个游戏有两个记录:一个来自每个游戏团队的视角。例如，如果英格兰在某一天赢了澳大利亚的比赛，那么这场比赛将有以下两个记录:</p><ul class=""><li id="e2b6" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">一个从英格兰的角度来看，显示英格兰赢得了这场比赛，和</li><li id="f62e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">另一个来自澳大利亚的视角，澳大利亚输掉了这场比赛</li></ul><p id="e776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，请注意，数据框中没有将对方国家的名称作为单独的一列。相反，它与<code class="fe og oh oi oj b">Match</code>栏捆绑在一起，就像这样:团队1对团队2。我们将执行以下步骤:</p><ul class=""><li id="ef08" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">通过拆分<code class="fe og oh oi oj b">Match</code>列，去除结果列的前导和尾随空格，并使用一个简单的<code class="fe og oh oi oj b">numpy.where</code>方法，创建一个新的<code class="fe og oh oi oj b">Opposition</code>特性</li><li id="5a1d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">删除不需要的列，只保留下列内容:<code class="fe og oh oi oj b">Result, Home/Away, Ground, Match Date, Country, Opposition</code></li><li id="beb3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">将<code class="fe og oh oi oj b">Match Date</code>列转换为<code class="fe og oh oi oj b">datetime</code>格式</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/81566eb1f31819139173223e19a46bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZYyiUWJOO__UAzh0V0bFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ODI_results_clean</p></figure><h2 id="f5c3" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">ODI _局数数据帧</h2><p id="04d3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们将处理我们的<code class="fe og oh oi oj b">ODI_innings</code>数据帧，这需要做更多的清理工作。让我们先了解一下它的结构:</p><ul class=""><li id="9bf2" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">每一个参加比赛的运动员的名字都在一排</li><li id="9cb6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">每个玩家的游戏特定统计数据在列中。击球和保龄球统计都有其特定的列</li><li id="8bf2" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">由于一名球员可以在同一场比赛中同时击球和投球，因此来自同一支球队的11名球员在每场比赛中都被包括两次，首先是他的击球统计数据，然后是他的保龄球统计数据。<code class="fe og oh oi oj b">Innings Number</code>列区分了这两个集合</li></ul><p id="ea79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在手动EDA过程中注意到的一些问题:</p><ul class=""><li id="4cd7" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">某些特定比赛的重复记录，其中相同局的统计重复</li><li id="3d60" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在几个例子中，球员的名字被重复，所以统计数据是两个不同的球员，但有相同的球员名字。这意味着我们不能执行一揽子<code class="fe og oh oi oj b">drop_duplicates</code>操作。相反，我们需要选择列的子集来识别重复项</li><li id="6a8f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">我们还需要修改一些拼写，使其与ICC排名列表中的拼写一致——这是我们即将进行的抓取排名信息的网络抓取任务的先决条件</li><li id="7605" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">由于ICC规则允许在特定条件下的比赛中使用替补球员，一些球员有12个球员的信息(而不是标准的11个)。我们将在此阶段保留所有12名球员的信息，稍后再处理</li></ul><p id="75e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据清理任务类似于我们在<code class="fe og oh oi oj b">ODI_results</code>上执行的任务，包括:</p><ul class=""><li id="463e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">基于要素子集删除重复的记录/行</li><li id="9b5a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">删除不需要的列，只保留下面的列:<code class="fe og oh oi oj b">Players, Opposition, Ground, Match Date, Country</code>。在特征工程的稍后阶段，我们将返回到一些被删除的列</li><li id="0233" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">清理<code class="fe og oh oi oj b">Opposition</code>列(删除<code class="fe og oh oi oj b">v</code>，重命名特定的列，使两个数据帧的命名一致:<code class="fe og oh oi oj b">ODI_results</code>和<code class="fe og oh oi oj b">ODI_innings</code></li><li id="eb87" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">将<code class="fe og oh oi oj b">Match Date</code>列转换为<code class="fe og oh oi oj b">datetime</code>格式</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5a378fdd5e15c58517af1a01bac17770.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*C34y9sGTl750V1AIFnVEiw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ODI _局数_清洁</p></figure><h2 id="119d" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">合并ODI_results和ODI _ Burgess</h2><p id="0ea1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，我们应该将两个清理过的数据帧合并为一个。我们的目标是在<code class="fe og oh oi oj b">ODI_results_clean</code>数据帧中添加24列，每一列都有参赛队和非参赛队的12名球员的名字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/88d2df79111ec899c3ee4c04ab8d7ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*zkgI02qKZuzlvOe73ipaPw.png"/></div></figure><p id="56bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的数据结构确保了我们将每个游戏的数据放在一行中。这是一个相当棘手的过程，涉及多个<code class="fe og oh oi oj b">merge</code>和<code class="fe og oh oi oj b">unstack</code>操作，但我会尽力解释我的方法:</p><ul class=""><li id="510c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">首先，将<code class="fe og oh oi oj b">Match Date</code>、<code class="fe og oh oi oj b">Ground</code>、<code class="fe og oh oi oj b">Country</code>上的<code class="fe og oh oi oj b">ODI_results_clean</code>和<code class="fe og oh oi oj b">ODI_innings_clean</code>合并，让游戏国玩家以长格式加入<code class="fe og oh oi oj b">ODI_results_clean</code>。在这个上下文中，长格式意味着用一列来保存玩家的名字，因此，每场比赛将跨越多行——类似于<code class="fe og oh oi oj b">ODI_innings_clean</code>。注意这里使用的是<code class="fe og oh oi oj b">left</code> join而不是<code class="fe og oh oi oj b">inner</code> join，因为我们希望保留来自<code class="fe og oh oi oj b">ODI_results_clean</code>的所有数据，即使ODI _ Burgess _ clean中没有相应球队的球员信息</li><li id="9418" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">然后执行类似的<code class="fe og oh oi oj b">merge</code>操作，只是这一次使用<code class="fe og oh oi oj b">Opposition</code>栏代替<code class="fe og oh oi oj b">Country</code>(以获得对手队球员的姓名)，连同<code class="fe og oh oi oj b">Match Date</code>和<code class="fe og oh oi oj b">Ground</code></li><li id="0d4a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">我们希望合并两个新的长格式数据框架，在单独的列中包含所有细节和每个队的球员。然而，在合并过程中，如果不复制玩家的名字，我们就不能以他们当前的形状做到这一点。在应用合并操作之前，我们希望有一个“平面”数据帧结构，其中每个国家的比赛数据都在一行中，即所有球员都在列中。我们将通过使用<code class="fe og oh oi oj b">groupby</code>和<code class="fe og oh oi oj b">unstack</code>方法的自定义函数来实现这一点</li><li id="0e98" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">一旦我们从比赛和对手的角度获得了2个“平面”数据帧，我们将执行一个简单的内部合并来将这两个数据帧连接在一起。我们使用了一个内部连接，因为我们想确保只有普通的行被连接，因为我预计<code class="fe og oh oi oj b">ODI_innings_clean</code>不会有特定球队的球员信息，无论是官方ODI状态还是其他</li><li id="76d3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">替换一些球员名字的拼写，以确保我们的数据和ODI排名之间的拼写一致，我们将废弃。我通过手工试错法发现了这一点，如果您有来自多个来源的数据，这在一定程度上是必需的</li></ul><p id="f242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迄今为止执行的数据管理操作代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="b358" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">ICC ODI等级的网页抓取</h2><p id="24dc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来是最后一点网络抓取，从官方ICC ODI排名网站<a class="ae ky" href="http://www.relianceiccrankings.com/datespecific/odi/" rel="noopener ugc nofollow" target="_blank">获取截至比赛日所有球员的ICC ODI排名。实现这一点的高级工作流如下:</a></p><ul class=""><li id="dd54" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">将<code class="fe og oh oi oj b">ODI_matches</code>数据帧分解回“long”格式，这样就只有一个<code class="fe og oh oi oj b">Players</code>列，单个匹配将跨越多行。这样做将有助于我们合并后刮排名</li></ul><p id="3846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于ODI播放的每个唯一日期:</p><ul class=""><li id="b748" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">刮出击球和保龄球的前100名球员，并将他们保存在单独的数据框中</li><li id="12cb" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">获取当天参加比赛的球员姓名，并保存到第三个数据帧</li><li id="1058" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">合并这三个数据帧</li><li id="d450" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在运动员姓名、击球等级和保龄球等级上逐个拆分合并的数据帧，使这三个信息集在三个数据帧中，运动员和等级在列中</li><li id="72e4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">沿着列将三个未堆叠的数据帧连接在一起</li><li id="2a12" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">将结果DF附加到列表中</li></ul><p id="f63a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe og oh oi oj b">for</code>循环的末尾，我们将有一个多个数据帧的列表，其中包含ODI比赛的每个日期的球员姓名、保龄球和击球等级。最后一步是对该列表进行简单的连接，以生成一个综合的最终数据帧(<code class="fe og oh oi oj b">final_result</code>)，该数据帧包含以下7，738行78列的信息:</p><ul class=""><li id="acd2" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">国家名称</li><li id="4b1c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">反对派名称</li><li id="e6b8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">主场/客场——从这个国家的角度来看，这场比赛是主场还是客场</li><li id="ab49" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">地面</li><li id="9fcc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">比赛日期</li><li id="1a09" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">结果—我们的目标变量</li><li id="4013" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">24名运动员的名字，国家和反对派各12名</li><li id="cfc8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">ICC ODI保龄球24名球员的排名(<code class="fe og oh oi oj b">np.nan</code>以防球员排名在前100名之外)</li><li id="4556" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">ICC ODI名选手的击球等级(<code class="fe og oh oi oj b">np.nan</code>如果选手不在前100名之内)</li></ul><h2 id="af92" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">toss_df数据帧</h2><p id="a993" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下一步是清理我们的<code class="fe og oh oi oj b">toss_df</code>数据帧，并将其与<code class="fe og oh oi oj b">ODI_matches</code>数据帧合并。一些高级任务包括:</p><ul class=""><li id="f9f6" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">从<code class="fe og oh oi oj b">Match</code>栏中提取比赛和对手队的名称</li><li id="67dc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">从<code class="fe og oh oi oj b">Ground</code>栏中提取准确的地面名称</li><li id="0709" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">作为网页抓取的结果，<code class="fe og oh oi oj b">Toss Won by</code>列中的一些记录包括<code class="fe og oh oi oj b">Result:</code>。这种情况更有可能发生在那些被放弃的、未完成的或其他不可能有结果的匹配中。我们将放弃这些记录</li><li id="d26b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">更新一些<code class="fe og oh oi oj b">Ground</code>名称，使其与<code class="fe og oh oi oj b">ODI_matches</code>数据帧一致</li><li id="50f2" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">与<code class="fe og oh oi oj b">final_result</code>数据帧合并成<code class="fe og oh oi oj b">final_data</code>数据帧</li></ul><p id="8f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个数据管理任务的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="8020" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">特征工程</h1><p id="a53f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经有了相当多的信息来开发一个预测性的工作模型，但是我们可以添加和评估更多的信息。</p><h2 id="be1c" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">比赛月份</h2><p id="a140" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我认为天气会对ODI比赛的结果产生影响。我们可以添加一年中的月份来代表这些信息。</p><h2 id="88a9" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">赢/赔率</h2><p id="a844" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个国家在任何给定日期赢得的累计比赛数与输掉的比赛数之比。根据我们目前收集的信息，我们可以很快确定这一点。</p><h2 id="cc02" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">击球/保龄球平均得分和每次得分(RPO)</h2><p id="e53b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们将根据原始<code class="fe og oh oi oj b">ODI_innings</code>数据框架中的局数信息，为每个团队计算以下四个新特性:</p><ul class=""><li id="93ed" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">平均打击率:每次击球失败得分</li><li id="2b16" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">保龄球平均得分:每门失分</li><li id="5c32" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">击球RPO:每次击球得分</li><li id="ba6b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">保龄球RPO:每次投球失分</li></ul><p id="a6ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这四个特征将根据每个国家截至比赛日期(但不包括比赛日期)的累计统计数据进行计算。计算它们所需的相关列有:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/a7fab725dafccd24ff29f5345f7e8635.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*mo-JhIOG9ps3mrRaZmwRGQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ODI _ Burgess _ for _ averages数据框架</p></figure><p id="fb9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只有计算四个新特征所需的六个特征中的五个，因为我们在游戏中被一个团队遗漏了<code class="fe og oh oi oj b">Innings Wickets Taken</code>。但是这很容易计算，因为我们有每场比赛对手的<code class="fe og oh oi oj b">Innings Wickets Taken</code>。一个队失去的三柱门相当于对方得到的三柱门。</p><p id="95a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，一旦我们有了计算四个新特性所需的所有六列，我们将遍历所有国家，计算每个国家到比赛日期为止(但不包括比赛日期)这六个变量的累积值。一旦我们有了累积的统计数据，我们只剩下计算四个新特性了。我们的新数据框架将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/1576d0259ee70c60f4db46517aa0ec25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NoyBN-L9-zsIAJ4ejkaog.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ODI_team_averages数据框架</p></figure><p id="97cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将删除除最后四列之外的所有列，并与<code class="fe og oh oi oj b">final_data</code>数据帧合并。</p><h2 id="d42e" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">掷硬币赢了</h2><p id="84d4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们还可以将<code class="fe og oh oi oj b">Toss Won By</code>列更新为类似于<code class="fe og oh oi oj b">Toss Won?</code>的内容，以表明游戏团队是否赢得了比赛。这将把列转换成二进制格式，并通过虚拟/一位热码编码消除潜在的稀疏数据帧。</p><h2 id="2ca5" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">玩家排名</h2><p id="4180" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">请记住，对于某些游戏，我们有十二个玩家(由于游戏期间的玩家替换)，但对于我们的模型训练和预测，我们不能有超过十一个玩家。这是因为在一场比赛开始前，一个队不能有超过11名队员。</p><p id="f88d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了适应这种情况，并且只有在我们的数据集中有12名玩家的比赛中，我们才会更新任何一名玩家的等级，使其等于截至<code class="fe og oh oi oj b">Match Date</code>的所有12名玩家的平均等级。</p><p id="2846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的特征工程已经接近尾声了，但是也许让我们也尝试一些额外的东西。目前，我们每场比赛总共有44个排名栏——这可能有点太多了，可能会导致“维数灾难”。如果我们可以在一个单独的列中总结每个队的击球和保龄球等级信息，会怎么样？这可能会将排名列的数量从44减少到4。</p><p id="e6a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但在此之前，我们应该估算缺失的等级。排名缺失是由于在比赛当天，球员不在ICC ODI排名前100名之列，即他们的排名高于100。我会用一个常量<code class="fe og oh oi oj b">101</code>来代替缺失的等级。您可以尝试一些其他常数，但我认为这是最合适的，因为较高的常数可能会由于有点离群而导致误解。</p><p id="7ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以选择任何描述性统计数据来表示11名球员的击球和保龄球信息，只要外行人在预测过程中能够快速计算出来。我将计算总和、平均值和中值，并在特征选择期间进一步评估。</p><p id="f917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经完成了所有的特性工程，产生了14个新特性。</p><p id="748a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征工程活动的所有代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="18da" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">特征选择</h1><p id="b270" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">参考我以前的<a class="ae ky" rel="noopener" target="_blank" href="/how-to-find-the-best-predictors-for-ml-algorithms-4b28a71a8a80">文章</a>，重温我将在这里使用的特性选择技术。</p><h2 id="4060" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">分类特征选择—卡方检验</h2><p id="b7c4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">执行卡方检验以确定我们的分类特征是否与目标变量相关，结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/480d4be595a3b12ca7f3ab91aee206d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*fFmrInB5MbrLz6lbVgSq-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡方检验</p></figure><p id="3c6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我们在这里得到了令人惊讶的结果——我本以为投掷结果和场地会对比赛结果产生重大影响。然而，根据我们手头的数据，鉴于它们的高p值，情况似乎并非如此。</p><p id="013e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有可能在有和没有这两个特性的情况下运行模型验证指标，并从那里得到它。但对于这个项目，我们将在模型训练之前放弃这些功能。</p><h2 id="93dc" class="nu lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">数字特征选择— F统计量</h2><p id="463f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对数值特征进行ANOVA F-统计测试可得出以下结论:</p><ul class=""><li id="89f5" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><code class="fe og oh oi oj b">Match Month</code>对于预测来说没有统计学意义(再次令人惊讶)</li><li id="b7fd" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">所有其他特征本身都具有统计学意义</li><li id="76bf" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">与总等级和平均等级相比，四个中值等级特征的F统计量非常低:我们不会考虑将它们用于模型训练</li><li id="2b7a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">总等级和平均等级的F统计量是相同的，所以如果我们愿意，可以使用任何一个</li><li id="5187" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">作为一个粗略的启发，如果我们将<code class="fe og oh oi oj b">Country Total Batting Rank</code>特征的F统计量与每个<code class="fe og oh oi oj b">Country_Batting Rank_x</code>列的F统计量之和进行比较，后者大于前者。</li></ul><p id="22b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我将放弃所有12个描述玩家等级的额外特征，这些特征是在上一个特征工程中创建的(和<code class="fe og oh oi oj b">Match Month</code>)，继续我们对单个玩家等级的建模。</p><p id="56ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征选择的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="7d9a" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">模型培训和验证</h1><p id="3d6d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，我们来到机器学习的有趣部分——模型训练。我们将使用简单的逻辑回归算法进行预测。</p><p id="db22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还尝试了特定的其他算法(例如，XGBoost、Random Forest、Ada Boost、Gradient Boosting)，但是除了Random Forest，其他三种算法并没有导致预测准确性的实质性提高。</p><p id="e254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在删除了基于特征选择步骤的列之后，我们只需要在拟合逻辑回归模型之前从分类特征中创建虚拟变量。</p><p id="fdd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于全面的模型评估，我们将执行<code class="fe og oh oi oj b"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RepeatedStratifiedKFold.html" rel="noopener ugc nofollow" target="_blank">RepeatedStratifiedkFold</a></code>交叉验证，重复十次，以准确度作为我们的评估标准，因为我们的数据不是不平衡的。</p><p id="30b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的平均准确度分数为68.66%，这是一个合理的准确度，如果不是非常高的话。但我想这是意料之中的，因为比赛的本质是个人的才华可以让一场比赛从一个失败的位置变成一个团队的胜利位置。</p><p id="0146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以画一个ROC曲线，确定合适的概率阈值来区分预期的赢和输。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/b83bf020ffc283d8f81bb04949cd2e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*bIF7y_pgKoB1vMudsvUSbA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">受试者工作特征曲线</p></figure><p id="c694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Youden%27s_J_statistic" rel="noopener ugc nofollow" target="_blank"> Youden的J统计量</a>，我们的理想概率阈值达到48.27%，也就是说，该阈值将产生最大的区分能力，以区分预期的赢和输。</p><p id="bed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的最后一步将是通过我们的web应用程序(Final_LR_Model.pkl)简单地处理模型以实现预测。</p><p id="c06e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有建模和验证相关的代码是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="2475" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">为数据捕获构建一个HTML前端</h1><p id="dc61" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">那么我们现在如何使用我们的模型进行预测呢？有几种方法可以做到这一点:我们可以将特性传递给模型，并调用<code class="fe og oh oi oj b">predict</code>或<code class="fe og oh oi oj b">predict_proba</code>方法，或者我们可以与他人共享腌好的文件来预测他们自己(只要他们了解python)。</p><p id="ba60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这两种方法都需要人工干预来加载数据并将其传递给模型。如果我们希望向世界开放我们的模型，允许任何人在任何时间做出他们的预测，而不需要与python和其他技术任务进行任何直接交互，会怎么样？</p><p id="bdda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们可以开发一个网站来捕获用户输入，将其传递给Flask后端进行预处理和预测，并通过另一个网页将模型输出返回给用户。本质上，我们想要像<a class="ae ky" href="https://bit.ly/predict-odi" rel="noopener ugc nofollow" target="_blank">这种</a>的东西——这是我们部署在云上的模型，让世界可以访问它，并且不需要python、机器学习等知识。</p><p id="2068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发一个网站需要一定程度的HTML和CSS样式表知识，这超出了本文的范围。然而，设计一个简单的输入表单并不需要成为专家。一些免费的在线平台和软件提供模板，或者允许通过简单的拖放界面进行HTML开发。</p><p id="8fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML代码告诉浏览器在屏幕上显示什么，而CSS文件告诉它如何在屏幕上显示HTML内容。CSS是一种通过指定背景颜色、字体大小和颜色、边距等来控制网页布局的有效方法。</p><p id="843f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请参考我们web应用程序的<a class="ae ky" href="https://github.com/finlytics-hub/ODI/blob/master/templates/home.html" rel="noopener ugc nofollow" target="_blank"> HTML </a>和<a class="ae ky" href="https://github.com/finlytics-hub/ODI/blob/master/static/style.css" rel="noopener ugc nofollow" target="_blank"> CSS </a>代码，并注意以下几点:</p><ul class=""><li id="1d30" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">HTML代码(连同任何相关的图像)应该在一个“模板”文件夹内。templates文件夹应该与Flask应用程序位于同一层，我们将在后面介绍它</li><li id="2dff" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">源代码应该位于名为“static”的文件夹中。静态文件夹应该与Flask应用程序位于同一级别。注意，这个文件夹的名称可以是您想要的任何名称，只要它在HTML代码中被适当地引用</li><li id="dc18" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">我们将在templates文件夹中有两个HTML代码:<a class="ae ky" href="https://github.com/finlytics-hub/ODI/blob/master/templates/home.html" rel="noopener ugc nofollow" target="_blank">一个</a>用于捕获用户输入(<code class="fe og oh oi oj b">home.html</code>)，另一个<a class="ae ky" href="https://github.com/finlytics-hub/ODI/blob/master/templates/result.html" rel="noopener ugc nofollow" target="_blank">用于显示模型输出(<code class="fe og oh oi oj b">result.html</code>)</a></li><li id="4fcd" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe og oh oi oj b">home.html</code>文件将包含几个下拉菜单和文本字段来捕捉用户输入。对于分类特征，最好使用下拉菜单来限制用户输入我们的模型未知的值。例如，<code class="fe og oh oi oj b">Country</code>、<code class="fe og oh oi oj b">Opposition</code>和<code class="fe og oh oi oj b">Home/Away</code>特性</li></ul><p id="ddab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义下拉菜单的示例代码:</p><pre class="kj kk kl km gt ov oj ow ox aw oy bi"><span id="724b" class="nu lw it oj b gy oz pa l pb pc">&lt;select class="element select large" id="element_2" name="element_2" required="required"&gt;     <br/>&lt;option value="" selected="selected"&gt;&lt;/option&gt;    &lt;option&gt;Afghanistan&lt;/option&gt;<br/>&lt;option&gt;Australia&lt;/option&gt;    <br/>&lt;option&gt;Bangladesh&lt;/option&gt;    <br/>&lt;option&gt;England&lt;/option&gt;    <br/>&lt;option&gt;India&lt;/option&gt;    <br/>&lt;option&gt;Ireland&lt;/option&gt;    <br/>&lt;option&gt;New Zealand&lt;/option&gt;    <br/>&lt;option&gt;Pakistan&lt;/option&gt;    <br/>&lt;option&gt;Scotland&lt;/option&gt;    <br/>&lt;option&gt;South Africa&lt;/option&gt;    <br/>&lt;option&gt;Sri Lanka&lt;/option&gt;    <br/>&lt;option&gt;West Indies&lt;/option&gt;    <br/>&lt;option&gt;Zimbabwe&lt;/option&gt;  <br/>&lt;/select&gt;</span></pre><p id="1206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义整数文本字段的示例代码(例如，玩家的保龄球等级):</p><pre class="kj kk kl km gt ov oj ow ox aw oy bi"><span id="963b" class="nu lw it oj b gy oz pa l pb pc">&lt;input id="element_99" name="element_99" class="element text large" type="number" step=".01" required="required" value=""/&gt;</span></pre><p id="b902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义浮动文本字段的示例代码(例如击球率):</p><pre class="kj kk kl km gt ov oj ow ox aw oy bi"><span id="3815" class="nu lw it oj b gy oz pa l pb pc">&lt;input id="element_3" name="element_3" class="element text large" type="number" step=".01" required="required" value=""/&gt;</span></pre><p id="da42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这些标签的一些主要元素:</p><ol class=""><li id="90e1" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ol my mz na bi translated"><code class="fe og oh oi oj b">&lt;select&gt;…&lt;/select&gt;</code>指定一个下拉框</li><li id="3197" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated"><code class="fe og oh oi oj b">&lt;option&gt;…&lt;/option&gt;</code>指定每个下拉选项</li><li id="8fe7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated"><code class="fe og oh oi oj b">id</code>是字段的唯一标识</li><li id="7871" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated"><code class="fe og oh oi oj b">name</code>是字段的唯一名称，我们的Flask应用程序可以使用它来引用特定的字段</li><li id="8757" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated"><code class="fe og oh oi oj b">class</code>是对CSS代码中定义的特定样式指南的引用</li><li id="8839" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated"><code class="fe og oh oi oj b">number</code>指定只接受整数作为输入</li><li id="073d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated"><code class="fe og oh oi oj b">step</code>允许输入浮点数</li><li id="626a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated"><code class="fe og oh oi oj b">required</code>确保用户不能将字段留空</li><li id="2bd0" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ol my mz na bi translated"><code class="fe og oh oi oj b">value</code>是表单加载时用户看到的默认值</li></ol><ul class=""><li id="3c1b" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">CSS代码在HTML文件的<code class="fe og oh oi oj b">&lt;head&gt;…&lt;/head&gt;</code>标记中被引用，如下所示(其中‘static’是保存CSS代码‘style . CSS’的文件夹名，<code class="fe og oh oi oj b"><a class="ae ky" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.url_for" rel="noopener ugc nofollow" target="_blank">url_for</a></code>是生成动态URL的内置Flask方法):</li></ul><pre class="kj kk kl km gt ov oj ow ox aw oy bi"><span id="1e24" class="nu lw it oj b gy oz pa l pb pc">&lt;link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='./style.css') }}"&gt;</span></pre><ul class=""><li id="e5ea" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><code class="fe og oh oi oj b">result.html</code>中的主要元素是对作为<code class="fe og oh oi oj b">{{pred}}</code>的<code class="fe og oh oi oj b">pred</code>变量的引用，它显示存储在Flask应用程序中的值</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="5fb1" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">通过Flask开发Web应用程序的后端</h1><p id="b077" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将使用Flask框架开发web应用程序的后端。可以把Flask想象成一个库，可以像Python中的其他库一样导入。所以基本上，我们的应用程序将是一个简单的Python文件(扩展名为<code class="fe og oh oi oj b">.py</code>，而不是扩展名为<code class="fe og oh oi oj b">.ipynb</code>的笔记本)，除了所有其他Python功能之外，它还利用了Flask。</p><p id="6179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们后端应用程序的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">app.py</p></figure><p id="2e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让上面的代码不言自明，我尽了最大努力做了很好的注释，但是让我们从更高的层面来看一下:</p><ul class=""><li id="02f3" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">导入所有需要的库</li><li id="0afe" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">实例化名为<code class="fe og oh oi oj b">app</code>的Flask应用程序</li><li id="b7b8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">加载我们的腌渍模型(<code class="fe og oh oi oj b">Final_LR_Model.pkl</code>)，它和<code class="fe og oh oi oj b">app.py</code>在同一个文件夹中</li><li id="3115" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">创建两个列表:<code class="fe og oh oi oj b">cols</code>带有输入列的名称，即在应用虚拟编码之前模型使用的特征，以及<code class="fe og oh oi oj b">col_list</code>带有虚拟编码特征的名称</li><li id="d859" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">通过Flask的<code class="fe og oh oi oj b"><a class="ae ky" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.render_template" rel="noopener ugc nofollow" target="_blank">render_template</a></code>方法显示<code class="fe og oh oi oj b">home.html</code>网页</li><li id="be36" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">将所有用户输入保存在列表<code class="fe og oh oi oj b">int_features</code>中，并将需要预测的国家名称保存在<code class="fe og oh oi oj b">country</code>变量中</li><li id="e100" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在应用虚拟编码(<code class="fe og oh oi oj b">cols</code>)之前，将输入列表转换成一个NumPy数组，然后转换成一个dataframe，其列与我们模型中的列相同</li><li id="e800" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">创建分类特征的虚拟变量，并重新索引生成的数据帧，以确保它具有我们的模型所需的所有虚拟编码列(通过带有<code class="fe og oh oi oj b">labels = col_list</code>参数的<code class="fe og oh oi oj b">pd.reindex</code>)</li><li id="0737" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">通过<code class="fe og oh oi oj b">predic_proba</code>预测一场比赛获胜的概率，转换成浮点数，通过一个简单的<code class="fe og oh oi oj b">if</code>语句确定该国有望赢得比赛还是输掉比赛</li><li id="8209" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">通过<code class="fe og oh oi oj b">render_template</code>显示<code class="fe og oh oi oj b">result.html</code>网页，将您选择的字符串分配给<code class="fe og oh oi oj b">pred</code>变量</li><li id="57ed" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">运行应用程序</li></ul><p id="02af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这个！</p><p id="95d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，让我们先在本地测试我们的应用程序，然后再将它部署到云中。启动Anaconda提示符(或您选择的任何终端)，导航到包含<code class="fe og oh oi oj b">app.py</code>、<code class="fe og oh oi oj b">Final_LR_Model.pkl</code>和模板&amp;静态文件夹的文件夹，并使用以下命令运行它:</p><pre class="kj kk kl km gt ov oj ow ox aw oy bi"><span id="7789" class="nu lw it oj b gy oz pa l pb pc">python app.py</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/dbba5e5529cfe3eefce0e5c177ed6396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkxHWHQ72826yPOFVRsL9w.png"/></div></div></figure><p id="08c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">忽略版本冲突版本(您可能看不到)，在web浏览器中打开URL。你应该看到你漂亮的<code class="fe og oh oi oj b">home.html</code>并且能够输入测试值并做出预测。</p><p id="33e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！你现在已经构建了你的第一个ML应用程序。接下来，我们将把这个应用程序从您的本地机器带到云中，以便其他人可以通过URL使用它。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="ae99" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">Heroku上的云部署</h1><p id="adca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Heroku为云部署提供平台即服务(PaaS)。有几种方法可以完成Heroku部署，但最简单的可能是通过GitHub库。</p><p id="5181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了我们在本地测试应用程序时使用的两个文件和两个文件夹，在Heroku部署之前，我们还需要GitHub存储库中的两个文件:</p><ul class=""><li id="50df" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><code class="fe og oh oi oj b">requirements.txt</code> <strong class="lb iu"> </strong>是一个文本文件，包含执行应用所需的python包的名称。这些是为成功执行应用程序而在环境中安装的必备软件包</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/a2fd40c801e53d72d3e7cca50781cc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*KUWStFGw8irE21G-5BBM5w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">requirements.txt</p></figure><p id="084a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该非常熟悉上述所有要求。可以把Gunicorn看作一个中间件，它允许您的Flask应用程序与托管它的服务器进行通信。从技术上讲，它是一个Python Web服务器网关接口(WSGI) HTTP服务器</p><ul class=""><li id="b9d6" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><code class="fe og oh oi oj b">Procfile</code>(没有任何文件扩展名)是一个应用程序中的进程类型列表，即一个给web服务器的指令列表，指示当有人登录到该应用程序时应该首先执行哪个文件。下图中的一行代码告诉服务器使用Gunicorn WSGI打开一个web应用程序，并在一个名为<code class="fe og oh oi oj b">app.py</code>的文件中运行一个名为<code class="fe og oh oi oj b">app</code>(这是我们在<code class="fe og oh oi oj b">app.py</code>中定义的应用程序名称)的应用程序</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/0b511db5c882abc8fefef9d8c37404b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*qiHs_MbPMC8H_LRn_kogBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Procfile</p></figure><p id="5e3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段，你的GitHub库应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/503335f41297774e0a24a6dbcc6c31c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*ML6uAGjKhCApkCdm7v2htQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/finlytics-hub/ODI" rel="noopener ugc nofollow" target="_blank">https://github.com/finlytics-hub/ODI</a></p></figure><p id="66ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照以下步骤完成Heroku部署:</p><ul class=""><li id="af05" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">登录你的Heroku账户(注册这种规模的项目是免费的),在你的仪表盘上点击“创建新应用”</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/7904a73f7cb8700fad7c4ae7a55b746a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTCdYKExxCAKdpe1oTEerg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Heroku仪表板</p></figure><ul class=""><li id="abca" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">输入您想要的应用程序名称和首选地区，然后单击“创建应用程序”</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/e7f9a77753543e41667a1332e6db376b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*4avqzflSo9x1kaPIwpYDeQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建新应用程序</p></figure><ul class=""><li id="5cd6" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">在“部署方法”下选择GitHub，并连接到您的GitHub帐户</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/9fef9bcb89d78aadd4146930e5cc63ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hb7LLhskuywX097WQP1Jpg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">选择并连接到GitHub</p></figure><ul class=""><li id="c484" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">GitHub可能会要求您在允许通过Heroku访问您的GitHub帐户之前进行身份验证</li><li id="8c2c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">一旦你的GitHub账户连接到Heroku，搜索并连接到你的目标GitHub库</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/e64e52ccaf2fe4a4492f8db35c27a20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFbk9MsD9bIta_fVUrgSwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">连接到GitHub存储库</p></figure><ul class=""><li id="7c74" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">连接到存储库后，在“手动部署”选项下部署其所需的分支</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/be0977bcf6b8a0dc4de9091371d76c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRZbHhMLZWPJew19s4nJZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部署分支</p></figure><ul class=""><li id="8889" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">等待一段时间，Heroku从存储库中取出所有需要的代码，在其服务器上安装所有需要的库，并完成部署。一旦完成，Heroku将确认你的成功部署(或其他),并给你一个选项来查看你的应用程序在一个特定的网址</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/55e5205f1fe8b2df4d813f2fefb677bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9puNAE7a_VxmGLZjv-ZEA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">成功部署</p></figure><p id="42ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部分了解我们可通过互联网访问的应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/7e68d5409f89afd7155586b30fa21511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vXYY6Z796UooZBBJPwTvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部署的应用程序(部分快照)</p></figure><p id="8acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有了它——一个完整的工作机器学习模型，用Python开发，部署在云上，任何人都可以全天候访问！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="86e7" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">结论</h1><p id="e432" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一次非常旋风般的旅行，我希望您会一直跟着我，同时也学习一些新的概念、工具、技术和方法。</p><p id="e1ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以在这里找到完整的笔记本<a class="ae ky" href="https://github.com/finlytics-hub/ODI/blob/master/Cricket_ODI_Predictions.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想讨论任何与数据分析、机器学习、金融或信用分析相关的问题，请随时联系<a class="ae ky" href="https://www.finlyticshub.com/" rel="noopener ugc nofollow" target="_blank"> me </a>。</p><p id="e4cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见，摇滚起来！</p></div></div>    
</body>
</html>