<html>
<head>
<title>Final Blows to the Dirty Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对脏数据的最后一击</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cross-field-validation-using-pandas-f7a316fd37b7?source=collection_archive---------28-----------------------#2020-11-15">https://towardsdatascience.com/cross-field-validation-using-pandas-f7a316fd37b7?source=collection_archive---------28-----------------------#2020-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dacb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用熊猫进行跨领域验证</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3cdf7bc5008b88f3f82af2fcfd437e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GoqtYp7BDf41rTKcS8yRQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">照片由</strong> <a class="ae kz" href="https://www.pexels.com/@ian-beckley-1278367?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ky">伊恩·贝克利</strong> </a> <strong class="bd ky">上</strong> <a class="ae kz" href="https://www.pexels.com/photo/top-view-photography-of-roads-2440013/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ky">像素</strong> </a></p></figure><h2 id="ee4e" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="5a50" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">如今，数据不再来自单一来源。通常情况下，它被收集在不同的位置，并合并在一起。合并数据时的一个常见挑战是数据完整性。简而言之，通过使用多个字段检查另一个字段的有效性来确保我们的数据是正确的。用更好的术语来说，这个过程叫做<strong class="ly iu">交叉字段验证</strong>。</p><p id="007f" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">对数据集的数据完整性进行健全性检查对于进行准确的分析和运行机器学习模型至关重要。交叉字段验证应该在您处理了大多数其他清理问题(如缺失值插补、确保字段约束到位等)之后进行。</p><p id="1d0a" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">我为这篇文章写了关于执行时间的代码片段。由于跨字段验证可能涉及对数百万个观察值跨多个列执行操作，因此执行速度非常重要。这里建议的解决方案应该具有足够的可伸缩性，甚至可以处理大规模数据集。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="e3d4" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7b9b" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">我生成了假数据来进行跨领域验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/147bdf0b5667deeeec379e341569827c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GpNhvQnZquXOfntphGEnoA.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="066d" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">交叉字段验证，示例1</h2><p id="47d2" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">在设置部分，我们加载了一个假的<code class="fe ne nf ng nh b">people</code>数据集。举例来说，我们将假设这些数据是从两个来源收集的:提供每个人的全名和生日的人口普查数据，这些数据后来与他们的医院记录合并在一起。</p><p id="c31e" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">为了进行准确的分析，我们应该确保我们的数据是有效的。在这种情况下，我们可以检查两个字段的有效性:年龄和身体质量指数(身体质量指数)。</p><p id="48fd" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">先说年龄。我们必须确保当我们从当前年份中减去他们的出生年份时，结果与<code class="fe ne nf ng nh b">age</code>列相匹配。</p><p id="9a77" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">当您执行跨字段验证时，速度应该是主要考虑的问题。与我们的小例子不同，您可能需要处理数百万次观察。对任何规模的数据集进行跨字段验证的最快方法之一是<code class="fe ne nf ng nh b">pandas</code>的<code class="fe ne nf ng nh b">apply</code>函数。</p><p id="205b" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">这里有一个简单的<code class="fe ne nf ng nh b">apply</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="efea" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">上面是一个按列执行的例子。<code class="fe ne nf ng nh b">apply</code>接受一个函数名作为参数，并在被调用的列的每个元素上调用该函数。该函数有一个额外的参数<code class="fe ne nf ng nh b">axis</code>，默认设置为<code class="fe ne nf ng nh b">0</code>或<code class="fe ne nf ng nh b">rows</code>。如果我们将其设置为<code class="fe ne nf ng nh b">1</code>或<code class="fe ne nf ng nh b">columns</code>，该功能将转换为按行执行。</p><blockquote class="ni nj nk"><p id="d3ae" class="lw lx nl ly b lz mp ju mb mc mq jx me nm mr mg mh nn ms mj mk no mt mm mn mo im bi translated">关于<code class="fe ne nf ng nh b">axis</code>参数的说明:<code class="fe ne nf ng nh b">axis='rows'</code>表示沿着垂直的行轴执行操作，因为行是垂直堆叠的。<code class="fe ne nf ng nh b">axis='columns'</code>表示沿水平的列轴执行操作，因为列是水平堆叠的。这两个术语让很多人感到困惑，因为它们看起来像是在做与他们被告知的相反的事情。事实上，只需要改变视角，或者用你愿意的话来说。</p></blockquote><p id="f873" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">让我们创建一个函数来验证一个人的年龄:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="6f0c" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">因为我们将使用<code class="fe ne nf ng nh b">apply</code>进行逐行操作，所以它的输入将是数据集的每一行。这就是为什么我们可以像在正常情况下一样轻松地访问每一列的值。</p><p id="a503" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">使用我们之前导入的<code class="fe ne nf ng nh b">datetime</code>包，我们将存储今天的日期。然后，我们通过相互减去年份来计算年龄。为此，您必须确保<code class="fe ne nf ng nh b">birthday</code>列具有<code class="fe ne nf ng nh b">datetime</code>数据类型。</p><p id="b98c" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">在<code class="fe ne nf ng nh b">return</code>语句中，我们比较了计算的年龄和给定的年龄，如果它们匹配，则返回<code class="fe ne nf ng nh b">True</code>，否则返回<code class="fe ne nf ng nh b">False</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/9e272692d902b81bf6f3188973115763.png" data-original-src="https://miro.medium.com/v2/format:webp/1*LxNYa3yYD3R8GLfvNPyREQ.png"/></div></figure><p id="0034" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">该功能按预期工作。现在，我们可以对无效年龄(如果有)的数据进行子集划分:</p><pre class="kj kk kl km gt np nh nq nr aw ns bi"><span id="7122" class="la lb it nh b gy nt nu l nv nw">people[people['age_valid'] == False]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/ea9689dcf5bdcb0c294f8abcf9790984.png" data-original-src="https://miro.medium.com/v2/format:webp/1*QSww8DRpXDgtbzTi_QLJtg.png"/></div></figure><p id="2191" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">有75行的年龄无效。如果你算一下，年龄是不匹配的。为了纠正这些值，我们可以编写一个新的函数，但是这将涉及代码重复。我们可以更新<code class="fe ne nf ng nh b">validate_age</code>来用有效值替换任何无效值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4a3b" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">我们可以使用<code class="fe ne nf ng nh b">assert</code>语句来确保操作成功:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="a47d" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">交叉字段验证，示例2</h2><p id="7023" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">接下来，我们将验证体重指数列。</p><blockquote class="ni nj nk"><p id="c5b4" class="lw lx nl ly b lz mp ju mb mc mq jx me nm mr mg mh nn ms mj mk no mt mm mn mo im bi translated">体重指数是从一个人的体重和身高得出的数值。</p></blockquote><p id="446c" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">快速的谷歌搜索给出了计算身体质量指数的公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/2745d36a46cb313a491fef0c1b0aff90.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*2roXu0_ySB_YTo1oWUUmvg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ky">图片由</strong> <a class="ae kz" href="https://www.wikipedia.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ky">维基</strong> </a>提供</p></figure><p id="cd9b" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">使用第一个示例中的思想，我们将为身体质量指数创建用正确值替换无效身体质量指数的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0bdf" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">用<code class="fe ne nf ng nh b">validate_</code>启动所有的验证函数是一个很好的实践。这向代码的读者发出了您正在执行验证的信号。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h2 id="8e05" class="la lb it bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">跨字段验证、速度比较</h2><p id="b582" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">在本节中，我们将对不同的跨字段验证方法进行速度比较。我们将从验证<code class="fe ne nf ng nh b">bmi</code>的<code class="fe ne nf ng nh b">apply</code>函数开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9c25" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">10k数据集大约需要0.3秒。接下来，我们将使用熊猫<code class="fe ne nf ng nh b">iterrows()</code>的for循环:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="12ee" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">花了10倍的时间！况且这个时间差不会是线性的。对于更大的数据集，这种差异变得越来越大。我不认为任何for循环能打败<code class="fe ne nf ng nh b">apply</code>函数，但我们也试试一般比<code class="fe ne nf ng nh b">iterrows()</code>更快的<code class="fe ne nf ng nh b">itertuples</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="bd57" class="pw-post-body-paragraph lw lx it ly b lz mp ju mb mc mq jx me lj mr mg mh ln ms mj mk lr mt mm mn mo im bi translated">还是比<code class="fe ne nf ng nh b">apply</code>慢很多。所以，跨字段验证的一般经验是总是使用<code class="fe ne nf ng nh b">apply</code>函数。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="8093" class="ny lb it bd lc nz oa ob lf oc od oe li jz of ka lm kc og kd lq kf oh kg lu oi bi translated">如果你喜欢这篇文章，请分享并留下反馈。作为一名作家，你的支持对我来说意味着一切！</h1><p id="2138" class="pw-post-body-paragraph lw lx it ly b lz ma ju mb mc md jx me lj mf mg mh ln mi mj mk lr ml mm mn mo im bi translated">阅读更多与主题相关的文章:</p><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/data-type-constraints-data-range-constraints-duplicate-data-with-pandas-44897a350b1e"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">掌握DS/ML中最耗时的任务，#1</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">处理常见的数据问题</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/master-the-most-hated-task-in-ds-ml-3b9779276d7c"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">掌握DS/ML中最讨厌的任务</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">用Pandas清理分类数据</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/fuzzywuzzy-fuzzy-string-matching-in-python-beginners-guide-9adc0edf4b35"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">FuzzyWuzzy:Python中的模糊字符串匹配，初学者指南</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">…以及在真实数据集上的动手实践</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/data-uniformity-in-data-science-9bec114fbfae"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">数据科学中的数据一致性</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">处理熊猫最常见的一致性问题</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="pd l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener follow" target="_blank" href="/meet-the-hardest-functions-of-pandas-part-i-7d1f74597e92"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">认识熊猫最难的功能，第一部分</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">掌握pivot_table()、stack()、unstack()的时机和方式</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="pe l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>