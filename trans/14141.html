<html>
<head>
<title>You Should Be Using purrr for More than Just Iteration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不应该仅仅在迭代中使用purrr</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/you-should-be-using-purrr-for-more-than-just-iteration-2884a37aba18?source=collection_archive---------33-----------------------#2020-09-29">https://towardsdatascience.com/you-should-be-using-purrr-for-more-than-just-iteration-2884a37aba18?source=collection_archive---------33-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="279c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Tidyverse包中的3个函数改进了R</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/19cb236ed94b8c65578ab98ee9c09ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPXBv1HwRgKA19sGYPMB0w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@catherineheath?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯瑟琳·希斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/cat-computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="db36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://purrr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> purrr包</a>是<a class="ae ky" href="https://www.tidyverse.org/packages/" rel="noopener ugc nofollow" target="_blank"> Tidyverse </a>的主要支柱之一，在实用性和通用性方面与<a class="ae ky" href="https://dplyr.tidyverse.org/" rel="noopener ugc nofollow" target="_blank"> dplyr </a>和管道操作器不相上下。其主要目的之一是将循环的<em class="lv">意图</em>与其<em class="lv">语法</em>对齐。在编写for循环时，不涉及一堆乏味的样板文件——它很少告诉读者循环做了什么——purrr map可以像简单的英语一样阅读，并且可以整齐地放入管道连接的操作组中。</p><p id="e040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这并不是purrr所能提供的全部。最长的一段时间，我只用了<code class="fe lw lx ly lz b">map</code>、<code class="fe lw lx ly lz b">walk</code>，以及它们的变体。从那以后，我发现了这个包的其他实用程序，它们使处理列表变得轻而易举。</p><p id="048d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这些函数一点也不隐藏，就在文档页面中的显眼位置，我觉得没有早点使用它们有点愚蠢。但是对于程序员来说，太容易陷入相同的例行程序，无意识地遵循“如果它没有坏”的思维模式。因此，为了激起您对purrr提供的鲜为人知的工具的兴趣，我选择了几个我最喜欢的工具来分享。我希望这样做会改进您的工作流，让您更加好奇这个R包还能提供什么。</p><h2 id="9a1e" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">避免用“set_names”反斜杠或替换函数</h2><p id="6179" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">现在，一个实际上是从<a class="ae ky" href="https://rlang.r-lib.org/reference/set_names.html" rel="noopener ugc nofollow" target="_blank"> rlang包</a>重新导出的函数，它本身在base R中有一个对应的可用版本，这看起来似乎是一个奇怪的起点。但是<code class="fe lw lx ly lz b">set_names</code>非常符合purrr的基本理念，我认为它是合适的。</p><p id="58fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在R中，从语法上来说，有四种类型的函数。分别是<strong class="lb iu">前缀</strong>(<strong class="lb iu"/><code class="fe lw lx ly lz b">do_something(argument)</code>)<strong class="lb iu">中缀</strong> ( <code class="fe lw lx ly lz b">+</code>、<code class="fe lw lx ly lz b">-</code>、<code class="fe lw lx ly lz b">%&gt;%</code>)<strong class="lb iu">替换</strong>(<code class="fe lw lx ly lz b">setter(x) &lt;- “eggs"</code>)<strong class="lb iu">特殊</strong>(类似<code class="fe lw lx ly lz b">if</code>的关键词)。</p><p id="0a2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，大多数阅读代码的人都非常熟悉前缀和中缀形式，尤其是来自其他语言的形式。虽然任何函数都可以通过使用反斜线以前缀形式编写，但这是R的另一个怪癖，在使代码更具可读性方面并没有起到很好的作用。</p><p id="c032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个字符向量，我们需要它们的字符长度。为了举例，我将使用像这样的简单操作，可能不需要使用列表和purrr——如果这让您感到困扰，那么想象一下我们正在做一些输出异构数据类型的更复杂的任务。</p><p id="4dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望输出列表的名称是原始字符，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="aab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意这个函数是如何很好地适应管道的。这里我利用了这样一个事实，即<code class="fe lw lx ly lz b">set_names</code>将默认给一个向量它自己的参数值作为名称。比手工创建一个命名的向量要快得多，也比在单独的一行上使用<code class="fe lw lx ly lz b">names(animal_nchars) &lt;- animals</code>漂亮得多。</p><h2 id="ae23" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">用“cross”避免嵌套循环</h2><p id="14a0" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">假设我们有两个不同长度的字符向量，我们希望将它们中的元素粘贴到一起，作为另一个字符向量返回。我们可以这样使用嵌套地图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="98b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这种方法很难阅读，并且需要一些额外的工作来获得一个字符向量。虽然像<a class="ae ky" href="https://purrr.tidyverse.org/reference/map2.html" rel="noopener ugc nofollow" target="_blank"> map2和pmap </a>这样的工具可以很好地处理相同长度的输入，但是在条件不太整洁的情况下它们就不起作用了。此外，内循环返回长度大于1的向量的事实阻止了我们在外循环中使用<code class="fe lw lx ly lz b">map_chr</code>。</p><p id="925a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请考虑这种方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="bdc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了，你不觉得吗？对于更复杂的函数，如果使用公式的话，我喜欢手动解包<code class="fe lw lx ly lz b">.</code>或<code class="fe lw lx ly lz b">.x</code>,只是为了让内容更具可读性。在决定是利用特定语言的速记来节省自己的时间，还是使用更冗长的速记来方便其他人时，总会有一点权衡。</p><h2 id="f69d" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">使用“保持”和“压缩”进行过滤</h2><p id="ce9d" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">在我的工作场所，我处理大量的空间数据。当跨地理区域迭代时，过程经常因为简单的数据覆盖原因而失败。我发现<a class="ae ky" href="https://purrr.tidyverse.org/reference/keep.html" rel="noopener ugc nofollow" target="_blank"> compact </a>函数对于在探索阶段过滤掉这些故障非常有用。</p><p id="b40f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于更持久的代码，最好明确要丢弃哪些元素，因此使用<code class="fe lw lx ly lz b">keep</code>可能是更好的选择，因为它让您指定一个谓词。</p><p id="6b30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">r有多个<a class="ae ky" href="https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/00Index.html" rel="noopener ugc nofollow" target="_blank">内置数据集</a>。假设我们想要列出它们的列名，但前提是它们必须以dataframes的形式存储。这是可以做到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于内置数据集是base R的一个怪癖，以编程方式访问它们有点奇怪，因此使用了<code class="fe lw lx ly lz b">get</code>。关于上面的片段，需要注意一些事情:</p><ul class=""><li id="276b" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">因为不是所有列出的数据集都被成功检索，所以我使用<code class="fe lw lx ly lz b">possibly</code>和<code class="fe lw lx ly lz b">compact</code>来过滤掉这些失败。</li><li id="7648" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">“仅当它们作为数据帧存储时”部分由管道的第4行中的<code class="fe lw lx ly lz b">keep</code>完成。</li><li id="1c52" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">注意<code class="fe lw lx ly lz b">set_names</code>是如何再次派上用场的，这样在过滤完成后，我们就知道每组列名与哪个数据集相关联。</li></ul></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="81c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里仅仅触及了表面，我的例子不可否认地有点做作，但是我希望我至少已经说服了你自己去探究除了使迭代更可读之外，purrr还能为你做些什么。</p><p id="ff7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，伴随着所有伟大的锤子而来的是责任，不要把一切都看成钉子。R中的列表通常不是保存数据的最佳数据结构选择。如果您可以将事情存储在数据帧中，并使用dplyr而不是purrr来实现您的目的，那么您应该这样做！</p><p id="78b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于处理列表的时候，purrr是一个很好的工具，但是经常没有被充分利用。祝你好运！</p></div></div>    
</body>
</html>