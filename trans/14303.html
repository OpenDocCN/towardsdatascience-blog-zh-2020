<html>
<head>
<title>The Way You Version Control Your ML Projects is Wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你控制ML项目版本的方式是错误的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-way-you-version-control-your-ml-projects-is-wrong-42910cba9bd9?source=collection_archive---------27-----------------------#2020-10-02">https://towardsdatascience.com/the-way-you-version-control-your-ml-projects-is-wrong-42910cba9bd9?source=collection_archive---------27-----------------------#2020-10-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="65c7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当您可以拥有更多时，是否在寻找一种类似git的数据版本控制方法？是时候跳出框框思考了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5e4e2a266c76602f707872f9a5a71e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlhJFHP8LLkOpN05bkST5g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">抓拍您的数据—照片由<a class="ae ky" href="https://unsplash.com/@adrienolichon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿德里安·奥利琼</a>在<a class="ae ky" href="https://unsplash.com/s/photos/polaroid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ba31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学家和机器学习工程师倾向于像管道这样的预测分析项目；接受明确定义的输入以产生特定输出的生产线。这些相互关联的步骤(例如，数据采集、数据处理、数据建模等。)一起朝着最终目标努力，但它们也可以是独立的过程，以自己的节奏运行。</p><blockquote class="lv"><p id="fc1b" class="lw lx it bd ly lz ma mb mc md me lu dk translated">如果有一种方法可以自动对每个ML管道步骤的结果进行版本控制，这不是很好吗？</p></blockquote><p id="05bc" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">ML管道中的步骤通常输出转换后的数据集，我们手动对其进行版本控制，并将其移动到对象存储桶。但是它们也可以产生各种其他工件，从原始变量到训练好的ML模型。那么，我们如何将所有这些事情版本化呢？腌制一切？饭桶？也许是LFS？如果有一种方法能够自动将所有这些结果版本化不是很好吗？</p><p id="ca90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个故事中，我们向你展示了如何自动地将你在项目中所做的最微小的改变版本化，而无需思考。咱们<strong class="lb iu"> </strong>开始吧！</p><blockquote class="mk ml mm"><p id="da8e" class="kz la mn lb b lc ld ju le lf lg jx lh mo lj lk ll mp ln lo lp mq lr ls lt lu im bi translated"><a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank">学习率</a>是为那些对AI和MLOps的世界感到好奇的人准备的时事通讯。你会在每周五收到我关于最新人工智能新闻和文章的更新和想法。在这里订阅<a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank"/>！</p></blockquote></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="e501" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">ML的版本控制</h1><p id="e8b1" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">数据科学家大部分时间都在Jupyter笔记本中探索数据和起草想法。通常，当我们试图对我们的工作进行版本化时，我们最终会得到一堆重复的<code class="fe nv nw nx ny b">ipynb</code>文件，采用不同的命名方案。</p><blockquote class="lv"><p id="cd9a" class="lw lx it bd ly lz ma mb mc md me lu dk translated">在ML管道的每一步之前和之后，我们能有自动拍摄我们工作的东西吗？此外，我们能在不需要大量配置的情况下开始使用它吗？只要打开一个笔记本，做我们的事情，并确保其他事情会照顾自己。</p></blockquote><p id="2d14" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">另一方面，众所周知，使用Git很难跟踪笔记本，而使用流行的VCS进行数据集版本控制是不可能的。Git大文件存储(LFS)用Git内部的文本指针替换音频样本、视频、数据集和图形等大文件，并将文件内容存储在远程服务器上；不理想。</p><p id="c76d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人也可以尝试<a class="ae ky" href="https://dvc.org/" rel="noopener ugc nofollow" target="_blank"> DVC </a>，但这只是一种类似Git的数据版本控制方法。这通常会让数据科学家更加头疼，他们不想学习另一种工具来完成工作。</p><p id="fedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能不能在ML流水线的每一步之前和之后都有自动抓拍我们工作的东西？此外，我们能在不需要大量配置的情况下开始使用它吗？只要打开一个笔记本，做我们的事情，并确保其他事情会照顾自己。是的，我们可以！让我们看看怎么做。</p><h1 id="962f" class="my mz it bd na nb nz nd ne nf oa nh ni jz ob ka nk kc oc kd nm kf od kg no np bi translated">设置工作空间</h1><p id="8a2e" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">因此，对我们在项目中所做的一切进行自动版本控制似乎有些极端，对吗？如果你对GCP使用MiniKF就不会了。安装MiniKF非常简单；我们需要的只是一个GCP帐户和从市场部署应用程序的能力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/e664c7d07f206994b12b5fd675649c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hXdiz3nntc4h068E.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MiniKF部署—作者图片</p></figure><ol class=""><li id="c41d" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">访问GCP页面上的<a class="ae ky" href="https://console.cloud.google.com/marketplace/details/arrikto-public/minikf" rel="noopener ugc nofollow" target="_blank">MiniKF</a></li><li id="7c81" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">选择<em class="mn">启动，设置虚拟机配置并点击部署</em></li></ol><blockquote class="mk ml mm"><p id="a329" class="kz la mn lb b lc ld ju le lf lg jx lh mo lj lk ll mp ln lo lp mq lr ls lt lu im bi translated">为了获得最佳性能，建议保留默认的虚拟机配置</p></blockquote><p id="5c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！部署最多需要十分钟，您可以按照屏幕上的说明观看进度；ssh进入机器，在终端上运行<code class="fe nv nw nx ny b">minikf</code>,等待直到您的端点和凭证准备好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/6f7334178c70626bfe61dcadf6de1312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*m88fp4Ps1mZ6V8eS.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MiniKF的提供已完成—图片由作者提供</p></figure><p id="5ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们准备访问Kubeflow仪表板。点击网址，输入你的凭证，你就可以开始了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f51d7c333f536a240c85ed48e700a043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dLdY998J5TKAUZIv.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kubeflow仪表板—按作者分类的图像</p></figure><h2 id="8f25" class="ov mz it bd na ow ox dn ne oy oz dp ni li pa pb nk lm pc pd nm lq pe pf no pg bi translated">运行Jupyter服务器</h2><p id="4927" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">那么，还剩下什么？我们需要一个Jupyter笔记本实例。使用提供的Jupyter Web应用程序，在MiniKF中创建Jupyter笔记本相对容易:</p><ol class=""><li id="870c" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">从左侧面板中选择笔记本</li><li id="a1e6" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">选择<code class="fe nv nw nx ny b">New Server</code>按钮</li><li id="02ed" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">填写服务器名称，请求您需要的CPU和RAM数量，然后点击<code class="fe nv nw nx ny b">LAUNCH</code></li></ol><blockquote class="mk ml mm"><p id="d70f" class="kz la mn lb b lc ld ju le lf lg jx lh mo lj lk ll mp ln lo lp mq lr ls lt lu im bi translated">按照本教程，保持Jupyter笔记本图像不变(<code class="fe nv nw nx ny b"><em class="it">jupyter-kale:v0.5.0-47-g2427cc9</em></code> —注意图像标签可能不同)</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2101b0fd9a8f46df8d260f1b8c833e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A0tTUmxTMCIBrIwk.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建Jupyter服务器—作者图片</p></figure><p id="0ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成这四个步骤后，等待笔记本服务器准备好并连接。你将被转移到你熟悉的JupyterLab工作区。</p><h1 id="8c1b" class="my mz it bd na nb nz nd ne nf oa nh ni jz ob ka nk kc oc kd nm kf od kg no np bi translated">这是一种魔法</h1><p id="62a0" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">在下面的故事中，我们看到了如何将Jupyter笔记本转换成Kubeflow管道，而无需编写任何代码。</p><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/jupyter-is-ready-for-production-as-is-b36f1d1ca8f8"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">Jupyter准备生产；原样</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">无需编写一行代码，即可将您的笔记本草稿转化为生产就绪的Kubeflow管道。</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div><p id="e9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，要使用当前的示例，您应该首先在JupyterLab环境中打开一个终端并克隆repo:</p><pre class="kj kk kl km gt pz ny qa qb aw qc bi"><span id="eb9e" class="ov mz it ny b gy qd qe l qf qg">git clone <a class="ae ky" href="https://github.com/dpoulopoulos/medium.git" rel="noopener ugc nofollow" target="_blank">https://github.com/dpoulopoulos/medium.git</a></span></pre><p id="b395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将目录更改为<code class="fe nv nw nx ny b">medium &gt; minikf</code>并启动<code class="fe nv nw nx ny b">titanic.ipynb</code>笔记本。取消对第一个代码单元的注释，然后运行它，将必要的依赖项安装到您的环境中。然后，让<strong class="lb iu"> Kale </strong>接手！</p><p id="fa39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查笔记本的左侧面板，您会看到一个紫色图标。这是有趣的开始…按下它来启用羽衣甘蓝扩展。你会自动看到每个单元格都被标注了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/9a5e0a3c1301f4f331b33b05b53684a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2RogDdR9upYnAbXC.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启用Kale扩展-按作者分类的图像</p></figure><p id="5ce2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到笔记本是分节的；导入、数据加载部分、数据处理、模型训练和评估等。这正是我们用羽衣甘蓝注释的。现在，这个笔记本是预先注释好的，但是你可以随意使用。您可以创建新的管道步骤，但是不要忘记添加它们的依赖项。</p><p id="cb5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何情况下，你都可以点击位于羽衣甘蓝部署面板底部的<code class="fe nv nw nx ny b">COMPILE AND RUN</code>按钮。无需编写一行代码，您的笔记本将被转换为Kubeflow管道，该管道将作为新实验的一部分执行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/36bde26f4ffc65e8fd5ffd9adc5536fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ok-YacpUzWLPONs0.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从Jupyter笔记本到Kubeflow管道——作者图片</p></figure><p id="f833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照Kale提供的链接观看跑步实验。几分钟后，管道将成功完成其任务。这是图表的最终视图(不要忘记切换左上角的<code class="fe nv nw nx ny b">Simplify Graph</code>选项):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/4040991d88d57266ea836e5e347dd3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sqC_PoA_SQHBYzJ-.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泰坦尼克号管道——作者图片</p></figure><p id="bab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你仔细观察，Kale做的第二件事是使用<a class="ae ky" href="https://www.kubeflow.org/docs/other-guides/integrations/data-management/" rel="noopener ugc nofollow" target="_blank"> Rok </a>给笔记本拍快照。此外，在管道的每一步之前和之后，它都会这样做。因此，我们可以在任何时候回到我们环境的状态。我们如何做到这一点？</p><h2 id="54d7" class="ov mz it bd na ow ox dn ne oy oz dp ni li pa pb nk lm pc pd nm lq pe pf no pg bi translated">韩国快照</h2><p id="cff0" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">Rok是一个数据管理产品，允许您对您的<strong class="lb iu">完整环境及其数据</strong>进行快照、版本化、打包、分发和克隆。它作为其支持的平台之一与Kubernetes进行了本机集成，并在几分钟内部署到现有集群、本地或云上。</p><p id="9d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它预装在MiniKF中，所以让我们使用它！假设您想在运行SVM分类器之前返回您的环境状态。</p><ol class=""><li id="bced" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">点击<code class="fe nv nw nx ny b">smv</code>步骤并选择<code class="fe nv nw nx ny b">Visualizations</code>选项卡</li><li id="ded5" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">跟随<code class="fe nv nw nx ny b">Rok autosnapshot</code>卡内的链接</li><li id="0428" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">复制页面顶部的韩国网址</li><li id="267d" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">创建一个新的笔记本服务器，并在顶部粘贴复制的网址</li><li id="dcec" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">配置虚拟机资源，并为工作区指定一个有效的名称</li><li id="5cf3" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">点击<code class="fe nv nw nx ny b">LAUNCH</code>按钮</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/d4b760500171f98bac9c9b6ed9d30c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zpKIS2B7d42gcbaKDN-ZAg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与韩国同行——作者图片</p></figure><p id="b1a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">当笔记本服务器准备好了，连接上它，一个新的JupyterLab环境将会准确地在你请求的点打开。到目前为止的所有单元格都已为您执行。</strong>您可以从该单元格继续工作；探索变量状态、数据集并训练模型。这下好了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/b92d705e012a35fae4251da38d04e716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jVGbmZiHh22U5fthyIkjbw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">继续你的JupyterLab状态——作者图片</p></figure><h1 id="9ebc" class="my mz it bd na nb nz nd ne nf oa nh ni jz ob ka nk kc oc kd nm kf od kg no np bi translated">结论</h1><p id="696f" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">在这个故事中，我们看到了如何在Jupyter笔记本上修改我们的作品，甚至不用去想它。我们在MiniKF上运行的每个实验都是分步进行的，我们可以使用Rok在任何时间点返回。</p><p id="b452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续使用MiniKF在Kubeflow中运行您的实验。您的工作流将保持不变，但在许多方面进行了扩展，没有任何样板代码。</p><h2 id="7415" class="ov mz it bd na ow ox dn ne oy oz dp ni li pa pb nk lm pc pd nm lq pe pf no pg bi translated">关于作者</h2><p id="4515" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">我的名字是<a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank">迪米特里斯·波罗普洛斯</a>，我是一名为<a class="ae ky" href="https://www.arrikto.com/" rel="noopener ugc nofollow" target="_blank">阿里克托</a>工作的机器学习工程师。我曾为欧洲委员会、欧盟统计局、国际货币基金组织、欧洲中央银行、经合组织和宜家等主要客户设计和实施人工智能和软件解决方案。</p><p id="97c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣阅读更多关于机器学习、深度学习、数据科学和数据操作的帖子，请在twitter上关注我的<a class="ae ky" href="https://medium.com/@dpoulopoulos" rel="noopener"> Medium </a>、<a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae ky" href="https://twitter.com/james2pl" rel="noopener ugc nofollow" target="_blank"> @james2pl </a>。</p><p id="884d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所表达的观点仅代表我个人，并不代表我的雇主的观点或意见。</p></div></div>    
</body>
</html>