<html>
<head>
<title>MLflow Part 2: Deploying a Tracking Server to Minikube!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MLflow第2部分:将跟踪服务器部署到Minikube！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mlflow-part-2-deploying-a-tracking-server-to-minikube-a2d6671e6455?source=collection_archive---------8-----------------------#2020-10-08">https://towardsdatascience.com/mlflow-part-2-deploying-a-tracking-server-to-minikube-a2d6671e6455?source=collection_archive---------8-----------------------#2020-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f38000f037e55890fe41f5ab65d32cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKJbJlMZXA9m3fUxoWxnPw.png"/></div></div></figure><h2 id="1dc2" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">MLflow 101</h2><div class=""/><div class=""><h2 id="88ca" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">在Minikube上运行的单个服务器中创建一个用于记录和跟踪模型工件的点</h2></div><p id="ea54" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="ly"> 10/15/20更新:在撰写本系列的下一篇文章时，我发现了几个妨碍我正确部署Minikube的错误。为此，我更新了一些内容，让您可以使用一个工作实例！😃</em></p><p id="a171" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">欢迎回来，朋友们！我们继续关注MLflow上的迷你系列。如果你错过了第一部分，一定要在这里查看<a class="ae lz" rel="noopener" target="_blank" href="/mlflow-part-1-getting-started-with-mlflow-8b45bfbbb334">。第一篇文章是关于MLflow的日志基本参数、度量和工件的超级基础介绍。这只是让我们将这些项目记录到本地机器上的一个位置，这不是一个理想的做法。在公司环境中，理想情况下，您希望将所有这些东西记录到一个集中的、可重用的位置。这就是我们今天要解决的问题！当然，你可以在这个链接</a>找到我在GitHub <a class="ae lz" href="https://github.com/dkhundley/ds-quick-tips/tree/master/009_mlflow_tracking_server" rel="noopener ugc nofollow" target="_blank">上的所有代码。</a></p><p id="9ee5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所以要明确的是，我们将涉及一些高级主题，这些主题需要一些关于Docker和Kubernetes的知识。我个人计划以后再写关于这些的文章，但是现在，如果你想快速开始使用Docker和Kubernetes，我推荐以下资源:</p><ul class=""><li id="3eb3" class="ma mb je le b lf lg li lj ll mc lp md lt me lx mf mg mh mi bi translated"><a class="ae lz" href="https://www.docker.com/101-tutorial" rel="noopener ugc nofollow" target="_blank"> Docker 101教程</a></li><li id="479e" class="ma mb je le b lf mj li mk ll ml lp mm lt mn lx mf mg mh mi bi translated"><a class="ae lz" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" rel="noopener ugc nofollow" target="_blank">学习Kubernetes基础知识</a></li></ul><p id="e77a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">现在，如果你知道Kubernetes，你很可能熟悉Minikube，但如果你不熟悉，Minikube基本上是一个小虚拟机，你可以在本地机器上运行，启动一个沙盒环境来测试Kubernetes的概念。一旦Minikube建立并运行，对于那些在合法的Kubernetes环境中工作过的人来说，它看起来会非常熟悉。设置Minikube的说明在本页中有很好的记录<a class="ae lz" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank">，但是为了让Minikube工作，我们需要在这篇文章的后面添加一些额外的东西。</a></p><p id="cbcc" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在继续之前，我认为一张图片胜过千言万语，所以下面是我们将在这里建造的建筑的一张小图片。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/854abf94e30a7b13e3c6578aa12b61f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKKuQCQnIcWLZK0XWFqHCw.png"/></div></div></figure><p id="e949" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好的，右边是我们的小型环境。同样，Minikube是合法的Kubernetes环境的高度代表，所以Minikube中的所有东西都是我们在任何Kubernetes工作区中看到的。因此，我们可以看到MLflow的跟踪服务器部署在部署内部。该部署通过将服务连接到入口与外部世界进行交互(这就是为什么在我们的图片中入口跨越内部和外部)，然后我们可以在web浏览器中查看跟踪服务器界面。很简单，对吧？</p><p id="21a2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好的，第一步是创建一个Docker映像，用于构建MLflow跟踪服务器。这真的很简单，我个人已经上传了我的公众形象，以防你想跳过这第一步。这是我个人Docker Hub中的图片。)Dockerfile将简单地构建在一个基本的Python映像之上，安装MLflow，并设置适当的entrypoint命令。看起来像这样:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="685a" class="mx my je mt b gy mz na l nb nc"># Defining base image<br/>FROM python:3.8.2-slim</span><span id="f416" class="mx my je mt b gy nd na l nb nc"># Installing packages from PyPi<br/>RUN pip install mlflow[extras]==1.9.1 &amp;&amp; \<br/>    pip install psycopg2-binary==2.8.5 &amp;&amp; \<br/>    pip install boto3==1.15.16</span><span id="e3ab" class="mx my je mt b gy nd na l nb nc"># Defining start up command<br/>EXPOSE 5000<br/>ENTRYPOINT ["mlflow", "server"]</span></pre><p id="d4df" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你知道这里的流程:建造并推进到Docker Hub！(或者就用我的。)</p><p id="37a9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><em class="ly">我们10-15-20更新开始的地方！</em></p><p id="0f10" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好的，在这篇文章的前一次迭代中，我试图使用一个简单的PVC来存储元数据和工件。事实证明这并不容易。相反，我们将不得不做一些额外的跑腿工作来让它在Minikube上运行。为此，我们将为后端元数据配置一个Postgres存储，并为工件配置一个名为Minio的对象存储。(下面有更多关于Minio的内容，以防你没听说过。)如果这两件事听起来都让你望而生畏，那没关系！您可以简单地使用我的代码来启动和运行。</p><p id="d48d" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好吧，让我们来解决Postgres的部署问题。以下是K8s清单代码:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9f84" class="mx my je mt b gy mz na l nb nc">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: mlflow-postgres-config<br/>  labels:<br/>    app: mlflow-postgres<br/>data:<br/>  POSTGRES_DB: mlflow_db<br/>  POSTGRES_USER: mlflow_user<br/>  POSTGRES_PASSWORD: mlflow_pwd<br/>  PGDATA: /var/lib/postgresql/mlflow/data<br/>---<br/>apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>  name: mlflow-postgres<br/>  labels:<br/>    app: mlflow-postgres<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: mlflow-postgres<br/>  serviceName: "mlflow-postgres-service"<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mlflow-postgres<br/>    spec:<br/>      containers:<br/>      - name: mlflow-postgres<br/>        image: postgres:11<br/>        ports:<br/>        - containerPort: 5432<br/>          protocol: TCP<br/>        envFrom:<br/>        - configMapRef:<br/>            name: mlflow-postgres-config<br/>        resources:<br/>          requests:<br/>            memory: "1Gi"<br/>            cpu: "500m"<br/>        volumeMounts:<br/>        - name: mlflow-pvc<br/>          mountPath: /var/lib/postgresql/mlflow<br/>  volumeClaimTemplates:<br/>  - metadata:<br/>      name: mlflow-pvc<br/>    spec:<br/>      accessModes: [ "ReadWriteOnce" ]<br/>      resources:<br/>        requests:<br/>          storage: 100Mi<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mlflow-postgres-service<br/>  labels:<br/>    svc: mlflow-postgres-service<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>  - port: 5432<br/>    targetPort: 5432<br/>    protocol: TCP<br/>  selector:<br/>    app: mlflow-postgres</span></pre><p id="7732" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，我不会一行一行地介绍所有内容，但在1000英尺的高度上，我将启动一个Postgres实例，它具有100兆字节的存储空间，并在代码顶部定义了适当的配置信息。如果你愿意，你可以改变这些变量。记住，我们只是在这里学习，所以这些变量显然是暴露的。在现实世界中，这是一个巨大的安全问题，所以如果您打算将它用于合法部署，请不要听从我的建议。</p><p id="38c0" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好了，部署好之后，我们就可以开始处理我们的对象存储了:Minio。现在，如果你像我一样对Minio完全陌生，它基本上是一个对象存储，你可以部署到K8s，基本上模仿亚马逊网络服务(AWS)的S3服务。其部署语法如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="27c3" class="mx my je mt b gy mz na l nb nc">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: mlflow-minio<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: mlflow-minio<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mlflow-minio<br/>    spec:<br/>      volumes:<br/>      - name: mlflow-pvc<br/>        persistentVolumeClaim:<br/>          claimName: mlflow-pvc<br/>      containers:<br/>      - name: mlflow-minio<br/>        image: minio/minio:latest<br/>        args:<br/>        - server<br/>        - /data<br/>        volumeMounts:<br/>        - name: mlflow-pvc<br/>          mountPath: '/data'<br/>        env:<br/>        - name: MINIO_ACCESS_KEY<br/>          value: "minio"<br/>        - name: MINIO_SECRET_KEY<br/>          value: "minio123"<br/>        ports:<br/>        - containerPort: 9000<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mlflow-minio-service<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>  - port: 9000<br/>    targetPort: 9000<br/>    protocol: TCP<br/>  selector:<br/>    app: mlflow-minio<br/>---<br/>apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: mlflow-minio-ingress<br/>  annotations:<br/>    kubernetes.io/ingress.class: nginx<br/>    nginx.ingress.kubernetes.il/add-base-url: "true"<br/>    nginx.ingress.kubernetes.io/ssl-redirect: "false"<br/>spec:<br/>  rules:<br/>  - host: mlflow-minio.local<br/>    http:<br/>      paths:<br/>        - backend:<br/>            serviceName: mlflow-minio-service<br/>            servicePort: 9000<br/>          path: /<br/>---<br/>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: mlflow-pvc<br/>spec:<br/>  accessModes:<br/>    - ReadWriteMany<br/>  resources:<br/>    requests:<br/>      storage: 100Mi</span></pre><p id="38d6" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，从高层次来看，我们正在部署一个Minio对象存储，由一个拥有100兆数据的PVC提供支持。您还可以在部署的环境变量中看到，我们定义了访问密钥ID和秘密访问密钥。这些与AWS的AWS_ACCESS_KEY_ID和AWS_SECRET_ACCESS_KEY非常相关。现在，在进入下一步之前，你必须正确配置你的机器的入口，在我最初的帖子中，我在下面分享了如何做。(我懒得在这里重新输入，所以为ingress做一个CTRL+F，我相信你会找到它！)</p><p id="dd49" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好的，如果您正确配置了入口，并在浏览器中导航到mlflow-minio.local，您应该会看到这个闪屏。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/4fc945de91a8390d6a694e1ae9874de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*poJASYjHFr_GQMdvh0jIhQ.png"/></div></div></figure><p id="192c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在相应的字段中，键入我们在Minio部署中定义的访问密钥和秘密密钥。(如果你和我保持一致，那分别是“minio”和“minio123”。)点击回车键进入下一个屏幕。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/df4ce2c68e12329e253e2368a9f8af18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cy3hrzvdU0NX5p1aVS7M7g.png"/></div></div></figure><p id="0876" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好的，在我的例子中，我已经创建了“桶”,我们将使用它来存储我们的工件。对于您来说，只需单击UI右下角的orangish加号，选择“创建新桶”，并将您的新桶命名为“mlflow”即可。</p><p id="d39c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">唷！好了，我们已经设置好了后端的东西！是时候让实际的服务器开始运转了！</p><p id="dc31" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我将主要坚持使用这里的部署清单。大多数语法对您来说都很熟悉。这里唯一需要注意的是我们将传递给建筑Docker图像的参数。让我先向您展示一下我的部署清单。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="739e" class="mx my je mt b gy mz na l nb nc"># Creating MLflow deployment<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: mlflow-deployment<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: mlflow-deployment<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mlflow-deployment<br/>    spec:<br/>      containers:<br/>      - name: mlflow-deployment<br/>        image: dkhundley/mlflow-server:1.0.3<br/>        imagePullPolicy: Always<br/>        args:<br/>        - --host=0.0.0.0<br/>        - --port=5000<br/>        - --backend-store-uri=postgresql://mlflow_user:mlflow_pwd@10.98.160.170:5432/mlflow_db<br/>        - --default-artifact-root=s3://mlflow/<br/>        - --workers=2<br/>        env:<br/>        - name: MLFLOW_S3_ENDPOINT_URL<br/>          value: <a class="ae lz" href="http://mlflow-minio.local/" rel="noopener ugc nofollow" target="_blank">http://mlflow-minio.local/</a><br/>        - name: AWS_ACCESS_KEY_ID<br/>          value: "minio"<br/>        - name: AWS_SECRET_ACCESS_KEY<br/>          value: "minio123"<br/>        ports:<br/>        - name: http<br/>          containerPort: 5000<br/>          protocol: TCP<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mlflow-service<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>    - port: 5000<br/>      targetPort: 5000<br/>      protocol: TCP<br/>      name: http<br/>  selector:<br/>    app: mlflow-deployment<br/>---<br/>apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: mlflow-ingress<br/>  annotations:<br/>    kubernetes.io/ingress.class: nginx<br/>    nginx.ingress.kubernetes.il/add-base-url: "true"<br/>spec:<br/>  rules:<br/>  - host: mlflow-server.local<br/>    http:<br/>      paths:<br/>        - backend:<br/>            serviceName: mlflow-service<br/>            servicePort: 5000<br/>          path: /</span></pre><p id="24e2" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这里需要指出几个关键点。首先，Postgres实例在“args”中用其IP地址引用。我通过运行以下命令获得了该IP地址:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b265" class="mx my je mt b gy mz na l nb nc">kubectl get services</span></pre><p id="2463" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这会给你这个屏幕:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/451632f03e63307f1d1e93c4f4bace21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYkCYf5E6K3YBB7iYtoZFQ.png"/></div></div></figure><p id="f178" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">您会注意到mlflow-postgres-service的CLUSTER-IP与我的服务器部署清单中的内容直接相关。无论你的服务显示什么，你都需要更新你的IP，因为它可能和我的不一样。(说实话……我觉得有一种编程方式可以做到这一点，但我真的不知道该怎么做。)还要注意我们是如何将Minio称为后端服务器的。对你来说，我们确实在使用类似AWS的环境变量可能看起来很奇怪，但是，嘿，这就是它的工作方式！</p><p id="160a" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好了，现在我们已经成功部署了一切，是时候让我们的Minikube入口工作了。如果你在一个合法的Kubernetes环境中工作，你可能不会有这个问题，但是Minikube在这里可能有点棘手。老实说，这最后一部分花了我好几天才弄明白，所以我很高兴终于把这些知识传授给你了！</p><p id="81e9" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">让我们再看一眼YAML入口:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="dda4" class="mx my je mt b gy mz na l nb nc"># Creating the Minikube ingress<br/>apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: mlflow-ingress<br/>  annotations:<br/>    kubernetes.io/ingress.class: nginx<br/>    nginx.ingress.kubernetes.il/add-base-url: "true"<br/>spec:<br/>  rules:<br/>  - host: mlflow-server.local<br/>    http:<br/>      paths:<br/>        - backend:<br/>            serviceName: mlflow-service<br/>            servicePort: 5000<br/>          path: /</span></pre><p id="cfb5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这其中的大部分你应该很熟悉。在我们的示例中，我们将在mlflow-server.local上提供MLflow跟踪服务器的UI。对您来说可能比较陌生的一点是那些注释，它们是绝对必要的。没有它们，您的入口将无法正常工作。我特意把下面的图片贴到Twitter上，试图让人们帮我解决黑屏问题。这很令人沮丧。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/079937cec5eb81770ccf8b62613134bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3bZBDs-hZqt-H3gZW33TA.jpeg"/></div></div></figure><p id="a0b5" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">呸，真是一团糟！经过反复试验，我终于发现上面提供的特定注释配置是有效的。老实说，我不能告诉你为什么。\_(ツ)_/</p><p id="0cc4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是等等，还有呢！默认情况下，Minikube没有设置为开箱即可处理入口。为了做到这一点，你需要做一些事情。首先，在Minikube服务器运行之后，运行以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="eb60" class="mx my je mt b gy mz na l nb nc">minikube addons enable ingress</span></pre><p id="a068" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">很简单。现在，您需要设置您的计算机，以通过我们在入口中设置的mlflow-server.local主机引用Minikube集群的IP。要获取Minikube的IP地址，只需运行以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="99a8" class="mx my je mt b gy mz na l nb nc">minikube ip</span></pre><p id="dee4" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">把它复制到你的剪贴板上。现在，下一部分对你来说可能是全新的。(至少，对我来说是这样！)就像您可以为Linux创建别名命令一样，您显然也可以创建从IP地址到web地址的别名关系。这非常有趣，因为我了解到这是您的浏览器将“localhost”翻译为您的本地IP地址的地方。</p><p id="3045" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">要导航到需要这样做的位置，请运行以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6540" class="mx my je mt b gy mz na l nb nc">sudo nano /etc/hosts</span></pre><p id="d280" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">您应该会看到一个类似这样的屏幕:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/8fa2e3d6806ef67e7b8c27d790a921eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d31jii-kPavtF_vkJWaSBQ.png"/></div></div></figure><p id="6a3c" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因此，您可以在顶部看到我刚才提到的本地主机。打开这个接口，粘贴您的Minikube的IP地址(在我的例子中是192.168.64.4 ),然后粘贴MLflow服务器和Minio工件存储的主机名，在我们的例子中分别是mlflow-server.local和mlflow-minio.local。</p><p id="7901" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">好的，如果你做了所有正确的事情，你应该已经准备好了！导航到您选择的浏览器，打开<a class="ae lz" href="http://mlflow-server.local." rel="noopener ugc nofollow" target="_blank">http://ml flow-server . local .</a>如果一切顺利，您应该会看到一个熟悉的屏幕。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/626ef36547ef6d838e07ce13da4015be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtScuTgXEJ25tvtAW9bkXg.png"/></div></div></figure><p id="2a4e" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这就是这篇文章的全部内容，各位！我不想给你们带来太多负担，所以在我们的下一篇文章中，我们将从这里开始，在这个共享的跟踪服务器上记录一两个实践模型，看看它是否工作。在接下来的两篇文章中，我们将进一步展示如何从这个跟踪服务器部署模型。所以说实话，这篇文章的内容可能没有那么迷人，但我们正在铺设火车轨道，它将在接下来的几篇文章中让一切真正飞起来。</p><p id="93ad" class="pw-post-body-paragraph lc ld je le b lf lg ko lh li lj kr lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">在那之前，感谢你阅读这篇文章！请务必查看我以前关于其他数据科学相关主题的文章，下周我们将看到更多MLflow内容！</p></div></div>    
</body>
</html>