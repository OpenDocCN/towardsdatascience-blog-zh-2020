<html>
<head>
<title>Understanding Confusion Matrix, Precision-Recall, and F1-Score</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解混淆矩阵、精确回忆和F1分数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-confusion-matrix-precision-recall-and-f1-score-8061c9270011?source=collection_archive---------5-----------------------#2020-10-19">https://towardsdatascience.com/understanding-confusion-matrix-precision-recall-and-f1-score-8061c9270011?source=collection_archive---------5-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="63c4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么在评估机器学习模型时，准确性不应该是你唯一关心的性能指标</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e170c0c4857c37264229edb293276756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5MxzxX6dRF9qU36oJ0wPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">封面图片(图片由<a class="ae kv" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>提供，经作者许可编辑)</p></figure><p id="89d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di">当</span>我过去几天在Kaggle浏览几本笔记本时，我不禁注意到一些名为<em class="mb">“在dataset_name上实现100%的准确性”、“使用algorithm_name实现完美的100%准确性”、</em>的笔记本，以及其他各种关于如何在你遇到的每个数据集上实现100%准确性的指南。虽然其中一些笔记本在构建数据集的概化模型方面做得很好，并提供了相当好的结果，但大多数笔记本只是对数据进行了过度拟合。</p><blockquote class="mc md me"><p id="f29c" class="kw kx mb ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated"><strong class="ky ir">过度拟合</strong>是指产生的分析过于紧密或精确地对应于一组特定的数据，因此可能无法拟合额外的数据或可靠地预测未来的观察结果— <a class="ae kv" href="https://en.wikipedia.org/wiki/Overfitting" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="9646" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一切中最悲伤的部分是什么？他们甚至没有意识到，在试图达到那个黄金数字时，他们对数据集进行了过度拟合。大多数笔记本都是在初学者友好的数据集上找到的，比如“Iris数据集”或“Titanic数据集”,这是有意义的，对吗？我们大多数人在开始机器学习的时候只学到了一件事:<em class="mb">“准确性很重要”</em>。虽然这是真的，但这只是在一定程度上有关系。这就是为什么我将讨论其他一些性能指标，如混淆矩阵、精确召回和F1分数，在评估机器学习模型时，您应该考虑与准确性一起使用。让我们开始吧。</p><h1 id="b654" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">混淆矩阵</h1><blockquote class="mc md me"><p id="44da" class="kw kx mb ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated">在机器学习领域，特别是统计分类问题中，<strong class="ky ir">混淆矩阵</strong>，也称为误差矩阵，是一种特定的表格布局，允许算法性能的可视化，通常是监督学习算法。— <a class="ae kv" href="https://en.wikipedia.org/wiki/Confusion_matrix" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1f8802072df1ae23b498b613ca3be60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*qooivqI5Q2ME17a3qQzOIg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两类分类问题的混淆矩阵(图片来源:作者)</p></figure><p id="b59c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解混淆矩阵，让我们考虑一个两类分类问题，其中两个结果是“肯定的”和“否定的”。给定一个要预测的数据点，模型的结果将是这两个中的任何一个。</p><p id="d75d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将预测值与真实值(实际值)进行对比，我们会得到一个包含以下代表性元素的矩阵:</p><p id="cb0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">真阳性(TP): </strong>这些数据点的实际结果是阳性的，并且算法正确地将其识别为阳性。</p><p id="46a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">真阴性(TN): </strong>这些是实际结果为阴性的数据点，算法正确地将其识别为阴性。</p><p id="795c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">假阳性(FP): </strong>这些数据点的实际结果是阴性的，但算法错误地将其识别为阳性。</p><p id="68b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">假阴性(FN): </strong>这些数据点的实际结果为阳性，但算法错误地将其识别为阴性。</p><p id="2ef0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所猜测的，使用混淆矩阵评估模型的目标是最大化TP和TN的值，最小化FP和FN的值。</p><p id="23e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解这个概念，让我们举一个现实生活中的例子:心脏病的预测。在这种情况下，结果将是患者是否患有心脏病。混淆矩阵看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/533f054b660bceb0c3ba61620727622e.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*h1MBLDA6bPxNpxwgSD1xNA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">心脏病预测的混淆矩阵(图片来源:作者)</p></figure><p id="3d91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，TP意味着患者实际上患有心脏病，并且算法预测正确。TN表示患者没有心脏病，算法预测正确。所以目标应该是尽可能地保持这些值。</p><h2 id="39e4" class="nb mj iq bd mk nc nd dn mo ne nf dp ms lf ng nh mu lj ni nj mw ln nk nl my nm bi translated">混淆矩阵如何帮助检测过度拟合？</h2><p id="7166" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">为了理解这一点，让我们考虑一下心脏病的例子。大多数时候，当我们处理医疗用例时，很有可能会有一个倾斜的数据集，即一个目标变量会比另一个有更多的数据点。在这种情况下，大多数接受测试的人不会被诊断出任何心脏病。因此，数据集中存在不平衡(偏斜)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/98b393466240c8d0e097621844fce59e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LyAh9RctaFKlir8dc0uf4w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">描述倾斜数据集的心脏病示例(图片来源:作者)</p></figure><p id="72ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在上图所示的数据集上训练一个模型，由于没有心脏病的患者的数据点数量远远多于有心脏病的患者，该模型将偏向于具有更多数据点的目标(特别是如果我们仅基于其准确性来评估模型)。</p><p id="abd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，经过训练，如果我们在测试集(没有心脏病的患者有8000个数据点，而有心脏病的患者只有2000个数据点)上测试模型，即使模型预测所有10000个数据点都没有任何心脏病，准确率仍然高达80%。这可能会产生误导，尤其是在假阴性的风险应该可以忽略不计的领域(一个预测患有心脏病的患者与没有心脏病的患者一样的模型将被证明是真正致命的)。</p><p id="5b0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是混淆矩阵发挥作用的地方。对于上述场景，混淆矩阵如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/18ea91019f7fb452c955104687b878c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*eN55myfVgE0lQdDQnnyqBA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">上述场景的混淆矩阵(图片来源:作者)</p></figure><p id="046a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您查看混淆矩阵以及模型获得的准确性，我们可以清楚地识别出模型在训练数据集上过度拟合，因为它将每个未知数据点预测为没有心脏病的患者。如果没有混淆矩阵，我们永远不会知道潜在的问题。</p><p id="89fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">scikit学习包包括混淆矩阵。你可以在这里查阅官方文档<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="9fa5" class="mi mj iq bd mk ml ob mn mo mp oc mr ms jw od jx mu jz oe ka mw kc of kd my mz bi translated">精确召回</h1><p id="de81" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">既然你已经理解了混淆矩阵的作用，那么理解精确召回就更容易了。</p><p id="a9ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经看到准确性在某些情况下是如何误导人的。精确度和召回率帮助我们进一步理解所显示的特定问题的精确度有多高。</p><blockquote class="mc md me"><p id="4d7a" class="kw kx mb ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated"><strong class="ky ir">精度</strong>(也叫<a class="ae kv" href="https://en.wikipedia.org/wiki/Positive_predictive_value" rel="noopener ugc nofollow" target="_blank">正预测值</a>)是相关实例在检索到的实例中所占的比例，而<strong class="ky ir">召回</strong>(也叫<a class="ae kv" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity" rel="noopener ugc nofollow" target="_blank">灵敏度</a>)是实际检索到的相关实例总数的比例。因此，精确度和召回率都基于对<a class="ae kv" href="https://en.wikipedia.org/wiki/Relevance_(information_retrieval)" rel="noopener ugc nofollow" target="_blank">相关性</a>的理解和度量。— <a class="ae kv" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="2b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，精确度意味着所做的正面预测有多少是正确的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4751a63f1b76c275b7353e895299574c.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*_cYPzG5XV7XaWBRKB-pqWQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">精度公式(图片来源:作者)</p></figure><p id="1b88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的心脏病例子中，它看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b98ba1a55cc441f0a14b84bc3fdf6c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*z1L85M17aKU2XPgH0UuonQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">精确示例(图片来源:作者)</p></figure><p id="dd7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可以被翻译成简单的语言，在所有被归类为患有心脏病的患者中，有多少人实际上患有心脏病？</p><p id="78d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说，回忆意味着分类器正确分类的实际正面预测的百分比。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/203acb397938b0441e7773afd981b8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*5OA6GNFIl-_VcRbxv6sITg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">回忆公式(图片来源:作者)</p></figure><p id="892c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的示例中，它看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2f842cab46c3f236e9cf6877dad7d78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*ZGbCXZi83VqGtO26Mh9TOA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">回忆例子(图片来源:作者)</p></figure><p id="5b55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它主要是问，在所有患有心脏病的病人中，有多少人被归类为患有心脏病？</p><p id="5d08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个公式乍一看似乎有点相同，但是一旦你明白了要点，就很难把两者混淆起来。</p><p id="ad93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">scikit学习包中也提供了Precision-Recall。你可以在这里查阅官方文档<a class="ae kv" href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="47a4" class="nb mj iq bd mk nc nd dn mo ne nf dp ms lf ng nh mu lj ni nj mw ln nk nl my nm bi translated">精确召回权衡</h2><p id="4913" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">假设我们训练一个逻辑回归分类器来识别病人是否患有心脏病。如果概率(阈值)大于或等于0.5，它将预测患者患有心脏病，如果概率小于0.5，则患者没有心脏病。</p><p id="f073" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们想建立一个模型，只有在对假设非常有信心的情况下，它才能预测患者是否患有心脏病，我们可能需要将阈值提高到0.7或0.8。</p><p id="12c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们最终得到一个具有高精度和低召回率的分类器。精度更高，因为现在分类器更确信患者患有心脏病。召回率较低，因为现在分类器的阈值设置得如此之高，将会有更少的患者被分类为患有心脏病。</p><p id="7d31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种选择是，我们建立一个模型，这样它就不会遗漏任何可能的心脏病患者病例(以避免假阴性)。如果一个患有心脏病的病人没有被模型注意到，这可能是致命的。在这种情况下，我们将阈值降低到0.2或0.3，这样即使患者有轻微的可能患有心脏病，也会发出警报，并且可以进行进一步的诊断来证明该假设。</p><p id="84b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们这里有一个<strong class="ky ir">高召回</strong>和<strong class="ky ir">低精度</strong>的例子。召回率更高，因为我们将对更多的心脏病患者进行分类。精确度较低，因为在大量预测患有心脏病的患者中，一些人在进一步诊断后实际上不会患有心脏病。</p><p id="eb98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，精确召回值会随着阈值的增加或降低而不断变化。构建具有更高精度或召回率的模型取决于您正在处理的问题陈述及其要求。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="6a48" class="mi mj iq bd mk ml ob mn mo mp oc mr ms jw od jx mu jz oe ka mw kc of kd my mz bi translated">f1-分数</h1><p id="4903" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">精确召回值对于理解特定算法的性能非常有用，也有助于根据需求产生结果。但是当涉及到比较在相同数据上训练的几个算法时，仅仅基于精确召回值就很难理解哪个算法更适合数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/fda43332c5697cca4f42eec504ac3086.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*7spa3sGLg0NuZfPiAOE3OQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">单纯基于查准率值，哪种算法更好？(图片来源:作者)</p></figure><p id="92c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，需要一种采用精确召回值并提供这些值的标准化表示的度量。</p><blockquote class="mc md me"><p id="9e7b" class="kw kx mb ky b kz la jr lb lc ld ju le mf lg lh li mg lk ll lm mh lo lp lq lr ij bi translated">在二进制分类的<!-- -->统计分析中，<strong class="ky ir"> F1得分</strong>(也称为<strong class="ky ir"> F得分</strong>或<strong class="ky ir"> F度量</strong>)是一个测试准确度的度量。通过测试的<a class="ae kv" href="https://en.wikipedia.org/wiki/Precision_(information_retrieval)" rel="noopener ugc nofollow" target="_blank">精度</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Recall_(information_retrieval)" rel="noopener ugc nofollow" target="_blank">召回</a>计算得出，其中精度是正确识别的阳性结果数除以所有阳性结果数，包括未正确识别的阳性结果，召回是正确识别的阳性结果数除以所有应被识别为阳性的样本数。— <a class="ae kv" href="https://en.wikipedia.org/wiki/F1_score" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="b366" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">F1得分也可以描述为精确度和召回率的调和平均值或加权平均值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/a40928bdfd84be49e15c51e8a1b05c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*ZMWbXzr6y1sLxJzbtAkkDQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">F1得分公式(图片来源:作者)</p></figure><p id="3e32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">精度或召回值为0是不可取的，因此它将使我们的F1得分为0(最低)。另一方面，如果精度和召回值都是1，那么我们得到的F1值为1，表示完美的精度召回值。F1分数的所有其他中间值的范围在0和1之间。</p><p id="3ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">scikit学习包中也提供了F1分数。你可以在这里查阅官方文档<a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="467e" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">结论</h1><p id="eb37" class="pw-post-body-paragraph kw kx iq ky b kz nn jr lb lc no ju le lf np lh li lj nq ll lm ln nr lp lq lr ij bi translated">我希望这篇文章能帮助你理解混淆矩阵、精确回忆和F1分数这些术语。使用这些指标肯定会帮助您更好地了解模型的性能。一旦您完全理解了这些概念，您还可以研究一些其他评估指标，如对数损失、ROC-AUC曲线、分类交叉熵等等。</p><h1 id="f69b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">参考</h1><ul class=""><li id="0844" class="om on iq ky b kz nn lc no lf oo lj op ln oq lr or os ot ou bi translated"><a class="ae kv" href="https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow/dp/1492032646" rel="noopener ugc nofollow" target="_blank">使用Scikit-Learn、Keras和TensorFlow进行机器实践学习:构建智能系统的概念、工具和技术</a>(非附属)</li><li id="fe18" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=W5meQnGACGo&amp;list=PLsas0wB8kXTF8tduPtwvM6MtB163ELjuP&amp;index=11" rel="noopener ugc nofollow" target="_blank">精确度和召回率的权衡—【吴恩达】</a></li><li id="977b" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Confusion_matrix" rel="noopener ugc nofollow" target="_blank">混淆矩阵—维基百科</a></li><li id="0cb5" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">精确召回——维基百科</a></li><li id="aabe" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/F1_score" rel="noopener ugc nofollow" target="_blank"> F1得分—维基百科</a></li></ul></div></div>    
</body>
</html>