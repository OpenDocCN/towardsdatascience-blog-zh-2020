<html>
<head>
<title>Deploy a machine learning application with Streamlit and Docker on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS上使用Streamlit和Docker部署机器学习应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-deploy-a-semantic-search-engine-with-streamlit-and-docker-on-aws-elastic-beanstalk-42ddce0422f3?source=collection_archive---------17-----------------------#2020-11-09">https://towardsdatascience.com/how-to-deploy-a-semantic-search-engine-with-streamlit-and-docker-on-aws-elastic-beanstalk-42ddce0422f3?source=collection_archive---------17-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/705d77841929d0761ebc988ab505b6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bR_2uqyBxoSTEHti_pSw1g.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><p id="6a06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在之前的博客中，我们讨论了如何用句子转换器和Faiss 构建一个语义搜索引擎。这里，我们将创建一个Streamlit应用程序，并在本地和AWS Elastic Beanstalk上部署搜索引擎。</p><p id="dd43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您想直接进入代码，请查看<a class="ae la" href="https://github.com/kstathou/vector_engine" rel="noopener ugc nofollow" target="_blank"> GitHub repo！</a></p><h1 id="dcd8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简化应用程序</h1><p id="81f1" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">Streamlit是一个开源的Python库，可以轻松创建用于机器学习和数据科学的应用程序。使用Streamlit，您不需要学习Flask或任何前端开发，您可以专注于您的应用程序。</p><p id="e79a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的应用程序将帮助用户搜索学术文章。用户将在搜索框中键入文本查询，并检索最相关的出版物及其元数据。他们还可以选择返回结果的数量，并根据论文引用数量和出版年份进行筛选。</p><p id="1fe0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在幕后，我们将使用句子蒸馏模型对搜索查询进行矢量化，并将其传递到预先构建的Faiss索引中进行相似性匹配。Faiss将测量查询向量和索引纸张向量之间的L2距离，并返回与查询最接近的纸张id列表。</p><p id="c6e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看这个应用程序会是什么样子，然后深入研究代码。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h2 id="0fca" class="mk lc iq bd ld ml mm dn lh mn mo dp ll kn mp mq lp kr mr ms lt kv mt mu lx mv bi translated">建立简化应用的原型</h2><p id="d14a" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">让我们导入所需的Python包。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mw mj l"/></div></figure><p id="d78c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们将编写几个函数来加载数据、transformer模型和Faiss索引。我们将使用<a class="ae la" href="https://docs.streamlit.io/en/stable/caching.html" rel="noopener ugc nofollow" target="_blank"> Streamlit的</a> <code class="fe mx my mz na b"><a class="ae la" href="https://docs.streamlit.io/en/stable/caching.html" rel="noopener ugc nofollow" target="_blank">@st.cache</a></code> <a class="ae la" href="https://docs.streamlit.io/en/stable/caching.html" rel="noopener ugc nofollow" target="_blank">装饰器</a>来缓存它们，以加速我们的应用程序。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mw mj l"/></div></figure><p id="82bc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们将创建应用程序的主体。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mw mj l"/></div></figure><p id="292b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们一行一行地检查代码:</p><ul class=""><li id="fa19" class="nb nc iq ke b kf kg kj kk kn nd kr ne kv nf kz ng nh ni nj bi translated"><strong class="ke ir">第4–6行</strong>:调用上面显示的函数，加载并缓存数据和模型。</li><li id="3895" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第8行</strong>:设置我们应用的标题。</li><li id="6d13" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第11行</strong>:在页面主体上创建一个<a class="ae la" href="https://docs.streamlit.io/en/stable/api.html#streamlit.text_area" rel="noopener ugc nofollow" target="_blank">多行文本输入小部件</a>。那是我们的搜索框！</li><li id="7384" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第14–17行</strong>:创建搜索引擎过滤器，并将它们放在侧边栏上。</li><li id="8336" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第22行</strong>:对给定的文本查询进行语义搜索，并返回最相关结果的论文id。这些将基于它们与文本查询的相似性来排序。</li><li id="16b5" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第24–28行</strong>:根据发表年份和论文引用次数过滤数据。</li><li id="3335" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第30–34行</strong>:对于第22行中检索到的每个纸张ID，从过滤后的数据集中提取其元数据。</li><li id="6bd0" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第36–43行</strong>:打印论文的元数据，即标题、引文、出版年份和摘要。</li></ul><h1 id="0e87" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将申请归档</h1><p id="eb50" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我们将使用Docker将应用程序及其所有依赖项打包到一个容器中。我们将创建一个<code class="fe mx my mz na b">Dockerfile</code>,它是一个包含命令(即指令)的文本文档，用来组合一个图像。如果你不熟悉Docker，<a class="ae la" href="https://docker-curriculum.com/" rel="noopener ugc nofollow" target="_blank">本指南提供了深入的介绍</a>。</p><pre class="me mf mg mh gt np na nq nr aw ns bi"><span id="fc37" class="mk lc iq na b gy nt nu l nv nw">FROM python:3.8-slim-buster<br/>COPY . /app<br/>WORKDIR /app<br/>RUN pip install -r requirements.txt<br/>EXPOSE 8501<br/>ENTRYPOINT ["streamlit","run"]<br/>CMD ["app.py"]</span></pre><p id="6daa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们一行一行地解释这个docker文件将做什么:</p><ul class=""><li id="eaa4" class="nb nc iq ke b kf kg kj kk kn nd kr ne kv nf kz ng nh ni nj bi translated"><strong class="ke ir">第1行</strong>:取一个Python <a class="ae la" href="https://docs.docker.com/develop/develop-images/baseimages/" rel="noopener ugc nofollow" target="_blank">基图</a>。</li><li id="34c4" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第二行</strong>:将这个<a class="ae la" href="https://github.com/kstathou/vector_engine" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>的内容复制到一个名为<code class="fe mx my mz na b">/app</code>的目录下</li><li id="c71d" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第3行</strong>:将工作目录更改为<code class="fe mx my mz na b">/app</code></li><li id="8df2" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第四行</strong> : Pip安装<code class="fe mx my mz na b">requirements.txt</code>文件。</li><li id="eeb4" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第5行</strong>:让容器在运行时监听8501端口。</li><li id="95f7" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第6行</strong>:启动集装箱时执行<code class="fe mx my mz na b">streamlit run</code>命令。</li><li id="43ee" class="nb nc iq ke b kf nk kj nl kn nm kr nn kv no kz ng nh ni nj bi translated"><strong class="ke ir">第7行</strong>:指定将提供给<code class="fe mx my mz na b">ENTRYPOINT</code>的参数，在我们的例子中，是应用程序的文件名。</li></ul><p id="ada4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，假设Docker正在您的机器上运行，我们可以用下面的命令<a class="ae la" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">构建</a>映像:</p><pre class="me mf mg mh gt np na nq nr aw ns bi"><span id="e7e4" class="mk lc iq na b gy nt nu l nv nw">$ docker build -t &lt;USERNAME&gt;/&lt;YOUR_IMAGE_NAME&gt; .</span></pre><p id="0a5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">构建</strong>命令将创建一个符合<code class="fe mx my mz na b">Dockerfile</code>规范的图像。现在，我们准备好部署我们的应用程序了！</p><h1 id="24ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">部署应用程序</h1><h2 id="42e0" class="mk lc iq bd ld ml mm dn lh mn mo dp ll kn mp mq lp kr mr ms lt kv mt mu lx mv bi translated">本地部署</h2><p id="81f2" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在本地部署我们的语义搜索引擎非常简单。构建完映像后，我们将使用<a class="ae la" href="https://docs.docker.com/engine/reference/run/" rel="noopener ugc nofollow" target="_blank"> run </a>命令在容器中旋转我们的应用程序。我们还将添加<code class="fe mx my mz na b">-p</code>参数，以在8501发布容器的端口。</p><pre class="me mf mg mh gt np na nq nr aw ns bi"><span id="d2e8" class="mk lc iq na b gy nt nu l nv nw">$ docker run -p 8501:8501 &lt;USERNAME&gt;/&lt;YOUR_IMAGE_NAME&gt;</span></pre><p id="5306" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以通过以下地址访问该应用程序:</p><pre class="me mf mg mh gt np na nq nr aw ns bi"><span id="e641" class="mk lc iq na b gy nt nu l nv nw">http://localhost:8501/</span></pre><h2 id="ca9a" class="mk lc iq bd ld ml mm dn lh mn mo dp ll kn mp mq lp kr mr ms lt kv mt mu lx mv bi translated">AWS弹性豆茎展开</h2><p id="d2cc" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">为了在AWS上部署我们的应用程序，我们需要将我们的图像发布到一个注册中心，云提供商可以访问这个注册中心。为了方便起见，我们还是用<a class="ae la" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>吧。如果您以前没有推送过图像，客户端可能会要求您登录。提供用于登录Docker Hub的相同凭据。请注意，这一步可能需要一段时间，因为我们的图像相当大！</p><pre class="me mf mg mh gt np na nq nr aw ns bi"><span id="58f5" class="mk lc iq na b gy nt nu l nv nw">$ docker push &lt;USERNAME&gt;/&lt;YOUR_IMAGE_NAME&gt; .</span></pre><blockquote class="nx ny nz"><p id="b367" class="kc kd oa ke b kf kg kh ki kj kk kl km ob ko kp kq oc ks kt ku od kw kx ky kz ij bi translated">在公共注册表上发布您的映像并不是强制性的，但是，它通过跳过一些配置步骤简化了部署。</p></blockquote><p id="e219" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们几乎可以在AWS Elastic Beanstalk (EB)上部署我们的映像了。让我们列出步骤:</p><ul class=""><li id="8b4c" class="nb nc iq ke b kf kg kj kk kn nd kr ne kv nf kz ng nh ni nj bi translated">登录<a class="ae la" href="https://aws.amazon.com/console/" rel="noopener ugc nofollow" target="_blank"> AWS控制台</a>，搜索<strong class="ke ir">弹性豆茎</strong>。</li></ul><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/452a338740c10e6d07709b473bb0f745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6vCis8rCcfJK1LlN"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><ul class=""><li id="1cf1" class="nb nc iq ke b kf kg kj kk kn nd kr ne kv nf kz ng nh ni nj bi translated">点击<strong class="ke ir">创建应用</strong>按钮，并命名您的应用。</li></ul><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/dc2f4c9adeb4c442a64668c84534d367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dSwIb1qqtt2lBq7n"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><ul class=""><li id="cd7e" class="nb nc iq ke b kf kg kj kk kn nd kr ne kv nf kz ng nh ni nj bi translated">选择<strong class="ke ir"> Docker </strong>作为平台。现在，我们需要从本地文件<strong class="ke ir">上传我们的代码</strong>。因为我们的应用程序是dockerized的，所以我们只需要提供容器的细节。我们将通过点击<strong class="ke ir">选择文件</strong>按钮并上传<code class="fe mx my mz na b"><a class="ae la" href="https://github.com/kstathou/vector_engine/blob/master/Dockerrun.aws.json" rel="noopener ugc nofollow" target="_blank">Dockerrun.aws.json</a></code> <a class="ae la" href="https://github.com/kstathou/vector_engine/blob/master/Dockerrun.aws.json" rel="noopener ugc nofollow" target="_blank">文件</a>来完成此操作。这是一个特定于AWS的文件，它与EB共享我们的应用程序的详细信息和docker配置。在上传之前，请确保您已经将<code class="fe mx my mz na b">Dockerrun.aws.json</code>中的图像名称从<code class="fe mx my mz na b">kstathou/vector_engine</code>更改为您之前使用的<code class="fe mx my mz na b">&lt;USERNAME&gt;/&lt;YOUR_IMAGE_NAME&gt;</code>。上传文件后，点击<strong class="ke ir">配置更多选项。</strong></li></ul><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/638fd053cb9cfdd23502249042196cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cxSzLeQdjt3oix7Y"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><ul class=""><li id="6fad" class="nb nc iq ke b kf kg kj kk kn nd kr ne kv nf kz ng nh ni nj bi translated">编辑<strong class="ke ir">实例</strong>和<strong class="ke ir">产能</strong>。从<strong class="ke ir">实例</strong>开始，将<strong class="ke ir">根卷类型</strong>更改为<em class="oa">通用(SSD) </em>并将<strong class="ke ir">大小</strong>更改为8GB。滚动到页面底部，点击<strong class="ke ir">保存。</strong>接下来，选择<strong class="ke ir"> Capacity </strong>并将<strong class="ke ir">实例类型</strong>从t2.micro更改为t3.medium。注意，我们选择的EC2实例不在空闲层中，您将因使用它而付费。请确保在使用完应用程序后关闭它！</li></ul><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/a0f0ce94dfe55266c6088482abd47a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4yXAALNLI_28ByPq"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><ul class=""><li id="1a76" class="nb nc iq ke b kf kg kj kk kn nd kr ne kv nf kz ng nh ni nj bi translated">点击<strong class="ke ir">创建应用程序。EB将需要几分钟来部署我们的应用程序。一旦完成，你将能够通过它的URL访问和分享语义搜索引擎！</strong></li></ul><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/73c949022168c4cf5371ca28805b0369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Miira1qzitqIGfrq"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由Kostas Stathoulopoulos提供</p></figure><h1 id="460c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9ce0" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在本教程中，我向您展示了如何使用Streamlit构建应用程序原型，以及如何使用Docker在本地和AWS Elastic Beanstalk上进行部署。如果你有任何问题，请在评论中告诉我。</p><p id="4f4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码可以在<a class="ae la" href="https://github.com/kstathou/vector_engine" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到！</p></div></div>    
</body>
</html>