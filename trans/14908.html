<html>
<head>
<title>A Swift Introduction To Lathe: OOP ML For Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">车床快速入门:面向对象建模语言</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-swift-introduction-to-lathe-oop-ml-for-julia-8208bcbb4fc8?source=collection_archive---------61-----------------------#2020-10-13">https://towardsdatascience.com/a-swift-introduction-to-lathe-oop-ml-for-julia-8208bcbb4fc8?source=collection_archive---------61-----------------------#2020-10-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1308" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">车床机器学习库使用介绍。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/181ea74b2dec6f43c3cc0121d6b7935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPwIG53S2G618AQsTslbMQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="39e2" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="0527" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi mm translated">在Julia生态系统中，有许多针对数据科学学科的包。有用于分布、推理和贝叶斯统计、数据可视化甚至深度学习的包。虽然这些包中的许多都是很棒的解决方案，并且分别工作得很好，但是还有一个更新的、更具包容性的解决方案，它在Julia语言中提供了类似Sklearn的语法，这通常有助于编写更多的函数代码。</p><p id="37e7" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">车床。jl是一个统计，预测建模，数据处理和深度学习库，所有这些都浓缩到一个单一的包中，您可以通过Pkg添加。与机器学习的其他Julian解决方案相比，Lathe.jl的一个优势是，Lathe利用Julia的调度类型来创建具有子调度方法的类型。这对于像模型这样的东西非常有用，在这种情况下，您可能希望有一个在拟合或预测之前执行一些逻辑的初始化函数。此外，使用包含在给定类型中的类型和数据的能力，而不是为了使用给定的方法而需要提供它们，对于机器学习来说也是非常有价值的。</p><blockquote class="na"><p id="b491" class="nb nc it bd nd ne nf ng nh ni nj ml dk translated"><a class="ae nk" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Introduction%20To%20Lathe.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="c9cc" class="ky kz it bd la lb ns ld le lf nt lh li jz nu ka lk kc nv kd lm kf nw kg lo lp bi translated">入门指南</h1><p id="804e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了开始用车床处理算法，你首先需要安装它。虽然这很简单，但重要的是要确保你使用的是正确的分支和版本的车床。要添加最新版本的车床，可以这样做</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="400a" class="oc kz it ny b gy od oe l of og">using Pkg;Pkg.add("Lathe")</span></pre><p id="999d" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">你体内的朱莉娅·REPL。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/14548b554185d7bc49d37807e7a3c093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*r41l_6xt_1_OkNnRyvy77A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="72dd" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这将给你车床版本0.1.1“黄油球。”只要您使用的是车床“Butterball”的版本，本教程应该适用于所有涉及的代码。如果您想先睹为快，也可以添加不稳定分支:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="f68c" class="oc kz it ny b gy od oe l of og">julia&gt;]<br/>pkg&gt; add Lathe#Unstable</span></pre><p id="8b3f" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">您还可以为0.1.0以上的每个特定版本添加分支:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="9e40" class="oc kz it ny b gy od oe l of og">add Lathe#Butterball<br/>add Lathe#0.1.0<br/>add Lathe#0.1.1<br/>add Lathe#0.1.2</span></pre><p id="43d8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">您还需要添加DataFrames.jl。它不仅是这台车床唯一的依赖项，而且还与车床中的许多函数相关联，这些函数将采用数据帧类型。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2e3d" class="oc kz it ny b gy od oe l of og">add DataFrames</span></pre><p id="8f62" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在你应该可以导入车床了:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6c37" class="oc kz it ny b gy od oe l of og">using Lathe</span></pre><p id="1d86" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">关于使用任何Julia包，我能给出的一些很好的建议是熟悉如何使用？()方法来浏览文档。大多数软件包使用Documenter.jl来创建它们的文档，这些文档通常是通过Juliahub生成的(这真的很酷)，所以经常会有一些文档，你可以很容易地在你的REPL或笔记本中访问它们。如果你想了解更多关于用doc-strings和Documenter.jl创建自动化文档的知识，我写了一个完整的教程，你可以在这里查看:</p><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/how-to-automate-julia-documentation-with-documenter-jl-21a44d4a188f"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">如何用Documenter.jl自动化Julia文档</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">没有文档，软件是没有用的，所以用Documenter.jl把文档的痛苦去掉吧</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="6935" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">每当我们运行我们的。()方法放在车床模块上，我们得到这样的回报:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/d819599c433a3d72e1c4159447c95bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*5bTi0nyob582BcFCl05y2Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="4c44" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">让我们先来看看Lathe.stats，它是Lathe.jl包含的统计库。我们将在下面的代码中直接使用它:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5ed4" class="oc kz it ny b gy od oe l of og">using Lathe: stats</span></pre><p id="bf48" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在我们将调用我们的？()方法在上面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/d86c017e63d23e0916371f90597ffbb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*VwRA6VSDZ9RuIbJdtGAQ7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="1cf0" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">作为回报，我们得到了这个库中所有可用函数的详细列表。今天，我们将忽略统计库，直接进入预处理，但是如果您需要的话，统计数据总是存在的。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="9813" class="ky kz it bd la lb ns ld le lf nt lh li jz nu ka lk kc nv kd lm kf nw kg lo lp bi translated">数据</h1><p id="16fa" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了开始使用车床，我们当然需要一些数据来支持它。用于基本示例的一个很好的格式是逗号分隔值，我们需要CSV.jl包来读取它。如果您的计算机上没有该包，您可以使用以下命令获取它:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="28fd" class="oc kz it ny b gy od oe l of og">pkg&gt; add CSV</span></pre><p id="6879" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">在本例中，我将使用一些汽车数据训练一个模型，这些数据包含欧洲汽车的信息，如里程、价格和转售价值。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="6433" class="oc kz it ny b gy od oe l of og">using CSV<br/>df = CSV.read("car data.csv")</span></pre><p id="f702" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">该数据有两个可能相关联的特征，并且用线性回归来探索是有趣的，那就是汽车的销售价格和它的制造年份。让我们从删除所有我们不需要的特性开始。为此，我们可以创建一个全新的数据框，或者删除我们不需要的要素。我更喜欢后者。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="d844" class="oc kz it ny b gy od oe l of og">using DataFrames<br/>df = DataFrame(:Year =&gt; df[:Year], :Price =&gt; df[:Selling_Price])</span></pre><p id="6de6" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">为了检查缺少的值，我们将运行一个快速for循环来检查值是否缺少:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e466" class="oc kz it ny b gy od oe l of og">for year in df[:Year]<br/>    if year == Missing<br/>        println("missing")<br/>    end<br/>end<br/>for price in df[:Price]<br/>    if price == Missing<br/>        println("missing")<br/>    end<br/>end</span></pre><p id="7d0b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">幸运的是，这个数据没有值，所以我们将继续把数据分成测试和训练集。为此，我们将使用车床:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/bf1bf640a3bf5aa33d6931d71f87f139.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*Cx0-n1SnRFk51F5VTjU4Jg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="94d8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们正在寻找的方法是TrainTestSplit()。要找到关于函数的更多信息，我们可以使用？()方法上也是如此:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/994954b286aeb91a070bb60abf685601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7py8S_uDTEdI8pdX8chpOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b5c3" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这不是最好的文档，但是它确实给了我们一个概念，我们需要为这个函数提供什么参数。有趣的是，这个函数使用Julia的dispatch，所以我们也可以直接调用dispatch函数，就像这样:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="3dd6" class="oc kz it ny b gy od oe l of og">train, test = preprocess._dfTrainTestSplit(df, .75)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/d6155bd76315718230dee3b511cc3246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-xuLHgAU9XTZF7S_XgxqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="b619" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在，我们将把它放入新的数组中，用于训练值和测试值:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="27d5" class="oc kz it ny b gy od oe l of og">trainX = train[:Price]<br/>trainY = train[:Year]<br/>testX = test[:Price]<br/>testY = test[:Year]</span></pre><h1 id="2bc2" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">建模</h1><p id="f9c3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">最后，我们可以从Lathe.models获取LinearRegression。如果您使用的是更新版本的Lathe，您可能需要调用SimpleLinearRegression。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e625" class="oc kz it ny b gy od oe l of og">?(models.LinearRegression)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/00ef76e5aefdfc67aed92529a9a97e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkpABjDzRQtHzH_w_MuNWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="8182" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">如您所见，我们需要为y和x提供一个一维数组，并将调用predict函数来返回一个预测值。我们可以像在Julia甚至Python中创建类型一样拟合模型:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="b14a" class="oc kz it ny b gy od oe l of og">model = models.LinearRegression(trainX, trainY)</span></pre><p id="8703" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在我们可以在没有测试数据的情况下调用这个模型。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="927e" class="oc kz it ny b gy od oe l of og">yhat = model.predict(testX)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/ac80c98a0c8d18e8c6b69ebf4cb72acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*xmRY-ynDwOUGVp5ozgUDCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="5e43" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">因为年份是整数，所以我将遍历这些值，并将它们四舍五入为最接近的整数:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="053e" class="oc kz it ny b gy od oe l of og">yhat = [year = Int64(round(year)) for year in yhat]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/a9d6be7af5277d209bbcd5266cc66261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8UZPz4fPSRZQ1sC_gNIATA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="pi pj pk"><p id="eeb7" class="lq lr pl ls b lt mv ju lv lw mw jx ly pm mx mb mc pn my mf mg po mz mj mk ml im bi translated">注意:</p><p id="174a" class="lq lr pl ls b lt mv ju lv lw mw jx ly pm mx mb mc pn my mf mg po mz mj mk ml im bi translated">如果您使用的是车床1.2 +，那么在直接调用模块时，您将能够调用所有函数作为导出。或者，您可以调用作为由车床导出的模块的子模块的函数。</p></blockquote><p id="1085" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">为了验证我们的模型，我们可以使用来自Lathe.stats的平均绝对误差指标:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e83a" class="oc kz it ny b gy od oe l of og">using Lathe.stats: mae<br/>println(mae(yhat, testY))</span></pre><p id="25c0" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我认为这是非常准确的！如果我们真的需要，我们也可以使用来自Lathe.preprocess的规格化器。对于这个例子，我打算迭代最小可行产品，但是MAE为0意味着模型在这个测试中是完美的，所以我真的没有任何改进可以做，除非我着手建立一个验证集并进一步提高模型的准确性——并冒过度拟合的风险。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="b226" class="ky kz it bd la lb ns ld le lf nt lh li jz nu ka lk kc nv kd lm kf nw kg lo lp bi translated">结论</h1><p id="c860" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">车床是一个伟大的上升和未来的工具，我非常兴奋。虽然肯定还有很多工作要做，但我认为它对Julia语言的影响是相当大的。有了类似Sklearn的语法，以及非常容易理解的函数和类型，我认为它可以为许多Python用户搭建一座桥梁，这些用户不太习惯于将参数放入一个结构并将它们作为参数传递，以使方法适合模型类型和数据。</p></div></div>    
</body>
</html>