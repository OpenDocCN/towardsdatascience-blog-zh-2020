<html>
<head>
<title>Efficient reinforcement learning on the edge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">边缘高效强化学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/efficient-reinforcement-learning-on-the-edge-331afa979a30?source=collection_archive---------50-----------------------#2020-11-02">https://towardsdatascience.com/efficient-reinforcement-learning-on-the-edge-331afa979a30?source=collection_archive---------50-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/84e387366b627e0d806967a385a31e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*A1D_qg-aOAlbyQ1JRaPLjw.png"/></div><p class="iv iw gj gh gi ix iy bd b be z dk translated">图片作者。</p></figure><div class=""/><div class=""><h2 id="d84e" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">借助正交持久性，我们可以在边缘设备上实现顺序学习</h2></div><p id="7042" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" rel="noopener" target="_blank" href="/exploiting-the-differences-between-model-training-and-prediction-40f087e52923">在之前的帖子</a>中，我们已经展示了如何利用模型训练(<em class="ln">即</em>需要所有数据，通常需要多次通过数据集)和预测(<em class="ln">即</em>基于具有预训练参数的单个函数)之间的差异，来有效地部署机器学习(ML)和人工智能(AI)模型。<a class="ae lm" rel="noopener" target="_blank" href="/why-would-you-use-webassembly-to-put-scikit-learn-in-the-browser-77671e8718d6">通过将训练好的模型传输到WebAssembly </a>，可以将受监督和不受监督的模型高效地部署到云和边缘设备。<a class="ae lm" href="https://www.scailable.net/edge/" rel="noopener ugc nofollow" target="_blank">我们已经能够在可用内存小于64Kb的设备上部署模型。相当酷。然而，我们经常被问到如何有效地更新模型(T10)(最好是本地更新模型(T11)):在边缘设备上更新模型(T14)状态的简单方法(T15)将允许有效的顺序学习和强化学习应用。</a></p><blockquote class="lo"><p id="69a9" class="lp lq jb bd lr ls lt lu lv lw lx ll dk translated">在边缘设备本身上更新模型<em class="ly">状态的简单方法将允许高效的顺序学习和强化学习应用。</em></p></blockquote><p id="9580" class="pw-post-body-paragraph kq kr jb ks b kt lz kc kv kw ma kf ky kz mb lb lc ld mc lf lg lh md lj lk ll ij bi translated">在这篇文章中，我们将解释如何使用正交持久性来更新WebAssembly二进制文件的状态，以实现这样的功能。我们将首先解释模型更新的概念(ML/AI)视图，然后关注WebAssembly中的实现。最后，我们将讨论正交持久性提供的可能性。</p><h1 id="8c1d" class="me mf jb bd mg mh mi mj mk ml mm mn mo kh mp ki mq kk mr kl ms kn mt ko mu mv bi translated">更新模型的状态</h1><p id="84e7" class="pw-post-body-paragraph kq kr jb ks b kt mw kc kv kw mx kf ky kz my lb lc ld mz lf lg lh na lj lk ll ij bi translated">正如我们之前所描述的，经过训练后，<a class="ae lm" rel="noopener" target="_blank" href="/exploiting-the-differences-between-model-training-and-prediction-40f087e52923">大多数机器学习模型由一个简单的(尽管通常是高维的)数学函数和一组参数组成</a>。例如，在神经网络中，所涉及的权重矩阵的条目构成了通过训练模型获得的<em class="ln">参数</em>。有点抽象地说，在训练之后，我们可以将模型定义为一个函数<em class="ln"> f() </em>，它将输入<em class="ln"> x </em>映射到(预期的)输出<em class="ln"> y </em>。我们可以明确说明，函数的行为取决于参数的状态<strong class="ks jc"><em class="ln"/></strong>:</p><p id="7a4c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="ln">y = f(x；</em><strong class="ks jc"><em class="ln">S1</em></strong><em class="ln">)</em></p><p id="be5e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">其中<strong class="ks jc"><em class="ln"/></strong>将包含(例如)所有必需的权重。</p><p id="1a91" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在许多情况下，能够随时间更新状态<strong class="ks jc"> <em class="ln"> S1 </em> </strong>是有用的。当(<em class="ln">例如</em>)存在<a class="ae lm" rel="noopener" target="_blank" href="/concept-drift-can-ruin-your-model-performance-and-how-to-address-it-dff08f97e29b">概念漂移</a>并且模型的性能随时间下降时，或者当部署到边缘设备的模型需要更新以反映本地情况时，这可能是有用的。在这种情况下(以及更多情况，参见我们下面的讨论)，将<strong class="ks jc"><em class="ln"/></strong>更新为<strong class="ks jc"><em class="ln"/></strong>—<em class="ln">即</em>所涉及参数的新状态会很有用，而不会有太多麻烦。此外，当部署模型时，应该维护其更新的状态:<em class="ln">即</em>当在边缘设备上运行时，更新的模型应该<em class="ln">保持</em>。</p><p id="e9f3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">虽然概念上很简单——我们只是将新状态<strong class="ks jc"> <em class="ln"> S2 </em> </strong>存储在某个地方——但是当使用WebAssembly部署模型时，在边缘设备上高效地实现持久状态更改有些棘手。然而这是很有可能的。</p><blockquote class="lo"><p id="7e67" class="lp lq jb bd lr ls lt lu lv lw lx ll dk translated">虽然在概念上很容易，但在边缘设备上有效实现持久状态改变在实践中往往很棘手。然而这是很有可能的。</p></blockquote><h1 id="a6ff" class="me mf jb bd mg mh mi mj mk ml mm mn mo kh nb ki mq kk nc kl ms kn nd ko mu mv bi translated">更新WebAssembly二进制文件的状态</h1><p id="29ec" class="pw-post-body-paragraph kq kr jb ks b kt mw kc kv kw mx kf ky kz my lb lc ld mz lf lg lh na lj lk ll ij bi translated">我们通常使用WebAssembly 将模型部署到<a class="ae lm" href="https://www.scailable.net/edge" rel="noopener ugc nofollow" target="_blank">边缘设备。当考虑这种模型的持续更新时，对所涉及的一般过程有一个合理的理解是有用的:</a></p><ol class=""><li id="342b" class="ne nf jb ks b kt ku kw kx kz ng ld nh lh ni ll nj nk nl nm bi translated">我们部署WebAssembly二进制文件——它有效地包含了<em class="ln"> f(。；</em><strong class="ks jc"><em class="ln"/></strong><em class="ln">)</em>—去边设备。这些二进制文件存储在设备的“磁盘”上，包括它们的状态<strong class="ks jc"><em class="ln"/></strong>。</li><li id="e1f2" class="ne nf jb ks b kt nn kw no kz np ld nq lh nr ll nj nk nl nm bi translated">边缘设备包含一个WebAssembly <em class="ln">运行时</em>，这是一个应用程序，它加载二进制文件并将其所谓的<code class="fe ns nt nu nv b">data section</code> ( <a class="ae lm" href="https://rsms.me/wasm-intro" rel="noopener ugc nofollow" target="_blank">参见本文以获得关于WebAssembly二进制文件</a>的更多信息)写入其(线性)内存:这个<code class="fe ns nt nu nv b">data section</code>通常用于存储模型的状态<strong class="ks jc"><em class="ln"/></strong>。运行时确保在边缘设备上执行预测(在我们的例子中，当。WASM二进制被称为，见本教程)。</li></ol><p id="bc5d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一般来说，在WebAssembly二进制文件之间来回传输数据是相对容易的:我们通常在传递一个指向内存中存储(<em class="ln">例如</em>)特征向量的位置的指针时这样做(详见<a class="ae lm" href="https://github.com/scailable/sclbl-tutorials/tree/master/sclbl-create-your-own-wasm" rel="noopener ugc nofollow" target="_blank">本教程</a>—特征向量是<em class="ln">y = f(x；</em><strong class="ks jc"><em class="ln">S</em></strong><em class="ln">)</em>以上符号介绍)。然而，传递一个持续的新状态<strong class="ks jc"> <em class="ln"> S </em> </strong>要棘手得多:不允许<em class="ln">直接向现有的<code class="fe ns nt nu nv b">data section</code>写入，这样做也不能确保它在磁盘上的持久性。</em></p><p id="1b69" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们通过向所有需要持久更新的WebAssembly二进制文件中自动添加一个新的<code class="fe ns nt nu nv b">custom data section</code>有效地解决了这个问题。这个<code class="fe ns nt nu nv b">custom data section </code>在功能上与标准的WebAssembly数据部分相同，只是这次它可以被更新:我们将一个导出的<code class="fe ns nt nu nv b">update()</code>函数添加到已部署的。WASM二进制文件，包含对模型状态进行任何更新所需的逻辑。因此，我们现在可以将状态从<strong class="ks jc"> S1 </strong>更新到<strong class="ks jc"> S2 </strong>以确保模型的更新。</p><p id="f9b1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然而，简单地更新线性存储器中的状态对于持久性来说是不够的；我们需要确保状态的任何变化也反映在磁盘上(<em class="ln">即</em>当打开和关闭设备时，我们希望<strong class="ks jc"> <em class="ln"> S2 </em> </strong>被保留)。这是通过扩展标准WebAssembly运行时来解决的:我们的edge运行时主动监控线性内存中的状态<strong class="ks jc"> <em class="ln"> S </em> </strong>。当它改变时，运行时会在磁盘上覆盖所涉及的WebAssembly二进制文件的<code class="fe ns nt nu nv b">custom data section</code>。因此，我们现在有了一个新的、持久的状态。</p><p id="c341" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，通过扩展WebAssembly的数据结构<em class="ln">和默认运行时</em>，有可能在边缘上允许ML/AI模型的高效持久更新。</p><blockquote class="lo"><p id="650f" class="lp lq jb bd lr ls lt lu lv lw lx ll dk translated">因此，通过扩展WebAssembly的数据结构<em class="ly">和默认运行时</em>，有可能允许边缘上的ML/AI模型的高效持久更新。</p></blockquote><h1 id="6fad" class="me mf jb bd mg mh mi mj mk ml mm mn mo kh nb ki mq kk nc kl ms kn nd ko mu mv bi translated">持久状态更新的可能性</h1><p id="d142" class="pw-post-body-paragraph kq kr jb ks b kt mw kc kv kw mx kf ky kz my lb lc ld mz lf lg lh na lj lk ll ij bi translated">我们已经描绘了一些场景，在这些场景中，对已部署的WebAssembly二进制文件进行(本地)更新可能是有意义的:在概念漂移或本地变化的情况下，使用新的状态<strong class="ks jc"><em class="ln"/></strong>不时地更新已部署的模型可能是有用的。然而，快速和持久的更新允许更丰富的应用程序:</p><ul class=""><li id="2d1d" class="ne nf jb ks b kt ku kw kx kz ng ld nh lh ni ll nw nk nl nm bi translated">模型状态的快速和持久更新允许边缘设备上的模型的<a class="ae lm" href="https://link.springer.com/article/10.1007/s11336-018-09656-z" rel="noopener ugc nofollow" target="_blank">顺序学习。例如，当模型可以用</a><a class="ae lm" href="https://papers.nips.cc/paper/3150-map-reduce-for-machine-learning-on-multicore.pdf" rel="noopener ugc nofollow" target="_blank">求和形式</a>来表达时，部署的模型可以很容易地用每个新的(标记的)可用数据点来更新。</li><li id="35ee" class="ne nf jb ks b kt nn kw no kz np ld nq lh nr ll nw nk nl nm bi translated">模型状态的快速和持久更新允许在边缘设备上进行强化学习(从而将独立的WebAssembly部署扩展到受监督和不受监督的模型之外)。例如，可以使用<code class="fe ns nt nu nv b">predict()</code>和<code class="fe ns nt nu nv b">update()</code>函数迭代地实现<a class="ae lm" href="https://journals.sagepub.com/doi/pdf/10.1177/2158244019851675" rel="noopener ugc nofollow" target="_blank">多武装强盗策略</a>(并添加一些主动探索)。</li></ul><p id="9396" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将很快向我们的<a class="ae lm" href="https://github.com/scailable/sclbl-webnode" rel="noopener ugc nofollow" target="_blank"> WebAssembly Javascript运行时</a>添加持久更新，从而让您看到在此设置中“运行时覆盖到磁盘”的实际实现。然而，我们希望在上面的帖子中已经提供了一个有价值的方法草图。</p><h1 id="b244" class="me mf jb bd mg mh mi mj mk ml mm mn mo kh mp ki mq kk mr kl ms kn mt ko mu mv bi translated">放弃</h1><p id="3716" class="pw-post-body-paragraph kq kr jb ks b kt mw kc kv kw mx kf ky kz my lb lc ld mz lf lg lh na lj lk ll ij bi translated"><em class="ln">值得注意的是我自己的参与:我是Jheronimus数据科学院</em> <a class="ae lm" href="https://www.jads.nl/" rel="noopener ugc nofollow" target="_blank"> <em class="ln">的数据科学教授，也是</em></a><a class="ae lm" href="https://www.scailable.net/" rel="noopener ugc nofollow" target="_blank"><em class="ln">Scailable</em></a><em class="ln">的联合创始人之一。因此，毫无疑问，我对Scailable有既得利益；我有兴趣让它成长，这样我们就可以最终将人工智能投入生产并兑现它的承诺。这里表达的观点是我自己的。</em></p></div></div>    
</body>
</html>