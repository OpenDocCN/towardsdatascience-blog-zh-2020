<html>
<head>
<title>Lane Change Detection — Computer Vision at Next stage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">车道变换检测——下一阶段的计算机视觉</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lane-change-detection-computer-vision-at-next-stage-914973f96f4b?source=collection_archive---------39-----------------------#2020-10-15">https://towardsdatascience.com/lane-change-detection-computer-vision-at-next-stage-914973f96f4b?source=collection_archive---------39-----------------------#2020-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f6bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">OpenCV和图像处理领域的领先创新</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/462540077a874abd3f1a7cb6e225b493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVIXEmmFhCawUXY4AsWwhg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算机视觉(图片由来自Pixabay 的<a class="ae kv" href="https://pixabay.com/illustrations/ai-future-intelligence-brain-4846063/" rel="noopener ugc nofollow" target="_blank">奥莰·卡里斯坎提供)</a></p></figure><p id="bfe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿，伙计们，兴奋起来吧，因为在本教程中，我们将了解如何使用计算机视觉和图像处理来检测汽车是否在道路上变道，所以不再拖延，让我们开始-</p><p id="94de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你一定听说过使用OpenCV haar cascade文件检测人脸、眼睛或汽车、公共汽车等物体。可以做到，但接下来呢？所以让我们用这个简单的检测方法来建立一些很酷的东西。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="953b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">1.资料组</h1><p id="c136" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本教程中，道路上汽车的视频文件被用作数据集。此外，我们可以使用图像数据集检测图像中的汽车，但在这里，当汽车改变车道时，我们会通过弹出窗口发出警告，因此对于这些动态，视频输入更可行。</p><h1 id="5ad7" class="lz ma iq bd mb mc mw me mf mg mx mi mj jw my jx ml jz mz ka mn kc na kd mp mq bi translated">2.投入</h1><p id="86b6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">第一步是给出教程中使用的输入OpenCV的haar级联文件，用于检测汽车的坐标，道路上汽车的视频文件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">接受输入</p></figure><p id="bfb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">cv2。VideoCapture()方法用于捕捉输入的视频，一段视频一般为每秒25幅图像/帧(fps)。在捕获输入后，使用循环提取帧，并使用汽车的haar级联文件检测到的坐标，我们在循环中围绕汽车绘制一个矩形，以在对捕获的帧执行其他操作时获得一致性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">检测汽车</p></figure><p id="34af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在OpenCV中使用BGR而不是RGB，所以(0，0，255)将在汽车上绘制一个红色矩形，而不是蓝色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/4e7831dbbb5999b2a1fda3998b275174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*tbO3EfTnr62VJf6T"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">框架(图片由作者提供)</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="78f8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">3.图像处理</h1><p id="3001" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们使用该帧，但是如果该帧具有非常高的分辨率，它将减慢所执行的操作，此外，该帧包括可以使用模糊来减少的噪声，这里使用高斯模糊。</p><p id="60e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们来看看一些图像处理的概念</p><h1 id="deec" class="lz ma iq bd mb mc mw me mf mg mx mi mj jw my jx ml jz mz ka mn kc na kd mp mq bi translated">3.1 HSV框架</h1><p id="5cdb" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在这里，我们使用从cv2捕获的帧中获得的HSV帧。VideoCapture()仅突出显示汽车转弯的点，并封锁其余道路&amp;汽车在道路上直行。设置上限和下限阈值来定义HSV中的颜色范围，以查看汽车改变车道的点，并用作帧的遮罩。下面是用来获得这个的代码片段-</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="423c" class="lz ma iq bd mb mc mw me mf mg mx mi mj jw my jx ml jz mz ka mn kc na kd mp mq bi translated">3.2侵蚀和膨胀</h1><p id="72f7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">腐蚀和膨胀是图像处理中使用的两种基本形态学操作。侵蚀算子在核的区域上具有局部最小值的效果，核是模板或遮罩。腐蚀用于减少图像中的散斑噪声，散斑是从图像中的物体边界被腐蚀掉的。膨胀是图像和内核的卷积，它具有局部最大值算子的效果。当添加像素以平滑图像中对象的边界时，应用膨胀来重新获得一些丢失的区域。</p><p id="bb85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从HSV帧中的第一步生成的遮罩现在用基本的形态学操作(腐蚀和膨胀)来处理。通过将帧和遮罩之间的按位AND运算应用于获取ROI(感兴趣区域)来生成结果帧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="1689" class="lz ma iq bd mb mc mw me mf mg mx mi mj jw my jx ml jz mz ka mn kc na kd mp mq bi translated">3.3车道检测</h1><p id="fc4a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">canny边缘检测器与Hough线变换一起用于车道检测。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/4dea39aebae072d07d76b694d1665eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/0*1tuqTf1G9d3NRoWa"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Canny边缘检测(图片作者提供)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a968" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">4.轮廓</h1><p id="67e2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">canny edge detector之类的算法用于查找分隔图像边缘的边缘像素，但它没有告诉如何查找对象或实体，因为我们无法组合/组装一些点和边缘，这里我们可以使用OpenCV中实现的轮廓概念，如cv2.findContours()。</p><p id="ae04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义—“轮廓是代表图像中曲线的点的列表。”轮廓由序列表示(序列是一个链表结构)，每个序列都编码了下一个点的位置信息。我们在ROI中多次运行cv2.findContours()来获取实体，然后使用cv2.drawContours()来绘制轮廓区域。轮廓可以是点、边、多边形等。所以在画等高线的时候，我们做多边形近似，找出一个区域的边长和面积。函数cv2.drawContours()的工作原理是从根节点开始绘制一棵树(数据结构),然后连接后续的点、边界框和freeman链码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="83b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">找到轮廓后的另一个重要任务是匹配它们。匹配轮廓意味着我们有两个单独的计算轮廓来相互比较，或者有一个轮廓来与抽象模板比较。</p><h1 id="5892" class="lz ma iq bd mb mc mw me mf mg mx mi mj jw my jx ml jz mz ka mn kc na kd mp mq bi translated">5.朋友圈</h1><p id="d2a9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们可以通过计算轮廓矩来比较两个轮廓。"矩是轮廓的总特征，通过将轮廓的所有像素相加来计算."</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/30ade37b902b75a27b61774562a1e7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/0*fdWiOVu5dvIApjpv"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片来自图书参考1《学习OpenCV》)</p></figure><p id="9353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">力矩类型- </strong></p><p id="2a23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ng">空间矩:</em> </strong> <em class="ng"> </em> m00，m10，m01，m20，m11，m02，m30，m21，m12，m03。</p><p id="ec44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ng">中心矩:</em> </strong> mu20，mu11，mu02，mu30，mu21，mu12，mu03。</p><p id="43fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ng">胡矩:</em>有七个胡矩(h0 — h6)或(h1 — h7)，两个符号都用。</p><p id="eb3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们计算力矩并使用cv2.fitEllipse()在点上拟合椭圆。该角度是从轮廓和力矩中找到的，因为改变车道需要45度旋转，这被认为是汽车转弯角度的阈值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/c7978b4529077908d894d797fd0000a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FAFzcbXK8bqq3Q7-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拟合椭圆(图片来自参考书籍1“学习OpenCV”)</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="26bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以使用Tkinter作为一个简单的弹出窗口来提醒变化，而不仅仅是打印变化车道的检测。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ccca9b2c79d4fe5fdc59b3071dded618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/0*__zFCv0EHdzE8yvX"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="abdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用画在车架上的矩形用绿线测量角度</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a924d99e7883f6f947afefb985abbb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/0*HPvLBcrFOOqQerIZ"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">弹出警告(图片由作者提供)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/7cb2b5deee66189e9949054b155540b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/0*5Poph6SAJELdXmgi"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出(图片由作者提供)</p></figure><h1 id="cfbb" class="lz ma iq bd mb mc mw me mf mg mx mi mj jw my jx ml jz mz ka mn kc na kd mp mq bi translated">6.总结和未来范围</h1><p id="8b89" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在本教程中，使用车道变换检测方法探索了智能汽车导航的一个小演示。</p><p id="7102" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算机视觉正在快速发展，其应用不仅在汽车的局部导航方面，而且在火星导航和产品检测领域都在进步，甚至正在开发医疗应用，并用于在早期阶段检测X射线图像中的癌症和肿瘤。</p><p id="4a4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">万岁，你坚持到了最后。太棒了。<a class="ae kv" href="https://github.com/Hitesh-Valecha/Car_Opencv" rel="noopener ugc nofollow" target="_blank">点击这里</a>获取我的<strong class="ky ir"> GitHub </strong>账户的源代码。</p><p id="daed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随意询问任何疑问，因为我们正在学习与机器一样的东西<a class="nk nl ep" href="https://medium.com/u/83a321d1f956?source=post_page-----914973f96f4b--------------------------------" rel="noopener" target="_blank"> Hitesh Valecha </a> …</p><p id="591f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献— </strong></p><ul class=""><li id="d9e3" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><em class="ng"> Bradski，Gary和Kaehler，Adrian </em>，<em class="ng">学习OpenCV:使用OpenCV库在C++中进行计算机视觉，O'Reilly Media，in C .第二版，2013年，@10.5555/2523356，ISBN-1449314651。</em></li><li id="af9d" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><em class="ng"> Laganiere，Robert，OpenCV计算机视觉应用编程食谱，Packt出版社，2014年第2版，@10.5555/2692691，ISBN — 1782161481。</em></li></ul><p id="80f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，由于创新从未停止，我邀请您阅读另一篇关于<a class="ae kv" rel="noopener" target="_blank" href="/ear-biometrics-machine-learning-a-little-further-1839e5d3e322"> <strong class="ky ir"> <em class="ng">耳朵生物识别</em> </strong> </a> <strong class="ky ir"> <em class="ng">的创新博客。</em> </strong></p></div></div>    
</body>
</html>