<html>
<head>
<title>Using GitHub Actions to speed up CI/CD in data science projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub动作加速数据科学项目中的CI/CD</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-github-actions-to-speed-up-ci-cd-in-data-science-projects-77d9b1c88228?source=collection_archive---------29-----------------------#2020-09-28">https://towardsdatascience.com/using-github-actions-to-speed-up-ci-cd-in-data-science-projects-77d9b1c88228?source=collection_archive---------29-----------------------#2020-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/34a548dbf313168a7c93b50aa7d9bde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nmhGciMOyoHrjpoW"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d0cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着关于云计算的最新进展，实现工具变得更加必要，这些工具同时是可扩展的，并且确保执行的可再现性。考虑到这一需求，一些工具应运而生，如<a class="ae kf" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，它们允许创建应用程序的“配方”，确保同一应用程序的不同版本平等运行。</p><p id="b4d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与虚拟机(VM)不同，虚拟机(VM)通过虚拟机管理程序提供基础架构并模拟处理器和内存，Docker在整个容器中共享这些资源，使开发人员可以更少地关注基础架构，而更多地关注应用程序的开发。尽管如此，项目和应用程序的容器化减轻了“它在我的机器上运行”的表述，因为它试图确保独立于开发者选择的平台，Docker容器总是以相同的方式执行。</p><p id="94eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鉴于容器化的好处不仅限于应用程序的开发，还可以用于其他领域，许多数据科学家开始使用Docker来容器化他们的分析、模型训练、仪表板和API，这不仅可以使项目的交付更容易(因为它减少了出现错误的可能性)，还可以确保一旦发现结果，就可以再次获得。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="690a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">CI/CD —持续集成和持续部署</h1><p id="5ceb" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">尽管数据科学家生成的许多见解和机器学习模型是有价值的，但当项目被困在不能被其他人使用的个人机器中时，它们无法为它们所插入的业务增加价值。因此，为了确保任何修改都被识别，并且其结果被扩展到其他团队，有持续集成和持续部署(CI/CD)的过程，这允许在项目的初始版本中测试和部署过程的自动化。</p><p id="e66e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多人可能熟悉CI/CD的概念，但是，用于此流程的许多工具都是付费的(例如<a class="ae kf" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>、<a class="ae kf" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>和<a class="ae kf" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> TravisCI </a>)，因此仅限于以下人员使用:</p><ul class=""><li id="0468" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">a)愿意支付这些工具的价格；</li><li id="6d36" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">或者b)在已经开发了CI/CD循环的公司工作。</li></ul><h1 id="0d35" class="ll lm it bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">GitHub和GitHub操作</h1><p id="9004" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">GitHub是一个知名的代码版本平台，拥有超过4000万用户和超过1亿个存储库，是一个巨大的开源代码来源，可供世界各地成千上万的人使用。</p><p id="eee4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GitHub于2019年创建了GitHub Actions工具，旨在支持开源项目的创建，并允许其用户抽象涉及CI/CD的流程。它允许用户定义的工作流的自动化，以帮助集成测试、拉请求的验证和许多其他特性。此外，用户使用的动作数量与日俱增，因为许多公司都在寻求开发工具来帮助用户社区。许多这些行动已经允许集成许多流行的工具，如Docker，AWS CloudFormation，Terraform，以及许多其他可以在<a class="ae kf" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank">这里</a>找到的工具。</p><p id="9751" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管GitHub Actions只对非私有存储库免费使用，但在考虑使用任何GitHub企业工具之前，在私有项目中可以利用不同级别的使用。这打开了一扇门，使得许多开发开源项目的人可以测试他们的工具，并以更加自动化和可扩展的方式传播他们的发现。</p><h1 id="9139" class="ll lm it bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">Docker登录&amp; Docker构建和推送</h1><p id="c871" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">与GitHub操作一起使用的工具之一是存储库中的登录操作，它允许存储Docker映像(如AWS的<a class="ae kf" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>、<a class="ae kf" href="https://aws.amazon.com/pt/ecr/" rel="noopener ugc nofollow" target="_blank">ECR</a>、GCP的<a class="ae kf" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">GCR</a>)，以及构建这些映像，而无需占用用户的机器。考虑到这些，在CI工作流文件中声明了两个操作，可以在这些链接中找到:<a class="ae kf" href="https://github.com/docker/login-action" rel="noopener ugc nofollow" target="_blank"> docker/login-action </a>和<a class="ae kf" href="https://github.com/docker/build-push-action" rel="noopener ugc nofollow" target="_blank">docker/build-push-action</a>。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="251a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将数据科学融入CI/CD流程</h1><p id="cc6c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">数据科学领域充满了不同的框架、依赖项和不同的语言，可以根据数据科学家的需求和能力来使用，但其中一个共同的事实是，它们都有可能被容器化过程封装，这有助于确保项目的可重复性。</p><p id="5c71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到这一点，我用来部署GitHub Actions自动化工具的例子涉及到使用R的<a class="ae kf" href="https://shiny.rstudio.com/" rel="noopener ugc nofollow" target="_blank"> Shiny </a>库开发一个web应用程序。然而，同样的工作流实现可以用于部署使用Python的<a class="ae kf" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>开发的API，即，或任何其他可以封装在Docker容器中的框架。</p><p id="9c35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">项目可以在这里找到:<a class="ae kf" href="https://github.com/paeselhz/ghActionsDockerShiny" rel="noopener ugc nofollow" target="_blank">paeselhz/ghActionsDockerShiny</a>。我不会详细介绍应用程序的开发，因为我使用的例子相对简单，没有详细的开发。本文的重点是项目的容器化，以及构建图像并将其存储在<a class="ae kf" href="http://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>中的工作流自动化，以供进一步下载。</p><h1 id="8251" class="ll lm it bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">创建Dockerfile文件</h1><p id="ba5a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">对于那些熟悉Docker文件及其语法的人来说，它的执行与使用Docker在本地开发、构建和运行的项目中的预期是一样的。在其中，我们声明了将用于进一步安装库和依赖项的基本映像，以及项目的配置、文件复制和其他通常可以添加到Dockerfile中的步骤。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="fac0" class="nq lm it nm b gy nr ns l nt nu">FROM rocker/shiny:4.0.0</span><span id="9619" class="nq lm it nm b gy nv ns l nt nu">RUN apt-get update \<br/>  &amp;&amp; apt-get install -y \<br/>    libxml2-dev \<br/>    libglpk-dev \<br/>  &amp;&amp; install2.r \<br/>    --error \<br/>    dplyr \<br/>    shiny \<br/>    purrr \<br/>    highcharter \<br/>    shinyWidgets \<br/>    shinycssloaders \<br/>    devtools \<br/>    xml2 \<br/>    igraph \<br/>    readr<br/>  <br/>RUN R -e "devtools::install_github('wilsonfreitas/rbcb')"</span><span id="479d" class="nq lm it nm b gy nv ns l nt nu">COPY . /srv/shiny-server</span><span id="3cc0" class="nq lm it nm b gy nv ns l nt nu">RUN chmod -R 777 /srv/shiny-server</span></pre><p id="0aee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个脚本位于项目根目录中，负责收集已经安装了Shiny及其依赖项的映像，并安装将由r。</p><h1 id="d4d1" class="ll lm it bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">创建工作流文件</h1><p id="bed0" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">为了让GitHub Actions知道工作流自动化需要采取哪些步骤，有必要在项目中创建一个文件，该文件位于。github/workflows/main.yml，文件语法与任何YAML文件相同，易于编码。如果用户不想在本地完成这个过程并提交更改，GitHub本身有一个在线代码编辑器来创建工作流。</p><p id="e7ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个文件中声明了一些步骤，例如工作流的名称、将用于部署工作流执行的触发器以及它将负责执行的作业。文件的名称和触发器部分是高度可定制的，用户可以以多种方式对其进行更改，此外，在作业部分，需要几个步骤来完成作业:登录Docker Hub，配置BuildX(将用于构建映像的工具)，配置QEMU(将允许多平台构建的工具)，将构建的映像部署到Docker Hub，注销并清理机器以确保没有进程仍在运行。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="6c28" class="nq lm it nm b gy nr ns l nt nu"># Setting up a Workflow to work with Github Actions</span><span id="8f5f" class="nq lm it nm b gy nv ns l nt nu">name: ci</span><span id="8ce8" class="nq lm it nm b gy nv ns l nt nu"># Controls to when trigger the GH Action<br/># Below are configurations to the following triggers:<br/># - commits at master branch<br/># - tag commits at the project<br/># - scheduled to run at 01:00GMT<br/># The user can also configure triggers at pull requests<br/># as well as remove branches from triggering GH Actions<br/>on:<br/>  push:<br/>    branches: [ master ]<br/>    tags: [ '*.*.*' ]<br/>  schedule:<br/>    - cron: '0 1 * * *'</span><span id="4606" class="nq lm it nm b gy nv ns l nt nu"># Below there is the job configuration to build the image<br/># and push it to a DockerHub repository<br/>jobs:<br/>  docker:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      -<br/>        name: Checkout<br/>        uses: actions/checkout@v2<br/>      -<br/>        name: Prepare<br/>        id: prep<br/>        run: |<br/>          DOCKER_IMAGE=&lt;USER_NAME&gt;/&lt;REPOSITORY_NAME&gt;<br/>          VERSION=noop<br/>          if [ "${{ github.event_name }}" = "schedule" ]; then<br/>            VERSION=nightly<br/>          elif [[ $GITHUB_REF == refs/tags/* ]]; then<br/>            VERSION=${GITHUB_REF#refs/tags/}<br/>          elif [[ $GITHUB_REF == refs/heads/* ]]; then<br/>            VERSION=$(echo ${GITHUB_REF#refs/heads/} | sed -r 's#/+#-#g')<br/>            if [ "${{ github.event.repository.default_branch }}" = "$VERSION" ]; then<br/>              VERSION=edge<br/>            fi<br/>          fi<br/>          TAGS="${DOCKER_IMAGE}:${VERSION}"<br/>          if [[ $VERSION =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then<br/>            MINOR=${VERSION%.*}<br/>            MAJOR=${MINOR%.*}<br/>            TAGS="$TAGS,${DOCKER_IMAGE}:${MINOR},${DOCKER_IMAGE}:${MAJOR},${DOCKER_IMAGE}:latest"<br/>          elif [ "${{ github.event_name }}" = "push" ]; then<br/>            TAGS="$TAGS,${DOCKER_IMAGE}:sha-${GITHUB_SHA::8}"<br/>          fi<br/>          echo ::set-output name=version::${VERSION}<br/>          echo ::set-output name=tags::${TAGS}<br/>          echo ::set-output name=created::$(date -u +'%Y-%m-%dT%H:%M:%SZ')<br/>      -<br/>        name: Set up QEMU<br/>        uses: docker/setup-qemu-action@v1<br/>      -<br/>        name: Set up Docker Buildx<br/>        uses: docker/setup-buildx-action@v1<br/>      -<br/>        name: Login to DockerHub<br/>        if: github.event_name != 'pull_request'<br/>        uses: docker/login-action@v1<br/>        with:<br/>          username: ${{ secrets.DOCKERHUB_USERNAME }}<br/>          password: ${{ secrets.DOCKERHUB_TOKEN }}<br/>      -<br/>        name: Build and push<br/>        id: docker_build<br/>        uses: docker/build-push-action@v2<br/>        with:<br/>          context: .<br/>          file: ./Dockerfile<br/>          platforms: linux/amd64<br/>          push: ${{ github.event_name != 'pull_request' }}<br/>          tags: ${{ steps.prep.outputs.tags }}<br/>          labels: |<br/>            org.opencontainers.image.title=${{ github.event.repository.name }}<br/>            org.opencontainers.image.description=${{ github.event.repository.description }}<br/>            org.opencontainers.image.url=${{ github.event.repository.html_url }}<br/>            org.opencontainers.image.source=${{ github.event.repository.clone_url }}<br/>            org.opencontainers.image.version=${{ steps.prep.outputs.version }}<br/>            org.opencontainers.image.created=${{ steps.prep.outputs.created }}<br/>            org.opencontainers.image.revision=${{ github.sha }}<br/>            org.opencontainers.image.licenses=${{ github.event.repository.license.spdx_id }}</span></pre><p id="6e44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">工作流代码几乎没有外部依赖性，假定Docker图像名称及其标签的创建在该代码中，然而，它需要一对秘密来登录Docker Hub，在这种情况下，需要Docker使用的用户名和一个令牌来登录Docker Hub ( <a class="ae kf" href="https://hub.docker.com/settings/security" rel="noopener ugc nofollow" target="_blank">可以在这里生成</a>)。有了用户名和令牌，用户只需进入他们的存储库，在“设置”选项卡中，在“机密”子页中添加令牌，如下图所示:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/c5ef55e729a0bf81f9fdcd100308deed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qtVtp5cCK6tAkEwrKABIjw.png"/></div></div></figure><p id="195c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这些步骤，项目应该能够使用GitHub动作来执行，从而允许构建、测试和部署过程的自动化。</p><p id="867f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文使用的示例中，最终的映像可以在Docker Hub <a class="ae kf" href="https://hub.docker.com/repository/docker/lhzpaese/ghactions_docker_shiny/general" rel="noopener ugc nofollow" target="_blank">这里</a>找到，并通过运行以下命令进行本地测试:</p><p id="03e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">` docker run-p 3838:3838 lhzpaese/GH actions _ docker _ shiny:latest '</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="19a8" class="nq lm it bd ln nx ny dn lr nz oa dp lv kr ob oc lz kv od oe md kz of og mh oh bi translated">来源:</h2><p id="c6bc" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">本文中使用的许多项目和工具的参考都是以超链接的形式随文本一起添加的。然而，我想离开Docker网上研讨会，它是这个项目的灵感来源，由<a class="ae kf" href="https://github.com/metcalfc" rel="noopener ugc nofollow" target="_blank"> metcalfc </a>主持，他在会上介绍了用于集成GitHub Actions和Docker的工具。</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="df02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的关注，如有任何问题或建议，请随时通过<a class="ae kf" href="https://www.linkedin.com/in/lhzpaese/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/lhzpaese/</a>和<a class="ae kf" href="https://github.com/paeselhz" rel="noopener ugc nofollow" target="_blank"> paeselhz </a>联系我。</p></div></div>    
</body>
</html>