<html>
<head>
<title>Modeling Biomedical Data for a Drug Discovery Knowledge Graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为药物发现知识图建模生物医学数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modelling-biomedical-data-for-a-drug-discovery-knowledge-graph-a709be653168?source=collection_archive---------22-----------------------#2020-10-06">https://towardsdatascience.com/modelling-biomedical-data-for-a-drug-discovery-knowledge-graph-a709be653168?source=collection_archive---------22-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b370adc4329b24a8c0cddd12b360a36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0tPc0Rt0u4LoMKrNIa0Ig.png"/></div></div></figure><div class=""/><div class=""><h2 id="3c3b" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">听取阿斯利康的数据科学和人工智能的汇报</h2></div><p id="4360" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本月早些时候，阿斯利康的副首席科学家娜塔莉·库尔巴托娃加入了我们的第一系列<a class="ae lm" href="https://discuss.grakn.ai/t/grakn-orbit-an-event-by-the-grakn-community/2177" rel="noopener ugc nofollow" target="_blank">轨道</a>。</p><p id="ce1f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Natalie在阿斯利康的数据科学和人工智能部门工作，在那里她专注于数据建模、将数据集成到知识图、预测算法以及其中的主题。</p><h1 id="3479" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated"><strong class="ak">目标:预测新的疾病目标</strong></h1><p id="ba50" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">在阿斯利康，Natalie的团队专注于构建一个知识图来预测新的疾病目标(基因或蛋白质目标)，他们称之为<em class="mk">发现图</em>。在构建过程中，Natalie向我们介绍了两种要考虑的数据源:</p><p id="8647" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">结构化数据</strong>指的是生物信息学中公开可用的数据集，这些数据集已经在行业中进行了整理和广泛使用。虽然生物医学结构化数据是机器可读的，但通常不容易处理。特别是，很难集成这些数据集，因为它们可以以不同的方式描述类似的概念，例如:<em class="mk">不同的id彼此不一致</em>。一些最常用的公开可用数据集包括:<a class="ae lm" href="https://www.ensembl.org/index.html" rel="noopener ugc nofollow" target="_blank"> Ensembl </a>、<a class="ae lm" href="https://www.uniprot.org/" rel="noopener ugc nofollow" target="_blank"> Uniprot </a>、<a class="ae lm" href="https://www.ebi.ac.uk/chembl/" rel="noopener ugc nofollow" target="_blank"> ChEMBL </a>、<a class="ae lm" href="https://pubchem.ncbi.nlm.nih.gov/" rel="noopener ugc nofollow" target="_blank"> PubChem </a>、<a class="ae lm" href="https://omnipathdb.org/" rel="noopener ugc nofollow" target="_blank"> OmniPath </a>、<a class="ae lm" href="https://reactome.org/what-is-reactome" rel="noopener ugc nofollow" target="_blank"> Reactome </a>、GO、CTD、<a class="ae lm" href="https://www.proteinatlas.org/" rel="noopener ugc nofollow" target="_blank">human protein tlas</a>。</p><p id="458e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">非结构化数据</strong>指来自文本的数据。为了处理这个，我们需要使用NLP(自然语言处理)管道，然后处理它们的输出。在这里，困难在于这些数据往往是杂乱和嘈杂的。对于他们的NLP引擎，娜塔莉的团队使用了开源库SciBERT以及阿斯利康的专有工具。</p><p id="c6a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Natalie然后向我们介绍了她的团队为他们的发现图构建的模式(幻灯片如下)。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/bd76c48408d1db6ff49e507274b14995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WHh3C8BSV2VtHFNAX0MEg.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">TypeDB Studio中的可视化模式——关注已定义的实体。经许可重新发布的幻灯片。</p></figure><p id="6452" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">娜塔莉的团队主要对研究<code class="fe mu mv mw mx b">compounds</code>、<code class="fe mu mv mw mx b">diseases</code>和<code class="fe mu mv mw mx b">gene/proteins</code>感兴趣——他们亲切地称之为<em class="mk">金三角</em>。这些实体之间的连接需要尽可能的稳固和可靠，这意味着将所有可能的、相关的数据源吸收到它们的<em class="mk">发现图中。</em></p><p id="ec8b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个<em class="mk">发现图</em>每天都在变大。到今天为止，它已经广泛地包含了这三种实体类型:</p><p id="a6fa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mu mv mw mx b">gene-protein</code>:19371<br/><code class="fe mu mv mw mx b">disease</code>:11565<br/><code class="fe mu mv mw mx b">compound</code>:14294<br/><em class="mk">实体类型之间还有656206个关系。</em></p><h1 id="09c4" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">他们是如何模拟这个“金三角”的？</h1><p id="6777" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">娜塔莉接着解释了她是如何对<em class="mk">发现图</em>的每一部分建模的，并一路举例。</p><h2 id="d32f" class="my lo jb bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated"><strong class="ak">模拟基因和蛋白质</strong></h2><p id="3037" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">首先，她的团队着眼于如何模拟基因和蛋白质。Natalie的团队没有将这些分成两个实体，而是决定将它们建模为一个实体，他们称之为<code class="fe mu mv mw mx b">gene-protein</code>。这有助于减少噪声和偏差。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/336f11baaa976bb5684912a8550e8707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEPYp1wIpkopPdOh9gpVSA.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">在TypeDB Studio中可视化的[基因-蛋白质]实体。经许可重新发布的幻灯片。</p></figure><p id="7264" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">相关属性<code class="fe mu mv mw mx b">gene-name</code>和<code class="fe mu mv mw mx b">chromosome</code>，指定相应的基因名称，以及该基因所在位置的染色体名称。<code class="fe mu mv mw mx b">gene-id</code>属性被建模为一个<em class="mk">抽象</em>，它包含每个<code class="fe mu mv mw mx b">gene-protein</code>的唯一id。</p><pre class="mm mn mo mp gt nk mx nl nm aw nn bi"><span id="1a15" class="my lo jb mx b gy no np l nq nr">💡 There may have been scenarios where a parent attribute is only defined for other attributes to inherit, and under no circumstance do we expect to have any instances of this parent. To model this logic in the schema, use the abstract keyword.</span></pre><p id="cbfa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mu mv mw mx b">interaction</code>关系建立了<code class="fe mu mv mw mx b">gene-protein</code>之间的交互，其中一个<em class="mk">扮演</em> <code class="fe mu mv mw mx b">gene-source</code>的角色，另一个<code class="fe mu mv mw mx b">gene-target</code>。这种关系在预测新的疾病靶点中特别重要，因为它连接了基因和蛋白质之间的调节相互作用。</p><h2 id="de03" class="my lo jb bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated"><strong class="ak">建模化合物</strong></h2><p id="3d95" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">娜塔莉的团队将小分子和抗体放在一起，而不是将它们分开，作为一个实体类型，他们称之为<code class="fe mu mv mw mx b">compound</code>。对于这些数据，他们使用了数据源:PubChem和ChEMBL。</p><p id="e564" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些数据库大约95%相同，但有些化学物质只存在于两个来源中的一个。为了处理这些独特的化学物质，他们决定分配一个<code class="fe mu mv mw mx b">chembl-id</code>作为主要ID，如果它有一个，但是如果它没有那个ID，那么他们将使用<code class="fe mu mv mw mx b">pubchem-id</code>。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/292ae8409a6bb059ce2fa06095964d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ylMfJSLV1jWhghyaCS-zQ.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">在TypeDB Studio中可视化的[复合]实体。经许可重新发布的幻灯片。</p></figure><p id="225b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">正如我们在Natalie的幻灯片上看到的,<code class="fe mu mv mw mx b">compound</code>用更多的属性建模。属性<code class="fe mu mv mw mx b">compound-id</code>被用作一个抽象属性，其子属性<code class="fe mu mv mw mx b">preferred-compound-id</code>、<code class="fe mu mv mw mx b">pubchem-id</code>、<code class="fe mu mv mw mx b">chembl-id</code>和<code class="fe mu mv mw mx b">drugbank</code>。</p><p id="984b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了获得<code class="fe mu mv mw mx b">preferred-compound-id</code>属性的值，他们使用两个<em class="mk">规则</em>来根据下面的逻辑分配<code class="fe mu mv mw mx b">chembl-id</code>或<code class="fe mu mv mw mx b">pubchem-id</code>:</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/08a541c3341be8c3e737ad1800920a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPXjgYreT_yLvS4W7T9SgQ.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">用于将适当的(ID)分配给特定[化合物]的规则。经许可重新发布的幻灯片。</p></figure><p id="1dd9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">第一个规则将<code class="fe mu mv mw mx b">chembl-id</code>的值(如果存在的话)附加到<code class="fe mu mv mw mx b">preferred-compound-id</code>。第二个规则首先检查<code class="fe mu mv mw mx b">compound</code>是否没有<code class="fe mu mv mw mx b">chembl-id</code>，如果是，那么它将<code class="fe mu mv mw mx b">pubchem-id</code>属性的值附加到<code class="fe mu mv mw mx b">preferred-compound-id</code>。这使得在特别查询<em class="mk">化合物</em>时，很容易查询该属性。</p><h2 id="d34b" class="my lo jb bd lp mz na dn lt nb nc dp lx kz nd ne lz ld nf ng mb lh nh ni md nj bi translated"><strong class="ak">建模疾病</strong></h2><p id="31fa" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">娜塔莉解释说，要建模的最复杂的概念是疾病。这是因为疾病有多个本体，每个本体都有不同的id。例如，一种疾病可能有来自不同本体和疾病层次的多个id。在下面的幻灯片中，娜塔莉向我们展示了三个数据源的层次结构:EFO、蒙多和多德。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/025d564eafa909af8ac2508a6c05e656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Fwm5dWhsOljGmaljCt3qQ.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">疾病数据源的本体论层次。经许可重新发布的幻灯片。</p></figure><p id="31e0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这种异质性的原因是，最初，这些本体是在不同的子域中设计的:例如，医生使用Orphanet，而医学研究小组可能使用另一个:EFO或MONDO。这导致数据互不关联，互不相干。Natalie和她的团队希望能够建立一个疾病实体模型，在这些本体之间交叉引用。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/b34d493d96db58b9d791270a1e5c3fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMY0rHx8fk5MtII_zxIVAQ.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">数据是从哪里来的？经许可重新发布的幻灯片。</p></figure><p id="26b6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为这个挑战，他们选择了建模两种实体类型:<code class="fe mu mv mw mx b">disease</code>和<code class="fe mu mv mw mx b">ontology</code>。他们使用一个<code class="fe mu mv mw mx b">disease-hierarchy</code>关系——一个<em class="mk">三元关系</em>——来连接这两者。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/6ca40694445eb7ba0c4124ef49bde449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMobG4Msr9E6glAPPl3J9Q.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">在TypeDB Studio中可视化的[疾病]实体。经许可重新发布的幻灯片。</p></figure><p id="9041" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有了这个<code class="fe mu mv mw mx b">disease-hierarchy</code>关系，Natalie和她的团队能够编写有用的查询，例如:</p><blockquote class="ns"><p id="71e7" class="nt nu jb bd nv nw nx ny nz oa ob ll dk translated">给我所有“慢性肾脏病”患儿的疾病节点使用EFO本体。</p></blockquote><figure class="oc od oe of og is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/c9aa258f29d91fe7b082bc1f15511304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNsq1OKyxC0LG_aeDukGQA.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">示例查询和层次结构中的预期路径。经许可重新发布的幻灯片。</p></figure><p id="7a80" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个查询展示了模型的强大功能——使用TypeDB的模式的强大功能——因为即使他们只是询问高级疾病，查询也将返回该疾病的所有可能的<em class="mk">子类型</em>。</p><p id="0cb7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了对此建模，Natalie再次利用TypeDB的规则引擎:</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/4d45482c89577f14d1a175a73f178abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADxkccVkEoNGTeX7ilB5yw.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">TypeDB中的传递性规则示例。经许可重新发布的幻灯片。</p></figure><p id="a8a2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面幻灯片中显示的规则<code class="fe mu mv mw mx b">single-ontology-transitivity</code>在<code class="fe mu mv mw mx b">disease-hierarchy</code>关系中创建了一个传递性。这个规则的结果是，如果查询一个<em class="mk">扮演</em> <code class="fe mu mv mw mx b">superior-disease</code>的疾病，将会推断出<em class="mk">扮演</em> <code class="fe mu mv mw mx b">subordinate-disease</code>的所有疾病。此外，这意味着即使您不指定您要查询的本体，您仍然会返回所有摄取的数据源中该特定父疾病的所有<em class="mk">从属疾病、</em>。</p><p id="2a59" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当特定的本体中没有相应的引用ID时，这种类型的规则特别有用。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/261ef81cbebd567d6257ccf21b0004c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4agUYMVfpkqE__p25kiJcA.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">将疾病实体映射到适当的[疾病id]。经许可重新发布的幻灯片。</p></figure><p id="9ec5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">正如Natalie向我们展示的，当某个<code class="fe mu mv mw mx b">disease-id</code>不存在于某个本体中时，我们可以沿着层级向上，直到我们找到一个确实存在的ID，然后分配那个ID。为此，Natalie使用了另一个<em class="mk">传递规则</em>:</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/2880063c9c45d7336b83ab7adfe989a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4HWJootafQiNc8OZtWtmQ.jpeg"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">当一个(id)不存在时，这个传递性规则从父节点向下拉。经许可重新发布的幻灯片。</p></figure><p id="a91e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">第一个规则<code class="fe mu mv mw mx b">determine-best-mesh-id-1</code>，如果一个<code class="fe mu mv mw mx b">mesh-id</code>已经存在，就给一个<code class="fe mu mv mw mx b">disease</code>实体分配一个<code class="fe mu mv mw mx b">best-mesh-id</code>属性。然后，第二个规则声明，如果我们不知道<code class="fe mu mv mw mx b">mesh-id</code>，我们希望从父疾病中删除<code class="fe mu mv mw mx b">mesh-id</code>。娜塔莉强调了这是多么有效，以及在实践中结果是多么积极。</p><h1 id="1071" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated"><strong class="ak">数据整合</strong></h1><p id="45e9" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">一旦领域被建模，我们就可以开始接收数据了。为此，有两种方法可以采用:</p><ul class=""><li id="99d5" class="oh oi jb ks b kt ku kw kx kz oj ld ok lh ol ll om on oo op bi translated"><strong class="ks jc">数据工厂:</strong>在加载到知识图之前集成数据</li><li id="4f48" class="oh oi jb ks b kt oq kw or kz os ld ot lh ou ll om on oo op bi translated"><strong class="ks jc">数据模式:</strong>通过灵活的数据加载和后续推理，数据集成发生在知识图中</li></ul><p id="565b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Natalie的研究小组使用<strong class="ks jc">数据模式</strong>方法，使用知识图本身作为整合数据的工具。这对一些开发者来说可能是反直觉的。</p><p id="34d4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您设想添加额外的未知数据源，那么您必须足够灵活地操作数据库中的数据。这使得复制另一个人的工作[论文]来验证假设。</p><p id="faec" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在研究工作的情况下，灵活性是必不可少的，正如Natalie在之前的冲突mesh-id中向我们展示的那样。</p><p id="1caa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如上所述，解决方案是使用TypeDB的推理引擎。</p><h1 id="8b32" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">摘要</h1><p id="ce88" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">最后，Natalie花了几分钟总结了这种方法在数据模式和逻辑推理方面的优势。</p><p id="f22f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">其他图形数据库在数据加载方面很灵活，但缺乏验证。虽然灵活性很重要，但是验证对于保持数据的一致性也是必要的。</p><blockquote class="ns"><p id="831f" class="nt nu jb bd nv nw nx ny nz oa ob ll dk translated">几个月前，Natalie的一个初级同事不小心将电影数据加载到了他们的生物医学知识图表中。第二天早上，团队的其他成员惊讶地看到他们的生物医学数据中有电影和演员！</p></blockquote><p id="6596" class="pw-post-body-paragraph kq kr jb ks b kt ov kc kv kw ow kf ky kz ox lb lc ld oy lf lg lh oz lj lk ll ij bi translated">使用TypeDB，在插入时通过数据模式对数据进行逻辑验证，以确保正确的数据进入知识图。</p><p id="61e6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Natalie认为这个数据库在正式的模式设计、逻辑推理和预测算法能力之间提供了一个很好的平衡。根据她的经验，在将数据加载到知识图之前，需要先对数据进行建模。和灵活的模式有助于找到这种理想的平衡。</p><pre class="mm mn mo mp gt nk mx nl nm aw nn bi"><span id="504d" class="my lo jb mx b gy no np l nq nr">💡 Note that all prediction algorithms depend on what you load in the database — aka: be careful what you put in the knowledge graph. The noise level should be as low as possible.</span></pre><p id="1c04" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后，她谈到了我们是在加载数据之前还是之后集成数据的关键选择，在他们的情况下(如上所述),一旦插入数据库，就在加载之后完成。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/125db09b3451bfd2be94dd993ebd0c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBCNkdAKUceR7z5kEOWnIQ.jpeg"/></div></div></figure><p id="6602" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">特别感谢娜塔莉和她在阿斯利康的团队的热情、奉献和透彻的解释。</p><p id="cbef" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你可以在Vaticle的YouTube频道<a class="ae lm" href="https://youtube.com/c/vaticle" rel="noopener ugc nofollow" target="_blank">这里</a>找到完整的演示。</p></div></div>    
</body>
</html>