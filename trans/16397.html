<html>
<head>
<title>Normalization Techniques in Python Using NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中使用NumPy的规范化技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/normalization-techniques-in-python-using-numpy-b998aa81d754?source=collection_archive---------2-----------------------#2020-11-12">https://towardsdatascience.com/normalization-techniques-in-python-using-numpy-b998aa81d754?source=collection_archive---------2-----------------------#2020-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="05cb" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/getting-started" rel="noopener" target="_blank">入门</a></h2><div class=""/><div class=""><h2 id="718f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用Python和NumPy规范化数据集以进行分析和建模。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/cfaa3e6b2426d7cfd6031e20b8a801e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoL6IhKZZYcdGyHP6DMkaA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者通过<a class="ae le" href="https://www.flickr.com/photos/cmmorrow/9654448075/in/album-72157635320846374/" rel="noopener ugc nofollow" target="_blank"> Flickr </a>拍摄的照片</p></figure><p id="1adc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">数据科学不仅仅是开发模型。大量工作涉及清理数据和选择要素。将具有相似分布但显著不同均值的要素或比例差异极大的要素插入模型可能会导致错误的预测。这些问题的一个常见解决方案是首先“归一化”特征以消除均值和方差的显著差异。</p><p id="6f74" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">术语“规范化”可能会引起误解(也不应该与<a class="ae le" href="https://en.wikipedia.org/wiki/Database_normalization" rel="noopener ugc nofollow" target="_blank">数据库规范化</a>相混淆)，因为它在统计学中意味着许多事情。然而，标准化技术中有一个共同的主题，就是将单独的数据集对齐，以便于比较。我们将重点介绍的两种技术是残差提取和重新缩放，残差提取会改变数据集的均值，而重新缩放会拉伸和压缩数据集中的值，以适应从0到1的范围。不用说，这两种技术都将消除应用于数据集的单元。幸运的是，移位和缩放技术都可以在Python中轻松完成，并使用NumPy Python包高效地进行计算。</p><h2 id="439a" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">提取残差</h2><p id="5728" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们先来探讨一下残差提取技术。残差是数据集中的值与数据集平均值之间的相对差值。当数据集具有相似的分布但显著不同的均值，从而使数据集之间的比较变得困难时，这种技术非常有用。例如，假设我们有一个由两个同等规模的不同班级参加的考试。问题一样，顺序一样，答案也一样。但是两个班的平均分不一样。一班在考试中平均得了82分，二班平均得了77分。我们怎样才能把两个班的分数结合起来呢？</p><p id="b75a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们从设置Python环境开始:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="04bc" class="mb mc iq mz b gy nd ne l nf ng">import numpy as np<br/>import scipy.stats as st<br/>from sci_analysis import analyze<br/>%matplotlib inline</span><span id="8a3f" class="mb mc iq mz b gy nh ne l nf ng">np.random.seed(12)</span></pre><p id="2dd8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">上面的代码导入NumPy包作为<code class="fe ni nj nk mz b">np</code>，SciPy stats模块作为<code class="fe ni nj nk mz b">st</code>——它将用于创建我们的数据集，sci_analysis Python包中的<code class="fe ni nj nk mz b">analyze</code>函数用于绘制结果，最后，我们设置随机数生成器种子值，以便结果是可重复的。作为参数传递给<code class="fe ni nj nk mz b">np.random.seed()</code>的数字12是任意选择的。现在，让我们创建两个数据集，每个类一个:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="2cee" class="mb mc iq mz b gy nd ne l nf ng">dist1 = st.norm.rvs(82, 4, size=25).astype(int)<br/>dist2 = st.norm.rvs(77, 7, size=25).astype(int)<br/>print(dist1)<br/>print(dist2)</span></pre><p id="9cd9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="ab77" class="mb mc iq mz b gy nd ne l nf ng">[83 79 82 75 85<br/> 75 82 81 78 93<br/> 79 83 86 77 87<br/> 81 86 78 77 86<br/> 84 82 84 84 77]</span><span id="5c68" class="mb mc iq mz b gy nh ne l nf ng">[61 65 64 61 72<br/> 73 76 78 74 75<br/> 77 70 72 77 72<br/> 72 76 86 79 74<br/> 72 76 92 54 80]</span></pre><p id="ca2a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">类别1由<code class="fe ni nj nk mz b">dist1</code>表示，类别2由<code class="fe ni nj nk mz b">dist2</code>表示。两个变量都是25个正态分布随机变量的NumPy数组，其中<code class="fe ni nj nk mz b">dist1</code>的平均值为82，标准差为4，而<code class="fe ni nj nk mz b">dist2</code>的平均值为77，标准差为7。两个数组都被转换成整数，以完成我们的考试分数示例。我们可以用下面的代码来可视化课堂成绩:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="61fc" class="mb mc iq mz b gy nd ne l nf ng">analyze(<br/>    {'dist1': dist1, 'dist2': dist2},<br/>    title='Different means',<br/>    nqp=False,<br/>)<br/>print(f'dist1 mean: {np.mean(dist1)} std dev: {np.std(dist1)}')<br/>print(f'dist2 mean: {np.mean(dist2)} std dev: {np.std(dist2)}')</span></pre><p id="c7db" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8cbdfa9fe07f8051edbfa8f38f395225.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*Z9S4Xnu-kTbgj0pL6P41Kg.png"/></div></figure><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="e9ee" class="mb mc iq mz b gy nd ne l nf ng">dist1 mean: 81.76 std dev: 4.197904239022134<br/>dist2 mean: 73.12 std dev: 7.7785345663563135</span></pre><p id="7ae6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从上图以及<code class="fe ni nj nk mz b">dist1</code>和<code class="fe ni nj nk mz b">dist2</code>的均值和标准差，我们可以看出分布不匹配。</p><p id="f290" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在让我们计算<code class="fe ni nj nk mz b">dist1</code>和<code class="fe ni nj nk mz b">dist2</code>的残差:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="5acb" class="mb mc iq mz b gy nd ne l nf ng">dist1_norm = dist1 - int(np.mean(dist1))<br/>dist2_norm = dist2 - int(np.mean(dist2))<br/>print(dist1_norm)<br/>print(dist2_norm)</span></pre><p id="db14" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="beeb" class="mb mc iq mz b gy nd ne l nf ng">[   2  -2   1  -6   4 <br/>   -6   1   0  -3  12 <br/>   -2   2   5  -4   6<br/>    0   5  -3  -4   5<br/>    3   1   3   3  -4]</span><span id="845c" class="mb mc iq mz b gy nh ne l nf ng">[ -12  -8  -9 -12  -1<br/>    0   3   5   1   2<br/>    4  -3  -1   4  -1<br/>   -1   3  13   6   1  <br/>   -1   3  19 -19   7]</span></pre><p id="18dc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">残差是每个值与该值的分布平均值之间的差。换句话说，每个残差都是距离每个分布的平均值的距离，现在平均值为零。因为现在每个分布的平均值为零，所以它们可以直接相互比较。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="b0c6" class="mb mc iq mz b gy nd ne l nf ng">analyze(<br/>    {'dist1': dist1_norm, 'dist2': dist2_norm},<br/>    title='Normalized',<br/>    nqp=False,<br/>)<br/>print(f'dist1 mean: {np.mean(dist1_norm)} std dev: {np.std(dist1_norm)}')<br/>print(f'dist2 mean: {np.mean(dist2_norm)} std dev: {np.std(dist2_norm)}')</span></pre><p id="ac8a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/82f61921eb5c14edc5150173340c8cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*sAXbM1kcD55-0HmMJjvvKQ.png"/></div></figure><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="80f8" class="mb mc iq mz b gy nd ne l nf ng">dist1 mean: 0.76 std dev: 4.197904239022134<br/>dist2 mean: 0.12 std dev: 7.7785345663563135</span></pre><p id="9735" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以看到平均值现在接近于零(如果在将值转换为整数时没有舍入误差，平均值应该为零)，但是每个分布的方差没有改变。这显示了计算残差是如何有效地移动每个分布的平均值，使它们对齐以便直接比较的。</p><h2 id="3f9b" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">最小-最大重新缩放</h2><p id="b65c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">另一种标准化技术是重新缩放数据集。这在尝试比较不同因素或使用不同单位的数据集时非常有用，例如比较英里和米。让我们生成两个新的分布，它们的比例相差100倍:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="e16c" class="mb mc iq mz b gy nd ne l nf ng">dist3 = st.gamma.rvs(1.7, size=25)<br/>dist4 = st.gamma.rvs(120, size=25)<br/>print(dist3)<br/>print(dist4)</span></pre><p id="a787" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="7d31" class="mb mc iq mz b gy nd ne l nf ng">[   0.49529541   1.42598239   0.38621773   0.96738928   0.53575876<br/>    1.72574991   0.3431045    0.80584646   0.77543188   1.84272915<br/>    2.049985     0.76373308   3.54020309   0.36979422   4.67967817<br/>    0.6311116    2.51371776   1.12812921   0.62183125   2.03923847<br/>    1.15269735   0.72795499   1.86093872   0.52560778   0.65314453]</span><span id="3a45" class="mb mc iq mz b gy nh ne l nf ng"> [113.88768554 108.94661696 118.40872068 124.94416222 150.91953839<br/>  116.86987547 107.05486021  89.61392457 126.28254195 123.32858014<br/>  108.31036684 114.52812809 109.43092709 114.17768634 114.54545154<br/>  111.21616394 102.08437696 127.42455395 105.82224292 127.28966453<br/>  114.03632754 120.02256655 120.77792085 103.43640076 112.24143473]</span></pre><p id="74fd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从上面的输出中，您可以看到<code class="fe ni nj nk mz b">dist3</code>在0到10的范围内，而<code class="fe ni nj nk mz b">dist4</code>比<code class="fe ni nj nk mz b">dist3</code>大100倍。通过检查平均值和标准偏差，我们可以看到这些分布不能相互比较。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="d585" class="mb mc iq mz b gy nd ne l nf ng">analyze(<br/>    {"dist3": dist3, "dist4": dist4},<br/>    title="Different Scales",<br/>    nqp=False,<br/>)<br/>print(f'dist3 mean: {np.mean(dist3)} std dev: {np.std(dist3)}')<br/>print(f'dist4 mean: {np.mean(dist4)} std dev: {np.std(dist4)}')</span></pre><p id="f972" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9eae2e13307310b7dfe913ad38ec9f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*o1vwHmQdptTtJP0KWOMf4g.png"/></div></figure><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="a801" class="mb mc iq mz b gy nd ne l nf ng">dist3 mean: 1.3024508282047844 std dev: 1.0372657584518052<br/>dist4 mean: 115.42402875045401 std dev: 11.29662689178773</span></pre><p id="efdf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">幸运的是，有一种技术可以通过使用每个数据集中每个值与最小值之间的距离与每个数据集中值的范围之比来重新调整分布。该比率由以下等式表示:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="45c0" class="mb mc iq mz b gy nd ne l nf ng">(x - min) / (max - min)</span></pre><p id="c12c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过在Python中应用这个等式，我们可以得到<code class="fe ni nj nk mz b">dist3</code>和<code class="fe ni nj nk mz b">dist4</code>的重新缩放版本:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="cc6c" class="mb mc iq mz b gy nd ne l nf ng">max = np.max(dist3)<br/>min = np.min(dist3)<br/>dist3_scaled = np.array([(x - min) / (max - min) for x in dist3])<br/>max = np.max(dist4)<br/>min = np.min(dist4)<br/>dist4_scaled = np.array([(x - min) / (max - min) for x in dist4])<br/>print(dist3_scaled)<br/>print(dist4_scaled)</span></pre><p id="49cb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="c75f" class="mb mc iq mz b gy nd ne l nf ng">[0.03509474 0.24970817 0.00994177 0.14395807 0.04442546<br/> 0.3188336  0.         0.10670681 0.09969331 0.34580864<br/> 0.39360118 0.09699561 0.7372407  0.00615456 1.        <br/> 0.06641352 0.50053647 0.18102418 0.0642735  0.39112306<br/> 0.18668952 0.08874529 0.35000771 0.04208467 0.07149424] </span><span id="5046" class="mb mc iq mz b gy nh ne l nf ng">[0.39594679 0.31534946 0.46969265 0.57629694 1.        <br/> 0.44459144 0.28449166 0.         0.59812822 0.54994402<br/> 0.30497113 0.40639351 0.32324939 0.4006772  0.40667608<br/> 0.35236968 0.20341453 0.6167564  0.26438555 0.61455612<br/> 0.3983714  0.49601725 0.50833838 0.22546836 0.36909361]</span></pre><p id="932d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过重新缩放<code class="fe ni nj nk mz b">dist3</code>和<code class="fe ni nj nk mz b">dist4</code>，每个数据集的最大值现在是1，而最小值现在是0。这很方便，因为每个数据集现在都在相同的比例上，并且每个分布的形状都得以保留。实际上，每个分布都被压缩并移动到0和1之间。现在，让我们检查重新缩放的<code class="fe ni nj nk mz b">dist3</code>和<code class="fe ni nj nk mz b">dist4</code>的平均值和标准偏差:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="8647" class="mb mc iq mz b gy nd ne l nf ng">analyze(<br/>    {'dist3': dist3_scaled, 'dist4': dist4_scaled},<br/>    title='Scaled',<br/>    nqp=False,<br/>)<br/>print(f'dist3 mean: {np.mean(dist3_scaled)} std dev: {np.std(dist3_scaled)}')<br/>print(f'dist4 mean: {np.mean(dist4_scaled)} std dev:{np.std(dist4_scaled)}')</span></pre><p id="fe0f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b84564d2079e59a854810b78f036f2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*H3Xd6Qv5AZmYY0FWlWR-Vw.png"/></div></figure><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="b2aa" class="mb mc iq mz b gy nd ne l nf ng">dist3 mean: 0.2212221913870349 std dev: 0.2391901615794912<br/>dist4 mean: 0.42100718959757816 std dev: 0.18426741349056594</span></pre><p id="a49d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们现在可以看到，<code class="fe ni nj nk mz b">dist3_scaled</code>和<code class="fe ni nj nk mz b">dist4_scaled</code>的均值在相似的标准差下有显著的不同。</p><h2 id="c9bf" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">使用NumPy规范化大型数据集</h2><p id="c5c9" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">残差和重定标都是归一化数据集以进行分析的有用技术。然而，这些数据集通常不只是25个值，因此值得考虑如何有效地计算残差和执行重缩放。幸运的是，NumPy可以帮助快速有效地执行这些计算。</p><p id="025c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您不熟悉NumPy，它是一个用于高性能科学计算的Python包。与使用常规Python列表相比，NumPy有两个使计算更快、更有效的特性。首先，NumPy使用数组作为其主要数据结构，与Python列表相比，它使用的内存更少，并且要求数组中的每个值都是相同的类型。标量也可以对数组进行操作——对数组的每个值应用标量操作。事实上，当我们通过从分布(一个数组)中减去分布(一个标量)的平均值来计算残差时，我们已经看到了这一点。</p><p id="1e76" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们比较一下使用Python列表理解和数组操作计算残差的速度差异。我们将首先创建一个包含100，000个值的随机正态分布变量数组:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="953e" class="mb mc iq mz b gy nd ne l nf ng">dist5 = st.norm.rvs(82, 5, size=100000)</span></pre><p id="9ba1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们看看使用列表理解计算<code class="fe ni nj nk mz b">dist5</code>的残差需要多长时间:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="6552" class="mb mc iq mz b gy nd ne l nf ng">avg = np.mean(dist5)<br/>%timeit [val - avg for val in dist5]</span></pre><p id="8d0a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="7ee8" class="mb mc iq mz b gy nd ne l nf ng">10 loops, best of 3: 24.9 ms per loop</span></pre><p id="b934" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">列表理解需要大约25毫秒来遍历<code class="fe ni nj nk mz b">dist5</code>中的每个值，这还不算太糟糕。然而，让我们再次计算<code class="fe ni nj nk mz b">dist5</code>的残差，但是使用NumPy标量运算:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="1186" class="mb mc iq mz b gy nd ne l nf ng">avg = np.mean(dist5)<br/>%timeit dist5 - avg</span></pre><p id="12a6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="22ea" class="mb mc iq mz b gy nd ne l nf ng">10000 loops, best of 3: 144 µs per loop</span></pre><p id="4ae4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">仅仅从<code class="fe ni nj nk mz b">dist5</code>(这是一个NumPy数组)中减去平均值就需要144微秒！这得益于NumPy阵列的高效设计。</p><p id="ec54" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，如果我们想用一个函数而不仅仅是一个简单的标量来操作一个数组呢？这是NumPy以通用函数的形式对Python的第二次性能提升。通用函数是“矢量化”操作，在迭代数组中的每个值时，利用CPU优化来实现计算加速。NumPy内置了无数的通用函数，但是我们也可以使用NumPy的<code class="fe ni nj nk mz b">frompyfunc()</code>函数编写自己的函数。</p><p id="9501" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们来看看使用列表理解和自定义通用函数来重新调整数组值在速度上的差异:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="3c3c" class="mb mc iq mz b gy nd ne l nf ng">min = np.min(dist5)<br/>max = np.max(dist5)<br/>%timeit [(val - min) / (max - min) for val in dist5]</span></pre><p id="ac7d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="b34e" class="mb mc iq mz b gy nd ne l nf ng">10 loops, best of 3: 47.2 ms per loop</span></pre><p id="49cf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过在47毫秒内重新缩放<code class="fe ni nj nk mz b">dist5</code>,列表理解的表现令人钦佩。让我们把这比作创建一个名为<code class="fe ni nj nk mz b">scale</code>的定制通用函数。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="367e" class="mb mc iq mz b gy nd ne l nf ng">scale = np.frompyfunc(lambda x, min, max: (x - min) / (max - min), 3, 1)</span></pre><p id="61b2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们使用<code class="fe ni nj nk mz b">np.frompyfunc()</code>函数，它接受一个可调用函数、输入数和输出数作为它的参数。在这种情况下，可调用的是lambda函数形式的重定标方程。如果你不熟悉lambda函数，你可以把它们想象成一行未命名的函数。我们的lambda函数有三个参数，<code class="fe ni nj nk mz b">x</code>、<code class="fe ni nj nk mz b">min</code>和<code class="fe ni nj nk mz b">max</code>。这三个参数是调用<code class="fe ni nj nk mz b">np.frompyfunc()</code>时指定的三个输入。同样值得注意的是，<code class="fe ni nj nk mz b">min</code>和<code class="fe ni nj nk mz b">max</code>是从<code class="fe ni nj nk mz b">dist5</code>计算的标量，而<code class="fe ni nj nk mz b">x</code>代表<code class="fe ni nj nk mz b">dist5</code>中的每个值。现在，让我们计算<code class="fe ni nj nk mz b">min</code>和<code class="fe ni nj nk mz b">max</code>并调用<code class="fe ni nj nk mz b">scale</code>函数:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="b5ec" class="mb mc iq mz b gy nd ne l nf ng">min = np.min(dist5)<br/>max = np.max(dist5)<br/>%timeit scale(dist5, min, max).astype(float)</span></pre><p id="f84d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">输出:</strong></p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="5eb5" class="mb mc iq mz b gy nd ne l nf ng">10 loops, best of 3: 20.4 ms per loop</span></pre><p id="d49f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如你所见，与列表理解相比，自定义通用函数需要一半的时间来完成。</p><h2 id="cf74" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">结论</h2><p id="131e" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们研究了两种归一化技术——残差提取和最小-最大重新缩放。残差提取可以被认为是移动一个分布，使其平均值为0。最小-最大重新缩放可以被认为是移动和压缩分布以适应0和1之间的范围。残差提取对于比较均值不同但形状相似的分布很有用。最小-最大重新缩放对于比较不同比例或不同形状的分布很有用。</p><p id="f82d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当分布用NumPy数组表示时，这两种规范化技术都可以用NumPy有效地执行。NumPy数组上的标量操作既快又易读。当需要对数组进行更复杂的操作时，可以使用通用函数来高效地执行操作。</p></div></div>    
</body>
</html>