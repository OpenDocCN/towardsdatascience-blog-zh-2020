<html>
<head>
<title>How to evaluate Vespa ranking functions from python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何评价来自python的Vespa排名函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-evaluate-vespa-ranking-functions-from-python-7749650f6e1a?source=collection_archive---------37-----------------------#2020-11-05">https://towardsdatascience.com/how-to-evaluate-vespa-ranking-functions-from-python-7749650f6e1a?source=collection_archive---------37-----------------------#2020-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b509" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用<a class="ae kf" href="https://pyvespa.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> pyvespa </a>评估<a class="ae kf" href="https://cord19.vespa.ai/" rel="noopener ugc nofollow" target="_blank"> cord19搜索应用</a>当前生产中的排名功能。</h2></div><p id="e2c8" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><em class="lc">这是一系列博客文章中的第二篇，将向您展示如何改进文本搜索应用程序，从下载数据到微调BERT模型。</em></p><p id="7a81" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">前一篇文章展示了如何下载和解析TREC-科维德数据。这一次将重点评估在<a class="ae kf" href="https://cord19.vespa.ai/" rel="noopener ugc nofollow" target="_blank"> cord19搜索应用</a>中可用的两个查询模型。这些模型将作为未来改进的基准。</p><p id="9a3d" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">您也可以从<a class="ae kf" href="https://colab.research.google.com/github/vespa-engine/pyvespa/blob/master/docs/sphinx/source/use_cases/cord19/cord19_connect_evaluate.ipynb" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>运行这里包含的步骤。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/38ceb38c5357f6acd3248bd895074755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1N2ihMRmi_XX4st_Mz2xw.jpeg"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@olloweb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">新闻社跟随</a>在<a class="ae kf" href="https://unsplash.com/s/photos/magnifying-glass?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h2 id="42a7" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kp mc md me kt mf mg mh kx mi mj mk ml bi translated">下载处理过的数据</h2><p id="9e61" class="pw-post-body-paragraph kg kh iq ki b kj mm jr kl km mn ju ko kp mo kr ks kt mp kv kw kx mq kz la lb ij bi translated">我们可以从下载我们在之前<a class="ae kf" href="https://pyvespa.readthedocs.io/en/latest/use_cases/cord19/cord19_download_parse_trec_covid.html" rel="noopener ugc nofollow" target="_blank">已经处理过的数据开始。</a></p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="7749" class="lt lu iq ms b gy mw mx l my mz">import requests, json<br/>from pandas import read_csv<br/><br/>topics = json.loads(requests.get(<br/>  "https://thigm85.github.io/data/cord19/topics.json").text<br/>)<br/>relevance_data = read_csv(<br/>  "https://thigm85.github.io/data/cord19/relevance_data.csv"<br/>)</span></pre><p id="d6e7" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe na nb nc ms b">topics</code>包含50个可用主题的数据，包括<code class="fe na nb nc ms b">query</code>、<code class="fe na nb nc ms b">question</code>和<code class="fe na nb nc ms b">narrative</code>。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="9c2d" class="lt lu iq ms b gy mw mx l my mz">topics["1"]</span><span id="7a79" class="lt lu iq ms b gy nd mx l my mz">{'query': 'coronavirus origin',<br/> 'question': 'what is the origin of COVID-19',<br/> 'narrative': "seeking range of information about the SARS-CoV-2 virus's origin, including its evolution, animal source, and first transmission into humans"}</span></pre><p id="4f3d" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe na nb nc ms b">relevance_data</code>包含50个主题中每个主题的相关性判断。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="ab68" class="lt lu iq ms b gy mw mx l my mz">relevance_data.head(5)</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="ab gu cl ne"><img src="../Images/ab9b87113db67b3833b0c2e09040c3eb.png" data-original-src="https://miro.medium.com/v2/format:webp/1*yXIBPqsEnd3PECyrTTDkhQ.png"/></div></figure><h2 id="83ea" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kp mc md me kt mf mg mh kx mi mj mk ml bi translated">安装pyvespa</h2><p id="5c8d" class="pw-post-body-paragraph kg kh iq ki b kj mm jr kl km mn ju ko kp mo kr ks kt mp kv kw kx mq kz la lb ij bi translated">我们将使用<a class="ae kf" href="https://pyvespa.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> pyvespa </a>来评估python中的排名函数。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="e17e" class="lt lu iq ms b gy mw mx l my mz">!pip install pyvespa</span></pre><p id="0e5b" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe na nb nc ms b">pyvespa</code>给Vespa提供一个python API。它允许我们创建、修改、部署正在运行的Vespa实例，并与之进行交互。该库的主要目标是允许更快的原型开发，并促进Vespa应用程序的机器学习实验。</p><h2 id="afdc" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kp mc md me kt mf mg mh kx mi mj mk ml bi translated">将带标签的数据格式化为预期的pyvespa格式</h2><p id="ad8b" class="pw-post-body-paragraph kg kh iq ki b kj mm jr kl km mn ju ko kp mo kr ks kt mp kv kw kx mq kz la lb ij bi translated"><code class="fe na nb nc ms b">pyvespa</code>期望带标签的数据遵循如下所示的格式。这是一个字典列表，其中每个字典代表一个包含<code class="fe na nb nc ms b">query_id</code>、<code class="fe na nb nc ms b">query</code>和一个<code class="fe na nb nc ms b">relevant_docs</code>列表的查询。每个相关文件包含一个必需的<code class="fe na nb nc ms b">id</code>键和一个可选的<code class="fe na nb nc ms b">score</code>键。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="24f4" class="lt lu iq ms b gy mw mx l my mz">labeled_data = [<br/>    {<br/>        'query_id': 1,<br/>        'query': 'coronavirus origin',<br/>        'relevant_docs': [{'id': '005b2j4b', 'score': 2}, {'id': '00fmeepz', 'score': 1}]<br/>    },<br/>    {<br/>        'query_id': 2,<br/>        'query': 'coronavirus response to weather changes',<br/>        'relevant_docs': [{'id': '01goni72', 'score': 2}, {'id': '03h85lvy', 'score': 2}]<br/>    }<br/>]</span></pre><p id="76bf" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们可以从之前下载的<code class="fe na nb nc ms b">topics</code>和<code class="fe na nb nc ms b">relevance_data</code>中创建<code class="fe na nb nc ms b">labeled_data</code>。我们将只在最终列表中包含相关性分数为&gt; 0的文档。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="e12f" class="lt lu iq ms b gy mw mx l my mz">labeled_data = [<br/>    {<br/>        "query_id": int(topic_id), <br/>        "query": topics[topic_id]["query"], <br/>        "relevant_docs": [<br/>            {<br/>                "id": row["cord_uid"], <br/>                "score": row["relevancy"]<br/>            } for idx, row in relevance_data[relevance_data.topic_id == int(topic_id)].iterrows() if row["relevancy"] &gt; 0<br/>        ]<br/>    } for topic_id in topics.keys()]</span></pre><h2 id="0c40" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kp mc md me kt mf mg mh kx mi mj mk ml bi translated">定义要评估的查询模型</h2><p id="441a" class="pw-post-body-paragraph kg kh iq ki b kj mm jr kl km mn ju ko kp mo kr ks kt mp kv kw kx mq kz la lb ij bi translated">我们将在这里定义两个要评估的查询模型。两者都将匹配与查询至少共享一个术语的所有文档。这通过设置<code class="fe na nb nc ms b">match_phase = OR()</code>来定义。</p><p id="768c" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">查询模型之间的差异发生在排序阶段。<code class="fe na nb nc ms b">or_default</code>模型将根据<a class="ae kf" href="https://docs.vespa.ai/documentation/nativerank.html" rel="noopener ugc nofollow" target="_blank">native ank</a>对文档进行排序，而<code class="fe na nb nc ms b">or_bm25</code>模型将根据<a class="ae kf" href="https://docs.vespa.ai/documentation/reference/bm25.html" rel="noopener ugc nofollow" target="_blank"> BM25 </a>对文档进行排序。关于这两种排名的讨论超出了本教程的范围。知道他们按照两种不同的公式对文档进行排序就够了。</p><p id="87c1" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这些排名资料是由cord19应用程序背后的团队定义的，可以在这里找到<a class="ae kf" href="https://github.com/vespa-engine/sample-apps/blob/master/vespa-cloud/cord-19-search/src/main/application/schemas/doc.sd" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="aabc" class="lt lu iq ms b gy mw mx l my mz">from vespa.query import Query, RankProfile, OR<br/><br/>query_models = {<br/>    "or_default": Query(<br/>        match_phase = OR(),<br/>        rank_profile = RankProfile(name="default")<br/>    ),<br/>    "or_bm25": Query(<br/>        match_phase = OR(),<br/>        rank_profile = RankProfile(name="bm25t5")<br/>    )<br/>}</span></pre><h2 id="6d0a" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kp mc md me kt mf mg mh kx mi mj mk ml bi translated">定义评估中使用的指标</h2><p id="2285" class="pw-post-body-paragraph kg kh iq ki b kj mm jr kl km mn ju ko kp mo kr ks kt mp kv kw kx mq kz la lb ij bi translated">我们希望计算以下指标:</p><ul class=""><li id="3a05" class="nf ng iq ki b kj kk km kn kp nh kt ni kx nj lb nk nl nm nn bi translated">查询匹配的文档的百分比</li><li id="fd59" class="nf ng iq ki b kj no km np kp nq kt nr kx ns lb nk nl nm nn bi translated">回忆@ 10</li><li id="1f1d" class="nf ng iq ki b kj no km np kp nq kt nr kx ns lb nk nl nm nn bi translated">倒数排名@ 10</li><li id="4b80" class="nf ng iq ki b kj no km np kp nq kt nr kx ns lb nk nl nm nn bi translated">NDCG @ 10</li></ul><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="c855" class="lt lu iq ms b gy mw mx l my mz">from vespa.evaluation import MatchRatio, Recall, ReciprocalRank, NormalizedDiscountedCumulativeGain<br/><br/>eval_metrics = [<br/>    MatchRatio(), <br/>    Recall(at=10), <br/>    ReciprocalRank(at=10), <br/>    NormalizedDiscountedCumulativeGain(at=10)<br/>]</span></pre><h2 id="6850" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kp mc md me kt mf mg mh kx mi mj mk ml bi translated">评价</h2><p id="87d4" class="pw-post-body-paragraph kg kh iq ki b kj mm jr kl km mn ju ko kp mo kr ks kt mp kv kw kx mq kz la lb ij bi translated">连接到正在运行的Vespa实例:</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="f07b" class="lt lu iq ms b gy mw mx l my mz">from vespa.application import Vespa<br/><br/>app = Vespa(url = "https://api.cord19.vespa.ai")</span></pre><p id="e8e4" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为每个查询模型计算上面定义的指标，并将结果存储在一个字典中。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="e2f4" class="lt lu iq ms b gy mw mx l my mz">evaluations = {}<br/>for query_model in query_models:<br/>    evaluations[query_model] = app.evaluate(<br/>        labeled_data = labeled_data,<br/>        eval_metrics = eval_metrics,<br/>        query_model = query_models[query_model],<br/>        id_field = "cord_uid",<br/>        hits = 10<br/>    )</span></pre><h2 id="fefb" class="lt lu iq bd lv lw lx dn ly lz ma dp mb kp mc md me kt mf mg mh kx mi mj mk ml bi translated">分析结果</h2><p id="4545" class="pw-post-body-paragraph kg kh iq ki b kj mm jr kl km mn ju ko kp mo kr ks kt mp kv kw kx mq kz la lb ij bi translated">让我们首先将数据组合成一个DataFrame，其格式便于在查询模型之间进行比较。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="712e" class="lt lu iq ms b gy mw mx l my mz">import pandas as pd<br/><br/>metric_values = []<br/>for query_model in query_models:<br/>    for metric in eval_metrics:<br/>        metric_values.append(<br/>            pd.DataFrame(<br/>                data={<br/>                    "query_model": query_model, <br/>                    "metric": metric.name, <br/>                    "value": evaluations[query_model][metric.name + "_value"].to_list()<br/>                }<br/>            )<br/>        )<br/>metric_values = pd.concat(metric_values, ignore_index=True)<br/>metric_values.head()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="ab gu cl ne"><img src="../Images/29c76d991ae4c64573f5f277999a98b5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*DY9WAhhgAzrrNDU1AmjsEg.png"/></div></figure><p id="8c74" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们可以在下面看到，基于BM25的查询模型在这里考虑的所有指标中都是优越的。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="d579" class="lt lu iq ms b gy mw mx l my mz">metric_values.groupby(['query_model', 'metric']).mean()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="ab gu cl ne"><img src="../Images/7a3d208d1e42ec60162652ac2c941364.png" data-original-src="https://miro.medium.com/v2/format:webp/1*F630ZvdLOTsfVXehyHQ2_w.png"/></div></figure><p id="b213" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们还可以可视化指标在查询中的分布，以便更好地了解结果。</p><pre class="le lf lg lh gt mr ms mt mu aw mv bi"><span id="f091" class="lt lu iq ms b gy mw mx l my mz">import plotly.express as px<br/><br/>fig = px.box(<br/>    metric_values[metric_values.metric == "ndcg_10"], <br/>    x="query_model", <br/>    y="value", <br/>    title="Ndgc @ 10",<br/>    points="all"<br/>)<br/>fig.show()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/2db6ec5ffc860699e40d0dee08d97813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZhHkwAu7kq5cebT4FU23Bg.png"/></div></figure></div></div>    
</body>
</html>