<html>
<head>
<title>Efficient Root Searching Algorithms in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中高效的根搜索算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mastering-root-searching-algorithms-in-python-7120c335a2a8?source=collection_archive---------25-----------------------#2020-11-10">https://towardsdatascience.com/mastering-root-searching-algorithms-in-python-7120c335a2a8?source=collection_archive---------25-----------------------#2020-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e477" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python中实现高效的寻根和优化搜索算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d37c73455d95c561e525f191ee5980a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HMgA8rFCUIxc6JPe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mang5ta?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Matteo Grando </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为数据科学家/计算机科学家，我们经常在日常生活中处理求根算法，不管我们是否意识到这一点。这些算法设计用于有效地<strong class="lb iu">定位特定值、局部/全局最大值或最小值</strong>的附近。</p><blockquote class="lv"><p id="16a6" class="lw lx it bd ly lz ma mb mc md me lu dk translated">我们使用求根算法来搜索特定值、局部/全局最大值或最小值的近似值。</p></blockquote><p id="65c8" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">在数学中，当我们说求根时，通常意味着我们试图解一个方程组，使得<code class="fe mk ml mm mn b">f(X) = 0</code>。这也使得求根算法成为非常有效的搜索算法。我们所要做的就是定义<code class="fe mk ml mm mn b">g(X) = f(X) — Y</code>，其中<code class="fe mk ml mm mn b">Y</code>是我们的搜索目标，然后求解<code class="fe mk ml mm mn b">X</code>，使得<code class="fe mk ml mm mn b">g(X) = f(X) — Y = 0</code>。</p><p id="a7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要有两类不同的方法:<strong class="lb iu">包围法</strong>(如二分法)和<strong class="lb iu">迭代法</strong>(如牛顿法、割线法、Steffensen法等。).在这篇博客中，我们将探讨如何用python实现这些算法，并对它们进行相互比较(随意点击算法名称跳转到不同的部分):</p><ol class=""><li id="87ea" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated"><a class="ae ky" href="#7baa" rel="noopener ugc nofollow">二分法算法</a></li><li id="2eb3" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><a class="ae ky" href="#98f0" rel="noopener ugc nofollow">雷古拉-法尔西算法</a></li><li id="58a6" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><a class="ae ky" href="#fcc0" rel="noopener ugc nofollow">伊利诺伊算法</a></li><li id="3738" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><a class="ae ky" href="#5f39" rel="noopener ugc nofollow">割线算法</a></li><li id="9c3d" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated"><a class="ae ky" href="#6c81" rel="noopener ugc nofollow">斯蒂芬森算法</a></li></ol><p id="4757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，让我们假设我们有一个<strong class="lb iu">连续函数</strong> <code class="fe mk ml mm mn b">f</code>，并且我们想要搜索一个值<code class="fe mk ml mm mn b">y</code>。也就是说，我们正在求解<code class="fe mk ml mm mn b">f(x) — y = 0</code>。</p><h1 id="7baa" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">1.二分法</h1><p id="fc5a" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">对分算法，或者更著名的是它的离散版本(二分搜索法)或树变体(二叉查找树)，是一种在界限内搜索目标值的有效算法。正因为如此，这个算法也被称为寻找算法的根的<strong class="lb iu">包围法。</strong></p><p id="c44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键强度:</strong></p><ul class=""><li id="7438" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">保证以合理的速度收敛到目标值的鲁棒算法</li></ul><p id="43dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键弱点:</strong></p><ul class=""><li id="eb5e" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">需要了解根的近似面积，例如3 ≤ π ≤ 4</li><li id="2431" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nz mu mv mw bi translated">工作良好在近似区域中只有一个根</li></ul><p id="cc68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们知道<code class="fe mk ml mm mn b">x</code>在<code class="fe mk ml mm mn b">f(a)</code>和<code class="fe mk ml mm mn b">f(b)</code>之间，这就形成了搜索的括号。该算法将检查<code class="fe mk ml mm mn b">x</code>是大于还是小于<code class="fe mk ml mm mn b">f((a + b) / 2)</code>，后者是支架的中点。</p><p id="d013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要一个<strong class="lb iu">误差范围</strong>来检查支架的中点。当搜索一个连续函数时，我们可能永远无法定位精确的值(例如定位π的末端)。当计算值足够接近目标值时，可以将误差幅度视为提前停止。例如，如果误差幅度为0.001%，则3.141624非常接近π，大约为3.1415926…</p><p id="11f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果计算值足够接近目标值，则搜索完成，否则，如果<code class="fe mk ml mm mn b">x &lt; f((a + b) / 2)</code>，则搜索下半部分的值，反之亦然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="98f0" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">2.错误位置算法</h1><p id="eb7c" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">就像二分法一样，Regula Falsi也使用一种包围式方法。然而，与二分法不同，它不使用每次迭代将问题空间一分为二的强力方法。相反，Regula Falsi迭代地绘制从<code class="fe mk ml mm mn b">f(a)</code>到<code class="fe mk ml mm mn b">f(b)</code>的直线，并且<strong class="lb iu">将截距与目标值</strong>进行比较。然而，不能保证搜索效率总是得到提高。例如，下图显示了只有下限以减少的速率增加，而上限仍然是一个<strong class="lb iu">停滞的界限</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1dd8262d31d61098a56fca0bbf7ccb11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*al8DXTvD5_LYiHMqOrye1w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">停滞的界限减缓了收敛。图片作者。</p></figure><p id="90d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键强项:</strong></p><ul class=""><li id="b7d0" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">通常比二分法收敛更快</li></ul><blockquote class="lv"><p id="cda0" class="lw lx it bd ly lz od oe of og oh lu dk translated">Regula Falsi利用了随着括号变小，连续函数将收敛到一条直线。</p></blockquote><p id="3e77" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated"><strong class="lb iu">关键弱点:</strong></p><ul class=""><li id="bc97" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">当算法遇到停滞边界时，收敛变慢</li><li id="0172" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nz mu mv mw bi translated">需要了解根的近似面积，例如3 ≤ π ≤ 4</li></ul><p id="eca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Regula Falsi和等分之间的关键区别在于<code class="fe mk ml mm mn b">c</code>不再是<code class="fe mk ml mm mn b">a</code>和<code class="fe mk ml mm mn b">b</code>之间的中点，而是被计算为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c527617107e4ca19b8bb30860326f680.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*qW1C4itMmrvgLZ_AdOmLRQ.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="fcc0" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">3.伊利诺伊算法(修正的雷古拉-法尔西)</h1><p id="607f" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">为了通过停滞边界，我们可以添加一个条件规则，当一个边界在两轮中保持停滞时。就拿前面的例子来说，由于<code class="fe mk ml mm mn b">b</code>已经两轮没有移动，而且<code class="fe mk ml mm mn b">c</code>还没有靠近根<code class="fe mk ml mm mn b">x</code>，所以在下一轮，线将被划到<code class="fe mk ml mm mn b">f(b) / 2</code>而不是<code class="fe mk ml mm mn b">f(b)</code>。如果下界是停滞的，这同样适用于下界。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5ffb1ac936790310b76f6a53a9467499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*1iKerip4EXANYsEtpPU-4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Illinois算法避免了长时间停滞边界，加快了收敛速度。图片作者。</p></figure><p id="9e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键强度:</strong></p><ul class=""><li id="d9cd" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">通常比二分法和正则法收敛得更快</li><li id="b7ed" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nz mu mv mw bi translated">通过将停滞边界到目标值的距离减半来避免停滞边界</li></ul><p id="6981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键弱点:</strong></p><ul class=""><li id="2b1d" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">当算法遇到停滞边界时，收敛变慢</li><li id="2af1" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nz mu mv mw bi translated">需要了解根的近似面积，例如3 ≤ π ≤ 4</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="5f39" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">4.割线法(拟牛顿法)</h1><p id="274e" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">到目前为止，我们一直在实施支架方法。如果我们不知道括号在哪里，怎么办？那么割线法会非常有用。割线法是一种迭代算法，从两个估计值开始，并试图向目标值收敛。虽然我们可以在算法收敛时获得更好的性能，并且我们也不需要知道根的粗略位置，但是如果两个初始估计值离实际根太远，我们可能会遇到<strong class="lb iu">发散的风险。</strong></p><p id="17dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键强度:</strong></p><ul class=""><li id="305a" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">不需要包含根的括号</li><li id="2fc7" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nz mu mv mw bi translated">不需要知道根的大致面积</li></ul><p id="edc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键弱点:</strong></p><ul class=""><li id="1a75" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">与所有以前的方法不同，割线不能保证收敛</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/7d7f4f75cff094308242adb333fe8202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PTvDSGXWNvM-Ycft.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于x1和x2定位x3的割线法。鸣谢:维基百科</p></figure><p id="fcdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法从检查两个用户定义的种子开始，假设我们想从<code class="fe mk ml mm mn b">x_0=4</code>和<code class="fe mk ml mm mn b">x_1=5</code>开始搜索<code class="fe mk ml mm mn b">x² — math.pi=0</code>的根，那么我们的种子是4和5。(注意，这与搜索<code class="fe mk ml mm mn b">x</code>相同，因此<code class="fe mk ml mm mn b">x²=math.pi</code>)</p><p id="6daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们像在Regula-Falsi中所做的那样，通过画一条穿过<code class="fe mk ml mm mn b">f(x_0)</code>和<code class="fe mk ml mm mn b">f(x_1)</code>的直线来定位目标值为<code class="fe mk ml mm mn b">x_2</code>的截距。如果<code class="fe mk ml mm mn b">f(x_2)</code>没有足够接近目标值，我们重复该步骤并定位<code class="fe mk ml mm mn b">x_3</code>。一般来说，下一个<code class="fe mk ml mm mn b">x</code>可以计算为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c6ed3d4d135d15f46dbef904a62102d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*tm73QRA97Z71n8Sgdq6XPQ.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="6c81" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">5.斯特芬森方法</h1><p id="d60d" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">割线的方法进一步改进了Regula-Falsi算法，去掉了对包含根的括号的要求。回想一下，直线实际上只是两个<code class="fe mk ml mm mn b">x</code>值(或Regula-Falsi和Illinois算法中的上下限)的切线(即导数)的简单估计。随着搜索的收敛，这种估计将更加准确。在Steffensen的算法中，我们将尝试用对导数的<strong class="lb iu">更好的估计来代替直线，以进一步改进割线法。</strong></p><p id="cc19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键强项:</strong></p><ul class=""><li id="64ae" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">不需要包含根的括号</li><li id="3941" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nz mu mv mw bi translated">不需要知道根的大致面积</li><li id="fa79" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nz mu mv mw bi translated">如果可能的话，比正割法收敛得更快</li></ul><p id="5cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关键弱点:</strong></p><ul class=""><li id="0d00" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu nz mu mv mw bi translated">如果初始种子离实际根太远，则不能保证收敛</li><li id="431c" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu nz mu mv mw bi translated">为了更好地估计导数，连续函数的计算将是正割方法的两倍</li></ul><p id="b6f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地估计导数，Steffenson的算法将根据用户定义的初始种子<code class="fe mk ml mm mn b">x_0</code>计算如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/8c4753f0a06533f694008d5ee3957c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*B9FysWB9NWCPtNetsaI_3g.png"/></div></figure><p id="db4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当于下面的公式，其中<em class="on"> h = f(x) </em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/70deb03ce64d11a7afba5d5493ea2cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*HlxpvTZ6RtWRiIuvdJkNJg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">取h的极限为0，你将得到f(x)的导数</p></figure><p id="565a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，广义估计斜率函数将用于定位与割线法相似的下一步:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/c102038585b9bdc4b94f18fda92a7ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*loJPjVYvTqQD2nEdVFOm4A.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="bb16" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">结论</h1><p id="54c2" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在博客中，我们讨论了以下5种求根算法的优点、缺点和实现:</p><ol class=""><li id="1dc7" class="mo mp it lb b lc ld lf lg li mq lm mr lq ms lu mt mu mv mw bi translated">二分法</li><li id="1f44" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">Regula-Falsi算法</li><li id="01a7" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">伊利诺伊算法</li><li id="39d1" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">割线算法</li><li id="21de" class="mo mp it lb b lc mx lf my li mz lm na lq nb lu mt mu mv mw bi translated">斯特芬森算法</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/347230289c7f44dd9811186be9885bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPZAlpvpTSVoURTKpgUE0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们已经实现的算法的比较</p></figure><p id="65e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你熟悉了这些算法，不要止步于此。实际上有更多的求根算法我们没有在这个博客中介绍，例如，牛顿-拉夫森法，逆二次插值法，布伦特法等。继续探索并将这些算法添加到您的工具库中。</p><p id="0c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意上面的片段都是我自己写的，没有经过彻底的测试。我强烈建议您尝试一下，并以此为起点来修改您自己的用例。记住！在部署之前进行测试！它能在我的环境中工作并不意味着它能在所有的设置中工作！</p><p id="7959" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再见！</p><h1 id="1e9f" class="nc nd it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">在你走之前</h1><p id="31b1" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">您可能还想查看这些中型博客，了解如何改进您的数据科学游戏:</p><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/efficient-implementation-of-conditional-logic-on-pandas-dataframes-4afa61eb7fce"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">熊猫数据帧上的高效条件逻辑</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">是时候停止过于依赖。iterrows()和。应用()</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/cookiecutter-plugin-for-jupyter-easily-organise-your-data-science-environment-a56f83140f72"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">Jupyter的Cookiecutter插件:轻松组织你的数据科学环境</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">一个Jupyter扩展，帮助一键组织项目文件夹</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ks ou"/></div></div></a></div><p id="8675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从这里学到了新的东西，请告诉我！也请让我知道我是否还遗漏了其他一些巧妙的技巧！</p><div class="or os gp gr ot ou"><a href="https://www.linkedin.com/in/louis-chan-b55b9287" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">Louis Chan-FTI Consulting | LinkedIn数据科学总监</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">雄心勃勃的，好奇的和有创造力的个人，对分支知识和知识之间的相互联系有强烈的信念</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">www.linkedin.com</p></div></div></div></a></div></div></div>    
</body>
</html>