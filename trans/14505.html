<html>
<head>
<title>Using in-memory access in Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在数据科学中使用内存访问</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-in-memory-access-in-data-science-96130a5bcc33?source=collection_archive---------38-----------------------#2020-10-06">https://towardsdatascience.com/using-in-memory-access-in-data-science-96130a5bcc33?source=collection_archive---------38-----------------------#2020-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e986" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于磁盘的数据库和内存访问之间的简单性能比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88f603946ce1002f7efdf0ae73ceac60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4O7vXueLrsSfR1NETEY1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:vectorgraphit.com。知识共享署名许可证。</p></figure><p id="9f03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在金融市场数据分析中，要分析的数据量和吞吐量可能令人望而生畏。这绝不是金融界特有的，因为它也发生在许多其他数据分析领域。这个特定行业的独特之处在于数据是高度结构化的(这在其他领域并不常见)。构成金融市场数据的是大量大小不一且大多互不相关的数据消息:最终很容易收到、存储、解码、解析和关联数亿条小消息。</p><p id="03aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分析如此大量的数据需要许多次迭代，并且在随机数据访问中节省时间的需要变得相关。</p><h1 id="cef9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">数据库与内存</h1><p id="84aa" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在数据科学和数据工程中，我们面临许多次如前所述的处理数据集的需要。这可能是因为我们想要以大吞吐量注入数据——模拟环境——或者因为我们只是需要迭代大型数据集以进行统计分析或蒙特卡罗模拟——并非数据科学中的一切都可以简化为ML模型。</p><p id="e037" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当存在这样的需求时，第一反应是使用数据库(可以是任何数据库)中的数据，并使用查询/访问策略来提取和使用数据。有时，这种方法根本无法避免，因为数据集太大，即使拆分也无法放入内存，或者因为使用数据的预期方式复杂多样。</p><p id="6547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在许多其他情况下，数据可以成功地简单地存储在RAM中，以便以后立即分配，或者在大块数据中，使用原始I/O直接从磁盘传输到内存。</p><p id="815f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">后一种方法尽管简单，但通常不被采用(通过将数据访问减少到仅仅从磁盘进行内存复制，然后通过数组进行内存请求，从而减少了一层复杂性)。它肯定不适合所有的场景，但是它非常适合模拟、分析和回溯测试，正如在定量研究和分析中发现的那样。数据通常可以按年份或任何其他标准进行划分。</p><p id="496b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">拆分可能被视为一个问题，但根据我的经验，它实际上简化了数据处理管道的后续阶段，即使使用数据库，也经常需要拆分。</p><p id="bd19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在内存中存储要分配的数据的方式和将数据存储为可以查询的存储库的方式存在差异。如果您计划将所有内容都移入RAM，那么理想情况下，您会希望存储一个将在编程语言中使用的结构的<em class="mr">字节内存</em>副本，而如果您计划使用数据库或存储库，那么它将是底层解决方案，即规定如何准备和存储数据的解决方案。</p><p id="67e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然您会发现许多人认为第一种方法违反了一些最佳实践(数据的字节顺序会引起可移植性问题，编译器不保证语言结构的一致性，等等)，但事实是它在受控环境中工作得非常好，在受控环境中，您可以定义平台、操作系统、编译器和分析的源代码。</p><p id="fc7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些反对意见/建议可能对打算发布的商业软件有效，或者可能是从理论角度进行讨论的基础，但是在现实生活的研究和分析任务中，它们的有效性可能会受到质疑，在这种情况下，平台和环境都是及时受控和稳定的。</p><p id="b003" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们已经到达了一个点，在平台和编译器架构方面没有太多的选择，所以关于字节序和编译器差异的讨论更多的是学术而不是实践。对我来说，这些是80年代和90年代的回忆，那时我们在平台方面更加多样化(SPARC、PowerPC、英特尔、Alpha)。这同样适用于许多不同UNIX供应商的操作系统。这种多样性很久以前就消失了。</p><h1 id="17a0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">RAM比基于磁盘的数据库快多少？</h1><p id="7d46" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了回答这个问题，我们将测试两个场景。一个将模拟使用内存映射文件访问基于磁盘的存储系统(这被认为是大文件的快速访问方法)，另一个将模拟针对内存阵列的直接内存访问。</p><p id="ee93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这两种情况下，文件和内存数组都填充了随机数据，我们在整个数据集(512Mb)上迭代10次，进行简单的计算(以避免编译器在其优化功能中跳过指令)，我们将测量每种方法花费的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于测试基于磁盘的存储访问与内存访问的源代码</p></figure><h1 id="7c8c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结果</h1><p id="80be" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在低端FreeBSD机器上运行的模拟结果清楚地显示了RAM如何显著提高访问性能:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c555" class="mz lv it mv b gy na nb l nc nd">durationTestFile<br/>20318<br/>durationTestArray<br/>7312</span></pre><p id="52e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使我们用操作(每个检索字节的累积和与位屏蔽操作)来偏置测试，当比较内存和磁盘时，我们仍然得到3:1的速度性能比。可能内存与磁盘的隔离效应比这个比率还要高得多。</p><p id="7382" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任何数据库或存储解决方案的性能都不可能超过内存映射文件的性能，因此我们可以得出结论，在内存上迭代可以大大减少计算时间。这不会让任何人感到惊讶，但是你仍然会发现有人声称两者是平等的，或者干脆否认直接内存访问方法是可行的，这是一个错误的假设。</p><p id="d6f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为对这个非正式基准的合理反对，有人可能会说我们没有考虑初始化数组的时间和将数据放入数组的时间。这些都是合理的反对意见，但是在对数据进行大量后续迭代(可能会持续几十分钟、几小时甚至几天)的情况下，使用内存而不是磁盘仍然有很大的好处，因为<em class="mr">它将大大减少运行分析的时间</em>。</p><blockquote class="ne nf ng"><p id="faa9" class="ky kz mr la b lb lc ju ld le lf jx lg nh li lj lk ni lm ln lo nj lq lr ls lt im bi translated">处理时间越长，使用的内存就越多。</p></blockquote><p id="53c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法没有被广泛使用，因为它通常意味着能够压缩数据并处理底层语言的实际内存表示，而且它远远超出了在<em class="mr"> JSON </em>和<em class="mr"> Jupyter笔记本中处理数据的舒适区。</em>它可能更适合使用C/C++ Java或Go的低延迟开发环境。</p><p id="5405" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还值得一提的是，整个方法只对高度结构化的数据有效，金融市场也是如此。处理非结构化数据或明确呈现关系依赖的数据需要不同的方法。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="0007" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mr">免责声明:此处表达的所有观点和信息均为我个人观点，并不代表我曾经、现在或将隶属或关联的任何实体的观点。</em></p></div></div>    
</body>
</html>