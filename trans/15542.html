<html>
<head>
<title>Anchors Away! More Python Regular Expressions Concepts You Wish You Knew</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">起锚！更多你希望知道的Python正则表达式概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/anchors-away-more-python-regular-expressions-you-wish-you-knew-8a7780ac54e9?source=collection_archive---------32-----------------------#2020-10-26">https://towardsdatascience.com/anchors-away-more-python-regular-expressions-you-wish-you-knew-8a7780ac54e9?source=collection_archive---------32-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="29a0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">教程| Python |正则表达式(Regex)</h2><div class=""/><div class=""><h2 id="9053" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Python中的高级正则表达式工具处理文本的秘密</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/d8bff230fa9389714788b089f9861b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*IL0TaIk5KbB5PNWX4aiv1w.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">作者图片</p></figure><p id="0238" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以你已经知道了Python中正则表达式的基础。像如何使用字符集、元字符、量词和捕获组这样的东西是基本的构建模块，但是你是一个超级用户，永远不会满足于仅仅是基础。你的文本争论问题比你希望用这些工具解决的要复杂得多。幸运的是，Python中有更多的正则表达式概念需要学习。这是更多文本辩论工具的锚！</p><blockquote class="lz ma mb"><p id="2220" class="ld le mc lf b lg lh kd li lj lk kg ll md ln lo lp me lr ls lt mf lv lw lx ly im bi translated">不确定基本的？查看我关于Python中正则表达式(regex)构建块的文章。</p></blockquote><div class="mg mh gp gr mi mj"><a rel="noopener follow" target="_blank" href="/a-gentle-introduction-to-regular-expressions-with-python-4f3fce46dcb4"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">Python正则表达式的简明介绍</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">正则表达式是数据科学家对付非结构化文本最强大的武器</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">towardsdatascience.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kx mj"/></div></div></a></div><h1 id="25db" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">(正文)起锚了！</h1><p id="1f3d" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">在我们开始SS正则表达式之前，我们需要讨论锚。更具体地说，<strong class="lf jd">文本锚</strong>。文本锚表示在字符串的开头或结尾查找匹配。在Python中，有两种类型的锚点:</p><ul class=""><li id="3fc8" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oa ob oc od bi translated"><code class="fe oe of og oh b">^</code>:匹配字符串开头的以下正则表达式</li><li id="bcf7" class="nv nw it lf b lg oi lj oj lm ok lq ol lu om ly oa ob oc od bi translated"><code class="fe oe of og oh b">$</code>:匹配字符串末尾的前一个正则表达式</li></ul><p id="2633" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">提醒一下，要在Python中使用regex，需要导入<code class="fe oe of og oh b">re</code>模块。在尝试新的正则表达式主题(比如锚点)时，<code class="fe oe of og oh b">re.findall()</code>函数特别有用。它将返回一个包含字符串中匹配项实际值的向量的列表。开始之前，请确保加载了<code class="fe oe of og oh b">re</code>模块。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="22b6" class="or mz it oh b gy os ot l ou ov">import re</span></pre><h2 id="8b98" class="or mz it bd na ow ox dn ne oy oz dp ni lm pa pb nk lq pc pd nm lu pe pf no iz bi translated">起锚，<code class="fe oe of og oh b">^</code>起锚</h2><p id="0899" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">要起航，我们必须在旅行开始时起锚。当处理文本数据时，您可能需要匹配一个正则表达式模式，但前提是它出现在字符串中的第一项。为此，我们还使用了一个锚点，具体来说就是<code class="fe oe of og oh b">^</code>。</p><p id="6955" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了演示，我们的目标是找到单词“the”，但前提是它出现在字符串的开头。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="d377" class="or mz it oh b gy os ot l ou ov">anchor = 'The ship set sail on the ocean'<br/>anchor_n = 'Ships set sail on the ocean to go places'</span></pre><p id="b2de" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从<code class="fe oe of og oh b">anchor</code>开始，当我们使用<code class="fe oe of og oh b">^</code>锚查找“the”时，我们只返回了它的一个实例。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="94c0" class="or mz it oh b gy os ot l ou ov">anchor01 = re.findall('^[Tt]he', anchor)<br/>print(anchor01)</span><span id="87be" class="or mz it oh b gy pg ot l ou ov">['The']</span></pre><p id="ebc1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们知道这是第一个实例，因为字符串开头的“the”是大写的。现在用<code class="fe oe of og oh b">anchor_n</code>，不返回任何结果。正则表达式通常匹配句子中的“The ”,但是使用<code class="fe oe of og oh b">^</code>定位符时，它只检查句子的开头。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="0222" class="or mz it oh b gy os ot l ou ov">anchor02 = re.findall('^[Tt]he', anchor_n)<br/>print(anchor02)</span><span id="ad01" class="or mz it oh b gy pg ot l ou ov">[]</span></pre><h2 id="7337" class="or mz it bd na ow ox dn ne oy oz dp ni lm pa pb nk lq pc pd nm lu pe pf no iz bi translated">抛锚，<code class="fe oe of og oh b">$</code>锚</h2><p id="69a5" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">在我们的正则表达式之旅结束时，我们需要放下锚。有时，只有当正则表达式出现在字符串末尾时，才需要匹配它。这是通过<code class="fe oe of og oh b">$</code>锚完成的。</p><p id="a1ee" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们再来看一下<code class="fe oe of og oh b">anchor</code>字符串，这次是在字符串的末尾寻找“海洋”。我们会有一个结果，“海洋。”</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="b17f" class="or mz it oh b gy os ot l ou ov">anchor03 = re.findall('ocean$', anchor)<br/>print(anchor03)</span><span id="0fa4" class="or mz it oh b gy pg ot l ou ov">['ocean']</span></pre><p id="f69c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样，如果我们查看<code class="fe oe of og oh b">anchor_n</code>，这次使用<code class="fe oe of og oh b">$</code>或结束锚，我们将得不到匹配，即使“海洋”出现在字符串中。如果它不在绳子的末端，<code class="fe oe of og oh b">$</code>号锚就不会把它捡起来。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="fd24" class="or mz it oh b gy os ot l ou ov">anchor04 = re.findall('ocean$', anchor_n)<br/>print(anchor04)</span><span id="2145" class="or mz it oh b gy pg ot l ou ov">[]</span></pre><h1 id="4888" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">正则表达式否定(避免冰山)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="pi pj di pk bf pl"><div class="gh gi ph"><img src="../Images/8ea7b75c38bc575a7960cb0cfbc207ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HG7j6J4rz9kD2xvJ"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">安妮·斯普拉特在<a class="ae pm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a7ca" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在我们知道了如何在字符串的开头和结尾匹配字符串(提升和降低SS正则表达式的锚点)，我们可以继续下一个概念:告诉regex匹配什么<strong class="lf jd">不匹配</strong>。</p><p id="00c5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">想象一下，你是一艘大船的船长，这是一艘船的处女航。让我们称这艘船为泰坦尼克号。作为这艘船的船长，你可能更关注于<strong class="lf jd">而不是</strong>撞上冰山，而不是其他任何具体的事情。</p><p id="840a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在字符串中，您可能希望指定某些模式来避免。要做到这一点，使用否定。这些将匹配除了您指定的内容之外的任何内容。在Python中有两种主要的方法来处理它们:</p><ul class=""><li id="77f4" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oa ob oc od bi translated">大写元字符:元字符匹配一组字符。一个大写的元字符通常会匹配除该字符集之外的所有内容</li><li id="965b" class="nv nw it lf b lg oi lj oj lm ok lq ol lu om ly oa ob oc od bi translated"><code class="fe oe of og oh b">^</code>和字符集:使用一个<code class="fe oe of og oh b">^</code>和一个字符集将匹配除了在字符集中指定的以外的所有内容</li></ul><h2 id="0990" class="or mz it bd na ow ox dn ne oy oz dp ni lm pa pb nk lq pc pd nm lu pe pf no iz bi translated">大写元字符</h2><p id="2aa7" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">在我上一篇关于Python中正则表达式的文章中，我们介绍了三种不同的元字符:<code class="fe oe of og oh b">\s</code>、<code class="fe oe of og oh b">\w</code>和<code class="fe oe of og oh b">\d</code>。作为复习，它们匹配字符串中的一组字符:<code class="fe oe of og oh b">\s</code>匹配空白字符(空格、制表符和换行符)，<code class="fe oe of og oh b">\w</code>匹配字母数字字符(字母和数字)，而<code class="fe oe of og oh b">\d</code>匹配任何数字(数字)。</p><p id="ca67" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当您大写这些元字符中的任何一个时，它将匹配除了正常匹配之外的所有内容。要查看它们的运行情况，让我们创建一个包含空格、数字、字母和标点符号的新字符串:</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="0b95" class="or mz it oh b gy os ot l ou ov">negation = 'I sail my 3 ships on the 7 seas.'</span></pre><p id="5028" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，当我们看一看我们的大写元字符时，我们将看到它们的输出是如何变化的。</p><ul class=""><li id="fd6b" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oa ob oc od bi translated">这将匹配除空格之外的任何内容。我们在输出中看到来自<code class="fe oe of og oh b">negation</code>字符串的所有字母、数字和标点符号</li></ul><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="8fc5" class="or mz it oh b gy os ot l ou ov">negation01 = re.findall('\S', negation)<br/>print(negation01)</span><span id="d9c2" class="or mz it oh b gy pg ot l ou ov">['I', 's', 'a', 'i', 'l', 'm', 'y', '3', 's', 'h', 'i', 'p', 's', 'o', 'n', 't', 'h', 'e', '7', 's', 'e', 'a', 's', '.']</span></pre><ul class=""><li id="8d69" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oa ob oc od bi translated"><code class="fe oe of og oh b">\W</code>:这将匹配除了字母和数字以外的任何内容。我们这里的输出是每个空格和句尾的句号</li></ul><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="97c9" class="or mz it oh b gy os ot l ou ov">negation02 = re.findall('\W', negation)<br/>print(negation02)</span><span id="75a1" class="or mz it oh b gy pg ot l ou ov">[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '.']</span></pre><ul class=""><li id="37cf" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oa ob oc od bi translated"><code class="fe oe of og oh b">\D</code>:这将匹配除数字以外的任何内容。您可能已经猜到，输出中有字母、空格和标点符号</li></ul><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="18d8" class="or mz it oh b gy os ot l ou ov">negation03 = re.findall('\D', negation)<br/>print(negation03)</span><span id="ec0e" class="or mz it oh b gy pg ot l ou ov">['I', ' ', 's', 'a', 'i', 'l', ' ', 'm', 'y', ' ', ' ', 's', 'h', 'i', 'p', 's', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', ' ', 's', 'e', 'a', 's', '.']</span></pre><h2 id="6341" class="or mz it bd na ow ox dn ne oy oz dp ni lm pa pb nk lq pc pd nm lu pe pf no iz bi translated"><code class="fe oe of og oh b">^</code>和字符集</h2><p id="a561" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">一些用例需要比元字符更灵活的否定。让我们看一个例子:</p><ul class=""><li id="96c3" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oa ob oc od bi translated">匹配给定字符串中的所有辅音</li></ul><p id="fc83" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们来分解一下这个问题。字母表里有21个辅音，我们想要全部。它们是不连续的，所以我们不能仅仅使用字符集中的一系列字母来得到它们。我们确实知道元音和辅音是互斥的，而且只有5个元音。如果我们能找到所有的元音，我们应该能通过否定得到所有的辅音。让我们从复习如何用字符集查找元音开始。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="93c4" class="or mz it oh b gy os ot l ou ov">negation04 = re.findall('[AEIOUaeiou]', negation)</span><span id="e755" class="or mz it oh b gy pg ot l ou ov">['I', 'a', 'i', 'i', 'o', 'e', 'e', 'a']</span></pre><p id="639d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">括号内的字符定义了字符集。在这种情况下，任何元音都匹配。要获得除元音以外的所有内容，我们可以使用<code class="fe oe of og oh b">^</code>。这将否定字符集内的所有内容。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="a683" class="or mz it oh b gy os ot l ou ov">negation05 = re.findall('[^AEIOUaeiou]', negation)</span><span id="8d3e" class="or mz it oh b gy pg ot l ou ov">[' ', 's', 'l', ' ', 'm', 'y', ' ', '3', ' ', 's', 'h', 'p', 's', ' ', 'n', ' ', 't', 'h', ' ', '7', ' ', 's', 's', '.']</span></pre><p id="37b2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">…但那不是辅音。还有一点工作要做。我们的结果中有空格、数字和标点符号。由于捕获组中的所有内容都被否定，所以我们只需在结果中匹配所有不想要的内容。<code class="fe oe of og oh b">\s</code>负责空格，<code class="fe oe of og oh b">\d</code>负责数字，<code class="fe oe of og oh b">\.</code>负责句点。<code class="fe oe of og oh b">\.</code>不是元字符，是逃期。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="8d39" class="or mz it oh b gy os ot l ou ov">negation06 = re.findall('[^AEIOUaeiou\s\d\.]', negation)</span><span id="d752" class="or mz it oh b gy pg ot l ou ov">['s', 'l', 'm', 'y', 's', 'h', 'p', 's', 'n', 't', 'h', 's', 's']</span></pre><p id="a111" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在所有的字符之后，我们需要以辅音结尾，也许这并不比键入21个不同的辅音更快，但它确实演示了我们如何将所有的字符加在一起，并使用正则表达式来得到我们想要的东西。</p><h1 id="c958" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">环顾四周(观赏野生动物)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="pi pj di pk bf pl"><div class="gh gi pn"><img src="../Images/2eb248d9c24bfe6ea873dbf995365df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UpjDdX5sksU2K-5E"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">马丁·韦特斯坦在<a class="ae pm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2e51" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">出海时，我们可能会留意一些东西。看到一些野生动物将会是一次更有趣的旅行。我们寻找野生动物，这样我们就可以找到一个靠近它的地方来停泊我们的船。作为一名经验丰富的船长，我们并不真正关心野生动物本身，只关心附近的安全空间，以便驾驶船只。</p><p id="d3ff" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">类似于我们想通过野生动物寻找一个停车的地方，我们可能想在一些文本中寻找我们真正想要的信息。如果您现在还没有弄明白，正则表达式可以轻松地处理这个问题。为此，我们使用了一种叫做环视的方法。Look arounds在字符串中搜索特定的匹配项，然后返回它之前或之后的某个值。这给我们留下了两种主要的环视方式:向前看和向后看。</p><p id="e566" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们用下面的字符串作为例子来说明这两者是如何工作的。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="90a9" class="or mz it oh b gy os ot l ou ov">lookaround = 'A penguin costs 2.99, a whale costs 5.99, I only have 3.50 left.'</span></pre><p id="9013" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于我们想从这个字符串中提取什么信息，我们有两个场景。</p><ol class=""><li id="d968" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly po ob oc od bi translated">每只动物的成本是多少？</li><li id="e6eb" class="nv nw it lf b lg oi lj oj lm ok lq ol lu om ly po ob oc od bi translated">卖什么动物？</li></ol><p id="5a43" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">起初，你可能会想为什么我们需要环顾四周才能做到这一点。你可以简单地寻找一个数字，句号，和另外两个数字。大概是这样的:</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="e48d" class="or mz it oh b gy os ot l ou ov">lookaround01 = re.findall('\d\.\d{2}', lookaround)</span></pre><p id="73d8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是一个不错的开始，但是这一行代码的输出会给出三种价格。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="85ef" class="or mz it oh b gy os ot l ou ov">print(lookaround01)</span><span id="7313" class="or mz it oh b gy pg ot l ou ov">[[1]]<br/>[1] "2.99" "5.99" "3.50"</span></pre><p id="6159" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">只有两种动物价格，最后一种是不相关的。环顾四周将有助于我们删除最后一个，并把一切都很好地纳入一个数据框架。</p><h2 id="ad25" class="or mz it bd na ow ox dn ne oy oz dp ni lm pa pb nk lq pc pd nm lu pe pf no iz bi translated">向后看</h2><p id="7652" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">查看<code class="fe oe of og oh b">lookaround</code>字符串，我们看到每种动物的价格前面都有单词“costs”我们将在后面用一个<strong class="lf jd">来看看。这将匹配我们通常匹配的任何内容，但前提是它之前有其他内容的匹配。前瞻的通用公式是<code class="fe oe of og oh b">"(?&lt;=if preceded by this)match_this"</code>。在我们的例子中，这将翻译如下(<code class="fe oe of og oh b">\s</code>被添加以说明单词和数字之间的空间):</strong></p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="2554" class="or mz it oh b gy os ot l ou ov"># Look behind<br/>look_behind = re.findall('(?&lt;=costs)\s\d\.\d{2}', lookaround)</span></pre><p id="5c2b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在我们有了每只动物的价格，不包括我在绳子上剩下的钱。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="be84" class="or mz it oh b gy os ot l ou ov">print(look_behind)</span><span id="f781" class="or mz it oh b gy pg ot l ou ov">[' 2.99', ' 5.99']</span></pre><p id="b19d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你仔细看，你会注意到琴弦上有空隙。现在不要担心这些，当我们建立一个数据框架来保存我们的价目表时，我们会处理这些问题。</p><h2 id="c37f" class="or mz it bd na ow ox dn ne oy oz dp ni lm pa pb nk lq pc pd nm lu pe pf no iz bi translated">向前看</h2><p id="40f0" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">现在，我们已经从字符串中获得了动物的价格，我们希望为价格列表数据框获取动物的名称。</p><p id="daf0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为此，我们现在需要匹配单词“成本”前面的单词。为此，我们将使用<strong class="lf jd">前瞻</strong>。前瞻的基本公式如下:<code class="fe oe of og oh b">"match this(?=if followed by this)"</code>。要从我们的字符串中获取动物名称，应该是这样的:</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="1aa2" class="or mz it oh b gy os ot l ou ov"># Look Ahead<br/>look_ahead = re.findall('\w+\s(?=costs)', lookaround)</span></pre><p id="fb8f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">就这样，我们抓住了单词costs之前的每个单词。在我们的字符串中是所有动物的名字。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="5b18" class="or mz it oh b gy os ot l ou ov">print(look_ahead)</span><span id="0d68" class="or mz it oh b gy pg ot l ou ov">['penguin ', 'whale ']</span></pre><h2 id="0c42" class="or mz it bd na ow ox dn ne oy oz dp ni lm pa pb nk lq pc pd nm lu pe pf no iz bi translated">创建动物价格数据框</h2><p id="7356" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">为了创建动物价格的数据框架，我们已经拥有了大部分我们需要的东西。我们只是用来自<code class="fe oe of og oh b">animals</code>和<code class="fe oe of og oh b">prices</code>的向量作为列创建一个数据帧。当然，要在Python中做到这一点，我们需要首先导入<code class="fe oe of og oh b">pandas</code>模块作为<code class="fe oe of og oh b">pd</code>。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="b856" class="or mz it oh b gy os ot l ou ov">import pandas as pd</span><span id="8925" class="or mz it oh b gy pg ot l ou ov">animal_prices = {'animals': look_ahead, 'prices': look_behind}<br/>animal_prices_df = pd.DataFrame(animal_prices)</span></pre><p id="0d1a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你忘了，当我们使用<code class="fe oe of og oh b">re.findall()</code>时，它返回一个字符串列表。这可以很容易地用于创建字典和数据框。</p><p id="2fbc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的下一步是解决这些多余的空间。我们将使用<code class="fe oe of og oh b">.strip()</code>方法。它移除字符串开头或结尾的空格。我们将使用列表理解在一行代码中为每一列完成这项工作。</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="4175" class="or mz it oh b gy os ot l ou ov">animal_prices_df['animals'] = [animal.strip() for animal in animal_prices_df['animals']]<br/>animal_prices_df['prices'] = [price.strip() for price in animal_prices_df['prices']]</span></pre><p id="c4e3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">生成的数据框如下所示:</p><pre class="ks kt ku kv gt on oh oo op aw oq bi"><span id="1753" class="or mz it oh b gy os ot l ou ov">   animals prices<br/>0  penguin   2.99<br/>1    whale   5.99</span></pre><h1 id="7a46" class="my mz it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">结论和进一步学习</h1><p id="c257" class="pw-post-body-paragraph ld le it lf b lg nq kd li lj nr kg ll lm ns lo lp lq nt ls lt lu nu lw lx ly im bi translated">就这样，你在SS正则表达式上的巡航结束了。你学到了:</p><ol class=""><li id="cce2" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly po ob oc od bi translated">如何匹配出现在字符串开头或结尾的字符串</li><li id="2b04" class="nv nw it lf b lg oi lj oj lm ok lq ol lu om ly po ob oc od bi translated">如何用否定来寻找除了某物以外的任何东西</li><li id="65c7" class="nv nw it lf b lg oi lj oj lm ok lq ol lu om ly po ob oc od bi translated">如何使用look arounds来匹配后面或前面的事物</li></ol><p id="eae2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">以下是与Python中的正则表达式相关的一些其他资源，可能对您有所帮助:</p><ul class=""><li id="f6bf" class="nv nw it lf b lg lh lj lk lm nx lq ny lu nz ly oa ob oc od bi translated"><a class="ae pm" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">官方</a> <code class="fe oe of og oh b"><a class="ae pm" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">re</a></code> <a class="ae pm" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">文档</a>:虽然文档看起来令人生畏，但学习如何阅读它只会在你编程时对你有所帮助</li><li id="9a39" class="nv nw it lf b lg oi lj oj lm ok lq ol lu om ly oa ob oc od bi translated"><a class="ae pm" href="https://www.w3schools.com/python/python_regex.asp" rel="noopener ugc nofollow" target="_blank"> w3schools参考资料</a>:庞大的编码和脚本语言参考资料知识库，包括python。他们的许多例子都可以通过点击“自己尝试”按钮直接在浏览器上运行</li><li id="aea1" class="nv nw it lf b lg oi lj oj lm ok lq ol lu om ly oa ob oc od bi translated"><a class="ae pm" href="https://www.datacamp.com/join-me/ODczNDQ5" rel="noopener ugc nofollow" target="_blank"> Datacamp课程</a>(付费链接):一个致力于数据科学、机器学习和数据可视化的在线学习社区。查看他们的课程“Python中的正则表达式”网站上每门课程的第一章都是免费的！</li></ul><div class="mg mh gp gr mi mj"><a href="https://realdrewdata.medium.com/membership" rel="noopener follow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd jd gy z fp mo fr fs mp fu fw jc bi translated">通过我的推荐链接加入Medium-Drew Seewald</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">realdrewdata.medium.com</p></div></div><div class="ms l"><div class="pp l mu mv mw ms mx kx mj"/></div></div></a></div></div></div>    
</body>
</html>