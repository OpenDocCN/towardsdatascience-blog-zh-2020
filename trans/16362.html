<html>
<head>
<title>Blazing Hot Python AsyncIO Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">炽热的Python AsyncIO管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/blazing-hot-python-asyncio-pipelines-438b34bed9f?source=collection_archive---------24-----------------------#2020-11-11">https://towardsdatascience.com/blazing-hot-python-asyncio-pipelines-438b34bed9f?source=collection_archive---------24-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9bc3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">并发高效地处理大量流水线式web、数据库和微服务请求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/18aa2570f74cc14d42e7403e217f200d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MDWsP2_vym0nah-U"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约书亚·牛顿在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="c09d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于内存高效和可读的代码来说，流水线功能非常强大。在这些函数中，一个函数的输出输入下一个函数的输入。一些示例应用包括:</p><ul class=""><li id="5e41" class="lz ma iq lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">跨越不同但相关的数据源的多级web刮刀</li><li id="f1bd" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">具有数据提取、转换和处理步骤的机器学习管道</li><li id="c201" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">对大数据集进行逐行操作</li></ul><p id="cab7" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">使用Python的<code class="fe mn mo mp mq b">asyncio</code>库进行并发操作既快速又节省资源，尤其是对于IO绑定的任务。</p><p id="da9f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">本文将向您展示如何构建您自己的可以非常高效地运行的管道，尤其是如果您要进行大量的IO操作，如web请求或数据库查询。后续文章将通过提供一个库来抽象出下面显示的大部分底层机制，使之变得更加容易。</p><h1 id="d669" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">同步发电机管道</h1><p id="0cf8" class="pw-post-body-paragraph ld le iq lf b lg nj jr li lj nk ju ll lm nl lo lp lq nm ls lt lu nn lw lx ly ij bi translated">Python生成器有一个<code class="fe mn mo mp mq b">send()</code>方法，可以用来在生成器调用<code class="fe mn mo mp mq b">yield</code>时将数据发送到生成器中。把它放入一个无限循环中，你会在你的管道中得到一个不断等待输入的阶段，用它做一些事情，然后发送到下一个阶段。</p><p id="c77c" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">您可以使用这种基于推送的方法以扇出模式发送到多个其他生成器，因此我们假设我们有一个<code class="fe mn mo mp mq b">target</code>生成器的列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/1bd452c52202d15f138370fda731b321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6lJqITcxUGFazA_b2vWBw.png"/></div></div></figure><p id="9132" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们从生成器函数创建生成器时，我们必须通过发送<code class="fe mn mo mp mq b">None</code>来初始化它。这使得生成器在功能代码中前进，直到遇到第一个<code class="fe mn mo mp mq b">yield</code>语句。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/3113f7e51d62187715c77603690fcae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*SOdBiTf79Sg1TMzU2-0Fcw.png"/></div></figure><p id="b12b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这里有一个完整的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="37cd" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">运行输出:</p><blockquote class="ns nt nu"><p id="52a2" class="ld le nv lf b lg lh jr li lj lk ju ll nw ln lo lp nx lr ls lt ny lv lw lx ly ij bi translated">T2:已初始化参数:你好T2 <br/> T1:已初始化参数:你好T1 <br/> T1:已接收输入:1 <br/> T1: T1发送1 <br/> T2:已接收输入:1 <br/> T1:已接收输入:2 <br/> T1: T1发送2 <br/> T2:已接收输入:2 <br/> T1:已接收输入:3 <br/> T1: T1发送3 <br/> T2:已接收输入:3 <br/>时长:6.01299477</p></blockquote><p id="5415" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="nv">注:</em></p><ul class=""><li id="bd06" class="lz ma iq lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">我们将所有的输入(第20–22行)发送到第一阶段，它会通过管道自动传播</li><li id="b549" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">这都是同步代码。在发送下一个输入之前，第一个输入完全通过。</li><li id="f67c" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">易于使用断点进行调试</li><li id="2dfa" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">我们必须反向构造和链接，因为<code class="fe mn mo mp mq b">gen1</code>(即<code class="fe mn mo mp mq b">gen2</code>)的目标生成器必须存在，才能作为参数传递给gen1的生成器函数。</li></ul><h1 id="1043" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">异步发电机管道</h1><p id="4fa0" class="pw-post-body-paragraph ld le iq lf b lg nj jr li lj nk ju ll lm nl lo lp lq nm ls lt lu nn lw lx ly ij bi translated">我们可以使用同步python生成器等待输入，但是使用协程异步处理输入(由sleep函数模拟)。我们通过将处理和发送代码放在<code class="fe mn mo mp mq b">async def</code>内部函数中来实现这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/a5a766660f0a17cc753c93224974a261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXfAEH4mFlIA7iETAhu-BQ.png"/></div></div></figure><p id="0d43" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在循环中的每一次迭代中，我们都会得到一个输入值，并生成一个asyncio任务。我们在一个全局<code class="fe mn mo mp mq b">tasks</code>列表中跟踪所有产生的任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/4705c394073f1db162e08890711b5b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gnz6fiJKUvYXCbd2XoPIgg.png"/></div></div></figure><p id="8473" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们的主函数也必须是一个运行在事件循环中的协程。这是由<code class="fe mn mo mp mq b">asyncio.run(main())</code>完成的。注意在main中，我们如何使用<code class="fe mn mo mp mq b">async.gather()</code>函数等待所有任务完成。这必须做两次，因为我们分两个阶段提交任务。现在很尴尬。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b311fbbbe82d3024de1804cd74879a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*pK_ZbkBFTdA4EwRwLZSL-g.png"/></div></figure><p id="827e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">完整示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="27ca" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">运行输出:</p><blockquote class="ns nt nu"><p id="d2e4" class="ld le nv lf b lg lh jr li lj lk ju ll nw ln lo lp nx lr ls lt ny lv lw lx ly ij bi translated">T2:用参数初始化:你好T2 <br/> T1:用参数初始化:你好T1 <br/> T1:用T1_inner创建任务，输入1。<br/> T1:使用T1_inner创建任务，输入2。<br/> T1:用T1_inner创建任务，输入3。<br/> T1:接收输入:1 <br/> T1: T1发送1 <br/> T2:用T2_inner创建任务，输入1。<br/> T1:接收输入:2 <br/> T1: T1发送2 <br/> T2:用T2_inner创建任务，输入2。<br/> T1:接收输入:3 <br/> T1: T1发送3 <br/> T2:用T2_inner创建任务，输入3。T2:接收到的输入:1 <br/> T2:接收到的输入:2 <br/> T2:接收到的输入:3 <br/>持续时间:2.00000000001</p></blockquote><p id="8355" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="nv">注</em>:</p><ul class=""><li id="6d73" class="lz ma iq lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated">由于异步睡眠，运行速度更快</li><li id="c4c4" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">需要一个事件循环</li><li id="3bbe" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">很难知道什么时候所有的任务都完成了</li><li id="2deb" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">关于<code class="fe mn mo mp mq b">send</code>函数的竞争条件的一些问题</li></ul><h1 id="240e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">等待救援的队伍</h1><p id="c02f" class="pw-post-body-paragraph ld le iq lf b lg nj jr li lj nk ju ll lm nl lo lp lq nm ls lt lu nn lw lx ly ij bi translated"><code class="fe mn mo mp mq b">asyncio.Queue</code>类也有一个方便的<code class="fe mn mo mp mq b">task_done()</code>方法。队列对象跟踪<code class="fe mn mo mp mq b">get()</code>和<code class="fe mn mo mp mq b">task_done()</code>被调用的次数。如果相同的次数，它假定从队列中取出的所有项目也已经被处理，并且它允许自己被加入(如果队列是空的)。这允许我们按顺序调用<code class="fe mn mo mp mq b">await on</code> <code class="fe mn mo mp mq b">q.join()</code>来了解一个阶段是否完成，并且我们可以避免多次调用<code class="fe mn mo mp mq b">asyncio.gather()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="46de" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">运行输出:</p><blockquote class="ns nt nu"><p id="20ff" class="ld le nv lf b lg lh jr li lj lk ju ll nw ln lo lp nx lr ls lt ny lv lw lx ly ij bi translated">T2:用参数初始化:你好T2 <br/> T1:用参数初始化:你好T1 <br/> T1:用T1_inner创建任务，输入1。<br/> T1:用T1_inner创建任务，输入2。<br/> T1:用T1_inner创建任务，输入3。<br/> T1:接收输入:1 <br/> T1:接收输入:2 <br/> T1:接收输入:3 <br/> T1: T1发送1 <br/> T1: T1发送2 <br/> T1: T1发送3 <br/> T2:用T2 _内创建任务，输入1。<br/> T2:用T2_inner创建任务，输入2。<br/> T2:用T2_inner创建任务，输入3。<br/> T2:已接收输入:1 <br/> T2:已接收输入:2 <br/> T2:已接收输入:3 <br/>持续时间:2.00000000005</p></blockquote><p id="c90d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">注意:</p><ul class=""><li id="493e" class="lz ma iq lf b lg lh lj lk lm mb lq mc lu md ly me mf mg mh bi translated"><code class="fe mn mo mp mq b">input_q.task_done()</code>是调用内部函数的结尾</li><li id="b556" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">我们没有把<code class="fe mn mo mp mq b">send()</code>变成发电机，而是把<code class="fe mn mo mp mq b">put()</code>放在一个队列上</li><li id="6bbe" class="lz ma iq lf b lg mi lj mj lm mk lq ml lu mm ly me mf mg mh bi translated">我们只需要收集一次任务</li></ul><h1 id="84b6" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="e0bc" class="pw-post-body-paragraph ld le iq lf b lg nj jr li lj nk ju ll lm nl lo lp lq nm ls lt lu nn lw lx ly ij bi translated">我们可以通过使用python生成器来创建简单的同步管道。通过交换到asyncio队列和协程，我们可以拥有非常高效的io管道，并保持对我们生成的任务的控制。</p></div></div>    
</body>
</html>