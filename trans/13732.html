<html>
<head>
<title>TensorFlow + Class Inheritance = Beautiful Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow +类继承=漂亮的代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tensorflow-class-inheritance-beautiful-code-59d2eb7cdfce?source=collection_archive---------22-----------------------#2020-09-21">https://towardsdatascience.com/tensorflow-class-inheritance-beautiful-code-59d2eb7cdfce?source=collection_archive---------22-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dfac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用这种方法深入研究更多的技术模型。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20e686388c225966a00b26a9e33893eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tjn3ys9jOqfiVHvp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@danlefeb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹·列斐伏尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="67ab" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简介:</h1><p id="0928" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">学习开发深度学习模型并不是一件容易完成的任务——尤其是对于那些可能在该领域没有丰富经验的人来说。当开始学习如何在TensorFlow中构建DL模型时，工作流程通常如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="23c4" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">但是，如果部署或更多的技术模型出现，这种构建模型的格式可能会对您的时间造成负担，而不是资产。Python的面向对象特性很好地发挥了作用，使它更多地属于后者而不是前者。本教程将分解开发更健壮的模型的工作流程。</p><h1 id="d85e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">继承:</h1><p id="43d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当观察上面的<code class="fe mu mv mw mx b">gist</code>时，我们可以看到我们初始化了<code class="fe mu mv mw mx b">keras.Sequential</code>，它的类类型是<code class="fe mu mv mw mx b">tf.keras.Model</code>。通过添加一个层列表作为<code class="fe mu mv mw mx b">parameter</code>，我们初始化要调用的层——按顺序——用于向前传递。</p><p id="19f3" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">我们可以使用所谓的<code class="fe mu mv mw mx b">class inheritance</code>来构建<a class="ae ky" href="https://www.tensorflow.org/api_docs/python/tf/keras/Model" rel="noopener ugc nofollow" target="_blank">张量流模型</a>。通过继承<code class="fe mu mv mw mx b">tf.keras.Model</code>类，我们可以将我们自己的层合并到模型中，并从那里构建我们的向前传递。</p><p id="9f52" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">对于简单分类的例子，比如上面的例子，这样做可能有点复杂<em class="my">(双关语。考虑到这一点，我仍然会继续上面的模式。如果您理解tensor flow API的基础，那么您将能够看到上面要点中的调用如何转化为开发更多面向对象的代码，这是本文的主要目的。</em></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="e356" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">当继承一个<code class="fe mu mv mw mx b">tf.keras.Model</code>类时，有两个主要步骤需要考虑:</p><ul class=""><li id="345a" class="ng nh it lt b lu mp lx mq ma ni me nj mi nk mm nl nm nn no bi translated">在<code class="fe mu mv mw mx b">__init__</code>内初始化模型中的必要层。</li><li id="2623" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">在<code class="fe mu mv mw mx b">call</code>内订购模型的向前传球。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="0959" class="nu la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">正在初始化类:</h2><p id="1a6f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于<code class="fe mu mv mw mx b">__init__</code>，我们有4个主要步骤。</p><ul class=""><li id="2959" class="ng nh it lt b lu mp lx mq ma ni me nj mi nk mm nl nm nn no bi translated">首先，我们引入<code class="fe mu mv mw mx b">super</code>的<code class="fe mu mv mw mx b">__init__</code>——在本例中是<code class="fe mu mv mw mx b">tf.keras.Model</code>。</li><li id="2d6e" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">其次，我们初始化<code class="fe mu mv mw mx b">Flatten</code>层。</li><li id="7d1a" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">第三，我们用<code class="fe mu mv mw mx b">128</code>单元初始化<code class="fe mu mv mw mx b">Dense</code>层，并激活<code class="fe mu mv mw mx b">tf.nn.relu</code>。值得注意的是，当我们在第一个要点中调用激活函数时，我们使用了一个字符串(<code class="fe mu mv mw mx b">'relu'</code>而不是<code class="fe mu mv mw mx b">tf.nn.relu</code>)。)当构建我们自己的模型类时，我们必须从<code class="fe mu mv mw mx b">tf.nn</code>模块中调用我们的激活函数。</li><li id="0162" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">第四，我们用<code class="fe mu mv mw mx b">10</code>单元初始化最后的<code class="fe mu mv mw mx b">Dense</code>层。</li></ul><p id="e74f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma mr mc md me ms mg mh mi mt mk ml mm im bi translated">为了一致性，<em class="my">总是</em>首先初始化<code class="fe mu mv mw mx b">super</code>的<code class="fe mu mv mw mx b">__init__</code>。这将确保当您在使用中调用该类时，它将作为<code class="fe mu mv mw mx b">tf.keras.Model</code>加载。层的初始化顺序无关紧要。</p><h2 id="ada9" class="nu la it bd lb nv nw dn lf nx ny dp lj ma nz oa ll me ob oc ln mi od oe lp of bi translated">打电话:</h2><p id="d155" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当定义<code class="fe mu mv mw mx b">call</code>时，我们正在定义模型的正向传递。我们有参数<code class="fe mu mv mw mx b">inputs</code>，在拟合时，这些参数将是<code class="fe mu mv mw mx b">x_train</code>。因此，在<code class="fe mu mv mw mx b">call</code>中，它将类似于第一个要点中的层的排序。然而，与层列表相反——并且依赖于<code class="fe mu mv mw mx b">fit</code>来确定向前传递——我们必须明确地确定<code class="fe mu mv mw mx b">x</code>首先进入<code class="fe mu mv mw mx b">Flatten</code>层——也就是<code class="fe mu mv mw mx b">self.flatten</code>,然后将其传递到<code class="fe mu mv mw mx b">self.dense1</code>层，最后输出<code class="fe mu mv mw mx b">self.dense2</code>层的结果。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="fda5" class="kz la it bd lb lc og le lf lg oh li lj jz oi ka ll kc oj kd ln kf ok kg lp lq bi translated">结论:</h1><p id="2669" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">本文应该作为构建更多面向对象代码的通用指南。了解自定义模型的工作流程可以让您在研究中获得更多自由和试验。我希望这篇文章对你有益。</p><blockquote class="ol"><p id="aedb" class="om on it bd oo op oq or os ot ou mm dk translated">感谢您的阅读。</p></blockquote></div></div>    
</body>
</html>