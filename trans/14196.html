<html>
<head>
<title>Introducing Hiveplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hiveplotlib简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-hiveplotlib-31014cefc7ac?source=collection_archive---------32-----------------------#2020-09-30">https://towardsdatascience.com/introducing-hiveplotlib-31014cefc7ac?source=collection_archive---------32-----------------------#2020-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7320" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过蜂巢图在Python中实现更好的网络可视化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80ef1fb760f2a9d1f794167092cd04ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Av5bRPCOKihpk8n_eCrrrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Hiveplotlib是一个新的开源Python包，用于生成蜂巢图。</p></figure><p id="a346" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">介绍<code class="fe lu lv lw lx b">hiveplotlib</code>——一个用于生成蜂巢图的新的开源Python包。<a class="ae ly" href="https://academic.oup.com/bib/article/13/5/627/412507" rel="noopener ugc nofollow" target="_blank">Hive Plots最初是由Martin Krzywinski </a>开发的，它生成定义明确的图形，允许对网络数据进行可解释的可视化探索。</p><p id="3c3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">hiveplotlib</code>库在<a class="ae ly" href="https://gitlab.com/geomdata/hiveplotlib" rel="noopener ugc nofollow" target="_blank"> Gitlab </a>上对所有人可见，其中<a class="ae ly" href="https://geomdata.gitlab.io/hiveplotlib/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>包括对蜂巢图的进一步解释、示例(玩具数据和真实数据)以及完整的代码文档。</p><p id="5dcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Hiveplotlib可以通过<code class="fe lu lv lw lx b">pip</code>安装:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="72b0" class="md me it lx b gy mf mg l mh mi">$ pip install hiveplotlib</span></pre><p id="8994" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，我们只支持基于<code class="fe lu lv lw lx b"><a class="ae ly" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank">matplotlib</a></code>的可视化，但我们计划扩展hiveplotlib，以用于交互式Python viz包，如<code class="fe lu lv lw lx b"><a class="ae ly" href="https://docs.bokeh.org/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">bokeh</a></code>、<code class="fe lu lv lw lx b"><a class="ae ly" href="https://plotly.com/" rel="noopener ugc nofollow" target="_blank">plotly</a></code>和<code class="fe lu lv lw lx b"><a class="ae ly" href="https://holoviews.org/" rel="noopener ugc nofollow" target="_blank">holoviews</a>.</code></p><h1 id="6cdc" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">运行时间</h1><p id="7afb" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated"><code class="fe lu lv lw lx b">hiveplotlib</code>很好地扩展到大型网络数据集。作为对合成数据的演示，让我们构建一个类似于<code class="fe lu lv lw lx b">hiveplotlib</code>标志中的“o”的蜂巢图:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="66ba" class="md me it lx b gy mf mg l mh mi">from hiveplotlib import hive_plot_n_axes, Node<br/>from hiveplotlib.viz import hive_plot_viz_mpl<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="e5ca" class="md me it lx b gy nf mg l mh mi">num_nodes = 20<br/>num_edges = 80</span><span id="da05" class="md me it lx b gy nf mg l mh mi">np.random.seed(0)</span><span id="5f4b" class="md me it lx b gy nf mg l mh mi"><em class="ng"># build node data</em><br/>nodes = []<br/>for i in range(num_nodes):<br/>    temp_node = Node(unique_id=i,<br/>                     data={'a': np.random.uniform(),<br/>                           'b': np.random.uniform(),<br/>                           'c': np.random.uniform()})<br/>    nodes.append(temp_node)</span><span id="6707" class="md me it lx b gy nf mg l mh mi"><em class="ng"># give the nodes simple int IDs</em><br/>node_ids = np.arange(num_nodes)</span><span id="b259" class="md me it lx b gy nf mg l mh mi"><em class="ng"># build random edges</em><br/>edges = np.random.choice(np.arange(num_nodes),<br/>                         size=num_edges*2).reshape(-1, 2)</span><span id="07a3" class="md me it lx b gy nf mg l mh mi"><em class="ng"># construct HivePlot instance, evenly spacing out nodes over 3 axes</em><br/>hp = hive_plot_n_axes(node_list=nodes, edges=edges,<br/>                      axes_assignments=[<br/>                          node_ids[:num_nodes//3],<br/>                          node_ids[num_nodes//3:2*num_nodes//3],<br/>                          node_ids[2*num_nodes//3:]<br/>                      ], sorting_variables=["a", "b", "c"],<br/>                      axes_names=["A", "B", "C"],<br/>                      vmins=[0, 0, 0], vmaxes=[1, 1, 1],<br/>                      orient_angle=-30)</span><span id="6625" class="md me it lx b gy nf mg l mh mi"><em class="ng"># change the line kwargs for edges in plot</em><br/>hp.add_edge_kwargs(axis_id_1="A", axis_id_2="B",<br/>                   c=f"C0", lw=3, alpha=1, zorder=1.5)<br/>hp.add_edge_kwargs(axis_id_1="B", axis_id_2="C",<br/>                   c=f"C2", lw=3, alpha=1, zorder=1.5)<br/>hp.add_edge_kwargs(axis_id_1="A", axis_id_2="C",<br/>                   c=f"C1", lw=3, alpha=1, zorder=1.5)</span><span id="e533" class="md me it lx b gy nf mg l mh mi">fig, ax = hive_plot_viz_mpl(hive_plot=hp)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c29f8e86e84c917fdfb8dee69493b036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*CwSZ-7FJhqlsGJEaik0CYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用hiveplotlib生成的蜂巢图的合成示例。</p></figure><p id="d57c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码(减去导入语句)在笔记本电脑上运行大约需要200毫秒。如果我们只将上面的代码更改为<code class="fe lu lv lw lx b">num_nodes = 10000</code>和<code class="fe lu lv lw lx b">num_edges = 10000</code>，运行时间会增加大约1秒。100，000个节点和边在大约10秒内运行。</p><h1 id="5c5c" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">数据输入</h1><p id="f2a2" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">为了使用hiveplotlib，我们需要争论两个数据源，<strong class="la iu">节点</strong>和<strong class="la iu">边</strong>。</p><h2 id="1c8f" class="md me it bd mk ni nj dn mo nk nl dp ms lh nm nn mu ll no np mw lp nq nr my ns bi translated">节点</h2><p id="dcde" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">在我们的框架中设置一个节点只需要一个数据字典和一个unique_id。这对于来自数据库查询的任何<code class="fe lu lv lw lx b">json</code>输出(例如，通过<code class="fe lu lv lw lx b">pymongo</code>来自Mongo数据库的查询)来说都是非常好的。<code class="fe lu lv lw lx b">pandas</code>数据帧也可以通过<code class="fe lu lv lw lx b">df.to_dict(orient="records")</code>轻松转换成这种格式。</p><h2 id="82c3" class="md me it bd mk ni nj dn mo nk nl dp ms lh nm nn mu ll no np mw lp nq nr my ns bi translated">优势</h2><p id="8c79" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">边存储为一个<code class="fe lu lv lw lx b">(n, 2) numpy.ndarray</code>，其中边(如果有方向)从第一列移动<em class="ng">到第二列<em class="ng">。</em></em></p><p id="fac1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了用真实数据演示代码，让我们看一个小而流行的例子:Zachary的空手道俱乐部。</p><h1 id="d3b7" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">一个例子:扎卡里的空手道俱乐部</h1><p id="e47f" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">从1970年到1972年，韦恩·w·扎卡里观察到一个空手道俱乐部分裂成两个派别，一派支持俱乐部主席，被称为“约翰·A”，另一派支持一名教练，被称为“嗨先生”最终，这两个派别正式分裂成两个俱乐部。</p><p id="3e1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个经常使用的数据集包含34个俱乐部成员(节点)和一个记录，记录了在俱乐部正式分裂之前谁与谁在班级之外交往(边缘)。</p><p id="3bed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们首先将以下工作的所有导入放在一个地方:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="ce3c" class="md me it lx b gy mf mg l mh mi"><strong class="lx iu">from</strong> <strong class="lx iu">hiveplotlib</strong> <strong class="lx iu">import</strong> Axis, Node, HivePlot<br/><strong class="lx iu">from</strong> <strong class="lx iu">hiveplotlib.viz</strong> <strong class="lx iu">import</strong> axes_viz_mpl, node_viz_mpl, edge_viz_mpl<br/><strong class="lx iu">from</strong> <strong class="lx iu">matplotlib.lines</strong> <strong class="lx iu">import</strong> Line2D<br/><strong class="lx iu">import</strong> <strong class="lx iu">matplotlib.pyplot</strong> <strong class="lx iu">as</strong> <strong class="lx iu">plt</strong><br/><strong class="lx iu">import</strong> <strong class="lx iu">networkx</strong> <strong class="lx iu">as</strong> <strong class="lx iu">nx</strong><br/><strong class="lx iu">import</strong> <strong class="lx iu">numpy</strong> <strong class="lx iu">as</strong> <strong class="lx iu">np</strong></span><span id="0bb7" class="md me it lx b gy nf mg l mh mi"># if you're in a jupyter notebook<br/>%matplotlib inline</span></pre><p id="f353" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过<code class="fe lu lv lw lx b">networkx</code>抓取空手道俱乐部数据集很方便:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="7f96" class="md me it lx b gy mf mg l mh mi">G = nx.karate_club_graph()</span></pre><p id="332a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个网络的可视化——在最初的论文<code class="fe lu lv lw lx b"><a class="ae ly" href="https://networkx.github.io/documentation/stable/auto_examples/graph/plot_karate_club.html" rel="noopener ugc nofollow" target="_blank">networkx</a></code>，甚至<a class="ae ly" href="https://en.wikipedia.org/wiki/Zachary%27s_karate_club" rel="noopener ugc nofollow" target="_blank">维基百科</a>——总是用一个圆形图来完成，所以让我们以此为起点:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="bb37" class="md me it lx b gy mf mg l mh mi"><em class="ng"># color the nodes by faction</em><br/>color = []<br/><strong class="lx iu">for</strong> node <strong class="lx iu">in</strong> G.nodes():<br/>    <strong class="lx iu">if</strong> G.nodes.data()[node]['club'] == "Mr. Hi":<br/>        color.append("C0")<br/>    <strong class="lx iu">else</strong>:<br/>        color.append("C1")<br/><br/>fig, ax = plt.subplots(figsize=(10, 10))<br/>plt.axis("equal")<br/>nx.draw_circular(G, with_labels=<strong class="lx iu">True</strong>, node_color=color, ax=ax, node_size=1000)<br/>ax.set_title("Zachary's Karate Club<strong class="lx iu">\n</strong>Circular Network Plot", fontsize=20)<br/><br/><em class="ng"># legend</em><br/>john_a_legend = Line2D([], [], markerfacecolor="C1", markeredgecolor='C1',<br/>                       marker='o', linestyle='None', markersize=10)<br/><br/>mr_hi_legend = Line2D([], [], markerfacecolor="C0", markeredgecolor='C0',<br/>                       marker='o', linestyle='None', markersize=10)<br/><br/>ax.legend([mr_hi_legend, john_a_legend],<br/>          ["Mr. Hi", "John A."],<br/>          loc='upper left', bbox_to_anchor=(1, 1), title="Faction")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/082a2d8a879f61e4d45a2a0dca754fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*GuLIW1dN3RgmZBRtXTXARg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扎卡里空手道俱乐部的环形网络图</p></figure><h2 id="0a08" class="md me it bd mk ni nj dn mo nk nl dp ms lh nm nn mu ll no np mw lp nq nr my ns bi translated">从循环图得出的结论</h2><p id="502c" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">从这张图表中可以得出一个清晰而不令人惊讶的结论，那就是Hi先生(node <code class="fe lu lv lw lx b">0</code>)和John A. (node <code class="fe lu lv lw lx b">33</code>)很受欢迎，但很难得出更多其他结论。</p><p id="8721" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用大约10秒钟的时间看上面的图，然后问自己以下问题:</p><blockquote class="nu nv nw"><p id="4dcf" class="ky kz ng la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi translated">这两个派别在社会上的分离程度如何？确认蓝色和橙色之间存在联系需要多长时间？</p><p id="511a" class="ky kz ng la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi translated">这两个群体之间的联系是来自一般更社会化的人吗？</p></blockquote><p id="c745" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要回答第一个问题，我们当然可以更小心地在我们的图中排序这些节点，将橙色与蓝色分开，但第二个问题仍然很难。</p><h2 id="8d8d" class="md me it bd mk ni nj dn mo nk nl dp ms lh nm nn mu ll no np mw lp nq nr my ns bi translated">设计蜂巢图</h2><p id="db96" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">蜂巢图允许我们仔细选择放置节点的轴以及如何在这些轴上对齐节点。</p><p id="7ff1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，有许多必要的声明，但有一个更易解释的网络可视化的回报。</p><p id="573f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了回答上述问题，我们将按照以下方式构建蜂巢图:</p><ul class=""><li id="d1b3" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">我们将总共构建<em class="ng"> 4 </em> <em class="ng">轴——</em>2轴用于约翰a派，2轴用于嗨先生派。使用<em class="ng">重复轴</em>可以让我们在结果可视化中以明确定义的方式看到<em class="ng">内部</em>派系的行为。</li><li id="8a70" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">我们将查看<em class="ng"> 3组边缘</em> —约翰a .派系内的边缘、嗨先生派系内的边缘以及两个派系之间的边缘。这就给了我们上面第一个问题一个明确的答案。</li><li id="ef0c" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">我们将按照<em class="ng">节点度</em>为每个阵营排序一个轴。这让我们可以很好地回答上面的第二个问题，稍后会有更多的内容。</li></ul><p id="7970" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们首先计算所有节点的度，同时为hiveplotlib构建必要的数据结构:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="f852" class="md me it lx b gy mf mg l mh mi">edges = np.array(G.edges)<br/><br/><em class="ng"># pull out degree information from nodes for later use</em><br/>node_ids, degrees = np.unique(edges, return_counts=<strong class="lx iu">True</strong>)<br/><br/>nodes = []<br/><strong class="lx iu">for</strong> node_id, degree <strong class="lx iu">in</strong> zip(node_ids, degrees):<br/>    <em class="ng"># store the index number as a way to align the nodes on axes</em><br/>    G.nodes.data()[node_id]['loc'] = node_id<br/>    <em class="ng"># also store the degree of each node as another way to<br/>    #  align nodes on axes</em><br/>    G.nodes.data()[node_id]['degree'] = degree<br/>    temp_node = Node(unique_id=node_id,<br/>                     data=G.nodes.data()[node_id])<br/>    nodes.append(temp_node)</span></pre><p id="144b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来是<code class="fe lu lv lw lx b">hiveplotlib</code>组件。让我们构建一个<code class="fe lu lv lw lx b">HivePlot()</code>实例:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="b772" class="md me it lx b gy mf mg l mh mi">karate_hp = HivePlot()<br/><br/><em class="ng">### nodes ###</em><br/><br/>karate_hp.add_nodes(nodes)<br/><br/><em class="ng">### axes ###</em><br/><br/>axis0 = Axis(axis_id="hi_id", start=1, end=5, angle=-30,<br/>             long_name="Mr. Hi Faction<strong class="lx iu">\n</strong>(Sorted by ID)")<br/>axis1 = Axis(axis_id="hi_degree", start=1, end=5, angle=30,<br/>             long_name="Mr. Hi Faction<strong class="lx iu">\n</strong>(Sorted by Degree)")<br/>axis2 = Axis(axis_id="john_degree", start=1, end=5, angle=180 - 30,<br/>             long_name="John A. Faction<strong class="lx iu">\n</strong>(Sorted by Degree)")<br/>axis3 = Axis(axis_id="john_id", start=1, end=5, angle=180 + 30,<br/>             long_name="John A. Faction<strong class="lx iu">\n</strong>(Sorted by ID)")<br/><br/>axes = [axis0, axis1, axis2, axis3]<br/><br/>karate_hp.add_axes(axes)<br/><br/><em class="ng">### node assignments ###</em><br/><br/><em class="ng"># partition the nodes into "Mr. Hi" nodes and "John A." nodes</em><br/>hi_nodes = [node.unique_id <strong class="lx iu">for</strong> node <strong class="lx iu">in</strong> nodes<br/>            <strong class="lx iu">if</strong> node.data['club'] == "Mr. Hi"]<br/>john_a_nodes = [node.unique_id <strong class="lx iu">for</strong> node <strong class="lx iu">in</strong> nodes<br/>                <strong class="lx iu">if</strong> node.data['club'] == "Officer"]<br/><br/><em class="ng"># assign nodes and sorting procedure to position nodes on axis</em><br/>karate_hp.place_nodes_on_axis(axis_id="hi_id", unique_ids=hi_nodes,<br/>                              sorting_feature_to_use="loc",<br/>                              vmin=0, vmax=33)<br/>karate_hp.place_nodes_on_axis(axis_id="hi_degree", <br/>                              unique_ids=hi_nodes,<br/>                              sorting_feature_to_use="degree",<br/>                              vmin=0, vmax=17)<br/>karate_hp.place_nodes_on_axis(axis_id="john_degree",<br/>                              unique_ids=john_a_nodes,<br/>                              sorting_feature_to_use="degree",<br/>                              vmin=0, vmax=17)<br/>karate_hp.place_nodes_on_axis(axis_id="john_id",<br/>                              unique_ids=john_a_nodes,<br/>                              sorting_feature_to_use="loc",<br/>                              vmin=0, vmax=33)<br/><br/><em class="ng">### edges ###</em><br/><br/>karate_hp.connect_axes(edges=edges, axis_id_1="hi_degree",<br/>                       axis_id_2="hi_id", c="C0")<br/>karate_hp.connect_axes(edges=edges, axis_id_1="john_degree",<br/>                       axis_id_2="john_id", c="C1")<br/>karate_hp.connect_axes(edges=edges, axis_id_1="hi_degree",<br/>                       axis_id_2="john_degree", c="C2")</span></pre><p id="3abc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为<code class="fe lu lv lw lx b">hiveplotlib</code>可视化的扩展，我们还将拉出John A .和Mr. Hi节点位置，在最终图形中用不同的颜色绘制它们。</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="826f" class="md me it lx b gy mf mg l mh mi"><em class="ng"># pull out the location of the John A. and Mr. Hi nodes<br/>#  for visual emphasis later</em><br/>john_a_degree_locations = \<br/>    karate_hp.axes["john_degree"].node_placements<br/>john_a_node = \<br/>    john_a_degree_locations\<br/>        .loc[john_a_degree_locations.loc[:, 'unique_id'] == 33,<br/>             ['x', 'y']].values.flatten()<br/><br/>mr_hi_degree_locations = \<br/>    karate_hp.axes["hi_degree"].node_placements<br/>mr_hi_node = \<br/>    mr_hi_degree_locations\<br/>        .loc[mr_hi_degree_locations.loc[:, 'unique_id'] == 0,<br/>             ['x', 'y']].values.flatten()</span></pre><h2 id="1842" class="md me it bd mk ni nj dn mo nk nl dp ms lh nm nn mu ll no np mw lp nq nr my ns bi translated">测绘</h2><p id="8af5" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们现在准备绘图:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="30d6" class="md me it lx b gy mf mg l mh mi"><em class="ng"># plot axes</em><br/>fig, ax = axes_viz_mpl(karate_hp,<br/>                       axes_labels_buffer=1.4)</span><span id="6d5b" class="md me it lx b gy nf mg l mh mi"><em class="ng"># plot nodes</em><br/>node_viz_mpl(karate_hp,<br/>             fig=fig, ax=ax, s=80, c="black")</span><span id="45ad" class="md me it lx b gy nf mg l mh mi"><em class="ng"># plot edges</em><br/>edge_viz_mpl(hive_plot=karate_hp, fig=fig, ax=ax, alpha=0.7,<br/>             zorder=-1)<br/>    <br/>ax.set_title("Zachary’s Karate Club\nHive Plot", fontsize=20, y=0.9)</span></pre><p id="9f45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还将为Hi先生和John A .添加一个突出显示节点，以及一个自定义图例以供参考，所有这些都使用标准的<code class="fe lu lv lw lx b">matplotlib</code>:</p><pre class="kj kk kl km gt lz lx ma mb aw mc bi"><span id="847b" class="md me it lx b gy mf mg l mh mi"><em class="ng"># highlight Mr. Hi and John. A on the degree axes</em><br/>ax.scatter(john_a_node[0], john_a_node[1],<br/>           facecolor="red", edgecolor="black", s=150, lw=2)<br/>ax.scatter(mr_hi_node[0], mr_hi_node[1],<br/>           facecolor="yellow", edgecolor="black", s=150, lw=2)</span><span id="33e5" class="md me it lx b gy nf mg l mh mi">### legend ###</span><span id="f8a0" class="md me it lx b gy nf mg l mh mi"><em class="ng"># edges</em><br/>custom_lines = [Line2D([0], [0], color=f'C{i}', lw=3, linestyle='-')<br/>                <strong class="lx iu">for</strong> i <strong class="lx iu">in</strong> range(3)]<br/><br/><em class="ng"># John A. and Mr. Hi nodes</em><br/>john_a_legend = Line2D([], [], markerfacecolor="red", <br/>                       markeredgecolor='black',<br/>                       marker='o', linestyle='None', markersize=10)<br/>custom_lines.append(john_a_legend)<br/><br/>mr_hi_legend = Line2D([], [], markerfacecolor="yellow",<br/>                      markeredgecolor='black',<br/>                      marker='o', linestyle='None', markersize=10)<br/>custom_lines.append(mr_hi_legend)<br/><br/>ax.legend(custom_lines, ["Within Mr. Hi Faction",<br/>                         "Within John A. Faction",<br/>                         "Between Factions",<br/>                         "John A.",<br/>                         "Mr. Hi"],<br/>          loc='upper left', bbox_to_anchor=(0.37, 0.35),<br/>          title="Social Connections")<br/><br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/189951b494e6581de326ca1d93995b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zmnCVmXXHTp0u1HNFXJQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Zachary的空手道俱乐部用hiveplotlib包可视化为一个蜂巢图。</p></figure><h2 id="2264" class="md me it bd mk ni nj dn mo nk nl dp ms lh nm nn mu ll no np mw lp nq nr my ns bi translated">蜂巢图的结论</h2><p id="fef8" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">让我们重温一下之前的问题:</p><blockquote class="nu nv nw"><p id="fa36" class="ky kz ng la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi translated">这两个派别在社会上的分离程度如何？确认蓝色和橙色之间存在联系需要多长时间？</p></blockquote><p id="8d35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这个图来看，派系内部的联系似乎比派系之间的联系多得多，但是我们可以清楚地看到绿色的派系之间的联系。</p><blockquote class="nu nv nw"><p id="2410" class="ky kz ng la b lb lc ju ld le lf jx lg nx li lj lk ny lm ln lo nz lq lr ls lt im bi translated">这两个群体之间的联系是来自更普遍的社会性的人吗？</p></blockquote><p id="8db4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">派系间的联系和一般的社交能力之间似乎没有特别强的相关性。否则，只会在每个度数轴上较高的节点之间有绿色连接。</p><p id="1213" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与圆形布局相比，生成这种蜂巢图可视化的设置成本当然更高——我们必须做出轴和排序决策。</p><p id="f9de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，作为回报，我们可以生成明确的可视化，作为回答真正的研究问题的第一步。</p><h1 id="a6ef" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">Hiveplotlib后续步骤</h1><p id="289c" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们很高兴能继续开发这个项目。我们计划的后续步骤包括但不限于:</p><ul class=""><li id="ecd0" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">扩展包以使用交互式Python可视化包。</li><li id="cb6d" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">扩展排序过程(通过单调函数进行缩放，对分类数据进行排序)。</li><li id="8082" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">在结果可视化中操纵单个边权重。</li><li id="8215" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">“分箱蜂巢图”——绘制边上节点分箱之间的连接，而不是单个节点到节点的边。</li></ul><h1 id="4ab6" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">承认</h1><p id="5dd5" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">感谢<a class="ae ly" href="https://geomdata.com/" rel="noopener ugc nofollow" target="_blank">几何数据分析</a>对该项目的开发和开源的支持。</p><p id="bc4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还要感谢罗德里格·加西亚-埃雷拉对<code class="fe lu lv lw lx b"><a class="ae ly" href="https://gitlab.com/rgarcia-herrera/pyveplot" rel="noopener ugc nofollow" target="_blank">pyveplot</a></code>所做的工作，我们将其作为结构设计的起点。我们还翻译了他的一些实用方法用于这个资源库。</p><h1 id="6d08" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">更多资源</h1><ul class=""><li id="7676" class="oa ob it la b lb na le nb lh op ll oq lp or lt of og oh oi bi translated">我们的文件可以在<a class="ae ly" href="https://geomdata.gitlab.io/hiveplotlib/index.html" rel="noopener ugc nofollow" target="_blank">https://geomdata.gitlab.io/hiveplotlib/index.html</a>找到</li><li id="5fba" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">Hiveplotlib Gitlab库:<a class="ae ly" href="https://gitlab.com/geomdata/hiveplotlib" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/geomdata/hiveplotlib</a></li><li id="c2e0" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">https://pypi.org/project/hiveplotlib/</li><li id="d91b" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">蜂巢地块的另一个优秀资源:<a class="ae ly" href="http://www.hiveplot.com/" rel="noopener ugc nofollow" target="_blank">http://www.hiveplot.com/</a></li><li id="336e" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">如果你正在寻找网络数据，斯坦福大学的大型网络数据集集合是一个很好的资源:<a class="ae ly" href="https://snap.stanford.edu/data/" rel="noopener ugc nofollow" target="_blank">https://snap.stanford.edu/data/</a></li></ul><h1 id="022a" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">参考</h1><p id="21b1" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">Krzywinski M，Birol I，Jones S，Marra M (2011年)。蜂巢图——可视化网络的理性方法。生物信息学简报(2011年12月9日，doi: 10.1093/bib/bbr069)。</p><p id="178e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">扎卡里W. (1977)。小团体中冲突和分裂的信息流模型。人类学研究杂志，33，452–473。</p></div></div>    
</body>
</html>